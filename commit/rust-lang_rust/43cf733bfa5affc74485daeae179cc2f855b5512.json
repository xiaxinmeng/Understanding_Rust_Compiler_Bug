{"sha": "43cf733bfa5affc74485daeae179cc2f855b5512", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzY2Y3MzNiZmE1YWZmYzc0NDg1ZGFlYWUxNzljYzJmODU1YjU1MTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-20T00:31:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-20T00:31:55Z"}, "message": "Auto merge of #25350 - alexcrichton:msvc, r=brson\n\nSpecial thanks to @retep998 for the [excellent writeup](https://github.com/rust-lang/rfcs/issues/1061) of tasks to be done and @ricky26 for initially blazing the trail here!\r\n\r\n# MSVC Support\r\n\r\nThis goal of this series of commits is to add MSVC support to the Rust compiler\r\nand build system, allowing it more easily interoperate with Visual Studio\r\ninstallations and native libraries compiled outside of MinGW.\r\n\r\nThe tl;dr; of this change is that there is a new target of the compiler,\r\n`x86_64-pc-windows-msvc`, which will not interact with the MinGW toolchain at\r\nall and will instead use `link.exe` to assemble output artifacts.\r\n\r\n## Why try to use MSVC?\r\n\r\nWith today's Rust distribution, when you install a compiler on Windows you also\r\ninstall `gcc.exe` and a number of supporting libraries by default (this can be\r\nopted out of). This allows installations to remain independent of MinGW\r\ninstallations, but it still generally requires native code to be linked with\r\nMinGW instead of MSVC. Some more background can also be found in #1768 about the\r\nincompatibilities between MinGW and MSVC.\r\n\r\nOverall the current installation strategy is quite nice so long as you don't\r\ninteract with native code, but once you do the usage of a MinGW-based `gcc.exe`\r\nstarts to get quite painful.\r\n\r\nRelying on a nonstandard Windows toolchain has also been a long-standing \"code\r\nsmell\" of Rust and has been slated for remedy for quite some time now. Using a\r\nstandard toolchain is a great motivational factor for improving the\r\ninteroperability of Rust code with the native system.\r\n\r\n## What does it mean to use MSVC?\r\n\r\n\"Using MSVC\" can be a bit of a nebulous concept, but this PR defines it as:\r\n\r\n* The build system for Rust will build as much code as possible with the MSVC\r\n  compiler, `cl.exe`.\r\n* The build system will use native MSVC tools for managing archives.\r\n* The compiler will link all output with `link.exe` instead of `gcc.exe`.\r\n\r\nNone of these are currently implemented today, but all are required for the\r\ncompiler to fluently interoperate with MSVC.\r\n\r\n## How does this all work?\r\n\r\nAt the highest level, this PR adds a new target triple to the Rust compiler:\r\n\r\n    x86_64-pc-windows-msvc\r\n\r\nAll logic for using MSVC or not is scoped within this triple and code can\r\nconditionally build for MSVC or MinGW via:\r\n\r\n    #[cfg(target_env = \"msvc\")]\r\n\r\nIt is expected that auto builders will be set up for MSVC-based compiles in\r\naddition to the existing MinGW-based compiles, and we will likely soon start\r\nshipping MSVC nightlies where `x86_64-pc-windows-msvc` is the host target triple\r\nof the compiler.\r\n\r\n# Summary of changes\r\n\r\nHere I'll explain at a high level what many of the changes made were targeted\r\nat, but many more details can be found in the commits themselves. Many thanks to\r\n@retep998 for the excellent writeup in rust-lang/rfcs#1061 and @rick26 for a lot\r\nof the initial proof-of-concept work!\r\n\r\n## Build system changes\r\n\r\nAs is probably expected, a large chunk of this PR is changes to Rust's build\r\nsystem to build with MSVC. At a high level **it is an explicit non goal** to\r\nenable building outside of a MinGW shell, instead all Makefile infrastructure we\r\nhave today is retrofitted with support to use MSVC instead of the standard MSVC\r\ntoolchain. Some of the high-level changes are:\r\n\r\n* The configure script now detects when MSVC is being targeted and adds a number\r\n  of additional requirements about the build environment:\r\n  * The `--msvc-root` option must be specified or `cl.exe` must be in PATH to\r\n    discover where MSVC is installed. The compiler in use is also required to\r\n    target x86_64.\r\n  * Once the MSVC root is known, the INCLUDE/LIB environment variables are\r\n    scraped so they can be reexported by the build system.\r\n  * CMake is required to build LLVM with MSVC (and LLVM is also configured with\r\n    CMake instead of the normal configure script).\r\n  * jemalloc is currently unconditionally disabled for MSVC targets as jemalloc\r\n    isn't a hard requirement and I don't know how to build it with MSVC.\r\n* Invocations of a C and/or C++ compiler are now abstracted behind macros to\r\n  appropriately call the underlying compiler with the correct format of\r\n  arguments, for example there is now a macro for \"assemble an archive from\r\n  objects\" instead of hard-coded invocations of `$(AR) crus liboutput.a ...`\r\n* The output filenames for standard libraries such as morestack/compiler-rt are\r\n  now \"more correct\" on windows as they are shipped as `foo.lib` instead of\r\n  `libfoo.a`.\r\n* Rust targets can now depend on native tools provided by LLVM, and as you'll\r\n  see in the commits the entire MSVC target depends on `llvm-ar.exe`.\r\n* Support for custom arbitrary makefile dependencies of Rust targets has been\r\n  added. The MSVC target for `rustc_llvm` currently requires a custom `.DEF`\r\n  file to be passed to the linker to get further linkages to complete.\r\n\r\n## Compiler changes\r\n\r\nThe modifications made to the compiler have so far largely been minor tweaks\r\nhere and there, mostly just adding a layer of abstraction over whether MSVC or a\r\nGNU-like linker is being used. At a high-level these changes are:\r\n\r\n* The section name for metadata storage in dynamic libraries is called `.rustc`\r\n  for MSVC-based platorms as section names cannot contain more than 8\r\n  characters.\r\n* The implementation of `rustc_back::Archive` was refactored, but the\r\n  functionality has remained the same.\r\n* Targets can now specify the default `ar` utility to use, and for MSVC this\r\n  defaults to `llvm-ar.exe`\r\n* The building of the linker command in `rustc_trans::back::link` has been\r\n  abstracted behind a trait for the same code path to be used between GNU and\r\n  MSVC linkers.\r\n\r\n## Standard library changes\r\n\r\nOnly a few small changes were required to the stadnard library itself, and only\r\nfor minor differences between the C runtime of msvcrt.dll and MinGW's libc.a\r\n\r\n* Some function names for floating point functions have leading underscores, and\r\n  some are not present at all.\r\n* Linkage to the `advapi32` library for crypto-related functions is now\r\n  explicit.\r\n* Some small bits of C code here and there were fixed for compatibility with\r\n  MSVC's cl.exe compiler.\r\n\r\n# Future Work\r\n\r\nThis commit is not yet a 100% complete port to using MSVC as there are still\r\nsome key components missing as well as some unimplemented optimizations. This PR\r\nis already getting large enough that I wanted to draw the line here, but here's\r\na list of what is not implemented in this PR, on purpose:\r\n\r\n## Unwinding\r\n\r\nThe revision of our LLVM submodule [does not seem to implement][llvm] does not\r\nsupport lowering SEH exception handling on the Windows MSVC targets, so\r\nunwinding support is not currently implemented for the standard library (it's\r\nlowered to an abort).\r\n\r\n[llvm]: https://github.com/rust-lang/llvm/blob/rust-llvm-2015-02-19/lib/CodeGen/Passes.cpp#L454-L461\r\n\r\nIt looks like, however, that upstream LLVM has quite a bit more support for SEH\r\nunwinding and landing pads than the current revision we have, so adding support\r\nwill likely just involve updating LLVM and then adding some shims of our own\r\nhere and there.\r\n\r\n## dllimport and dllexport\r\n\r\nAn interesting part of Windows which MSVC forces our hand on (and apparently\r\nMinGW didn't) is the usage of `dllimport` and `dllexport` attributes in LLVM IR\r\nas well as native dependencies (in C these correspond to\r\n`__declspec(dllimport)`).\r\n\r\nWhenever a dynamic library is built by MSVC it must have its public interface\r\nspecified by functions tagged with `dllexport` or otherwise they're not\r\navailable to be linked against. This poses a few problems for the compiler, some\r\nof which are somewhat fundamental, but this commit alters the compiler to attach\r\nthe `dllexport` attribute to all LLVM functions that are reachable (e.g. they're\r\nalready tagged with external linkage). This is suboptimal for a few reasons:\r\n\r\n* If an object file will never be included in a dynamic library, there's no need\r\n  to attach the dllexport attribute. Most object files in Rust are not destined\r\n  to become part of a dll as binaries are statically linked by default.\r\n* If the compiler is emitting both an rlib and a dylib, the same source object\r\n  file is currently used but with MSVC this may be less feasible. The compiler\r\n  may be able to get around this, but it may involve some invasive changes to\r\n  deal with this.\r\n\r\nThe flipside of this situation is that whenever you link to a dll and you import\r\na function from it, the import should be tagged with `dllimport`. At this time,\r\nhowever, the compiler does not emit `dllimport` for any declarations other than\r\nconstants (where it is required), which is again suboptimal for even more\r\nreasons!\r\n\r\n* Calling a function imported from another dll without using `dllimport` causes\r\n  the linker/compiler to have extra overhead (one `jmp` instruction on x86) when\r\n  calling the function.\r\n* The same object file may be used in different circumstances, so a function may\r\n  be imported from a dll if the object is linked into a dll, but it may be\r\n  just linked against if linked into an rlib.\r\n* The compiler has no knowledge about whether native functions should be tagged\r\n  dllimport or not.\r\n\r\nFor now the compiler takes the perf hit (I do not have any numbers to this\r\neffect) by marking very little as `dllimport` and praying the linker will take\r\ncare of everything. Fixing this problem will likely require adding a few\r\nattributes to Rust itself (feature gated at the start) and then strongly\r\nrecommending static linkage on Windows! This may also involve shipping a\r\nstatically linked compiler on Windows instead of a dynamically linked compiler,\r\nbut these sorts of changes are pretty invasive and aren't part of this PR.\r\n\r\n## CI integration\r\n\r\nThankfully we don't need to set up a new snapshot bot for the changes made here as our snapshots are freestanding already, we should be able to use the same snapshot to bootstrap both MinGW and MSVC compilers (once a new snapshot is made from these changes).\r\n\r\nI plan on setting up a new suite of auto bots which are testing MSVC configurations for now as well, for now they'll just be bootstrapping and not running tests, but once unwinding is implemented they'll start running all tests as well and we'll eventually start gating on them as well.\r\n\r\n---\r\n\r\nI'd love as many eyes on this as we've got as this was one of my first interactions with MSVC and Visual Studio, so there may be glaring holes that I'm missing here and there!\r\n\r\ncc @retep998, @ricky26, @vadimcn, @klutzy \r\n\r\nr? @brson", "tree": {"sha": "de08f6fe265dd327ffd6c3bc27167d7c6807d0b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de08f6fe265dd327ffd6c3bc27167d7c6807d0b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43cf733bfa5affc74485daeae179cc2f855b5512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43cf733bfa5affc74485daeae179cc2f855b5512", "html_url": "https://github.com/rust-lang/rust/commit/43cf733bfa5affc74485daeae179cc2f855b5512", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43cf733bfa5affc74485daeae179cc2f855b5512/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c322dbbf8a518d00c6db689ca80b0047f2328890", "url": "https://api.github.com/repos/rust-lang/rust/commits/c322dbbf8a518d00c6db689ca80b0047f2328890", "html_url": "https://github.com/rust-lang/rust/commit/c322dbbf8a518d00c6db689ca80b0047f2328890"}, {"sha": "cb3071b2736244db03f800102f123f437fabc9c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb3071b2736244db03f800102f123f437fabc9c1", "html_url": "https://github.com/rust-lang/rust/commit/cb3071b2736244db03f800102f123f437fabc9c1"}], "stats": {"total": 2898, "additions": 1832, "deletions": 1066}, "files": [{"sha": "d3bb5a541a47067e54e6838f70c687104dfa3e6b", "filename": "Makefile.in", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -266,8 +266,3 @@ ifneq ($(strip $(findstring TAGS.emacs,$(MAKECMDGOALS)) \\\n   CFG_INFO := $(info cfg: including ctags rules)\n   include $(CFG_SRC_DIR)mk/ctags.mk\n endif\n-\n-# Find all of the .d files and include them to add information about\n-# header file dependencies.\n-ALL_DEP_FILES := $(ALL_OBJ_FILES:%.o=%.d)\n--include $(ALL_DEP_FILES)"}, {"sha": "4f3375b866817556c418a12632b35e6bf9af6611", "filename": "configure", "status": "modified", "additions": 98, "deletions": 10, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/configure", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -610,7 +610,7 @@ CFG_TARGET=$(to_llvm_triple $CFG_TARGET)\n # there's no rpath. This is where the build system itself puts libraries;\n # --libdir is used to configure the installation directory.\n # FIXME: This needs to parameterized over target triples. Do it in platform.mk\n-if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ]\n+if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ] || [ \"$CFG_OSTYPE\" = \"pc-windows-msvc\" ]\n then\n     CFG_LIBDIR_RELATIVE=bin\n else\n@@ -628,7 +628,8 @@ esac\n \n CFG_LIBDIR_RELATIVE=`echo ${CFG_LIBDIR} | cut -c$((${#CFG_PREFIX}+${CAT_INC}))-`\n \n-if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ] && [ \"$CFG_LIBDIR_RELATIVE\" != \"bin\" ]; then\n+if ( [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ] || [ \"$CFG_OSTYPE\" = \"pc-windows-msvc\" ] ) \\\n+\t&& [ \"$CFG_LIBDIR_RELATIVE\" != \"bin\" ]; then\n     err \"libdir on windows should be set to 'bin'\"\n fi\n \n@@ -817,7 +818,7 @@ then\n fi\n \n BIN_SUF=\n-if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ]\n+if [ \"$CFG_OSTYPE\" = \"pc-windows-gnu\" ] || [ \"$CFG_OSTYPE\" = \"pc-windows-msvc\" ]\n then\n     BIN_SUF=.exe\n fi\n@@ -1097,6 +1098,65 @@ do\n                 err \"musl libc $CFG_MUSL_ROOT/lib/libc.a not found\"\n             fi\n             ;;\n+\n+        x86_64-*-msvc)\n+            # Currently the build system is not configured to build jemalloc\n+            # with MSVC, so we omit this optional dependency.\n+            step_msg \"targeting MSVC, disabling jemalloc\"\n+            CFG_DISABLE_JEMALLOC=1\n+            putvar CFG_DISABLE_JEMALLOC\n+\n+            # There are some MSYS python builds which will auto-translate\n+            # windows-style paths to MSYS-style paths in Python itself.\n+            # Unfortunately this breaks LLVM's build system as somewhere along\n+            # the line LLVM prints a path into a file from Python and then CMake\n+            # later tries to interpret that path. If Python prints a MSYS path\n+            # and CMake tries to use it as a Windows path, you're gonna have a\n+            # Bad Time.\n+            #\n+            # Consequently here we try to detect when that happens and print an\n+            # error if it does.\n+            if $CFG_PYTHON -c 'import sys; print sys.argv[1]' `pwd` | grep '^/'\n+            then\n+                err \"python is silently translating windows paths to MSYS paths \\\n+                     and the build will fail if this python is used.\\n\\n \\\n+                     Either an official python install must be used or an \\\n+                     alternative python package in MinGW must be used.\"\n+            fi\n+\n+            # MSVC requires cmake because that's how we're going to build LLVM\n+            probe_need CFG_CMAKE cmake\n+\n+            # Use the REG program to figure out where VS is installed\n+            # We need to figure out where cl.exe and link.exe are, so we do some\n+            # munging and some probing here. We also look for the default\n+            # INCLUDE and LIB variables for MSVC so we can set those in the\n+            # build system as well.\n+            install=$(reg QUERY \\\n+                       'HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\VisualStudio\\12.0' \\\n+                       -v InstallDir)\n+            need_ok \"couldn't find visual studio install root\"\n+            CFG_MSVC_ROOT=$(echo \"$install\" | grep InstallDir | sed 's/.*REG_SZ[ ]*//')\n+            CFG_MSVC_ROOT=$(dirname \"$CFG_MSVC_ROOT\")\n+            CFG_MSVC_ROOT=$(dirname \"$CFG_MSVC_ROOT\")\n+            CFG_MSVC_CL=\"${CFG_MSVC_ROOT}/VC/bin/amd64/cl.exe\"\n+            CFG_MSVC_LIB=\"${CFG_MSVC_ROOT}/VC/bin/amd64/lib.exe\"\n+            CFG_MSVC_LINK=\"${CFG_MSVC_ROOT}/VC/bin/amd64/link.exe\"\n+\n+            vcvarsall=\"${CFG_MSVC_ROOT}/VC/vcvarsall.bat\"\n+            CFG_MSVC_INCLUDE_PATH=$(cmd /c \"\\\"$vcvarsall\\\" amd64 && cmd /c echo %INCLUDE%\")\n+            need_ok \"failed to learn about MSVC's INCLUDE\"\n+            CFG_MSVC_LIB_PATH=$(cmd /c \"\\\"$vcvarsall\\\" amd64 && cmd /c echo %LIB%\")\n+            need_ok \"failed to learn about MSVC's LIB\"\n+\n+            putvar CFG_MSVC_ROOT\n+            putvar CFG_MSVC_CL\n+            putvar CFG_MSVC_LIB\n+            putvar CFG_MSVC_LINK\n+            putvar CFG_MSVC_INCLUDE_PATH\n+            putvar CFG_MSVC_LIB_PATH\n+            ;;\n+\n         *)\n             ;;\n     esac\n@@ -1138,6 +1198,7 @@ do\n   do\n     make_dir $t/rt/stage$s\n     make_dir $t/rt/jemalloc\n+    make_dir $t/rt/compiler-rt\n     for i in                                          \\\n       isaac sync test \\\n       arch/i386 arch/x86_64 arch/arm arch/aarch64 arch/mips arch/powerpc\n@@ -1301,7 +1362,39 @@ do\n         done\n     fi\n \n-    if [ ${do_reconfigure} -ne 0 ]\n+    use_cmake=0\n+    case \"$t\" in\n+        (*-msvc)\n+        use_cmake=1\n+        ;;\n+    esac\n+\n+    if [ ${do_reconfigure} -ne 0 ] && [ ${use_cmake} -ne 0 ]\n+    then\n+        msg \"configuring LLVM for $t with cmake\"\n+\n+        CMAKE_ARGS=\"-DLLVM_INCLUDE_TESTS=OFF\"\n+        if [ ! -z \"$CFG_DISABLE_OPTIMIZE_LLVM\" ]; then\n+            CMAKE_ARGS=\"$CMAKE_ARGS -DCMAKE_BUILD_TYPE=Debug\"\n+        else\n+            CMAKE_ARGS=\"$CMAKE_ARGS -DCMAKE_BUILD_TYPE=Release\"\n+        fi\n+        if [ -z \"$CFG_ENABLE_LLVM_ASSERTIONS\" ]\n+        then\n+            CMAKE_ARGS=\"$CMAKE_ARGS -DLLVM_ENABLE_ASSERTIONS=OFF\"\n+        else\n+            CMAKE_ARGS=\"$CMAKE_ARGS -DLLVM_ENABLE_ASSERTIONS=ON\"\n+        fi\n+\n+        msg \"configuring LLVM with:\"\n+        msg \"$CMAKE_ARGS\"\n+        (cd $LLVM_BUILD_DIR && \"$CFG_CMAKE\" $CFG_LLVM_SRC_DIR \\\n+                                            -G \"Visual Studio 12 2013 Win64\" \\\n+                                            $CMAKE_ARGS)\n+        need_ok \"LLVM cmake configure failed\"\n+    fi\n+\n+    if [ ${do_reconfigure} -ne 0 ] && [ ${use_cmake} -eq 0 ]\n     then\n         # LLVM's configure doesn't recognize the new Windows triples yet\n         gnu_t=$(to_gnu_triple $t)\n@@ -1325,7 +1418,7 @@ do\n         # (llvm's configure tries to find pthread first, so we have to disable it explicitly.)\n         # Also note that pthreads works badly on mingw-w64 systems: #8996\n         case \"$CFG_BUILD\" in\n-            (*-windows-*)\n+            (*-windows-gnu)\n             LLVM_OPTS=\"$LLVM_OPTS --disable-pthreads\"\n             ;;\n         esac\n@@ -1509,11 +1602,6 @@ do\n     putvar $CFG_LLVM_INST_DIR\n done\n \n-# Munge any paths that appear in config.mk back to posix-y\n-cp config.tmp config.tmp.bak\n-sed -e 's@ \\([a-zA-Z]\\):[/\\\\]@ /\\1/@g;' <config.tmp.bak >config.tmp\n-rm -f config.tmp.bak\n-\n msg\n copy_if_changed ${CFG_SRC_DIR}Makefile.in ./Makefile\n move_if_changed config.tmp config.mk"}, {"sha": "8cd09fa9043c8136d1e2d4878f2a1dd304ae8011", "filename": "mk/cfg/aarch64-apple-ios.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fcfg%2Faarch64-apple-ios.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fcfg%2Faarch64-apple-ios.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-apple-ios.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -5,6 +5,7 @@ ifneq ($(findstring darwin,$(CFG_OSTYPE)),)\n CFG_IOS_SDK_aarch64-apple-ios := $(shell xcrun --show-sdk-path -sdk iphoneos 2>/dev/null)\n CFG_IOS_SDK_FLAGS_aarch64-apple-ios := -target aarch64-apple-darwin -isysroot $(CFG_IOS_SDK_aarch64-apple-ios) -mios-version-min=7.0 -arch arm64\n CC_aarch64-apple-ios = $(shell xcrun -find -sdk iphoneos clang)\n+LINK_aarch64-apple-ios = $(shell xcrun -find -sdk iphoneos clang)\n CXX_aarch64-apple-ios = $(shell xcrun -find -sdk iphoneos clang++)\n CPP_aarch64-apple-ios = $(shell xcrun -find -sdk iphoneos clang++)\n AR_aarch64-apple-ios = $(shell xcrun -find -sdk iphoneos ar)"}, {"sha": "9e0245e093d8abc05196eb52a5b715b41d2987e3", "filename": "mk/cfg/aarch64-linux-android.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fcfg%2Faarch64-linux-android.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fcfg%2Faarch64-linux-android.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-linux-android.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -1,6 +1,7 @@\n # aarch64-linux-android configuration\n # CROSS_PREFIX_aarch64-linux-android-\n CC_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-gcc\n+LINK_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-gcc\n CXX_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-g++\n CPP_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-gcc -E\n AR_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-ar"}, {"sha": "88d7700db820f78d3c439fa07b8ecf03ea56c554", "filename": "mk/cfg/aarch64-unknown-linux-gnu.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fcfg%2Faarch64-unknown-linux-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fcfg%2Faarch64-unknown-linux-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-unknown-linux-gnu.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -1,6 +1,7 @@\n # aarch64-unknown-linux-gnu configuration\n CROSS_PREFIX_aarch64-unknown-linux-gnu=aarch64-linux-gnu-\n CC_aarch64-unknown-linux-gnu=gcc\n+LINK_aarch64-unknown-linux-gnu=gcc\n CXX_aarch64-unknown-linux-gnu=g++\n CPP_aarch64-unknown-linux-gnu=gcc -E\n AR_aarch64-unknown-linux-gnu=ar"}, {"sha": "a66f70f6305ed6e62b6cce45b45f35c1a5220e0f", "filename": "mk/cfg/arm-linux-androideabi.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fcfg%2Farm-linux-androideabi.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fcfg%2Farm-linux-androideabi.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Farm-linux-androideabi.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -1,4 +1,5 @@\n # arm-linux-androideabi configuration\n+LINK_arm-linux-androideabi=$(CFG_ANDROID_CROSS_PATH)/bin/arm-linux-androideabi-gcc\n CC_arm-linux-androideabi=$(CFG_ANDROID_CROSS_PATH)/bin/arm-linux-androideabi-gcc\n CXX_arm-linux-androideabi=$(CFG_ANDROID_CROSS_PATH)/bin/arm-linux-androideabi-g++\n CPP_arm-linux-androideabi=$(CFG_ANDROID_CROSS_PATH)/bin/arm-linux-androideabi-gcc -E"}, {"sha": "10aaf137e8b3a40e29bb3494a0c0bed60714c3a5", "filename": "mk/cfg/x86_64-pc-windows-gnu.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -1,6 +1,7 @@\n # x86_64-pc-windows-gnu configuration\n CROSS_PREFIX_x86_64-pc-windows-gnu=x86_64-w64-mingw32-\n CC_x86_64-pc-windows-gnu=gcc\n+LINK_x86_64-pc-windows-gnu=gcc\n CXX_x86_64-pc-windows-gnu=g++\n CPP_x86_64-pc-windows-gnu=gcc -E\n AR_x86_64-pc-windows-gnu=ar"}, {"sha": "bd1088b7cd13348ef691d2994b690acae8ca991a", "filename": "mk/cfg/x86_64-pc-windows-msvc.mk", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-pc-windows-msvc.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -0,0 +1,82 @@\n+# x86_64-pc-windows-msvc configuration\n+CC_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL)\" -nologo\n+LINK_x86_64-pc-windows-msvc=\"$(CFG_MSVC_LINK)\" -nologo\n+CXX_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL)\" -nologo\n+CPP_x86_64-pc-windows-msvc=\"$(CFG_MSVC_CL)\" -nologo\n+AR_x86_64-pc-windows-msvc=\"$(CFG_MSVC_LIB)\" -nologo\n+CFG_LIB_NAME_x86_64-pc-windows-msvc=$(1).dll\n+CFG_STATIC_LIB_NAME_x86_64-pc-windows-msvc=$(1).lib\n+CFG_LIB_GLOB_x86_64-pc-windows-msvc=$(1)-*.dll\n+CFG_LIB_DSYM_GLOB_x86_64-pc-windows-msvc=$(1)-*.dylib.dSYM\n+CFG_JEMALLOC_CFLAGS_x86_64-pc-windows-msvc :=\n+CFG_GCCISH_CFLAGS_x86_64-pc-windows-msvc :=\n+CFG_GCCISH_CXXFLAGS_x86_64-pc-windows-msvc :=\n+CFG_GCCISH_LINK_FLAGS_x86_64-pc-windows-msvc :=\n+CFG_GCCISH_DEF_FLAG_x86_64-pc-windows-msvc :=\n+CFG_LLC_FLAGS_x86_64-pc-windows-msvc :=\n+CFG_INSTALL_NAME_x86_64-pc-windows-msvc =\n+CFG_EXE_SUFFIX_x86_64-pc-windows-msvc := .exe\n+CFG_WINDOWSY_x86_64-pc-windows-msvc := 1\n+CFG_UNIXY_x86_64-pc-windows-msvc :=\n+CFG_LDPATH_x86_64-pc-windows-msvc :=\n+CFG_RUN_x86_64-pc-windows-msvc=$(2)\n+CFG_RUN_TARG_x86_64-pc-windows-msvc=$(call CFG_RUN_x86_64-pc-windows-msvc,,$(2))\n+CFG_GNU_TRIPLE_x86_64-pc-windows-msvc := x86_64-pc-win32\n+\n+# These two environment variables are scraped by the `./configure` script and\n+# are necessary for `cl.exe` to find standard headers (the INCLUDE variable) and\n+# for `link.exe` to find standard libraries (the LIB variable).\n+ifdef CFG_MSVC_INCLUDE_PATH\n+export INCLUDE := $(CFG_MSVC_INCLUDE_PATH)\n+endif\n+ifdef CFG_MSVC_LIB_PATH\n+export LIB := $(CFG_MSVC_LIB_PATH)\n+endif\n+\n+# Unfortunately `link.exe` is also a program in `/usr/bin` on MinGW installs,\n+# but it's not the one that we want. As a result we make sure that our detected\n+# `link.exe` shows up in PATH first.\n+ifdef CFG_MSVC_LINK\n+export PATH := $(CFG_MSVC_ROOT)/VC/bin/amd64:$(PATH)\n+endif\n+\n+# There are more comments about this available in the target specification for\n+# Windows MSVC in the compiler, but the gist of it is that we use `llvm-ar.exe`\n+# instead of `lib.exe` for assembling archives, so we need to inject this custom\n+# dependency here.\n+NATIVE_TOOL_DEPS_core_T_x86_64-pc-windows-msvc += llvm-ar.exe\n+INSTALLED_BINS_x86_64-pc-windows-msvc += llvm-ar.exe\n+\n+# When working with MSVC on windows, each DLL needs to explicitly declare its\n+# interface to the outside world through some means. The options for doing so\n+# include:\n+#\n+# 1. A custom attribute on each function itself\n+# 2. A linker argument saying what to export\n+# 3. A file which lists all symbols that need to be exported\n+#\n+# The Rust compiler takes care (1) for us for all Rust code by annotating all\n+# public-facing functions with dllexport, but we have a few native dependencies\n+# which need to cross the DLL boundary. The most important of these dependencies\n+# is LLVM which is linked into `rustc_llvm.dll` but primarily used from\n+# `rustc_trans.dll`. This means that many of LLVM's C API functions need to be\n+# exposed from `rustc_llvm.dll` to be forwarded over the boundary.\n+#\n+# Unfortunately, at this time, LLVM does not handle this sort of exportation on\n+# Windows for us, so we're forced to do it ourselves if we want it (which seems\n+# like the path of least resistance right now). To do this we generate a `.DEF`\n+# file [1] which we then custom-pass to the linker when building the rustc_llvm\n+# crate. This DEF file list all symbols that are exported from\n+# `src/librustc_llvm/lib.rs` and is generated by a small python script.\n+#\n+# Fun times!\n+#\n+# [1]: https://msdn.microsoft.com/en-us/library/28d6s79h.aspx\n+RUSTFLAGS_rustc_llvm_T_x86_64-pc-windows-msvc += \\\n+\t-C link-args=\"-DEF:x86_64-pc-windows-msvc/rt/rustc_llvm.def\"\n+CUSTOM_DEPS_rustc_llvm_T_x86_64-pc-windows-msvc += \\\n+\tx86_64-pc-windows-msvc/rt/rustc_llvm.def\n+\n+x86_64-pc-windows-msvc/rt/rustc_llvm.def: $(S)src/etc/mklldef.py \\\n+\t\t\t$(S)src/librustc_llvm/lib.rs\n+\t$(CFG_PYTHON) $^ $@ rustc_llvm-$(CFG_FILENAME_EXTRA)"}, {"sha": "c04ef89ebc58a658a9629d51670d618459901538", "filename": "mk/clean.mk", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -118,16 +118,3 @@ $(foreach host, $(CFG_HOST), \\\n  $(eval $(foreach target, $(CFG_TARGET), \\\n   $(eval $(foreach stage, 0 1 2 3, \\\n    $(eval $(call CLEAN_TARGET_STAGE_N,$(stage),$(target),$(host))))))))\n-\n-define DEF_CLEAN_LLVM_HOST\n-ifeq ($(CFG_LLVM_ROOT),)\n-clean-llvm$(1):\n-\t$$(Q)$$(MAKE) -C $$(CFG_LLVM_BUILD_DIR_$(1)) clean\n-else\n-clean-llvm$(1): ;\n-\n-endif\n-endef\n-\n-$(foreach host, $(CFG_HOST), \\\n- $(eval $(call DEF_CLEAN_LLVM_HOST,$(host))))"}, {"sha": "62dc1019066f0b446cd0f88b83a15f9d30332f58", "filename": "mk/crates.mk", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -125,9 +125,6 @@ ONLY_RLIB_rustc_bitflags := 1\n # Documented-by-default crates\n DOC_CRATES := std alloc collections core libc rustc_unicode\n \n-# Installed objects/libraries by default\n-INSTALLED_OBJECTS := libmorestack.a libcompiler-rt.a\n-\n ################################################################################\n # You should not need to edit below this line\n ################################################################################"}, {"sha": "9aab51daba9141dffff527dfd5d95cd4134168b0", "filename": "mk/dist.mk", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -144,9 +144,11 @@ dist/$$(PKG_NAME)-$(1).tar.gz: dist-install-dir-$(1) prepare-overlay-$(1)\n \t@$(call E, build: $$@)\n # Copy essential gcc components into installer\n ifdef CFG_WINDOWSY_$(1)\n+ifeq ($$(findstring gnu,$(1)),gnu)\n \t$$(Q)rm -Rf tmp/dist/win-rust-gcc-$(1)\n \t$$(Q)$$(CFG_PYTHON) $$(S)src/etc/make-win-dist.py tmp/dist/$$(PKG_NAME)-$(1)-image tmp/dist/win-rust-gcc-$(1) $(1)\n \t$$(Q)cp -r $$(S)src/etc/third-party tmp/dist/$$(PKG_NAME)-$(1)-image/share/doc/\n+endif\n endif\n \t$$(Q)$$(S)src/rust-installer/gen-installer.sh \\\n \t\t--product-name=Rust \\\n@@ -213,7 +215,14 @@ endif\n dist-install-dirs: $(foreach host,$(CFG_HOST),dist-install-dir-$(host))\n \n ifdef CFG_WINDOWSY_$(CFG_BUILD)\n-MAYBE_MINGW_TARBALLS=$(foreach host,$(CFG_HOST),dist/$(MINGW_PKG_NAME)-$(host).tar.gz)\n+define BUILD_MINGW_TARBALL\n+ifeq ($$(findstring gnu,$(1)),gnu)\n+MAYBE_MINGW_TARBALLS += dist/$(MINGW_PKG_NAME)-$(1).tar.gz\n+endif\n+endef\n+\n+$(foreach host,$(CFG_HOST),\\\n+  $(eval $(call BUILD_MINGW_TARBALL,$(host))))\n endif\n \n ifeq ($(CFG_DISABLE_DOCS),)"}, {"sha": "d5b608e88daf85852291ca4ced7c14ec4f45513e", "filename": "mk/llvm.mk", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fllvm.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -19,19 +19,47 @@ LLVM_DEPS_INC=$(call rwildcard,$(CFG_LLVM_SRC_DIR)include,*cpp *hpp)\n LLVM_DEPS=$(LLVM_DEPS_SRC) $(LLVM_DEPS_INC)\n endif\n \n+ifdef CFG_DISABLE_OPTIMIZE_LLVM\n+LLVM_BUILD_CONFIG_MODE := Debug\n+else\n+LLVM_BUILD_CONFIG_MODE := Release\n+endif\n+\n define DEF_LLVM_RULES\n \n # If CFG_LLVM_ROOT is defined then we don't build LLVM ourselves\n ifeq ($(CFG_LLVM_ROOT),)\n \n LLVM_STAMP_$(1) = $$(CFG_LLVM_BUILD_DIR_$(1))/llvm-auto-clean-stamp\n \n+ifeq ($$(findstring msvc,$(1)),msvc)\n+\n+$$(LLVM_CONFIG_$(1)): $$(LLVM_DEPS) $$(LLVM_STAMP_$(1))\n+\t@$$(call E, cmake: llvm)\n+\t$$(Q)$$(CFG_CMAKE) --build $$(CFG_LLVM_BUILD_DIR_$(1)) \\\n+\t\t--config $$(LLVM_BUILD_CONFIG_MODE)\n+\t$$(Q)touch $$(LLVM_CONFIG_$(1))\n+\n+clean-llvm$(1):\n+\n+else\n+\n $$(LLVM_CONFIG_$(1)): $$(LLVM_DEPS) $$(LLVM_STAMP_$(1))\n \t@$$(call E, make: llvm)\n \t$$(Q)$$(MAKE) -C $$(CFG_LLVM_BUILD_DIR_$(1)) $$(CFG_LLVM_BUILD_ENV_$(1)) ONLY_TOOLS=\"$$(LLVM_TOOLS)\"\n \t$$(Q)touch $$(LLVM_CONFIG_$(1))\n+\n+clean-llvm$(1):\n+\t$$(Q)$$(MAKE) -C $$(CFG_LLVM_BUILD_DIR_$(1)) clean\n+\n endif\n \n+else\n+clean-llvm$(1):\n+endif\n+\n+$$(LLVM_AR_$(1)): $$(LLVM_CONFIG_$(1))\n+\n # This is used to independently force an LLVM clean rebuild\n # when we changed something not otherwise captured by builtin\n # dependencies. In these cases, commit a change that touches\n@@ -66,7 +94,7 @@ $(foreach host,$(CFG_HOST), \\\n \n # This can't be done in target.mk because it's included before this file.\n define LLVM_LINKAGE_DEPS\n-$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.rustc_llvm: $$(LLVM_LINKAGE_PATH_$(3))\n+$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.rustc_llvm: $$(LLVM_LINKAGE_PATH_$(2))\n endef\n \n $(foreach source,$(CFG_HOST), \\"}, {"sha": "24d9ed2c68e7ed1b1af53ffd398ee243a46dfdfc", "filename": "mk/main.mk", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -87,10 +87,6 @@ CFG_INFO := $(info cfg: version $(CFG_VERSION))\n # More configuration\n ######################################################################\n \n-# We track all of the object files we might build so that we can find\n-# and include all of the .d files in one fell swoop.\n-ALL_OBJ_FILES :=\n-\n MKFILE_DEPS := config.stamp $(call rwildcard,$(CFG_SRC_DIR)mk/,*)\n MKFILES_FOR_TARBALL:=$(MKFILE_DEPS)\n ifneq ($(NO_MKFILE_DEPS),)\n@@ -298,16 +294,21 @@ endif\n # Any rules that depend on LLVM should depend on LLVM_CONFIG\n LLVM_CONFIG_$(1):=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-config$$(X_$(1))\n LLVM_MC_$(1):=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-mc$$(X_$(1))\n+LLVM_AR_$(1):=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-ar$$(X_$(1))\n LLVM_VERSION_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --version)\n LLVM_BINDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --bindir)\n LLVM_INCDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --includedir)\n LLVM_LIBDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --libdir)\n LLVM_LIBDIR_RUSTFLAGS_$(1)=-L \"$$(LLVM_LIBDIR_$(1))\"\n LLVM_LIBS_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --libs $$(LLVM_COMPONENTS))\n LLVM_LDFLAGS_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --ldflags)\n+ifeq ($$(findstring freebsd,$(1)),freebsd)\n # On FreeBSD, it may search wrong headers (that are for pre-installed LLVM),\n # so we replace -I with -iquote to ensure that it searches bundled LLVM first.\n LLVM_CXXFLAGS_$(1)=$$(subst -I, -iquote , $$(shell \"$$(LLVM_CONFIG_$(1))\" --cxxflags))\n+else\n+LLVM_CXXFLAGS_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --cxxflags)\n+endif\n LLVM_HOST_TRIPLE_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --host-target)\n \n LLVM_AS_$(1)=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-as$$(X_$(1))\n@@ -402,8 +403,6 @@ endif\n # Prerequisites for using the stageN compiler to build target artifacts\n TSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(HSREQ$(1)_H_$(3)) \\\n-\t$$(foreach obj,$$(INSTALLED_OBJECTS),\\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(obj)) \\\n \t$$(foreach obj,$$(INSTALLED_OBJECTS_$(2)),\\\n \t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(obj))\n "}, {"sha": "26a6db1c5bd1aa1b4097fa0798a94dd46929c3d3", "filename": "mk/platform.mk", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -90,10 +90,6 @@ ifneq ($(findstring linux,$(CFG_OSTYPE)),)\n   endif\n endif\n \n-# These flags will cause the compiler to produce a .d file\n-# next to the .o file that lists header deps.\n-CFG_DEPEND_FLAGS = -MMD -MP -MT $(1) -MF $(1:%.o=%.d)\n-\n AR := ar\n \n define SET_FROM_CFG\n@@ -116,6 +112,14 @@ CFG_RLIB_GLOB=lib$(1)-*.rlib\n \n include $(wildcard $(CFG_SRC_DIR)mk/cfg/*.mk)\n \n+define ADD_INSTALLED_OBJECTS\n+  INSTALLED_OBJECTS_$(1) += $$(call CFG_STATIC_LIB_NAME_$(1),morestack) \\\n+                            $$(call CFG_STATIC_LIB_NAME_$(1),compiler-rt)\n+endef\n+\n+$(foreach target,$(CFG_TARGET), \\\n+  $(eval $(call ADD_INSTALLED_OBJECTS,$(target))))\n+\n # The -Qunused-arguments sidesteps spurious warnings from clang\n define FILTER_FLAGS\n   ifeq ($$(CFG_USING_CLANG),1)\n@@ -129,6 +133,21 @@ endef\n $(foreach target,$(CFG_TARGET), \\\n   $(eval $(call FILTER_FLAGS,$(target))))\n \n+# Configure various macros to pass gcc or cl.exe style arguments\n+define CC_MACROS\n+  CFG_CC_INCLUDE_$(1)=-I $$(1)\n+  ifeq ($$(findstring msvc,$(1)),msvc)\n+    CFG_CC_OUTPUT_$(1)=-Fo:$$(1)\n+    CFG_CREATE_ARCHIVE_$(1)=$$(AR_$(1)) -OUT:$$(1)\n+  else\n+    CFG_CC_OUTPUT_$(1)=-o $$(1)\n+    CFG_CREATE_ARCHIVE_$(1)=$$(AR_$(1)) crus $$(1)\n+  endif\n+endef\n+\n+$(foreach target,$(CFG_TARGET), \\\n+  $(eval $(call CC_MACROS,$(target))))\n+\n \n ifeq ($(CFG_CCACHE_CPP2),1)\n   CCACHE_CPP2=1\n@@ -145,21 +164,23 @@ FIND_COMPILER = $(word 1,$(1:ccache=))\n define CFG_MAKE_TOOLCHAIN\n   # Prepend the tools with their prefix if cross compiling\n   ifneq ($(CFG_BUILD),$(1))\n+    ifneq ($$(findstring msvc,$(1)),msvc)\n        CC_$(1)=$(CROSS_PREFIX_$(1))$(CC_$(1))\n        CXX_$(1)=$(CROSS_PREFIX_$(1))$(CXX_$(1))\n        CPP_$(1)=$(CROSS_PREFIX_$(1))$(CPP_$(1))\n        AR_$(1)=$(CROSS_PREFIX_$(1))$(AR_$(1))\n-       RUSTC_CROSS_FLAGS_$(1)=-C linker=$$(call FIND_COMPILER,$$(CC_$(1))) \\\n+       LINK_$(1)=$(CROSS_PREFIX_$(1))$(LINK_$(1))\n+       RUSTC_CROSS_FLAGS_$(1)=-C linker=$$(call FIND_COMPILER,$$(LINK_$(1))) \\\n            -C ar=$$(call FIND_COMPILER,$$(AR_$(1))) $(RUSTC_CROSS_FLAGS_$(1))\n \n        RUSTC_FLAGS_$(1)=$$(RUSTC_CROSS_FLAGS_$(1)) $(RUSTC_FLAGS_$(1))\n+    endif\n   endif\n \n   CFG_COMPILE_C_$(1) = $$(CC_$(1)) \\\n         $$(CFG_GCCISH_CFLAGS) \\\n         $$(CFG_GCCISH_CFLAGS_$(1)) \\\n-        $$(CFG_DEPEND_FLAGS) \\\n-        -c -o $$(1) $$(2)\n+        -c $$(call CFG_CC_OUTPUT_$(1),$$(1)) $$(2)\n   CFG_LINK_C_$(1) = $$(CC_$(1)) \\\n         $$(CFG_GCCISH_LINK_FLAGS) -o $$(1) \\\n         $$(CFG_GCCISH_LINK_FLAGS_$(1)) \\\n@@ -170,8 +191,7 @@ define CFG_MAKE_TOOLCHAIN\n         $$(CFG_GCCISH_CXXFLAGS) \\\n         $$(CFG_GCCISH_CFLAGS_$(1)) \\\n         $$(CFG_GCCISH_CXXFLAGS_$(1)) \\\n-        $$(CFG_DEPEND_FLAGS) \\\n-        -c -o $$(1) $$(2)\n+        -c $$(call CFG_CC_OUTPUT_$(1),$$(1)) $$(2)\n   CFG_LINK_CXX_$(1) = $$(CXX_$(1)) \\\n         $$(CFG_GCCISH_LINK_FLAGS) -o $$(1) \\\n         $$(CFG_GCCISH_LINK_FLAGS_$(1)) \\\n@@ -189,7 +209,7 @@ define CFG_MAKE_TOOLCHAIN\n \n   # We're using llvm-mc as our assembler because it supports\n   # .cfi pseudo-ops on mac\n-  CFG_ASSEMBLE_$(1)=$$(CPP_$(1)) -E $$(CFG_DEPEND_FLAGS) $$(2) | \\\n+  CFG_ASSEMBLE_$(1)=$$(CPP_$(1)) -E $$(2) | \\\n                     $$(LLVM_MC_$$(CFG_BUILD)) \\\n                     -assemble \\\n                     -relocation-model=$$(LLVM_MC_RELOCATION_MODEL) \\\n@@ -201,7 +221,7 @@ define CFG_MAKE_TOOLCHAIN\n   # For the ARM, AARCH64, MIPS and POWER crosses, use the toolchain assembler\n   # FIXME: We should be able to use the LLVM assembler\n   CFG_ASSEMBLE_$(1)=$$(CC_$(1)) $$(CFG_GCCISH_CFLAGS_$(1)) \\\n-                   $$(CFG_DEPEND_FLAGS) $$(2) -c -o $$(1)\n+                   $$(2) -c -o $$(1)\n \n   endif\n "}, {"sha": "573b7ac79fd1a2fc20241ab854b8d6d25dc42859", "filename": "mk/prepare.mk", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fprepare.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Fprepare.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fprepare.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -36,7 +36,10 @@ endef\n \n # Copy an executable\n # $(1) is the filename/libname-glob\n+#\n+# Gee, what's up with that $(nop)? See comment below.\n define PREPARE_BIN\n+\t$(nop)\n \t@$(call E, prepare: $(PREPARE_DEST_BIN_DIR)/$(1))\n \t$(Q)$(PREPARE_BIN_CMD) $(PREPARE_SOURCE_BIN_DIR)/$(1) $(PREPARE_DEST_BIN_DIR)/$(1)\n endef\n@@ -119,6 +122,8 @@ define DEF_PREPARE_TARGET_N\n # Rebind PREPARE_*_LIB_DIR to point to rustlib, then install the libs for the targets\n prepare-target-$(2)-host-$(3)-$(1)-$(4): PREPARE_WORKING_SOURCE_LIB_DIR=$$(PREPARE_SOURCE_LIB_DIR)/rustlib/$(2)/lib\n prepare-target-$(2)-host-$(3)-$(1)-$(4): PREPARE_WORKING_DEST_LIB_DIR=$$(PREPARE_DEST_LIB_DIR)/rustlib/$(2)/lib\n+prepare-target-$(2)-host-$(3)-$(1)-$(4): PREPARE_SOURCE_BIN_DIR=$$(PREPARE_SOURCE_LIB_DIR)/rustlib/$(3)/bin\n+prepare-target-$(2)-host-$(3)-$(1)-$(4): PREPARE_DEST_BIN_DIR=$$(PREPARE_DEST_LIB_DIR)/rustlib/$(3)/bin\n prepare-target-$(2)-host-$(3)-$(1)-$(4): prepare-maybe-clean-$(4) \\\n         $$(foreach crate,$$(TARGET_CRATES), \\\n           $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(crate)) \\\n@@ -133,15 +138,19 @@ prepare-target-$(2)-host-$(3)-$(1)-$(4): prepare-maybe-clean-$(4) \\\n       $$(if $$(findstring $(2), $$(PREPARE_TARGETS)), \\\n         $$(if $$(findstring $(3), $$(PREPARE_HOST)), \\\n           $$(call PREPARE_DIR,$$(PREPARE_WORKING_DEST_LIB_DIR)) \\\n+          $$(call PREPARE_DIR,$$(PREPARE_DEST_BIN_DIR)) \\\n           $$(foreach crate,$$(TARGET_CRATES), \\\n \t    $$(if $$(or $$(findstring 1, $$(ONLY_RLIB_$$(crate))),$$(findstring 1,$$(CFG_INSTALL_ONLY_RLIB_$(2)))),, \\\n               $$(call PREPARE_LIB,$$(call CFG_LIB_GLOB_$(2),$$(crate)))) \\\n             $$(call PREPARE_LIB,$$(call CFG_RLIB_GLOB,$$(crate)))) \\\n           $$(if $$(findstring $(2),$$(CFG_HOST)), \\\n             $$(foreach crate,$$(HOST_CRATES), \\\n               $$(call PREPARE_LIB,$$(call CFG_LIB_GLOB_$(2),$$(crate)))),) \\\n-\t  $$(foreach object,$$(INSTALLED_OBJECTS) $$(INSTALLED_OBJECTS_$(2)),\\\n-\t    $$(call PREPARE_LIB,$$(object))),),),)\n+\t  $$(foreach object,$$(INSTALLED_OBJECTS_$(2)),\\\n+\t    $$(call PREPARE_LIB,$$(object))) \\\n+\t  $$(foreach bin,$$(INSTALLED_BINS_$(3)),\\\n+\t    $$(call PREPARE_BIN,$$(bin))) \\\n+\t,),),)\n endef\n \n define INSTALL_GDB_DEBUGGER_SCRIPTS_COMMANDS"}, {"sha": "777a2a0fd3b4bfceee113033a8d78a4ea468b336", "filename": "mk/rt.mk", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -81,8 +81,8 @@ $$(RT_OUTPUT_DIR_$(1))/%.o: $(S)src/rt/%.c $$(MKFILE_DEPS)\n \t@mkdir -p $$(@D)\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(call CFG_COMPILE_C_$(1), $$@, \\\n-\t\t-I $$(S)src/rt/hoedown/src \\\n-\t\t-I $$(S)src/rt \\\n+\t\t$$(call CFG_CC_INCLUDE_$(1),$$(S)src/rt/hoedown/src) \\\n+\t\t$$(call CFG_CC_INCLUDE_$(1),$$(S)src/rt) \\\n                  $$(RUNTIME_CFLAGS_$(1))) $$<\n \n $$(RT_OUTPUT_DIR_$(1))/%.o: $(S)src/rt/%.S $$(MKFILE_DEPS) \\\n@@ -109,12 +109,7 @@ OBJS_$(2)_$(1) := $$(OBJS_$(2)_$(1):.S=.o)\n NATIVE_$(2)_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),$(2))\n $$(RT_OUTPUT_DIR_$(1))/$$(NATIVE_$(2)_$(1)): $$(OBJS_$(2)_$(1))\n \t@$$(call E, link: $$@)\n-\t$$(Q)$$(AR_$(1)) rcs $$@ $$^\n-\n-ifeq ($$(findstring windows,$(1)),windows)\n-$$(RT_OUTPUT_DIR_$(1))/lib$(2).a: $$(RT_OUTPUT_DIR_$(1))/$$(NATIVE_$(2)_$(1))\n-\t$$(Q)cp $$^ $$@\n-endif\n+\t$$(Q)$$(call CFG_CREATE_ARCHIVE_$(1),$$@) $$^\n \n endef\n \n@@ -227,22 +222,36 @@ COMPRT_DEPS := $(wildcard \\\n               $(S)src/compiler-rt/*/*/*/*)\n endif\n \n-COMPRT_NAME_$(1) := libcompiler-rt.a\n+COMPRT_NAME_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),compiler-rt)\n COMPRT_LIB_$(1) := $$(RT_OUTPUT_DIR_$(1))/$$(COMPRT_NAME_$(1))\n COMPRT_BUILD_DIR_$(1) := $$(RT_OUTPUT_DIR_$(1))/compiler-rt\n \n+# Note that on MSVC-targeting builds we hardwire CC/AR to gcc/ar even though\n+# we're targeting MSVC. This is because although compiler-rt has a CMake build\n+# config I can't actually figure out how to use it, so I'm not sure how to use\n+# cl.exe to build the objects. Additionally, the compiler-rt library when built\n+# with gcc has the same ABI as cl.exe, so they're largely compatible\n+COMPRT_CC_$(1) := $$(CC_$(1))\n+COMPRT_AR_$(1) := $$(AR_$(1))\n+COMPRT_CFLAGS_$(1) := $$(CFG_GCCISH_CFLAGS_$(1))\n+ifeq ($$(findstring msvc,$(1)),msvc)\n+COMPRT_CC_$(1) := gcc\n+COMPRT_AR_$(1) := ar\n+COMPRT_CFLAGS_$(1) := $$(CFG_GCCISH_CFLAGS_$(1)) -m64\n+endif\n+\n $$(COMPRT_LIB_$(1)): $$(COMPRT_DEPS) $$(MKFILE_DEPS)\n \t@$$(call E, make: compiler-rt)\n \t$$(Q)$$(MAKE) -C \"$(S)src/compiler-rt\" \\\n \t\tProjSrcRoot=\"$(S)src/compiler-rt\" \\\n \t\tProjObjRoot=\"$$(abspath $$(COMPRT_BUILD_DIR_$(1)))\" \\\n-\t\tCC=\"$$(CC_$(1))\" \\\n-\t\tAR=\"$$(AR_$(1))\" \\\n-\t\tRANLIB=\"$$(AR_$(1)) s\" \\\n-\t\tCFLAGS=\"$$(CFG_GCCISH_CFLAGS_$(1))\" \\\n+\t\tCC='$$(COMPRT_CC_$(1))' \\\n+\t\tAR='$$(COMPRT_AR_$(1))' \\\n+\t\tRANLIB='$$(COMPRT_AR_$(1)) s' \\\n+\t\tCFLAGS=\"$$(COMPRT_CFLAGS_$(1))\" \\\n \t\tTargetTriple=$(1) \\\n \t\ttriple-builtins\n-\t$$(Q)cp $$(COMPRT_BUILD_DIR_$(1))/triple/builtins/libcompiler_rt.a $$(COMPRT_LIB_$(1))\n+\t$$(Q)cp $$(COMPRT_BUILD_DIR_$(1))/triple/builtins/libcompiler_rt.a $$@\n \n ################################################################################\n # libbacktrace"}, {"sha": "50d993701421e896a18a0be34baf5c923c161e47", "filename": "mk/rustllvm.mk", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Frustllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Frustllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frustllvm.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -18,27 +18,41 @@ define DEF_RUSTLLVM_TARGETS\n # to find the llvm includes (probably because we're not actually installing\n # llvm, but using it straight out of the build directory)\n ifdef CFG_WINDOWSY_$(1)\n-LLVM_EXTRA_INCDIRS_$(1)= -iquote $(S)src/llvm/include \\\n-                         -iquote $$(CFG_LLVM_BUILD_DIR_$(1))/include\n+LLVM_EXTRA_INCDIRS_$(1)= $$(call CFG_CC_INCLUDE_$(1),$(S)src/llvm/include) \\\n+                         $$(call CFG_CC_INCLUDE_$(1),\\\n+\t\t\t   $$(CFG_LLVM_BUILD_DIR_$(1))/include)\n endif\n \n RUSTLLVM_OBJS_CS_$(1) := $$(addprefix rustllvm/, \\\n \tExecutionEngineWrapper.cpp RustWrapper.cpp PassWrapper.cpp)\n \n RUSTLLVM_INCS_$(1) = $$(LLVM_EXTRA_INCDIRS_$(1)) \\\n-                     -iquote $$(LLVM_INCDIR_$(1)) \\\n-                     -iquote $$(S)src/rustllvm/include\n+                     $$(call CFG_CC_INCLUDE_$(1),$$(LLVM_INCDIR_$(1))) \\\n+                     $$(call CFG_CC_INCLUDE_$(1),$$(S)src/rustllvm/include)\n RUSTLLVM_OBJS_OBJS_$(1) := $$(RUSTLLVM_OBJS_CS_$(1):rustllvm/%.cpp=$(1)/rustllvm/%.o)\n-ALL_OBJ_FILES += $$(RUSTLLVM_OBJS_OBJS_$(1))\n+\n+# Note that we appease `cl.exe` and its need for some sort of exception\n+# handling flag with the `EHsc` argument here as well.\n+ifeq ($$(findstring msvc,$(1)),msvc)\n+EXTRA_RUSTLLVM_CXXFLAGS_$(1) := //EHsc\n+endif\n \n $$(RT_OUTPUT_DIR_$(1))/$$(call CFG_STATIC_LIB_NAME_$(1),rustllvm): \\\n \t    $$(RUSTLLVM_OBJS_OBJS_$(1))\n \t@$$(call E, link: $$@)\n-\t$$(Q)$$(AR_$(1)) rcs $$@ $$(RUSTLLVM_OBJS_OBJS_$(1))\n+\t$$(Q)$$(call CFG_CREATE_ARCHIVE_$(1),$$@) $$^\n \n+# On MSVC we need to double-escape arguments that llvm-config printed which\n+# start with a '/'. The shell we're running in will auto-translate the argument\n+# `/foo` to `C:/msys64/foo` but we really want it to be passed through as `/foo`\n+# so the argument passed to our shell must be `//foo`.\n $(1)/rustllvm/%.o: $(S)src/rustllvm/%.cpp $$(MKFILE_DEPS) $$(LLVM_CONFIG_$(1))\n \t@$$(call E, compile: $$@)\n-\t$$(Q)$$(call CFG_COMPILE_CXX_$(1), $$@, $$(LLVM_CXXFLAGS_$(1)) $$(RUSTLLVM_INCS_$(1))) $$<\n+\t$$(Q)$$(call CFG_COMPILE_CXX_$(1), $$@,) \\\n+\t\t$$(subst  /,//,$$(LLVM_CXXFLAGS_$(1))) \\\n+\t\t$$(EXTRA_RUSTLLVM_CXXFLAGS_$(1)) \\\n+\t\t$$(RUSTLLVM_INCS_$(1)) \\\n+\t\t$$<\n endef\n \n # Instantiate template for all stages"}, {"sha": "c8efb8e86d6d75fd13cbeab9079da6c2e4b2f562", "filename": "mk/target.mk", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -37,7 +37,10 @@ CRATE_FULLDEPS_$(1)_T_$(2)_H_$(3)_$(4) := \\\n \t\t$$(foreach dep,$$(NATIVE_DEPS_$(4)), \\\n \t\t  $$(RT_OUTPUT_DIR_$(2))/$$(call CFG_STATIC_LIB_NAME_$(2),$$(dep))) \\\n \t\t$$(foreach dep,$$(NATIVE_DEPS_$(4)_T_$(2)), \\\n-\t\t  $$(RT_OUTPUT_DIR_$(2))/$$(dep))\n+\t\t  $$(RT_OUTPUT_DIR_$(2))/$$(dep)) \\\n+\t\t$$(foreach dep,$$(NATIVE_TOOL_DEPS_$(4)_T_$(2)), \\\n+\t\t  $$(TBIN$(1)_T_$(3)_H_$(3))/$$(dep)) \\\n+\t\t$$(CUSTOM_DEPS_$(4)_T_$(2))\n endef\n \n $(foreach host,$(CFG_HOST), \\\n@@ -83,13 +86,14 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): \\\n \t    $$(dir $$@)$$(call CFG_LIB_GLOB_$(2),$(4)))\n \t$$(call REMOVE_ALL_OLD_GLOB_MATCHES, \\\n \t    $$(dir $$@)$$(call CFG_RLIB_GLOB,$(4)))\n-\t$(Q)CFG_LLVM_LINKAGE_FILE=$$(LLVM_LINKAGE_PATH_$(3)) \\\n+\t$(Q)CFG_LLVM_LINKAGE_FILE=$$(LLVM_LINKAGE_PATH_$(2)) \\\n \t    $$(subst @,,$$(STAGE$(1)_T_$(2)_H_$(3))) \\\n \t\t$$(RUST_LIB_FLAGS_ST$(1)) \\\n \t\t-L \"$$(RT_OUTPUT_DIR_$(2))\" \\\n \t\t$$(LLVM_LIBDIR_RUSTFLAGS_$(2)) \\\n \t\t$$(LLVM_STDCPP_RUSTFLAGS_$(2)) \\\n \t\t$$(RUSTFLAGS_$(4)) \\\n+\t\t$$(RUSTFLAGS_$(4)_T_$(2)) \\\n \t\t--out-dir $$(@D) \\\n \t\t-C extra-filename=-$$(CFG_FILENAME_EXTRA) \\\n \t\t$$<\n@@ -149,6 +153,11 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/%: $$(RT_OUTPUT_DIR_$(2))/% \\\n \t    | $$(TLIB$(1)_T_$(2)_H_$(3))/ $$(SNAPSHOT_RUSTC_POST_CLEANUP)\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n+\n+$$(TBIN$(1)_T_$(2)_H_$(3))/%: $$(CFG_LLVM_INST_DIR_$(2))/bin/% \\\n+\t    | $$(TBIN$(1)_T_$(2)_H_$(3))/ $$(SNAPSHOT_RUSTC_POST_CLEANUP)\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n endef\n \n $(foreach source,$(CFG_HOST), \\"}, {"sha": "44c661c4e20ea61bcb77157bb27a2b1904d4006c", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -382,7 +382,7 @@ $(3)/stage$(1)/test/$(4)test-$(2)$$(X_$(2)): \\\n \t\t$$(CRATEFILE_$(4)) \\\n \t\t$$(TESTDEP_$(1)_$(2)_$(3)_$(4))\n \t@$$(call E, rustc: $$@)\n-\t$(Q)CFG_LLVM_LINKAGE_FILE=$$(LLVM_LINKAGE_PATH_$(3)) \\\n+\t$(Q)CFG_LLVM_LINKAGE_FILE=$$(LLVM_LINKAGE_PATH_$(2)) \\\n \t    $$(subst @,,$$(STAGE$(1)_T_$(2)_H_$(3))) -o $$@ $$< --test \\\n \t\t-L \"$$(RT_OUTPUT_DIR_$(2))\" \\\n \t\t$$(LLVM_LIBDIR_RUSTFLAGS_$(2)) \\\n@@ -894,7 +894,7 @@ ifeq ($(2),$$(CFG_BUILD))\n $$(call TEST_OK_FILE,$(1),$(2),$(3),doc-crate-$(4)): $$(CRATEDOCTESTDEP_$(1)_$(2)_$(3)_$(4))\n \t@$$(call E, run doc-crate-$(4) [$(2)])\n \t$$(Q)touch $$@.start_time\n-\t$$(Q)CFG_LLVM_LINKAGE_FILE=$$(LLVM_LINKAGE_PATH_$(3)) \\\n+\t$$(Q)CFG_LLVM_LINKAGE_FILE=$$(LLVM_LINKAGE_PATH_$(2)) \\\n \t    $$(RUSTDOC_$(1)_T_$(2)_H_$(3)) --test --cfg dox \\\n \t        $$(CRATEFILE_$(4)) --test-args \"$$(TESTARGS)\" && \\\n \t        touch -r $$@.start_time $$@ && rm $$@.start_time"}, {"sha": "d2f8ee469a4a1ec0332d24c94cadc95ca70972c9", "filename": "src/etc/mklldef.py", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Fetc%2Fmklldef.py", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Fetc%2Fmklldef.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmklldef.py?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -0,0 +1,25 @@\n+# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+import sys\n+\n+input_file = sys.argv[1]\n+output_file = sys.argv[2]\n+name = sys.argv[3]\n+\n+with open(input_file, 'r') as f:\n+    with open(output_file, 'w') as g:\n+        print >> g, 'LIBRARY ' + name\n+        print >> g, 'EXPORTS'\n+        for x in f:\n+            x = str(x)\n+            if not x.startswith('    pub fn LLVM'): continue\n+            name = x[11:x.find('(')]\n+            print >> g, '  ' + name"}, {"sha": "7a925fa3f33670ef57bc5acca15b56bd7336d7d5", "filename": "src/etc/mklldeps.py", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Fetc%2Fmklldeps.py", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Fetc%2Fmklldeps.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmklldeps.py?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -80,10 +80,13 @@ def run(args):\n     assert('stdlib=libc++' not in out)\n     f.write(\"#[link(name = \\\"stdc++\\\", kind = \\\"static\\\")]\\n\")\n else:\n+    # Note that we use `cfg_attr` here because on MSVC the C++ standard library\n+    # is not c++ or stdc++, but rather the linker takes care of linking the\n+    # right standard library.\n     if 'stdlib=libc++' in out:\n-        f.write(\"#[link(name = \\\"c++\\\")]\\n\")\n+        f.write(\"#[cfg_attr(not(target_env = \\\"msvc\\\"), link(name = \\\"c++\\\"))]\\n\")\n     else:\n-        f.write(\"#[link(name = \\\"stdc++\\\")]\\n\")\n+        f.write(\"#[cfg_attr(not(target_env = \\\"msvc\\\"), link(name = \\\"stdc++\\\"))]\\n\")\n \n # Attach everything to an extern block\n f.write(\"extern {}\\n\")"}, {"sha": "3d19e95211e8da598ca82b886e7b7ed387af758f", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -150,6 +150,12 @@ extern {}\n #[link(name = \"c\", kind = \"static\")]\n extern {}\n \n+#[cfg(all(windows, target_env = \"msvc\"))]\n+#[link(name = \"kernel32\")]\n+#[link(name = \"shell32\")]\n+#[link(name = \"msvcrt\")]\n+extern {}\n+\n // libnacl provides functions that require a trip through the IRT to work.\n // ie: _exit, mmap, nanosleep, etc. Anything that would otherwise require a trip\n // to the kernel."}, {"sha": "f96094d3d090db01b058d3c7861801c0172211b2", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -526,8 +526,7 @@ impl<'a> Context<'a> {\n \n         for (lib, kind) in m {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n-            let metadata = match get_metadata_section(self.target.options.is_like_osx,\n-                                                      &lib) {\n+            let metadata = match get_metadata_section(self.target, &lib) {\n                 Ok(blob) => {\n                     if self.crate_matches(blob.as_slice(), &lib) {\n                         blob\n@@ -715,16 +714,18 @@ impl ArchiveMetadata {\n }\n \n // Just a small wrapper to time how long reading metadata takes.\n-fn get_metadata_section(is_osx: bool, filename: &Path) -> Result<MetadataBlob, String> {\n+fn get_metadata_section(target: &Target, filename: &Path)\n+                        -> Result<MetadataBlob, String> {\n     let mut ret = None;\n     let dur = Duration::span(|| {\n-        ret = Some(get_metadata_section_imp(is_osx, filename));\n+        ret = Some(get_metadata_section_imp(target, filename));\n     });\n     info!(\"reading {:?} => {}\", filename.file_name().unwrap(), dur);\n     return ret.unwrap();;\n }\n \n-fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlob, String> {\n+fn get_metadata_section_imp(target: &Target, filename: &Path)\n+                            -> Result<MetadataBlob, String> {\n     if !filename.exists() {\n         return Err(format!(\"no such file: '{}'\", filename.display()));\n     }\n@@ -768,7 +769,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n                                              name_len as usize).to_vec();\n             let name = String::from_utf8(name).unwrap();\n             debug!(\"get_metadata_section: name {}\", name);\n-            if read_meta_section_name(is_osx) == name {\n+            if read_meta_section_name(target) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n                 let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n                 let cvbuf: *const u8 = cbuf as *const u8;\n@@ -798,26 +799,41 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n     }\n }\n \n-pub fn meta_section_name(is_osx: bool) -> &'static str {\n-    if is_osx {\n+pub fn meta_section_name(target: &Target) -> &'static str {\n+    if target.options.is_like_osx {\n         \"__DATA,__note.rustc\"\n+    } else if target.options.is_like_msvc {\n+        // When using link.exe it was seen that the section name `.note.rustc`\n+        // was getting shortened to `.note.ru`, and according to the PE and COFF\n+        // specification:\n+        //\n+        // > Executable images do not use a string table and do not support\n+        // > section names longer than 8\u00a0characters\n+        //\n+        // https://msdn.microsoft.com/en-us/library/windows/hardware/gg463119.aspx\n+        //\n+        // As a result, we choose a slightly shorter name! As to why\n+        // `.note.rustc` works on MinGW, that's another good question...\n+        \".rustc\"\n     } else {\n         \".note.rustc\"\n     }\n }\n \n-pub fn read_meta_section_name(is_osx: bool) -> &'static str {\n-    if is_osx {\n+pub fn read_meta_section_name(target: &Target) -> &'static str {\n+    if target.options.is_like_osx {\n         \"__note.rustc\"\n+    } else if target.options.is_like_msvc {\n+        \".rustc\"\n     } else {\n         \".note.rustc\"\n     }\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-pub fn list_file_metadata(is_osx: bool, path: &Path,\n+pub fn list_file_metadata(target: &Target, path: &Path,\n                           out: &mut io::Write) -> io::Result<()> {\n-    match get_metadata_section(is_osx, path) {\n+    match get_metadata_section(target, path) {\n         Ok(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n         Err(msg) => {\n             write!(out, \"{}\\n\", msg)"}, {"sha": "39d1f5ba205e4dc8ae8e84cba74e5894866185fe", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 87, "deletions": 87, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -30,16 +30,11 @@ pub struct ArchiveConfig<'a> {\n     pub lib_search_paths: Vec<PathBuf>,\n     pub slib_prefix: String,\n     pub slib_suffix: String,\n-    pub maybe_ar_prog: Option<String>\n+    pub ar_prog: String\n }\n \n pub struct Archive<'a> {\n-    handler: &'a ErrorHandler,\n-    dst: PathBuf,\n-    lib_search_paths: Vec<PathBuf>,\n-    slib_prefix: String,\n-    slib_suffix: String,\n-    maybe_ar_prog: Option<String>\n+    config: ArchiveConfig<'a>,\n }\n \n /// Helper for adding many files to an archive with a single invocation of\n@@ -53,47 +48,10 @@ pub struct ArchiveBuilder<'a> {\n     should_update_symbols: bool,\n }\n \n-fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n-          args: &str, cwd: Option<&Path>,\n-          paths: &[&Path]) -> Output {\n-    let ar = match *maybe_ar_prog {\n-        Some(ref ar) => &ar[..],\n-        None => \"ar\"\n-    };\n-    let mut cmd = Command::new(ar);\n-\n-    cmd.arg(args).args(paths).stdout(Stdio::piped()).stderr(Stdio::piped());\n-    debug!(\"{:?}\", cmd);\n-\n-    match cwd {\n-        Some(p) => {\n-            cmd.current_dir(p);\n-            debug!(\"inside {:?}\", p.display());\n-        }\n-        None => {}\n-    }\n-\n-    match cmd.spawn() {\n-        Ok(prog) => {\n-            let o = prog.wait_with_output().unwrap();\n-            if !o.status.success() {\n-                handler.err(&format!(\"{:?} failed with: {}\", cmd, o.status));\n-                handler.note(&format!(\"stdout ---\\n{}\",\n-                                  str::from_utf8(&o.stdout).unwrap()));\n-                handler.note(&format!(\"stderr ---\\n{}\",\n-                                  str::from_utf8(&o.stderr).unwrap())\n-                             );\n-                handler.abort_if_errors();\n-            }\n-            o\n-        },\n-        Err(e) => {\n-            handler.err(&format!(\"could not exec `{}`: {}\", &ar[..],\n-                             e));\n-            handler.abort_if_errors();\n-            panic!(\"rustc::back::archive::run_ar() should not reach this point\");\n-        }\n-    }\n+enum Action<'a> {\n+    Remove(&'a Path),\n+    AddObjects(&'a [&'a PathBuf], bool),\n+    UpdateSymbols,\n }\n \n pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n@@ -120,43 +78,89 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n \n impl<'a> Archive<'a> {\n     fn new(config: ArchiveConfig<'a>) -> Archive<'a> {\n-        let ArchiveConfig { handler, dst, lib_search_paths, slib_prefix, slib_suffix,\n-            maybe_ar_prog } = config;\n-        Archive {\n-            handler: handler,\n-            dst: dst,\n-            lib_search_paths: lib_search_paths,\n-            slib_prefix: slib_prefix,\n-            slib_suffix: slib_suffix,\n-            maybe_ar_prog: maybe_ar_prog\n-        }\n+        Archive { config: config }\n     }\n \n     /// Opens an existing static archive\n     pub fn open(config: ArchiveConfig<'a>) -> Archive<'a> {\n         let archive = Archive::new(config);\n-        assert!(archive.dst.exists());\n+        assert!(archive.config.dst.exists());\n         archive\n     }\n \n     /// Removes a file from this archive\n     pub fn remove_file(&mut self, file: &str) {\n-        run_ar(self.handler, &self.maybe_ar_prog, \"d\", None, &[&self.dst, &Path::new(file)]);\n+        self.run(None, Action::Remove(Path::new(file)));\n     }\n \n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<String> {\n-        let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, &[&self.dst]);\n-        let output = str::from_utf8(&output.stdout).unwrap();\n-        // use lines_any because windows delimits output with `\\r\\n` instead of\n-        // just `\\n`\n-        output.lines_any().map(|s| s.to_string()).collect()\n+        let archive = match ArchiveRO::open(&self.config.dst) {\n+            Some(ar) => ar,\n+            None => return Vec::new(),\n+        };\n+        let ret = archive.iter().filter_map(|child| child.name())\n+                         .map(|name| name.to_string())\n+                         .collect();\n+        return ret;\n     }\n \n     /// Creates an `ArchiveBuilder` for adding files to this archive.\n     pub fn extend(self) -> ArchiveBuilder<'a> {\n         ArchiveBuilder::new(self)\n     }\n+\n+    fn run(&self, cwd: Option<&Path>, action: Action) -> Output {\n+        let abs_dst = env::current_dir().unwrap().join(&self.config.dst);\n+        let ar = &self.config.ar_prog;\n+        let mut cmd = Command::new(ar);\n+        cmd.stdout(Stdio::piped()).stderr(Stdio::piped());\n+        self.prepare_ar_action(&mut cmd, &abs_dst, action);\n+        info!(\"{:?}\", cmd);\n+\n+        if let Some(p) = cwd {\n+            cmd.current_dir(p);\n+            info!(\"inside {:?}\", p.display());\n+        }\n+\n+        let handler = &self.config.handler;\n+        match cmd.spawn() {\n+            Ok(prog) => {\n+                let o = prog.wait_with_output().unwrap();\n+                if !o.status.success() {\n+                    handler.err(&format!(\"{:?} failed with: {}\", cmd, o.status));\n+                    handler.note(&format!(\"stdout ---\\n{}\",\n+                                          str::from_utf8(&o.stdout).unwrap()));\n+                    handler.note(&format!(\"stderr ---\\n{}\",\n+                                          str::from_utf8(&o.stderr).unwrap()));\n+                    handler.abort_if_errors();\n+                }\n+                o\n+            },\n+            Err(e) => {\n+                handler.err(&format!(\"could not exec `{}`: {}\",\n+                                     self.config.ar_prog, e));\n+                handler.abort_if_errors();\n+                panic!(\"rustc::back::archive::run() should not reach this point\");\n+            }\n+        }\n+    }\n+\n+    fn prepare_ar_action(&self, cmd: &mut Command, dst: &Path, action: Action) {\n+        match action {\n+            Action::Remove(file) => {\n+                cmd.arg(\"d\").arg(dst).arg(file);\n+            }\n+            Action::AddObjects(objs, update_symbols) => {\n+                cmd.arg(if update_symbols {\"crus\"} else {\"cruS\"})\n+                   .arg(dst)\n+                   .args(objs);\n+            }\n+            Action::UpdateSymbols => {\n+                cmd.arg(\"s\").arg(dst);\n+            }\n+        }\n+    }\n }\n \n impl<'a> ArchiveBuilder<'a> {\n@@ -179,10 +183,10 @@ impl<'a> ArchiveBuilder<'a> {\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) -> io::Result<()> {\n         let location = find_library(name,\n-                                    &self.archive.slib_prefix,\n-                                    &self.archive.slib_suffix,\n-                                    &self.archive.lib_search_paths,\n-                                    self.archive.handler);\n+                                    &self.archive.config.slib_prefix,\n+                                    &self.archive.config.slib_suffix,\n+                                    &self.archive.config.lib_search_paths,\n+                                    self.archive.config.handler);\n         self.add_archive(&location, name, |_| false)\n     }\n \n@@ -229,17 +233,13 @@ impl<'a> ArchiveBuilder<'a> {\n     pub fn build(self) -> Archive<'a> {\n         // Get an absolute path to the destination, so `ar` will work even\n         // though we run it from `self.work_dir`.\n-        let abs_dst = env::current_dir().unwrap().join(&self.archive.dst);\n-        assert!(!abs_dst.is_relative());\n-        let mut args = vec![&*abs_dst];\n-        let mut total_len = abs_dst.to_string_lossy().len();\n+        let mut objects = Vec::new();\n+        let mut total_len = self.archive.config.dst.to_string_lossy().len();\n \n         if self.members.is_empty() {\n-            // OSX `ar` does not allow using `r` with no members, but it does\n-            // allow running `ar s file.a` to update symbols only.\n             if self.should_update_symbols {\n-                run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"s\", Some(self.work_dir.path()), &args[..]);\n+                self.archive.run(Some(self.work_dir.path()),\n+                                 Action::UpdateSymbols);\n             }\n             return self.archive;\n         }\n@@ -257,24 +257,22 @@ impl<'a> ArchiveBuilder<'a> {\n             // string, not an array of strings.)\n             if total_len + len + 1 > ARG_LENGTH_LIMIT {\n                 // Add the archive members seen so far, without updating the\n-                // symbol table (`S`).\n-                run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"cruS\", Some(self.work_dir.path()), &args[..]);\n+                // symbol table.\n+                self.archive.run(Some(self.work_dir.path()),\n+                                 Action::AddObjects(&objects, false));\n \n-                args.clear();\n-                args.push(&abs_dst);\n-                total_len = abs_dst.to_string_lossy().len();\n+                objects.clear();\n+                total_len = self.archive.config.dst.to_string_lossy().len();\n             }\n \n-            args.push(member_name);\n+            objects.push(member_name);\n             total_len += len + 1;\n         }\n \n         // Add the remaining archive members, and update the symbol table if\n         // necessary.\n-        let flags = if self.should_update_symbols { \"crus\" } else { \"cruS\" };\n-        run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-               flags, Some(self.work_dir.path()), &args[..]);\n+        self.archive.run(Some(self.work_dir.path()),\n+                         Action::AddObjects(&objects, self.should_update_symbols));\n \n         self.archive\n     }\n@@ -305,6 +303,8 @@ impl<'a> ArchiveBuilder<'a> {\n             };\n             if filename.contains(\".SYMDEF\") { continue }\n             if skip(filename) { continue }\n+            let filename = Path::new(filename).file_name().unwrap()\n+                                              .to_str().unwrap();\n \n             // Archives on unix systems typically do not have slashes in\n             // filenames as the `ar` utility generally only uses the last"}, {"sha": "3ae70ca854bdbf5c6083978bdf41923cd0d5200a", "filename": "src/librustc_back/target/linux_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_base.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -13,7 +13,6 @@ use std::default::Default;\n \n pub fn opts() -> TargetOptions {\n     TargetOptions {\n-        linker: \"cc\".to_string(),\n         dynamic_linking: true,\n         executables: true,\n         morestack: true,"}, {"sha": "22d966014da1c348b7048a731dff9ab5a2623858", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -59,6 +59,7 @@ mod freebsd_base;\n mod linux_base;\n mod openbsd_base;\n mod windows_base;\n+mod windows_msvc_base;\n \n /// Everything `rustc` knows about how to compile for a specific target.\n ///\n@@ -92,6 +93,8 @@ pub struct Target {\n pub struct TargetOptions {\n     /// Linker to invoke. Defaults to \"cc\".\n     pub linker: String,\n+    /// Archive utility to use when managing archives. Defaults to \"ar\".\n+    pub ar: String,\n     /// Linker arguments that are unconditionally passed *before* any\n     /// user-defined libraries.\n     pub pre_link_args: Vec<String>,\n@@ -145,29 +148,32 @@ pub struct TargetOptions {\n     /// only really used for figuring out how to find libraries, since Windows uses its own\n     /// library naming convention. Defaults to false.\n     pub is_like_windows: bool,\n+    pub is_like_msvc: bool,\n     /// Whether the target toolchain is like Android's. Only useful for compiling against Android.\n     /// Defaults to false.\n     pub is_like_android: bool,\n     /// Whether the linker support GNU-like arguments such as -O. Defaults to false.\n     pub linker_is_gnu: bool,\n     /// Whether the linker support rpaths or not. Defaults to false.\n     pub has_rpath: bool,\n-    /// Whether to disable linking to compiler-rt. Defaults to false, as LLVM will emit references\n-    /// to the functions that compiler-rt provides.\n+    /// Whether to disable linking to compiler-rt. Defaults to false, as LLVM\n+    /// will emit references to the functions that compiler-rt provides.\n     pub no_compiler_rt: bool,\n-    /// Dynamically linked executables can be compiled as position independent if the default\n-    /// relocation model of position independent code is not changed. This is a requirement to take\n-    /// advantage of ASLR, as otherwise the functions in the executable are not randomized and can\n-    /// be used during an exploit of a vulnerability in any code.\n+    /// Dynamically linked executables can be compiled as position independent\n+    /// if the default relocation model of position independent code is not\n+    /// changed. This is a requirement to take advantage of ASLR, as otherwise\n+    /// the functions in the executable are not randomized and can be used\n+    /// during an exploit of a vulnerability in any code.\n     pub position_independent_executables: bool,\n }\n \n impl Default for TargetOptions {\n-    /// Create a set of \"sane defaults\" for any target. This is still incomplete, and if used for\n-    /// compilation, will certainly not work.\n+    /// Create a set of \"sane defaults\" for any target. This is still\n+    /// incomplete, and if used for compilation, will certainly not work.\n     fn default() -> TargetOptions {\n         TargetOptions {\n             linker: \"cc\".to_string(),\n+            ar: \"ar\".to_string(),\n             pre_link_args: Vec::new(),\n             post_link_args: Vec::new(),\n             cpu: \"generic\".to_string(),\n@@ -188,6 +194,7 @@ impl Default for TargetOptions {\n             is_like_osx: false,\n             is_like_windows: false,\n             is_like_android: false,\n+            is_like_msvc: false,\n             linker_is_gnu: false,\n             has_rpath: false,\n             no_compiler_rt: false,\n@@ -371,7 +378,9 @@ impl Target {\n             armv7s_apple_ios,\n \n             x86_64_pc_windows_gnu,\n-            i686_pc_windows_gnu\n+            i686_pc_windows_gnu,\n+\n+            x86_64_pc_windows_msvc\n         );\n \n "}, {"sha": "30d74c807352c192a6a554484d108fef0c8d402f", "filename": "src/librustc_back/target/windows_msvc_base.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::TargetOptions;\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    TargetOptions {\n+        function_sections: true,\n+        linker: \"link.exe\".to_string(),\n+        // When taking a look at the value of this `ar` field, one might expect\n+        // `lib.exe` to be the value here! The `lib.exe` program is the default\n+        // tool for managing `.lib` archives on Windows, but unfortunately the\n+        // compiler cannot use it.\n+        //\n+        // To recap, we use `ar` here to manage rlibs (which are just archives).\n+        // LLVM does not expose bindings for modifying archives so we have to\n+        // invoke this utility for write operations (e.g. deleting files, adding\n+        // files, etc). Normally archives only have object files within them,\n+        // but the compiler also uses archives for storing metadata and\n+        // compressed bytecode, so we don't exactly fall within \"normal use\n+        // cases\".\n+        //\n+        // MSVC's `lib.exe` tool by default will choke when adding a non-object\n+        // file to an archive, which we do on a regular basis, making it\n+        // inoperable for us. Luckily, however, LLVM has already rewritten `ar`\n+        // in the form of `llvm-ar` which is built by default when we build\n+        // LLVM. This tool, unlike `lib.exe`, works just fine with non-object\n+        // files, so we use it instead.\n+        //\n+        // Note that there's a few caveats associated with this:\n+        //\n+        // * This still requires that the *linker* (the consumer of rlibs) will\n+        //   ignore non-object files. Thankfully `link.exe` on Windows does\n+        //   indeed ignore non-object files in archives.\n+        // * This requires `llvm-ar.exe` to be distributed with the compiler\n+        //   itself, but we already make sure of this elsewhere.\n+        //\n+        // Perhaps one day we won't even need this tool at all and we'll just be\n+        // able to make library calls into LLVM!\n+        ar: \"llvm-ar.exe\".to_string(),\n+        dynamic_linking: true,\n+        executables: true,\n+        dll_prefix: \"\".to_string(),\n+        dll_suffix: \".dll\".to_string(),\n+        exe_suffix: \".exe\".to_string(),\n+        staticlib_prefix: \"\".to_string(),\n+        staticlib_suffix: \".lib\".to_string(),\n+        morestack: false,\n+        is_like_windows: true,\n+        is_like_msvc: true,\n+        pre_link_args: vec![\n+            \"/NOLOGO\".to_string(),\n+            \"/NXCOMPAT\".to_string(),\n+        ],\n+\n+        .. Default::default()\n+    }\n+}"}, {"sha": "f7c3ca4b3f6edd61d41975cfba58fec7f5f23853", "filename": "src/librustc_back/target/x86_64_pc_windows_msvc.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_msvc.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    let mut base = super::windows_msvc_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+\n+    Target {\n+        // This is currently in sync with the specification for\n+        // x86_64-pc-windows-gnu but there's a comment in that file questioning\n+        // whether this is valid or not. Sounds like the two should stay in sync\n+        // at least for now.\n+        data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                      f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n+                      s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n+        llvm_target: \"x86_64-pc-windows-msvc\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"windows\".to_string(),\n+        target_env: \"msvc\".to_string(),\n+        options: base,\n+    }\n+}"}, {"sha": "2c0e1a05c3dfab3e1f9d9a52e82ab65e5ece7661", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -402,7 +402,7 @@ impl RustcDefaultCalls {\n                 &Input::File(ref ifile) => {\n                     let path = &(*ifile);\n                     let mut v = Vec::new();\n-                    metadata::loader::list_file_metadata(sess.target.target.options.is_like_osx,\n+                    metadata::loader::list_file_metadata(&sess.target.target,\n                                                          path,\n                                                          &mut v).unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());"}, {"sha": "a3b9a0e846700bf51d90b7a63c984b022a94d986", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -55,6 +55,7 @@ pub use self::CallConv::*;\n pub use self::Visibility::*;\n pub use self::DiagnosticSeverity::*;\n pub use self::Linkage::*;\n+pub use self::DLLStorageClassTypes::*;\n \n use std::ffi::CString;\n use std::cell::RefCell;\n@@ -123,6 +124,15 @@ pub enum DiagnosticSeverity {\n     Note,\n }\n \n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub enum DLLStorageClassTypes {\n+    DefaultStorageClass = 0,\n+    DLLImportStorageClass = 1,\n+    DLLExportStorageClass = 2,\n+}\n+\n bitflags! {\n     flags Attribute : u32 {\n         const ZExt            = 1 << 0,\n@@ -1761,7 +1771,7 @@ extern {\n                          Dialect: c_uint)\n                          -> ValueRef;\n \n-    pub static LLVMRustDebugMetadataVersion: u32;\n+    pub fn LLVMRustDebugMetadataVersion() -> u32;\n \n     pub fn LLVMRustAddModuleFlag(M: ModuleRef,\n                                  name: *const c_char,\n@@ -2075,7 +2085,8 @@ extern {\n     pub fn LLVMRustArchiveIteratorFree(AIR: ArchiveIteratorRef);\n     pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n \n-    pub fn LLVMRustSetDLLExportStorageClass(V: ValueRef);\n+    pub fn LLVMRustSetDLLStorageClass(V: ValueRef,\n+                                      C: DLLStorageClassTypes);\n \n     pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n                                   data: *mut *const c_char) -> c_int;\n@@ -2125,6 +2136,12 @@ pub fn SetLinkage(global: ValueRef, link: Linkage) {\n     }\n }\n \n+pub fn SetDLLStorageClass(global: ValueRef, class: DLLStorageClassTypes) {\n+    unsafe {\n+        LLVMRustSetDLLStorageClass(global, class);\n+    }\n+}\n+\n pub fn SetUnnamedAddr(global: ValueRef, unnamed: bool) {\n     unsafe {\n         LLVMSetUnnamedAddr(global, unnamed as Bool);"}, {"sha": "844a0a698677ff312240ef61bd5b5951b925b7d6", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 91, "deletions": 175, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use super::archive::{Archive, ArchiveBuilder, ArchiveConfig, METADATA_FILENAME};\n-use super::archive;\n-use super::rpath;\n+use super::linker::{Linker, GnuLinker, MsvcLinker};\n use super::rpath::RPathConfig;\n+use super::rpath;\n use super::svh::Svh;\n use session::config;\n use session::config::NoDebugInfo;\n@@ -29,7 +29,6 @@ use util::sha2::{Digest, Sha256};\n use util::fs::fix_windows_verbatim_for_gcc;\n use rustc_back::tempdir::TempDir;\n \n-use std::ffi::OsString;\n use std::fs::{self, PathExt};\n use std::io::{self, Read, Write};\n use std::mem;\n@@ -366,6 +365,12 @@ pub fn get_cc_prog(sess: &Session) -> String {\n     }\n }\n \n+pub fn get_ar_prog(sess: &Session) -> String {\n+    sess.opts.cg.ar.clone().unwrap_or_else(|| {\n+        sess.target.target.options.ar.clone()\n+    })\n+}\n+\n pub fn remove(sess: &Session, path: &Path) {\n     match fs::remove_file(path) {\n         Ok(..) => {}\n@@ -541,23 +546,22 @@ fn link_rlib<'a>(sess: &'a Session,\n                  trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n                  obj_filename: &Path,\n                  out_filename: &Path) -> ArchiveBuilder<'a> {\n+    info!(\"preparing rlib from {:?} to {:?}\", obj_filename, out_filename);\n     let handler = &sess.diagnostic().handler;\n     let config = ArchiveConfig {\n         handler: handler,\n         dst: out_filename.to_path_buf(),\n         lib_search_paths: archive_search_paths(sess),\n         slib_prefix: sess.target.target.options.staticlib_prefix.clone(),\n         slib_suffix: sess.target.target.options.staticlib_suffix.clone(),\n-        maybe_ar_prog: sess.opts.cg.ar.clone()\n+        ar_prog: get_ar_prog(sess),\n     };\n     let mut ab = ArchiveBuilder::create(config);\n     ab.add_file(obj_filename).unwrap();\n \n     for &(ref l, kind) in &*sess.cstore.get_used_libraries().borrow() {\n         match kind {\n-            cstore::NativeStatic => {\n-                ab.add_native_library(&l[..]).unwrap();\n-            }\n+            cstore::NativeStatic => ab.add_native_library(&l).unwrap(),\n             cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n     }\n@@ -608,10 +612,8 @@ fn link_rlib<'a>(sess: &'a Session,\n             }) {\n                 Ok(..) => {}\n                 Err(e) => {\n-                    sess.err(&format!(\"failed to write {}: {}\",\n-                                     metadata.display(),\n-                                     e));\n-                    sess.abort_if_errors();\n+                    sess.fatal(&format!(\"failed to write {}: {}\",\n+                                        metadata.display(), e));\n                 }\n             }\n             ab.add_file(&metadata).unwrap();\n@@ -653,9 +655,8 @@ fn link_rlib<'a>(sess: &'a Session,\n                                                     &bc_data_deflated) {\n                     Ok(()) => {}\n                     Err(e) => {\n-                        sess.err(&format!(\"failed to write compressed bytecode: \\\n-                                          {}\", e));\n-                        sess.abort_if_errors()\n+                        sess.fatal(&format!(\"failed to write compressed \\\n+                                             bytecode: {}\", e));\n                     }\n                 };\n \n@@ -789,6 +790,8 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n // links to all upstream files as well.\n fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n                  obj_filename: &Path, out_filename: &Path) {\n+    info!(\"preparing dylib? ({}) from {:?} to {:?}\", dylib, obj_filename,\n+          out_filename);\n     let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n \n     // The invocations of cc share some flags across platforms\n@@ -801,10 +804,17 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         cmd.arg(root.join(obj));\n     }\n \n-    link_args(&mut cmd, sess, dylib, tmpdir.path(),\n-              trans, obj_filename, out_filename);\n-    if !sess.target.target.options.no_compiler_rt {\n-        cmd.arg(\"-lcompiler-rt\");\n+    {\n+        let mut linker = if sess.target.target.options.is_like_msvc {\n+            Box::new(MsvcLinker { cmd: &mut cmd, sess: &sess }) as Box<Linker>\n+        } else {\n+            Box::new(GnuLinker { cmd: &mut cmd, sess: &sess }) as Box<Linker>\n+        };\n+        link_args(&mut *linker, sess, dylib, tmpdir.path(),\n+                  trans, obj_filename, out_filename);\n+        if !sess.target.target.options.no_compiler_rt {\n+            linker.link_staticlib(\"compiler-rt\");\n+        }\n     }\n     for obj in &sess.target.target.options.post_link_objects {\n         cmd.arg(root.join(obj));\n@@ -819,7 +829,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     sess.abort_if_errors();\n \n     // Invoke the system linker\n-    debug!(\"{:?}\", &cmd);\n+    info!(\"{:?}\", &cmd);\n     let prog = time(sess.time_passes(), \"running linker\", (), |()| cmd.output());\n     match prog {\n         Ok(prog) => {\n@@ -833,14 +843,11 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n                 sess.note(str::from_utf8(&output[..]).unwrap());\n                 sess.abort_if_errors();\n             }\n-            debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.stderr).unwrap());\n-            debug!(\"linker stdout:\\n{}\", String::from_utf8(prog.stdout).unwrap());\n+            info!(\"linker stderr:\\n{}\", String::from_utf8(prog.stderr).unwrap());\n+            info!(\"linker stdout:\\n{}\", String::from_utf8(prog.stdout).unwrap());\n         },\n         Err(e) => {\n-            sess.err(&format!(\"could not exec the linker `{}`: {}\",\n-                             pname,\n-                             e));\n-            sess.abort_if_errors();\n+            sess.fatal(&format!(\"could not exec the linker `{}`: {}\", pname, e));\n         }\n     }\n \n@@ -850,15 +857,12 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     if sess.target.target.options.is_like_osx && sess.opts.debuginfo != NoDebugInfo {\n         match Command::new(\"dsymutil\").arg(out_filename).output() {\n             Ok(..) => {}\n-            Err(e) => {\n-                sess.err(&format!(\"failed to run dsymutil: {}\", e));\n-                sess.abort_if_errors();\n-            }\n+            Err(e) => sess.fatal(&format!(\"failed to run dsymutil: {}\", e)),\n         }\n     }\n }\n \n-fn link_args(cmd: &mut Command,\n+fn link_args(cmd: &mut Linker,\n              sess: &Session,\n              dylib: bool,\n              tmpdir: &Path,\n@@ -873,10 +877,9 @@ fn link_args(cmd: &mut Command,\n     // target descriptor\n     let t = &sess.target.target;\n \n-    cmd.arg(\"-L\").arg(&fix_windows_verbatim_for_gcc(&lib_path));\n-\n-    cmd.arg(\"-o\").arg(out_filename).arg(obj_filename);\n-\n+    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+    cmd.add_object(obj_filename);\n+    cmd.output_filename(out_filename);\n \n     // Stack growth requires statically linking a __morestack function. Note\n     // that this is listed *before* all other libraries. Due to the usage of the\n@@ -895,89 +898,44 @@ fn link_args(cmd: &mut Command,\n     // will include the __morestack symbol 100% of the time, always resolving\n     // references to it even if the object above didn't use it.\n     if t.options.morestack {\n-        if t.options.is_like_osx {\n-            let morestack = lib_path.join(\"libmorestack.a\");\n-\n-            let mut v = OsString::from(\"-Wl,-force_load,\");\n-            v.push(&morestack);\n-            cmd.arg(&v);\n-        } else {\n-            cmd.args(&[\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n-        }\n+        cmd.link_whole_staticlib(\"morestack\", &[lib_path]);\n     }\n \n     // When linking a dynamic library, we put the metadata into a section of the\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here.\n     if dylib {\n-        cmd.arg(&obj_filename.with_extension(\"metadata.o\"));\n+        cmd.add_object(&obj_filename.with_extension(\"metadata.o\"));\n     }\n \n-    if t.options.is_like_osx {\n-        // The dead_strip option to the linker specifies that functions and data\n-        // unreachable by the entry point will be removed. This is quite useful\n-        // with Rust's compilation model of compiling libraries at a time into\n-        // one object file. For example, this brings hello world from 1.7MB to\n-        // 458K.\n-        //\n-        // Note that this is done for both executables and dynamic libraries. We\n-        // won't get much benefit from dylibs because LLVM will have already\n-        // stripped away as much as it could. This has not been seen to impact\n-        // link times negatively.\n-        //\n-        // -dead_strip can't be part of the pre_link_args because it's also used\n-        // for partial linking when using multiple codegen units (-r). So we\n-        // insert it here.\n-        cmd.arg(\"-Wl,-dead_strip\");\n-    }\n-\n-    // If we're building a dylib, we don't use --gc-sections because LLVM has\n-    // already done the best it can do, and we also don't want to eliminate the\n-    // metadata. If we're building an executable, however, --gc-sections drops\n-    // the size of hello world from 1.8MB to 597K, a 67% reduction.\n-    if !dylib && !t.options.is_like_osx {\n-        cmd.arg(\"-Wl,--gc-sections\");\n-    }\n+    // Try to strip as much out of the generated object by removing unused\n+    // sections if possible. See more comments in linker.rs\n+    cmd.gc_sections(dylib);\n \n     let used_link_args = sess.cstore.get_used_link_args().borrow();\n \n-    if t.options.position_independent_executables {\n+    if !dylib && t.options.position_independent_executables {\n         let empty_vec = Vec::new();\n         let empty_str = String::new();\n         let args = sess.opts.cg.link_args.as_ref().unwrap_or(&empty_vec);\n         let mut args = args.iter().chain(used_link_args.iter());\n-        if !dylib\n-            && (t.options.relocation_model == \"pic\"\n-                || *sess.opts.cg.relocation_model.as_ref()\n-                   .unwrap_or(&empty_str) == \"pic\")\n+        let relocation_model = sess.opts.cg.relocation_model.as_ref()\n+                                   .unwrap_or(&empty_str);\n+        if (t.options.relocation_model == \"pic\" || *relocation_model == \"pic\")\n             && !args.any(|x| *x == \"-static\") {\n-            cmd.arg(\"-pie\");\n+            cmd.position_independent_executable();\n         }\n     }\n \n-    if t.options.linker_is_gnu {\n-        // GNU-style linkers support optimization with -O. GNU ld doesn't need a\n-        // numeric argument, but other linkers do.\n-        if sess.opts.optimize == config::Default ||\n-           sess.opts.optimize == config::Aggressive {\n-            cmd.arg(\"-Wl,-O1\");\n-        }\n-    }\n+    // Pass optimization flags down to the linker.\n+    cmd.optimize();\n \n     // We want to prevent the compiler from accidentally leaking in any system\n     // libraries, so we explicitly ask gcc to not link to any libraries by\n     // default. Note that this does not happen for windows because windows pulls\n     // in some large number of libraries and I couldn't quite figure out which\n     // subset we wanted.\n-    if !t.options.is_like_windows {\n-        cmd.arg(\"-nodefaultlibs\");\n-    }\n-\n-    // Mark all dynamic libraries and executables as compatible with ASLR\n-    // FIXME #17098: ASLR breaks gdb\n-    if t.options.is_like_windows && sess.opts.debuginfo == NoDebugInfo {\n-        // cmd.arg(\"-Wl,--dynamicbase\");\n-    }\n+    cmd.no_default_libraries();\n \n     // Take careful note of the ordering of the arguments we pass to the linker\n     // here. Linkers will assume that things on the left depend on things to the\n@@ -1019,18 +977,7 @@ fn link_args(cmd: &mut Command,\n     // # Telling the linker what we're doing\n \n     if dylib {\n-        // On mac we need to tell the linker to let this library be rpathed\n-        if sess.target.target.options.is_like_osx {\n-            cmd.args(&[\"-dynamiclib\", \"-Wl,-dylib\"]);\n-\n-            if sess.opts.cg.rpath {\n-                let mut v = OsString::from(\"-Wl,-install_name,@rpath/\");\n-                v.push(out_filename.file_name().unwrap());\n-                cmd.arg(&v);\n-            }\n-        } else {\n-            cmd.arg(\"-shared\");\n-        }\n+        cmd.build_dylib(out_filename);\n     }\n \n     // FIXME (#2397): At some point we want to rpath our guesses as to\n@@ -1059,9 +1006,10 @@ fn link_args(cmd: &mut Command,\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n-    let empty = Vec::new();\n-    cmd.args(&sess.opts.cg.link_args.as_ref().unwrap_or(&empty));\n-    cmd.args(&used_link_args[..]);\n+    if let Some(ref args) = sess.opts.cg.link_args {\n+        cmd.args(args);\n+    }\n+    cmd.args(&used_link_args);\n }\n \n // # Native library linking\n@@ -1075,21 +1023,15 @@ fn link_args(cmd: &mut Command,\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n+fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n     sess.target_filesearch(PathKind::All).for_each_lib_search_path(|path, k| {\n         match k {\n-            PathKind::Framework => { cmd.arg(\"-F\").arg(path); }\n-            _ => { cmd.arg(\"-L\").arg(&fix_windows_verbatim_for_gcc(path)); }\n+            PathKind::Framework => { cmd.framework_path(path); }\n+            _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(path)); }\n         }\n         FileDoesntMatch\n     });\n \n-    // Some platforms take hints about whether a library is static or dynamic.\n-    // For those that support this, we ensure we pass the option if the library\n-    // was flagged \"static\" (most defaults are dynamic) to ensure that if\n-    // libfoo.a and libfoo.so both exist that the right one is chosen.\n-    let takes_hints = !sess.target.target.options.is_like_osx;\n-\n     let libs = sess.cstore.get_used_libraries();\n     let libs = libs.borrow();\n \n@@ -1100,46 +1042,29 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n         kind != cstore::NativeStatic\n     });\n \n-    // Platforms that take hints generally also support the --whole-archive\n-    // flag. We need to pass this flag when linking static native libraries to\n-    // ensure the entire library is included.\n-    //\n-    // For more details see #15460, but the gist is that the linker will strip\n-    // away any unused objects in the archive if we don't otherwise explicitly\n-    // reference them. This can occur for libraries which are just providing\n-    // bindings, libraries with generic functions, etc.\n-    if takes_hints {\n-        cmd.arg(\"-Wl,--whole-archive\").arg(\"-Wl,-Bstatic\");\n-    }\n+    // Some platforms take hints about whether a library is static or dynamic.\n+    // For those that support this, we ensure we pass the option if the library\n+    // was flagged \"static\" (most defaults are dynamic) to ensure that if\n+    // libfoo.a and libfoo.so both exist that the right one is chosen.\n+    cmd.hint_static();\n+\n     let search_path = archive_search_paths(sess);\n     for l in staticlibs {\n-        if takes_hints {\n-            cmd.arg(&format!(\"-l{}\", l));\n-        } else {\n-            // -force_load is the OSX equivalent of --whole-archive, but it\n-            // involves passing the full path to the library to link.\n-            let lib = archive::find_library(&l[..],\n-                                            &sess.target.target.options.staticlib_prefix,\n-                                            &sess.target.target.options.staticlib_suffix,\n-                                            &search_path[..],\n-                                            &sess.diagnostic().handler);\n-            let mut v = OsString::from(\"-Wl,-force_load,\");\n-            v.push(&lib);\n-            cmd.arg(&v);\n-        }\n-    }\n-    if takes_hints {\n-        cmd.arg(\"-Wl,--no-whole-archive\").arg(\"-Wl,-Bdynamic\");\n+        // Here we explicitly ask that the entire archive is included into the\n+        // result artifact. For more details see #15460, but the gist is that\n+        // the linker will strip away any unused objects in the archive if we\n+        // don't otherwise explicitly reference them. This can occur for\n+        // libraries which are just providing bindings, libraries with generic\n+        // functions, etc.\n+        cmd.link_whole_staticlib(l, &search_path);\n     }\n \n+    cmd.hint_dynamic();\n+\n     for &(ref l, kind) in others {\n         match kind {\n-            cstore::NativeUnknown => {\n-                cmd.arg(&format!(\"-l{}\", l));\n-            }\n-            cstore::NativeFramework => {\n-                cmd.arg(\"-framework\").arg(&l[..]);\n-            }\n+            cstore::NativeUnknown => cmd.link_dylib(l),\n+            cstore::NativeFramework => cmd.link_framework(l),\n             cstore::NativeStatic => unreachable!(),\n         }\n     }\n@@ -1150,7 +1075,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n // Rust crates are not considered at all when creating an rlib output. All\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n-fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n+fn add_upstream_rust_crates(cmd: &mut Linker, sess: &Session,\n                             dylib: bool, tmpdir: &Path,\n                             trans: &CrateTranslation) {\n     // All of the heavy lifting has previously been accomplished by the\n@@ -1201,7 +1126,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     }\n \n     // Adds the static \"rlib\" versions of all crates to the command line.\n-    fn add_static_crate(cmd: &mut Command, sess: &Session, tmpdir: &Path,\n+    fn add_static_crate(cmd: &mut Linker, sess: &Session, tmpdir: &Path,\n                         cratepath: &Path) {\n         // When performing LTO on an executable output, all of the\n         // bytecode from the upstream libraries has already been\n@@ -1227,11 +1152,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                 match fs::copy(&cratepath, &dst) {\n                     Ok(..) => {}\n                     Err(e) => {\n-                        sess.err(&format!(\"failed to copy {} to {}: {}\",\n-                                         cratepath.display(),\n-                                         dst.display(),\n-                                         e));\n-                        sess.abort_if_errors();\n+                        sess.fatal(&format!(\"failed to copy {} to {}: {}\",\n+                                            cratepath.display(),\n+                                            dst.display(), e));\n                     }\n                 }\n                 // Fix up permissions of the copy, as fs::copy() preserves\n@@ -1244,10 +1167,8 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                 }) {\n                     Ok(..) => {}\n                     Err(e) => {\n-                        sess.err(&format!(\"failed to chmod {} when preparing \\\n-                                          for LTO: {}\", dst.display(),\n-                                         e));\n-                        sess.abort_if_errors();\n+                        sess.fatal(&format!(\"failed to chmod {} when preparing \\\n+                                             for LTO: {}\", dst.display(), e));\n                     }\n                 }\n                 let handler = &sess.diagnostic().handler;\n@@ -1257,33 +1178,33 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     lib_search_paths: archive_search_paths(sess),\n                     slib_prefix: sess.target.target.options.staticlib_prefix.clone(),\n                     slib_suffix: sess.target.target.options.staticlib_suffix.clone(),\n-                    maybe_ar_prog: sess.opts.cg.ar.clone()\n+                    ar_prog: get_ar_prog(sess),\n                 };\n                 let mut archive = Archive::open(config);\n                 archive.remove_file(&format!(\"{}.o\", name));\n                 let files = archive.files();\n                 if files.iter().any(|s| s.ends_with(\".o\")) {\n-                    cmd.arg(&dst);\n+                    cmd.link_rlib(&dst);\n                 }\n             });\n         } else {\n-            cmd.arg(&fix_windows_verbatim_for_gcc(cratepath));\n+            cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n         }\n     }\n \n     // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crate(cmd: &mut Command, sess: &Session, cratepath: &Path) {\n+    fn add_dynamic_crate(cmd: &mut Linker, sess: &Session, cratepath: &Path) {\n         // If we're performing LTO, then it should have been previously required\n         // that all upstream rust dependencies were available in an rlib format.\n         assert!(!sess.lto());\n \n         // Just need to tell the linker about where the library lives and\n         // what its name is\n         if let Some(dir) = cratepath.parent() {\n-            cmd.arg(\"-L\").arg(&fix_windows_verbatim_for_gcc(dir));\n+            cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n         }\n         let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n-        cmd.arg(&format!(\"-l{}\", unlib(&sess.target, filestem)));\n+        cmd.link_dylib(&unlib(&sess.target, filestem));\n     }\n }\n \n@@ -1305,7 +1226,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n+fn add_upstream_native_libraries(cmd: &mut Linker, sess: &Session) {\n     // Be sure to use a topological sorting of crates because there may be\n     // interdependencies between native libraries. When passing -nodefaultlibs,\n     // for example, almost all native libraries depend on libc, so we have to\n@@ -1320,13 +1241,8 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n         let libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         for &(kind, ref lib) in &libs {\n             match kind {\n-                cstore::NativeUnknown => {\n-                    cmd.arg(&format!(\"-l{}\", *lib));\n-                }\n-                cstore::NativeFramework => {\n-                    cmd.arg(\"-framework\");\n-                    cmd.arg(&lib[..]);\n-                }\n+                cstore::NativeUnknown => cmd.link_dylib(lib),\n+                cstore::NativeFramework => cmd.link_framework(lib),\n                 cstore::NativeStatic => {\n                     sess.bug(\"statics shouldn't be propagated\");\n                 }"}, {"sha": "1eacec46c87bbad7b130cccc8f4fb0ef34ffd0b2", "filename": "src/librustc_trans/back/linker.rs", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -0,0 +1,253 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ffi::OsString;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use rustc_back::archive;\n+use session::Session;\n+use session::config;\n+\n+/// Linker abstraction used by back::link to build up the command to invoke a\n+/// linker.\n+///\n+/// This trait is the total list of requirements needed by `back::link` and\n+/// represents the meaning of each option being passed down. This trait is then\n+/// used to dispatch on whether a GNU-like linker (generally `ld.exe`) or an\n+/// MSVC linker (e.g. `link.exe`) is being used.\n+pub trait Linker {\n+    fn link_dylib(&mut self, lib: &str);\n+    fn link_framework(&mut self, framework: &str);\n+    fn link_staticlib(&mut self, lib: &str);\n+    fn link_rlib(&mut self, lib: &Path);\n+    fn link_whole_staticlib(&mut self, lib: &str, search_path: &[PathBuf]);\n+    fn include_path(&mut self, path: &Path);\n+    fn framework_path(&mut self, path: &Path);\n+    fn output_filename(&mut self, path: &Path);\n+    fn add_object(&mut self, path: &Path);\n+    fn gc_sections(&mut self, is_dylib: bool);\n+    fn position_independent_executable(&mut self);\n+    fn optimize(&mut self);\n+    fn no_default_libraries(&mut self);\n+    fn build_dylib(&mut self, out_filename: &Path);\n+    fn args(&mut self, args: &[String]);\n+    fn hint_static(&mut self);\n+    fn hint_dynamic(&mut self);\n+    fn whole_archives(&mut self);\n+    fn no_whole_archives(&mut self);\n+}\n+\n+pub struct GnuLinker<'a> {\n+    pub cmd: &'a mut Command,\n+    pub sess: &'a Session,\n+}\n+\n+impl<'a> GnuLinker<'a> {\n+    fn takes_hints(&self) -> bool {\n+        !self.sess.target.target.options.is_like_osx\n+    }\n+}\n+\n+impl<'a> Linker for GnuLinker<'a> {\n+    fn link_dylib(&mut self, lib: &str) { self.cmd.arg(\"-l\").arg(lib); }\n+    fn link_staticlib(&mut self, lib: &str) { self.cmd.arg(\"-l\").arg(lib); }\n+    fn link_rlib(&mut self, lib: &Path) { self.cmd.arg(lib); }\n+    fn include_path(&mut self, path: &Path) { self.cmd.arg(\"-L\").arg(path); }\n+    fn framework_path(&mut self, path: &Path) { self.cmd.arg(\"-F\").arg(path); }\n+    fn output_filename(&mut self, path: &Path) { self.cmd.arg(\"-o\").arg(path); }\n+    fn add_object(&mut self, path: &Path) { self.cmd.arg(path); }\n+    fn position_independent_executable(&mut self) { self.cmd.arg(\"-pie\"); }\n+    fn args(&mut self, args: &[String]) { self.cmd.args(args); }\n+\n+    fn link_framework(&mut self, framework: &str) {\n+        self.cmd.arg(\"-framework\").arg(framework);\n+    }\n+\n+    fn link_whole_staticlib(&mut self, lib: &str, search_path: &[PathBuf]) {\n+        let target = &self.sess.target.target;\n+        if !target.options.is_like_osx {\n+            self.cmd.arg(\"-Wl,--whole-archive\")\n+                    .arg(\"-l\").arg(lib)\n+                    .arg(\"-Wl,--no-whole-archive\");\n+        } else {\n+            // -force_load is the OSX equivalent of --whole-archive, but it\n+            // involves passing the full path to the library to link.\n+            let mut v = OsString::from(\"-Wl,-force_load,\");\n+            v.push(&archive::find_library(lib,\n+                                          &target.options.staticlib_prefix,\n+                                          &target.options.staticlib_suffix,\n+                                          search_path,\n+                                          &self.sess.diagnostic().handler));\n+            self.cmd.arg(&v);\n+        }\n+    }\n+\n+    fn gc_sections(&mut self, is_dylib: bool) {\n+        // The dead_strip option to the linker specifies that functions and data\n+        // unreachable by the entry point will be removed. This is quite useful\n+        // with Rust's compilation model of compiling libraries at a time into\n+        // one object file. For example, this brings hello world from 1.7MB to\n+        // 458K.\n+        //\n+        // Note that this is done for both executables and dynamic libraries. We\n+        // won't get much benefit from dylibs because LLVM will have already\n+        // stripped away as much as it could. This has not been seen to impact\n+        // link times negatively.\n+        //\n+        // -dead_strip can't be part of the pre_link_args because it's also used\n+        // for partial linking when using multiple codegen units (-r).  So we\n+        // insert it here.\n+        if self.sess.target.target.options.is_like_osx {\n+            self.cmd.arg(\"-Wl,-dead_strip\");\n+\n+        // If we're building a dylib, we don't use --gc-sections because LLVM\n+        // has already done the best it can do, and we also don't want to\n+        // eliminate the metadata. If we're building an executable, however,\n+        // --gc-sections drops the size of hello world from 1.8MB to 597K, a 67%\n+        // reduction.\n+        } else if !is_dylib {\n+            self.cmd.arg(\"-Wl,--gc-sections\");\n+        }\n+    }\n+\n+    fn optimize(&mut self) {\n+        if !self.sess.target.target.options.linker_is_gnu { return }\n+\n+        // GNU-style linkers support optimization with -O. GNU ld doesn't\n+        // need a numeric argument, but other linkers do.\n+        if self.sess.opts.optimize == config::Default ||\n+           self.sess.opts.optimize == config::Aggressive {\n+            self.cmd.arg(\"-Wl,-O1\");\n+        }\n+    }\n+\n+    fn no_default_libraries(&mut self) {\n+        // Unfortunately right now passing -nodefaultlibs to gcc on windows\n+        // doesn't work so hot (in terms of native dependencies). This if\n+        // statement should hopefully be removed one day though!\n+        if !self.sess.target.target.options.is_like_windows {\n+            self.cmd.arg(\"-nodefaultlibs\");\n+        }\n+    }\n+\n+    fn build_dylib(&mut self, out_filename: &Path) {\n+        // On mac we need to tell the linker to let this library be rpathed\n+        if self.sess.target.target.options.is_like_osx {\n+            self.cmd.args(&[\"-dynamiclib\", \"-Wl,-dylib\"]);\n+\n+            if self.sess.opts.cg.rpath {\n+                let mut v = OsString::from(\"-Wl,-install_name,@rpath/\");\n+                v.push(out_filename.file_name().unwrap());\n+                self.cmd.arg(&v);\n+            }\n+        } else {\n+            self.cmd.arg(\"-shared\");\n+        }\n+    }\n+\n+    fn whole_archives(&mut self) {\n+        if !self.takes_hints() { return }\n+        self.cmd.arg(\"-Wl,--whole-archive\");\n+    }\n+\n+    fn no_whole_archives(&mut self) {\n+        if !self.takes_hints() { return }\n+        self.cmd.arg(\"-Wl,--no-whole-archive\");\n+    }\n+\n+    fn hint_static(&mut self) {\n+        if !self.takes_hints() { return }\n+        self.cmd.arg(\"-Wl,-Bstatic\");\n+    }\n+\n+    fn hint_dynamic(&mut self) {\n+        if !self.takes_hints() { return }\n+        self.cmd.arg(\"-Wl,-Bdynamic\");\n+    }\n+}\n+\n+pub struct MsvcLinker<'a> {\n+    pub cmd: &'a mut Command,\n+    pub sess: &'a Session,\n+}\n+\n+impl<'a> Linker for MsvcLinker<'a> {\n+    fn link_rlib(&mut self, lib: &Path) { self.cmd.arg(lib); }\n+    fn add_object(&mut self, path: &Path) { self.cmd.arg(path); }\n+    fn args(&mut self, args: &[String]) { self.cmd.args(args); }\n+    fn build_dylib(&mut self, _out_filename: &Path) { self.cmd.arg(\"/DLL\"); }\n+    fn gc_sections(&mut self, _is_dylib: bool) { self.cmd.arg(\"/OPT:REF,ICF\"); }\n+\n+    fn link_dylib(&mut self, lib: &str) {\n+        self.cmd.arg(&format!(\"{}.lib\", lib));\n+    }\n+    fn link_staticlib(&mut self, lib: &str) {\n+        self.cmd.arg(&format!(\"{}.lib\", lib));\n+    }\n+\n+    fn position_independent_executable(&mut self) {\n+        // noop\n+    }\n+\n+    fn no_default_libraries(&mut self) {\n+        // Currently we don't pass the /NODEFAULTLIB flag to the linker on MSVC\n+        // as there's been trouble in the past of linking the C++ standard\n+        // library required by LLVM. This likely needs to happen one day, but\n+        // in general Windows is also a more controlled environment than\n+        // Unix, so it's not necessarily as critical that this be implemented.\n+        //\n+        // Note that there are also some licensing worries about statically\n+        // linking some libraries which require a specific agreement, so it may\n+        // not ever be possible for us to pass this flag.\n+    }\n+\n+    fn include_path(&mut self, path: &Path) {\n+        let mut arg = OsString::from(\"/LIBPATH:\");\n+        arg.push(path);\n+        self.cmd.arg(&arg);\n+    }\n+\n+    fn output_filename(&mut self, path: &Path) {\n+        let mut arg = OsString::from(\"/OUT:\");\n+        arg.push(path);\n+        self.cmd.arg(&arg);\n+    }\n+\n+    fn framework_path(&mut self, _path: &Path) {\n+        panic!(\"frameworks are not supported on windows\")\n+    }\n+    fn link_framework(&mut self, _framework: &str) {\n+        panic!(\"frameworks are not supported on windows\")\n+    }\n+\n+    fn link_whole_staticlib(&mut self, lib: &str, _search_path: &[PathBuf]) {\n+        // not supported?\n+        self.link_staticlib(lib);\n+    }\n+    fn optimize(&mut self) {\n+        // Needs more investigation of `/OPT` arguments\n+    }\n+    fn whole_archives(&mut self) {\n+        // hints not supported?\n+    }\n+    fn no_whole_archives(&mut self) {\n+        // hints not supported?\n+    }\n+\n+    // On windows static libraries are of the form `foo.lib` and dynamic\n+    // libraries are not linked against directly, but rather through their\n+    // import libraries also called `foo.lib`. As a result there's no\n+    // possibility for a native library to appear both dynamically and\n+    // statically in the same folder so we don't have to worry about hints like\n+    // we do on Unix platforms.\n+    fn hint_static(&mut self) {}\n+    fn hint_dynamic(&mut self) {}\n+}"}, {"sha": "a1220ab6ba86e46d6d6820be2e152f2373818c05", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -74,6 +74,7 @@ pub mod back {\n     pub use rustc_back::x86;\n     pub use rustc_back::x86_64;\n \n+    pub mod linker;\n     pub mod link;\n     pub mod lto;\n     pub mod write;"}, {"sha": "e44aae76c19ad9456e17b939e64e7678c72993d4", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -237,6 +237,9 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n             llvm::set_thread_local(c, true);\n         }\n     }\n+    if ccx.use_dll_storage_attrs() {\n+        llvm::SetDLLStorageClass(c, llvm::DLLImportStorageClass);\n+    }\n     ccx.externs().borrow_mut().insert(name.to_string(), c);\n     return c;\n }\n@@ -670,7 +673,8 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {\n-                    let llfn = foreign::register_foreign_item_fn(ccx, fn_ty.abi, t, &name[..]);\n+                    let llfn = foreign::register_foreign_item_fn(ccx, fn_ty.abi,\n+                                                                 t, &name);\n                     let attrs = csearch::get_item_attrs(&ccx.sess().cstore, did);\n                     attributes::from_fn_attrs(ccx, &attrs, llfn);\n                     llfn\n@@ -1938,11 +1942,17 @@ pub fn update_linkage(ccx: &CrateContext,\n     match id {\n         Some(id) if ccx.reachable().contains(&id) => {\n             llvm::SetLinkage(llval, llvm::ExternalLinkage);\n+            if ccx.use_dll_storage_attrs() {\n+                llvm::SetDLLStorageClass(llval, llvm::DLLExportStorageClass);\n+            }\n         },\n         _ => {\n             // `id` does not refer to an item in `ccx.reachable`.\n             if ccx.sess().opts.cg.codegen_units > 1 {\n                 llvm::SetLinkage(llval, llvm::ExternalLinkage);\n+                if ccx.use_dll_storage_attrs() {\n+                    llvm::SetDLLStorageClass(llval, llvm::DLLExportStorageClass);\n+                }\n             } else {\n                 llvm::SetLinkage(llval, llvm::InternalLinkage);\n             }\n@@ -2101,9 +2111,15 @@ fn finish_register_fn(ccx: &CrateContext, sym: String, node_id: ast::NodeId,\n     if ccx.tcx().lang_items.stack_exhausted() == Some(def) {\n         attributes::split_stack(llfn, false);\n         llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n+        if ccx.use_dll_storage_attrs() {\n+            llvm::SetDLLStorageClass(llfn, llvm::DLLExportStorageClass);\n+        }\n     }\n     if ccx.tcx().lang_items.eh_personality() == Some(def) {\n         llvm::SetLinkage(llfn, llvm::ExternalLinkage);\n+        if ccx.use_dll_storage_attrs() {\n+            llvm::SetDLLStorageClass(llfn, llvm::DLLExportStorageClass);\n+        }\n     }\n }\n \n@@ -2170,7 +2186,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n         // FIXME: #16581: Marking a symbol in the executable with `dllexport`\n         // linkage forces MinGW's linker to output a `.reloc` section for ASLR\n         if ccx.sess().target.target.options.is_like_windows {\n-            unsafe { llvm::LLVMRustSetDLLExportStorageClass(llfn) }\n+            llvm::SetDLLStorageClass(llfn, llvm::DLLExportStorageClass);\n         }\n \n         let llbb = unsafe {\n@@ -2526,7 +2542,7 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        let name = loader::meta_section_name(cx.sess().target.target.options.is_like_osx);\n+        let name = loader::meta_section_name(&cx.sess().target.target);\n         let name = CString::new(name).unwrap();\n         llvm::LLVMSetSection(llglobal, name.as_ptr())\n     }\n@@ -2587,6 +2603,7 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n                 if !declared.contains(&name) &&\n                    !reachable.contains(str::from_utf8(&name).unwrap()) {\n                     llvm::SetLinkage(val, llvm::InternalLinkage);\n+                    llvm::SetDLLStorageClass(val, llvm::DefaultStorageClass);\n                 }\n             }\n         }"}, {"sha": "51db0adf5b77508a8235aafea96ab99a9fee37c4", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -75,6 +75,7 @@ pub struct SharedCrateContext<'tcx> {\n \n     available_monomorphizations: RefCell<FnvHashSet<String>>,\n     available_drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, String>>,\n+    use_dll_storage_attrs: bool,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n@@ -251,6 +252,51 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             create_context_and_module(&tcx.sess, \"metadata\")\n         };\n \n+        // An interesting part of Windows which MSVC forces our hand on (and\n+        // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n+        // attributes in LLVM IR as well as native dependencies (in C these\n+        // correspond to `__declspec(dllimport)`).\n+        //\n+        // Whenever a dynamic library is built by MSVC it must have its public\n+        // interface specified by functions tagged with `dllexport` or otherwise\n+        // they're not available to be linked against. This poses a few problems\n+        // for the compiler, some of which are somewhat fundamental, but we use\n+        // the `use_dll_storage_attrs` variable below to attach the `dllexport`\n+        // attribute to all LLVM functions that are reachable (e.g. they're\n+        // already tagged with external linkage). This is suboptimal for a few\n+        // reasons:\n+        //\n+        // * If an object file will never be included in a dynamic library,\n+        //   there's no need to attach the dllexport attribute. Most object\n+        //   files in Rust are not destined to become part of a dll as binaries\n+        //   are statically linked by default.\n+        // * If the compiler is emitting both an rlib and a dylib, the same\n+        //   source object file is currently used but with MSVC this may be less\n+        //   feasible. The compiler may be able to get around this, but it may\n+        //   involve some invasive changes to deal with this.\n+        //\n+        // The flipside of this situation is that whenever you link to a dll and\n+        // you import a function from it, the import should be tagged with\n+        // `dllimport`. At this time, however, the compiler does not emit\n+        // `dllimport` for any declarations other than constants (where it is\n+        // required), which is again suboptimal for even more reasons!\n+        //\n+        // * Calling a function imported from another dll without using\n+        //   `dllimport` causes the linker/compiler to have extra overhead (one\n+        //   `jmp` instruction on x86) when calling the function.\n+        // * The same object file may be used in different circumstances, so a\n+        //   function may be imported from a dll if the object is linked into a\n+        //   dll, but it may be just linked against if linked into an rlib.\n+        // * The compiler has no knowledge about whether native functions should\n+        //   be tagged dllimport or not.\n+        //\n+        // For now the compiler takes the perf hit (I do not have any numbers to\n+        // this effect) by marking very little as `dllimport` and praying the\n+        // linker will take care of everything. Fixing this problem will likely\n+        // require adding a few attributes to Rust itself (feature gated at the\n+        // start) and then strongly recommending static linkage on MSVC!\n+        let use_dll_storage_attrs = tcx.sess.target.target.options.is_like_msvc;\n+\n         let mut shared_ccx = SharedCrateContext {\n             local_ccxs: Vec::with_capacity(local_count),\n             metadata_llmod: metadata_llmod,\n@@ -277,6 +323,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             check_drop_flag_for_sanity: check_drop_flag_for_sanity,\n             available_monomorphizations: RefCell::new(FnvHashSet()),\n             available_drop_glues: RefCell::new(FnvHashMap()),\n+            use_dll_storage_attrs: use_dll_storage_attrs,\n         };\n \n         for i in 0..local_count {\n@@ -365,6 +412,10 @@ impl<'tcx> SharedCrateContext<'tcx> {\n     pub fn stats<'a>(&'a self) -> &'a Stats {\n         &self.stats\n     }\n+\n+    pub fn use_dll_storage_attrs(&self) -> bool {\n+        self.use_dll_storage_attrs\n+    }\n }\n \n impl<'tcx> LocalCrateContext<'tcx> {\n@@ -733,6 +784,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         // values.\n         self.shared.check_drop_flag_for_sanity\n     }\n+\n+    pub fn use_dll_storage_attrs(&self) -> bool {\n+        self.shared.use_dll_storage_attrs()\n+    }\n }\n \n /// Declare any llvm intrinsics that you might need"}, {"sha": "4e5407016ba9b554a0a1d302800d825cc27686cf", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -193,7 +193,7 @@ pub fn finalize(cx: &CrateContext) {\n         // Prevent bitcode readers from deleting the debug info.\n         let ptr = \"Debug Info Version\\0\".as_ptr();\n         llvm::LLVMRustAddModuleFlag(cx.llmod(), ptr as *const _,\n-                                    llvm::LLVMRustDebugMetadataVersion);\n+                                    llvm::LLVMRustDebugMetadataVersion());\n     };\n }\n "}, {"sha": "e0ab5dec98dfeb9421d060ca8134e931ff4d1abe", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 51, "deletions": 47, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -9,14 +9,14 @@\n // except according to those terms.\n //! Declare various LLVM values.\n //!\n-//! Prefer using functions and methods from this module rather than calling LLVM functions\n-//! directly. These functions do some additional work to ensure we do the right thing given\n-//! the preconceptions of trans.\n+//! Prefer using functions and methods from this module rather than calling LLVM\n+//! functions directly. These functions do some additional work to ensure we do\n+//! the right thing given the preconceptions of trans.\n //!\n //! Some useful guidelines:\n //!\n-//! * Use declare_* family of methods if you are declaring, but are not interested in defining the\n-//! ValueRef they return.\n+//! * Use declare_* family of methods if you are declaring, but are not\n+//!   interested in defining the ValueRef they return.\n //! * Use define_* family of methods when you might be defining the ValueRef.\n //! * When in doubt, define.\n use llvm::{self, ValueRef};\n@@ -37,8 +37,8 @@ use libc::c_uint;\n \n /// Declare a global value.\n ///\n-/// If there\u2019s a value with the same name already declared, the function will return its ValueRef\n-/// instead.\n+/// If there\u2019s a value with the same name already declared, the function will\n+/// return its ValueRef instead.\n pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRef {\n     debug!(\"declare_global(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n@@ -54,10 +54,10 @@ pub fn declare_global(ccx: &CrateContext, name: &str, ty: Type) -> llvm::ValueRe\n ///\n /// For rust functions use `declare_rust_fn` instead.\n ///\n-/// If there\u2019s a value with the same name already declared, the function will update the\n-/// declaration and return existing ValueRef instead.\n-pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty: Type,\n-                  output: ty::FnOutput) -> ValueRef {\n+/// If there\u2019s a value with the same name already declared, the function will\n+/// update the declaration and return existing ValueRef instead.\n+pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv,\n+                  ty: Type, output: ty::FnOutput) -> ValueRef {\n     debug!(\"declare_fn(name={:?})\", name);\n     let namebuf = CString::new(name).unwrap_or_else(|_|{\n         ccx.sess().bug(&format!(\"name {:?} contains an interior null byte\", name))\n@@ -67,7 +67,8 @@ pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n     };\n \n     llvm::SetFunctionCallConv(llfn, callconv);\n-    // Function addresses in Rust are never significant, allowing functions to be merged.\n+    // Function addresses in Rust are never significant, allowing functions to\n+    // be merged.\n     llvm::SetUnnamedAddr(llfn, true);\n \n     if output == ty::FnDiverging {\n@@ -88,23 +89,25 @@ pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n \n /// Declare a C ABI function.\n ///\n-/// Only use this for foreign function ABIs and glue. For Rust functions use `declare_rust_fn`\n-/// instead.\n+/// Only use this for foreign function ABIs and glue. For Rust functions use\n+/// `declare_rust_fn` instead.\n ///\n-/// If there\u2019s a value with the same name already declared, the function will update the\n-/// declaration and return existing ValueRef instead.\n-pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type, output: ty::Ty) -> ValueRef {\n+/// If there\u2019s a value with the same name already declared, the function will\n+/// update the declaration and return existing ValueRef instead.\n+pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type,\n+                   output: ty::Ty) -> ValueRef {\n     declare_fn(ccx, name, llvm::CCallConv, fn_type, ty::FnConverging(output))\n }\n \n \n /// Declare a Rust function.\n ///\n-/// If there\u2019s a value with the same name already declared, the function will update the\n-/// declaration and return existing ValueRef instead.\n+/// If there\u2019s a value with the same name already declared, the function will\n+/// update the declaration and return existing ValueRef instead.\n pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                                  fn_type: ty::Ty<'tcx>) -> ValueRef {\n-    debug!(\"declare_rust_fn(name={:?}, fn_type={})\", name, fn_type.repr(ccx.tcx()));\n+    debug!(\"declare_rust_fn(name={:?}, fn_type={})\", name,\n+           fn_type.repr(ccx.tcx()));\n     let fn_type = monomorphize::normalize_associated_type(ccx.tcx(), &fn_type);\n     debug!(\"declare_rust_fn (after normalised associated types) fn_type={}\",\n            fn_type.repr(ccx.tcx()));\n@@ -131,7 +134,8 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n     let llfty = type_of::type_of_rust_fn(ccx, env, &sig, abi);\n     debug!(\"declare_rust_fn llfty={}\", ccx.tn().type_to_string(llfty));\n \n-    // it is ok to directly access sig.0.output because we erased all late-bound-regions above\n+    // it is ok to directly access sig.0.output because we erased all\n+    // late-bound-regions above\n     let llfn = declare_fn(ccx, name, llvm::CCallConv, llfty, sig.0.output);\n     attributes::from_fn_type(ccx, fn_type).apply_llfn(llfn);\n     llfn\n@@ -140,8 +144,8 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n \n /// Declare a Rust function with internal linkage.\n ///\n-/// If there\u2019s a value with the same name already declared, the function will update the\n-/// declaration and return existing ValueRef instead.\n+/// If there\u2019s a value with the same name already declared, the function will\n+/// update the declaration and return existing ValueRef instead.\n pub fn declare_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                                           fn_type: ty::Ty<'tcx>) -> ValueRef {\n     let llfn = declare_rust_fn(ccx, name, fn_type);\n@@ -152,10 +156,10 @@ pub fn declare_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &s\n \n /// Declare a global with an intention to define it.\n ///\n-/// Use this function when you intend to define a global. This function will return None if the\n-/// name already has a definition associated with it. In that case an error should be reported to\n-/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n-/// #[export_name] attributes).\n+/// Use this function when you intend to define a global. This function will\n+/// return None if the name already has a definition associated with it. In that\n+/// case an error should be reported to the user, because it usually happens due\n+/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRef> {\n     if get_defined_value(ccx, name).is_some() {\n         None\n@@ -169,10 +173,10 @@ pub fn define_global(ccx: &CrateContext, name: &str, ty: Type) -> Option<ValueRe\n ///\n /// For rust functions use `define_rust_fn` instead.\n ///\n-/// Use this function when you intend to define a function. This function will return None if the\n-/// name already has a definition associated with it. In that case an error should be reported to\n-/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n-/// #[export_name] attributes).\n+/// Use this function when you intend to define a function. This function will\n+/// return None if the name already has a definition associated with it. In that\n+/// case an error should be reported to the user, because it usually happens due\n+/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n pub fn define_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, fn_type: Type,\n                  output: ty::FnOutput) -> Option<ValueRef> {\n     if get_defined_value(ccx, name).is_some() {\n@@ -185,13 +189,13 @@ pub fn define_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, fn_ty\n \n /// Declare a C ABI function with an intention to define it.\n ///\n-/// Use this function when you intend to define a function. This function will return None if the\n-/// name already has a definition associated with it. In that case an error should be reported to\n-/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n-/// #[export_name] attributes).\n+/// Use this function when you intend to define a function. This function will\n+/// return None if the name already has a definition associated with it. In that\n+/// case an error should be reported to the user, because it usually happens due\n+/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n ///\n-/// Only use this for foreign function ABIs and glue. For Rust functions use `declare_rust_fn`\n-/// instead.\n+/// Only use this for foreign function ABIs and glue. For Rust functions use\n+/// `declare_rust_fn` instead.\n pub fn define_cfn(ccx: &CrateContext, name: &str, fn_type: Type,\n                   output: ty::Ty) -> Option<ValueRef> {\n     if get_defined_value(ccx, name).is_some() {\n@@ -204,10 +208,10 @@ pub fn define_cfn(ccx: &CrateContext, name: &str, fn_type: Type,\n \n /// Declare a Rust function with an intention to define it.\n ///\n-/// Use this function when you intend to define a function. This function will return None if the\n-/// name already has a definition associated with it. In that case an error should be reported to\n-/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n-/// #[export_name] attributes).\n+/// Use this function when you intend to define a function. This function will\n+/// return None if the name already has a definition associated with it. In that\n+/// case an error should be reported to the user, because it usually happens due\n+/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n pub fn define_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                                 fn_type: ty::Ty<'tcx>) -> Option<ValueRef> {\n     if get_defined_value(ccx, name).is_some() {\n@@ -220,10 +224,10 @@ pub fn define_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n \n /// Declare a Rust function with an intention to define it.\n ///\n-/// Use this function when you intend to define a function. This function will return None if the\n-/// name already has a definition associated with it. In that case an error should be reported to\n-/// the user, because it usually happens due to user\u2019s fault (e.g. misuse of #[no_mangle] or\n-/// #[export_name] attributes).\n+/// Use this function when you intend to define a function. This function will\n+/// return None if the name already has a definition associated with it. In that\n+/// case an error should be reported to the user, because it usually happens due\n+/// to user\u2019s fault (e.g. misuse of #[no_mangle] or #[export_name] attributes).\n pub fn define_internal_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                                          fn_type: ty::Ty<'tcx>) -> Option<ValueRef> {\n     if get_defined_value(ccx, name).is_some() {\n@@ -250,8 +254,8 @@ fn get_defined_value(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n             (llvm::LLVMIsDeclaration(val) != 0,\n              linkage == llvm::AvailableExternallyLinkage as c_uint)\n         };\n-        debug!(\"get_defined_value: found {:?} value (declaration: {}, aext_link: {})\", name,\n-               declaration, aext_link);\n+        debug!(\"get_defined_value: found {:?} value (declaration: {}, \\\n+                aext_link: {})\", name, declaration, aext_link);\n         if !declaration || aext_link {\n             Some(val)\n         } else {"}, {"sha": "e31d97b3240385c0b08283ae5f2e67d197575131", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -32,7 +32,6 @@ pub use core::f32::consts;\n mod cmath {\n     use libc::{c_float, c_int};\n \n-    #[link_name = \"m\"]\n     extern {\n         pub fn acosf(n: c_float) -> c_float;\n         pub fn asinf(n: c_float) -> c_float;\n@@ -44,13 +43,10 @@ mod cmath {\n         pub fn erfcf(n: c_float) -> c_float;\n         pub fn expm1f(n: c_float) -> c_float;\n         pub fn fdimf(a: c_float, b: c_float) -> c_float;\n-        pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;\n         pub fn fmaxf(a: c_float, b: c_float) -> c_float;\n         pub fn fminf(a: c_float, b: c_float) -> c_float;\n         pub fn fmodf(a: c_float, b: c_float) -> c_float;\n         pub fn nextafterf(x: c_float, y: c_float) -> c_float;\n-        pub fn hypotf(x: c_float, y: c_float) -> c_float;\n-        pub fn ldexpf(x: c_float, n: c_int) -> c_float;\n         pub fn logbf(n: c_float) -> c_float;\n         pub fn log1pf(n: c_float) -> c_float;\n         pub fn ilogbf(n: c_float) -> c_int;\n@@ -60,12 +56,27 @@ mod cmath {\n         pub fn tanhf(n: c_float) -> c_float;\n         pub fn tgammaf(n: c_float) -> c_float;\n \n-        #[cfg(unix)]\n+        #[cfg_attr(all(windows, target_env = \"msvc\"), link_name = \"__lgammaf_r\")]\n         pub fn lgammaf_r(n: c_float, sign: &mut c_int) -> c_float;\n+        #[cfg_attr(all(windows, target_env = \"msvc\"), link_name = \"_hypotf\")]\n+        pub fn hypotf(x: c_float, y: c_float) -> c_float;\n \n-        #[cfg(windows)]\n-        #[link_name=\"__lgammaf_r\"]\n-        pub fn lgammaf_r(n: c_float, sign: &mut c_int) -> c_float;\n+        #[cfg(any(unix, all(windows, not(target_env = \"msvc\"))))]\n+        pub fn frexpf(n: c_float, value: &mut c_int) -> c_float;\n+        #[cfg(any(unix, all(windows, not(target_env = \"msvc\"))))]\n+        pub fn ldexpf(x: c_float, n: c_int) -> c_float;\n+    }\n+\n+    #[cfg(all(windows, target_env = \"msvc\"))]\n+    pub unsafe fn ldexpf(x: c_float, n: c_int) -> c_float {\n+        f64::ldexp(x as f64, n as isize) as c_float\n+    }\n+\n+    #[cfg(all(windows, target_env = \"msvc\"))]\n+    pub unsafe fn frexpf(x: c_float, value: &mut c_int) -> c_float {\n+        let (a, b) = f64::frexp(x as f64);\n+        *value = b as c_int;\n+        a as c_float\n     }\n }\n "}, {"sha": "e87855ffd4eed8526b541ad312e92f79eb10d4c1", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -48,7 +48,6 @@ mod cmath {\n         pub fn fmod(a: c_double, b: c_double) -> c_double;\n         pub fn nextafter(x: c_double, y: c_double) -> c_double;\n         pub fn frexp(n: c_double, value: &mut c_int) -> c_double;\n-        pub fn hypot(x: c_double, y: c_double) -> c_double;\n         pub fn ldexp(x: c_double, n: c_int) -> c_double;\n         pub fn logb(n: c_double) -> c_double;\n         pub fn log1p(n: c_double) -> c_double;\n@@ -69,11 +68,11 @@ mod cmath {\n         pub fn y1(n: c_double) -> c_double;\n         pub fn yn(i: c_int, n: c_double) -> c_double;\n \n-        #[cfg(unix)]\n-        pub fn lgamma_r(n: c_double, sign: &mut c_int) -> c_double;\n-        #[cfg(windows)]\n-        #[link_name=\"__lgamma_r\"]\n+        #[cfg_attr(all(windows, target_env = \"msvc\"), link_name = \"__lgamma_r\")]\n         pub fn lgamma_r(n: c_double, sign: &mut c_int) -> c_double;\n+\n+        #[cfg_attr(all(windows, target_env = \"msvc\"), link_name = \"_hypot\")]\n+        pub fn hypot(x: c_double, y: c_double) -> c_double;\n     }\n }\n "}, {"sha": "885adf19ca1fc6e16ffd9d37ebbdeebe3f46f345", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -279,6 +279,7 @@ mod imp {\n     const CRYPT_VERIFYCONTEXT: DWORD = 0xF0000000;\n \n     #[allow(non_snake_case)]\n+    #[link(name = \"advapi32\")]\n     extern \"system\" {\n         fn CryptAcquireContextA(phProv: *mut HCRYPTPROV,\n                                 pszContainer: LPCSTR,"}, {"sha": "b24099505ed896a7207760b3c4139bf7e23f141c", "filename": "src/libstd/rt/unwind.rs", "status": "removed", "additions": 0, "deletions": 615, "changes": 615, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -1,615 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementation of Rust stack unwinding\n-//!\n-//! For background on exception handling and stack unwinding please see\n-//! \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n-//! documents linked from it.\n-//! These are also good reads:\n-//!     http://theofilos.cs.columbia.edu/blog/2013/09/22/base_abi/\n-//!     http://monoinfinito.wordpress.com/series/exception-handling-in-c/\n-//!     http://www.airs.com/blog/index.php?s=exception+frames\n-//!\n-//! ## A brief summary\n-//!\n-//! Exception handling happens in two phases: a search phase and a cleanup phase.\n-//!\n-//! In both phases the unwinder walks stack frames from top to bottom using\n-//! information from the stack frame unwind sections of the current process's\n-//! modules (\"module\" here refers to an OS module, i.e. an executable or a\n-//! dynamic library).\n-//!\n-//! For each stack frame, it invokes the associated \"personality routine\", whose\n-//! address is also stored in the unwind info section.\n-//!\n-//! In the search phase, the job of a personality routine is to examine exception\n-//! object being thrown, and to decide whether it should be caught at that stack\n-//! frame.  Once the handler frame has been identified, cleanup phase begins.\n-//!\n-//! In the cleanup phase, personality routines invoke cleanup code associated\n-//! with their stack frames (i.e. destructors).  Once stack has been unwound down\n-//! to the handler frame level, unwinding stops and the last personality routine\n-//! transfers control to its catch block.\n-//!\n-//! ## Frame unwind info registration\n-//!\n-//! Each module has its own frame unwind info section (usually \".eh_frame\"), and\n-//! unwinder needs to know about all of them in order for unwinding to be able to\n-//! cross module boundaries.\n-//!\n-//! On some platforms, like Linux, this is achieved by dynamically enumerating\n-//! currently loaded modules via the dl_iterate_phdr() API and finding all\n-//! .eh_frame sections.\n-//!\n-//! Others, like Windows, require modules to actively register their unwind info\n-//! sections by calling __register_frame_info() API at startup.  In the latter\n-//! case it is essential that there is only one copy of the unwinder runtime in\n-//! the process.  This is usually achieved by linking to the dynamic version of\n-//! the unwind runtime.\n-//!\n-//! Currently Rust uses unwind runtime provided by libgcc.\n-\n-use prelude::v1::*;\n-\n-use any::Any;\n-use boxed;\n-use cell::Cell;\n-use cmp;\n-use panicking;\n-use fmt;\n-use intrinsics;\n-use libc::c_void;\n-use mem;\n-use sync::atomic::{self, Ordering};\n-use sys_common::mutex::{Mutex, MUTEX_INIT};\n-\n-use rt::libunwind as uw;\n-\n-struct Exception {\n-    uwe: uw::_Unwind_Exception,\n-    cause: Option<Box<Any + Send + 'static>>,\n-}\n-\n-pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: u32);\n-\n-// Variables used for invoking callbacks when a thread starts to unwind.\n-//\n-// For more information, see below.\n-const MAX_CALLBACKS: usize = 16;\n-static CALLBACKS: [atomic::AtomicUsize; MAX_CALLBACKS] =\n-        [atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n-         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT];\n-static CALLBACK_CNT: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n-\n-thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n-\n-/// Invoke a closure, capturing the cause of panic if one occurs.\n-///\n-/// This function will return `Ok(())` if the closure did not panic, and will\n-/// return `Err(cause)` if the closure panics. The `cause` returned is the\n-/// object with which panic was originally invoked.\n-///\n-/// This function also is unsafe for a variety of reasons:\n-///\n-/// * This is not safe to call in a nested fashion. The unwinding\n-///   interface for Rust is designed to have at most one try/catch block per\n-///   thread, not multiple. No runtime checking is currently performed to uphold\n-///   this invariant, so this function is not safe. A nested try/catch block\n-///   may result in corruption of the outer try/catch block's state, especially\n-///   if this is used within a thread itself.\n-///\n-/// * It is not sound to trigger unwinding while already unwinding. Rust threads\n-///   have runtime checks in place to ensure this invariant, but it is not\n-///   guaranteed that a rust thread is in place when invoking this function.\n-///   Unwinding twice can lead to resource leaks where some destructors are not\n-///   run.\n-pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> {\n-    let mut f = Some(f);\n-\n-    let prev = PANICKING.with(|s| s.get());\n-    PANICKING.with(|s| s.set(false));\n-    let ep = rust_try(try_fn::<F>, &mut f as *mut _ as *mut c_void);\n-    PANICKING.with(|s| s.set(prev));\n-    return if ep.is_null() {\n-        Ok(())\n-    } else {\n-        let my_ep = ep as *mut Exception;\n-        rtdebug!(\"caught {}\", (*my_ep).uwe.exception_class);\n-        let cause = (*my_ep).cause.take();\n-        uw::_Unwind_DeleteException(ep);\n-        Err(cause.unwrap())\n-    };\n-\n-    extern fn try_fn<F: FnOnce()>(opt_closure: *mut c_void) {\n-        let opt_closure = opt_closure as *mut Option<F>;\n-        unsafe { (*opt_closure).take().unwrap()(); }\n-    }\n-\n-    #[link(name = \"rustrt_native\", kind = \"static\")]\n-    #[cfg(not(test))]\n-    extern {}\n-\n-    extern {\n-        // Rust's try-catch\n-        // When f(...) returns normally, the return value is null.\n-        // When f(...) throws, the return value is a pointer to the caught\n-        // exception object.\n-        fn rust_try(f: extern fn(*mut c_void),\n-                    data: *mut c_void) -> *mut uw::_Unwind_Exception;\n-    }\n-}\n-\n-/// Determines whether the current thread is unwinding because of panic.\n-pub fn panicking() -> bool {\n-    PANICKING.with(|s| s.get())\n-}\n-\n-// An uninlined, unmangled function upon which to slap yer breakpoints\n-#[inline(never)]\n-#[no_mangle]\n-#[allow(private_no_mangle_fns)]\n-fn rust_panic(cause: Box<Any + Send + 'static>) -> ! {\n-    rtdebug!(\"begin_unwind()\");\n-\n-    unsafe {\n-        let exception: Box<_> = box Exception {\n-            uwe: uw::_Unwind_Exception {\n-                exception_class: rust_exception_class(),\n-                exception_cleanup: exception_cleanup,\n-                private: [0; uw::unwinder_private_data_size],\n-            },\n-            cause: Some(cause),\n-        };\n-        let exception_param = boxed::into_raw(exception) as *mut uw::_Unwind_Exception;\n-        let error = uw::_Unwind_RaiseException(exception_param);\n-        rtabort!(\"Could not unwind stack, error = {}\", error as isize)\n-    }\n-\n-    extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n-                                exception: *mut uw::_Unwind_Exception) {\n-        rtdebug!(\"exception_cleanup()\");\n-        unsafe {\n-            let _: Box<Exception> = Box::from_raw(exception as *mut Exception);\n-        }\n-    }\n-}\n-\n-// Rust's exception class identifier.  This is used by personality routines to\n-// determine whether the exception was thrown by their own runtime.\n-fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n-    // M O Z \\0  R U S T -- vendor, language\n-    0x4d4f5a_00_52555354\n-}\n-\n-// We could implement our personality routine in pure Rust, however exception\n-// info decoding is tedious.  More importantly, personality routines have to\n-// handle various platform quirks, which are not fun to maintain.  For this\n-// reason, we attempt to reuse personality routine of the C language:\n-// __gcc_personality_v0.\n-//\n-// Since C does not support exception catching, __gcc_personality_v0 simply\n-// always returns _URC_CONTINUE_UNWIND in search phase, and always returns\n-// _URC_INSTALL_CONTEXT (i.e. \"invoke cleanup code\") in cleanup phase.\n-//\n-// This is pretty close to Rust's exception handling approach, except that Rust\n-// does have a single \"catch-all\" handler at the bottom of each thread's stack.\n-// So we have two versions of the personality routine:\n-// - rust_eh_personality, used by all cleanup landing pads, which never catches,\n-//   so the behavior of __gcc_personality_v0 is perfectly adequate there, and\n-// - rust_eh_personality_catch, used only by rust_try(), which always catches.\n-//\n-// Note, however, that for implementation simplicity, rust_eh_personality_catch\n-// lacks code to install a landing pad, so in order to obtain exception object\n-// pointer (which it needs to return upstream), rust_try() employs another trick:\n-// it calls into the nested rust_try_inner(), whose landing pad does not resume\n-// unwinds.  Instead, it extracts the exception pointer and performs a \"normal\"\n-// return.\n-//\n-// See also: rt/rust_try.ll\n-\n-#[cfg(all(not(target_arch = \"arm\"),\n-          not(all(windows, target_arch = \"x86_64\")),\n-          not(test)))]\n-#[doc(hidden)]\n-pub mod eabi {\n-    use rt::libunwind as uw;\n-    use libc::c_int;\n-\n-    extern \"C\" {\n-        fn __gcc_personality_v0(version: c_int,\n-                                actions: uw::_Unwind_Action,\n-                                exception_class: uw::_Unwind_Exception_Class,\n-                                ue_header: *mut uw::_Unwind_Exception,\n-                                context: *mut uw::_Unwind_Context)\n-            -> uw::_Unwind_Reason_Code;\n-    }\n-\n-    #[lang = \"eh_personality\"]\n-    #[no_mangle] // referenced from rust_try.ll\n-    #[allow(private_no_mangle_fns)]\n-    extern fn rust_eh_personality(\n-        version: c_int,\n-        actions: uw::_Unwind_Action,\n-        exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        unsafe {\n-            __gcc_personality_v0(version, actions, exception_class, ue_header,\n-                                 context)\n-        }\n-    }\n-\n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality_catch(\n-        _version: c_int,\n-        actions: uw::_Unwind_Action,\n-        _exception_class: uw::_Unwind_Exception_Class,\n-        _ue_header: *mut uw::_Unwind_Exception,\n-        _context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-\n-        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n-            uw::_URC_HANDLER_FOUND // catch!\n-        }\n-        else { // cleanup phase\n-            uw::_URC_INSTALL_CONTEXT\n-        }\n-    }\n-}\n-\n-// iOS on armv7 is using SjLj exceptions and therefore requires to use\n-// a specialized personality routine: __gcc_personality_sj0\n-\n-#[cfg(all(target_os = \"ios\", target_arch = \"arm\", not(test)))]\n-#[doc(hidden)]\n-pub mod eabi {\n-    use rt::libunwind as uw;\n-    use libc::c_int;\n-\n-    extern \"C\" {\n-        fn __gcc_personality_sj0(version: c_int,\n-                                actions: uw::_Unwind_Action,\n-                                exception_class: uw::_Unwind_Exception_Class,\n-                                ue_header: *mut uw::_Unwind_Exception,\n-                                context: *mut uw::_Unwind_Context)\n-            -> uw::_Unwind_Reason_Code;\n-    }\n-\n-    #[lang = \"eh_personality\"]\n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality(\n-        version: c_int,\n-        actions: uw::_Unwind_Action,\n-        exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        unsafe {\n-            __gcc_personality_sj0(version, actions, exception_class, ue_header,\n-                                  context)\n-        }\n-    }\n-\n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality_catch(\n-        _version: c_int,\n-        actions: uw::_Unwind_Action,\n-        _exception_class: uw::_Unwind_Exception_Class,\n-        _ue_header: *mut uw::_Unwind_Exception,\n-        _context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n-            uw::_URC_HANDLER_FOUND // catch!\n-        }\n-        else { // cleanup phase\n-            unsafe {\n-                __gcc_personality_sj0(_version, actions, _exception_class, _ue_header,\n-                                      _context)\n-            }\n-        }\n-    }\n-}\n-\n-\n-// ARM EHABI uses a slightly different personality routine signature,\n-// but otherwise works the same.\n-#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(test)))]\n-#[doc(hidden)]\n-pub mod eabi {\n-    use rt::libunwind as uw;\n-    use libc::c_int;\n-\n-    extern \"C\" {\n-        fn __gcc_personality_v0(state: uw::_Unwind_State,\n-                                ue_header: *mut uw::_Unwind_Exception,\n-                                context: *mut uw::_Unwind_Context)\n-            -> uw::_Unwind_Reason_Code;\n-    }\n-\n-    #[lang = \"eh_personality\"]\n-    #[no_mangle] // referenced from rust_try.ll\n-    #[allow(private_no_mangle_fns)]\n-    extern \"C\" fn rust_eh_personality(\n-        state: uw::_Unwind_State,\n-        ue_header: *mut uw::_Unwind_Exception,\n-        context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        unsafe {\n-            __gcc_personality_v0(state, ue_header, context)\n-        }\n-    }\n-\n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality_catch(\n-        state: uw::_Unwind_State,\n-        _ue_header: *mut uw::_Unwind_Exception,\n-        _context: *mut uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        if (state as c_int & uw::_US_ACTION_MASK as c_int)\n-                           == uw::_US_VIRTUAL_UNWIND_FRAME as c_int { // search phase\n-            uw::_URC_HANDLER_FOUND // catch!\n-        }\n-        else { // cleanup phase\n-            uw::_URC_INSTALL_CONTEXT\n-        }\n-    }\n-}\n-\n-// Win64 SEH (see http://msdn.microsoft.com/en-us/library/1eyas8tf.aspx)\n-//\n-// This looks a bit convoluted because rather than implementing a native SEH handler,\n-// GCC reuses the same personality routine as for the other architectures by wrapping it\n-// with an \"API translator\" layer (_GCC_specific_handler).\n-\n-#[cfg(all(windows, target_arch = \"x86_64\", not(test)))]\n-#[doc(hidden)]\n-#[allow(non_camel_case_types, non_snake_case)]\n-pub mod eabi {\n-    pub use self::EXCEPTION_DISPOSITION::*;\n-    use rt::libunwind as uw;\n-    use libc::{c_void, c_int};\n-\n-    #[repr(C)]\n-    pub struct EXCEPTION_RECORD;\n-    #[repr(C)]\n-    pub struct CONTEXT;\n-    #[repr(C)]\n-    pub struct DISPATCHER_CONTEXT;\n-\n-    #[repr(C)]\n-    #[derive(Copy, Clone)]\n-    pub enum EXCEPTION_DISPOSITION {\n-        ExceptionContinueExecution,\n-        ExceptionContinueSearch,\n-        ExceptionNestedException,\n-        ExceptionCollidedUnwind\n-    }\n-\n-    type _Unwind_Personality_Fn =\n-        extern \"C\" fn(\n-            version: c_int,\n-            actions: uw::_Unwind_Action,\n-            exception_class: uw::_Unwind_Exception_Class,\n-            ue_header: *mut uw::_Unwind_Exception,\n-            context: *mut uw::_Unwind_Context\n-        ) -> uw::_Unwind_Reason_Code;\n-\n-    extern \"C\" {\n-        fn __gcc_personality_seh0(\n-            exceptionRecord: *mut EXCEPTION_RECORD,\n-            establisherFrame: *mut c_void,\n-            contextRecord: *mut CONTEXT,\n-            dispatcherContext: *mut DISPATCHER_CONTEXT\n-        ) -> EXCEPTION_DISPOSITION;\n-\n-        fn _GCC_specific_handler(\n-            exceptionRecord: *mut EXCEPTION_RECORD,\n-            establisherFrame: *mut c_void,\n-            contextRecord: *mut CONTEXT,\n-            dispatcherContext: *mut DISPATCHER_CONTEXT,\n-            personality: _Unwind_Personality_Fn\n-        ) -> EXCEPTION_DISPOSITION;\n-    }\n-\n-    #[lang = \"eh_personality\"]\n-    #[no_mangle] // referenced from rust_try.ll\n-    #[allow(private_no_mangle_fns)]\n-    extern \"C\" fn rust_eh_personality(\n-        exceptionRecord: *mut EXCEPTION_RECORD,\n-        establisherFrame: *mut c_void,\n-        contextRecord: *mut CONTEXT,\n-        dispatcherContext: *mut DISPATCHER_CONTEXT\n-    ) -> EXCEPTION_DISPOSITION\n-    {\n-        unsafe {\n-            __gcc_personality_seh0(exceptionRecord, establisherFrame,\n-                                   contextRecord, dispatcherContext)\n-        }\n-    }\n-\n-    #[no_mangle] // referenced from rust_try.ll\n-    pub extern \"C\" fn rust_eh_personality_catch(\n-        exceptionRecord: *mut EXCEPTION_RECORD,\n-        establisherFrame: *mut c_void,\n-        contextRecord: *mut CONTEXT,\n-        dispatcherContext: *mut DISPATCHER_CONTEXT\n-    ) -> EXCEPTION_DISPOSITION\n-    {\n-        extern \"C\" fn inner(\n-                _version: c_int,\n-                actions: uw::_Unwind_Action,\n-                _exception_class: uw::_Unwind_Exception_Class,\n-                _ue_header: *mut uw::_Unwind_Exception,\n-                _context: *mut uw::_Unwind_Context\n-            ) -> uw::_Unwind_Reason_Code\n-        {\n-            if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n-                uw::_URC_HANDLER_FOUND // catch!\n-            }\n-            else { // cleanup phase\n-                uw::_URC_INSTALL_CONTEXT\n-            }\n-        }\n-\n-        unsafe {\n-            _GCC_specific_handler(exceptionRecord, establisherFrame,\n-                                  contextRecord, dispatcherContext,\n-                                  inner)\n-        }\n-    }\n-}\n-\n-#[cfg(not(test))]\n-/// Entry point of panic from the libcore crate.\n-#[lang = \"panic_fmt\"]\n-pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n-                                file: &'static str, line: u32) -> ! {\n-    begin_unwind_fmt(msg, &(file, line))\n-}\n-\n-/// The entry point for unwinding with a formatted message.\n-///\n-/// This is designed to reduce the amount of code required at the call\n-/// site as much as possible (so that `panic!()` has as low an impact\n-/// on (e.g.) the inlining of other functions as possible), by moving\n-/// the actual formatting into this shared place.\n-#[inline(never)] #[cold]\n-pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, u32)) -> ! {\n-    use fmt::Write;\n-\n-    // We do two allocations here, unfortunately. But (a) they're\n-    // required with the current scheme, and (b) we don't handle\n-    // panic + OOM properly anyway (see comment in begin_unwind\n-    // below).\n-\n-    let mut s = String::new();\n-    let _ = s.write_fmt(msg);\n-    begin_unwind_inner(Box::new(s), file_line)\n-}\n-\n-/// This is the entry point of unwinding for panic!() and assert!().\n-#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n-pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> ! {\n-    // Note that this should be the only allocation performed in this code path.\n-    // Currently this means that panic!() on OOM will invoke this code path,\n-    // but then again we're not really ready for panic on OOM anyway. If\n-    // we do start doing this, then we should propagate this allocation to\n-    // be performed in the parent of this thread instead of the thread that's\n-    // panicking.\n-\n-    // see below for why we do the `Any` coercion here.\n-    begin_unwind_inner(Box::new(msg), file_line)\n-}\n-\n-/// The core of the unwinding.\n-///\n-/// This is non-generic to avoid instantiation bloat in other crates\n-/// (which makes compilation of small crates noticeably slower). (Note:\n-/// we need the `Any` object anyway, we're not just creating it to\n-/// avoid being generic.)\n-///\n-/// Doing this split took the LLVM IR line counts of `fn main() { panic!()\n-/// }` from ~1900/3700 (-O/no opts) to 180/590.\n-#[inline(never)] #[cold] // this is the slow path, please never inline this\n-fn begin_unwind_inner(msg: Box<Any + Send>,\n-                      file_line: &(&'static str, u32)) -> ! {\n-    // Make sure the default failure handler is registered before we look at the\n-    // callbacks. We also use a raw sys-based mutex here instead of a\n-    // `std::sync` one as accessing TLS can cause weird recursive problems (and\n-    // we don't need poison checking).\n-    unsafe {\n-        static LOCK: Mutex = MUTEX_INIT;\n-        static mut INIT: bool = false;\n-        LOCK.lock();\n-        if !INIT {\n-            register(panicking::on_panic);\n-            INIT = true;\n-        }\n-        LOCK.unlock();\n-    }\n-\n-    // First, invoke call the user-defined callbacks triggered on thread panic.\n-    //\n-    // By the time that we see a callback has been registered (by reading\n-    // MAX_CALLBACKS), the actual callback itself may have not been stored yet,\n-    // so we just chalk it up to a race condition and move on to the next\n-    // callback. Additionally, CALLBACK_CNT may briefly be higher than\n-    // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n-    let callbacks = {\n-        let amt = CALLBACK_CNT.load(Ordering::SeqCst);\n-        &CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n-    };\n-    for cb in callbacks {\n-        match cb.load(Ordering::SeqCst) {\n-            0 => {}\n-            n => {\n-                let f: Callback = unsafe { mem::transmute(n) };\n-                let (file, line) = *file_line;\n-                f(&*msg, file, line);\n-            }\n-        }\n-    };\n-\n-    // Now that we've run all the necessary unwind callbacks, we actually\n-    // perform the unwinding.\n-    if panicking() {\n-        // If a thread panics while it's already unwinding then we\n-        // have limited options. Currently our preference is to\n-        // just abort. In the future we may consider resuming\n-        // unwinding or otherwise exiting the thread cleanly.\n-        rterrln!(\"thread panicked while panicking. aborting.\");\n-        unsafe { intrinsics::abort() }\n-    }\n-    PANICKING.with(|s| s.set(true));\n-    rust_panic(msg);\n-}\n-\n-/// Register a callback to be invoked when a thread unwinds.\n-///\n-/// This is an unsafe and experimental API which allows for an arbitrary\n-/// callback to be invoked when a thread panics. This callback is invoked on both\n-/// the initial unwinding and a double unwinding if one occurs. Additionally,\n-/// the local `Thread` will be in place for the duration of the callback, and\n-/// the callback must ensure that it remains in place once the callback returns.\n-///\n-/// Only a limited number of callbacks can be registered, and this function\n-/// returns whether the callback was successfully registered or not. It is not\n-/// currently possible to unregister a callback once it has been registered.\n-pub unsafe fn register(f: Callback) -> bool {\n-    match CALLBACK_CNT.fetch_add(1, Ordering::SeqCst) {\n-        // The invocation code has knowledge of this window where the count has\n-        // been incremented, but the callback has not been stored. We're\n-        // guaranteed that the slot we're storing into is 0.\n-        n if n < MAX_CALLBACKS => {\n-            let prev = CALLBACKS[n].swap(mem::transmute(f), Ordering::SeqCst);\n-            rtassert!(prev == 0);\n-            true\n-        }\n-        // If we accidentally bumped the count too high, pull it back.\n-        _ => {\n-            CALLBACK_CNT.store(MAX_CALLBACKS, Ordering::SeqCst);\n-            false\n-        }\n-    }\n-}"}, {"sha": "39b32a3f08e4970f72f3fd7fa3bf128688a09c55", "filename": "src/libstd/rt/unwind/gcc.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fgcc.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -0,0 +1,342 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use any::Any;\n+use boxed;\n+use libc::c_void;\n+use rt::libunwind as uw;\n+\n+struct Exception {\n+    uwe: uw::_Unwind_Exception,\n+    cause: Option<Box<Any + Send + 'static>>,\n+}\n+\n+pub unsafe fn panic(data: Box<Any + Send + 'static>) -> ! {\n+    let exception: Box<_> = box Exception {\n+        uwe: uw::_Unwind_Exception {\n+            exception_class: rust_exception_class(),\n+            exception_cleanup: exception_cleanup,\n+            private: [0; uw::unwinder_private_data_size],\n+        },\n+        cause: Some(data),\n+    };\n+    let exception_param = boxed::into_raw(exception) as *mut uw::_Unwind_Exception;\n+    let error = uw::_Unwind_RaiseException(exception_param);\n+    rtabort!(\"Could not unwind stack, error = {}\", error as isize);\n+\n+    extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n+                                exception: *mut uw::_Unwind_Exception) {\n+        rtdebug!(\"exception_cleanup()\");\n+        unsafe {\n+            let _: Box<Exception> = Box::from_raw(exception as *mut Exception);\n+        }\n+    }\n+}\n+\n+pub unsafe fn cleanup(ptr: *mut c_void) -> Box<Any + Send + 'static> {\n+    let my_ep = ptr as *mut Exception;\n+    rtdebug!(\"caught {}\", (*my_ep).uwe.exception_class);\n+    let cause = (*my_ep).cause.take();\n+    uw::_Unwind_DeleteException(ptr as *mut _);\n+    cause.unwrap()\n+}\n+\n+// Rust's exception class identifier.  This is used by personality routines to\n+// determine whether the exception was thrown by their own runtime.\n+fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n+    // M O Z \\0  R U S T -- vendor, language\n+    0x4d4f5a_00_52555354\n+}\n+\n+// We could implement our personality routine in pure Rust, however exception\n+// info decoding is tedious.  More importantly, personality routines have to\n+// handle various platform quirks, which are not fun to maintain.  For this\n+// reason, we attempt to reuse personality routine of the C language:\n+// __gcc_personality_v0.\n+//\n+// Since C does not support exception catching, __gcc_personality_v0 simply\n+// always returns _URC_CONTINUE_UNWIND in search phase, and always returns\n+// _URC_INSTALL_CONTEXT (i.e. \"invoke cleanup code\") in cleanup phase.\n+//\n+// This is pretty close to Rust's exception handling approach, except that Rust\n+// does have a single \"catch-all\" handler at the bottom of each thread's stack.\n+// So we have two versions of the personality routine:\n+// - rust_eh_personality, used by all cleanup landing pads, which never catches,\n+//   so the behavior of __gcc_personality_v0 is perfectly adequate there, and\n+// - rust_eh_personality_catch, used only by rust_try(), which always catches.\n+//\n+// Note, however, that for implementation simplicity, rust_eh_personality_catch\n+// lacks code to install a landing pad, so in order to obtain exception object\n+// pointer (which it needs to return upstream), rust_try() employs another trick:\n+// it calls into the nested rust_try_inner(), whose landing pad does not resume\n+// unwinds.  Instead, it extracts the exception pointer and performs a \"normal\"\n+// return.\n+//\n+// See also: rt/rust_try.ll\n+\n+#[cfg(all(not(target_arch = \"arm\"),\n+          not(all(windows, target_arch = \"x86_64\")),\n+          not(test)))]\n+pub mod eabi {\n+    use rt::libunwind as uw;\n+    use libc::c_int;\n+\n+    extern \"C\" {\n+        fn __gcc_personality_v0(version: c_int,\n+                                actions: uw::_Unwind_Action,\n+                                exception_class: uw::_Unwind_Exception_Class,\n+                                ue_header: *mut uw::_Unwind_Exception,\n+                                context: *mut uw::_Unwind_Context)\n+            -> uw::_Unwind_Reason_Code;\n+    }\n+\n+    #[lang=\"eh_personality\"]\n+    #[no_mangle] // referenced from rust_try.ll\n+    #[allow(private_no_mangle_fns)]\n+    extern fn rust_eh_personality(\n+        version: c_int,\n+        actions: uw::_Unwind_Action,\n+        exception_class: uw::_Unwind_Exception_Class,\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        unsafe {\n+            __gcc_personality_v0(version, actions, exception_class, ue_header,\n+                                 context)\n+        }\n+    }\n+\n+    #[no_mangle] // referenced from rust_try.ll\n+    pub extern \"C\" fn rust_eh_personality_catch(\n+        _version: c_int,\n+        actions: uw::_Unwind_Action,\n+        _exception_class: uw::_Unwind_Exception_Class,\n+        _ue_header: *mut uw::_Unwind_Exception,\n+        _context: *mut uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+\n+        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n+            uw::_URC_HANDLER_FOUND // catch!\n+        }\n+        else { // cleanup phase\n+            uw::_URC_INSTALL_CONTEXT\n+        }\n+    }\n+}\n+\n+// iOS on armv7 is using SjLj exceptions and therefore requires to use\n+// a specialized personality routine: __gcc_personality_sj0\n+\n+#[cfg(all(target_os = \"ios\", target_arch = \"arm\", not(test)))]\n+pub mod eabi {\n+    use rt::libunwind as uw;\n+    use libc::c_int;\n+\n+    extern \"C\" {\n+        fn __gcc_personality_sj0(version: c_int,\n+                                actions: uw::_Unwind_Action,\n+                                exception_class: uw::_Unwind_Exception_Class,\n+                                ue_header: *mut uw::_Unwind_Exception,\n+                                context: *mut uw::_Unwind_Context)\n+            -> uw::_Unwind_Reason_Code;\n+    }\n+\n+    #[lang=\"eh_personality\"]\n+    #[no_mangle] // referenced from rust_try.ll\n+    pub extern \"C\" fn rust_eh_personality(\n+        version: c_int,\n+        actions: uw::_Unwind_Action,\n+        exception_class: uw::_Unwind_Exception_Class,\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        unsafe {\n+            __gcc_personality_sj0(version, actions, exception_class, ue_header,\n+                                  context)\n+        }\n+    }\n+\n+    #[no_mangle] // referenced from rust_try.ll\n+    pub extern \"C\" fn rust_eh_personality_catch(\n+        _version: c_int,\n+        actions: uw::_Unwind_Action,\n+        _exception_class: uw::_Unwind_Exception_Class,\n+        _ue_header: *mut uw::_Unwind_Exception,\n+        _context: *mut uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n+            uw::_URC_HANDLER_FOUND // catch!\n+        }\n+        else { // cleanup phase\n+            unsafe {\n+                __gcc_personality_sj0(_version, actions, _exception_class, _ue_header,\n+                                      _context)\n+            }\n+        }\n+    }\n+}\n+\n+\n+// ARM EHABI uses a slightly different personality routine signature,\n+// but otherwise works the same.\n+#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(test)))]\n+pub mod eabi {\n+    use rt::libunwind as uw;\n+    use libc::c_int;\n+\n+    extern \"C\" {\n+        fn __gcc_personality_v0(state: uw::_Unwind_State,\n+                                ue_header: *mut uw::_Unwind_Exception,\n+                                context: *mut uw::_Unwind_Context)\n+            -> uw::_Unwind_Reason_Code;\n+    }\n+\n+    #[lang=\"eh_personality\"]\n+    #[no_mangle] // referenced from rust_try.ll\n+    #[allow(private_no_mangle_fns)]\n+    extern \"C\" fn rust_eh_personality(\n+        state: uw::_Unwind_State,\n+        ue_header: *mut uw::_Unwind_Exception,\n+        context: *mut uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        unsafe {\n+            __gcc_personality_v0(state, ue_header, context)\n+        }\n+    }\n+\n+    #[no_mangle] // referenced from rust_try.ll\n+    pub extern \"C\" fn rust_eh_personality_catch(\n+        state: uw::_Unwind_State,\n+        _ue_header: *mut uw::_Unwind_Exception,\n+        _context: *mut uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        if (state as c_int & uw::_US_ACTION_MASK as c_int)\n+                           == uw::_US_VIRTUAL_UNWIND_FRAME as c_int { // search phase\n+            uw::_URC_HANDLER_FOUND // catch!\n+        }\n+        else { // cleanup phase\n+            uw::_URC_INSTALL_CONTEXT\n+        }\n+    }\n+}\n+\n+// Win64 SEH (see http://msdn.microsoft.com/en-us/library/1eyas8tf.aspx)\n+//\n+// This looks a bit convoluted because rather than implementing a native SEH\n+// handler, GCC reuses the same personality routine as for the other\n+// architectures by wrapping it with an \"API translator\" layer\n+// (_GCC_specific_handler).\n+\n+#[cfg(all(windows, target_arch = \"x86_64\", not(test)))]\n+#[doc(hidden)]\n+#[allow(non_camel_case_types, non_snake_case)]\n+pub mod eabi {\n+    pub use self::EXCEPTION_DISPOSITION::*;\n+    use rt::libunwind as uw;\n+    use libc::{c_void, c_int};\n+\n+    #[repr(C)]\n+    pub struct EXCEPTION_RECORD;\n+    #[repr(C)]\n+    pub struct CONTEXT;\n+    #[repr(C)]\n+    pub struct DISPATCHER_CONTEXT;\n+\n+    #[repr(C)]\n+    #[derive(Copy, Clone)]\n+    pub enum EXCEPTION_DISPOSITION {\n+        ExceptionContinueExecution,\n+        ExceptionContinueSearch,\n+        ExceptionNestedException,\n+        ExceptionCollidedUnwind\n+    }\n+\n+    type _Unwind_Personality_Fn =\n+        extern \"C\" fn(\n+            version: c_int,\n+            actions: uw::_Unwind_Action,\n+            exception_class: uw::_Unwind_Exception_Class,\n+            ue_header: *mut uw::_Unwind_Exception,\n+            context: *mut uw::_Unwind_Context\n+        ) -> uw::_Unwind_Reason_Code;\n+\n+    extern \"C\" {\n+        fn __gcc_personality_seh0(\n+            exceptionRecord: *mut EXCEPTION_RECORD,\n+            establisherFrame: *mut c_void,\n+            contextRecord: *mut CONTEXT,\n+            dispatcherContext: *mut DISPATCHER_CONTEXT\n+        ) -> EXCEPTION_DISPOSITION;\n+\n+        fn _GCC_specific_handler(\n+            exceptionRecord: *mut EXCEPTION_RECORD,\n+            establisherFrame: *mut c_void,\n+            contextRecord: *mut CONTEXT,\n+            dispatcherContext: *mut DISPATCHER_CONTEXT,\n+            personality: _Unwind_Personality_Fn\n+        ) -> EXCEPTION_DISPOSITION;\n+    }\n+\n+    #[lang=\"eh_personality\"]\n+    #[no_mangle] // referenced from rust_try.ll\n+    #[allow(private_no_mangle_fns)]\n+    extern \"C\" fn rust_eh_personality(\n+        exceptionRecord: *mut EXCEPTION_RECORD,\n+        establisherFrame: *mut c_void,\n+        contextRecord: *mut CONTEXT,\n+        dispatcherContext: *mut DISPATCHER_CONTEXT\n+    ) -> EXCEPTION_DISPOSITION\n+    {\n+        unsafe {\n+            __gcc_personality_seh0(exceptionRecord, establisherFrame,\n+                                   contextRecord, dispatcherContext)\n+        }\n+    }\n+\n+    #[no_mangle] // referenced from rust_try.ll\n+    pub extern \"C\" fn rust_eh_personality_catch(\n+        exceptionRecord: *mut EXCEPTION_RECORD,\n+        establisherFrame: *mut c_void,\n+        contextRecord: *mut CONTEXT,\n+        dispatcherContext: *mut DISPATCHER_CONTEXT\n+    ) -> EXCEPTION_DISPOSITION\n+    {\n+        extern \"C\" fn inner(\n+                _version: c_int,\n+                actions: uw::_Unwind_Action,\n+                _exception_class: uw::_Unwind_Exception_Class,\n+                _ue_header: *mut uw::_Unwind_Exception,\n+                _context: *mut uw::_Unwind_Context\n+            ) -> uw::_Unwind_Reason_Code\n+        {\n+            if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n+                uw::_URC_HANDLER_FOUND // catch!\n+            }\n+            else { // cleanup phase\n+                uw::_URC_INSTALL_CONTEXT\n+            }\n+        }\n+\n+        unsafe {\n+            _GCC_specific_handler(exceptionRecord, establisherFrame,\n+                                  contextRecord, dispatcherContext,\n+                                  inner)\n+        }\n+    }\n+}\n+"}, {"sha": "576035ffe9a027ec20b2635a7b163143f1820359", "filename": "src/libstd/rt/unwind/mod.rs", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibstd%2Frt%2Funwind%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibstd%2Frt%2Funwind%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fmod.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -0,0 +1,319 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of Rust stack unwinding\n+//!\n+//! For background on exception handling and stack unwinding please see\n+//! \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n+//! documents linked from it.\n+//! These are also good reads:\n+//!     http://theofilos.cs.columbia.edu/blog/2013/09/22/base_abi/\n+//!     http://monoinfinito.wordpress.com/series/exception-handling-in-c/\n+//!     http://www.airs.com/blog/index.php?s=exception+frames\n+//!\n+//! ## A brief summary\n+//!\n+//! Exception handling happens in two phases: a search phase and a cleanup phase.\n+//!\n+//! In both phases the unwinder walks stack frames from top to bottom using\n+//! information from the stack frame unwind sections of the current process's\n+//! modules (\"module\" here refers to an OS module, i.e. an executable or a\n+//! dynamic library).\n+//!\n+//! For each stack frame, it invokes the associated \"personality routine\", whose\n+//! address is also stored in the unwind info section.\n+//!\n+//! In the search phase, the job of a personality routine is to examine exception\n+//! object being thrown, and to decide whether it should be caught at that stack\n+//! frame.  Once the handler frame has been identified, cleanup phase begins.\n+//!\n+//! In the cleanup phase, personality routines invoke cleanup code associated\n+//! with their stack frames (i.e. destructors).  Once stack has been unwound down\n+//! to the handler frame level, unwinding stops and the last personality routine\n+//! transfers control to its catch block.\n+//!\n+//! ## Frame unwind info registration\n+//!\n+//! Each module has its own frame unwind info section (usually \".eh_frame\"), and\n+//! unwinder needs to know about all of them in order for unwinding to be able to\n+//! cross module boundaries.\n+//!\n+//! On some platforms, like Linux, this is achieved by dynamically enumerating\n+//! currently loaded modules via the dl_iterate_phdr() API and finding all\n+//! .eh_frame sections.\n+//!\n+//! Others, like Windows, require modules to actively register their unwind info\n+//! sections by calling __register_frame_info() API at startup.  In the latter\n+//! case it is essential that there is only one copy of the unwinder runtime in\n+//! the process.  This is usually achieved by linking to the dynamic version of\n+//! the unwind runtime.\n+//!\n+//! Currently Rust uses unwind runtime provided by libgcc.\n+\n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n+\n+use prelude::v1::*;\n+\n+use any::Any;\n+use boxed;\n+use cell::Cell;\n+use cmp;\n+use panicking;\n+use fmt;\n+use intrinsics;\n+use libc::c_void;\n+use mem;\n+use sync::atomic::{self, Ordering};\n+use sys_common::mutex::{Mutex, MUTEX_INIT};\n+\n+// The actual unwinding implementation is cfg'd here, and we've got two current\n+// implementations. One goes through SEH on Windows and the other goes through\n+// libgcc via the libunwind-like API.\n+#[cfg(target_env = \"msvc\")] #[path = \"seh.rs\"] #[doc(hidden)]\n+pub mod imp;\n+#[cfg(not(target_env = \"msvc\"))] #[path = \"gcc.rs\"] #[doc(hidden)]\n+pub mod imp;\n+\n+pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: u32);\n+\n+// Variables used for invoking callbacks when a thread starts to unwind.\n+//\n+// For more information, see below.\n+const MAX_CALLBACKS: usize = 16;\n+static CALLBACKS: [atomic::AtomicUsize; MAX_CALLBACKS] =\n+        [atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n+         atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT];\n+static CALLBACK_CNT: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+\n+thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n+\n+#[link(name = \"rustrt_native\", kind = \"static\")]\n+#[cfg(not(test))]\n+extern {}\n+\n+/// Invoke a closure, capturing the cause of panic if one occurs.\n+///\n+/// This function will return `Ok(())` if the closure did not panic, and will\n+/// return `Err(cause)` if the closure panics. The `cause` returned is the\n+/// object with which panic was originally invoked.\n+///\n+/// This function also is unsafe for a variety of reasons:\n+///\n+/// * This is not safe to call in a nested fashion. The unwinding\n+///   interface for Rust is designed to have at most one try/catch block per\n+///   thread, not multiple. No runtime checking is currently performed to uphold\n+///   this invariant, so this function is not safe. A nested try/catch block\n+///   may result in corruption of the outer try/catch block's state, especially\n+///   if this is used within a thread itself.\n+///\n+/// * It is not sound to trigger unwinding while already unwinding. Rust threads\n+///   have runtime checks in place to ensure this invariant, but it is not\n+///   guaranteed that a rust thread is in place when invoking this function.\n+///   Unwinding twice can lead to resource leaks where some destructors are not\n+///   run.\n+pub unsafe fn try<F: FnOnce()>(f: F) -> Result<(), Box<Any + Send>> {\n+    let mut f = Some(f);\n+    return inner_try(try_fn::<F>, &mut f as *mut _ as *mut c_void);\n+\n+    // If an inner function were not used here, then this generic function `try`\n+    // uses the native symbol `rust_try`, for which the code is statically\n+    // linked into the standard library. This means that the DLL for the\n+    // standard library must have `rust_try` as an exposed symbol that\n+    // downstream crates can link against (because monomorphizations of `try` in\n+    // downstream crates will have a reference to the `rust_try` symbol).\n+    //\n+    // On MSVC this requires the symbol `rust_try` to be tagged with\n+    // `dllexport`, but it's easier to not have conditional `src/rt/rust_try.ll`\n+    // files and instead just have this non-generic shim the compiler can take\n+    // care of exposing correctly.\n+    unsafe fn inner_try(f: extern fn(*mut c_void), data: *mut c_void)\n+                        -> Result<(), Box<Any + Send>> {\n+        let prev = PANICKING.with(|s| s.get());\n+        PANICKING.with(|s| s.set(false));\n+        let ep = rust_try(f, data);\n+        PANICKING.with(|s| s.set(prev));\n+        if ep.is_null() {\n+            Ok(())\n+        } else {\n+            Err(imp::cleanup(ep))\n+        }\n+    }\n+\n+    extern fn try_fn<F: FnOnce()>(opt_closure: *mut c_void) {\n+        let opt_closure = opt_closure as *mut Option<F>;\n+        unsafe { (*opt_closure).take().unwrap()(); }\n+    }\n+\n+    extern {\n+        // Rust's try-catch\n+        // When f(...) returns normally, the return value is null.\n+        // When f(...) throws, the return value is a pointer to the caught\n+        // exception object.\n+        fn rust_try(f: extern fn(*mut c_void),\n+                    data: *mut c_void) -> *mut c_void;\n+    }\n+}\n+\n+/// Determines whether the current thread is unwinding because of panic.\n+pub fn panicking() -> bool {\n+    PANICKING.with(|s| s.get())\n+}\n+\n+// An uninlined, unmangled function upon which to slap yer breakpoints\n+#[inline(never)]\n+#[no_mangle]\n+#[allow(private_no_mangle_fns)]\n+fn rust_panic(cause: Box<Any + Send + 'static>) -> ! {\n+    rtdebug!(\"begin_unwind()\");\n+    unsafe {\n+        imp::panic(cause)\n+    }\n+}\n+\n+#[cfg(not(test))]\n+/// Entry point of panic from the libcore crate.\n+#[lang = \"panic_fmt\"]\n+pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n+                                file: &'static str, line: u32) -> ! {\n+    begin_unwind_fmt(msg, &(file, line))\n+}\n+\n+/// The entry point for unwinding with a formatted message.\n+///\n+/// This is designed to reduce the amount of code required at the call\n+/// site as much as possible (so that `panic!()` has as low an impact\n+/// on (e.g.) the inlining of other functions as possible), by moving\n+/// the actual formatting into this shared place.\n+#[inline(never)] #[cold]\n+pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, u32)) -> ! {\n+    use fmt::Write;\n+\n+    // We do two allocations here, unfortunately. But (a) they're\n+    // required with the current scheme, and (b) we don't handle\n+    // panic + OOM properly anyway (see comment in begin_unwind\n+    // below).\n+\n+    let mut s = String::new();\n+    let _ = s.write_fmt(msg);\n+    begin_unwind_inner(Box::new(s), file_line)\n+}\n+\n+/// This is the entry point of unwinding for panic!() and assert!().\n+#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n+pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> ! {\n+    // Note that this should be the only allocation performed in this code path.\n+    // Currently this means that panic!() on OOM will invoke this code path,\n+    // but then again we're not really ready for panic on OOM anyway. If\n+    // we do start doing this, then we should propagate this allocation to\n+    // be performed in the parent of this thread instead of the thread that's\n+    // panicking.\n+\n+    // see below for why we do the `Any` coercion here.\n+    begin_unwind_inner(Box::new(msg), file_line)\n+}\n+\n+/// The core of the unwinding.\n+///\n+/// This is non-generic to avoid instantiation bloat in other crates\n+/// (which makes compilation of small crates noticeably slower). (Note:\n+/// we need the `Any` object anyway, we're not just creating it to\n+/// avoid being generic.)\n+///\n+/// Doing this split took the LLVM IR line counts of `fn main() { panic!()\n+/// }` from ~1900/3700 (-O/no opts) to 180/590.\n+#[inline(never)] #[cold] // this is the slow path, please never inline this\n+fn begin_unwind_inner(msg: Box<Any + Send>,\n+                      file_line: &(&'static str, u32)) -> ! {\n+    // Make sure the default failure handler is registered before we look at the\n+    // callbacks. We also use a raw sys-based mutex here instead of a\n+    // `std::sync` one as accessing TLS can cause weird recursive problems (and\n+    // we don't need poison checking).\n+    unsafe {\n+        static LOCK: Mutex = MUTEX_INIT;\n+        static mut INIT: bool = false;\n+        LOCK.lock();\n+        if !INIT {\n+            register(panicking::on_panic);\n+            INIT = true;\n+        }\n+        LOCK.unlock();\n+    }\n+\n+    // First, invoke call the user-defined callbacks triggered on thread panic.\n+    //\n+    // By the time that we see a callback has been registered (by reading\n+    // MAX_CALLBACKS), the actual callback itself may have not been stored yet,\n+    // so we just chalk it up to a race condition and move on to the next\n+    // callback. Additionally, CALLBACK_CNT may briefly be higher than\n+    // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n+    let callbacks = {\n+        let amt = CALLBACK_CNT.load(Ordering::SeqCst);\n+        &CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n+    };\n+    for cb in callbacks {\n+        match cb.load(Ordering::SeqCst) {\n+            0 => {}\n+            n => {\n+                let f: Callback = unsafe { mem::transmute(n) };\n+                let (file, line) = *file_line;\n+                f(&*msg, file, line);\n+            }\n+        }\n+    };\n+\n+    // Now that we've run all the necessary unwind callbacks, we actually\n+    // perform the unwinding.\n+    if panicking() {\n+        // If a thread panics while it's already unwinding then we\n+        // have limited options. Currently our preference is to\n+        // just abort. In the future we may consider resuming\n+        // unwinding or otherwise exiting the thread cleanly.\n+        rterrln!(\"thread panicked while panicking. aborting.\");\n+        unsafe { intrinsics::abort() }\n+    }\n+    PANICKING.with(|s| s.set(true));\n+    rust_panic(msg);\n+}\n+\n+/// Register a callback to be invoked when a thread unwinds.\n+///\n+/// This is an unsafe and experimental API which allows for an arbitrary\n+/// callback to be invoked when a thread panics. This callback is invoked on both\n+/// the initial unwinding and a double unwinding if one occurs. Additionally,\n+/// the local `Thread` will be in place for the duration of the callback, and\n+/// the callback must ensure that it remains in place once the callback returns.\n+///\n+/// Only a limited number of callbacks can be registered, and this function\n+/// returns whether the callback was successfully registered or not. It is not\n+/// currently possible to unregister a callback once it has been registered.\n+pub unsafe fn register(f: Callback) -> bool {\n+    match CALLBACK_CNT.fetch_add(1, Ordering::SeqCst) {\n+        // The invocation code has knowledge of this window where the count has\n+        // been incremented, but the callback has not been stored. We're\n+        // guaranteed that the slot we're storing into is 0.\n+        n if n < MAX_CALLBACKS => {\n+            let prev = CALLBACKS[n].swap(mem::transmute(f), Ordering::SeqCst);\n+            rtassert!(prev == 0);\n+            true\n+        }\n+        // If we accidentally bumped the count too high, pull it back.\n+        _ => {\n+            CALLBACK_CNT.store(MAX_CALLBACKS, Ordering::SeqCst);\n+            false\n+        }\n+    }\n+}"}, {"sha": "a72c1debe14e0eeb506bba1ec60a2d39b1f7d410", "filename": "src/libstd/rt/unwind/seh.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibstd%2Frt%2Funwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Flibstd%2Frt%2Funwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind%2Fseh.rs?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use any::Any;\n+use intrinsics;\n+use libc::c_void;\n+\n+pub unsafe fn panic(_data: Box<Any + Send + 'static>) -> ! {\n+    intrinsics::abort();\n+}\n+\n+pub unsafe fn cleanup(_ptr: *mut c_void) -> Box<Any + Send + 'static> {\n+    intrinsics::abort();\n+}\n+\n+#[lang = \"eh_personality\"]\n+#[no_mangle]\n+pub extern fn rust_eh_personality() {}\n+\n+#[no_mangle]\n+pub extern fn rust_eh_personality_catch() {}"}, {"sha": "92371e90aba0cc636b84f4447d0eefe572fc8544", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -14,7 +14,8 @@\n #include <assert.h>\n #include <stdlib.h>\n \n-#if !defined(__WIN32__)\n+\n+#if !defined(_WIN32)\n #include <dirent.h>\n #include <pthread.h>\n #include <signal.h>\n@@ -40,7 +41,15 @@\n \n /* Foreign builtins. */\n //include valgrind.h after stdint.h so that uintptr_t is defined for msys2 w64\n+#ifndef _WIN32\n #include \"valgrind/valgrind.h\"\n+#endif\n+\n+#if defined(_MSC_VER)\n+# define RUST_BUILTIN_API __declspec(dllexport)\n+#else\n+# define RUST_BUILTIN_API\n+#endif\n \n #ifndef _WIN32\n char*\n@@ -84,12 +93,7 @@ rust_dirent_t_size() {\n }\n #endif\n \n-uintptr_t\n-rust_running_on_valgrind() {\n-    return RUNNING_ON_VALGRIND;\n-}\n-\n-#if defined(__WIN32__)\n+#if defined(_WIN32)\n int\n get_num_cpus() {\n     SYSTEM_INFO sysinfo;\n@@ -131,19 +135,19 @@ get_num_cpus() {\n }\n #endif\n \n+RUST_BUILTIN_API\n uintptr_t\n rust_get_num_cpus() {\n     return get_num_cpus();\n }\n \n-unsigned int\n-rust_valgrind_stack_register(void *start, void *end) {\n-  return VALGRIND_STACK_REGISTER(start, end);\n-}\n-\n-void\n-rust_valgrind_stack_deregister(unsigned int id) {\n-  VALGRIND_STACK_DEREGISTER(id);\n+uintptr_t\n+rust_running_on_valgrind() {\n+#ifdef _WIN32\n+    return 0;\n+#else\n+    return RUNNING_ON_VALGRIND;\n+#endif\n }\n \n #if defined(__DragonFly__)"}, {"sha": "8824cef2a816c153ea468796cebea190d99a91f6", "filename": "src/rt/rust_test_helpers.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Frt%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Frt%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.c?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -135,6 +135,8 @@ struct ManyInts {\n     struct TwoU8s arg6;\n };\n \n+// MSVC doesn't allow empty structs or unions\n+#ifndef _MSC_VER\n struct Empty {\n };\n \n@@ -148,6 +150,7 @@ rust_dbg_extern_empty_struct(struct ManyInts v1, struct Empty e, struct ManyInts\n     assert(v1.arg6.one == v2.arg6.one + 1);\n     assert(v1.arg6.two == v2.arg6.two + 1);\n }\n+#endif\n \n intptr_t\n rust_get_test_int() {\n@@ -191,9 +194,7 @@ rust_dbg_abi_2(struct floats f) {\n }\n \n int\n-rust_dbg_static_mut;\n-\n-int rust_dbg_static_mut = 3;\n+rust_dbg_static_mut = 3;\n \n void\n rust_dbg_static_mut_check_four() {"}, {"sha": "66db7326d21bf45c94d586cb7f4cd94998365e32", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/43cf733bfa5affc74485daeae179cc2f855b5512/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=43cf733bfa5affc74485daeae179cc2f855b5512", "patch": "@@ -233,7 +233,9 @@ DIT unwrapDI(LLVMMetadataRef ref) {\n     return DIT(ref ? unwrap<MDNode>(ref) : NULL);\n }\n \n-extern \"C\" const uint32_t LLVMRustDebugMetadataVersion = DEBUG_METADATA_VERSION;\n+extern \"C\" const uint32_t LLVMRustDebugMetadataVersion() {\n+    return DEBUG_METADATA_VERSION;\n+}\n \n extern \"C\" void LLVMRustAddModuleFlag(LLVMModuleRef M,\n                                       const char *name,\n@@ -837,9 +839,10 @@ LLVMRustArchiveChildData(Archive::Child *child, size_t *size) {\n }\n \n extern \"C\" void\n-LLVMRustSetDLLExportStorageClass(LLVMValueRef Value) {\n+LLVMRustSetDLLStorageClass(LLVMValueRef Value,\n+                           GlobalValue::DLLStorageClassTypes Class) {\n     GlobalValue *V = unwrap<GlobalValue>(Value);\n-    V->setDLLStorageClass(GlobalValue::DLLExportStorageClass);\n+    V->setDLLStorageClass(Class);\n }\n \n // Note that the two following functions look quite similar to the"}]}