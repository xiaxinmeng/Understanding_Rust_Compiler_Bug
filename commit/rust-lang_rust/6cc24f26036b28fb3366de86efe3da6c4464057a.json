{"sha": "6cc24f26036b28fb3366de86efe3da6c4464057a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjYzI0ZjI2MDM2YjI4ZmIzMzY2ZGU4NmVmZTNkYTZjNDQ2NDA1N2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-01T12:21:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-01T12:21:04Z"}, "message": "Auto merge of #60137 - eddyb:rustdoc-rm-def-ctor-hax, r=petrochenkov\n\nrustdoc: remove def_ctor hack.\n\n~~No longer necessary since we have `describe_def`.~~\n\nTurns out `def_ctor` was used in conjunction with abusing `tcx.type_of(def_id)` working on both type definitions and `impl`s (specifically, of builtin types), but also reimplementing a lot of the logic that `Clean` already provides on `Ty` / `ty::TraitRef`.\n\nThe first commit now does the minimal refactor to keep it working, while the second commit contains the rest of the refactor I started (parts of which I'm not sure we need to keep).", "tree": {"sha": "e551218300e5ff738313096ac47bc9c377394c7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e551218300e5ff738313096ac47bc9c377394c7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cc24f26036b28fb3366de86efe3da6c4464057a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cc24f26036b28fb3366de86efe3da6c4464057a", "html_url": "https://github.com/rust-lang/rust/commit/6cc24f26036b28fb3366de86efe3da6c4464057a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cc24f26036b28fb3366de86efe3da6c4464057a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47e0803d5c2ad5952220f2c260d7e12921c1d3fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/47e0803d5c2ad5952220f2c260d7e12921c1d3fe", "html_url": "https://github.com/rust-lang/rust/commit/47e0803d5c2ad5952220f2c260d7e12921c1d3fe"}, {"sha": "be9f43e0d4f365b9c1fa895946404693b624236d", "url": "https://api.github.com/repos/rust-lang/rust/commits/be9f43e0d4f365b9c1fa895946404693b624236d", "html_url": "https://github.com/rust-lang/rust/commit/be9f43e0d4f365b9c1fa895946404693b624236d"}], "stats": {"total": 873, "additions": 204, "deletions": 669}, "files": [{"sha": "57f5e23918884beee1911e713490425b8ca12969", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 26, "deletions": 62, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=6cc24f26036b28fb3366de86efe3da6c4464057a", "patch": "@@ -44,7 +44,6 @@ impl<A> AutoTraitResult<A> {\n pub struct AutoTraitInfo<'cx> {\n     pub full_user_env: ty::ParamEnv<'cx>,\n     pub region_data: RegionConstraintData<'cx>,\n-    pub names_map: FxHashSet<String>,\n     pub vid_to_region: FxHashMap<ty::RegionVid, ty::Region<'cx>>,\n }\n \n@@ -77,15 +76,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     /// in the future.\n     pub fn find_auto_trait_generics<A>(\n         &self,\n-        did: DefId,\n+        ty: Ty<'tcx>,\n+        orig_env: ty::ParamEnv<'tcx>,\n         trait_did: DefId,\n-        generics: &ty::Generics,\n         auto_trait_callback: impl for<'i> Fn(&InferCtxt<'_, 'tcx, 'i>, AutoTraitInfo<'i>) -> A,\n     ) -> AutoTraitResult<A> {\n         let tcx = self.tcx;\n-        let ty = self.tcx.type_of(did);\n-\n-        let orig_params = tcx.param_env(did);\n \n         let trait_ref = ty::TraitRef {\n             def_id: trait_did,\n@@ -98,16 +94,16 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             let mut selcx = SelectionContext::with_negative(&infcx, true);\n             let result = selcx.select(&Obligation::new(\n                 ObligationCause::dummy(),\n-                orig_params,\n+                orig_env,\n                 trait_pred.to_poly_trait_predicate(),\n             ));\n \n             match result {\n                 Ok(Some(Vtable::VtableImpl(_))) => {\n                     debug!(\n-                        \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): \\\n+                        \"find_auto_trait_generics({:?}): \\\n                          manual impl found, bailing out\",\n-                        did, trait_did, generics\n+                        trait_ref\n                     );\n                     true\n                 }\n@@ -158,11 +154,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n             let (new_env, user_env) = match self.evaluate_predicates(\n                 &mut infcx,\n-                did,\n                 trait_did,\n                 ty,\n-                orig_params.clone(),\n-                orig_params,\n+                orig_env,\n+                orig_env,\n                 &mut fresh_preds,\n                 false,\n             ) {\n@@ -172,24 +167,23 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n             let (full_env, full_user_env) = self.evaluate_predicates(\n                 &mut infcx,\n-                did,\n                 trait_did,\n                 ty,\n-                new_env.clone(),\n+                new_env,\n                 user_env,\n                 &mut fresh_preds,\n                 true,\n             ).unwrap_or_else(|| {\n                 panic!(\n                     \"Failed to fully process: {:?} {:?} {:?}\",\n-                    ty, trait_did, orig_params\n+                    ty, trait_did, orig_env\n                 )\n             });\n \n             debug!(\n-                \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): fulfilling \\\n+                \"find_auto_trait_generics({:?}): fulfilling \\\n                  with {:?}\",\n-                did, trait_did, generics, full_env\n+                trait_ref, full_env\n             );\n             infcx.clear_caches();\n \n@@ -211,23 +205,14 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 )\n             });\n \n-            let names_map: FxHashSet<String> = generics\n-                .params\n-                .iter()\n-                .filter_map(|param| match param.kind {\n-                    ty::GenericParamDefKind::Lifetime => Some(param.name.to_string()),\n-                    _ => None,\n-                })\n-                .collect();\n-\n             let body_id_map: FxHashMap<_, _> = infcx\n                 .region_obligations\n                 .borrow()\n                 .iter()\n                 .map(|&(id, _)| (id, vec![]))\n                 .collect();\n \n-            infcx.process_registered_region_obligations(&body_id_map, None, full_env.clone());\n+            infcx.process_registered_region_obligations(&body_id_map, None, full_env);\n \n             let region_data = infcx\n                 .borrow_region_constraints()\n@@ -239,7 +224,6 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             let info = AutoTraitInfo {\n                 full_user_env,\n                 region_data,\n-                names_map,\n                 vid_to_region,\n             };\n \n@@ -286,10 +270,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     // the final synthesized generics: we don't want our generated docs page to contain something\n     // like 'T: Copy + Clone', as that's redundant. Therefore, we keep track of a separate\n     // 'user_env', which only holds the predicates that will actually be displayed to the user.\n-    pub fn evaluate_predicates<'b, 'gcx, 'c>(\n+    fn evaluate_predicates<'b, 'gcx, 'c>(\n         &self,\n         infcx: &InferCtxt<'b, 'tcx, 'c>,\n-        ty_did: DefId,\n         trait_did: DefId,\n         ty: Ty<'c>,\n         param_env: ty::ParamEnv<'c>,\n@@ -314,13 +297,13 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         let mut user_computed_preds: FxHashSet<_> =\n             user_env.caller_bounds.iter().cloned().collect();\n \n-        let mut new_env = param_env.clone();\n+        let mut new_env = param_env;\n         let dummy_cause = ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID);\n \n         while let Some(pred) = predicates.pop_front() {\n             infcx.clear_caches();\n \n-            if !already_visited.insert(pred.clone()) {\n+            if !already_visited.insert(pred) {\n                 continue;\n             }\n \n@@ -368,7 +351,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                         already_visited.remove(&pred);\n                         self.add_user_pred(\n                             &mut user_computed_preds,\n-                            ty::Predicate::Trait(pred.clone()),\n+                            ty::Predicate::Trait(pred),\n                         );\n                         predicates.push_back(pred);\n                     } else {\n@@ -387,7 +370,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n             computed_preds.extend(user_computed_preds.iter().cloned());\n             let normalized_preds =\n-                elaborate_predicates(tcx, computed_preds.clone().into_iter().collect());\n+                elaborate_predicates(tcx, computed_preds.iter().cloned().collect());\n             new_env = ty::ParamEnv::new(\n                 tcx.mk_predicates(normalized_preds),\n                 param_env.reveal,\n@@ -401,9 +384,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             None\n         );\n         debug!(\n-            \"evaluate_nested_obligations(ty_did={:?}, trait_did={:?}): succeeded with '{:?}' \\\n+            \"evaluate_nested_obligations(ty={:?}, trait_did={:?}): succeeded with '{:?}' \\\n              '{:?}'\",\n-            ty_did, trait_did, new_env, final_user_env\n+            ty, trait_did, new_env, final_user_env\n         );\n \n         return Some((new_env, final_user_env));\n@@ -522,28 +505,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn region_name(&self, region: Region<'_>) -> Option<String> {\n-        match region {\n-            &ty::ReEarlyBound(r) => Some(r.name.to_string()),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn get_lifetime(&self, region: Region<'_>,\n-                        names_map: &FxHashMap<String, String>) -> String {\n-        self.region_name(region)\n-            .map(|name|\n-                names_map.get(&name).unwrap_or_else(||\n-                    panic!(\"Missing lifetime with name {:?} for {:?}\", name, region)\n-                )\n-            )\n-            .cloned()\n-            .unwrap_or_else(|| \"'static\".to_owned())\n-    }\n-\n     // This is very similar to handle_lifetimes. However, instead of matching ty::Region's\n     // to each other, we match ty::RegionVid's to ty::Region's\n-    pub fn map_vid_to_region<'cx>(\n+    fn map_vid_to_region<'cx>(\n         &self,\n         regions: &RegionConstraintData<'cx>,\n     ) -> FxHashMap<ty::RegionVid, ty::Region<'cx>> {\n@@ -653,7 +617,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn evaluate_nested_obligations<\n+    fn evaluate_nested_obligations<\n         'b,\n         'c,\n         'd,\n@@ -672,10 +636,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         let dummy_cause = ObligationCause::misc(DUMMY_SP, hir::DUMMY_HIR_ID);\n \n         for (obligation, mut predicate) in nested\n-            .map(|o| (o.clone(), o.predicate.clone()))\n+            .map(|o| (o.clone(), o.predicate))\n         {\n             let is_new_pred =\n-                fresh_preds.insert(self.clean_pred(select.infcx(), predicate.clone()));\n+                fresh_preds.insert(self.clean_pred(select.infcx(), predicate));\n \n             // Resolve any inference variables that we can, to help selection succeed\n             predicate = select.infcx().resolve_type_vars_if_possible(&predicate);\n@@ -693,14 +657,14 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             // We check this by calling is_of_param on the relevant types\n             // from the various possible predicates\n             match &predicate {\n-                &ty::Predicate::Trait(ref p) => {\n+                &ty::Predicate::Trait(p) => {\n                     if self.is_param_no_infer(p.skip_binder().trait_ref.substs)\n                         && !only_projections\n                         && is_new_pred {\n \n                         self.add_user_pred(computed_preds, predicate);\n                     }\n-                    predicates.push_back(p.clone());\n+                    predicates.push_back(p);\n                 }\n                 &ty::Predicate::Projection(p) => {\n                     debug!(\"evaluate_nested_obligations: examining projection predicate {:?}\",\n@@ -742,7 +706,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     if p.ty().skip_binder().has_infer_types() {\n                         debug!(\"Projecting and unifying projection predicate {:?}\",\n                                predicate);\n-                        match poly_project_and_unify_type(select, &obligation.with(p.clone())) {\n+                        match poly_project_and_unify_type(select, &obligation.with(p)) {\n                             Err(e) => {\n                                 debug!(\n                                     \"evaluate_nested_obligations: Unable to unify predicate \\"}, {"sha": "11e8192521d79901d131832bf575f83964fb90f9", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 86, "deletions": 164, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=6cc24f26036b28fb3366de86efe3da6c4464057a", "patch": "@@ -1,125 +1,89 @@\n use rustc::hir;\n-use rustc::traits::auto_trait as auto;\n+use rustc::traits::auto_trait::{self, AutoTraitResult};\n use rustc::ty::{self, TypeFoldable};\n use std::fmt::Debug;\n \n-use self::def_ctor::{get_def_from_def_id, get_def_from_hir_id};\n-\n use super::*;\n \n pub struct AutoTraitFinder<'a, 'tcx> {\n     pub cx: &'a core::DocContext<'tcx>,\n-    pub f: auto::AutoTraitFinder<'a, 'tcx>,\n+    pub f: auto_trait::AutoTraitFinder<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     pub fn new(cx: &'a core::DocContext<'tcx>) -> Self {\n-        let f = auto::AutoTraitFinder::new(cx.tcx);\n+        let f = auto_trait::AutoTraitFinder::new(cx.tcx);\n \n         AutoTraitFinder { cx, f }\n     }\n \n-    pub fn get_with_def_id(&self, def_id: DefId) -> Vec<Item> {\n-        get_def_from_def_id(&self.cx, def_id, &|def_ctor| {\n-            self.get_auto_trait_impls(def_id, &def_ctor, None)\n-        })\n-    }\n-\n-    pub fn get_with_hir_id(&self, id: hir::HirId, name: String) -> Vec<Item> {\n-        get_def_from_hir_id(&self.cx, id, name, &|def_ctor, name| {\n-            let did = self.cx.tcx.hir().local_def_id_from_hir_id(id);\n-            self.get_auto_trait_impls(did, &def_ctor, Some(name))\n-        })\n-    }\n-\n-    pub fn get_auto_trait_impls<F>(\n+    // FIXME(eddyb) figure out a better way to pass information about\n+    // parametrization of `ty` than `param_env_def_id`.\n+    pub fn get_auto_trait_impls(\n         &self,\n-        def_id: DefId,\n-        def_ctor: &F,\n-        name: Option<String>,\n-    ) -> Vec<Item>\n-    where F: Fn(DefId) -> Def {\n-        if self.cx\n-            .tcx\n-            .get_attrs(def_id)\n-            .lists(\"doc\")\n-            .has_word(\"hidden\")\n-        {\n-            debug!(\n-                \"get_auto_trait_impls(def_id={:?}, def_ctor=...): item has doc('hidden'), \\\n-                 aborting\",\n-                def_id\n-            );\n-            return Vec::new();\n-        }\n-\n-        let tcx = self.cx.tcx;\n-        let generics = self.cx.tcx.generics_of(def_id);\n-\n-        debug!(\n-            \"get_auto_trait_impls(def_id={:?}, def_ctor=..., generics={:?}\",\n-            def_id, generics\n+        ty: Ty<'tcx>,\n+        param_env_def_id: DefId,\n+    ) -> Vec<Item> {\n+        let param_env = self.cx.tcx.param_env(param_env_def_id);\n+\n+        debug!(\"get_auto_trait_impls({:?})\", ty);\n+        let auto_traits = self.cx.send_trait.into_iter().chain(\n+            Some(self.cx.tcx.require_lang_item(lang_items::SyncTraitLangItem))\n         );\n-        let auto_traits: Vec<_> = self.cx\n-            .send_trait\n-            .and_then(|send_trait| {\n-                self.get_auto_trait_impl_for(\n-                    def_id,\n-                    name.clone(),\n-                    generics.clone(),\n-                    def_ctor,\n-                    send_trait,\n-                )\n-            })\n-            .into_iter()\n-            .chain(self.get_auto_trait_impl_for(\n-                def_id,\n-                name,\n-                generics.clone(),\n-                def_ctor,\n-                tcx.require_lang_item(lang_items::SyncTraitLangItem),\n-            ).into_iter())\n-            .collect();\n+        auto_traits.filter_map(|trait_def_id| {\n+            let trait_ref = ty::TraitRef {\n+                def_id: trait_def_id,\n+                substs: self.cx.tcx.mk_substs_trait(ty, &[]),\n+            };\n+            if !self.cx\n+                .generated_synthetics\n+                .borrow_mut()\n+                .insert((ty, trait_def_id))\n+            {\n+                debug!(\n+                    \"get_auto_trait_impl_for({:?}): already generated, aborting\",\n+                    trait_ref\n+                );\n+                return None;\n+            }\n \n-        debug!(\n-            \"get_auto_traits: type {:?} auto_traits {:?}\",\n-            def_id, auto_traits\n-        );\n-        auto_traits\n-    }\n+            let result = self.f.find_auto_trait_generics(\n+                ty,\n+                param_env,\n+                trait_def_id,\n+                |infcx, info| {\n+                    let region_data = info.region_data;\n \n-    fn get_auto_trait_impl_for<F>(\n-        &self,\n-        def_id: DefId,\n-        name: Option<String>,\n-        generics: ty::Generics,\n-        def_ctor: &F,\n-        trait_def_id: DefId,\n-    ) -> Option<Item>\n-    where F: Fn(DefId) -> Def {\n-        if !self.cx\n-            .generated_synthetics\n-            .borrow_mut()\n-            .insert((def_id, trait_def_id))\n-        {\n-            debug!(\n-                \"get_auto_trait_impl_for(def_id={:?}, generics={:?}, def_ctor=..., \\\n-                 trait_def_id={:?}): already generated, aborting\",\n-                def_id, generics, trait_def_id\n-            );\n-            return None;\n-        }\n+                    let names_map = self.cx.tcx.generics_of(param_env_def_id)\n+                        .params\n+                        .iter()\n+                        .filter_map(|param| match param.kind {\n+                            ty::GenericParamDefKind::Lifetime => Some(param.name.to_string()),\n+                            _ => None,\n+                        })\n+                        .map(|name| (name.clone(), Lifetime(name)))\n+                        .collect();\n+                    let lifetime_predicates =\n+                        self.handle_lifetimes(&region_data, &names_map);\n+                    let new_generics = self.param_env_to_generics(\n+                        infcx.tcx,\n+                        param_env_def_id,\n+                        info.full_user_env,\n+                        lifetime_predicates,\n+                        info.vid_to_region,\n+                    );\n \n-        let result = self.find_auto_trait_generics(def_id, trait_def_id, &generics);\n+                    debug!(\n+                        \"find_auto_trait_generics(param_env_def_id={:?}, trait_def_id={:?}): \\\n+                            finished with {:?}\",\n+                        param_env_def_id, trait_def_id, new_generics\n+                    );\n \n-        if result.is_auto() {\n-            let trait_ = hir::TraitRef {\n-                path: get_path_for_type(self.cx.tcx, trait_def_id, hir::def::Def::Trait),\n-                hir_ref_id: hir::DUMMY_HIR_ID,\n-            };\n+                    new_generics\n+                },\n+            );\n \n             let polarity;\n-\n             let new_generics = match result {\n                 AutoTraitResult::PositiveImpl(new_generics) => {\n                     polarity = None;\n@@ -140,83 +104,38 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     // Instead, we generate `impl !Send for Foo<T>`, which better\n                     // expresses the fact that `Foo<T>` never implements `Send`,\n                     // regardless of the choice of `T`.\n-                    let real_generics = (&generics, &Default::default());\n-\n-                    // Clean the generics, but ignore the '?Sized' bounds generated\n-                    // by the `Clean` impl\n-                    let clean_generics = real_generics.clean(self.cx);\n+                    let params = (self.cx.tcx.generics_of(param_env_def_id), &Default::default())\n+                        .clean(self.cx).params;\n \n                     Generics {\n-                        params: clean_generics.params,\n+                        params,\n                         where_predicates: Vec::new(),\n                     }\n                 }\n-                _ => unreachable!(),\n+                AutoTraitResult::ExplicitImpl => return None,\n             };\n-            let real_name = name.map(|name| Ident::from_str(&name));\n-            let ty = self.cx.get_real_ty(def_id, def_ctor, &real_name, &generics);\n \n-            return Some(Item {\n+            Some(Item {\n                 source: Span::empty(),\n                 name: None,\n                 attrs: Default::default(),\n                 visibility: None,\n-                def_id: self.cx.next_def_id(def_id.krate),\n+                def_id: self.cx.next_def_id(param_env_def_id.krate),\n                 stability: None,\n                 deprecation: None,\n                 inner: ImplItem(Impl {\n                     unsafety: hir::Unsafety::Normal,\n                     generics: new_generics,\n                     provided_trait_methods: Default::default(),\n-                    trait_: Some(trait_.clean(self.cx)),\n+                    trait_: Some(trait_ref.clean(self.cx).get_trait_type().unwrap()),\n                     for_: ty.clean(self.cx),\n                     items: Vec::new(),\n                     polarity,\n                     synthetic: true,\n                     blanket_impl: None,\n                 }),\n-            });\n-        }\n-        None\n-    }\n-\n-    fn find_auto_trait_generics(\n-        &self,\n-        did: DefId,\n-        trait_did: DefId,\n-        generics: &ty::Generics,\n-    ) -> AutoTraitResult {\n-        match self.f.find_auto_trait_generics(did, trait_did, generics,\n-                |infcx, mut info| {\n-                    let region_data = info.region_data;\n-                    let names_map =\n-                        info.names_map\n-                            .drain()\n-                            .map(|name| (name.clone(), Lifetime(name)))\n-                            .collect();\n-                    let lifetime_predicates =\n-                        self.handle_lifetimes(&region_data, &names_map);\n-                    let new_generics = self.param_env_to_generics(\n-                        infcx.tcx,\n-                        did,\n-                        info.full_user_env,\n-                        generics.clone(),\n-                        lifetime_predicates,\n-                        info.vid_to_region,\n-                    );\n-\n-                    debug!(\n-                        \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): \\\n-                         finished with {:?}\",\n-                        did, trait_did, generics, new_generics\n-                    );\n-\n-                    new_generics\n-                }) {\n-            auto::AutoTraitResult::ExplicitImpl => AutoTraitResult::ExplicitImpl,\n-            auto::AutoTraitResult::NegativeImpl => AutoTraitResult::NegativeImpl,\n-            auto::AutoTraitResult::PositiveImpl(res) => AutoTraitResult::PositiveImpl(res),\n-        }\n+            })\n+        }).collect()\n     }\n \n     fn get_lifetime(\n@@ -530,16 +449,15 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     fn param_env_to_generics<'b, 'c, 'cx>(\n         &self,\n         tcx: TyCtxt<'b, 'c, 'cx>,\n-        did: DefId,\n+        param_env_def_id: DefId,\n         param_env: ty::ParamEnv<'cx>,\n-        type_generics: ty::Generics,\n         mut existing_predicates: Vec<WherePredicate>,\n         vid_to_region: FxHashMap<ty::RegionVid, ty::Region<'cx>>,\n     ) -> Generics {\n         debug!(\n-            \"param_env_to_generics(did={:?}, param_env={:?}, type_generics={:?}, \\\n+            \"param_env_to_generics(param_env_def_id={:?}, param_env={:?}, \\\n              existing_predicates={:?})\",\n-            did, param_env, type_generics, existing_predicates\n+            param_env_def_id, param_env, existing_predicates\n         );\n \n         // The `Sized` trait must be handled specially, since we only display it when\n@@ -553,7 +471,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             tcx,\n         };\n \n-        let orig_bounds: FxHashSet<_> = self.cx.tcx.param_env(did).caller_bounds.iter().collect();\n+        let orig_bounds: FxHashSet<_> =\n+            self.cx.tcx.param_env(param_env_def_id).caller_bounds.iter().collect();\n         let clean_where_predicates = param_env\n             .caller_bounds\n             .iter()\n@@ -568,11 +487,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 (replaced.clone(), replaced.clean(self.cx))\n             });\n \n-        let full_generics = (&type_generics, &tcx.explicit_predicates_of(did));\n-        let Generics {\n-            params: mut generic_params,\n-            ..\n-        } = full_generics.clean(self.cx);\n+        let mut generic_params = (\n+            tcx.generics_of(param_env_def_id),\n+            &tcx.explicit_predicates_of(param_env_def_id),\n+        ).clean(self.cx).params;\n \n         let mut has_sized = FxHashSet::default();\n         let mut ty_to_bounds: FxHashMap<_, FxHashSet<_>> = Default::default();\n@@ -757,10 +675,14 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                         .or_default()\n                                         .insert(*trait_.clone());\n                                 }\n-                                _ => panic!(\"Unexpected trait {:?} for {:?}\", trait_, did),\n+                                _ => panic!(\n+                                    \"Unexpected trait {:?} for {:?}\",\n+                                    trait_,\n+                                    param_env_def_id,\n+                                ),\n                             }\n                         }\n-                        _ => panic!(\"Unexpected LHS {:?} for {:?}\", lhs, did),\n+                        _ => panic!(\"Unexpected LHS {:?} for {:?}\", lhs, param_env_def_id),\n                     }\n                 }\n             };"}, {"sha": "5c42d705bd579e155bff1345a4a1cd24b5c9f25d", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 61, "deletions": 97, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=6cc24f26036b28fb3366de86efe3da6c4464057a", "patch": "@@ -9,8 +9,6 @@ use crate::core::DocAccessLevels;\n \n use super::*;\n \n-use self::def_ctor::{get_def_from_def_id, get_def_from_hir_id};\n-\n pub struct BlanketImplFinder<'a, 'tcx> {\n     pub cx: &'a core::DocContext<'tcx>,\n }\n@@ -20,67 +18,36 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n         BlanketImplFinder { cx }\n     }\n \n-    pub fn get_with_def_id(&self, def_id: DefId) -> Vec<Item> {\n-        get_def_from_def_id(&self.cx, def_id, &|def_ctor| {\n-            self.get_blanket_impls(def_id, &def_ctor, None)\n-        })\n-    }\n-\n-    pub fn get_with_hir_id(&self, id: hir::HirId, name: String) -> Vec<Item> {\n-        get_def_from_hir_id(&self.cx, id, name, &|def_ctor, name| {\n-            let did = self.cx.tcx.hir().local_def_id_from_hir_id(id);\n-            self.get_blanket_impls(did, &def_ctor, Some(name))\n-        })\n-    }\n-\n-    pub fn get_blanket_impls<F>(\n+    // FIXME(eddyb) figure out a better way to pass information about\n+    // parametrization of `ty` than `param_env_def_id`.\n+    pub fn get_blanket_impls(\n         &self,\n-        def_id: DefId,\n-        def_ctor: &F,\n-        name: Option<String>,\n-    ) -> Vec<Item>\n-    where F: Fn(DefId) -> Def {\n-        debug!(\"get_blanket_impls(def_id={:?}, ...)\", def_id);\n+        ty: Ty<'tcx>,\n+        param_env_def_id: DefId,\n+    ) -> Vec<Item> {\n+        let param_env = self.cx.tcx.param_env(param_env_def_id);\n+\n+        debug!(\"get_blanket_impls({:?})\", ty);\n         let mut impls = Vec::new();\n-        if self.cx\n-            .tcx\n-            .get_attrs(def_id)\n-            .lists(\"doc\")\n-            .has_word(\"hidden\")\n-        {\n-            debug!(\n-                \"get_blanket_impls(def_id={:?}, def_ctor=...): item has doc('hidden'), \\\n-                 aborting\",\n-                def_id\n-            );\n-            return impls;\n-        }\n-        let ty = self.cx.tcx.type_of(def_id);\n-        let generics = self.cx.tcx.generics_of(def_id);\n-        let real_name = name.map(|name| Ident::from_str(&name));\n-        let param_env = self.cx.tcx.param_env(def_id);\n         for &trait_def_id in self.cx.all_traits.iter() {\n             if !self.cx.renderinfo.borrow().access_levels.is_doc_reachable(trait_def_id) ||\n                self.cx.generated_synthetics\n                       .borrow_mut()\n-                      .get(&(def_id, trait_def_id))\n+                      .get(&(ty, trait_def_id))\n                       .is_some() {\n                 continue\n             }\n             self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n-                self.cx.tcx.infer_ctxt().enter(|infcx| {\n-                    debug!(\"get_blanet_impls: Considering impl for trait '{:?}' {:?}\",\n-                           trait_def_id, impl_def_id);\n-                    let t_generics = infcx.tcx.generics_of(impl_def_id);\n-                    let trait_ref = infcx.tcx.impl_trait_ref(impl_def_id)\n-                                             .expect(\"Cannot get impl trait\");\n-\n+                debug!(\"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n+                        trait_def_id, impl_def_id);\n+                let trait_ref = self.cx.tcx.impl_trait_ref(impl_def_id).unwrap();\n+                let may_apply = self.cx.tcx.infer_ctxt().enter(|infcx| {\n                     match trait_ref.self_ty().sty {\n                         ty::Param(_) => {},\n-                        _ => return,\n+                        _ => return false,\n                     }\n \n-                    let substs = infcx.fresh_substs_for_item(DUMMY_SP, def_id);\n+                    let substs = infcx.fresh_substs_for_item(DUMMY_SP, param_env_def_id);\n                     let ty = ty.subst(infcx.tcx, substs);\n                     let param_env = param_env.subst(infcx.tcx, substs);\n \n@@ -100,7 +67,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             \"invoking predicate_may_hold: param_env={:?}, trait_ref={:?}, ty={:?}\",\n                              param_env, trait_ref, ty\n                         );\n-                        let may_apply = match infcx.evaluate_obligation(\n+                        match infcx.evaluate_obligation(\n                             &traits::Obligation::new(\n                                 cause,\n                                 param_env,\n@@ -109,56 +76,53 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         ) {\n                             Ok(eval_result) => eval_result.may_apply(),\n                             Err(traits::OverflowError) => true, // overflow doesn't mean yes *or* no\n-                        };\n-                        debug!(\"get_blanket_impls: found applicable impl: {}\\\n-                               for trait_ref={:?}, ty={:?}\",\n-                               may_apply, trait_ref, ty);\n-\n-                        if !may_apply {\n-                            return\n                         }\n-                        self.cx.generated_synthetics.borrow_mut()\n-                                                    .insert((def_id, trait_def_id));\n-                        let trait_ = hir::TraitRef {\n-                            path: get_path_for_type(infcx.tcx,\n-                                                    trait_def_id,\n-                                                    hir::def::Def::Trait),\n-                            hir_ref_id: hir::DUMMY_HIR_ID,\n-                        };\n-                        let provided_trait_methods =\n-                            infcx.tcx.provided_trait_methods(trait_def_id)\n-                                     .into_iter()\n-                                     .map(|meth| meth.ident.to_string())\n-                                     .collect();\n-\n-                        let ty = self.cx.get_real_ty(def_id, def_ctor, &real_name, generics);\n-                        let predicates = infcx.tcx.explicit_predicates_of(impl_def_id);\n-\n-                        impls.push(Item {\n-                            source: infcx.tcx.def_span(impl_def_id).clean(self.cx),\n-                            name: None,\n-                            attrs: Default::default(),\n-                            visibility: None,\n-                            def_id: self.cx.next_def_id(impl_def_id.krate),\n-                            stability: None,\n-                            deprecation: None,\n-                            inner: ImplItem(Impl {\n-                                unsafety: hir::Unsafety::Normal,\n-                                generics: (t_generics, &predicates).clean(self.cx),\n-                                provided_trait_methods,\n-                                trait_: Some(trait_.clean(self.cx)),\n-                                for_: ty.clean(self.cx),\n-                                items: infcx.tcx.associated_items(impl_def_id)\n-                                                .collect::<Vec<_>>()\n-                                                .clean(self.cx),\n-                                polarity: None,\n-                                synthetic: false,\n-                                blanket_impl: Some(infcx.tcx.type_of(impl_def_id)\n-                                                            .clean(self.cx)),\n-                            }),\n-                        });\n+                    } else {\n+                        false\n                     }\n                 });\n+                debug!(\"get_blanket_impls: found applicable impl: {}\\\n+                        for trait_ref={:?}, ty={:?}\",\n+                        may_apply, trait_ref, ty);\n+                if !may_apply {\n+                    return;\n+                }\n+\n+                self.cx.generated_synthetics.borrow_mut()\n+                                            .insert((ty, trait_def_id));\n+                let provided_trait_methods =\n+                    self.cx.tcx.provided_trait_methods(trait_def_id)\n+                                .into_iter()\n+                                .map(|meth| meth.ident.to_string())\n+                                .collect();\n+\n+                impls.push(Item {\n+                    source: self.cx.tcx.def_span(impl_def_id).clean(self.cx),\n+                    name: None,\n+                    attrs: Default::default(),\n+                    visibility: None,\n+                    def_id: self.cx.next_def_id(impl_def_id.krate),\n+                    stability: None,\n+                    deprecation: None,\n+                    inner: ImplItem(Impl {\n+                        unsafety: hir::Unsafety::Normal,\n+                        generics: (\n+                            self.cx.tcx.generics_of(impl_def_id),\n+                            &self.cx.tcx.explicit_predicates_of(impl_def_id),\n+                        ).clean(self.cx),\n+                        provided_trait_methods,\n+                        // FIXME(eddyb) compute both `trait_` and `for_` from\n+                        // the post-inference `trait_ref`, as it's more accurate.\n+                        trait_: Some(trait_ref.clean(self.cx).get_trait_type().unwrap()),\n+                        for_: ty.clean(self.cx),\n+                        items: self.cx.tcx.associated_items(impl_def_id)\n+                                        .collect::<Vec<_>>()\n+                                        .clean(self.cx),\n+                        polarity: None,\n+                        synthetic: false,\n+                        blanket_impl: Some(trait_ref.self_ty().clean(self.cx)),\n+                    }),\n+                });\n             });\n         }\n         impls"}, {"sha": "405a2e66d6e5c21dbb4d48b212a0c4d17fe33f81", "filename": "src/librustdoc/clean/def_ctor.rs", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/47e0803d5c2ad5952220f2c260d7e12921c1d3fe/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47e0803d5c2ad5952220f2c260d7e12921c1d3fe/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs?ref=47e0803d5c2ad5952220f2c260d7e12921c1d3fe", "patch": "@@ -1,55 +0,0 @@\n-use crate::core::DocContext;\n-\n-use super::*;\n-\n-pub fn get_def_from_def_id<F>(cx: &DocContext<'_>,\n-                              def_id: DefId,\n-                              callback: &F,\n-) -> Vec<Item>\n-where F: Fn(& dyn Fn(DefId) -> Def) -> Vec<Item> {\n-    let ty = cx.tcx.type_of(def_id);\n-\n-    match ty.sty {\n-        ty::Adt(adt, _) => callback(&match adt.adt_kind() {\n-            AdtKind::Struct => Def::Struct,\n-            AdtKind::Enum => Def::Enum,\n-            AdtKind::Union => Def::Union,\n-        }),\n-        ty::Int(_) |\n-        ty::Uint(_) |\n-        ty::Float(_) |\n-        ty::Str |\n-        ty::Bool |\n-        ty::Char => callback(&move |_: DefId| {\n-            match ty.sty {\n-                ty::Int(x) => Def::PrimTy(hir::Int(x)),\n-                ty::Uint(x) => Def::PrimTy(hir::Uint(x)),\n-                ty::Float(x) => Def::PrimTy(hir::Float(x)),\n-                ty::Str => Def::PrimTy(hir::Str),\n-                ty::Bool => Def::PrimTy(hir::Bool),\n-                ty::Char => Def::PrimTy(hir::Char),\n-                _ => unreachable!(),\n-            }\n-        }),\n-        _ => {\n-            debug!(\"Unexpected type {:?}\", def_id);\n-            Vec::new()\n-        }\n-    }\n-}\n-\n-pub fn get_def_from_hir_id<F>(cx: &DocContext<'_>,\n-                              id: hir::HirId,\n-                              name: String,\n-                              callback: &F,\n-) -> Vec<Item>\n-where F: Fn(& dyn Fn(DefId) -> Def, String) -> Vec<Item> {\n-    let item = &cx.tcx.hir().expect_item_by_hir_id(id).node;\n-\n-    callback(&match *item {\n-        hir::ItemKind::Struct(_, _) => Def::Struct,\n-        hir::ItemKind::Union(_, _) => Def::Union,\n-        hir::ItemKind::Enum(_, _) => Def::Enum,\n-        _ => panic!(\"Unexpected type {:?} {:?}\", item, id),\n-    }, name)\n-}"}, {"sha": "7f5ba91900bce538e0a1f27636c4a4b0980d4f30", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 170, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6cc24f26036b28fb3366de86efe3da6c4464057a", "patch": "@@ -8,7 +8,6 @@ pub mod cfg;\n mod simplify;\n mod auto_trait;\n mod blanket_impl;\n-pub mod def_ctor;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::sync::Lrc;\n@@ -22,8 +21,7 @@ use rustc::mir::interpret::{GlobalId, ConstValue};\n use rustc::hir::{self, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::hir::map::DisambiguatedDefPathData;\n-use rustc::ty::subst::{Kind, InternalSubsts, SubstsRef, UnpackedKind};\n+use rustc::ty::subst::{InternalSubsts, SubstsRef, UnpackedKind};\n use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::ty::fold::TypeFolder;\n use rustc::ty::layout::VariantIdx;\n@@ -35,7 +33,7 @@ use syntax::source_map::{dummy_spanned, Spanned};\n use syntax::ptr::P;\n use syntax::symbol::keywords::{self, Keyword};\n use syntax::symbol::InternedString;\n-use syntax_pos::{self, DUMMY_SP, Pos, FileName};\n+use syntax_pos::{self, Pos, FileName};\n \n use std::collections::hash_map::Entry;\n use std::fmt;\n@@ -3777,40 +3775,13 @@ pub struct Impl {\n     pub blanket_impl: Option<Type>,\n }\n \n-pub fn get_auto_traits_with_hir_id(\n-    cx: &DocContext<'_>,\n-    id: hir::HirId,\n-    name: String\n-) -> Vec<Item> {\n-    let finder = AutoTraitFinder::new(cx);\n-    finder.get_with_hir_id(id, name)\n-}\n-\n-pub fn get_auto_traits_with_def_id(\n-    cx: &DocContext<'_>,\n-    id: DefId\n-) -> Vec<Item> {\n-    let finder = AutoTraitFinder::new(cx);\n-\n-    finder.get_with_def_id(id)\n-}\n-\n-pub fn get_blanket_impls_with_hir_id(\n-    cx: &DocContext<'_>,\n-    id: hir::HirId,\n-    name: String\n-) -> Vec<Item> {\n-    let finder = BlanketImplFinder::new(cx);\n-    finder.get_with_hir_id(id, name)\n-}\n-\n-pub fn get_blanket_impls_with_def_id(\n-    cx: &DocContext<'_>,\n-    id: DefId\n-) -> Vec<Item> {\n-    let finder = BlanketImplFinder::new(cx);\n-\n-    finder.get_with_def_id(id)\n+pub fn get_auto_trait_and_blanket_impls(\n+    cx: &DocContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    param_env_def_id: DefId,\n+) -> impl Iterator<Item = Item> {\n+    AutoTraitFinder::new(cx).get_auto_trait_impls(ty, param_env_def_id).into_iter()\n+        .chain(BlanketImplFinder::new(cx).get_blanket_impls(ty, param_env_def_id))\n }\n \n impl Clean<Vec<Item>> for doctree::Impl {\n@@ -4462,125 +4433,8 @@ pub fn path_to_def(tcx: TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n     }\n }\n \n-pub fn get_path_for_type(\n-    tcx: TyCtxt<'_, '_, '_>,\n-    def_id: DefId,\n-    def_ctor: impl Fn(DefId) -> Def,\n-) -> hir::Path {\n-    use rustc::ty::print::Printer;\n-\n-    struct AbsolutePathPrinter<'a, 'tcx> {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    }\n-\n-    impl Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n-        type Error = !;\n-\n-        type Path = Vec<String>;\n-        type Region = ();\n-        type Type = ();\n-        type DynExistential = ();\n-\n-        fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-            self.tcx\n-        }\n-\n-        fn print_region(\n-            self,\n-            _region: ty::Region<'_>,\n-        ) -> Result<Self::Region, Self::Error> {\n-            Ok(())\n-        }\n-\n-        fn print_type(\n-            self,\n-            _ty: Ty<'tcx>,\n-        ) -> Result<Self::Type, Self::Error> {\n-            Ok(())\n-        }\n-\n-        fn print_dyn_existential(\n-            self,\n-            _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n-        ) -> Result<Self::DynExistential, Self::Error> {\n-            Ok(())\n-        }\n-\n-        fn path_crate(\n-            self,\n-            cnum: CrateNum,\n-        ) -> Result<Self::Path, Self::Error> {\n-            Ok(vec![self.tcx.original_crate_name(cnum).to_string()])\n-        }\n-        fn path_qualified(\n-            self,\n-            self_ty: Ty<'tcx>,\n-            trait_ref: Option<ty::TraitRef<'tcx>>,\n-        ) -> Result<Self::Path, Self::Error> {\n-            // This shouldn't ever be needed, but just in case:\n-            Ok(vec![match trait_ref {\n-                Some(trait_ref) => format!(\"{:?}\", trait_ref),\n-                None => format!(\"<{}>\", self_ty),\n-            }])\n-        }\n-\n-        fn path_append_impl(\n-            self,\n-            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-            _disambiguated_data: &DisambiguatedDefPathData,\n-            self_ty: Ty<'tcx>,\n-            trait_ref: Option<ty::TraitRef<'tcx>>,\n-        ) -> Result<Self::Path, Self::Error> {\n-            let mut path = print_prefix(self)?;\n-\n-            // This shouldn't ever be needed, but just in case:\n-            path.push(match trait_ref {\n-                Some(trait_ref) => {\n-                    format!(\"<impl {} for {}>\", trait_ref, self_ty)\n-                }\n-                None => format!(\"<impl {}>\", self_ty),\n-            });\n-\n-            Ok(path)\n-        }\n-        fn path_append(\n-            self,\n-            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-            disambiguated_data: &DisambiguatedDefPathData,\n-        ) -> Result<Self::Path, Self::Error> {\n-            let mut path = print_prefix(self)?;\n-            path.push(disambiguated_data.data.as_interned_str().to_string());\n-            Ok(path)\n-        }\n-        fn path_generic_args(\n-            self,\n-            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-            _args: &[Kind<'tcx>],\n-        ) -> Result<Self::Path, Self::Error> {\n-            print_prefix(self)\n-        }\n-    }\n-\n-    let names = AbsolutePathPrinter { tcx: tcx.global_tcx() }\n-        .print_def_path(def_id, &[])\n-        .unwrap();\n-\n-    hir::Path {\n-        span: DUMMY_SP,\n-        def: def_ctor(def_id),\n-        segments: hir::HirVec::from_vec(names.iter().map(|s| hir::PathSegment {\n-            ident: ast::Ident::from_str(&s),\n-            hir_id: None,\n-            def: None,\n-            args: None,\n-            infer_types: false,\n-        }).collect())\n-    }\n-}\n-\n // End of code copied from rust-clippy\n \n-\n #[derive(Eq, PartialEq, Hash, Copy, Clone, Debug)]\n enum RegionTarget<'tcx> {\n     Region(Region<'tcx>),\n@@ -4599,21 +4453,6 @@ enum SimpleBound {\n     Outlives(Lifetime),\n }\n \n-enum AutoTraitResult {\n-    ExplicitImpl,\n-    PositiveImpl(Generics),\n-    NegativeImpl,\n-}\n-\n-impl AutoTraitResult {\n-    fn is_auto(&self) -> bool {\n-        match *self {\n-            AutoTraitResult::PositiveImpl(_) | AutoTraitResult::NegativeImpl => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n impl From<GenericBound> for SimpleBound {\n     fn from(bound: GenericBound) -> Self {\n         match bound.clone() {"}, {"sha": "831adb301efcb2d3c8cae20844b00f0d182396bc", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 101, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6cc24f26036b28fb3366de86efe3da6c4464057a", "patch": "@@ -2,10 +2,10 @@ use rustc_lint;\n use rustc::session::{self, config};\n use rustc::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CrateNum, LOCAL_CRATE};\n use rustc::hir::def::Def;\n-use rustc::hir::{self, HirId, HirVec};\n+use rustc::hir::HirId;\n use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{Ty, TyCtxt};\n use rustc::lint::{self, LintPass};\n use rustc::session::config::ErrorOutputType;\n use rustc::session::DiagnosticOutput;\n@@ -16,13 +16,9 @@ use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n use rustc_target::spec::TargetTriple;\n \n-use syntax::ast::{self, Ident};\n use syntax::source_map;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::json::JsonEmitter;\n-use syntax::ptr::P;\n-use syntax::symbol::keywords;\n-use syntax_pos::DUMMY_SP;\n use errors;\n use errors::emitter::{Emitter, EmitterWriter};\n use parking_lot::ReentrantMutex;\n@@ -36,7 +32,7 @@ use std::rc::Rc;\n use crate::visit_ast::RustdocVisitor;\n use crate::config::{Options as RustdocOptions, RenderOptions};\n use crate::clean;\n-use crate::clean::{get_path_for_type, Clean, MAX_DEF_ID, AttributesExt};\n+use crate::clean::{Clean, MAX_DEF_ID, AttributesExt};\n use crate::html::render::RenderInfo;\n \n use crate::passes;\n@@ -74,8 +70,9 @@ pub struct DocContext<'tcx> {\n     pub send_trait: Option<DefId>,\n     pub fake_def_ids: RefCell<FxHashMap<CrateNum, DefId>>,\n     pub all_fake_def_ids: RefCell<FxHashSet<DefId>>,\n-    /// Maps (type_id, trait_id) -> auto trait impl\n-    pub generated_synthetics: RefCell<FxHashSet<(DefId, DefId)>>,\n+    /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n+    // FIXME(eddyb) make this a `ty::TraitRef<'tcx>` set.\n+    pub generated_synthetics: RefCell<FxHashSet<(Ty<'tcx>, DefId)>>,\n     pub all_traits: Vec<DefId>,\n }\n \n@@ -173,98 +170,6 @@ impl<'tcx> DocContext<'tcx> {\n             self.tcx.hir().as_local_hir_id(def_id)\n         }\n     }\n-\n-    pub fn get_real_ty<F>(&self,\n-                          def_id: DefId,\n-                          def_ctor: &F,\n-                          real_name: &Option<Ident>,\n-                          generics: &ty::Generics,\n-    ) -> hir::Ty\n-    where F: Fn(DefId) -> Def {\n-        let path = get_path_for_type(self.tcx, def_id, def_ctor);\n-        let mut segments = path.segments.into_vec();\n-        let last = segments.pop().expect(\"segments were empty\");\n-\n-        segments.push(hir::PathSegment::new(\n-            real_name.unwrap_or(last.ident),\n-            None,\n-            None,\n-            self.generics_to_path_params(generics.clone()),\n-            false,\n-        ));\n-\n-        let new_path = hir::Path {\n-            span: path.span,\n-            def: path.def,\n-            segments: HirVec::from_vec(segments),\n-        };\n-\n-        hir::Ty {\n-            node: hir::TyKind::Path(hir::QPath::Resolved(None, P(new_path))),\n-            span: DUMMY_SP,\n-            hir_id: hir::DUMMY_HIR_ID,\n-        }\n-    }\n-\n-    pub fn generics_to_path_params(&self, generics: ty::Generics) -> hir::GenericArgs {\n-        let mut args = vec![];\n-\n-        for param in generics.params.iter() {\n-            match param.kind {\n-                ty::GenericParamDefKind::Lifetime => {\n-                    let name = if param.name == \"\" {\n-                        hir::ParamName::Plain(keywords::StaticLifetime.ident())\n-                    } else {\n-                        hir::ParamName::Plain(ast::Ident::from_interned_str(param.name))\n-                    };\n-\n-                    args.push(hir::GenericArg::Lifetime(hir::Lifetime {\n-                        hir_id: hir::DUMMY_HIR_ID,\n-                        span: DUMMY_SP,\n-                        name: hir::LifetimeName::Param(name),\n-                    }));\n-                }\n-                ty::GenericParamDefKind::Type { .. } => {\n-                    args.push(hir::GenericArg::Type(self.ty_param_to_ty(param.clone())));\n-                }\n-                ty::GenericParamDefKind::Const => {\n-                    args.push(hir::GenericArg::Const(hir::ConstArg {\n-                        value: hir::AnonConst {\n-                            hir_id: hir::DUMMY_HIR_ID,\n-                            body: hir::BodyId {\n-                                hir_id: hir::DUMMY_HIR_ID,\n-                            }\n-                        },\n-                        span: DUMMY_SP,\n-                    }))\n-                }\n-            }\n-        }\n-\n-        hir::GenericArgs {\n-            args: HirVec::from_vec(args),\n-            bindings: HirVec::new(),\n-            parenthesized: false,\n-        }\n-    }\n-\n-    pub fn ty_param_to_ty(&self, param: ty::GenericParamDef) -> hir::Ty {\n-        debug!(\"ty_param_to_ty({:?}) {:?}\", param, param.def_id);\n-        hir::Ty {\n-            node: hir::TyKind::Path(hir::QPath::Resolved(\n-                None,\n-                P(hir::Path {\n-                    span: DUMMY_SP,\n-                    def: Def::TyParam(param.def_id),\n-                    segments: HirVec::from_vec(vec![\n-                        hir::PathSegment::from_ident(Ident::from_interned_str(param.name))\n-                    ]),\n-                }),\n-            )),\n-            span: DUMMY_SP,\n-            hir_id: hir::DUMMY_HIR_ID,\n-        }\n-    }\n }\n \n pub trait DocAccessLevels {"}, {"sha": "8d33cd72e29aad0eab1f3a1557271f160e36f62b", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=6cc24f26036b28fb3366de86efe3da6c4464057a", "patch": "@@ -67,16 +67,14 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n         if !def_id.is_local() {\n             inline::build_impl(cx, def_id, &mut new_items);\n \n-            let auto_impls = get_auto_traits_with_def_id(cx, def_id);\n-            let blanket_impls = get_blanket_impls_with_def_id(cx, def_id);\n-            let mut renderinfo = cx.renderinfo.borrow_mut();\n+            // FIXME(eddyb) is this `doc(hidden)` check needed?\n+            if !cx.tcx.get_attrs(def_id).lists(\"doc\").has_word(\"hidden\") {\n+                let self_ty = cx.tcx.type_of(def_id);\n+                let impls = get_auto_trait_and_blanket_impls(cx, self_ty, def_id);\n+                let mut renderinfo = cx.renderinfo.borrow_mut();\n \n-            let new_impls: Vec<Item> = auto_impls.into_iter()\n-                .chain(blanket_impls.into_iter())\n-                .filter(|i| renderinfo.inlined.insert(i.def_id))\n-                .collect();\n-\n-            new_items.extend(new_impls);\n+                new_items.extend(impls.filter(|i| renderinfo.inlined.insert(i.def_id)));\n+            }\n         }\n     }\n \n@@ -155,14 +153,13 @@ impl<'a, 'tcx> SyntheticImplCollector<'a, 'tcx> {\n impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n-            if let (Some(hir_id), Some(name)) =\n-                (self.cx.tcx.hir().as_local_hir_id(i.def_id), i.name.clone())\n-            {\n-                self.impls.extend(get_auto_traits_with_hir_id(self.cx, hir_id, name.clone()));\n-                self.impls.extend(get_blanket_impls_with_hir_id(self.cx, hir_id, name));\n-            } else {\n-                self.impls.extend(get_auto_traits_with_def_id(self.cx, i.def_id));\n-                self.impls.extend(get_blanket_impls_with_def_id(self.cx, i.def_id));\n+            // FIXME(eddyb) is this `doc(hidden)` check needed?\n+            if !self.cx.tcx.get_attrs(i.def_id).lists(\"doc\").has_word(\"hidden\") {\n+                self.impls.extend(get_auto_trait_and_blanket_impls(\n+                    self.cx,\n+                    self.cx.tcx.type_of(i.def_id),\n+                    i.def_id,\n+                ));\n             }\n         }\n "}, {"sha": "f247ee637b97548e84e97c366ba47bd3e3c86528", "filename": "src/test/rustdoc/blanket-reexport-item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Ftest%2Frustdoc%2Fblanket-reexport-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Ftest%2Frustdoc%2Fblanket-reexport-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fblanket-reexport-item.rs?ref=6cc24f26036b28fb3366de86efe3da6c4464057a", "patch": "@@ -1,6 +1,6 @@\n #![crate_name = \"foo\"]\n \n-// @has foo/struct.S.html '//h3[@id=\"impl-Into\"]//code' 'impl<T, U> Into for T'\n+// @has foo/struct.S.html '//h3[@id=\"impl-Into%3CU%3E\"]//code' 'impl<T, U> Into<U> for T'\n pub struct S2 {}\n mod m {\n     pub struct S {}"}, {"sha": "d96301f3ae736f35eaf5e95001d834fd3cf8b829", "filename": "src/test/rustdoc/issue-34473.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Ftest%2Frustdoc%2Fissue-34473.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Ftest%2Frustdoc%2Fissue-34473.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-34473.rs?ref=6cc24f26036b28fb3366de86efe3da6c4464057a", "patch": "@@ -7,6 +7,5 @@ mod second {\n // @has foo/index.html\n // @!has - SomeTypeWithLongName\n // @has foo/struct.SomeType.html\n-// @!has - SomeTypeWithLongName\n // @!has foo/struct.SomeTypeWithLongName.html\n pub use second::{SomeTypeWithLongName as SomeType};"}, {"sha": "80a717718c22b607a6dc920d72cad34aa5eb4339", "filename": "src/test/rustdoc/synthetic_auto/complex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc24f26036b28fb3366de86efe3da6c4464057a/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs?ref=6cc24f26036b28fb3366de86efe3da6c4464057a", "patch": "@@ -21,7 +21,7 @@ mod foo {\n \n // @has complex/struct.NotOuter.html\n // @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<'a, T, K: \\\n-// ?Sized> Send for NotOuter<'a, T, K> where K: for<'b> Fn((&'b bool, &'a u8)) \\\n+// ?Sized> Send for Outer<'a, T, K> where K: for<'b> Fn((&'b bool, &'a u8)) \\\n // -> &'b i8, T: MyTrait<'a>, <T as MyTrait<'a>>::MyItem: Copy, 'a: 'static\"\n \n pub use foo::{Foo, Inner as NotInner, MyTrait as NotMyTrait, Outer as NotOuter};"}]}