{"sha": "0a01d82f6f3e33ca742c8e985d2a4819faeafe40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMDFkODJmNmYzZTMzY2E3NDJjOGU5ODVkMmE0ODE5ZmFlYWZlNDA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-27T23:08:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-28T02:56:16Z"}, "message": "preliminary work on making future's sendable\n\nalso various improvements to the ptr casting fns:\n- rename assimilate() to to_unsafe_ptr() (fixes #3110)\n- introduce `unsafe::copy_lifetime()` to copy the lifetime from one ptr to another", "tree": {"sha": "e6a3bfdfac3be000e62bcb2f5c8b3e1acbdc7a45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6a3bfdfac3be000e62bcb2f5c8b3e1acbdc7a45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a01d82f6f3e33ca742c8e985d2a4819faeafe40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a01d82f6f3e33ca742c8e985d2a4819faeafe40", "html_url": "https://github.com/rust-lang/rust/commit/0a01d82f6f3e33ca742c8e985d2a4819faeafe40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a01d82f6f3e33ca742c8e985d2a4819faeafe40/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff513b1bcd0d872899b453cb3542e7a0924d5bde", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff513b1bcd0d872899b453cb3542e7a0924d5bde", "html_url": "https://github.com/rust-lang/rust/commit/ff513b1bcd0d872899b453cb3542e7a0924d5bde"}], "stats": {"total": 118, "additions": 89, "deletions": 29}, "files": [{"sha": "e176b2544d4e355dc9a1a7737a127132a919dda7", "filename": "src/libcore/future.rs", "status": "modified", "additions": 73, "deletions": 24, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0a01d82f6f3e33ca742c8e985d2a4819faeafe40/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a01d82f6f3e33ca742c8e985d2a4819faeafe40/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=0a01d82f6f3e33ca742c8e985d2a4819faeafe40", "patch": "@@ -17,6 +17,7 @@\n \n import either::Either;\n import pipes::recv;\n+import unsafe::copy_lifetime;\n \n export Future;\n export extensions;\n@@ -31,18 +32,29 @@ export spawn;\n export future_pipe;\n \n #[doc = \"The future type\"]\n-enum Future<A> = {\n-    mut v: Either<@A, fn@() -> A>\n-};\n+struct Future<A> {\n+    /*priv*/ mut state: FutureState<A>;\n+}\n \n-/// Methods on the `future` type\n-impl<A:copy send> Future<A> {\n+priv enum FutureState<A> {\n+    Pending(fn@() -> A),\n+    Evaluating,\n+    Forced(A)\n+}\n \n+/// Methods on the `future` type\n+impl<A:copy> Future<A> {\n     fn get() -> A {\n         //! Get the value of the future\n \n         get(&self)\n     }\n+}\n+\n+impl<A> Future<A> {\n+    fn get_ref(&self) -> &self/A {\n+        get_ref(self)\n+    }\n \n     fn with<B>(blk: fn((&A)) -> B) -> B {\n         //! Work with the value without copying it\n@@ -59,9 +71,7 @@ fn from_value<A>(+val: A) -> Future<A> {\n      * not block.\n      */\n \n-    Future({\n-        mut v: either::Left(@val)\n-    })\n+    Future {state: Forced(val)}\n }\n \n fn from_port<A:send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n@@ -83,7 +93,7 @@ fn from_port<A:send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n     }\n }\n \n-fn from_fn<A>(f: fn@() -> A) -> Future<A> {\n+fn from_fn<A>(+f: @fn() -> A) -> Future<A> {\n     /*!\n      * Create a future from a function.\n      *\n@@ -92,9 +102,7 @@ fn from_fn<A>(f: fn@() -> A) -> Future<A> {\n      * function. It is not spawned into another task.\n      */\n \n-    Future({\n-        mut v: either::Right(f)\n-    })\n+    Future {state: Pending(f)}\n }\n \n fn spawn<A:send>(+blk: fn~() -> A) -> Future<A> {\n@@ -110,24 +118,54 @@ fn spawn<A:send>(+blk: fn~() -> A) -> Future<A> {\n     }))\n }\n \n+fn get_ref<A>(future: &r/Future<A>) -> &r/A {\n+    /*!\n+     * Executes the future's closure and then returns a borrowed\n+     * pointer to the result.  The borrowed pointer lasts as long as\n+     * the future.\n+     */\n+\n+    // The unsafety here is to hide the aliases from borrowck, which\n+    // would otherwise be concerned that someone might reassign\n+    // `future.state` and cause the value of the future to be freed.\n+    // But *we* know that once `future.state` is `Forced()` it will\n+    // never become \"unforced\"---so we can safely return a pointer\n+    // into the interior of the Forced() variant which will last as\n+    // long as the future itself.\n+\n+    match future.state {\n+      Forced(ref v) => { // v here has type &A, but with a shorter lifetime.\n+        return unsafe{ copy_lifetime(future, v) }; // ...extend it.\n+      }\n+      Evaluating => {\n+        fail ~\"Recursive forcing of future!\";\n+      }\n+      Pending(_) => {}\n+    }\n+\n+    let mut state = Evaluating;\n+    state <-> future.state;\n+    match move state {\n+      Forced(_) | Evaluating => {\n+        fail ~\"Logic error.\";\n+      }\n+      Pending(move f) => {\n+        future.state = Forced(f());\n+        return get_ref(future);\n+      }\n+    }\n+}\n+\n fn get<A:copy>(future: &Future<A>) -> A {\n     //! Get the value of the future\n \n-    do with(future) |v| { *v }\n+    *get_ref(future)\n }\n \n fn with<A,B>(future: &Future<A>, blk: fn((&A)) -> B) -> B {\n     //! Work with the value without copying it\n \n-    let v = match copy future.v {\n-      either::Left(v) => v,\n-      either::Right(f) => {\n-        let v = @f();\n-        future.v = either::Left(v);\n-        v\n-      }\n-    };\n-    blk(v)\n+    blk(get_ref(future))\n }\n \n proto! future_pipe (\n@@ -152,8 +190,7 @@ fn test_from_port() {\n \n #[test]\n fn test_from_fn() {\n-    let f = fn@() -> ~str { ~\"brail\" };\n-    let f = from_fn(f);\n+    let f = from_fn(|| ~\"brail\");\n     assert get(&f) == ~\"brail\";\n }\n \n@@ -169,6 +206,18 @@ fn test_with() {\n     assert with(&f, |v| *v) == ~\"nail\";\n }\n \n+#[test]\n+fn test_get_ref_method() {\n+    let f = from_value(22);\n+    assert *f.get_ref() == 22;\n+}\n+\n+#[test]\n+fn test_get_ref_fn() {\n+    let f = from_value(22);\n+    assert *get_ref(&f) == 22;\n+}\n+\n #[test]\n fn test_interface_with() {\n     let f = from_value(~\"kale\");"}, {"sha": "2a99ce3f3d6c5209fa4806cc1e1d7de249a9250d", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a01d82f6f3e33ca742c8e985d2a4819faeafe40/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a01d82f6f3e33ca742c8e985d2a4819faeafe40/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=0a01d82f6f3e33ca742c8e985d2a4819faeafe40", "patch": "@@ -1,7 +1,7 @@\n //! Unsafe pointer utility functions\n \n export addr_of;\n-export assimilate;\n+export to_unsafe_ptr;\n export mut_addr_of;\n export offset;\n export const_offset;\n@@ -136,9 +136,10 @@ unsafe fn memset<T>(dst: *mut T, c: int, count: uint)  {\n   (\"assimilate\" because it makes the pointer forget its region.)\n */\n #[inline(always)]\n-fn assimilate<T>(thing: &T) -> *T unsafe {\n+fn to_unsafe_ptr<T>(thing: &T) -> *T unsafe {\n     unsafe::reinterpret_cast(thing)\n }\n+\n /**\n   Cast a region pointer - &T - to a uint.\n   This is safe, but is implemented with an unsafe block due to"}, {"sha": "af3f082ea1b5e108892fa7bb820b84f6c81965b2", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a01d82f6f3e33ca742c8e985d2a4819faeafe40/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a01d82f6f3e33ca742c8e985d2a4819faeafe40/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=0a01d82f6f3e33ca742c8e985d2a4819faeafe40", "patch": "@@ -7,6 +7,7 @@ export SharedMutableState, shared_mutable_state, clone_shared_mutable_state;\n export get_shared_mutable_state, get_shared_immutable_state;\n export unwrap_shared_mutable_state;\n export Exclusive, exclusive, unwrap_exclusive;\n+export copy_lifetime;\n \n import task::atomically;\n \n@@ -57,15 +58,24 @@ unsafe fn transmute<L, G>(-thing: L) -> G {\n \n /// Coerce an immutable reference to be mutable.\n unsafe fn transmute_mut<T>(+ptr: &a/T) -> &a/mut T { transmute(ptr) }\n+\n /// Coerce a mutable reference to be immutable.\n unsafe fn transmute_immut<T>(+ptr: &a/mut T) -> &a/T { transmute(ptr) }\n+\n /// Coerce a borrowed pointer to have an arbitrary associated region.\n unsafe fn transmute_region<T>(+ptr: &a/T) -> &b/T { transmute(ptr) }\n+\n /// Coerce a borrowed mutable pointer to have an arbitrary associated region.\n unsafe fn transmute_mut_region<T>(+ptr: &a/mut T) -> &b/mut T {\n     transmute(ptr)\n }\n \n+/// Transforms lifetime of the second pointer to match the first.\n+unsafe fn copy_lifetime<S,T>(_ptr: &a/S, ptr: &T) -> &a/T {\n+    transmute_region(ptr)\n+}\n+\n+\n /****************************************************************************\n  * Shared state & exclusive ARC\n  ****************************************************************************/"}, {"sha": "aed7c316770569eb84c3ecdd84e8fcf26b0041e8", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a01d82f6f3e33ca742c8e985d2a4819faeafe40/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a01d82f6f3e33ca742c8e985d2a4819faeafe40/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=0a01d82f6f3e33ca742c8e985d2a4819faeafe40", "patch": "@@ -21,8 +21,8 @@\n  */\n \n import libc::size_t;\n-import ptr::assimilate;\n import comm = core::comm;\n+import ptr::to_unsafe_ptr;\n \n // libuv struct mappings\n type uv_ip4_addr = {\n@@ -824,7 +824,7 @@ unsafe fn ip4_name(src: &sockaddr_in) -> ~str {\n     let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                      0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8];\n     do vec::as_buf(dst) |dst_buf, size| {\n-        rustrt::rust_uv_ip4_name(assimilate(src),\n+        rustrt::rust_uv_ip4_name(to_unsafe_ptr(src),\n                                  dst_buf, size as libc::size_t);\n         // seems that checking the result of uv_ip4_name\n         // doesn't work too well..\n@@ -844,7 +844,7 @@ unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8];\n     do vec::as_buf(dst) |dst_buf, size| {\n-        let src_unsafe_ptr = assimilate(src);\n+        let src_unsafe_ptr = to_unsafe_ptr(src);\n         log(debug, fmt!(\"val of src *sockaddr_in6: %? sockaddr_in6: %?\",\n                         src_unsafe_ptr, src));\n         let result = rustrt::rust_uv_ip6_name(src_unsafe_ptr,"}]}