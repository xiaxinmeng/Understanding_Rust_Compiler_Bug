{"sha": "e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNmU0YmQwZjdlNzIyZDNjOTdkMWNhNDUzODdlNThmODFlNGU4ZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-02T01:29:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-02T01:29:28Z"}, "message": "Auto merge of #76231 - tmandry:rollup-ilvs9fq, r=tmandry\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #74880 (Add trailing comma support to matches macro)\n - #76074 (Add new `-Z dump-mir-spanview` option)\n - #76088 (Add more examples to lexicographic cmp on Iterators.)\n - #76099 (Add info about `!` and `impl Trait`)\n - #76126 (Use \"Fira Sans\" for crate list font)\n - #76132 (Factor out StmtKind::MacCall fields into `MacCallStmt` struct)\n - #76143 (Give a better error message for duplicate built-in macros)\n - #76158 (Stabilise link-self-contained option)\n - #76201 (Move to intra-doc links for library/core/src/panic.rs)\n - #76206 (Make all methods of `std::net::Ipv6Addr` const)\n - #76207 (# Move to intra-doc links for library/core/src/clone.rs)\n - #76212 (Document lint missing_doc_code_examples is nightly-only)\n - #76218 (lexer: Tiny improvement to shebang detection)\n - #76221 (Clean up header in `iter` docs for `for` loops)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "505c8905fbf0db875c1be97477b65cac833bb653", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/505c8905fbf0db875c1be97477b65cac833bb653"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "html_url": "https://github.com/rust-lang/rust/commit/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "130359cb05246fcacdde61baa2613419ef6570c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/130359cb05246fcacdde61baa2613419ef6570c7", "html_url": "https://github.com/rust-lang/rust/commit/130359cb05246fcacdde61baa2613419ef6570c7"}, {"sha": "4dd75f8049b722ea8bd4ff9d7c6c4a438161bad6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dd75f8049b722ea8bd4ff9d7c6c4a438161bad6", "html_url": "https://github.com/rust-lang/rust/commit/4dd75f8049b722ea8bd4ff9d7c6c4a438161bad6"}], "stats": {"total": 1163, "additions": 1064, "deletions": 99}, "files": [{"sha": "49aa1fc17357efac004445a15dfc35b3abf58cf4", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -922,9 +922,13 @@ impl Stmt {\n     pub fn add_trailing_semicolon(mut self) -> Self {\n         self.kind = match self.kind {\n             StmtKind::Expr(expr) => StmtKind::Semi(expr),\n-            StmtKind::MacCall(mac) => StmtKind::MacCall(\n-                mac.map(|(mac, _style, attrs)| (mac, MacStmtStyle::Semicolon, attrs)),\n-            ),\n+            StmtKind::MacCall(mac) => {\n+                StmtKind::MacCall(mac.map(|MacCallStmt { mac, style: _, attrs }| MacCallStmt {\n+                    mac,\n+                    style: MacStmtStyle::Semicolon,\n+                    attrs,\n+                }))\n+            }\n             kind => kind,\n         };\n         self\n@@ -958,7 +962,14 @@ pub enum StmtKind {\n     /// Just a trailing semi-colon.\n     Empty,\n     /// Macro.\n-    MacCall(P<(MacCall, MacStmtStyle, AttrVec)>),\n+    MacCall(P<MacCallStmt>),\n+}\n+\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct MacCallStmt {\n+    pub mac: MacCall,\n+    pub style: MacStmtStyle,\n+    pub attrs: AttrVec,\n }\n \n #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug)]"}, {"sha": "12d6f7cc33ddc2977143a820d0a93b3297337f90", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -16,7 +16,6 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n use std::iter;\n-use std::ops::DerefMut;\n \n pub struct MarkedAttrs(GrowableBitSet<AttrId>);\n \n@@ -634,10 +633,7 @@ impl HasAttrs for StmtKind {\n             StmtKind::Local(ref local) => local.attrs(),\n             StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.attrs(),\n             StmtKind::Empty | StmtKind::Item(..) => &[],\n-            StmtKind::MacCall(ref mac) => {\n-                let (_, _, ref attrs) = **mac;\n-                attrs.attrs()\n-            }\n+            StmtKind::MacCall(ref mac) => mac.attrs.attrs(),\n         }\n     }\n \n@@ -647,8 +643,7 @@ impl HasAttrs for StmtKind {\n             StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.visit_attrs(f),\n             StmtKind::Empty | StmtKind::Item(..) => {}\n             StmtKind::MacCall(mac) => {\n-                let (_mac, _style, attrs) = mac.deref_mut();\n-                attrs.visit_attrs(f);\n+                mac.attrs.visit_attrs(f);\n             }\n         }\n     }"}, {"sha": "3ef83ef3fc9737d9434540f8e72dec87f5067e98", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -1305,7 +1305,7 @@ pub fn noop_flat_map_stmt_kind<T: MutVisitor>(\n         StmtKind::Semi(expr) => vis.filter_map_expr(expr).into_iter().map(StmtKind::Semi).collect(),\n         StmtKind::Empty => smallvec![StmtKind::Empty],\n         StmtKind::MacCall(mut mac) => {\n-            let (mac_, _semi, attrs) = mac.deref_mut();\n+            let MacCallStmt { mac: mac_, style: _, attrs } = mac.deref_mut();\n             vis.visit_mac(mac_);\n             visit_thin_attrs(attrs, vis);\n             smallvec![StmtKind::MacCall(mac)]"}, {"sha": "234ce280f97c4e5ee3ac7f01b8cbdbed598474ef", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -692,7 +692,7 @@ pub fn walk_stmt<'a, V: Visitor<'a>>(visitor: &mut V, statement: &'a Stmt) {\n         StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => visitor.visit_expr(expr),\n         StmtKind::Empty => {}\n         StmtKind::MacCall(ref mac) => {\n-            let (ref mac, _, ref attrs) = **mac;\n+            let MacCallStmt { ref mac, style: _, ref attrs } = **mac;\n             visitor.visit_mac(mac);\n             for attr in attrs.iter() {\n                 visitor.visit_attribute(attr);"}, {"sha": "53b6d536a4a4ee1540f0052b251ef6274c82de7d", "filename": "compiler/rustc_ast_pretty/src/pprust.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -1507,11 +1507,10 @@ impl<'a> State<'a> {\n                 self.s.word(\";\");\n             }\n             ast::StmtKind::MacCall(ref mac) => {\n-                let (ref mac, style, ref attrs) = **mac;\n                 self.space_if_not_bol();\n-                self.print_outer_attributes(attrs);\n-                self.print_mac(mac);\n-                if style == ast::MacStmtStyle::Semicolon {\n+                self.print_outer_attributes(&mac.attrs);\n+                self.print_mac(&mac.mac);\n+                if mac.style == ast::MacStmtStyle::Semicolon {\n                     self.s.word(\";\");\n                 }\n             }"}, {"sha": "8262ae4cdbb866ba834aba517474a44a3c1f48e8", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -1084,7 +1084,7 @@ fn get_crt_libs_path(sess: &Session) -> Option<PathBuf> {\n \n fn get_object_file_path(sess: &Session, name: &str, self_contained: bool) -> PathBuf {\n     // prefer system {,dll}crt2.o libs, see get_crt_libs_path comment for more details\n-    if sess.opts.debugging_opts.link_self_contained.is_none()\n+    if sess.opts.cg.link_self_contained.is_none()\n         && sess.target.target.llvm_target.contains(\"windows-gnu\")\n     {\n         if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n@@ -1289,7 +1289,7 @@ fn link_output_kind(sess: &Session, crate_type: CrateType) -> LinkOutputKind {\n /// Whether we link to our own CRT objects instead of relying on gcc to pull them.\n /// We only provide such support for a very limited number of targets.\n fn crt_objects_fallback(sess: &Session, crate_type: CrateType) -> bool {\n-    if let Some(self_contained) = sess.opts.debugging_opts.link_self_contained {\n+    if let Some(self_contained) = sess.opts.cg.link_self_contained {\n         return self_contained;\n     }\n \n@@ -1499,7 +1499,7 @@ fn link_local_crate_native_libs_and_dependent_crate_libs<'a, B: ArchiveBuilder<'\n /// Add sysroot and other globally set directories to the directory search list.\n fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session, self_contained: bool) {\n     // Prefer system mingw-w64 libs, see get_crt_libs_path comment for more details.\n-    if sess.opts.debugging_opts.link_self_contained.is_none()\n+    if sess.opts.cg.link_self_contained.is_none()\n         && cfg!(windows)\n         && sess.target.target.llvm_target.contains(\"windows-gnu\")\n     {"}, {"sha": "789a1fc35a64fa8af5a613b469d25eaaa9402f71", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -454,6 +454,7 @@ E0768: include_str!(\"./error_codes/E0768.md\"),\n E0769: include_str!(\"./error_codes/E0769.md\"),\n E0770: include_str!(\"./error_codes/E0770.md\"),\n E0771: include_str!(\"./error_codes/E0771.md\"),\n+E0773: include_str!(\"./error_codes/E0773.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "b19a58bf33d2c97fe025143497098a23004ffb39", "filename": "compiler/rustc_error_codes/src/error_codes/E0773.md", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0773.md", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0773.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0773.md?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -0,0 +1,38 @@\n+A builtin-macro was defined more than once.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0773\n+#![feature(decl_macro)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_builtin_macro]\n+pub macro test($item:item) {\n+    /* compiler built-in */\n+}\n+\n+mod inner {\n+    #[rustc_builtin_macro]\n+    pub macro test($item:item) {\n+        /* compiler built-in */\n+    }\n+}\n+```\n+\n+To fix the issue, remove the duplicate declaration:\n+\n+```\n+#![feature(decl_macro)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_builtin_macro]\n+pub macro test($item:item) {\n+    /* compiler built-in */\n+}\n+```\n+\n+In very rare edge cases, this may happen when loading `core` or `std` twice,\n+once with `check` metadata and once with `build` metadata.\n+For more information, see [#75176].\n+\n+[#75176]: https://github.com/rust-lang/rust/pull/75176#issuecomment-683234468"}, {"sha": "105f81c6e0f6799b476e91f8ffd2dd10ca85db58", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -13,7 +13,7 @@ use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, AttrItem, Block, LitKind, NodeId, PatKind, Path};\n-use rustc_ast::{ItemKind, MacArgs, MacStmtStyle, StmtKind};\n+use rustc_ast::{ItemKind, MacArgs, MacCallStmt, MacStmtStyle, StmtKind};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, is_builtin_attr, HasAttrs};\n use rustc_data_structures::map_in_place::MapInPlace;\n@@ -1363,7 +1363,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         }\n \n         if let StmtKind::MacCall(mac) = stmt.kind {\n-            let (mac, style, attrs) = mac.into_inner();\n+            let MacCallStmt { mac, style, attrs } = mac.into_inner();\n             self.check_attributes(&attrs);\n             let mut placeholder =\n                 self.collect_bang(mac, stmt.span, AstFragmentKind::Stmts).make_stmts();"}, {"sha": "dbd2e70af6a7af128915e820cebab950ffb483dc", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -92,7 +92,11 @@ pub fn placeholder(\n             AstFragment::Ty(P(ast::Ty { id, span, kind: ast::TyKind::MacCall(mac_placeholder()) }))\n         }\n         AstFragmentKind::Stmts => AstFragment::Stmts(smallvec![{\n-            let mac = P((mac_placeholder(), ast::MacStmtStyle::Braces, ast::AttrVec::new()));\n+            let mac = P(ast::MacCallStmt {\n+                mac: mac_placeholder(),\n+                style: ast::MacStmtStyle::Braces,\n+                attrs: ast::AttrVec::new(),\n+            });\n             ast::Stmt { id, span, kind: ast::StmtKind::MacCall(mac) }\n         }]),\n         AstFragmentKind::Arms => AstFragment::Arms(smallvec![ast::Arm {\n@@ -293,7 +297,7 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n \n     fn flat_map_stmt(&mut self, stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n         let (style, mut stmts) = match stmt.kind {\n-            ast::StmtKind::MacCall(mac) => (mac.1, self.remove(stmt.id).make_stmts()),\n+            ast::StmtKind::MacCall(mac) => (mac.style, self.remove(stmt.id).make_stmts()),\n             _ => return noop_flat_map_stmt(stmt, self),\n         };\n "}, {"sha": "ada8dc90494bc1194c77d5707149022d2028c890", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -402,6 +402,7 @@ fn test_codegen_options_tracking_hash() {\n     // `link_arg` is omitted because it just forwards to `link_args`.\n     untracked!(link_args, vec![String::from(\"abc\"), String::from(\"def\")]);\n     untracked!(link_dead_code, Some(true));\n+    untracked!(link_self_contained, Some(true));\n     untracked!(linker, Some(PathBuf::from(\"linker\")));\n     untracked!(linker_flavor, Some(LinkerFlavor::Gcc));\n     untracked!(no_stack_check, true);"}, {"sha": "44999bbe85713b998aad129a11640552202acab8", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -191,12 +191,16 @@ pub fn strip_shebang(input: &str) -> Option<usize> {\n     // For simplicity we consider any line starting with `#!` a shebang,\n     // regardless of restrictions put on shebangs by specific platforms.\n     if let Some(input_tail) = input.strip_prefix(\"#!\") {\n-        // Ok, this is a shebang but if the next non-whitespace token is `[` or maybe\n-        // a doc comment (due to `TokenKind::(Line,Block)Comment` ambiguity at lexer level),\n+        // Ok, this is a shebang but if the next non-whitespace token is `[`,\n         // then it may be valid Rust code, so consider it Rust code.\n-        let next_non_whitespace_token = tokenize(input_tail).map(|tok| tok.kind).find(|tok|\n-            !matches!(tok, TokenKind::Whitespace | TokenKind::LineComment { .. } | TokenKind::BlockComment { .. })\n-        );\n+        let next_non_whitespace_token = tokenize(input_tail).map(|tok| tok.kind).find(|tok| {\n+            !matches!(\n+                tok,\n+                TokenKind::Whitespace\n+                    | TokenKind::LineComment { doc_style: None }\n+                    | TokenKind::BlockComment { doc_style: None, .. }\n+            )\n+        });\n         if next_non_whitespace_token != Some(TokenKind::OpenBracket) {\n             // No other choice than to consider this a shebang.\n             return Some(2 + input_tail.lines().next().unwrap_or_default().len());"}, {"sha": "ed0fafb1aac16f32ba96c892e6a6c719986b25bb", "filename": "compiler/rustc_mir/src/util/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -9,6 +9,7 @@ mod alignment;\n pub mod collect_writes;\n mod graphviz;\n pub(crate) mod pretty;\n+pub(crate) mod spanview;\n \n pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;"}, {"sha": "db57766620e8134964add64d72678cb17369dcc5", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -6,6 +6,7 @@ use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n \n use super::graphviz::write_mir_fn_graphviz;\n+use super::spanview::write_mir_fn_spanview;\n use crate::transform::MirSource;\n use either::Either;\n use rustc_data_structures::fx::FxHashMap;\n@@ -147,6 +148,16 @@ fn dump_matched_mir_node<'tcx, F>(\n             write_mir_fn_graphviz(tcx, source.def_id(), body, false, &mut file)?;\n         };\n     }\n+\n+    if let Some(spanview) = tcx.sess.opts.debugging_opts.dump_mir_spanview {\n+        let _: io::Result<()> = try {\n+            let mut file =\n+                create_dump_file(tcx, \"html\", pass_num, pass_name, disambiguator, source)?;\n+            if source.def_id().is_local() {\n+                write_mir_fn_spanview(tcx, source.def_id(), body, spanview, &mut file)?;\n+            }\n+        };\n+    }\n }\n \n /// Returns the path to the filename where we should dump a given MIR."}, {"sha": "b2f2b5fc1e6f49067d88015ab619b85cba4f6c2d", "filename": "compiler/rustc_mir/src/util/spanview.rs", "status": "added", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -0,0 +1,461 @@\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::hir;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::config::MirSpanview;\n+use rustc_span::{BytePos, Pos, Span};\n+\n+use std::io::{self, Write};\n+use std::iter::Peekable;\n+\n+pub const TOOLTIP_INDENT: &str = \"    \";\n+\n+const NEW_LINE_SPAN: &str = \"</span>\\n<span class=\\\"line\\\">\";\n+const HEADER: &str = r#\"<!DOCTYPE html>\n+<html>\n+<head>\n+    <title>coverage_of_if_else - Code Regions</title>\n+    <style>\n+    .line {\n+        counter-increment: line;\n+    }\n+    .line:before {\n+        content: counter(line) \": \";\n+        font-family: Menlo, Monaco, monospace;\n+        font-style: italic;\n+        width: 3.8em;\n+        display: inline-block;\n+        text-align: right;\n+        filter: opacity(50%);\n+        -webkit-user-select: none;\n+    }\n+    .code {\n+        color: #dddddd;\n+        background-color: #222222;\n+        font-family: Menlo, Monaco, monospace;\n+        line-height: 1.4em;\n+        border-bottom: 2px solid #222222;\n+        white-space: pre;\n+        display: inline-block;\n+    }\n+    .odd {\n+        background-color: #55bbff;\n+        color: #223311;\n+    }\n+    .even {\n+        background-color: #ee7756;\n+        color: #551133;\n+    }\n+    .code {\n+        --index: calc(var(--layer) - 1);\n+        padding-top: calc(var(--index) * 0.15em);\n+        filter:\n+            hue-rotate(calc(var(--index) * 25deg))\n+            saturate(calc(100% - (var(--index) * 2%)))\n+            brightness(calc(100% - (var(--index) * 1.5%)));\n+    }\n+    .annotation {\n+        color: #4444ff;\n+        font-family: monospace;\n+        font-style: italic;\n+        display: none;\n+        -webkit-user-select: none;\n+    }\n+    body:active .annotation {\n+        /* requires holding mouse down anywhere on the page */\n+        display: inline-block;\n+    }\n+    span:hover .annotation {\n+        /* requires hover over a span ONLY on its first line */\n+        display: inline-block;\n+    }\n+    </style>\n+</head>\n+<body>\"#;\n+\n+const FOOTER: &str = r#\"\n+</body>\n+</html>\"#;\n+\n+/// Metadata to highlight the span of a MIR BasicBlock, Statement, or Terminator.\n+pub struct SpanViewable {\n+    pub span: Span,\n+    pub title: String,\n+    pub tooltip: String,\n+}\n+\n+/// Write a spanview HTML+CSS file to analyze MIR element spans.\n+pub fn write_mir_fn_spanview<'tcx, W>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    body: &Body<'tcx>,\n+    spanview: MirSpanview,\n+    w: &mut W,\n+) -> io::Result<()>\n+where\n+    W: Write,\n+{\n+    let body_span = hir_body(tcx, def_id).value.span;\n+    let mut span_viewables = Vec::new();\n+    for (bb, data) in body.basic_blocks().iter_enumerated() {\n+        match spanview {\n+            MirSpanview::Statement => {\n+                for (i, statement) in data.statements.iter().enumerate() {\n+                    if let Some(span_viewable) =\n+                        statement_span_viewable(tcx, body_span, bb, i, statement)\n+                    {\n+                        span_viewables.push(span_viewable);\n+                    }\n+                }\n+                if let Some(span_viewable) = terminator_span_viewable(tcx, body_span, bb, data) {\n+                    span_viewables.push(span_viewable);\n+                }\n+            }\n+            MirSpanview::Terminator => {\n+                if let Some(span_viewable) = terminator_span_viewable(tcx, body_span, bb, data) {\n+                    span_viewables.push(span_viewable);\n+                }\n+            }\n+            MirSpanview::Block => {\n+                if let Some(span_viewable) = block_span_viewable(tcx, body_span, bb, data) {\n+                    span_viewables.push(span_viewable);\n+                }\n+            }\n+        }\n+    }\n+    write_spanview_document(tcx, def_id, span_viewables, w)?;\n+    Ok(())\n+}\n+\n+/// Generate a spanview HTML+CSS document for the given local function `def_id`, and a pre-generated\n+/// list `SpanViewable`s.\n+pub fn write_spanview_document<'tcx, W>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    mut span_viewables: Vec<SpanViewable>,\n+    w: &mut W,\n+) -> io::Result<()>\n+where\n+    W: Write,\n+{\n+    let fn_span = fn_span(tcx, def_id);\n+    writeln!(w, \"{}\", HEADER)?;\n+    let mut next_pos = fn_span.lo();\n+    let end_pos = fn_span.hi();\n+    let source_map = tcx.sess.source_map();\n+    let start = source_map.lookup_char_pos(next_pos);\n+    write!(\n+        w,\n+        r#\"<div class=\"code\" style=\"counter-reset: line {}\"><span class=\"line\">{}\"#,\n+        start.line - 1,\n+        \" \".repeat(start.col.to_usize())\n+    )?;\n+    span_viewables.sort_unstable_by(|a, b| {\n+        let a = a.span;\n+        let b = b.span;\n+        if a.lo() == b.lo() {\n+            // Sort hi() in reverse order so shorter spans are attempted after longer spans.\n+            // This should give shorter spans a higher \"layer\", so they are not covered by\n+            // the longer spans.\n+            b.hi().partial_cmp(&a.hi())\n+        } else {\n+            a.lo().partial_cmp(&b.lo())\n+        }\n+        .unwrap()\n+    });\n+    let mut ordered_span_viewables = span_viewables.iter().peekable();\n+    let mut alt = false;\n+    while ordered_span_viewables.peek().is_some() {\n+        next_pos = write_span_viewables(tcx, next_pos, &mut ordered_span_viewables, false, 1, w)?;\n+        alt = !alt;\n+    }\n+    if next_pos < end_pos {\n+        write_coverage_gap(tcx, next_pos, end_pos, w)?;\n+    }\n+    write!(w, r#\"</span></div>\"#)?;\n+    writeln!(w, \"{}\", FOOTER)?;\n+    Ok(())\n+}\n+\n+/// Format a string showing the start line and column, and end line and column within a file.\n+pub fn source_range_no_file<'tcx>(tcx: TyCtxt<'tcx>, span: &Span) -> String {\n+    let source_map = tcx.sess.source_map();\n+    let start = source_map.lookup_char_pos(span.lo());\n+    let end = source_map.lookup_char_pos(span.hi());\n+    format!(\"{}:{}-{}:{}\", start.line, start.col.to_usize() + 1, end.line, end.col.to_usize() + 1)\n+}\n+\n+pub fn statement_kind_name(statement: &Statement<'_>) -> &'static str {\n+    use StatementKind::*;\n+    match statement.kind {\n+        Assign(..) => \"Assign\",\n+        FakeRead(..) => \"FakeRead\",\n+        SetDiscriminant { .. } => \"SetDiscriminant\",\n+        StorageLive(..) => \"StorageLive\",\n+        StorageDead(..) => \"StorageDead\",\n+        LlvmInlineAsm(..) => \"LlvmInlineAsm\",\n+        Retag(..) => \"Retag\",\n+        AscribeUserType(..) => \"AscribeUserType\",\n+        Coverage(..) => \"Coverage\",\n+        Nop => \"Nop\",\n+    }\n+}\n+\n+pub fn terminator_kind_name(term: &Terminator<'_>) -> &'static str {\n+    use TerminatorKind::*;\n+    match term.kind {\n+        Goto { .. } => \"Goto\",\n+        SwitchInt { .. } => \"SwitchInt\",\n+        Resume => \"Resume\",\n+        Abort => \"Abort\",\n+        Return => \"Return\",\n+        Unreachable => \"Unreachable\",\n+        Drop { .. } => \"Drop\",\n+        DropAndReplace { .. } => \"DropAndReplace\",\n+        Call { .. } => \"Call\",\n+        Assert { .. } => \"Assert\",\n+        Yield { .. } => \"Yield\",\n+        GeneratorDrop => \"GeneratorDrop\",\n+        FalseEdge { .. } => \"FalseEdge\",\n+        FalseUnwind { .. } => \"FalseUnwind\",\n+        InlineAsm { .. } => \"InlineAsm\",\n+    }\n+}\n+\n+fn statement_span_viewable<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body_span: Span,\n+    bb: BasicBlock,\n+    i: usize,\n+    statement: &Statement<'tcx>,\n+) -> Option<SpanViewable> {\n+    let span = statement.source_info.span;\n+    if !body_span.contains(span) {\n+        return None;\n+    }\n+    let title = format!(\"bb{}[{}]\", bb.index(), i);\n+    let tooltip = tooltip(tcx, &title, span, vec![statement.clone()], &None);\n+    Some(SpanViewable { span, title, tooltip })\n+}\n+\n+fn terminator_span_viewable<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body_span: Span,\n+    bb: BasicBlock,\n+    data: &BasicBlockData<'tcx>,\n+) -> Option<SpanViewable> {\n+    let term = data.terminator();\n+    let span = term.source_info.span;\n+    if !body_span.contains(span) {\n+        return None;\n+    }\n+    let title = format!(\"bb{}`{}`\", bb.index(), terminator_kind_name(term));\n+    let tooltip = tooltip(tcx, &title, span, vec![], &data.terminator);\n+    Some(SpanViewable { span, title, tooltip })\n+}\n+\n+fn block_span_viewable<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body_span: Span,\n+    bb: BasicBlock,\n+    data: &BasicBlockData<'tcx>,\n+) -> Option<SpanViewable> {\n+    let span = compute_block_span(data, body_span);\n+    if !body_span.contains(span) {\n+        return None;\n+    }\n+    let title = format!(\"bb{}\", bb.index());\n+    let tooltip = tooltip(tcx, &title, span, data.statements.clone(), &data.terminator);\n+    Some(SpanViewable { span, title, tooltip })\n+}\n+\n+fn compute_block_span<'tcx>(data: &BasicBlockData<'tcx>, body_span: Span) -> Span {\n+    let mut span = data.terminator().source_info.span;\n+    for statement_span in data.statements.iter().map(|statement| statement.source_info.span) {\n+        // Only combine Spans from the function's body_span.\n+        if body_span.contains(statement_span) {\n+            span = span.to(statement_span);\n+        }\n+    }\n+    span\n+}\n+\n+/// Recursively process each ordered span. Spans that overlap will have progressively varying\n+/// styles, such as increased padding for each overlap. Non-overlapping adjacent spans will\n+/// have alternating style choices, to help distinguish between them if, visually adjacent.\n+/// The `layer` is incremented for each overlap, and the `alt` bool alternates between true\n+/// and false, for each adjacent non-overlapping span. Source code between the spans (code\n+/// that is not in any coverage region) has neutral styling.\n+fn write_span_viewables<'tcx, 'b, W>(\n+    tcx: TyCtxt<'tcx>,\n+    next_pos: BytePos,\n+    ordered_span_viewables: &mut Peekable<impl Iterator<Item = &'b SpanViewable>>,\n+    alt: bool,\n+    layer: usize,\n+    w: &mut W,\n+) -> io::Result<BytePos>\n+where\n+    W: Write,\n+{\n+    let span_viewable =\n+        ordered_span_viewables.next().expect(\"ordered_span_viewables should have some\");\n+    if next_pos < span_viewable.span.lo() {\n+        write_coverage_gap(tcx, next_pos, span_viewable.span.lo(), w)?;\n+    }\n+    let mut remaining_span = span_viewable.span;\n+    let mut subalt = false;\n+    loop {\n+        let next_span_viewable = match ordered_span_viewables.peek() {\n+            None => break,\n+            Some(span_viewable) => *span_viewable,\n+        };\n+        if !next_span_viewable.span.overlaps(remaining_span) {\n+            break;\n+        }\n+        write_span(\n+            tcx,\n+            remaining_span.until(next_span_viewable.span),\n+            Some(span_viewable),\n+            alt,\n+            layer,\n+            w,\n+        )?;\n+        let next_pos = write_span_viewables(\n+            tcx,\n+            next_span_viewable.span.lo(),\n+            ordered_span_viewables,\n+            subalt,\n+            layer + 1,\n+            w,\n+        )?;\n+        subalt = !subalt;\n+        if next_pos < remaining_span.hi() {\n+            remaining_span = remaining_span.with_lo(next_pos);\n+        } else {\n+            return Ok(next_pos);\n+        }\n+    }\n+    write_span(tcx, remaining_span, Some(span_viewable), alt, layer, w)\n+}\n+\n+fn write_coverage_gap<'tcx, W>(\n+    tcx: TyCtxt<'tcx>,\n+    lo: BytePos,\n+    hi: BytePos,\n+    w: &mut W,\n+) -> io::Result<BytePos>\n+where\n+    W: Write,\n+{\n+    write_span(tcx, Span::with_root_ctxt(lo, hi), None, false, 0, w)\n+}\n+\n+fn write_span<'tcx, W>(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    span_viewable: Option<&SpanViewable>,\n+    alt: bool,\n+    layer: usize,\n+    w: &mut W,\n+) -> io::Result<BytePos>\n+where\n+    W: Write,\n+{\n+    let source_map = tcx.sess.source_map();\n+    let snippet = source_map\n+        .span_to_snippet(span)\n+        .unwrap_or_else(|err| bug!(\"span_to_snippet error for span {:?}: {:?}\", span, err));\n+    let labeled_snippet = if let Some(SpanViewable { title, .. }) = span_viewable {\n+        if span.is_empty() {\n+            format!(r#\"<span class=\"annotation\">@{}</span>\"#, title)\n+        } else {\n+            format!(r#\"<span class=\"annotation\">@{}:</span> {}\"#, title, escape_html(&snippet))\n+        }\n+    } else {\n+        snippet\n+    };\n+    let maybe_alt = if layer > 0 {\n+        if alt { \" odd\" } else { \" even\" }\n+    } else {\n+        \"\"\n+    };\n+    let maybe_tooltip = if let Some(SpanViewable { tooltip, .. }) = span_viewable {\n+        format!(\" title=\\\"{}\\\"\", escape_attr(tooltip))\n+    } else {\n+        \"\".to_owned()\n+    };\n+    if layer == 1 {\n+        write!(w, \"<span>\")?;\n+    }\n+    for (i, line) in labeled_snippet.lines().enumerate() {\n+        if i > 0 {\n+            write!(w, \"{}\", NEW_LINE_SPAN)?;\n+        }\n+        write!(\n+            w,\n+            r#\"<span class=\"code{}\" style=\"--layer: {}\"{}>{}</span>\"#,\n+            maybe_alt, layer, maybe_tooltip, line\n+        )?;\n+    }\n+    if layer == 1 {\n+        write!(w, \"</span>\")?;\n+    }\n+    Ok(span.hi())\n+}\n+\n+fn tooltip<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    title: &str,\n+    span: Span,\n+    statements: Vec<Statement<'tcx>>,\n+    terminator: &Option<Terminator<'tcx>>,\n+) -> String {\n+    let source_map = tcx.sess.source_map();\n+    let mut text = Vec::new();\n+    text.push(format!(\"{}: {}:\", title, &source_map.span_to_string(span)));\n+    for statement in statements {\n+        let source_range = source_range_no_file(tcx, &statement.source_info.span);\n+        text.push(format!(\n+            \"\\n{}{}: {}: {}\",\n+            TOOLTIP_INDENT,\n+            source_range,\n+            statement_kind_name(&statement),\n+            format!(\"{:?}\", statement)\n+        ));\n+    }\n+    if let Some(term) = terminator {\n+        let source_range = source_range_no_file(tcx, &term.source_info.span);\n+        text.push(format!(\n+            \"\\n{}{}: {}: {:?}\",\n+            TOOLTIP_INDENT,\n+            source_range,\n+            terminator_kind_name(term),\n+            term.kind\n+        ));\n+    }\n+    text.join(\"\")\n+}\n+\n+fn fn_span<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Span {\n+    let hir_id =\n+        tcx.hir().local_def_id_to_hir_id(def_id.as_local().expect(\"expected DefId is local\"));\n+    tcx.hir().span(hir_id)\n+}\n+\n+fn hir_body<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx rustc_hir::Body<'tcx> {\n+    let hir_node = tcx.hir().get_if_local(def_id).expect(\"expected DefId is local\");\n+    let fn_body_id = hir::map::associated_body(hir_node).expect(\"HIR node is a function with body\");\n+    tcx.hir().body(fn_body_id)\n+}\n+\n+fn escape_html(s: &str) -> String {\n+    s.replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\n+}\n+\n+fn escape_attr(s: &str) -> String {\n+    s.replace(\"&\", \"&amp;\")\n+        .replace(\"\\\"\", \"&quot;\")\n+        .replace(\"'\", \"&#39;\")\n+        .replace(\"<\", \"&lt;\")\n+        .replace(\">\", \"&gt;\")\n+}"}, {"sha": "947ca6b5bd562155dc4059f4694dd2048f29855f", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -10,7 +10,7 @@ use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, TokenKind};\n use rustc_ast::util::classify;\n-use rustc_ast::{AttrStyle, AttrVec, Attribute, MacCall, MacStmtStyle};\n+use rustc_ast::{AttrStyle, AttrVec, Attribute, MacCall, MacCallStmt, MacStmtStyle};\n use rustc_ast::{Block, BlockCheckMode, Expr, ExprKind, Local, Stmt, StmtKind, DUMMY_NODE_ID};\n use rustc_errors::{Applicability, PResult};\n use rustc_span::source_map::{BytePos, Span};\n@@ -107,7 +107,7 @@ impl<'a> Parser<'a> {\n \n         let kind = if delim == token::Brace || self.token == token::Semi || self.token == token::Eof\n         {\n-            StmtKind::MacCall(P((mac, style, attrs)))\n+            StmtKind::MacCall(P(MacCallStmt { mac, style, attrs }))\n         } else {\n             // Since none of the above applied, this is an expression statement macro.\n             let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac), AttrVec::new());"}, {"sha": "50729086ec6acb1ae122f0201f5ccd5a1e1b3ec9", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -867,6 +867,12 @@ pub struct ExternPreludeEntry<'a> {\n     pub introduced_by_item: bool,\n }\n \n+/// Used for better errors for E0773\n+enum BuiltinMacroState {\n+    NotYetSeen(SyntaxExtension),\n+    AlreadySeen(Span),\n+}\n+\n /// The main resolver class.\n ///\n /// This is the visitor that walks the whole crate.\n@@ -960,7 +966,7 @@ pub struct Resolver<'a> {\n \n     crate_loader: CrateLoader<'a>,\n     macro_names: FxHashSet<Ident>,\n-    builtin_macros: FxHashMap<Symbol, SyntaxExtension>,\n+    builtin_macros: FxHashMap<Symbol, BuiltinMacroState>,\n     registered_attrs: FxHashSet<Ident>,\n     registered_tools: FxHashSet<Ident>,\n     macro_use_prelude: FxHashMap<Symbol, &'a NameBinding<'a>>,"}, {"sha": "bea7138964764126c561a97144e5c06c1cda666c", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -3,14 +3,15 @@\n \n use crate::imports::ImportResolver;\n use crate::Namespace::*;\n-use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy};\n+use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BuiltinMacroState, Determinacy};\n use crate::{CrateLint, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Weak};\n use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment, ToNameBinding};\n use rustc_ast::{self as ast, NodeId};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::struct_span_err;\n use rustc_expand::base::{Indeterminate, InvocationRes, ResolverExpand, SyntaxExtension};\n use rustc_expand::compile_declarative_macro;\n use rustc_expand::expand::{AstFragment, AstFragmentKind, Invocation, InvocationKind};\n@@ -166,7 +167,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n     }\n \n     fn register_builtin_macro(&mut self, ident: Ident, ext: SyntaxExtension) {\n-        if self.builtin_macros.insert(ident.name, ext).is_some() {\n+        if self.builtin_macros.insert(ident.name, BuiltinMacroState::NotYetSeen(ext)).is_some() {\n             self.session\n                 .span_err(ident.span, &format!(\"built-in macro `{}` was already defined\", ident));\n         }\n@@ -1076,10 +1077,23 @@ impl<'a> Resolver<'a> {\n \n         if result.is_builtin {\n             // The macro was marked with `#[rustc_builtin_macro]`.\n-            if let Some(ext) = self.builtin_macros.remove(&item.ident.name) {\n+            if let Some(builtin_macro) = self.builtin_macros.get_mut(&item.ident.name) {\n                 // The macro is a built-in, replace its expander function\n                 // while still taking everything else from the source code.\n-                result.kind = ext.kind;\n+                // If we already loaded this builtin macro, give a better error message than 'no such builtin macro'.\n+                match mem::replace(builtin_macro, BuiltinMacroState::AlreadySeen(item.span)) {\n+                    BuiltinMacroState::NotYetSeen(ext) => result.kind = ext.kind,\n+                    BuiltinMacroState::AlreadySeen(span) => {\n+                        struct_span_err!(\n+                            self.session,\n+                            item.span,\n+                            E0773,\n+                            \"attempted to define built-in macro more than once\"\n+                        )\n+                        .span_note(span, \"previously defined here\")\n+                        .emit();\n+                    }\n+                }\n             } else {\n                 let msg = format!(\"cannot find a built-in macro with name `{}`\", item.ident);\n                 self.session.span_err(item.span, &msg);"}, {"sha": "6861314a88f6fc1843c7f731fb1dcb71d3cfba5a", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -163,6 +163,21 @@ pub enum LtoCli {\n     Unspecified,\n }\n \n+/// The different settings that the `-Z dump_mir_spanview` flag can have. `Statement` generates a\n+/// document highlighting each span of every statement (including terminators). `Terminator` and\n+/// `Block` highlight a single span per `BasicBlock`: the span of the block's `Terminator`, or a\n+/// computed span for the block, representing the entire range, covering the block's terminator and\n+/// all of its statements.\n+#[derive(Clone, Copy, PartialEq, Hash, Debug)]\n+pub enum MirSpanview {\n+    /// Default `-Z dump_mir_spanview` or `-Z dump_mir_spanview=statement`\n+    Statement,\n+    /// `-Z dump_mir_spanview=terminator`\n+    Terminator,\n+    /// `-Z dump_mir_spanview=block`\n+    Block,\n+}\n+\n #[derive(Clone, PartialEq, Hash)]\n pub enum LinkerPluginLto {\n     LinkerPlugin(PathBuf),"}, {"sha": "a28c17917df3b8c4ee614d124acb5745795bc507", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -255,6 +255,7 @@ macro_rules! options {\n         pub const parse_strip: &str = \"either `none`, `debuginfo`, or `symbols`\";\n         pub const parse_linker_flavor: &str = ::rustc_target::spec::LinkerFlavor::one_of();\n         pub const parse_optimization_fuel: &str = \"crate=integer\";\n+        pub const parse_mir_spanview: &str = \"`statement` (default), `terminator`, or `block`\";\n         pub const parse_unpretty: &str = \"`string` or `string=string`\";\n         pub const parse_treat_err_as_bug: &str = \"either no value or a number bigger than 0\";\n         pub const parse_lto: &str =\n@@ -551,6 +552,36 @@ macro_rules! options {\n             }\n         }\n \n+        fn parse_mir_spanview(slot: &mut Option<MirSpanview>, v: Option<&str>) -> bool {\n+            if v.is_some() {\n+                let mut bool_arg = None;\n+                if parse_opt_bool(&mut bool_arg, v) {\n+                    *slot = if bool_arg.unwrap() {\n+                        Some(MirSpanview::Statement)\n+                    } else {\n+                        None\n+                    };\n+                    return true\n+                }\n+            }\n+\n+            let v = match v {\n+                None => {\n+                    *slot = Some(MirSpanview::Statement);\n+                    return true;\n+                }\n+                Some(v) => v,\n+            };\n+\n+            *slot = Some(match v.trim_end_matches(\"s\") {\n+                \"statement\" | \"stmt\" => MirSpanview::Statement,\n+                \"terminator\" | \"term\" => MirSpanview::Terminator,\n+                \"block\" | \"basicblock\" => MirSpanview::Block,\n+                _ => return false,\n+            });\n+            true\n+        }\n+\n         fn parse_treat_err_as_bug(slot: &mut Option<usize>, v: Option<&str>) -> bool {\n             match v {\n                 Some(s) => { *slot = s.parse().ok().filter(|&x| x != 0); slot.unwrap_or(0) != 0 }\n@@ -719,6 +750,9 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"extra arguments to append to the linker invocation (space separated)\"),\n     link_dead_code: Option<bool> = (None, parse_opt_bool, [UNTRACKED],\n         \"keep dead code at link time (useful for code coverage) (default: no)\"),\n+    link_self_contained: Option<bool> = (None, parse_opt_bool, [UNTRACKED],\n+        \"control whether to link Rust provided C objects/libraries or rely\n+        on C toolchain installed in the system\"),\n     linker: Option<PathBuf> = (None, parse_opt_pathbuf, [UNTRACKED],\n         \"system linker to link outputs with\"),\n     linker_flavor: Option<LinkerFlavor> = (None, parse_linker_flavor, [UNTRACKED],\n@@ -849,6 +883,11 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"exclude the pass number when dumping MIR (used in tests) (default: no)\"),\n     dump_mir_graphviz: bool = (false, parse_bool, [UNTRACKED],\n         \"in addition to `.mir` files, create graphviz `.dot` files (default: no)\"),\n+    dump_mir_spanview: Option<MirSpanview> = (None, parse_mir_spanview, [UNTRACKED],\n+        \"in addition to `.mir` files, create `.html` files to view spans for \\\n+        all `statement`s (including terminators), only `terminator` spans, or \\\n+        computed `block` spans (one span encompassing a block's terminator and \\\n+        all statements).\"),\n     emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],\n         \"emit a section containing stack size metadata (default: no)\"),\n     fewer_names: bool = (false, parse_bool, [TRACKED],\n@@ -894,9 +933,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"keep hygiene data after analysis (default: no)\"),\n     link_native_libraries: bool = (true, parse_bool, [UNTRACKED],\n         \"link native libraries in the linker invocation (default: yes)\"),\n-    link_self_contained: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"control whether to link Rust provided C objects/libraries or rely\n-         on C toolchain installed in the system\"),\n     link_only: bool = (false, parse_bool, [TRACKED],\n         \"link the `.rlink` file generated by `-Z no-link` (default: no)\"),\n     llvm_time_trace: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "a953a3a4182bce854c29c7f02a5aceb67ccbf945", "filename": "library/core/src/clone.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fcore%2Fsrc%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fcore%2Fsrc%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fclone.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -7,11 +7,9 @@\n //! contain owned boxes or implement [`Drop`]), so the compiler considers\n //! them cheap and safe to copy. For other types copies must be made\n //! explicitly, by convention implementing the [`Clone`] trait and calling\n-//! the [`clone`][clone] method.\n+//! the [`clone`] method.\n //!\n-//! [`Clone`]: trait.Clone.html\n-//! [clone]: trait.Clone.html#tymethod.clone\n-//! [`Drop`]: ../../std/ops/trait.Drop.html\n+//! [`clone`]: Clone::clone\n //!\n //! Basic usage example:\n //!\n@@ -51,7 +49,9 @@\n /// ## Derivable\n ///\n /// This trait can be used with `#[derive]` if all fields are `Clone`. The `derive`d\n-/// implementation of [`clone`] calls [`clone`] on each field.\n+/// implementation of [`Clone`] calls [`clone`] on each field.\n+///\n+/// [`clone`]: Clone::clone\n ///\n /// For a generic struct, `#[derive]` implements `Clone` conditionally by adding bound `Clone` on\n /// generic parameters.\n@@ -74,9 +74,6 @@\n /// An example is a generic struct holding a function pointer. In this case, the\n /// implementation of `Clone` cannot be `derive`d, but can be implemented as:\n ///\n-/// [`Copy`]: ../../std/marker/trait.Copy.html\n-/// [`clone`]: trait.Clone.html#tymethod.clone\n-///\n /// ```\n /// struct Generate<T>(fn() -> T);\n ///"}, {"sha": "1be9c4de916871f088dd4871b6c5bc9ae2d55aa2", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -135,7 +135,7 @@\n //! methods like `nth` and `fold` if an iterator can compute them more efficiently without calling\n //! `next`.\n //!\n-//! # for Loops and IntoIterator\n+//! # `for` loops and `IntoIterator`\n //!\n //! Rust's `for` loop syntax is actually sugar for iterators. Here's a basic\n //! example of `for`:"}, {"sha": "0bac21406bf4ee025e8792eaf98bdbdf3f0d3c58", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -3078,6 +3078,7 @@ pub trait Iterator {\n     /// assert_eq!([1].iter().lt([1].iter()), false);\n     /// assert_eq!([1].iter().lt([1, 2].iter()), true);\n     /// assert_eq!([1, 2].iter().lt([1].iter()), false);\n+    /// assert_eq!([1, 2].iter().lt([1, 2].iter()), false);\n     /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn lt<I>(self, other: I) -> bool\n@@ -3098,6 +3099,7 @@ pub trait Iterator {\n     /// assert_eq!([1].iter().le([1].iter()), true);\n     /// assert_eq!([1].iter().le([1, 2].iter()), true);\n     /// assert_eq!([1, 2].iter().le([1].iter()), false);\n+    /// assert_eq!([1, 2].iter().le([1, 2].iter()), true);\n     /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn le<I>(self, other: I) -> bool\n@@ -3118,6 +3120,7 @@ pub trait Iterator {\n     /// assert_eq!([1].iter().gt([1].iter()), false);\n     /// assert_eq!([1].iter().gt([1, 2].iter()), false);\n     /// assert_eq!([1, 2].iter().gt([1].iter()), true);\n+    /// assert_eq!([1, 2].iter().gt([1, 2].iter()), false);\n     /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn gt<I>(self, other: I) -> bool\n@@ -3138,6 +3141,7 @@ pub trait Iterator {\n     /// assert_eq!([1].iter().ge([1].iter()), true);\n     /// assert_eq!([1].iter().ge([1, 2].iter()), false);\n     /// assert_eq!([1, 2].iter().ge([1].iter()), true);\n+    /// assert_eq!([1, 2].iter().ge([1, 2].iter()), true);\n     /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn ge<I>(self, other: I) -> bool"}, {"sha": "a1b0821004b5ff2e1eef1d3d30ed87a7d9a36c97", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -242,7 +242,7 @@ macro_rules! debug_assert_ne {\n #[macro_export]\n #[stable(feature = \"matches_macro\", since = \"1.42.0\")]\n macro_rules! matches {\n-    ($expression:expr, $( $pattern:pat )|+ $( if $guard: expr )?) => {\n+    ($expression:expr, $( $pattern:pat )|+ $( if $guard: expr )? $(,)?) => {\n         match $expression {\n             $( $pattern )|+ $( if $guard )? => true,\n             _ => false"}, {"sha": "25ee73c626eace350acbd8f233df23a8c5bf6635", "filename": "library/core/src/panic.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fcore%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fcore%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -92,8 +92,6 @@ impl<'a> PanicInfo<'a> {\n     /// If the `panic!` macro from the `core` crate (not from `std`)\n     /// was used with a formatting string and some additional arguments,\n     /// returns that message ready to be used for example with [`fmt::write`]\n-    ///\n-    /// [`fmt::write`]: ../fmt/fn.write.html\n     #[unstable(feature = \"panic_info_message\", issue = \"66745\")]\n     pub fn message(&self) -> Option<&fmt::Arguments<'_>> {\n         self.message\n@@ -105,8 +103,6 @@ impl<'a> PanicInfo<'a> {\n     /// This method will currently always return [`Some`], but this may change\n     /// in future versions.\n     ///\n-    /// [`Some`]: ../../std/option/enum.Option.html#variant.Some\n-    ///\n     /// # Examples\n     ///\n     /// ```should_panic\n@@ -153,10 +149,7 @@ impl fmt::Display for PanicInfo<'_> {\n \n /// A struct containing information about the location of a panic.\n ///\n-/// This structure is created by the [`location`] method of [`PanicInfo`].\n-///\n-/// [`location`]: ../../std/panic/struct.PanicInfo.html#method.location\n-/// [`PanicInfo`]: ../../std/panic/struct.PanicInfo.html\n+/// This structure is created by [`PanicInfo::location()`].\n ///\n /// # Examples\n ///"}, {"sha": "3141b3b9526d0bb5f1b42de8d1f7aa05f0b4f8c0", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -238,6 +238,7 @@\n #![feature(concat_idents)]\n #![feature(const_cstr_unchecked)]\n #![feature(const_fn_transmute)]\n+#![feature(const_ipv6)]\n #![feature(const_raw_ptr_deref)]\n #![feature(container_error_extra)]\n #![feature(core_intrinsics)]"}, {"sha": "341a112df71b3c51775af40a39e8620b73e10f1a", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -1102,8 +1102,9 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).segments(),\n     ///            [0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff]);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn segments(&self) -> [u16; 8] {\n+    pub const fn segments(&self) -> [u16; 8] {\n         // All elements in `s6_addr` must be big endian.\n         // SAFETY: `[u8; 16]` is always safe to transmute to `[u16; 8]`.\n         let [a, b, c, d, e, f, g, h] = unsafe { transmute::<_, [u16; 8]>(self.inner.s6_addr) };\n@@ -1135,9 +1136,10 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unspecified(), false);\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).is_unspecified(), true);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_unspecified(&self) -> bool {\n-        self.segments() == [0, 0, 0, 0, 0, 0, 0, 0]\n+    pub const fn is_unspecified(&self) -> bool {\n+        u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::UNSPECIFIED.octets())\n     }\n \n     /// Returns [`true`] if this is a loopback address (::1).\n@@ -1155,9 +1157,10 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_loopback(), false);\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_loopback(), true);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_loopback(&self) -> bool {\n-        self.segments() == [0, 0, 0, 0, 0, 0, 0, 1]\n+    pub const fn is_loopback(&self) -> bool {\n+        u128::from_be_bytes(self.octets()) == u128::from_be_bytes(Ipv6Addr::LOCALHOST.octets())\n     }\n \n     /// Returns [`true`] if the address appears to be globally routable.\n@@ -1182,7 +1185,8 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0x1).is_global(), false);\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1).is_global(), true);\n     /// ```\n-    pub fn is_global(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    pub const fn is_global(&self) -> bool {\n         match self.multicast_scope() {\n             Some(Ipv6MulticastScope::Global) => true,\n             None => self.is_unicast_global(),\n@@ -1208,7 +1212,8 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unique_local(), false);\n     /// assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 0).is_unique_local(), true);\n     /// ```\n-    pub fn is_unique_local(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    pub const fn is_unique_local(&self) -> bool {\n         (self.segments()[0] & 0xfe00) == 0xfc00\n     }\n \n@@ -1263,7 +1268,8 @@ impl Ipv6Addr {\n     /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n     /// [IETF RFC 4291 section 2.5.6]: https://tools.ietf.org/html/rfc4291#section-2.5.6\n     /// [RFC 4291 errata 4406]: https://www.rfc-editor.org/errata/eid4406\n-    pub fn is_unicast_link_local_strict(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    pub const fn is_unicast_link_local_strict(&self) -> bool {\n         (self.segments()[0] & 0xffff) == 0xfe80\n             && (self.segments()[1] & 0xffff) == 0\n             && (self.segments()[2] & 0xffff) == 0\n@@ -1320,7 +1326,8 @@ impl Ipv6Addr {\n     ///\n     /// [IETF RFC 4291 section 2.4]: https://tools.ietf.org/html/rfc4291#section-2.4\n     /// [RFC 4291 errata 4406]: https://www.rfc-editor.org/errata/eid4406\n-    pub fn is_unicast_link_local(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    pub const fn is_unicast_link_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfe80\n     }\n \n@@ -1359,7 +1366,8 @@ impl Ipv6Addr {\n     /// addresses.\n     ///\n     /// [RFC 3879]: https://tools.ietf.org/html/rfc3879\n-    pub fn is_unicast_site_local(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    pub const fn is_unicast_site_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfec0\n     }\n \n@@ -1381,7 +1389,8 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_documentation(), false);\n     /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_documentation(), true);\n     /// ```\n-    pub fn is_documentation(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    pub const fn is_documentation(&self) -> bool {\n         (self.segments()[0] == 0x2001) && (self.segments()[1] == 0xdb8)\n     }\n \n@@ -1416,7 +1425,8 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).is_unicast_global(), false);\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_unicast_global(), true);\n     /// ```\n-    pub fn is_unicast_global(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    pub const fn is_unicast_global(&self) -> bool {\n         !self.is_multicast()\n             && !self.is_loopback()\n             && !self.is_unicast_link_local()\n@@ -1440,7 +1450,8 @@ impl Ipv6Addr {\n     /// );\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).multicast_scope(), None);\n     /// ```\n-    pub fn multicast_scope(&self) -> Option<Ipv6MulticastScope> {\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    pub const fn multicast_scope(&self) -> Option<Ipv6MulticastScope> {\n         if self.is_multicast() {\n             match self.segments()[0] & 0x000f {\n                 1 => Some(Ipv6MulticastScope::InterfaceLocal),\n@@ -1472,8 +1483,9 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0).is_multicast(), true);\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_multicast(), false);\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n-    pub fn is_multicast(&self) -> bool {\n+    pub const fn is_multicast(&self) -> bool {\n         (self.segments()[0] & 0xff00) == 0xff00\n     }\n \n@@ -1498,7 +1510,8 @@ impl Ipv6Addr {\n     ///            Some(Ipv4Addr::new(192, 10, 2, 255)));\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4_mapped(), None);\n     /// ```\n-    pub fn to_ipv4_mapped(&self) -> Option<Ipv4Addr> {\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n+    pub const fn to_ipv4_mapped(&self) -> Option<Ipv4Addr> {\n         match self.octets() {\n             [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, a, b, c, d] => {\n                 Some(Ipv4Addr::new(a, b, c, d))\n@@ -1525,8 +1538,9 @@ impl Ipv6Addr {\n     /// assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_ipv4(),\n     ///            Some(Ipv4Addr::new(0, 0, 0, 1)));\n     /// ```\n+    #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn to_ipv4(&self) -> Option<Ipv4Addr> {\n+    pub const fn to_ipv4(&self) -> Option<Ipv4Addr> {\n         if let [0, 0, 0, 0, 0, 0 | 0xffff, ab, cd] = self.segments() {\n             let [a, b] = ab.to_be_bytes();\n             let [c, d] = cd.to_be_bytes();"}, {"sha": "d00824cfb3e98b3429faae874348e0a195b5a058", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -1,7 +1,6 @@\n #[doc(primitive = \"bool\")]\n #[doc(alias = \"true\")]\n #[doc(alias = \"false\")]\n-//\n /// The boolean type.\n ///\n /// The `bool` represents a value, which could only be either `true` or `false`. If you cast\n@@ -12,8 +11,8 @@\n /// `bool` implements various traits, such as [`BitAnd`], [`BitOr`], [`Not`], etc.,\n /// which allow us to perform boolean operations using `&`, `|` and `!`.\n ///\n-/// `if` always demands a `bool` value. [`assert!`], being an important macro in testing,\n-/// checks whether an expression returns `true`.\n+/// `if` always demands a `bool` value. [`assert!`], which is an important macro in testing,\n+/// checks whether an expression returns `true` and panics if it isn't.\n ///\n /// ```\n /// let bool_val = true & false | false;\n@@ -194,14 +193,48 @@ mod prim_bool {}\n /// # `!` and traits\n ///\n /// When writing your own traits, `!` should have an `impl` whenever there is an obvious `impl`\n-/// which doesn't `panic!`. As it turns out, most traits can have an `impl` for `!`. Take [`Debug`]\n+/// which doesn't `panic!`. The reason is that functions returning an `impl Trait` where `!`\n+/// does not have an `impl` of `Trait` cannot diverge as their only possible code path. In other\n+/// words, they can't return `!` from every code path. As an example, this code doesn't compile:\n+///\n+/// ```compile_fail\n+/// use core::ops::Add;\n+///\n+/// fn foo() -> impl Add<u32> {\n+///     unimplemented!()\n+/// }\n+/// ```\n+///\n+/// But this code does:\n+///\n+/// ```\n+/// use core::ops::Add;\n+///\n+/// fn foo() -> impl Add<u32> {\n+///     if true {\n+///         unimplemented!()\n+///     } else {\n+///         0\n+///     }\n+/// }\n+/// ```\n+///\n+/// The reason is that, in the first example, there are many possible types that `!` could coerce\n+/// to, because many types implement `Add<u32>`. However, in the second example,\n+/// the `else` branch returns a `0`, which the compiler infers from the return type to be of type\n+/// `u32`. Since `u32` is a concrete type, `!` can and will be coerced to it. See issue [#36375]\n+/// for more information on this quirk of `!`.\n+///\n+/// [#36375]: https://github.com/rust-lang/rust/issues/36375\n+///\n+/// As it turns out, though, most traits can have an `impl` for `!`. Take [`Debug`]\n /// for example:\n ///\n /// ```\n /// #![feature(never_type)]\n /// # use std::fmt;\n /// # trait Debug {\n-/// # fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result;\n+/// #     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result;\n /// # }\n /// impl Debug for ! {\n ///     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "bed10ca16d326aec62183dbacfd96bbf7a32630c", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -44,13 +44,13 @@ incremental builds the default is 256 which allows caching to be more granular.\n \n ## control-flow-guard\n \n-This flag controls whether LLVM enables the Windows [Control Flow \n-Guard](https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard) \n-platform security feature. This flag is currently ignored for non-Windows targets. \n+This flag controls whether LLVM enables the Windows [Control Flow\n+Guard](https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard)\n+platform security feature. This flag is currently ignored for non-Windows targets.\n It takes one of the following values:\n \n * `y`, `yes`, `on`, `checks`, or no value: enable Control Flow Guard.\n-* `nochecks`: emit Control Flow Guard metadata without runtime enforcement checks (this \n+* `nochecks`: emit Control Flow Guard metadata without runtime enforcement checks (this\n should only be used for testing purposes as it does not provide security enforcement).\n * `n`, `no`, `off`: do not enable Control Flow Guard (the default).\n \n@@ -200,6 +200,18 @@ the following values:\n An example of when this flag might be useful is when trying to construct code coverage\n metrics.\n \n+## link-self-contained\n+\n+On targets that support it this flag controls whether the linker will use libraries and objects\n+shipped with Rust instead or those in the system.\n+It takes one of the following values:\n+\n+* no value: rustc will use heuristic to disable self-contained mode if system has necessary tools.\n+* `y`, `yes`, `on`: use only libraries/objects shipped with Rust.\n+* `n`, `no`, or `off`: rely on the user or the linker to provide non-Rust libraries/objects.\n+\n+This allows overriding cases when detection fails or user wants to use shipped libraries.\n+\n ## linker\n \n This flag controls which linker `rustc` invokes to link your code. It takes a"}, {"sha": "8e2869fef553e101824af966fd97609c140f4839", "filename": "src/doc/rustdoc/src/lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -51,7 +51,7 @@ warning: missing documentation for a function\n \n ## missing_doc_code_examples\n \n-This lint is **allowed by default**. It detects when a documentation block\n+This lint is **allowed by default** and is **nightly-only**. It detects when a documentation block\n is missing a code example. For example:\n \n ```rust"}, {"sha": "e4aba8963c7624285cb316f028e594144acb127a", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -1062,12 +1062,13 @@ themePicker.onblur = handleThemeButtonsBlur;\n             let content = format!(\n                 \"<h1 class='fqn'>\\\n                      <span class='in-band'>List of all crates</span>\\\n-                </h1><ul class='mod'>{}</ul>\",\n+                </h1>\\\n+                <ul class='crate mod'>{}</ul>\",\n                 krates\n                     .iter()\n                     .map(|s| {\n                         format!(\n-                            \"<li><a class=\\\"mod\\\" href=\\\"{}index.html\\\">{}</a></li>\",\n+                            \"<li><a class=\\\"crate mod\\\" href=\\\"{}index.html\\\">{}</a></li>\",\n                             ensure_trailing_slash(s),\n                             s\n                         )"}, {"sha": "b4571018270ac7866306394b4f55c2af0f05cd3d", "filename": "src/librustdoc/html/static/themes/ayu.css", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -178,6 +178,9 @@ pre {\n .content span.externcrate, .content span.mod, .content a.mod {\n \tcolor: #acccf9;\n }\n+.content ul.crate a.crate {\n+\tfont: 16px/1.6 \"Fira Sans\";\n+}\n .content span.struct, .content a.struct {\n \tcolor: #ffa0a5;\n }"}, {"sha": "fc1d6e0ede66e4af8dea70e4dae307ca568af4e1", "filename": "src/test/mir-opt/spanview-block.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fmir-opt%2Fspanview-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fmir-opt%2Fspanview-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fspanview-block.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -0,0 +1,5 @@\n+// Test spanview block output\n+// compile-flags: -Z dump-mir-spanview=block\n+\n+// EMIT_MIR spanview_block.main.mir_map.0.html\n+fn main() {}"}, {"sha": "a43ad5e71a3930931d6801ba0a3b786827384884", "filename": "src/test/mir-opt/spanview-statement.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fmir-opt%2Fspanview-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fmir-opt%2Fspanview-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fspanview-statement.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -0,0 +1,5 @@\n+// Test spanview output (the default value for `-Z dump-mir-spanview` is \"statement\")\n+// compile-flags: -Z dump-mir-spanview\n+\n+// EMIT_MIR spanview_statement.main.mir_map.0.html\n+fn main() {}"}, {"sha": "92e1411eadbdaf9ee4a111be6ed104352ca8862c", "filename": "src/test/mir-opt/spanview-terminator.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fmir-opt%2Fspanview-terminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fmir-opt%2Fspanview-terminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fspanview-terminator.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -0,0 +1,5 @@\n+// Test spanview terminator output\n+// compile-flags: -Z dump-mir-spanview=terminator\n+\n+// EMIT_MIR spanview_terminator.main.mir_map.0.html\n+fn main() {}"}, {"sha": "7c1b7bc3b84b0bb031a35775a334c8ca11de20a8", "filename": "src/test/mir-opt/spanview_block.main.mir_map.0.html", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fmir-opt%2Fspanview_block.main.mir_map.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fmir-opt%2Fspanview_block.main.mir_map.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fspanview_block.main.mir_map.0.html?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -0,0 +1,67 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+    <title>coverage_of_if_else - Code Regions</title>\n+    <style>\n+    .line {\n+        counter-increment: line;\n+    }\n+    .line:before {\n+        content: counter(line) \": \";\n+        font-family: Menlo, Monaco, monospace;\n+        font-style: italic;\n+        width: 3.8em;\n+        display: inline-block;\n+        text-align: right;\n+        filter: opacity(50%);\n+        -webkit-user-select: none;\n+    }\n+    .code {\n+        color: #dddddd;\n+        background-color: #222222;\n+        font-family: Menlo, Monaco, monospace;\n+        line-height: 1.4em;\n+        border-bottom: 2px solid #222222;\n+        white-space: pre;\n+        display: inline-block;\n+    }\n+    .odd {\n+        background-color: #55bbff;\n+        color: #223311;\n+    }\n+    .even {\n+        background-color: #ee7756;\n+        color: #551133;\n+    }\n+    .code {\n+        --index: calc(var(--layer) - 1);\n+        padding-top: calc(var(--index) * 0.15em);\n+        filter:\n+            hue-rotate(calc(var(--index) * 25deg))\n+            saturate(calc(100% - (var(--index) * 2%)))\n+            brightness(calc(100% - (var(--index) * 1.5%)));\n+    }\n+    .annotation {\n+        color: #4444ff;\n+        font-family: monospace;\n+        font-style: italic;\n+        display: none;\n+        -webkit-user-select: none;\n+    }\n+    body:active .annotation {\n+        /* requires holding mouse down anywhere on the page */\n+        display: inline-block;\n+    }\n+    span:hover .annotation {\n+        /* requires hover over a span ONLY on its first line */\n+        display: inline-block;\n+    }\n+    </style>\n+</head>\n+<body>\n+<div class=\"code\" style=\"counter-reset: line 4\"><span class=\"line\"><span class=\"code\" style=\"--layer: 0\">fn main() </span><span><span class=\"code even\" style=\"--layer: 1\" title=\"bb0: $DIR/spanview-block.rs:5:11: 5:13:\n+    5:11-5:13: Assign: _0 = const ()\n+    5:13-5:13: Goto: goto -&gt; bb2\"><span class=\"annotation\">@bb0:</span> {}</span></span><span><span class=\"code even\" style=\"--layer: 1\" title=\"bb2: $DIR/spanview-block.rs:5:13: 5:13:\n+    5:13-5:13: Return: return\"><span class=\"annotation\">@bb2</span></span></span></span></div>\n+</body>\n+</html>"}, {"sha": "f8662a3277a05e472513a6f95bb19df6f584b314", "filename": "src/test/mir-opt/spanview_statement.main.mir_map.0.html", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fmir-opt%2Fspanview_statement.main.mir_map.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fmir-opt%2Fspanview_statement.main.mir_map.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fspanview_statement.main.mir_map.0.html?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -0,0 +1,67 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+    <title>coverage_of_if_else - Code Regions</title>\n+    <style>\n+    .line {\n+        counter-increment: line;\n+    }\n+    .line:before {\n+        content: counter(line) \": \";\n+        font-family: Menlo, Monaco, monospace;\n+        font-style: italic;\n+        width: 3.8em;\n+        display: inline-block;\n+        text-align: right;\n+        filter: opacity(50%);\n+        -webkit-user-select: none;\n+    }\n+    .code {\n+        color: #dddddd;\n+        background-color: #222222;\n+        font-family: Menlo, Monaco, monospace;\n+        line-height: 1.4em;\n+        border-bottom: 2px solid #222222;\n+        white-space: pre;\n+        display: inline-block;\n+    }\n+    .odd {\n+        background-color: #55bbff;\n+        color: #223311;\n+    }\n+    .even {\n+        background-color: #ee7756;\n+        color: #551133;\n+    }\n+    .code {\n+        --index: calc(var(--layer) - 1);\n+        padding-top: calc(var(--index) * 0.15em);\n+        filter:\n+            hue-rotate(calc(var(--index) * 25deg))\n+            saturate(calc(100% - (var(--index) * 2%)))\n+            brightness(calc(100% - (var(--index) * 1.5%)));\n+    }\n+    .annotation {\n+        color: #4444ff;\n+        font-family: monospace;\n+        font-style: italic;\n+        display: none;\n+        -webkit-user-select: none;\n+    }\n+    body:active .annotation {\n+        /* requires holding mouse down anywhere on the page */\n+        display: inline-block;\n+    }\n+    span:hover .annotation {\n+        /* requires hover over a span ONLY on its first line */\n+        display: inline-block;\n+    }\n+    </style>\n+</head>\n+<body>\n+<div class=\"code\" style=\"counter-reset: line 4\"><span class=\"line\"><span class=\"code\" style=\"--layer: 0\">fn main() </span><span><span class=\"code even\" style=\"--layer: 1\" title=\"bb0[0]: $DIR/spanview-statement.rs:5:11: 5:13:\n+    5:11-5:13: Assign: _0 = const ()\"><span class=\"annotation\">@bb0[0]:</span> {}</span></span><span><span class=\"code even\" style=\"--layer: 1\" title=\"bb0`Goto`: $DIR/spanview-statement.rs:5:13: 5:13:\n+    5:13-5:13: Goto: goto -&gt; bb2\"><span class=\"annotation\">@bb0`Goto`</span></span></span><span><span class=\"code even\" style=\"--layer: 1\" title=\"bb2`Return`: $DIR/spanview-statement.rs:5:13: 5:13:\n+    5:13-5:13: Return: return\"><span class=\"annotation\">@bb2`Return`</span></span></span></span></div>\n+</body>\n+</html>"}, {"sha": "d0a11a8d2629d06f2db783eaac7b82f857853f96", "filename": "src/test/mir-opt/spanview_terminator.main.mir_map.0.html", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fmir-opt%2Fspanview_terminator.main.mir_map.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fmir-opt%2Fspanview_terminator.main.mir_map.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fspanview_terminator.main.mir_map.0.html?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -0,0 +1,66 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+    <title>coverage_of_if_else - Code Regions</title>\n+    <style>\n+    .line {\n+        counter-increment: line;\n+    }\n+    .line:before {\n+        content: counter(line) \": \";\n+        font-family: Menlo, Monaco, monospace;\n+        font-style: italic;\n+        width: 3.8em;\n+        display: inline-block;\n+        text-align: right;\n+        filter: opacity(50%);\n+        -webkit-user-select: none;\n+    }\n+    .code {\n+        color: #dddddd;\n+        background-color: #222222;\n+        font-family: Menlo, Monaco, monospace;\n+        line-height: 1.4em;\n+        border-bottom: 2px solid #222222;\n+        white-space: pre;\n+        display: inline-block;\n+    }\n+    .odd {\n+        background-color: #55bbff;\n+        color: #223311;\n+    }\n+    .even {\n+        background-color: #ee7756;\n+        color: #551133;\n+    }\n+    .code {\n+        --index: calc(var(--layer) - 1);\n+        padding-top: calc(var(--index) * 0.15em);\n+        filter:\n+            hue-rotate(calc(var(--index) * 25deg))\n+            saturate(calc(100% - (var(--index) * 2%)))\n+            brightness(calc(100% - (var(--index) * 1.5%)));\n+    }\n+    .annotation {\n+        color: #4444ff;\n+        font-family: monospace;\n+        font-style: italic;\n+        display: none;\n+        -webkit-user-select: none;\n+    }\n+    body:active .annotation {\n+        /* requires holding mouse down anywhere on the page */\n+        display: inline-block;\n+    }\n+    span:hover .annotation {\n+        /* requires hover over a span ONLY on its first line */\n+        display: inline-block;\n+    }\n+    </style>\n+</head>\n+<body>\n+<div class=\"code\" style=\"counter-reset: line 4\"><span class=\"line\"><span class=\"code\" style=\"--layer: 0\">fn main() {}</span><span><span class=\"code even\" style=\"--layer: 1\" title=\"bb0`Goto`: $DIR/spanview-terminator.rs:5:13: 5:13:\n+    5:13-5:13: Goto: goto -&gt; bb2\"><span class=\"annotation\">@bb0`Goto`</span></span></span><span><span class=\"code even\" style=\"--layer: 1\" title=\"bb2`Return`: $DIR/spanview-terminator.rs:5:13: 5:13:\n+    5:13-5:13: Return: return\"><span class=\"annotation\">@bb2`Return`</span></span></span></span></div>\n+</body>\n+</html>"}, {"sha": "be668a1276a0163cb192afba1176048fb4950e83", "filename": "src/test/rustdoc/index-page.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Frustdoc%2Findex-page.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Frustdoc%2Findex-page.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Findex-page.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -6,6 +6,6 @@\n \n // @has foo/../index.html\n // @has - '//span[@class=\"in-band\"]' 'List of all crates'\n-// @has - '//ul[@class=\"mod\"]//a[@href=\"foo/index.html\"]' 'foo'\n-// @has - '//ul[@class=\"mod\"]//a[@href=\"all_item_types/index.html\"]' 'all_item_types'\n+// @has - '//ul[@class=\"crate mod\"]//a[@href=\"foo/index.html\"]' 'foo'\n+// @has - '//ul[@class=\"crate mod\"]//a[@href=\"all_item_types/index.html\"]' 'all_item_types'\n pub struct Foo;"}, {"sha": "e3841c38c2231d5c61bf678fc31b149b59e07b17", "filename": "src/test/ui/consts/std/net/ipv6.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fnet%2Fipv6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fnet%2Fipv6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstd%2Fnet%2Fipv6.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -0,0 +1,53 @@\n+// run-pass\n+\n+#![feature(ip)]\n+#![feature(const_ipv6)]\n+\n+use std::net::{Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n+\n+fn main() {\n+    const IP_ADDRESS : Ipv6Addr = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1);\n+    assert_eq!(IP_ADDRESS, Ipv6Addr::LOCALHOST);\n+\n+    const SEGMENTS : [u16; 8] = IP_ADDRESS.segments();\n+    assert_eq!(SEGMENTS, [0 ,0 ,0 ,0 ,0 ,0 ,0, 1]);\n+\n+    const OCTETS : [u8; 16] = IP_ADDRESS.octets();\n+    assert_eq!(OCTETS, [0 ,0 ,0 ,0 ,0 ,0 ,0, 0 ,0 ,0 ,0 ,0 ,0 ,0, 0, 1]);\n+\n+    const IS_UNSPECIFIED : bool = IP_ADDRESS.is_unspecified();\n+    assert!(!IS_UNSPECIFIED);\n+\n+    const IS_LOOPBACK : bool = IP_ADDRESS.is_loopback();\n+    assert!(IS_LOOPBACK);\n+\n+    const IS_GLOBAL : bool = IP_ADDRESS.is_global();\n+    assert!(!IS_GLOBAL);\n+\n+    const IS_UNIQUE_LOCAL : bool = IP_ADDRESS.is_unique_local();\n+    assert!(!IS_UNIQUE_LOCAL);\n+\n+    const IS_UNICAST_LINK_LOCAL_STRICT : bool = IP_ADDRESS.is_unicast_link_local_strict();\n+    assert!(!IS_UNICAST_LINK_LOCAL_STRICT);\n+\n+    const IS_UNICAST_LINK_LOCAL : bool = IP_ADDRESS.is_unicast_link_local();\n+    assert!(!IS_UNICAST_LINK_LOCAL);\n+\n+    const IS_UNICAST_SITE_LOCAL : bool = IP_ADDRESS.is_unicast_site_local();\n+    assert!(!IS_UNICAST_SITE_LOCAL);\n+\n+    const IS_DOCUMENTATION : bool = IP_ADDRESS.is_documentation();\n+    assert!(!IS_DOCUMENTATION);\n+\n+    const IS_UNICAST_GLOBAL : bool = IP_ADDRESS.is_unicast_global();\n+    assert!(!IS_UNICAST_GLOBAL);\n+\n+    const MULTICAST_SCOPE : Option<Ipv6MulticastScope> = IP_ADDRESS.multicast_scope();\n+    assert_eq!(MULTICAST_SCOPE, None);\n+\n+    const IS_MULTICAST : bool = IP_ADDRESS.is_multicast();\n+    assert!(!IS_MULTICAST);\n+\n+    const IP_V4 : Option<Ipv4Addr> = IP_ADDRESS.to_ipv4();\n+    assert_eq!(IP_V4.unwrap(), Ipv4Addr::new(0, 0, 0, 1));\n+}"}, {"sha": "35f0f429059a930b6ab427f5353ed42040bd8b6e", "filename": "src/test/ui/macros/duplicate-builtin.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fui%2Fmacros%2Fduplicate-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fui%2Fmacros%2Fduplicate-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fduplicate-builtin.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags:--crate-type lib\n+#![feature(decl_macro)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_builtin_macro]\n+pub macro test($item:item) {\n+//~^ NOTE previously defined\n+    /* compiler built-in */\n+}\n+\n+mod inner {\n+    #[rustc_builtin_macro]\n+    pub macro test($item:item) {\n+    //~^ ERROR attempted to define built-in macro more than once [E0773]\n+        /* compiler built-in */\n+    }\n+}"}, {"sha": "58accea27bb960123850a2a277c3503f6501abf3", "filename": "src/test/ui/macros/duplicate-builtin.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fui%2Fmacros%2Fduplicate-builtin.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fui%2Fmacros%2Fduplicate-builtin.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fduplicate-builtin.stderr?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -0,0 +1,21 @@\n+error[E0773]: attempted to define built-in macro more than once\n+  --> $DIR/duplicate-builtin.rs:13:5\n+   |\n+LL | /     pub macro test($item:item) {\n+LL | |\n+LL | |         /* compiler built-in */\n+LL | |     }\n+   | |_____^\n+   |\n+note: previously defined here\n+  --> $DIR/duplicate-builtin.rs:6:1\n+   |\n+LL | / pub macro test($item:item) {\n+LL | |\n+LL | |     /* compiler built-in */\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0773`."}, {"sha": "16f9139e6479e2cdd87ca27e03e37aa01ff81157", "filename": "src/test/ui/macros/unknown-builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -1,12 +1,12 @@\n-// error-pattern: cannot find a built-in macro with name `line`\n+// error-pattern: attempted to define built-in macro more than once\n \n #![feature(rustc_attrs)]\n \n #[rustc_builtin_macro]\n macro_rules! unknown { () => () } //~ ERROR cannot find a built-in macro with name `unknown`\n \n #[rustc_builtin_macro]\n-macro_rules! line { () => () }\n+macro_rules! line { () => () } //~ NOTE previously defined here\n \n fn main() {\n     line!();"}, {"sha": "7b04e05293ea1f12ef8ed6c12dd06dcd4318488c", "filename": "src/test/ui/macros/unknown-builtin.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Funknown-builtin.stderr?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -4,7 +4,7 @@ error: cannot find a built-in macro with name `unknown`\n LL | macro_rules! unknown { () => () }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: cannot find a built-in macro with name `line`\n+error[E0773]: attempted to define built-in macro more than once\n   --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n    |\n LL | /     macro_rules! line {\n@@ -13,6 +13,13 @@ LL | |             /* compiler built-in */\n LL | |         };\n LL | |     }\n    | |_____^\n+   |\n+note: previously defined here\n+  --> $DIR/unknown-builtin.rs:9:1\n+   |\n+LL | macro_rules! line { () => () }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0773`."}, {"sha": "72866753e0e6e9b046a9c84613dfeee48d23d3c8", "filename": "src/test/ui/parser/shebang/shebang-doc-comment.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fui%2Fparser%2Fshebang%2Fshebang-doc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fui%2Fparser%2Fshebang%2Fshebang-doc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fshebang%2Fshebang-doc-comment.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -1,6 +1,3 @@\n #!///bin/bash\n [allow(unused_variables)]\n-//~^^ ERROR expected `[`, found doc comment\n-\n-// Doc comment is misinterpreted as a whitespace (regular comment) during shebang detection.\n-// Even if it wasn't, it would still result in an error, just a different one.\n+//~^ ERROR expected item, found `[`"}, {"sha": "2227d45ec5a3d9da98040b71b7affb191da9f33d", "filename": "src/test/ui/parser/shebang/shebang-doc-comment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fui%2Fparser%2Fshebang%2Fshebang-doc-comment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftest%2Fui%2Fparser%2Fshebang%2Fshebang-doc-comment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fshebang%2Fshebang-doc-comment.stderr?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -1,8 +1,8 @@\n-error: expected `[`, found doc comment `///bin/bash`\n-  --> $DIR/shebang-doc-comment.rs:1:3\n+error: expected item, found `[`\n+  --> $DIR/shebang-doc-comment.rs:2:1\n    |\n-LL | #!///bin/bash\n-   |   ^^^^^^^^^^^ expected `[`\n+LL | [allow(unused_variables)]\n+   | ^ expected item\n \n error: aborting due to previous error\n "}, {"sha": "3c3f8b26e3ac1a4a4b83974e7d9b7d20fabce2c9", "filename": "src/tools/clippy/clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=e36e4bd0f7e722d3c97d1ca45387e58f81e4e8ea", "patch": "@@ -191,7 +191,7 @@ pub fn eq_stmt(l: &Stmt, r: &Stmt) -> bool {\n         (Item(l), Item(r)) => eq_item(l, r, eq_item_kind),\n         (Expr(l), Expr(r)) | (Semi(l), Semi(r)) => eq_expr(l, r),\n         (Empty, Empty) => true,\n-        (MacCall(l), MacCall(r)) => l.1 == r.1 && eq_mac_call(&l.0, &r.0) && over(&l.2, &r.2, |l, r| eq_attr(l, r)),\n+        (MacCall(l), MacCall(r)) => l.style == r.style && eq_mac_call(&l.mac, &r.mac) && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r)),\n         _ => false,\n     }\n }"}]}