{"sha": "346065f621c861179a4f51d701c9c7c7a907346b", "node_id": "C_kwDOAAsO6NoAKDM0NjA2NWY2MjFjODYxMTc5YTRmNTFkNzAxYzljN2M3YTkwNzM0NmI", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-04-28T23:45:05Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-04-28T23:45:05Z"}, "message": "rustdoc: fix missing method list for primitive deref target\n\nThis change makes it so that local impls count when listing primitives that\nneed retained.", "tree": {"sha": "890b3efbe5d6422d6bc0dd3777968a475c66abf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/890b3efbe5d6422d6bc0dd3777968a475c66abf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/346065f621c861179a4f51d701c9c7c7a907346b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/346065f621c861179a4f51d701c9c7c7a907346b", "html_url": "https://github.com/rust-lang/rust/commit/346065f621c861179a4f51d701c9c7c7a907346b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/346065f621c861179a4f51d701c9c7c7a907346b/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "082e4ca49770ebc9cb0ee616f3726a67471be8cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/082e4ca49770ebc9cb0ee616f3726a67471be8cb", "html_url": "https://github.com/rust-lang/rust/commit/082e4ca49770ebc9cb0ee616f3726a67471be8cb"}], "stats": {"total": 95, "additions": 60, "deletions": 35}, "files": [{"sha": "7b6b1ba0d96413394b840c7e8452b34d898902e4", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/346065f621c861179a4f51d701c9c7c7a907346b/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/346065f621c861179a4f51d701c9c7c7a907346b/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=346065f621c861179a4f51d701c9c7c7a907346b", "patch": "@@ -33,21 +33,50 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n         coll.items\n     };\n \n-    let mut new_items = Vec::new();\n+    let mut new_items_external = Vec::new();\n+    let mut new_items_local = Vec::new();\n \n     // External trait impls.\n     cx.with_all_trait_impls(|cx, all_trait_impls| {\n         let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_extern_trait_impls\");\n         for &impl_def_id in all_trait_impls.iter().skip_while(|def_id| def_id.is_local()) {\n-            inline::build_impl(cx, None, impl_def_id, None, &mut new_items);\n+            inline::build_impl(cx, None, impl_def_id, None, &mut new_items_external);\n+        }\n+    });\n+\n+    // Local trait impls.\n+    cx.with_all_trait_impls(|cx, all_trait_impls| {\n+        let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_local_trait_impls\");\n+        let mut attr_buf = Vec::new();\n+        for &impl_def_id in all_trait_impls.iter().take_while(|def_id| def_id.is_local()) {\n+            let mut parent = cx.tcx.parent(impl_def_id);\n+            while let Some(did) = parent {\n+                attr_buf.extend(\n+                    cx.tcx\n+                        .get_attrs(did)\n+                        .iter()\n+                        .filter(|attr| attr.has_name(sym::doc))\n+                        .filter(|attr| {\n+                            if let Some([attr]) = attr.meta_item_list().as_deref() {\n+                                attr.has_name(sym::cfg)\n+                            } else {\n+                                false\n+                            }\n+                        })\n+                        .cloned(),\n+                );\n+                parent = cx.tcx.parent(did);\n+            }\n+            inline::build_impl(cx, None, impl_def_id, Some(&attr_buf), &mut new_items_local);\n+            attr_buf.clear();\n         }\n     });\n \n     cx.tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n         for def_id in PrimitiveType::all_impls(cx.tcx) {\n             // Try to inline primitive impls from other crates.\n             if !def_id.is_local() {\n-                inline::build_impl(cx, None, def_id, None, &mut new_items);\n+                inline::build_impl(cx, None, def_id, None, &mut new_items_external);\n             }\n         }\n         for (prim, did) in PrimitiveType::primitive_locations(cx.tcx) {\n@@ -57,7 +86,7 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n             if did.is_local() {\n                 for def_id in prim.impls(cx.tcx) {\n                     let impls = get_auto_trait_and_blanket_impls(cx, def_id);\n-                    new_items.extend(impls.filter(|i| cx.inlined.insert(i.item_id)));\n+                    new_items_external.extend(impls.filter(|i| cx.inlined.insert(i.item_id)));\n                 }\n             }\n         }\n@@ -90,7 +119,7 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n     }\n \n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n-    for it in &new_items {\n+    for it in new_items_external.iter().chain(new_items_local.iter()) {\n         if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n             if trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait()\n                 && cleaner.keep_impl(for_, true)\n@@ -122,7 +151,8 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n         }\n     }\n \n-    new_items.retain(|it| {\n+    // Filter out external items that are not needed\n+    new_items_external.retain(|it| {\n         if let ImplItem(Impl { ref for_, ref trait_, ref kind, .. }) = *it.kind {\n             cleaner.keep_impl(\n                 for_,\n@@ -134,37 +164,10 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n         }\n     });\n \n-    // Local trait impls.\n-    cx.with_all_trait_impls(|cx, all_trait_impls| {\n-        let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_local_trait_impls\");\n-        let mut attr_buf = Vec::new();\n-        for &impl_def_id in all_trait_impls.iter().take_while(|def_id| def_id.is_local()) {\n-            let mut parent = cx.tcx.parent(impl_def_id);\n-            while let Some(did) = parent {\n-                attr_buf.extend(\n-                    cx.tcx\n-                        .get_attrs(did)\n-                        .iter()\n-                        .filter(|attr| attr.has_name(sym::doc))\n-                        .filter(|attr| {\n-                            if let Some([attr]) = attr.meta_item_list().as_deref() {\n-                                attr.has_name(sym::cfg)\n-                            } else {\n-                                false\n-                            }\n-                        })\n-                        .cloned(),\n-                );\n-                parent = cx.tcx.parent(did);\n-            }\n-            inline::build_impl(cx, None, impl_def_id, Some(&attr_buf), &mut new_items);\n-            attr_buf.clear();\n-        }\n-    });\n-\n     if let ModuleItem(Module { items, .. }) = &mut *krate.module.kind {\n         items.extend(synth_impls);\n-        items.extend(new_items);\n+        items.extend(new_items_external);\n+        items.extend(new_items_local);\n     } else {\n         panic!(\"collect-trait-impls can't run\");\n     };"}, {"sha": "cccf273a820283afbcd848eb50b8bc7192bc8556", "filename": "src/test/rustdoc/deref-slice-core.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/346065f621c861179a4f51d701c9c7c7a907346b/src%2Ftest%2Frustdoc%2Fderef-slice-core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/346065f621c861179a4f51d701c9c7c7a907346b/src%2Ftest%2Frustdoc%2Fderef-slice-core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-slice-core.rs?ref=346065f621c861179a4f51d701c9c7c7a907346b", "patch": "@@ -0,0 +1,22 @@\n+// https://github.com/rust-lang/rust/issues/95325\n+//\n+// Show methods reachable from Deref of primitive.\n+#![no_std]\n+\n+use core::ops::Deref;\n+\n+// @has 'deref_slice_core/struct.MyArray.html'\n+// @has '-' '//*[@id=\"deref-methods-%5BT%5D\"]' 'Methods from Deref<Target = [T]>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.len\"]' 'pub fn len(&self)'\n+\n+pub struct MyArray<T> {\n+    array: [T; 10],\n+}\n+\n+impl<T> Deref for MyArray<T> {\n+    type Target = [T];\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.array\n+    }\n+}"}]}