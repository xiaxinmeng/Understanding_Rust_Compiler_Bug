{"sha": "7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNzNlNGNjNDdmMjk1ZTViNjhmYTdhYTg2Njg4Y2FiZmQzYzdlZWE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-05-19T19:26:24Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-05-22T17:03:08Z"}, "message": "Remove ReScope", "tree": {"sha": "c5f538c0fb540da5f0e3f0def9e68b685e1a2dbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5f538c0fb540da5f0e3f0def9e68b685e1a2dbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "html_url": "https://github.com/rust-lang/rust/commit/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c102312c2ba5f3f679a606ed8cfafd3aa811bd29", "url": "https://api.github.com/repos/rust-lang/rust/commits/c102312c2ba5f3f679a606ed8cfafd3aa811bd29", "html_url": "https://github.com/rust-lang/rust/commit/c102312c2ba5f3f679a606ed8cfafd3aa811bd29"}], "stats": {"total": 482, "additions": 27, "deletions": 455}, "files": [{"sha": "c2dae6ba4f83db32e9e5dfe0120e35f21d092950", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -332,7 +332,6 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n-            | ty::ReScope(_)\n             | ty::ReEmpty(_)\n             | ty::RePlaceholder(..)\n             | ty::ReErased => self.canonicalize_region_mode.canonicalize_free_region(self, r),"}, {"sha": "70a2122a9ea5d26c611b07269f9de70c5522d53f", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -619,7 +619,6 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n             | ty::ReVar(..)\n             | ty::ReEmpty(_)\n             | ty::ReStatic\n-            | ty::ReScope(..)\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(..) => {\n                 // see common code below"}, {"sha": "66781e88c118af694533874987ee9337bb53ee04", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -88,51 +88,6 @@ pub(super) fn note_and_explain_region(\n     suffix: &str,\n ) {\n     let (description, span) = match *region {\n-        ty::ReScope(scope) => {\n-            let new_string;\n-            let unknown_scope =\n-                || format!(\"{}unknown scope: {:?}{}.  Please report a bug.\", prefix, scope, suffix);\n-            let span = scope.span(tcx, region_scope_tree);\n-            let hir_id = scope.hir_id(region_scope_tree);\n-            let tag = match hir_id.and_then(|hir_id| tcx.hir().find(hir_id)) {\n-                Some(Node::Block(_)) => \"block\",\n-                Some(Node::Expr(expr)) => match expr.kind {\n-                    hir::ExprKind::Call(..) => \"call\",\n-                    hir::ExprKind::MethodCall(..) => \"method call\",\n-                    hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n-                    hir::ExprKind::Match(.., hir::MatchSource::WhileLetDesugar) => \"while let\",\n-                    hir::ExprKind::Match(.., hir::MatchSource::ForLoopDesugar) => \"for\",\n-                    hir::ExprKind::Match(..) => \"match\",\n-                    _ => \"expression\",\n-                },\n-                Some(Node::Stmt(_)) => \"statement\",\n-                Some(Node::Item(it)) => item_scope_tag(&it),\n-                Some(Node::TraitItem(it)) => trait_item_scope_tag(&it),\n-                Some(Node::ImplItem(it)) => impl_item_scope_tag(&it),\n-                Some(_) | None => {\n-                    err.span_note(span, &unknown_scope());\n-                    return;\n-                }\n-            };\n-            let scope_decorated_tag = match scope.data {\n-                region::ScopeData::Node => tag,\n-                region::ScopeData::CallSite => \"scope of call-site for function\",\n-                region::ScopeData::Arguments => \"scope of function body\",\n-                region::ScopeData::Destruction => {\n-                    new_string = format!(\"destruction scope surrounding {}\", tag);\n-                    &new_string[..]\n-                }\n-                region::ScopeData::Remainder(first_statement_index) => {\n-                    new_string = format!(\n-                        \"block suffix following statement {}\",\n-                        first_statement_index.index()\n-                    );\n-                    &new_string[..]\n-                }\n-            };\n-            explain_span(tcx, scope_decorated_tag, span)\n-        }\n-\n         ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic => {\n             msg_span_from_free_region(tcx, region)\n         }"}, {"sha": "b4cfcb3a1c3256c708450472cad47b7cf2c9d33e", "filename": "src/librustc_infer/infer/freshen.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -127,7 +127,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n-            | ty::ReScope(_)\n             | ty::ReVar(_)\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty(_)"}, {"sha": "5d3e8f440d6fd6fd44785b99c6907f6a20f45fd4", "filename": "src/librustc_infer/infer/lexical_region_resolve/graphviz.rs", "status": "removed", "additions": 0, "deletions": 253, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/c102312c2ba5f3f679a606ed8cfafd3aa811bd29/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c102312c2ba5f3f679a606ed8cfafd3aa811bd29/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=c102312c2ba5f3f679a606ed8cfafd3aa811bd29", "patch": "@@ -1,253 +0,0 @@\n-//! This module provides linkage between libgraphviz traits and\n-//! `rustc_trait_selection::infer::region_constraints`, generating a\n-//! rendering of the graph represented by the list of `Constraint`\n-//! instances (which make up the edges of the graph), as well as the\n-//! origin for each constraint (which are attached to the labels on\n-//! each edge).\n-\n-/// For clarity, rename the graphviz crate locally to dot.\n-use graphviz as dot;\n-\n-use super::Constraint;\n-use crate::infer::region_constraints::RegionConstraintData;\n-use crate::infer::RegionRelations;\n-use crate::infer::SubregionOrigin;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def_id::DefIndex;\n-use rustc_middle::middle::region;\n-use rustc_middle::ty;\n-\n-use std::borrow::Cow;\n-use std::collections::btree_map::BTreeMap;\n-use std::collections::hash_map::Entry::Vacant;\n-use std::env;\n-use std::fs;\n-use std::io;\n-use std::sync::atomic::{AtomicBool, Ordering};\n-\n-fn print_help_message() {\n-    println!(\n-        \"\\\n--Z print-region-graph by default prints a region constraint graph for every \\n\\\n-function body, to the path `constraints.nodeXXX.dot`, where the XXX is \\n\\\n-replaced with the node id of the function under analysis.                   \\n\\\n-                                                                            \\n\\\n-To select one particular function body, set `RUST_REGION_GRAPH_NODE=XXX`,   \\n\\\n-where XXX is the node id desired.                                           \\n\\\n-                                                                            \\n\\\n-To generate output to some path other than the default                      \\n\\\n-`constraints.nodeXXX.dot`, set `RUST_REGION_GRAPH=/path/desired.dot`;  \\n\\\n-occurrences of the character `%` in the requested path will be replaced with\\n\\\n-the node id of the function under analysis.                                 \\n\\\n-                                                                            \\n\\\n-(Since you requested help via RUST_REGION_GRAPH=help, no region constraint  \\n\\\n-graphs will be printed.                                                     \\n\\\n-\"\n-    );\n-}\n-\n-pub fn maybe_print_constraints_for<'a, 'tcx>(\n-    region_data: &RegionConstraintData<'tcx>,\n-    region_rels: &RegionRelations<'a, 'tcx>,\n-) {\n-    let tcx = region_rels.tcx;\n-    let context = region_rels.context;\n-\n-    if !tcx.sess.opts.debugging_opts.print_region_graph {\n-        return;\n-    }\n-\n-    let requested_node = env::var(\"RUST_REGION_GRAPH_NODE\")\n-        .ok()\n-        .and_then(|s| s.parse().map(DefIndex::from_u32).ok());\n-\n-    if requested_node.is_some() && requested_node != Some(context.index) {\n-        return;\n-    }\n-\n-    let requested_output = env::var(\"RUST_REGION_GRAPH\");\n-    debug!(\"requested_output: {:?} requested_node: {:?}\", requested_output, requested_node);\n-\n-    let output_path = {\n-        let output_template = match requested_output {\n-            Ok(ref s) if s == \"help\" => {\n-                static PRINTED_YET: AtomicBool = AtomicBool::new(false);\n-                if !PRINTED_YET.load(Ordering::SeqCst) {\n-                    print_help_message();\n-                    PRINTED_YET.store(true, Ordering::SeqCst);\n-                }\n-                return;\n-            }\n-\n-            Ok(other_path) => other_path,\n-            Err(_) => \"constraints.node%.dot\".to_string(),\n-        };\n-\n-        if output_template.is_empty() {\n-            panic!(\"empty string provided as RUST_REGION_GRAPH\");\n-        }\n-\n-        if output_template.contains('%') {\n-            let mut new_str = String::new();\n-            for c in output_template.chars() {\n-                if c == '%' {\n-                    new_str.push_str(&context.index.as_u32().to_string());\n-                } else {\n-                    new_str.push(c);\n-                }\n-            }\n-            new_str\n-        } else {\n-            output_template\n-        }\n-    };\n-\n-    if let Err(e) = dump_region_data_to(region_rels, &region_data.constraints, &output_path) {\n-        let msg = format!(\"io error dumping region constraints: {}\", e);\n-        tcx.sess.err(&msg)\n-    }\n-}\n-\n-struct ConstraintGraph<'a, 'tcx> {\n-    graph_name: String,\n-    region_rels: &'a RegionRelations<'a, 'tcx>,\n-    map: &'a BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n-    node_ids: FxHashMap<Node, usize>,\n-}\n-\n-#[derive(Clone, Hash, PartialEq, Eq, Debug, Copy)]\n-enum Node {\n-    RegionVid(ty::RegionVid),\n-    Region(ty::RegionKind),\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug, Copy)]\n-enum Edge<'tcx> {\n-    Constraint(Constraint<'tcx>),\n-    EnclScope(region::Scope, region::Scope),\n-}\n-\n-impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n-    fn new(\n-        name: String,\n-        region_rels: &'a RegionRelations<'a, 'tcx>,\n-        map: &'a ConstraintMap<'tcx>,\n-    ) -> ConstraintGraph<'a, 'tcx> {\n-        let mut i = 0;\n-        let mut node_ids = FxHashMap::default();\n-        {\n-            let mut add_node = |node| {\n-                if let Vacant(e) = node_ids.entry(node) {\n-                    e.insert(i);\n-                    i += 1;\n-                }\n-            };\n-\n-            for (n1, n2) in map.keys().map(|c| constraint_to_nodes(c)) {\n-                add_node(n1);\n-                add_node(n2);\n-            }\n-\n-            region_rels.region_scope_tree.each_encl_scope(|sub, sup| {\n-                add_node(Node::Region(ty::ReScope(sub)));\n-                add_node(Node::Region(ty::ReScope(sup)));\n-            });\n-        }\n-\n-        ConstraintGraph { map, node_ids, region_rels, graph_name: name }\n-    }\n-}\n-\n-impl<'a, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'tcx> {\n-    type Node = Node;\n-    type Edge = Edge<'tcx>;\n-    fn graph_id(&self) -> dot::Id<'_> {\n-        dot::Id::new(&*self.graph_name).unwrap()\n-    }\n-    fn node_id(&self, n: &Node) -> dot::Id<'_> {\n-        let node_id = match self.node_ids.get(n) {\n-            Some(node_id) => node_id,\n-            None => bug!(\"no node_id found for node: {:?}\", n),\n-        };\n-        let name = || format!(\"node_{}\", node_id);\n-\n-        dot::Id::new(name())\n-            .unwrap_or_else(|_| bug!(\"failed to create graphviz node identified by {}\", name()))\n-    }\n-    fn node_label(&self, n: &Node) -> dot::LabelText<'_> {\n-        match *n {\n-            Node::RegionVid(n_vid) => dot::LabelText::label(format!(\"{:?}\", n_vid)),\n-            Node::Region(n_rgn) => dot::LabelText::label(format!(\"{:?}\", n_rgn)),\n-        }\n-    }\n-    fn edge_label(&self, e: &Edge<'_>) -> dot::LabelText<'_> {\n-        match *e {\n-            Edge::Constraint(ref c) => {\n-                dot::LabelText::label(format!(\"{:?}\", self.map.get(c).unwrap()))\n-            }\n-            Edge::EnclScope(..) => dot::LabelText::label(\"(enclosed)\".to_owned()),\n-        }\n-    }\n-}\n-\n-fn constraint_to_nodes(c: &Constraint<'_>) -> (Node, Node) {\n-    match *c {\n-        Constraint::VarSubVar(rv_1, rv_2) => (Node::RegionVid(rv_1), Node::RegionVid(rv_2)),\n-        Constraint::RegSubVar(r_1, rv_2) => (Node::Region(*r_1), Node::RegionVid(rv_2)),\n-        Constraint::VarSubReg(rv_1, r_2) => (Node::RegionVid(rv_1), Node::Region(*r_2)),\n-        Constraint::RegSubReg(r_1, r_2) => (Node::Region(*r_1), Node::Region(*r_2)),\n-    }\n-}\n-\n-fn edge_to_nodes(e: &Edge<'_>) -> (Node, Node) {\n-    match *e {\n-        Edge::Constraint(ref c) => constraint_to_nodes(c),\n-        Edge::EnclScope(sub, sup) => {\n-            (Node::Region(ty::ReScope(sub)), Node::Region(ty::ReScope(sup)))\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'tcx> {\n-    type Node = Node;\n-    type Edge = Edge<'tcx>;\n-    fn nodes(&self) -> dot::Nodes<'_, Node> {\n-        let set = self.node_ids.keys().cloned().collect::<FxHashSet<_>>();\n-        debug!(\"constraint graph has {} nodes\", set.len());\n-        set.into_iter().collect()\n-    }\n-    fn edges(&self) -> dot::Edges<'_, Edge<'tcx>> {\n-        debug!(\"constraint graph has {} edges\", self.map.len());\n-        let mut v: Vec<_> = self.map.keys().map(|e| Edge::Constraint(*e)).collect();\n-        self.region_rels\n-            .region_scope_tree\n-            .each_encl_scope(|sub, sup| v.push(Edge::EnclScope(sub, sup)));\n-        debug!(\"region graph has {} edges\", v.len());\n-        Cow::Owned(v)\n-    }\n-    fn source(&self, edge: &Edge<'tcx>) -> Node {\n-        let (n1, _) = edge_to_nodes(edge);\n-        debug!(\"edge {:?} has source {:?}\", edge, n1);\n-        n1\n-    }\n-    fn target(&self, edge: &Edge<'tcx>) -> Node {\n-        let (_, n2) = edge_to_nodes(edge);\n-        debug!(\"edge {:?} has target {:?}\", edge, n2);\n-        n2\n-    }\n-}\n-\n-pub type ConstraintMap<'tcx> = BTreeMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n-\n-fn dump_region_data_to<'a, 'tcx>(\n-    region_rels: &RegionRelations<'a, 'tcx>,\n-    map: &ConstraintMap<'tcx>,\n-    path: &str,\n-) -> io::Result<()> {\n-    debug!(\"dump_region_data map (len: {}) path: {}\", map.len(), path);\n-    let g = ConstraintGraph::new(\"region_data\".to_string(), region_rels, map);\n-    debug!(\"dump_region_data calling render\");\n-    let mut v = Vec::new();\n-    dot::render(&g, &mut v).unwrap();\n-    fs::write(path, &v)\n-}"}, {"sha": "ef3eb24f2885292ee27eddf7f6d7709f16fd6536", "filename": "src/librustc_infer/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 4, "deletions": 56, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -18,13 +18,11 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n-use rustc_middle::ty::{ReLateBound, RePlaceholder, ReScope, ReVar};\n+use rustc_middle::ty::{ReLateBound, RePlaceholder, ReVar};\n use rustc_middle::ty::{Region, RegionVid};\n use rustc_span::Span;\n use std::fmt;\n \n-mod graphviz;\n-\n /// This function performs lexical region resolution given a complete\n /// set of constraints and variable origins. It performs a fixed-point\n /// iteration to find region values which satisfy all constraints,\n@@ -149,7 +147,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             self.region_rels.context,\n             self.dump_constraints(self.region_rels)\n         );\n-        graphviz::maybe_print_constraints_for(&self.data, self.region_rels);\n \n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n@@ -426,15 +423,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         match *b_data {\n             VarValue::Value(cur_region) => {\n-                // Identical scopes can show up quite often, if the fixed point\n-                // iteration converges slowly. Skip them. This is purely an\n-                // optimization.\n-                if let (ReScope(a_scope), ReScope(cur_scope)) = (a_region, cur_region) {\n-                    if a_scope == cur_scope {\n-                        return false;\n-                    }\n-                }\n-\n                 // This is a specialized version of the `lub_concrete_regions`\n                 // check below for a common case, here purely as an\n                 // optimization.\n@@ -528,8 +516,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 self.tcx().lifetimes.re_static\n             }\n \n-            (&ReEmpty(_), r @ (ReEarlyBound(_) | ReFree(_) | ReScope(_)))\n-            | (r @ (ReEarlyBound(_) | ReFree(_) | ReScope(_)), &ReEmpty(_)) => {\n+            (&ReEmpty(_), r @ (ReEarlyBound(_) | ReFree(_)))\n+            | (r @ (ReEarlyBound(_) | ReFree(_)), &ReEmpty(_)) => {\n                 // All empty regions are less than early-bound, free,\n                 // and scope regions.\n                 r\n@@ -554,46 +542,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 }\n             }\n \n-            (&ReEarlyBound(_) | &ReFree(_), &ReScope(s_id))\n-            | (&ReScope(s_id), &ReEarlyBound(_) | &ReFree(_)) => {\n-                // A \"free\" region can be interpreted as \"some region\n-                // at least as big as fr.scope\".  So, we can\n-                // reasonably compare free regions and scopes:\n-                let fr_scope = match (a, b) {\n-                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n-                        self.region_rels.region_scope_tree.early_free_scope(self.tcx(), br)\n-                    }\n-                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n-                        self.region_rels.region_scope_tree.free_scope(self.tcx(), fr)\n-                    }\n-                    _ => bug!(),\n-                };\n-                let r_id =\n-                    self.region_rels.region_scope_tree.nearest_common_ancestor(fr_scope, s_id);\n-                if r_id == fr_scope {\n-                    // if the free region's scope `fr.scope` is bigger than\n-                    // the scope region `s_id`, then the LUB is the free\n-                    // region itself:\n-                    match (a, b) {\n-                        (_, &ReScope(_)) => return a,\n-                        (&ReScope(_), _) => return b,\n-                        _ => bug!(),\n-                    }\n-                }\n-\n-                // otherwise, we don't know what the free region is,\n-                // so we must conservatively say the LUB is static:\n-                self.tcx().lifetimes.re_static\n-            }\n-\n-            (&ReScope(a_id), &ReScope(b_id)) => {\n-                // The region corresponding to an outer block is a\n-                // subtype of the region corresponding to an inner\n-                // block.\n-                let lub = self.region_rels.region_scope_tree.nearest_common_ancestor(a_id, b_id);\n-                self.tcx().mk_region(ReScope(lub))\n-            }\n-\n             (&ReEarlyBound(_) | &ReFree(_), &ReEarlyBound(_) | &ReFree(_)) => {\n                 self.region_rels.lub_free_regions(a, b)\n             }\n@@ -662,7 +610,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     if !self.sub_concrete_regions(a_region, b_region) {\n                         debug!(\n                             \"collect_errors: region error at {:?}: \\\n-                             cannot verify that {:?}={:?} <= {:?}\",\n+                            cannot verify that {:?}={:?} <= {:?}\",\n                             origin, a_vid, a_region, b_region\n                         );\n                         *a_data = VarValue::ErrorValue;"}, {"sha": "f45b224275574d6f3c802e3e4d42838c5a4eda67", "filename": "src/librustc_infer/infer/region_constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -758,11 +758,9 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n \n     pub fn universe(&self, region: Region<'tcx>) -> ty::UniverseIndex {\n         match *region {\n-            ty::ReScope(..)\n-            | ty::ReStatic\n-            | ty::ReErased\n-            | ty::ReFree(..)\n-            | ty::ReEarlyBound(..) => ty::UniverseIndex::ROOT,\n+            ty::ReStatic | ty::ReErased | ty::ReFree(..) | ty::ReEarlyBound(..) => {\n+                ty::UniverseIndex::ROOT\n+            }\n             ty::ReEmpty(ui) => ui,\n             ty::RePlaceholder(placeholder) => placeholder.universe,\n             ty::ReVar(vid) => self.var_universe(vid),"}, {"sha": "ef6247881c0be12995dba134bf176f38d38046ff", "filename": "src/librustc_middle/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fimpls_ty.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -87,9 +87,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n                 index.hash_stable(hcx, hasher);\n                 name.hash_stable(hcx, hasher);\n             }\n-            ty::ReScope(scope) => {\n-                scope.hash_stable(hcx, hasher);\n-            }\n             ty::ReFree(ref free_region) => {\n                 free_region.hash_stable(hcx, hasher);\n             }"}, {"sha": "f03d91aa64b781c07a75a5cf40027cad0641118a", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -1,5 +1,4 @@\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n-use crate::middle::region;\n use crate::mir::interpret::{sign_extend, truncate, AllocId, ConstValue, Pointer, Scalar};\n use crate::ty::layout::IntegerExt;\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n@@ -1588,9 +1587,9 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n                 false\n             }\n \n-            ty::ReScope(_) | ty::ReVar(_) if identify_regions => true,\n+            ty::ReVar(_) if identify_regions => true,\n \n-            ty::ReVar(_) | ty::ReScope(_) | ty::ReErased => false,\n+            ty::ReVar(_) | ty::ReErased => false,\n \n             ty::ReStatic | ty::ReEmpty(_) => true,\n         }\n@@ -1666,32 +1665,12 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n                     }\n                 }\n             }\n-            ty::ReScope(scope) if identify_regions => {\n-                match scope.data {\n-                    region::ScopeData::Node => p!(write(\"'{}s\", scope.item_local_id().as_usize())),\n-                    region::ScopeData::CallSite => {\n-                        p!(write(\"'{}cs\", scope.item_local_id().as_usize()))\n-                    }\n-                    region::ScopeData::Arguments => {\n-                        p!(write(\"'{}as\", scope.item_local_id().as_usize()))\n-                    }\n-                    region::ScopeData::Destruction => {\n-                        p!(write(\"'{}ds\", scope.item_local_id().as_usize()))\n-                    }\n-                    region::ScopeData::Remainder(first_statement_index) => p!(write(\n-                        \"'{}_{}rs\",\n-                        scope.item_local_id().as_usize(),\n-                        first_statement_index.index()\n-                    )),\n-                }\n-                return Ok(self);\n-            }\n             ty::ReVar(region_vid) if identify_regions => {\n                 p!(write(\"{:?}\", region_vid));\n                 return Ok(self);\n             }\n             ty::ReVar(_) => {}\n-            ty::ReScope(_) | ty::ReErased => {}\n+            ty::ReErased => {}\n             ty::ReStatic => {\n                 p!(write(\"'static\"));\n                 return Ok(self);"}, {"sha": "569a8d90bfcc3cbb533f6b7c8abd1b79f2cd40eb", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -87,8 +87,6 @@ impl fmt::Debug for ty::RegionKind {\n \n             ty::ReFree(ref fr) => fr.fmt(f),\n \n-            ty::ReScope(id) => write!(f, \"ReScope({:?})\", id),\n-\n             ty::ReStatic => write!(f, \"ReStatic\"),\n \n             ty::ReVar(ref vid) => vid.fmt(f),"}, {"sha": "370702f7f221dacd723d069a31e74f5d180b1b99", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -6,7 +6,6 @@ use self::InferTy::*;\n use self::TyKind::*;\n \n use crate::infer::canonical::Canonical;\n-use crate::middle::region;\n use crate::mir::interpret::ConstValue;\n use crate::mir::interpret::{LitToConstInput, Scalar};\n use crate::mir::Promoted;\n@@ -1179,25 +1178,22 @@ rustc_index::newtype_index! {\n \n pub type Region<'tcx> = &'tcx RegionKind;\n \n-/// Representation of (lexical) regions. Note that the NLL checker\n-/// uses a distinct representation of regions. For this reason, it\n-/// internally replaces all the regions with inference variables --\n-/// the index of the variable is then used to index into internal NLL\n-/// data structures. See `rustc_mir::borrow_check` module for more\n-/// information.\n+/// Representation of regions. Note that the NLL checker uses a distinct\n+/// representation of regions. For this reason, it internally replaces all the\n+/// regions with inference variables -- the index of the variable is then used\n+/// to index into internal NLL data structures. See `rustc_mir::borrow_check`\n+/// module for more information.\n ///\n /// ## The Region lattice within a given function\n ///\n-/// In general, the (lexical, and hence deprecated) region lattice\n-/// looks like\n+/// In general, the region lattice looks like\n ///\n /// ```\n /// static ----------+-----...------+       (greatest)\n /// |                |              |\n /// early-bound and  |              |\n /// free regions     |              |\n /// |                |              |\n-/// scope regions    |              |\n /// |                |              |\n /// empty(root)   placeholder(U1)   |\n /// |            /                  |\n@@ -1212,13 +1208,7 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// Early-bound/free regions are the named lifetimes in scope from the\n /// function declaration. They have relationships to one another\n /// determined based on the declared relationships from the\n-/// function. They all collectively outlive the scope regions. (See\n-/// `RegionRelations` type, and particularly\n-/// `crate::infer::outlives::free_region_map::FreeRegionMap`.)\n-///\n-/// The scope regions are related to one another based on the AST\n-/// structure. (See `RegionRelations` type, and particularly the\n-/// `rustc_middle::middle::region::ScopeTree`.)\n+/// function.\n ///\n /// Note that inference variables and bound regions are not included\n /// in this diagram. In the case of inference variables, they should\n@@ -1307,11 +1297,6 @@ pub enum RegionKind {\n     /// region parameters.\n     ReFree(FreeRegion),\n \n-    /// A concrete region naming some statically determined scope\n-    /// (e.g., an expression or sequence of statements) within the\n-    /// current function.\n-    ReScope(region::Scope),\n-\n     /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n     ReStatic,\n \n@@ -1535,7 +1520,6 @@ impl RegionKind {\n             RegionKind::ReEarlyBound(ebr) => ebr.has_name(),\n             RegionKind::ReLateBound(_, br) => br.is_named(),\n             RegionKind::ReFree(fr) => fr.bound_region.is_named(),\n-            RegionKind::ReScope(..) => false,\n             RegionKind::ReStatic => true,\n             RegionKind::ReVar(..) => false,\n             RegionKind::RePlaceholder(placeholder) => placeholder.name.is_named(),\n@@ -1616,7 +1600,7 @@ impl RegionKind {\n                 flags = flags | TypeFlags::HAS_RE_PARAM;\n                 flags = flags | TypeFlags::STILL_FURTHER_SPECIALIZABLE;\n             }\n-            ty::ReFree { .. } | ty::ReScope { .. } => {\n+            ty::ReFree { .. } => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n             }"}, {"sha": "e912ef7b20202f6595d993709757eeed01987a3e", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -284,7 +284,6 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             },\n \n             ty::ReLateBound(..)\n-            | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty(_)"}, {"sha": "d14ae40b45a0b22aaa6f4e82998861a3d23a831d", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -670,7 +670,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n // `least_region`. We cannot use `push_outlives_components` because regions in\n // closure signatures are not included in their outlives components. We need to\n // ensure all regions outlive the given bound so that we don't end up with,\n-// say, `ReScope` appearing in a return type and causing ICEs when other\n+// say, `ReVar` appearing in a return type and causing ICEs when other\n // functions end up with region constraints involving regions from other\n // functions.\n //\n@@ -816,7 +816,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             // The regions that we expect from borrow checking.\n             ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n \n-            ty::ReEmpty(_) | ty::RePlaceholder(_) | ty::ReVar(_) | ty::ReScope(_) => {\n+            ty::ReEmpty(_) | ty::RePlaceholder(_) | ty::ReVar(_) => {\n                 // All of the regions in the type should either have been\n                 // erased by writeback, or mapped back to named regions by\n                 // borrow checking."}, {"sha": "a33ada2fb6ef193cb96759f6fb4d84ef0e9bff7d", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -394,7 +394,6 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'t\n                 ty::BrEnv => unimplemented!(),\n             },\n             ReFree(_) => unimplemented!(),\n-            ReScope(_) => unimplemented!(),\n             ReStatic => unimplemented!(),\n             ReVar(_) => unimplemented!(),\n             RePlaceholder(placeholder_region) => {"}, {"sha": "1b7fde69830f04efedf9be6a9ff91c446dae1eac", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -12,7 +12,7 @@ use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::{self, GenericParamDefKind, ToPredicate, Ty};\n+use rustc_middle::ty::{self, GenericParamDefKind, Ty};\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n@@ -518,22 +518,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let InferOk { value: (), obligations } =\n                     self.at(&cause, self.param_env).eq(*expected_ty, supplied_ty)?;\n                 all_obligations.extend(obligations);\n-\n-                // Also, require that the supplied type must outlive\n-                // the closure body.\n-                let closure_body_region = self.tcx.mk_region(ty::ReScope(region::Scope {\n-                    id: body.value.hir_id.local_id,\n-                    data: region::ScopeData::Node,\n-                }));\n-                all_obligations.push(Obligation::new(\n-                    cause,\n-                    self.param_env,\n-                    ty::PredicateKind::TypeOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n-                        supplied_ty,\n-                        closure_body_region,\n-                    )))\n-                    .to_predicate(self.tcx),\n-                ));\n             }\n \n             let (supplied_output_ty, _) = self.infcx.replace_bound_vars_with_fresh_vars("}, {"sha": "6b7adb728e7e6ae06c3067f995c9976a4445c9b9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -106,13 +106,13 @@ use rustc_hir::lang_items::{\n use rustc_hir::{ExprKind, GenericArg, HirIdMap, Item, ItemKind, Node, PatKind, QPath};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n+use rustc_infer::infer;\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_infer::infer::{self, InferCtxt, InferOk, InferResult, TyCtxtInferExt};\n+use rustc_infer::infer::{InferCtxt, InferOk, InferResult, RegionVariableOrigin, TyCtxtInferExt};\n use rustc_middle::hir::map::blocks::FnLikeNode;\n-use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -667,13 +667,6 @@ impl Inherited<'a, 'tcx> {\n         let tcx = infcx.tcx;\n         let item_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let body_id = tcx.hir().maybe_body_owned_by(item_id);\n-        let implicit_region_bound = body_id.map(|body_id| {\n-            let body = tcx.hir().body(body_id);\n-            tcx.mk_region(ty::ReScope(region::Scope {\n-                id: body.value.hir_id.local_id,\n-                data: region::ScopeData::CallSite,\n-            }))\n-        });\n \n         Inherited {\n             tables: MaybeInProgressTables { maybe_tables: infcx.in_progress_tables },\n@@ -686,7 +679,7 @@ impl Inherited<'a, 'tcx> {\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n             opaque_types: RefCell::new(Default::default()),\n             opaque_types_vars: RefCell::new(Default::default()),\n-            implicit_region_bound,\n+            implicit_region_bound: None,\n             body_id,\n         }\n     }\n@@ -1337,12 +1330,9 @@ fn check_fn<'a, 'tcx>(\n     // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n     // (as it's created inside the body itself, not passed in from outside).\n     let maybe_va_list = if fn_sig.c_variadic {\n-        let va_list_did =\n-            tcx.require_lang_item(VaListTypeLangItem, Some(body.params.last().unwrap().span));\n-        let region = tcx.mk_region(ty::ReScope(region::Scope {\n-            id: body.value.hir_id.local_id,\n-            data: region::ScopeData::CallSite,\n-        }));\n+        let span = body.params.last().unwrap().span;\n+        let va_list_did = tcx.require_lang_item(VaListTypeLangItem, Some(span));\n+        let region = fcx.next_region_var(RegionVariableOrigin::MiscVariable(span));\n \n         Some(tcx.type_of(va_list_did).subst(tcx, &[region.into()]))\n     } else {"}, {"sha": "8b06967879638aa3c1e06b6bc2fedefac2bb4ace", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -170,7 +170,6 @@ fn is_free_region(tcx: TyCtxt<'_>, region: Region<'_>) -> bool {\n \n         // These regions don't appear in types from type declarations:\n         RegionKind::ReErased\n-        | RegionKind::ReScope(..)\n         | RegionKind::ReVar(..)\n         | RegionKind::RePlaceholder(..)\n         | RegionKind::ReFree(..) => {"}, {"sha": "e04af6850dea198fc437466249b1fabda0123c81", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -444,7 +444,6 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::ReFree(..)\n-            | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty(_)"}, {"sha": "702c7d1e0f1203568e73a7af01a4431694ffe648", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7d73e4cc47f295e5b68fa7aa86688cabfd3c7eea", "patch": "@@ -447,7 +447,6 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n \n             ty::ReLateBound(..)\n             | ty::ReFree(..)\n-            | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty(_)"}]}