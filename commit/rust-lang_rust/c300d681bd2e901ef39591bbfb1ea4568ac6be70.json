{"sha": "c300d681bd2e901ef39591bbfb1ea4568ac6be70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMDBkNjgxYmQyZTkwMWVmMzk1OTFiYmZiMWVhNDU2OGFjNmJlNzA=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-26T20:44:22Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-29T12:46:44Z"}, "message": "`range(a, b).foo()` -> `(a..b).foo()`\n\nsed -i 's/ range(\\([^,]*\\), *\\([^()]*\\))\\./ (\\1\\.\\.\\2)\\./g' **/*.rs", "tree": {"sha": "ee0b4b0a74846595b700d1b2375fd10309b63a22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee0b4b0a74846595b700d1b2375fd10309b63a22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c300d681bd2e901ef39591bbfb1ea4568ac6be70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c300d681bd2e901ef39591bbfb1ea4568ac6be70", "html_url": "https://github.com/rust-lang/rust/commit/c300d681bd2e901ef39591bbfb1ea4568ac6be70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c300d681bd2e901ef39591bbfb1ea4568ac6be70/comments", "author": null, "committer": null, "parents": [{"sha": "bedd8108dc9b79402d1ea5349d766275f73398ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/bedd8108dc9b79402d1ea5349d766275f73398ff", "html_url": "https://github.com/rust-lang/rust/commit/bedd8108dc9b79402d1ea5349d766275f73398ff"}], "stats": {"total": 244, "additions": 122, "deletions": 122}, "files": [{"sha": "d52e40e0a96642b557951e8211428a9c2279bcc5", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -95,7 +95,7 @@ use heap::deallocate;\n /// use std::thread::Thread;\n ///\n /// fn main() {\n-///     let numbers: Vec<_> = range(0, 100u32).map(|i| i as f32).collect();\n+///     let numbers: Vec<_> = (0..100u32).map(|i| i as f32).collect();\n ///     let shared_numbers = Arc::new(numbers);\n ///\n ///     for _ in range(0u, 10) {"}, {"sha": "0df095c48c6b13099d685a0d4f0625af96775c29", "filename": "src/libcollections/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbench.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -70,7 +70,7 @@ pub fn find_rand_n<M, T, I, F>(n: uint,\n {\n     // setup\n     let mut rng = rand::weak_rng();\n-    let mut keys = range(0, n).map(|_| rng.gen::<uint>() % n)\n+    let mut keys = (0..n).map(|_| rng.gen::<uint>() % n)\n                               .collect::<Vec<_>>();\n \n     for k in keys.iter() {"}, {"sha": "dc3fc818d5ce0f4983daebccb8bb15206bdaf2b6", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -660,7 +660,7 @@ impl Bitv {\n \n         let len = self.nbits/8 +\n                   if self.nbits % 8 == 0 { 0 } else { 1 };\n-        range(0, len).map(|i|\n+        (0..len).map(|i|\n             bit(self, i, 0) |\n             bit(self, i, 1) |\n             bit(self, i, 2) |\n@@ -2283,7 +2283,7 @@ mod tests {\n \n         assert_eq!(bitv.iter().collect::<Vec<bool>>(), bools);\n \n-        let long = range(0, 10000).map(|i| i % 2 == 0).collect::<Vec<_>>();\n+        let long = (0..10000).map(|i| i % 2 == 0).collect::<Vec<_>>();\n         let bitv: Bitv = long.iter().map(|n| *n).collect();\n         assert_eq!(bitv.iter().collect::<Vec<bool>>(), long)\n     }\n@@ -2647,7 +2647,7 @@ mod bitv_set_test {\n         let idxs: Vec<uint> = bitv.iter().collect();\n         assert_eq!(idxs, vec![0, 2, 3]);\n \n-        let long: BitvSet = range(0u, 10000).filter(|&n| n % 2 == 0).collect();\n+        let long: BitvSet = (0u..10000).filter(|&n| n % 2 == 0).collect();\n         let real = range_step(0, 10000, 2).collect::<Vec<uint>>();\n \n         let idxs: Vec<uint> = long.iter().collect();"}, {"sha": "dbc931330a19d3735b4e9ed44734ea8c559d2a73", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -1661,7 +1661,7 @@ mod test {\n         let size = 10000u;\n \n         // Forwards\n-        let mut map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+        let mut map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n \n         fn test<T>(size: uint, mut iter: T) where T: Iterator<Item=(uint, uint)> {\n             for i in range(0, size) {\n@@ -1681,7 +1681,7 @@ mod test {\n         let size = 10000u;\n \n         // Forwards\n-        let mut map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+        let mut map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n \n         fn test<T>(size: uint, mut iter: T) where T: Iterator<Item=(uint, uint)> {\n             for i in range(0, size) {\n@@ -1701,7 +1701,7 @@ mod test {\n         let size = 10000u;\n \n         // Forwards\n-        let mut map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+        let mut map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n \n         fn test<T>(size: uint, mut iter: T)\n                 where T: Iterator<Item=(uint, uint)> + DoubleEndedIterator {\n@@ -1727,7 +1727,7 @@ mod test {\n         let size = 5u;\n \n         // Forwards\n-        let map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+        let map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n \n         let mut j = 0u;\n         for ((&k, &v), i) in map.range(Included(&2), Unbounded).zip(range(2u, size)) {\n@@ -1741,11 +1741,11 @@ mod test {\n     #[test]\n     fn test_range_1000() {\n         let size = 1000u;\n-        let map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+        let map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n \n         fn test(map: &BTreeMap<uint, uint>, size: uint, min: Bound<&uint>, max: Bound<&uint>) {\n             let mut kvs = map.range(min, max).map(|(&k, &v)| (k, v));\n-            let mut pairs = range(0, size).map(|i| (i, i));\n+            let mut pairs = (0..size).map(|i| (i, i));\n \n             for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n                 assert_eq!(kv, pair);\n@@ -1764,7 +1764,7 @@ mod test {\n     #[test]\n     fn test_range() {\n         let size = 200u;\n-        let map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+        let map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n \n         for i in range(0, size) {\n             for j in range(i, size) {"}, {"sha": "4ce581b79c441033ab29e28ef34f60f08ca9ceca", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -1334,7 +1334,7 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let list: DList<int> = range(0i, 10).collect();\n+        let list: DList<int> = (0i..10).collect();\n         assert_eq!(format!(\"{:?}\", list), \"DList [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let list: DList<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()"}, {"sha": "fe839e16a1ba0fc60c48260de21c87c3ae713f8a", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -1828,7 +1828,7 @@ mod tests {\n \n     #[bench]\n     fn bench_iter_1000(b: &mut test::Bencher) {\n-        let ring: RingBuf<int> = range(0i, 1000).collect();\n+        let ring: RingBuf<int> = (0i..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -1841,7 +1841,7 @@ mod tests {\n \n     #[bench]\n     fn bench_mut_iter_1000(b: &mut test::Bencher) {\n-        let mut ring: RingBuf<int> = range(0i, 1000).collect();\n+        let mut ring: RingBuf<int> = (0i..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -1977,7 +1977,7 @@ mod tests {\n \n     #[test]\n     fn test_swap() {\n-        let mut d: RingBuf<int> = range(0i, 5).collect();\n+        let mut d: RingBuf<int> = (0i..5).collect();\n         d.pop_front();\n         d.swap(0, 3);\n         assert_eq!(d.iter().map(|&x|x).collect::<Vec<int>>(), vec!(4, 2, 3, 1));\n@@ -2309,7 +2309,7 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let ringbuf: RingBuf<int> = range(0i, 10).collect();\n+        let ringbuf: RingBuf<int> = (0i..10).collect();\n         assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let ringbuf: RingBuf<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n@@ -2494,9 +2494,9 @@ mod tests {\n \n             for len in range(0, final_len) {\n                 let expected = if back {\n-                    range(0, len).collect()\n+                    (0..len).collect()\n                 } else {\n-                    range(0, len).rev().collect()\n+                    (0..len).rev().collect()\n                 };\n                 for tail_pos in range(0, usable_cap) {\n                     tester.tail = tail_pos;\n@@ -2652,16 +2652,16 @@ mod tests {\n             ring.push_back(i);\n \n             let (left, right) = ring.as_slices();\n-            let expected: Vec<_> = range(0, i+1).collect();\n+            let expected: Vec<_> = (0..i+1).collect();\n             assert_eq!(left, expected);\n             assert_eq!(right, []);\n         }\n \n         for j in range(-last, 0) {\n             ring.push_front(j);\n             let (left, right) = ring.as_slices();\n-            let expected_left: Vec<_> = range(-last, j+1).rev().collect();\n-            let expected_right: Vec<_> = range(0, first).collect();\n+            let expected_left: Vec<_> = (-last..j+1).rev().collect();\n+            let expected_right: Vec<_> = (0..first).collect();\n             assert_eq!(left, expected_left);\n             assert_eq!(right, expected_right);\n         }\n@@ -2680,16 +2680,16 @@ mod tests {\n             ring.push_back(i);\n \n             let (left, right) = ring.as_mut_slices();\n-            let expected: Vec<_> = range(0, i+1).collect();\n+            let expected: Vec<_> = (0..i+1).collect();\n             assert_eq!(left, expected);\n             assert_eq!(right, []);\n         }\n \n         for j in range(-last, 0) {\n             ring.push_front(j);\n             let (left, right) = ring.as_mut_slices();\n-            let expected_left: Vec<_> = range(-last, j+1).rev().collect();\n-            let expected_right: Vec<_> = range(0, first).collect();\n+            let expected_left: Vec<_> = (-last..j+1).rev().collect();\n+            let expected_right: Vec<_> = (0..first).collect();\n             assert_eq!(left, expected_left);\n             assert_eq!(right, expected_right);\n         }"}, {"sha": "bd07f354fbb31b1cabea4dffda6943c89bc6c638", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -1165,7 +1165,7 @@ impl ElementSwaps {\n         // element (equal to the original index).\n         ElementSwaps{\n             emit_reset: true,\n-            sdir: range(0, length).map(|i| SizeDirection{ size: i, dir: Neg }).collect(),\n+            sdir: (0..length).map(|i| SizeDirection{ size: i, dir: Neg }).collect(),\n             swaps_made: 0\n         }\n     }\n@@ -1526,7 +1526,7 @@ mod tests {\n     #[test]\n     fn test_from_fn() {\n         // Test on-stack from_fn.\n-        let mut v = range(0, 3).map(square).collect::<Vec<_>>();\n+        let mut v = (0..3).map(square).collect::<Vec<_>>();\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 3u);\n@@ -1536,7 +1536,7 @@ mod tests {\n         }\n \n         // Test on-heap from_fn.\n-        v = range(0, 5).map(square).collect::<Vec<_>>();\n+        v = (0..5).map(square).collect::<Vec<_>>();\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 5u);\n@@ -2134,7 +2134,7 @@ mod tests {\n                 // the second item represents which occurrence of that\n                 // number this element is, i.e. the second elements\n                 // will occur in sorted order.\n-                let mut v = range(0, len).map(|_| {\n+                let mut v = (0..len).map(|_| {\n                         let n = thread_rng().gen::<uint>() % 10;\n                         counts[n] += 1;\n                         (n, counts[n])\n@@ -2723,7 +2723,7 @@ mod tests {\n         assert_eq!(xs.capacity(), 128);\n         xs.shrink_to_fit();\n         assert_eq!(xs.capacity(), 100);\n-        assert_eq!(xs, range(0i, 100i).collect::<Vec<_>>());\n+        assert_eq!(xs, (0i..100i).collect::<Vec<_>>());\n     }\n \n     #[test]\n@@ -2854,7 +2854,7 @@ mod bench {\n     fn iterator(b: &mut Bencher) {\n         // peculiar numbers to stop LLVM from optimising the summation\n         // out.\n-        let v = range(0u, 100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect::<Vec<_>>();\n+        let v = (0u..100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect::<Vec<_>>();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -2882,7 +2882,7 @@ mod bench {\n     #[bench]\n     fn concat(b: &mut Bencher) {\n         let xss: Vec<Vec<uint>> =\n-            range(0, 100u).map(|i| range(0, i).collect()).collect();\n+            (0..100u).map(|i| (0..i).collect()).collect();\n         b.iter(|| {\n             xss.concat();\n         });\n@@ -2891,7 +2891,7 @@ mod bench {\n     #[bench]\n     fn connect(b: &mut Bencher) {\n         let xss: Vec<Vec<uint>> =\n-            range(0, 100u).map(|i| range(0, i).collect()).collect();\n+            (0..100u).map(|i| (0..i).collect()).collect();\n         b.iter(|| {\n             xss.connect(&0)\n         });\n@@ -2908,7 +2908,7 @@ mod bench {\n \n     #[bench]\n     fn starts_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n+        let vec: Vec<uint> = (0..100).collect();\n         b.iter(|| {\n             vec.starts_with(vec.as_slice())\n         })\n@@ -2924,8 +2924,8 @@ mod bench {\n \n     #[bench]\n     fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n-        let mut match_vec: Vec<uint> = range(0, 99).collect();\n+        let vec: Vec<uint> = (0..100).collect();\n+        let mut match_vec: Vec<uint> = (0..99).collect();\n         match_vec.push(0);\n         b.iter(|| {\n             vec.starts_with(match_vec.as_slice())\n@@ -2934,7 +2934,7 @@ mod bench {\n \n     #[bench]\n     fn ends_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n+        let vec: Vec<uint> = (0..100).collect();\n         b.iter(|| {\n             vec.ends_with(vec.as_slice())\n         })\n@@ -2950,8 +2950,8 @@ mod bench {\n \n     #[bench]\n     fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n-        let mut match_vec: Vec<uint> = range(0, 100).collect();\n+        let vec: Vec<uint> = (0..100).collect();\n+        let mut match_vec: Vec<uint> = (0..100).collect();\n         match_vec.as_mut_slice()[0] = 200;\n         b.iter(|| {\n             vec.starts_with(match_vec.as_slice())\n@@ -2960,7 +2960,7 @@ mod bench {\n \n     #[bench]\n     fn contains_last_element(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n+        let vec: Vec<uint> = (0..100).collect();\n         b.iter(|| {\n             vec.contains(&99u)\n         })\n@@ -3069,7 +3069,7 @@ mod bench {\n \n     #[bench]\n     fn sort_sorted(b: &mut Bencher) {\n-        let mut v = range(0u, 10000).collect::<Vec<_>>();\n+        let mut v = (0u..10000).collect::<Vec<_>>();\n         b.iter(|| {\n             v.sort();\n         });\n@@ -3113,7 +3113,7 @@ mod bench {\n \n     #[bench]\n     fn sort_big_sorted(b: &mut Bencher) {\n-        let mut v = range(0, 10000u).map(|i| (i, i, i, i)).collect::<Vec<_>>();\n+        let mut v = (0..10000u).map(|i| (i, i, i, i)).collect::<Vec<_>>();\n         b.iter(|| {\n             v.sort();\n         });"}, {"sha": "cfc8218dc1ce08f4e2498561c81bfe804c66d4a6", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -2122,7 +2122,7 @@ mod tests {\n     #[test]\n     fn test_chars_decoding() {\n         let mut bytes = [0u8; 4];\n-        for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n+        for c in (0u32..0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n             let s = ::core::str::from_utf8(&bytes[..len]).unwrap();\n             if Some(c) != s.chars().next() {\n@@ -2134,7 +2134,7 @@ mod tests {\n     #[test]\n     fn test_chars_rev_decoding() {\n         let mut bytes = [0u8; 4];\n-        for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n+        for c in (0u32..0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n             let s = ::core::str::from_utf8(&bytes[..len]).unwrap();\n             if Some(c) != s.chars().rev().next() {"}, {"sha": "99ad6deae7b0fac70dd98047202b9af7fb4645ed", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -2442,7 +2442,7 @@ mod tests {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let dst = range(0, src_len).collect::<Vec<_>>();\n+            let dst = (0..src_len).collect::<Vec<_>>();\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         })"}, {"sha": "2c89c7ffa3bc1fbda8c344030c1f6aefb6e0b629", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -242,7 +242,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n                     if i < 0\n                     || buf[i as uint] == b'-'\n                     || buf[i as uint] == b'+' {\n-                        for j in range(i as uint + 1, end).rev() {\n+                        for j in (i as uint + 1..end).rev() {\n                             buf[j + 1] = buf[j];\n                         }\n                         buf[(i + 1) as uint] = value2ascii(1);"}, {"sha": "173bfbaca6bd65f7ef06382289380afc194dfffb", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -717,7 +717,7 @@ pub trait IteratorExt: Iterator + Sized {\n         Self: ExactSizeIterator + DoubleEndedIterator\n     {\n         let len = self.len();\n-        for i in range(0, len).rev() {\n+        for i in (0..len).rev() {\n             if predicate(self.next_back().expect(\"rposition: incorrect ExactSizeIterator\")) {\n                 return Some(i);\n             }"}, {"sha": "dc57d22bbca6f3ef966f1557b6fbf2091ef31de6", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -812,7 +812,7 @@ impl TwoWaySearcher {\n \n             // See if the left part of the needle matches\n             let start = if long_period { 0 } else { self.memory };\n-            for i in range(start, self.crit_pos).rev() {\n+            for i in (start..self.crit_pos).rev() {\n                 if needle[i] != haystack[self.position + i] {\n                     self.position += self.period;\n                     if !long_period {"}, {"sha": "da2b053efda6ee695ed2422778612d5f28510154", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -731,12 +731,12 @@ fn test_random_access_cycle() {\n #[test]\n fn test_double_ended_range() {\n     assert!(range(11i, 14).rev().collect::<Vec<int>>() == vec![13i, 12, 11]);\n-    for _ in range(10i, 0).rev() {\n+    for _ in (10i..0).rev() {\n         panic!(\"unreachable\");\n     }\n \n     assert!(range(11u, 14).rev().collect::<Vec<uint>>() == vec![13u, 12, 11]);\n-    for _ in range(10u, 0).rev() {\n+    for _ in (10u..0).rev() {\n         panic!(\"unreachable\");\n     }\n }\n@@ -883,7 +883,7 @@ fn test_fuse() {\n \n #[bench]\n fn bench_rposition(b: &mut Bencher) {\n-    let it: Vec<uint> = range(0u, 300).collect();\n+    let it: Vec<uint> = (0u..300).collect();\n     b.iter(|| {\n         it.iter().rposition(|&x| x <= 150);\n     });\n@@ -900,7 +900,7 @@ fn bench_skip_while(b: &mut Bencher) {\n \n #[bench]\n fn bench_multiple_take(b: &mut Bencher) {\n-    let mut it = range(0u, 42).cycle();\n+    let mut it = (0u..42).cycle();\n     b.iter(|| {\n         let n = it.next().unwrap();\n         for _ in range(0u, n) {"}, {"sha": "bb9d1524786829f9f92916685ef545e848e258a5", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -223,13 +223,13 @@ fn test_ord() {\n /* FIXME(#20575)\n #[test]\n fn test_collect() {\n-    let v: Option<Vec<int>> = range(0i, 0).map(|_| Some(0i)).collect();\n+    let v: Option<Vec<int>> = (0i..0).map(|_| Some(0i)).collect();\n     assert!(v == Some(vec![]));\n \n-    let v: Option<Vec<int>> = range(0i, 3).map(|x| Some(x)).collect();\n+    let v: Option<Vec<int>> = (0i..3).map(|x| Some(x)).collect();\n     assert!(v == Some(vec![0, 1, 2]));\n \n-    let v: Option<Vec<int>> = range(0i, 3).map(|x| {\n+    let v: Option<Vec<int>> = (0i..3).map(|x| {\n         if x > 1 { None } else { Some(x) }\n     }).collect();\n     assert!(v == None);"}, {"sha": "d36228fa3d75b30a8ae38a9a575d31c3669f9fa5", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -68,13 +68,13 @@ pub fn test_impl_map_err() {\n /* FIXME(#20575)\n #[test]\n fn test_collect() {\n-    let v: Result<Vec<int>, ()> = range(0i, 0).map(|_| Ok::<int, ()>(0)).collect();\n+    let v: Result<Vec<int>, ()> = (0i..0).map(|_| Ok::<int, ()>(0)).collect();\n     assert!(v == Ok(vec![]));\n \n-    let v: Result<Vec<int>, ()> = range(0i, 3).map(|x| Ok::<int, ()>(x)).collect();\n+    let v: Result<Vec<int>, ()> = (0i..3).map(|x| Ok::<int, ()>(x)).collect();\n     assert!(v == Ok(vec![0, 1, 2]));\n \n-    let v: Result<Vec<int>, int> = range(0i, 3).map(|x| {\n+    let v: Result<Vec<int>, int> = (0i..3).map(|x| {\n         if x > 1 { Err(x) } else { Ok(x) }\n     }).collect();\n     assert!(v == Err(2));"}, {"sha": "3db79f2ba1fabcd40945781a39ed30e58e23c167", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -586,7 +586,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n \n     fn f(_x: uint) -> Vec<Optval> { return Vec::new(); }\n \n-    let mut vals: Vec<_> = range(0, n_opts).map(f).collect();\n+    let mut vals: Vec<_> = (0..n_opts).map(f).collect();\n     let mut free: Vec<String> = Vec::new();\n     let l = args.len();\n     let mut i = 0;"}, {"sha": "37276d90171f1cbb50bdb6fb1b721e82172000d5", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -247,14 +247,14 @@ mod test {\n         let seed : &[_] = &[0u32; 8];\n         let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n \n-        let v = range(0, 16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n+        let v = (0..16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(0xade0b876, 0x903df1a0, 0xe56a5d40, 0x28bd8653,\n                         0xb819d2bd, 0x1aed8da0, 0xccef36a8, 0xc70d778b,\n                         0x7c5941da, 0x8d485751, 0x3fe02477, 0x374ad8b8,\n                         0xf4b8436a, 0x1ca11815, 0x69b687c3, 0x8665eeb2));\n \n-        let v = range(0, 16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n+        let v = (0..16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(0xbee7079f, 0x7a385155, 0x7c97ba98, 0x0d082d73,\n                         0xa0290fcb, 0x6965e348, 0x3e53c612, 0xed7aee32,"}, {"sha": "a8dbcb387a7c3fdc83c6aece867559e3c6124b7c", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -330,7 +330,7 @@ impl Isaac64Rng {\n         if use_rsl {\n             macro_rules! memloop {\n                 ($arr:expr) => {{\n-                    for i in range(0, RAND_SIZE_64 / 8).map(|i| i * 8) {\n+                    for i in (0..RAND_SIZE_64 / 8).map(|i| i * 8) {\n                         a+=$arr[i  ]; b+=$arr[i+1];\n                         c+=$arr[i+2]; d+=$arr[i+3];\n                         e+=$arr[i+4]; f+=$arr[i+5];\n@@ -347,7 +347,7 @@ impl Isaac64Rng {\n             memloop!(self.rsl);\n             memloop!(self.mem);\n         } else {\n-            for i in range(0, RAND_SIZE_64 / 8).map(|i| i * 8) {\n+            for i in (0..RAND_SIZE_64 / 8).map(|i| i * 8) {\n                 mix!();\n                 self.mem[i  ]=a; self.mem[i+1]=b;\n                 self.mem[i+2]=c; self.mem[i+3]=d;\n@@ -374,7 +374,7 @@ impl Isaac64Rng {\n         }\n \n         for &(mr_offset, m2_offset) in MP_VEC.iter() {\n-            for base in range(0, MIDPOINT / 4).map(|i| i * 4) {\n+            for base in (0..MIDPOINT / 4).map(|i| i * 4) {\n \n                 macro_rules! rngstepp {\n                     ($j:expr, $shift:expr) => {{\n@@ -573,7 +573,7 @@ mod test {\n         let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n-        let v = range(0, 10).map(|_| ra.next_u32()).collect::<Vec<_>>();\n+        let v = (0..10).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(2558573138, 873787463, 263499565, 2103644246, 3595684709,\n                         4203127393, 264982119, 2765226902, 2737944514, 3900253796));\n@@ -583,7 +583,7 @@ mod test {\n         // skip forward to the 10000th number\n         for _ in range(0u, 10000) { rb.next_u32(); }\n \n-        let v = range(0, 10).map(|_| rb.next_u32()).collect::<Vec<_>>();\n+        let v = (0..10).map(|_| rb.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(3676831399, 3183332890, 2834741178, 3854698763, 2717568474,\n                         1576568959, 3507990155, 179069555, 141456972, 2478885421));\n@@ -593,7 +593,7 @@ mod test {\n         let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n-        let v = range(0, 10).map(|_| ra.next_u64()).collect::<Vec<_>>();\n+        let v = (0..10).map(|_| ra.next_u64()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(547121783600835980, 14377643087320773276, 17351601304698403469,\n                         1238879483818134882, 11952566807690396487, 13970131091560099343,\n@@ -605,7 +605,7 @@ mod test {\n         // skip forward to the 10000th number\n         for _ in range(0u, 10000) { rb.next_u64(); }\n \n-        let v = range(0, 10).map(|_| rb.next_u64()).collect::<Vec<_>>();\n+        let v = (0..10).map(|_| rb.next_u64()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(18143823860592706164, 8491801882678285927, 2699425367717515619,\n                         17196852593171130876, 2606123525235546165, 15790932315217671084,"}, {"sha": "e71ea92e69327cc414a4e9255c1c3f0804558305", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -1184,7 +1184,7 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_A_aligned(b: &mut Bencher) {\n-        let data = range(0, 4*100).map(|i| {\n+        let data = (0..4*100).map(|i| {\n             match i % 2 {\n               0 => 0x80u8,\n               _ => i as u8,\n@@ -1202,7 +1202,7 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_A_unaligned(b: &mut Bencher) {\n-        let data = range(0, 4*100+1).map(|i| {\n+        let data = (0..4*100+1).map(|i| {\n             match i % 2 {\n               1 => 0x80u8,\n               _ => i as u8\n@@ -1220,7 +1220,7 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_D_aligned(b: &mut Bencher) {\n-        let data = range(0, 4*100).map(|i| {\n+        let data = (0..4*100).map(|i| {\n             match i % 4 {\n               0 => 0x10u8,\n               3 => i as u8,\n@@ -1239,7 +1239,7 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_D_unaligned(b: &mut Bencher) {\n-        let data = range(0, 4*100+1).map(|i| {\n+        let data = (0..4*100+1).map(|i| {\n             match i % 4 {\n               1 => 0x10u8,\n               0 => i as u8,"}, {"sha": "0ad809207dfd69e9b523c92e878c0b9e7788a666", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -1598,7 +1598,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     F: FnMut(&mut SeekableMemWriter, &T),\n     T: Hash<SipHasher>,\n {\n-    let mut buckets: Vec<Vec<entry<T>>> = range(0, 256u16).map(|_| Vec::new()).collect();\n+    let mut buckets: Vec<Vec<entry<T>>> = (0..256u16).map(|_| Vec::new()).collect();\n     for elt in index.into_iter() {\n         let mut s = SipHasher::new();\n         elt.val.hash(&mut s);"}, {"sha": "fec7b51157d81a25e82974d82de6289cb6f3ea73", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -70,7 +70,7 @@ impl<'a> fmt::Debug for Matrix<'a> {\n \n         let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0u);\n         assert!(m.iter().all(|row| row.len() == column_count));\n-        let column_widths: Vec<uint> = range(0, column_count).map(|col| {\n+        let column_widths: Vec<uint> = (0..column_count).map(|col| {\n             pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0u)\n         }).collect();\n \n@@ -609,7 +609,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n                                 let pat_slice = &pats[];\n-                                let subpats: Vec<_> = range(0, arity).map(|i| {\n+                                let subpats: Vec<_> = (0..arity).map(|i| {\n                                     pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n                                 }).collect();\n                                 vec![construct_witness(cx, &c, subpats, left_ty)]"}, {"sha": "7941e3f79f7acda6fe75861728d54fae1aa5468d", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -1343,7 +1343,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 let mut new_lts = Vec::new();\n                 if data.lifetimes.len() == 0 {\n                     // traverse once to see if there's a need to insert lifetime\n-                    let need_insert = range(0, expected).any(|i| {\n+                    let need_insert = (0..expected).any(|i| {\n                         indexes.contains(&i)\n                     });\n                     if need_insert {"}, {"sha": "b626c8b7ee29ccb4232dc7d13d6bb6b3999f1b54", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -828,7 +828,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn next_ty_vars(&self, n: uint) -> Vec<Ty<'tcx>> {\n-        range(0, n).map(|_i| self.next_ty_var()).collect()\n+        (0..n).map(|_i| self.next_ty_var()).collect()\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {"}, {"sha": "517fd54a80589a67a95a75f06dc52da49d18e5e0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -2473,7 +2473,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n // FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n fn err_args<'tcx>(tcx: &ty::ctxt<'tcx>, len: uint) -> Vec<Ty<'tcx>> {\n-    range(0, len).map(|_| tcx.types.err).collect()\n+    (0..len).map(|_| tcx.types.err).collect()\n }\n \n fn write_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,"}, {"sha": "27e5295d2c8a226e0cdc668e750416d5eaaa865e", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -1775,11 +1775,11 @@ mod test_map {\n             for _ in half {}\n \n             DROP_VECTOR.with(|v| {\n-                let nk = range(0u, 100).filter(|&i| {\n+                let nk = (0u..100).filter(|&i| {\n                     v.borrow()[i] == 1\n                 }).count();\n \n-                let nv = range(0u, 100).filter(|&i| {\n+                let nv = (0u..100).filter(|&i| {\n                     v.borrow()[i+100] == 1\n                 }).count();\n "}, {"sha": "dc16fd88201a1aac68fcf4c1d7765f375507b8db", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -1198,7 +1198,7 @@ mod test_set {\n \n     #[test]\n     fn test_drain() {\n-        let mut s: HashSet<int> = range(1, 100).collect();\n+        let mut s: HashSet<int> = (1..100).collect();\n \n         // try this a bunch of times to make sure we don't screw up internal state.\n         for _ in range(0i, 20) {"}, {"sha": "cb74c741b2f7115399be29c0bf69295011c00419", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -1001,7 +1001,7 @@ mod tests {\n     fn test_pow() {\n         fn naive_pow<T: Int>(base: T, exp: uint) -> T {\n             let one: T = Int::one();\n-            range(0, exp).fold(one, |acc, _| acc * base)\n+            (0..exp).fold(one, |acc, _| acc * base)\n         }\n         macro_rules! assert_pow {\n             (($num:expr, $exp:expr) => $expected:expr) => {{\n@@ -1028,7 +1028,7 @@ mod bench {\n \n     #[bench]\n     fn bench_pow_function(b: &mut Bencher) {\n-        let v = range(0, 1024u).collect::<Vec<_>>();\n+        let v = (0..1024u).collect::<Vec<_>>();\n         b.iter(|| {v.iter().fold(0u, |old, new| old.pow(*new));});\n     }\n }"}, {"sha": "f429f731b7d00d01a808b244208f3256b0f282d1", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -518,7 +518,7 @@ mod bench {\n         ({\n             use super::u64_from_be_bytes;\n \n-            let data = range(0u8, $stride*100+$start_index).collect::<Vec<_>>();\n+            let data = (0u8..$stride*100+$start_index).collect::<Vec<_>>();\n             let mut sum = 0u64;\n             $b.iter(|| {\n                 let mut i = $start_index;"}, {"sha": "a347b4c0665a38d0b7e72ec9920c80a4f04b88eb", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -617,7 +617,7 @@ unsafe fn load_argc_and_argv(argc: int,\n                              argv: *const *const c_char) -> Vec<Vec<u8>> {\n     use iter::range;\n \n-    range(0, argc as uint).map(|i| {\n+    (0..argc as uint).map(|i| {\n         ffi::c_str_to_bytes(&*argv.offset(i as int)).to_vec()\n     }).collect()\n }\n@@ -717,7 +717,7 @@ fn real_args() -> Vec<String> {\n     let lpCmdLine = unsafe { GetCommandLineW() };\n     let szArgList = unsafe { CommandLineToArgvW(lpCmdLine, lpArgCount) };\n \n-    let args: Vec<_> = range(0, nArgs as uint).map(|i| unsafe {\n+    let args: Vec<_> = (0..nArgs as uint).map(|i| unsafe {\n         // Determine the length of this argument.\n         let ptr = *szArgList.offset(i as int);\n         let mut len = 0;"}, {"sha": "7193d4438e5f8f3f04abdf8bc0ac02064244fcb8", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -176,7 +176,7 @@\n //! }\n //!\n //! fn free_doors(blocked: &[uint]) -> Vec<uint> {\n-//!     range(0, 3).filter(|x| !blocked.contains(x)).collect()\n+//!     (0u..3).filter(|x| !blocked.contains(x)).collect()\n //! }\n //!\n //! fn main() {\n@@ -601,7 +601,7 @@ mod test {\n         let max_val = 100i;\n \n         let mut r = thread_rng();\n-        let vals = range(min_val, max_val).collect::<Vec<int>>();\n+        let vals = (min_val..max_val).collect::<Vec<int>>();\n         let small_sample = sample(&mut r, vals.iter(), 5);\n         let large_sample = sample(&mut r, vals.iter(), vals.len() + 5);\n "}, {"sha": "b63f2e2d73a03df4f783892ed18f17cca57550bd", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -97,7 +97,7 @@ mod imp {\n \n     unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> {\n         let argv = argv as *const *const libc::c_char;\n-        range(0, argc as uint).map(|i| {\n+        (0..argc as uint).map(|i| {\n             ffi::c_str_to_bytes(&*argv.offset(i as int)).to_vec()\n         }).collect()\n     }"}, {"sha": "574892d419ab6a1450678ea799e162cb9266f7c9", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -150,7 +150,7 @@ impl<T: Send> Packet<T> {\n                     tail: ptr::null_mut(),\n                 },\n                 buf: Buffer {\n-                    buf: range(0, cap + if cap == 0 {1} else {0}).map(|_| None).collect(),\n+                    buf: (0..cap + if cap == 0 {1} else {0}).map(|_| None).collect(),\n                     start: 0,\n                     size: 0,\n                 },"}, {"sha": "e310b8f6d90b3f3fe5a635124e1ba7ab06fbce8c", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -126,7 +126,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n     let cnt = unsafe { backtrace(buf.as_mut_ptr(), SIZE as libc::c_int) as uint};\n \n     // skipping the first one as it is write itself\n-    let iter = range(1, cnt).map(|i| {\n+    let iter = (1..cnt).map(|i| {\n         print(w, i as int, buf[i])\n     });\n     result::fold(iter, (), |_, _| ())"}, {"sha": "993d9000ae11308d915e21d0a6c2ccf9b1ee5f0c", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -166,7 +166,7 @@ pub fn count_names(ms: &[TokenTree]) -> usize {\n pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: BytePos)\n                            -> Box<MatcherPos> {\n     let match_idx_hi = count_names(&ms[]);\n-    let matches: Vec<_> = range(0, match_idx_hi).map(|_| Vec::new()).collect();\n+    let matches: Vec<_> = (0..match_idx_hi).map(|_| Vec::new()).collect();\n     box MatcherPos {\n         stack: vec![],\n         top_elts: TtSeq(ms),"}, {"sha": "d466ece0998b104d7120d2498df1da4d7697696f", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -939,7 +939,7 @@ mod bench {\n     #[bench]\n     pub fn sum_many_f64(b: &mut Bencher) {\n         let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n-        let v = range(0, 500).map(|i| nums[i%5]).collect::<Vec<_>>();\n+        let v = (0..500).map(|i| nums[i%5]).collect::<Vec<_>>();\n \n         b.iter(|| {\n             v.sum();"}, {"sha": "663ee9b719fb504ae204ffa3d88751dbedce5d2e", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -62,13 +62,13 @@ fn descending<M: MutableMap>(map: &mut M, n_keys: uint) {\n     println!(\" Descending integers:\");\n \n     timed(\"insert\", || {\n-        for i in range(0, n_keys).rev() {\n+        for i in (0..n_keys).rev() {\n             map.insert(i, i + 1);\n         }\n     });\n \n     timed(\"search\", || {\n-        for i in range(0, n_keys).rev() {\n+        for i in (0..n_keys).rev() {\n             assert_eq!(map.find(&i).unwrap(), &(i + 1));\n         }\n     });"}, {"sha": "ebdecbc8d02b6b1d8491f2948531e61d6331d2c4", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -97,7 +97,7 @@ impl Perm {\n             *place = i as i32 + 1;\n         }\n \n-        for i in range(1, self.n as uint).rev() {\n+        for i in (1..self.n as uint).rev() {\n             let d = idx / self.fact[i] as i32;\n             self.cnt[i] = d;\n             idx %= self.fact[i] as i32;\n@@ -161,7 +161,7 @@ fn fannkuch(n: i32) -> (i32, i32) {\n     let mut futures = vec![];\n     let k = perm.max() / N;\n \n-    for (_, j) in range(0, N).zip(iter::count(0, k)) {\n+    for (_, j) in (0..N).zip(iter::count(0, k)) {\n         let max = cmp::min(j+k, perm.max());\n \n         futures.push(Thread::scoped(move|| {"}, {"sha": "67654f979c282635744ef415db0123840159e7ef", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -135,7 +135,7 @@ struct Items<'a> {\n impl Table {\n     fn new() -> Table {\n         Table {\n-            items: range(0, TABLE_SIZE).map(|_| None).collect()\n+            items: (0..TABLE_SIZE).map(|_| None).collect()\n         }\n     }\n \n@@ -299,7 +299,7 @@ fn main() {\n     };\n     let input = Arc::new(input);\n \n-    let nb_freqs: Vec<_> = range(1u, 3).map(|i| {\n+    let nb_freqs: Vec<_> = (1u..3).map(|i| {\n         let input = input.clone();\n         (i, Thread::scoped(move|| generate_frequencies(input.as_slice(), i)))\n     }).collect();"}, {"sha": "d0959068ce8521859916c41f483842730979ef46", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -80,7 +80,7 @@ fn mandelbrot<W: old_io::Writer>(w: uint, mut out: W) -> old_io::IoResult<()> {\n     let mut precalc_r = Vec::with_capacity(w);\n     let mut precalc_i = Vec::with_capacity(h);\n \n-    let precalc_futures = range(0, WORKERS).map(|i| {\n+    let precalc_futures = (0..WORKERS).map(|i| {\n         Thread::scoped(move|| {\n             let mut rs = Vec::with_capacity(w / WORKERS);\n             let mut is = Vec::with_capacity(w / WORKERS);\n@@ -118,7 +118,7 @@ fn mandelbrot<W: old_io::Writer>(w: uint, mut out: W) -> old_io::IoResult<()> {\n     let arc_init_r = Arc::new(precalc_r);\n     let arc_init_i = Arc::new(precalc_i);\n \n-    let data = range(0, WORKERS).map(|i| {\n+    let data = (0..WORKERS).map(|i| {\n         let vec_init_r = arc_init_r.clone();\n         let vec_init_i = arc_init_i.clone();\n "}, {"sha": "b31241f12151ef13161b704eb70fcb8d3dc4a35e", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -169,7 +169,7 @@ fn make_masks() -> Vec<Vec<Vec<u64> > > {\n         .map(|(id, p)| transform(p, id != 3))\n         .collect();\n \n-    range(0i, 50).map(|yx| {\n+    (0i..50).map(|yx| {\n         transforms.iter().enumerate().map(|(id, t)| {\n             t.iter().filter_map(|p| mask(yx / 5, yx % 5, id, p)).collect()\n         }).collect()\n@@ -297,7 +297,7 @@ fn search(\n     let masks_at = &masks[i];\n \n     // for every unused piece\n-    for id in range(0u, 10).filter(|&id| board & (1 << (id + 50)) == 0) {\n+    for id in (0u..10).filter(|&id| board & (1 << (id + 50)) == 0) {\n         // for each mask that fits on the board\n         for m in masks_at[id].iter().filter(|&m| board & *m == 0) {\n             // This check is too costly."}, {"sha": "8c6925a0f1fa30e85976633f0a67cfad9d62061b", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -49,8 +49,8 @@ impl Sudoku {\n     }\n \n     pub fn from_vec(vec: &[[u8;9];9]) -> Sudoku {\n-        let g = range(0, 9u).map(|i| {\n-            range(0, 9u).map(|j| { vec[i][j] }).collect()\n+        let g = (0..9u).map(|i| {\n+            (0..9u).map(|j| { vec[i][j] }).collect()\n         }).collect();\n         return Sudoku::new(g)\n     }"}, {"sha": "107c5cb9782252cfd687f7c3bb9a424cc4a4839d", "filename": "src/test/debuginfo/lexical-scope-in-parameterless-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-parameterless-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-parameterless-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-parameterless-closure.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -19,6 +19,6 @@\n // Nothing to do here really, just make sure it compiles. See issue #8513.\n fn main() {\n     let _ = |&:|();\n-    let _ = range(1u,3).map(|_| 5i);\n+    let _ = (1u..3).map(|_| 5i);\n }\n "}, {"sha": "0ad43ea01710ca0687206c4798802f234790f59d", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -45,7 +45,7 @@ fn main() {\n             let _ = write!(&mut File::create(&main_file).unwrap(),\n                            \"#![feature(non_ascii_idents)] fn main() {{ {} }}\",\n                            // random string of length n\n-                           range(0, n).map(|_| random_char()).collect::<String>());\n+                           (0..n).map(|_| random_char()).collect::<String>());\n         }\n \n         // rustc is passed to us with --out-dir and -L etc., so we"}, {"sha": "b8e19d370261377a6380f18170ebd379cd82bad2", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -26,7 +26,7 @@ fn add_int(x: &mut Ints, v: int) {\n \n fn iter_ints<F>(x: &Ints, mut f: F) -> bool where F: FnMut(&int) -> bool {\n     let l = x.values.len();\n-    range(0u, l).all(|i| f(&x.values[i]))\n+    (0u..l).all(|i| f(&x.values[i]))\n }\n \n pub fn main() {"}, {"sha": "533d67e27eb2fd8137761e4f156e82d7ebe253c4", "filename": "src/test/run-pass/extern-stress.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-stress.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -41,7 +41,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n pub fn main() {\n-    range(0u, 100).map(|_| {\n+    (0u..100).map(|_| {\n         Thread::scoped(move|| {\n             assert_eq!(count(5), 16);\n         })"}, {"sha": "5201c934185a78a3bb669dc7efd26eb41fcaf0ca", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -38,7 +38,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n pub fn main() {\n-    range(0, 10u).map(|i| {\n+    (0..10u).map(|i| {\n         Thread::scoped(move|| {\n             let result = count(5);\n             println!(\"result = {}\", result);"}, {"sha": "227d8f7b8c82ab970409f07a228386646f1f0590", "filename": "src/test/run-pass/issue-15673.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Fissue-15673.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Fissue-15673.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15673.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -11,5 +11,5 @@\n use std::iter::AdditiveIterator;\n fn main() {\n     let x: [u64; 3] = [1, 2, 3];\n-    assert_eq!(6, range(0, 3).map(|i| x[i]).sum());\n+    assert_eq!(6, (0..3).map(|i| x[i]).sum());\n }"}, {"sha": "f724af73422297204e8510ace7ef7dd8c2940894", "filename": "src/test/run-pass/issue-18539.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Fissue-18539.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Fissue-18539.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18539.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -19,5 +19,5 @@ fn uint_to_foo(_: uint) -> Foo {\n \n #[allow(unused_must_use)]\n fn main() {\n-    range(0u, 10).map(uint_to_foo);\n+    (0u..10).map(uint_to_foo);\n }"}, {"sha": "fecef2f87d8cec066f3f3dfbed1b0e3b2bfadcd3", "filename": "src/test/run-pass/issue-2989.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Fissue-2989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Fissue-2989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2989.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -21,7 +21,7 @@ impl methods for () {\n // the position of this function is significant! - if it comes before methods\n // then it works, if it comes after it then it doesn't!\n fn to_bools(bitv: Storage) -> Vec<bool> {\n-    range(0, 8).map(|i| {\n+    (0..8).map(|i| {\n         let w = i / 64;\n         let b = i % 64;\n         let x = 1u64 & (bitv.storage[w] >> b);"}, {"sha": "09507afb9cefda1e418e031612d03594e1d48490", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -153,7 +153,7 @@ unsafe fn test_triangle() -> bool {\n     // Test 3: turn triangle into a square, bottom to top.\n     unsafe fn test_3(ascend: &mut [*mut u8]) {\n         let new_size = idx_to_size(COUNT-1);\n-        for i in range(0u, COUNT / 2).rev() {\n+        for i in (0u..COUNT / 2).rev() {\n             let (p0, p1, old_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n             assert!(old_size < new_size);\n \n@@ -168,7 +168,7 @@ unsafe fn test_triangle() -> bool {\n     // Test 4: turn the square back into a triangle, bottom to top.\n     unsafe fn test_4(ascend: &mut [*mut u8]) {\n         let old_size = idx_to_size(COUNT-1);\n-        for i in range(0u, COUNT / 2).rev() {\n+        for i in (0u..COUNT / 2).rev() {\n             let (p0, p1, new_size) = (ascend[2*i], ascend[2*i+1], idx_to_size(i));\n             assert!(new_size < old_size);\n "}, {"sha": "efc1913a2055d160749bb40f41e6a6f8fa1dd7bf", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -36,7 +36,7 @@ fn start(argc: int, argv: *const *const u8) -> int {\n     }\n \n     let args = unsafe {\n-        range(0, argc as uint).map(|i| {\n+        (0..argc as uint).map(|i| {\n             let ptr = *argv.offset(i as int) as *const _;\n             ffi::c_str_to_bytes(&ptr).to_vec()\n         }).collect::<Vec<_>>()"}, {"sha": "07e61733a56a8407134b36d1cef2a1f7f02cf028", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -34,7 +34,7 @@ fn test() {\n \n     let (srv_tx, srv_rx) = channel();\n     let (cli_tx, cli_rx) = channel();\n-    let _t = range(0, N).map(|_| {\n+    let _t = (0..N).map(|_| {\n         let a = a.clone();\n         let cnt = cnt.clone();\n         let srv_tx = srv_tx.clone();\n@@ -55,7 +55,7 @@ fn test() {\n         })\n     }).collect::<Vec<_>>();\n \n-    let _t = range(0, N).map(|_| {\n+    let _t = (0..N).map(|_| {\n         let cli_tx = cli_tx.clone();\n         Thread::scoped(move|| {\n             for _ in range(0, M) {"}, {"sha": "b2f6dad998881b344501cbc7d6f30e2356865e75", "filename": "src/test/run-pass/typeck_type_placeholder_1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -21,11 +21,11 @@ static CONSTEXPR: TestStruct = TestStruct{x: &413 as *const _};\n \n \n pub fn main() {\n-    let x: Vec<_> = range(0u, 5).collect();\n+    let x: Vec<_> = (0u..5).collect();\n     let expected: &[uint] = &[0,1,2,3,4];\n     assert_eq!(x.as_slice(), expected);\n \n-    let x = range(0u, 5).collect::<Vec<_>>();\n+    let x = (0u..5).collect::<Vec<_>>();\n     assert_eq!(x.as_slice(), expected);\n \n     let y: _ = \"hello\";"}, {"sha": "8b9c65c7ca83cce98f8907b69cf5da49c0a79c69", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -22,7 +22,7 @@ pub fn main() {\n     let (tx, rx) = channel();\n     let n = 100u;\n     let mut expected = 0u;\n-    let _t = range(0u, n).map(|i| {\n+    let _t = (0u..n).map(|i| {\n         expected += i;\n         let tx = tx.clone();\n         Thread::scoped(move|| {"}, {"sha": "ef48bdff11d0b101ecc3fb5d393cb9b711d9e766", "filename": "src/test/run-pass/wait-forked-but-failed-child.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c300d681bd2e901ef39591bbfb1ea4568ac6be70/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs?ref=c300d681bd2e901ef39591bbfb1ea4568ac6be70", "patch": "@@ -55,7 +55,7 @@ fn find_zombies() { }\n fn main() {\n     let too_long = format!(\"/NoSuchCommand{:0300}\", 0u8);\n \n-    let _failures = range(0, 100).map(|_| {\n+    let _failures = (0..100).map(|_| {\n         let cmd = Command::new(too_long.as_slice());\n         let failed = cmd.spawn();\n         assert!(failed.is_err(), \"Make sure the command fails to spawn(): {:?}\", cmd);"}]}