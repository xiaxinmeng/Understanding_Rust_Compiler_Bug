{"sha": "494c0c3b61bdcd3389789495fc91c74d6fcf4a10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NGMwYzNiNjFiZGNkMzM4OTc4OTQ5NWZjOTFjNzRkNmZjZjRhMTA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-20T01:28:09Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-20T01:28:09Z"}, "message": "After all that, give up on \"complex\" version of type_has_pointers and just manually inspect. Can't calculate property during interning.", "tree": {"sha": "8ed77e5131dfaa9437652746377e63a32e6862e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ed77e5131dfaa9437652746377e63a32e6862e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/494c0c3b61bdcd3389789495fc91c74d6fcf4a10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/494c0c3b61bdcd3389789495fc91c74d6fcf4a10", "html_url": "https://github.com/rust-lang/rust/commit/494c0c3b61bdcd3389789495fc91c74d6fcf4a10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/494c0c3b61bdcd3389789495fc91c74d6fcf4a10/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d09e12e15b8b37739cb2935ae3e8e13c693bd8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d09e12e15b8b37739cb2935ae3e8e13c693bd8f", "html_url": "https://github.com/rust-lang/rust/commit/5d09e12e15b8b37739cb2935ae3e8e13c693bd8f"}], "stats": {"total": 123, "additions": 64, "deletions": 59}, "files": [{"sha": "4618c65b0bd043ce0b9bc3ca454fc85f59e3a77b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/494c0c3b61bdcd3389789495fc91c74d6fcf4a10/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494c0c3b61bdcd3389789495fc91c74d6fcf4a10/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=494c0c3b61bdcd3389789495fc91c74d6fcf4a10", "patch": "@@ -2214,7 +2214,7 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n         }\n \n         case (_) {\n-            if (ty::type_contains_pointers(cx.fcx.lcx.ccx.tcx, t) &&\n+            if (ty::type_has_pointers(cx.fcx.lcx.ccx.tcx, t) &&\n                 ty::type_is_structural(cx.fcx.lcx.ccx.tcx, t)) {\n                 rslt = iter_structural_ty(cx, v0, t,\n                                           bind drop_ty(_, _, _));\n@@ -3112,7 +3112,7 @@ fn drop_ty(&@block_ctxt cx,\n            ValueRef v,\n            ty::t t) -> result {\n \n-    if (ty::type_contains_pointers(cx.fcx.lcx.ccx.tcx, t)) {\n+    if (ty::type_has_pointers(cx.fcx.lcx.ccx.tcx, t)) {\n         ret call_tydesc_glue(cx, v, t, false, abi::tydesc_field_drop_glue);\n     }\n     ret res(cx, C_nil());\n@@ -3122,7 +3122,7 @@ fn free_ty(&@block_ctxt cx,\n            ValueRef v,\n            ty::t t) -> result {\n \n-    if (ty::type_contains_pointers(cx.fcx.lcx.ccx.tcx, t)) {\n+    if (ty::type_has_pointers(cx.fcx.lcx.ccx.tcx, t)) {\n         ret call_tydesc_glue(cx, v, t, false, abi::tydesc_field_free_glue);\n     }\n     ret res(cx, C_nil());"}, {"sha": "f50443c2a41a2399d62442a6ece28638f78c74cb", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 61, "deletions": 56, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/494c0c3b61bdcd3389789495fc91c74d6fcf4a10/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/494c0c3b61bdcd3389789495fc91c74d6fcf4a10/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=494c0c3b61bdcd3389789495fc91c74d6fcf4a10", "patch": "@@ -89,8 +89,7 @@ type raw_t = rec(sty struct,\n                  bool has_params,\n                  bool has_bound_params,\n                  bool has_vars,\n-                 bool has_locals,\n-                 bool has_pointers);\n+                 bool has_locals);\n \n type t = uint;\n \n@@ -260,32 +259,28 @@ fn mk_raw_ty(&ctxt cx, &sty st, &option::t[str] cname) -> raw_t {\n     let bool has_bound_params = false;\n     let bool has_vars = false;\n     let bool has_locals = false;\n-    let bool has_pointers = false;\n \n     fn derive_flags_t(&ctxt cx,\n                       &mutable bool has_params,\n                       &mutable bool has_bound_params,\n                       &mutable bool has_vars,\n                       &mutable bool has_locals,\n-                      &mutable bool has_pointers,\n                       &t tt) {\n         auto rt = interner::get[raw_t](*cx.ts, tt);\n         has_params = has_params || rt.has_params;\n         has_bound_params = has_bound_params || rt.has_bound_params;\n         has_vars = has_vars || rt.has_vars;\n         has_locals = has_locals || rt.has_locals;\n-        has_pointers = has_pointers || rt.has_pointers;\n     }\n \n     fn derive_flags_mt(&ctxt cx,\n                        &mutable bool has_params,\n                        &mutable bool has_bound_params,\n                        &mutable bool has_vars,\n                        &mutable bool has_locals,\n-                       &mutable bool has_pointers,\n                        &mt m) {\n         derive_flags_t(cx, has_params, has_bound_params,\n-                       has_vars, has_locals, has_pointers, m.ty);\n+                       has_vars, has_locals, m.ty);\n     }\n \n \n@@ -294,101 +289,89 @@ fn mk_raw_ty(&ctxt cx, &sty st, &option::t[str] cname) -> raw_t {\n                         &mutable bool has_bound_params,\n                         &mutable bool has_vars,\n                         &mutable bool has_locals,\n-                        &mutable bool has_pointers,\n                         &arg a) {\n         derive_flags_t(cx, has_params, has_bound_params,\n-                       has_vars, has_locals, has_pointers, a.ty);\n+                       has_vars, has_locals, a.ty);\n     }\n \n     fn derive_flags_sig(&ctxt cx,\n                         &mutable bool has_params,\n                         &mutable bool has_bound_params,\n                         &mutable bool has_vars,\n                         &mutable bool has_locals,\n-                        &mutable bool has_pointers,\n                         &vec[arg] args,\n                         &t tt) {\n         for (arg a in args) {\n             derive_flags_arg(cx, has_params, has_bound_params,\n-                             has_vars, has_locals, has_pointers, a);\n+                             has_vars, has_locals, a);\n         }\n         derive_flags_t(cx, has_params, has_bound_params,\n-                       has_vars, has_locals, has_pointers, tt);\n+                       has_vars, has_locals, tt);\n     }\n \n     alt (st) {\n         case (ty_param(_)) {\n             has_params = true;\n-            has_pointers = true;\n         }\n         case (ty_bound_param(_)) {\n             has_bound_params = true;\n-            has_pointers = true;\n         }\n         case (ty_var(_)) { has_vars = true; }\n         case (ty_local(_)) { has_locals = true; }\n-        case (ty_tag(?did, ?tys)) {\n+        case (ty_tag(_, ?tys)) {\n             for (t tt in tys) {\n                 derive_flags_t(cx, has_params, has_bound_params,\n-                               has_vars, has_locals, has_pointers, tt);\n+                               has_vars, has_locals, tt);\n             }\n         }\n         case (ty_box(?m)) {\n-            has_pointers = true;\n             derive_flags_mt(cx, has_params, has_bound_params,\n-                            has_vars, has_locals, has_pointers, m);\n+                            has_vars, has_locals, m);\n         }\n \n         case (ty_vec(?m)) {\n-            has_pointers = true;\n             derive_flags_mt(cx, has_params, has_bound_params,\n-                            has_vars, has_locals, has_pointers, m);\n+                            has_vars, has_locals, m);\n         }\n \n         case (ty_port(?tt)) {\n-            has_pointers = true;\n             derive_flags_t(cx, has_params, has_bound_params,\n-                           has_vars, has_locals, has_pointers, tt);\n+                           has_vars, has_locals, tt);\n         }\n \n         case (ty_chan(?tt)) {\n-            has_pointers = true;\n             derive_flags_t(cx, has_params, has_bound_params,\n-                           has_vars, has_locals, has_pointers, tt);\n+                           has_vars, has_locals, tt);\n         }\n \n         case (ty_tup(?mts)) {\n             for (mt m in mts) {\n                 derive_flags_mt(cx, has_params, has_bound_params,\n-                                has_vars, has_locals, has_pointers, m);\n+                                has_vars, has_locals, m);\n             }\n         }\n \n         case (ty_rec(?flds)) {\n             for (field f in flds) {\n                 derive_flags_mt(cx, has_params, has_bound_params,\n-                                has_vars, has_locals, has_pointers, f.mt);\n+                                has_vars, has_locals, f.mt);\n             }\n         }\n \n         case (ty_fn(_, ?args, ?tt)) {\n-            has_pointers = true;\n             derive_flags_sig(cx, has_params, has_bound_params,\n-                             has_vars, has_locals, has_pointers, args, tt);\n+                             has_vars, has_locals, args, tt);\n         }\n \n         case (ty_native_fn(_, ?args, ?tt)) {\n-            has_pointers = true;\n             derive_flags_sig(cx, has_params, has_bound_params,\n-                             has_vars, has_locals, has_pointers, args, tt);\n+                             has_vars, has_locals, args, tt);\n         }\n \n         case (ty_obj(?meths)) {\n-            has_pointers = true;\n             for (method m in meths) {\n                 derive_flags_sig(cx, has_params, has_bound_params,\n-                                 has_vars, has_locals, has_pointers,\n-                                 m.inputs, m.output);\n+                                 has_vars, has_locals, m.inputs, m.output);\n             }\n         }\n         case (_) { }\n@@ -398,8 +381,7 @@ fn mk_raw_ty(&ctxt cx, &sty st, &option::t[str] cname) -> raw_t {\n             has_params = has_params,\n             has_bound_params = has_bound_params,\n             has_vars = has_vars,\n-            has_locals = has_locals,\n-            has_pointers = has_pointers);\n+            has_locals = has_locals);\n }\n \n fn intern(&ctxt cx, &sty st, &option::t[str] cname) {\n@@ -408,16 +390,7 @@ fn intern(&ctxt cx, &sty st, &option::t[str] cname) {\n \n fn gen_ty_full(&ctxt cx, &sty st, &option::t[str] cname) -> t {\n     auto raw_type = mk_raw_ty(cx, st, cname);\n-    auto t = interner::intern[raw_t](*cx.ts, raw_type);\n-\n-    /*\n-    if (raw_type.has_pointers) {\n-        log_err \"type has pointers: \" + ty_to_str(cx, t);\n-    } else {\n-        log_err \"type has no pointers: \" + ty_to_str(cx, t);\n-    }\n-    */\n-    ret t;\n+    ret interner::intern[raw_t](*cx.ts, raw_type);\n }\n \n // These are private constructors to this module. External users should always\n@@ -936,7 +909,6 @@ fn sequence_element_type(&ctxt cx, &t ty) -> t {\n     fail;\n }\n \n-\n fn type_is_tup_like(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_box(_))    { ret true; }\n@@ -998,6 +970,49 @@ fn type_is_scalar(&ctxt cx, &t ty) -> bool {\n }\n \n \n+fn type_has_pointers(&ctxt cx, &t ty) -> bool {\n+    alt (struct(cx, ty)) {\n+        // scalar types\n+        case (ty_nil) { ret false; }\n+        case (ty_bool) { ret false; }\n+        case (ty_int) { ret false; }\n+        case (ty_float) { ret false; }\n+        case (ty_uint) { ret false; }\n+        case (ty_machine(_)) { ret false; }\n+        case (ty_char) { ret false; }\n+        case (ty_type) { ret false; }\n+        case (ty_native) { ret false; }\n+\n+        case (ty_tup(?elts))    {\n+            for (mt m in elts) {\n+                if (type_has_pointers(cx, m.ty)) { ret true; }\n+            }\n+            ret false;\n+        }\n+        case (ty_rec(?flds)) {\n+            for (field f in flds) {\n+                if (type_has_pointers(cx, f.mt.ty)) { ret true; }\n+            }\n+            ret false;\n+        }\n+\n+        case (ty_tag(?did,?tps))  {\n+            auto variants = tag_variants(cx, did);\n+            for (variant_info variant in variants) {\n+                auto tup_ty = mk_imm_tup(cx, variant.args);\n+                // Perform any type parameter substitutions.\n+                tup_ty = bind_params_in_type(cx, tup_ty);\n+                tup_ty = substitute_type_params(cx, tps, tup_ty);\n+                if (type_has_pointers(cx, tup_ty)) { ret true; }\n+            }\n+            ret false;\n+        }\n+        case (_) { ret true; }\n+    }\n+    fail;\n+}\n+\n+\n // FIXME: should we just return true for native types in\n // type_is_scalar?\n fn type_is_native(&ctxt cx, &t ty) -> bool {\n@@ -1616,15 +1631,6 @@ fn type_contains_bound_params(&ctxt cx, &t typ) -> bool {\n     ret interner::get[raw_t](*cx.ts, typ).has_bound_params;\n }\n \n-fn type_contains_pointers(&ctxt cx, &t typ) -> bool {\n-    // FIXME: this is currently incorrect, pending an improved\n-    // version of the \"contains pointers\" derived property.\n-    //\n-    // ret interner::get[raw_t](*cx.ts, typ).has_pointers;\n-\n-    ret (!type_is_scalar(cx, typ));\n-}\n-\n // Type accessors for substructures of types\n \n fn ty_fn_args(&ctxt cx, &t fty) -> vec[arg] {\n@@ -2832,7 +2838,6 @@ fn def_has_ty_params(&ast::def def) -> bool {\n \n type variant_info = rec(vec[ty::t] args, ty::t ctor_ty, ast::def_id id);\n \n-// Returns information about the variants in a tag.\n fn tag_variants(&ctxt cx, &ast::def_id id) -> vec[variant_info] {\n     if (cx.sess.get_targ_crate_num() != id._0) {\n         ret creader::get_tag_variants(cx, id);"}]}