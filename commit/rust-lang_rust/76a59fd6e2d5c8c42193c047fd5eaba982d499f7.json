{"sha": "76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YTU5ZmQ2ZTJkNWM4YzQyMTkzYzA0N2ZkNWVhYmE5ODJkNDk5Zjc=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-13T06:17:50Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-15T23:13:56Z"}, "message": "std: add an RAII unlocker to Mutex.\n\nThis automatically unlocks its lock when it goes out of scope, and\nprovides a safe(ish) method to call .wait.", "tree": {"sha": "a913c967de98b492f47fdd0bbd5a11cf0be96ed5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a913c967de98b492f47fdd0bbd5a11cf0be96ed5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "html_url": "https://github.com/rust-lang/rust/commit/76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fba32ea79f1828ef441d91abca3635fad57f323d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fba32ea79f1828ef441d91abca3635fad57f323d", "html_url": "https://github.com/rust-lang/rust/commit/fba32ea79f1828ef441d91abca3635fad57f323d"}], "stats": {"total": 228, "additions": 134, "deletions": 94}, "files": [{"sha": "0e8d8ef88e8ffbefd21dc80b73f2faeb9bcb81ed", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "patch": "@@ -669,8 +669,7 @@ impl Scheduler {\n         // is acquired here. This is the resumption points and the \"bounce\"\n         // that it is referring to.\n         unsafe {\n-            current_task.nasty_deschedule_lock.lock();\n-            current_task.nasty_deschedule_lock.unlock();\n+            let _guard = current_task.nasty_deschedule_lock.lock();\n         }\n         return current_task;\n     }\n@@ -766,9 +765,10 @@ impl Scheduler {\n         // unlocked the lock so there's no worry of this memory going away.\n         let cur = self.change_task_context(cur, next, |sched, mut task| {\n             let lock: *mut Mutex = &mut task.nasty_deschedule_lock;\n-            unsafe { (*lock).lock() }\n-            f(sched, BlockedTask::block(task.swap()));\n-            unsafe { (*lock).unlock() }\n+            unsafe {\n+                let _guard = (*lock).lock();\n+                f(sched, BlockedTask::block(task.swap()));\n+            }\n         });\n         cur.put();\n     }\n@@ -1466,12 +1466,11 @@ mod test {\n             let mut handle = pool.spawn_sched();\n             handle.send(PinnedTask(pool.task(TaskOpts::new(), proc() {\n                 unsafe {\n-                    LOCK.lock();\n+                    let mut guard = LOCK.lock();\n \n                     start_ch.send(());\n-                    LOCK.wait();   // block the scheduler thread\n-                    LOCK.signal(); // let them know we have the lock\n-                    LOCK.unlock();\n+                    guard.wait();   // block the scheduler thread\n+                    guard.signal(); // let them know we have the lock\n                 }\n \n                 fin_ch.send(());\n@@ -1503,10 +1502,9 @@ mod test {\n                 child_ch.send(20);\n                 pingpong(&parent_po, &child_ch);\n                 unsafe {\n-                    LOCK.lock();\n-                    LOCK.signal();   // wakeup waiting scheduler\n-                    LOCK.wait();     // wait for them to grab the lock\n-                    LOCK.unlock();\n+                    let mut guard = LOCK.lock();\n+                    guard.signal();   // wakeup waiting scheduler\n+                    guard.wait();     // wait for them to grab the lock\n                 }\n             })));\n             drop(handle);"}, {"sha": "455f7e589e420789ebeb43625d494ca9993ae381", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "patch": "@@ -324,9 +324,8 @@ impl GreenTask {\n         unsafe {\n             let mtx = &mut self.nasty_deschedule_lock as *mut Mutex;\n             let handle = self.handle.get_mut_ref() as *mut SchedHandle;\n-            (*mtx).lock();\n+            let _guard = (*mtx).lock();\n             (*handle).send(RunOnce(self));\n-            (*mtx).unlock();\n         }\n     }\n }"}, {"sha": "e0aaf20e8387583523c486f357ac1ba95e86c5b1", "filename": "src/libnative/bookkeeping.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibnative%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibnative%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fbookkeeping.rs?ref=76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "patch": "@@ -29,9 +29,8 @@ pub fn increment() {\n pub fn decrement() {\n     unsafe {\n         if TASK_COUNT.fetch_sub(1, atomics::SeqCst) == 1 {\n-            TASK_LOCK.lock();\n-            TASK_LOCK.signal();\n-            TASK_LOCK.unlock();\n+            let mut guard = TASK_LOCK.lock();\n+            guard.signal();\n         }\n     }\n }\n@@ -40,11 +39,12 @@ pub fn decrement() {\n /// the entry points of native programs\n pub fn wait_for_other_tasks() {\n     unsafe {\n-        TASK_LOCK.lock();\n-        while TASK_COUNT.load(atomics::SeqCst) > 0 {\n-            TASK_LOCK.wait();\n+        {\n+            let mut guard = TASK_LOCK.lock();\n+            while TASK_COUNT.load(atomics::SeqCst) > 0 {\n+                guard.wait();\n+            }\n         }\n-        TASK_LOCK.unlock();\n         TASK_LOCK.destroy();\n     }\n }"}, {"sha": "1de729aee2ee03e15c440b6388003e4d9944f8be", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "patch": "@@ -222,15 +222,14 @@ pub fn init() {\n         static mut INITIALIZED: bool = false;\n         static mut LOCK: Mutex = MUTEX_INIT;\n \n-        LOCK.lock();\n+        let _guard = LOCK.lock();\n         if !INITIALIZED {\n             let mut data: WSADATA = mem::init();\n             let ret = WSAStartup(0x202,      // version 2.2\n                                  &mut data);\n             assert_eq!(ret, 0);\n             INITIALIZED = true;\n         }\n-        LOCK.unlock();\n     }\n }\n "}, {"sha": "8ddce2c3990493f0b773dd926a466741750fecc3", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "patch": "@@ -41,7 +41,7 @@ pub fn boot(helper: fn(imp::signal, Port<Req>)) {\n     static mut INITIALIZED: bool = false;\n \n     unsafe {\n-        LOCK.lock();\n+        let mut _guard = LOCK.lock();\n         if !INITIALIZED {\n             let (msgp, msgc) = Chan::new();\n             // promote this to a shared channel\n@@ -58,7 +58,6 @@ pub fn boot(helper: fn(imp::signal, Port<Req>)) {\n             rt::at_exit(proc() { shutdown() });\n             INITIALIZED = true;\n         }\n-        LOCK.unlock();\n     }\n }\n "}, {"sha": "d940edcadc72bc6727fc577ca202d2e830114944", "filename": "src/libnative/task.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "patch": "@@ -191,20 +191,19 @@ impl rt::Runtime for Ops {\n             let task = BlockedTask::block(cur_task);\n \n             if times == 1 {\n-                (*me).lock.lock();\n+                let mut guard = (*me).lock.lock();\n                 (*me).awoken = false;\n                 match f(task) {\n                     Ok(()) => {\n                         while !(*me).awoken {\n-                            (*me).lock.wait();\n+                            guard.wait();\n                         }\n                     }\n                     Err(task) => { cast::forget(task.wake()); }\n                 }\n-                (*me).lock.unlock();\n             } else {\n                 let mut iter = task.make_selectable(times);\n-                (*me).lock.lock();\n+                let mut guard = (*me).lock.lock();\n                 (*me).awoken = false;\n                 let success = iter.all(|task| {\n                     match f(task) {\n@@ -216,9 +215,8 @@ impl rt::Runtime for Ops {\n                     }\n                 });\n                 while success && !(*me).awoken {\n-                    (*me).lock.wait();\n+                    guard.wait();\n                 }\n-                (*me).lock.unlock();\n             }\n             // re-acquire ownership of the task\n             cur_task = cast::transmute::<uint, ~Task>(cur_task_dupe);\n@@ -235,10 +233,9 @@ impl rt::Runtime for Ops {\n             let me = &mut *self as *mut Ops;\n             to_wake.put_runtime(self as ~rt::Runtime);\n             cast::forget(to_wake);\n-            (*me).lock.lock();\n+            let mut guard = (*me).lock.lock();\n             (*me).awoken = true;\n-            (*me).lock.signal();\n-            (*me).lock.unlock();\n+            guard.signal();\n         }\n     }\n "}, {"sha": "fcd00b70dd1573dac94af66c2027f5f5606d5971", "filename": "src/libstd/comm/shared.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibstd%2Fcomm%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibstd%2Fcomm%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fshared.rs?ref=76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "patch": "@@ -75,7 +75,7 @@ impl<T: Send> Packet<T> {\n             select_lock: unsafe { Mutex::new() },\n         };\n         // see comments in inherit_blocker about why we grab this lock\n-        unsafe { p.select_lock.lock() }\n+        unsafe { p.select_lock.lock_noguard() }\n         return p;\n     }\n \n@@ -124,7 +124,7 @@ impl<T: Send> Packet<T> {\n         // interfere with this method. After we unlock this lock, we're\n         // signifying that we're done modifying self.cnt and self.to_wake and\n         // the port is ready for the world to continue using it.\n-        unsafe { self.select_lock.unlock() }\n+        unsafe { self.select_lock.unlock_noguard() }\n     }\n \n     pub fn send(&mut self, t: T) -> bool {\n@@ -438,8 +438,7 @@ impl<T: Send> Packet<T> {\n         // about looking at and dealing with to_wake. Once we have acquired the\n         // lock, we are guaranteed that inherit_blocker is done.\n         unsafe {\n-            self.select_lock.lock();\n-            self.select_lock.unlock();\n+            let _guard = self.select_lock.lock();\n         }\n \n         // Like the stream implementation, we want to make sure that the count"}, {"sha": "4a5958c2cfbc46b8a6091ea8227bd4d07c097400", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "patch": "@@ -44,7 +44,6 @@ use ptr;\n use str;\n use str::{Str, StrSlice};\n use fmt;\n-use unstable::finally::Finally;\n use sync::atomics::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n use path::{Path, GenericPath};\n use iter::Iterator;\n@@ -146,15 +145,12 @@ Serialize access through a global lock.\n */\n fn with_env_lock<T>(f: || -> T) -> T {\n     use unstable::mutex::{Mutex, MUTEX_INIT};\n-    use unstable::finally::Finally;\n \n     static mut lock: Mutex = MUTEX_INIT;\n \n     unsafe {\n-        return (|| {\n-            lock.lock();\n-            f()\n-        }).finally(|| lock.unlock());\n+        let _guard = lock.lock();\n+        f()\n     }\n }\n "}, {"sha": "c91797c9559cf66b78b5c473880f5defbd84c19b", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "patch": "@@ -68,7 +68,6 @@ mod imp {\n     use option::{Option, Some, None};\n     use ptr::RawPtr;\n     use iter::Iterator;\n-    use unstable::finally::Finally;\n     use unstable::mutex::{Mutex, MUTEX_INIT};\n     use mem;\n \n@@ -111,16 +110,10 @@ mod imp {\n     }\n \n     fn with_lock<T>(f: || -> T) -> T {\n-        (|| {\n-            unsafe {\n-                lock.lock();\n-                f()\n-            }\n-        }).finally(|| {\n-            unsafe {\n-                lock.unlock();\n-            }\n-        })\n+        unsafe {\n+            let _guard = lock.lock();\n+            f()\n+        }\n     }\n \n     fn get_global_ptr() -> *mut Option<~~[~[u8]]> {"}, {"sha": "4828c4ee5af525347b5163e65bb206417cbe11c8", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "patch": "@@ -157,7 +157,7 @@ pub mod dl {\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence\n-            lock.lock();\n+            let _guard = lock.lock();\n             let _old_error = dlerror();\n \n             let result = f();\n@@ -168,7 +168,7 @@ pub mod dl {\n             } else {\n                 Err(str::raw::from_c_str(last_error))\n             };\n-            lock.unlock();\n+\n             ret\n         }\n     }"}, {"sha": "2fa7fbeab4e293390b19da0864252b74d7e81726", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 88, "deletions": 16, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "patch": "@@ -47,10 +47,24 @@\n \n #[allow(non_camel_case_types)];\n \n+use option::{Option, None, Some};\n+use ops::Drop;\n+\n pub struct Mutex {\n     priv inner: imp::Mutex,\n }\n \n+/// Automatically unlocks the mutex that it was created from on\n+/// destruction.\n+///\n+/// Using this makes lock-based code resilient to unwinding/task\n+/// failure, because the lock will be automatically unlocked even\n+/// then.\n+#[must_use]\n+pub struct LockGuard<'a> {\n+    priv lock: &'a mut Mutex\n+}\n+\n pub static MUTEX_INIT: Mutex = Mutex {\n     inner: imp::MUTEX_INIT,\n };\n@@ -63,30 +77,88 @@ impl Mutex {\n \n     /// Acquires this lock. This assumes that the current thread does not\n     /// already hold the lock.\n-    pub unsafe fn lock(&mut self) { self.inner.lock() }\n+    ///\n+    /// # Example\n+    /// ```\n+    /// use std::unstable::mutex::Mutex;\n+    /// unsafe {\n+    ///     let mut lock = Mutex::new();\n+    ///\n+    ///     {\n+    ///         let _guard = lock.lock();\n+    ///         // critical section...\n+    ///     } // automatically unlocked in `_guard`'s destructor\n+    /// }\n+    /// ```\n+    pub unsafe fn lock<'a>(&'a mut self) -> LockGuard<'a> {\n+        self.inner.lock();\n+\n+        LockGuard { lock: self }\n+    }\n \n-    /// Attempts to acquire the lock. The value returned is whether the lock was\n-    /// acquired or not\n-    pub unsafe fn trylock(&mut self) -> bool { self.inner.trylock() }\n+    /// Attempts to acquire the lock. The value returned is `Some` if\n+    /// the attempt succeeded.\n+    pub unsafe fn trylock<'a>(&'a mut self) -> Option<LockGuard<'a>> {\n+        if self.inner.trylock() {\n+            Some(LockGuard { lock: self })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Acquire the lock without creating a `LockGuard`.\n+    ///\n+    /// Prefer using `.lock`.\n+    pub unsafe fn lock_noguard(&mut self) { self.inner.lock() }\n+\n+    /// Attempts to acquire the lock without creating a\n+    /// `LockGuard`. The value returned is whether the lock was\n+    /// acquired or not.\n+    ///\n+    /// Prefer using `.trylock`.\n+    pub unsafe fn trylock_noguard(&mut self) -> bool {\n+        self.inner.trylock()\n+    }\n \n     /// Unlocks the lock. This assumes that the current thread already holds the\n     /// lock.\n-    pub unsafe fn unlock(&mut self) { self.inner.unlock() }\n+    pub unsafe fn unlock_noguard(&mut self) { self.inner.unlock() }\n \n     /// Block on the internal condition variable.\n     ///\n-    /// This function assumes that the lock is already held\n-    pub unsafe fn wait(&mut self) { self.inner.wait() }\n+    /// This function assumes that the lock is already held. Prefer\n+    /// using `LockGuard.wait` since that guarantees that the lock is\n+    /// held.\n+    pub unsafe fn wait_noguard(&mut self) { self.inner.wait() }\n \n     /// Signals a thread in `wait` to wake up\n-    pub unsafe fn signal(&mut self) { self.inner.signal() }\n+    pub unsafe fn signal_noguard(&mut self) { self.inner.signal() }\n \n     /// This function is especially unsafe because there are no guarantees made\n     /// that no other thread is currently holding the lock or waiting on the\n     /// condition variable contained inside.\n     pub unsafe fn destroy(&mut self) { self.inner.destroy() }\n }\n \n+impl<'a> LockGuard<'a> {\n+    /// Block on the internal condition variable.\n+    pub unsafe fn wait(&mut self) {\n+        self.lock.wait_noguard()\n+    }\n+\n+    /// Signals a thread in `wait` to wake up.\n+    pub unsafe fn signal(&mut self) {\n+        self.lock.signal_noguard()\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for LockGuard<'a> {\n+    fn drop(&mut self) {\n+        unsafe {self.lock.unlock_noguard()}\n+    }\n+}\n+\n #[cfg(unix)]\n mod imp {\n     use libc;\n@@ -382,30 +454,30 @@ mod imp {\n mod test {\n     use prelude::*;\n \n+    use mem::drop;\n     use super::{Mutex, MUTEX_INIT};\n     use rt::thread::Thread;\n \n     #[test]\n     fn somke_lock() {\n         static mut lock: Mutex = MUTEX_INIT;\n         unsafe {\n-            lock.lock();\n-            lock.unlock();\n+            let _guard = lock.lock();\n         }\n     }\n \n     #[test]\n     fn somke_cond() {\n         static mut lock: Mutex = MUTEX_INIT;\n         unsafe {\n-            lock.lock();\n+            let mut guard = lock.lock();\n             let t = Thread::start(proc() {\n-                lock.lock();\n-                lock.signal();\n-                lock.unlock();\n+                let mut guard = lock.lock();\n+                guard.signal();\n             });\n-            lock.wait();\n-            lock.unlock();\n+            guard.wait();\n+            drop(guard);\n+\n             t.join();\n         }\n     }"}, {"sha": "343eacbf4297ff22b41650a1321b79cb4258348a", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "patch": "@@ -11,16 +11,16 @@\n use clone::Clone;\n use kinds::Send;\n use ops::Drop;\n-use option::{Option,Some,None};\n+use option::Option;\n use sync::arc::UnsafeArc;\n-use unstable::mutex::Mutex;\n+use unstable::mutex::{Mutex, LockGuard};\n \n pub struct LittleLock {\n     priv l: Mutex,\n }\n \n pub struct LittleGuard<'a> {\n-    priv l: &'a mut Mutex,\n+    priv l: LockGuard<'a>\n }\n \n impl Drop for LittleLock {\n@@ -29,33 +29,21 @@ impl Drop for LittleLock {\n     }\n }\n \n-#[unsafe_destructor]\n-impl<'a> Drop for LittleGuard<'a> {\n-    fn drop(&mut self) {\n-        unsafe { self.l.unlock(); }\n-    }\n-}\n-\n impl LittleLock {\n     pub fn new() -> LittleLock {\n         unsafe { LittleLock { l: Mutex::new() } }\n     }\n \n     pub unsafe fn lock<'a>(&'a mut self) -> LittleGuard<'a> {\n-        self.l.lock();\n-        LittleGuard { l: &mut self.l }\n+        LittleGuard { l: self.l.lock() }\n     }\n \n     pub unsafe fn try_lock<'a>(&'a mut self) -> Option<LittleGuard<'a>> {\n-        if self.l.trylock() {\n-            Some(LittleGuard { l: &mut self.l })\n-        } else {\n-            None\n-        }\n+        self.l.trylock().map(|guard| LittleGuard { l: guard })\n     }\n \n     pub unsafe fn signal(&mut self) {\n-        self.l.signal();\n+        self.l.signal_noguard();\n     }\n }\n "}, {"sha": "f5914b26e858d61103f90014732b082560c58639", "filename": "src/libsync/sync/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibsync%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76a59fd6e2d5c8c42193c047fd5eaba982d499f7/src%2Flibsync%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fsync%2Fmutex.rs?ref=76a59fd6e2d5c8c42193c047fd5eaba982d499f7", "patch": "@@ -288,11 +288,11 @@ impl StaticMutex {\n     // `lock()` function on an OS mutex\n     fn native_lock(&mut self, t: ~Task) {\n         Local::put(t);\n-        unsafe { self.lock.lock(); }\n+        unsafe { self.lock.lock_noguard(); }\n     }\n \n     fn native_unlock(&mut self) {\n-        unsafe { self.lock.unlock(); }\n+        unsafe { self.lock.unlock_noguard(); }\n     }\n \n     fn green_lock(&mut self, t: ~Task) {"}]}