{"sha": "1c296d54e3dcc36c1a778873f26035000a352ba2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMjk2ZDU0ZTNkY2MzNmMxYTc3ODg3M2YyNjAzNTAwMGEzNTJiYTI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-19T18:03:36Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-19T18:03:36Z"}, "message": "Merge #576\n\n576: Beginnings of generics r=matklad a=flodiebold\n\nThis implements the beginnings of the generics infrastructure; generic parameters for structs work and are correctly substituted in fields. Functions and methods aren't handled at all yet (as the tests show).\r\n\r\nThe name resolution in `ty` really needs refactoring now, I hope to do that next ;)\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "0a6ce660ee32080287284c93bffaaaada91f3584", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a6ce660ee32080287284c93bffaaaada91f3584"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c296d54e3dcc36c1a778873f26035000a352ba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c296d54e3dcc36c1a778873f26035000a352ba2", "html_url": "https://github.com/rust-lang/rust/commit/1c296d54e3dcc36c1a778873f26035000a352ba2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c296d54e3dcc36c1a778873f26035000a352ba2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "bade91db081a3465dea3547ab8ab669f78fde9dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/bade91db081a3465dea3547ab8ab669f78fde9dc", "html_url": "https://github.com/rust-lang/rust/commit/bade91db081a3465dea3547ab8ab669f78fde9dc"}, {"sha": "5f3509e140d19b989db418a00ac6778c622cde5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f3509e140d19b989db418a00ac6778c622cde5d", "html_url": "https://github.com/rust-lang/rust/commit/5f3509e140d19b989db418a00ac6778c622cde5d"}], "stats": {"total": 902, "additions": 805, "deletions": 97}, "files": [{"sha": "ab1c428db7ebee53945e08c60508f3343cdaa8d1", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -1,3 +1,6 @@\n+//! This module contains the implementation details of the HIR for ADTs, i.e.\n+//! structs and enums (and unions).\n+\n use std::sync::Arc;\n \n use ra_syntax::{\n@@ -62,7 +65,7 @@ fn get_def_id(\n     };\n     let loc = DefLoc {\n         kind: expected_kind,\n-        source_item_id: source_item_id,\n+        source_item_id,\n         ..*same_file_loc\n     };\n     loc.id(db)"}, {"sha": "88eda5ed0fd31088e856df08bda0b4e239d88d83", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -12,6 +12,7 @@ use crate::{\n     expr::BodySyntaxMapping,\n     ty::InferenceResult,\n     adt::VariantData,\n+    generics::GenericParams,\n     code_model_impl::def_id_to_ast,\n };\n \n@@ -201,6 +202,10 @@ impl Struct {\n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::StructDef>) {\n         def_id_to_ast(db, self.def_id)\n     }\n+\n+    pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n+        db.generic_params(self.def_id)\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -228,6 +233,10 @@ impl Enum {\n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::EnumDef>) {\n         def_id_to_ast(db, self.def_id)\n     }\n+\n+    pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n+        db.generic_params(self.def_id)\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -339,6 +348,10 @@ impl Function {\n     pub fn infer(&self, db: &impl HirDatabase) -> Arc<InferenceResult> {\n         db.infer(self.def_id)\n     }\n+\n+    pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n+        db.generic_params(self.def_id)\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -384,6 +397,10 @@ impl Trait {\n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::TraitDef>) {\n         def_id_to_ast(db, self.def_id)\n     }\n+\n+    pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n+        db.generic_params(self.def_id)\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -399,4 +416,8 @@ impl Type {\n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::TypeDef>) {\n         def_id_to_ast(db, self.def_id)\n     }\n+\n+    pub fn generic_params(&self, db: &impl HirDatabase) -> Arc<GenericParams> {\n+        db.generic_params(self.def_id)\n+    }\n }"}, {"sha": "73c212de8c343a101a8b6eb8e5e394d90f3ba3f0", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -95,15 +95,15 @@ impl Module {\n     }\n \n     /// Finds a child module with the specified name.\n-    pub fn child_impl(&self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n+    pub(crate) fn child_impl(&self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id);\n         let child_id = loc.module_id.child(&module_tree, name)?;\n         Some(Module::from_module_id(db, loc.source_root_id, child_id))\n     }\n \n     /// Iterates over all child modules.\n-    pub fn children_impl(&self, db: &impl HirDatabase) -> impl Iterator<Item = Module> {\n+    pub(crate) fn children_impl(&self, db: &impl HirDatabase) -> impl Iterator<Item = Module> {\n         // FIXME this should be implementable without collecting into a vec, but\n         // it's kind of hard since the iterator needs to keep a reference to the\n         // module tree.\n@@ -117,21 +117,21 @@ impl Module {\n         children.into_iter()\n     }\n \n-    pub fn parent_impl(&self, db: &impl HirDatabase) -> Option<Module> {\n+    pub(crate) fn parent_impl(&self, db: &impl HirDatabase) -> Option<Module> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id);\n         let parent_id = loc.module_id.parent(&module_tree)?;\n         Some(Module::from_module_id(db, loc.source_root_id, parent_id))\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope_impl(&self, db: &impl HirDatabase) -> ModuleScope {\n+    pub(crate) fn scope_impl(&self, db: &impl HirDatabase) -> ModuleScope {\n         let loc = self.def_id.loc(db);\n         let item_map = db.item_map(loc.source_root_id);\n         item_map.per_module[&loc.module_id].clone()\n     }\n \n-    pub fn resolve_path_impl(&self, db: &impl HirDatabase, path: &Path) -> PerNs<DefId> {\n+    pub(crate) fn resolve_path_impl(&self, db: &impl HirDatabase, path: &Path) -> PerNs<DefId> {\n         let mut curr_per_ns = PerNs::types(\n             match path.kind {\n                 PathKind::Crate => self.crate_root(db),\n@@ -147,7 +147,7 @@ impl Module {\n             .def_id,\n         );\n \n-        for name in path.segments.iter() {\n+        for segment in path.segments.iter() {\n             let curr = match curr_per_ns.as_ref().take_types() {\n                 Some(r) => r,\n                 None => {\n@@ -163,15 +163,17 @@ impl Module {\n             curr_per_ns = match curr.resolve(db) {\n                 Def::Module(m) => {\n                     let scope = m.scope(db);\n-                    match scope.get(&name) {\n+                    match scope.get(&segment.name) {\n                         Some(r) => r.def_id,\n                         None => PerNs::none(),\n                     }\n                 }\n                 Def::Enum(e) => {\n                     // enum variant\n-                    let matching_variant =\n-                        e.variants(db).into_iter().find(|(n, _variant)| n == name);\n+                    let matching_variant = e\n+                        .variants(db)\n+                        .into_iter()\n+                        .find(|(n, _variant)| n == &segment.name);\n \n                     match matching_variant {\n                         Some((_n, variant)) => PerNs::both(variant.def_id(), e.def_id()),\n@@ -189,7 +191,10 @@ impl Module {\n         curr_per_ns\n     }\n \n-    pub fn problems_impl(&self, db: &impl HirDatabase) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n+    pub(crate) fn problems_impl(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id);\n         loc.module_id.problems(&module_tree, db)"}, {"sha": "f383701d7710d298a1959b7253e8929a266b90d6", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -14,6 +14,7 @@ use crate::{\n     ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks},\n     adt::{StructData, EnumData, EnumVariantData},\n     impl_block::ModuleImplBlocks,\n+    generics::GenericParams,\n };\n \n #[salsa::query_group]\n@@ -101,6 +102,9 @@ pub trait HirDatabase:\n     #[salsa::invoke(crate::expr::body_syntax_mapping)]\n     fn body_syntax_mapping(&self, def_id: DefId) -> Arc<crate::expr::BodySyntaxMapping>;\n \n+    #[salsa::invoke(crate::generics::GenericParams::generic_params_query)]\n+    fn generic_params(&self, def_id: DefId) -> Arc<GenericParams>;\n+\n     #[salsa::invoke(crate::FnSignature::fn_signature_query)]\n     fn fn_signature(&self, def_id: DefId) -> Arc<FnSignature>;\n }"}, {"sha": "d8248ad4917ddcff0f8195ec2286333d535693fb", "filename": "crates/ra_hir/src/generics.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -0,0 +1,48 @@\n+//! Many kinds of items or constructs can have generic parameters: functions,\n+//! structs, impls, traits, etc. This module provides a common HIR for these\n+//! generic parameters. See also the `Generics` type and the `generics_of` query\n+//! in rustc.\n+\n+use std::sync::Arc;\n+\n+use ra_syntax::ast::{TypeParamList, AstNode, NameOwner};\n+\n+use crate::{db::HirDatabase, DefId, Name, AsName};\n+\n+/// Data about a generic parameter (to a function, struct, impl, ...).\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct GenericParam {\n+    pub(crate) idx: u32,\n+    pub(crate) name: Name,\n+}\n+\n+/// Data about the generic parameters of a function, struct, impl, etc.\n+#[derive(Clone, PartialEq, Eq, Debug, Default)]\n+pub struct GenericParams {\n+    pub(crate) params: Vec<GenericParam>,\n+}\n+\n+impl GenericParams {\n+    pub(crate) fn generic_params_query(db: &impl HirDatabase, def_id: DefId) -> Arc<GenericParams> {\n+        let (_file_id, node) = def_id.source(db);\n+        let mut generics = GenericParams::default();\n+        if let Some(type_param_list) = node.children().find_map(TypeParamList::cast) {\n+            for (idx, type_param) in type_param_list.type_params().enumerate() {\n+                let name = type_param\n+                    .name()\n+                    .map(AsName::as_name)\n+                    .unwrap_or_else(Name::missing);\n+                let param = GenericParam {\n+                    idx: idx as u32,\n+                    name,\n+                };\n+                generics.params.push(param);\n+            }\n+        }\n+        Arc::new(generics)\n+    }\n+\n+    pub(crate) fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {\n+        self.params.iter().find(|p| &p.name == name)\n+    }\n+}"}, {"sha": "c5408e277e8a913d6dbfaca3e780df99afa394d0", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -151,6 +151,15 @@ pub(crate) enum DefKind {\n     Type,\n     Item,\n \n+    /// The constructor of a struct. E.g. if we have `struct Foo(usize)`, the\n+    /// name `Foo` needs to resolve to different types depending on whether we\n+    /// are in the types or values namespace: As a type, `Foo` of course refers\n+    /// to the struct `Foo`; as a value, `Foo` is a callable type with signature\n+    /// `(usize) -> Foo`. The cleanest approach to handle this seems to be to\n+    /// have different defs in the two namespaces.\n+    ///\n+    /// rustc does the same; note that it even creates a struct constructor if\n+    /// the struct isn't a tuple struct (see `CtorKind::Fictive` in rustc).\n     StructCtor,\n }\n "}, {"sha": "361d39f03e828a9e9ce3ffc2ad8561aebbca4c9f", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -24,6 +24,7 @@ mod type_ref;\n mod ty;\n mod impl_block;\n mod expr;\n+mod generics;\n \n mod code_model_api;\n mod code_model_impl;"}, {"sha": "6e6f2f04bd21fb0c229be1ca1178d38a28258d29", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -243,6 +243,7 @@ salsa::database_storage! {\n             fn body_hir() for db::BodyHirQuery;\n             fn body_syntax_mapping() for db::BodySyntaxMappingQuery;\n             fn fn_signature() for db::FnSignatureQuery;\n+            fn generic_params() for db::GenericParamsQuery;\n         }\n     }\n }"}, {"sha": "4874e82f31ac7a899656bba73c5fb88d0b00c61a", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -221,10 +221,10 @@ where\n             };\n         }\n         for (import_id, import_data) in input.imports.iter() {\n-            if let Some(name) = import_data.path.segments.iter().last() {\n+            if let Some(segment) = import_data.path.segments.iter().last() {\n                 if !import_data.is_glob {\n                     module_items.items.insert(\n-                        name.clone(),\n+                        segment.name.clone(),\n                         Resolution {\n                             def_id: PerNs::none(),\n                             import: Some(import_id),\n@@ -319,13 +319,13 @@ where\n             PathKind::Crate => module_id.crate_root(&self.module_tree),\n         };\n \n-        for (i, name) in import.path.segments.iter().enumerate() {\n+        for (i, segment) in import.path.segments.iter().enumerate() {\n             let is_last = i == import.path.segments.len() - 1;\n \n-            let def_id = match self.result.per_module[&curr].items.get(name) {\n+            let def_id = match self.result.per_module[&curr].items.get(&segment.name) {\n                 Some(res) if !res.def_id.is_none() => res.def_id,\n                 _ => {\n-                    log::debug!(\"path segment {:?} not found\", name);\n+                    log::debug!(\"path segment {:?} not found\", segment.name);\n                     return false;\n                 }\n             };\n@@ -336,7 +336,7 @@ where\n                 } else {\n                     log::debug!(\n                         \"path segment {:?} resolved to value only, but is not last\",\n-                        name\n+                        segment.name\n                     );\n                     return false;\n                 };\n@@ -358,17 +358,17 @@ where\n                             log::debug!(\"resolving {:?} in other source root\", path);\n                             let def_id = module.resolve_path(self.db, &path);\n                             if !def_id.is_none() {\n-                                let name = path.segments.last().unwrap();\n+                                let last_segment = path.segments.last().unwrap();\n                                 self.update(module_id, |items| {\n                                     let res = Resolution {\n                                         def_id,\n                                         import: Some(import_id),\n                                     };\n-                                    items.items.insert(name.clone(), res);\n+                                    items.items.insert(last_segment.name.clone(), res);\n                                 });\n                                 log::debug!(\n                                     \"resolved import {:?} ({:?}) cross-source root to {:?}\",\n-                                    name,\n+                                    last_segment.name,\n                                     import,\n                                     def_id.map(|did| did.loc(self.db))\n                                 );\n@@ -382,7 +382,7 @@ where\n                     _ => {\n                         log::debug!(\n                             \"path segment {:?} resolved to non-module {:?}, but is not last\",\n-                            name,\n+                            segment.name,\n                             type_def_id.loc(self.db)\n                         );\n                         return true; // this resolved to a non-module, so the path won't ever resolve\n@@ -391,7 +391,7 @@ where\n             } else {\n                 log::debug!(\n                     \"resolved import {:?} ({:?}) within source root to {:?}\",\n-                    name,\n+                    segment.name,\n                     import,\n                     def_id.map(|did| did.loc(self.db))\n                 );\n@@ -400,7 +400,7 @@ where\n                         def_id,\n                         import: Some(import_id),\n                     };\n-                    items.items.insert(name.clone(), res);\n+                    items.items.insert(segment.name.clone(), res);\n                 })\n             }\n         }"}, {"sha": "c3d14c689d96e148dddc7bbf387521d1de240aeb", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -1,11 +1,35 @@\n+use std::sync::Arc;\n+\n use ra_syntax::{ast, AstNode};\n \n-use crate::{Name, AsName};\n+use crate::{Name, AsName, type_ref::TypeRef};\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     pub kind: PathKind,\n-    pub segments: Vec<Name>,\n+    pub segments: Vec<PathSegment>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct PathSegment {\n+    pub name: Name,\n+    pub args_and_bindings: Option<Arc<GenericArgs>>,\n+}\n+\n+/// Generic arguments to a path segment (e.g. the `i32` in `Option<i32>`). This\n+/// can (in the future) also include bindings of associated types, like in\n+/// `Iterator<Item = Foo>`.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct GenericArgs {\n+    pub args: Vec<GenericArg>,\n+    // someday also bindings\n+}\n+\n+/// A single generic argument.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum GenericArg {\n+    Type(TypeRef),\n+    // or lifetime...\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -34,7 +58,17 @@ impl Path {\n         loop {\n             let segment = path.segment()?;\n             match segment.kind()? {\n-                ast::PathSegmentKind::Name(name) => segments.push(name.as_name()),\n+                ast::PathSegmentKind::Name(name) => {\n+                    let args = segment\n+                        .type_arg_list()\n+                        .and_then(GenericArgs::from_ast)\n+                        .map(Arc::new);\n+                    let segment = PathSegment {\n+                        name: name.as_name(),\n+                        args_and_bindings: args,\n+                    };\n+                    segments.push(segment);\n+                }\n                 ast::PathSegmentKind::CrateKw => {\n                     kind = PathKind::Crate;\n                     break;\n@@ -88,15 +122,34 @@ impl Path {\n         if self.kind != PathKind::Plain || self.segments.len() > 1 {\n             return None;\n         }\n-        self.segments.first()\n+        self.segments.first().map(|s| &s.name)\n+    }\n+}\n+\n+impl GenericArgs {\n+    fn from_ast(node: &ast::TypeArgList) -> Option<GenericArgs> {\n+        let mut args = Vec::new();\n+        for type_arg in node.type_args() {\n+            let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n+            args.push(GenericArg::Type(type_ref));\n+        }\n+        // lifetimes and assoc type args ignored for now\n+        if args.len() > 0 {\n+            Some(GenericArgs { args })\n+        } else {\n+            None\n+        }\n     }\n }\n \n impl From<Name> for Path {\n     fn from(name: Name) -> Path {\n         Path {\n             kind: PathKind::Plain,\n-            segments: vec![name],\n+            segments: vec![PathSegment {\n+                name,\n+                args_and_bindings: None,\n+            }],\n         }\n     }\n }\n@@ -160,7 +213,10 @@ fn convert_path(prefix: Option<Path>, path: &ast::Path) -> Option<Path> {\n                 kind: PathKind::Plain,\n                 segments: Vec::with_capacity(1),\n             });\n-            res.segments.push(name.as_name());\n+            res.segments.push(PathSegment {\n+                name: name.as_name(),\n+                args_and_bindings: None, // no type args in use\n+            });\n             res\n         }\n         ast::PathSegmentKind::CrateKw => {"}, {"sha": "9b71824859c4820949d584e5ce2482f659f81f75", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 308, "deletions": 62, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -37,6 +37,8 @@ use crate::{\n     type_ref::{TypeRef, Mutability},\n     name::KnownName,\n     expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat},\n+    generics::GenericParams,\n+    path::GenericArg,\n };\n \n /// The ID of a type variable.\n@@ -151,10 +153,20 @@ impl Expectation {\n     }\n }\n \n+/// A list of substitutions for generic parameters.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct Substs(Arc<[Ty]>);\n+\n+impl Substs {\n+    pub fn empty() -> Substs {\n+        Substs(Arc::new([]))\n+    }\n+}\n+\n /// A type. This is based on the `TyKind` enum in rustc (librustc/ty/sty.rs).\n ///\n /// This should be cheap to clone.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub enum Ty {\n     /// The primitive boolean type. Written as `bool`.\n     Bool,\n@@ -175,7 +187,8 @@ pub enum Ty {\n         def_id: DefId,\n         /// The name, for displaying.\n         name: Name,\n-        // later we'll need generic substitutions here\n+        /// Substitutions for the generic parameters of the type.\n+        substs: Substs,\n     },\n \n     /// The pointee of a string slice. Written as `str`.\n@@ -234,9 +247,15 @@ pub enum Ty {\n \n     // Opaque (`impl Trait`) type found in a return type.\n     // Opaque(DefId, Substs),\n+    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n+    Param {\n+        /// The index of the parameter (starting with parameters from the\n+        /// surrounding impl, then the current function).\n+        idx: u32,\n+        /// The name of the parameter, for displaying.\n+        name: Name,\n+    },\n \n-    // A type parameter; for example, `T` in `fn f<T>(x: T) {}\n-    // Param(ParamTy),\n     /// A type variable used during type checking. Not to be confused with a\n     /// type parameter.\n     Infer(InferTy),\n@@ -250,7 +269,7 @@ pub enum Ty {\n }\n \n /// A function signature.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub struct FnSig {\n     input: Vec<Ty>,\n     output: Ty,\n@@ -259,41 +278,45 @@ pub struct FnSig {\n impl Ty {\n     pub(crate) fn from_hir(\n         db: &impl HirDatabase,\n+        // TODO: the next three parameters basically describe the scope for name\n+        // resolution; this should be refactored into something like a general\n+        // resolver architecture\n         module: &Module,\n         impl_block: Option<&ImplBlock>,\n+        generics: &GenericParams,\n         type_ref: &TypeRef,\n     ) -> Self {\n         match type_ref {\n             TypeRef::Never => Ty::Never,\n             TypeRef::Tuple(inner) => {\n                 let inner_tys = inner\n                     .iter()\n-                    .map(|tr| Ty::from_hir(db, module, impl_block, tr))\n+                    .map(|tr| Ty::from_hir(db, module, impl_block, generics, tr))\n                     .collect::<Vec<_>>();\n                 Ty::Tuple(inner_tys.into())\n             }\n-            TypeRef::Path(path) => Ty::from_hir_path(db, module, impl_block, path),\n+            TypeRef::Path(path) => Ty::from_hir_path(db, module, impl_block, generics, path),\n             TypeRef::RawPtr(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, inner);\n+                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n                 Ty::RawPtr(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Array(inner) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, inner);\n+                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n                 Ty::Array(Arc::new(inner_ty))\n             }\n             TypeRef::Slice(inner) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, inner);\n+                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n                 Ty::Slice(Arc::new(inner_ty))\n             }\n             TypeRef::Reference(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, inner);\n+                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n                 Ty::Ref(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n                 let mut inner_tys = params\n                     .iter()\n-                    .map(|tr| Ty::from_hir(db, module, impl_block, tr))\n+                    .map(|tr| Ty::from_hir(db, module, impl_block, generics, tr))\n                     .collect::<Vec<_>>();\n                 let return_ty = inner_tys\n                     .pop()\n@@ -312,15 +335,19 @@ impl Ty {\n         db: &impl HirDatabase,\n         module: &Module,\n         impl_block: Option<&ImplBlock>,\n+        generics: &GenericParams,\n         type_ref: Option<&TypeRef>,\n     ) -> Self {\n-        type_ref.map_or(Ty::Unknown, |t| Ty::from_hir(db, module, impl_block, t))\n+        type_ref.map_or(Ty::Unknown, |t| {\n+            Ty::from_hir(db, module, impl_block, generics, t)\n+        })\n     }\n \n     pub(crate) fn from_hir_path(\n         db: &impl HirDatabase,\n         module: &Module,\n         impl_block: Option<&ImplBlock>,\n+        generics: &GenericParams,\n         path: &Path,\n     ) -> Self {\n         if let Some(name) = path.as_ident() {\n@@ -329,24 +356,105 @@ impl Ty {\n             } else if let Some(float_ty) = primitive::UncertainFloatTy::from_name(name) {\n                 return Ty::Float(float_ty);\n             } else if name.as_known_name() == Some(KnownName::SelfType) {\n-                return Ty::from_hir_opt(db, module, None, impl_block.map(|i| i.target_type()));\n+                // TODO pass the impl block's generics?\n+                let generics = &GenericParams::default();\n+                return Ty::from_hir_opt(\n+                    db,\n+                    module,\n+                    None,\n+                    generics,\n+                    impl_block.map(|i| i.target_type()),\n+                );\n             } else if let Some(known) = name.as_known_name() {\n                 match known {\n                     KnownName::Bool => return Ty::Bool,\n                     KnownName::Char => return Ty::Char,\n                     KnownName::Str => return Ty::Str,\n                     _ => {}\n                 }\n+            } else if let Some(generic_param) = generics.find_by_name(&name) {\n+                return Ty::Param {\n+                    idx: generic_param.idx,\n+                    name: generic_param.name.clone(),\n+                };\n             }\n         }\n \n         // Resolve in module (in type namespace)\n-        let resolved = if let Some(r) = module.resolve_path(db, path).take_types() {\n-            r\n-        } else {\n-            return Ty::Unknown;\n+        let resolved = match module.resolve_path(db, path).take_types() {\n+            Some(r) => r,\n+            None => return Ty::Unknown,\n         };\n-        db.type_for_def(resolved)\n+        let ty = db.type_for_def(resolved);\n+        let substs = Ty::substs_from_path(db, module, impl_block, generics, path, resolved);\n+        ty.apply_substs(substs)\n+    }\n+\n+    /// Collect generic arguments from a path into a `Substs`. See also\n+    /// `create_substs_for_ast_path` and `def_to_ty` in rustc.\n+    fn substs_from_path(\n+        db: &impl HirDatabase,\n+        // the scope of the segment...\n+        module: &Module,\n+        impl_block: Option<&ImplBlock>,\n+        outer_generics: &GenericParams,\n+        path: &Path,\n+        resolved: DefId,\n+    ) -> Substs {\n+        let mut substs = Vec::new();\n+        let def = resolved.resolve(db);\n+        let last = path\n+            .segments\n+            .last()\n+            .expect(\"path should have at least one segment\");\n+        let (def_generics, segment) = match def {\n+            Def::Struct(s) => (s.generic_params(db), last),\n+            Def::Enum(e) => (e.generic_params(db), last),\n+            Def::Function(f) => (f.generic_params(db), last),\n+            Def::Trait(t) => (t.generic_params(db), last),\n+            Def::EnumVariant(ev) => {\n+                // the generic args for an enum variant may be either specified\n+                // on the segment referring to the enum, or on the segment\n+                // referring to the variant. So `Option::<T>::None` and\n+                // `Option::None::<T>` are both allowed (though the former is\n+                // preferred). See also `def_ids_for_path_segments` in rustc.\n+                let len = path.segments.len();\n+                let segment = if len >= 2 && path.segments[len - 2].args_and_bindings.is_some() {\n+                    // Option::<T>::None\n+                    &path.segments[len - 2]\n+                } else {\n+                    // Option::None::<T>\n+                    last\n+                };\n+                (ev.parent_enum(db).generic_params(db), segment)\n+            }\n+            _ => return Substs::empty(),\n+        };\n+        // substs_from_path\n+        if let Some(generic_args) = &segment.args_and_bindings {\n+            // if args are provided, it should be all of them, but we can't rely on that\n+            let param_count = def_generics.params.len();\n+            for arg in generic_args.args.iter().take(param_count) {\n+                match arg {\n+                    GenericArg::Type(type_ref) => {\n+                        let ty = Ty::from_hir(db, module, impl_block, outer_generics, type_ref);\n+                        substs.push(ty);\n+                    }\n+                }\n+            }\n+        }\n+        // add placeholders for args that were not provided\n+        // TODO: handle defaults\n+        for _ in segment\n+            .args_and_bindings\n+            .as_ref()\n+            .map(|ga| ga.args.len())\n+            .unwrap_or(0)..def_generics.params.len()\n+        {\n+            substs.push(Ty::Unknown);\n+        }\n+        assert_eq!(substs.len(), def_generics.params.len());\n+        Substs(substs.into())\n     }\n \n     pub fn unit() -> Self {\n@@ -374,7 +482,14 @@ impl Ty {\n                 }\n                 sig_mut.output.walk_mut(f);\n             }\n-            Ty::Adt { .. } => {} // need to walk type parameters later\n+            Ty::Adt { substs, .. } => {\n+                // Without an Arc::make_mut_slice, we can't avoid the clone here:\n+                let mut v: Vec<_> = substs.0.iter().cloned().collect();\n+                for t in &mut v {\n+                    t.walk_mut(f);\n+                }\n+                substs.0 = v.into();\n+            }\n             _ => {}\n         }\n     }\n@@ -394,6 +509,49 @@ impl Ty {\n             _ => None,\n         }\n     }\n+\n+    /// If this is a type with type parameters (an ADT or function), replaces\n+    /// the `Substs` for these type parameters with the given ones. (So e.g. if\n+    /// `self` is `Option<_>` and the substs contain `u32`, we'll have\n+    /// `Option<u32>` afterwards.)\n+    pub fn apply_substs(self, substs: Substs) -> Ty {\n+        match self {\n+            Ty::Adt { def_id, name, .. } => Ty::Adt {\n+                def_id,\n+                name,\n+                substs,\n+            },\n+            _ => self,\n+        }\n+    }\n+\n+    /// Replaces type parameters in this type using the given `Substs`. (So e.g.\n+    /// if `self` is `&[T]`, where type parameter T has index 0, and the\n+    /// `Substs` contain `u32` at index 0, we'll have `&[u32]` afterwards.)\n+    pub fn subst(self, substs: &Substs) -> Ty {\n+        self.fold(&mut |ty| match ty {\n+            Ty::Param { idx, name } => {\n+                if (idx as usize) < substs.0.len() {\n+                    substs.0[idx as usize].clone()\n+                } else {\n+                    // TODO: does this indicate a bug? i.e. should we always\n+                    // have substs for all type params? (they might contain the\n+                    // params themselves again...)\n+                    Ty::Param { idx, name }\n+                }\n+            }\n+            ty => ty,\n+        })\n+    }\n+\n+    /// Returns the type parameters of this type if it has some (i.e. is an ADT\n+    /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n+    fn substs(&self) -> Option<Substs> {\n+        match self {\n+            Ty::Adt { substs, .. } => Some(substs.clone()),\n+            _ => None,\n+        }\n+    }\n }\n \n impl fmt::Display for Ty {\n@@ -425,7 +583,17 @@ impl fmt::Display for Ty {\n                     .to_fmt(f)?;\n                 write!(f, \" -> {}\", sig.output)\n             }\n-            Ty::Adt { name, .. } => write!(f, \"{}\", name),\n+            Ty::Adt { name, substs, .. } => {\n+                write!(f, \"{}\", name)?;\n+                if substs.0.len() > 0 {\n+                    join(substs.0.iter())\n+                        .surround_with(\"<\", \">\")\n+                        .separator(\", \")\n+                        .to_fmt(f)?;\n+                }\n+                Ok(())\n+            }\n+            Ty::Param { name, .. } => write!(f, \"{}\", name),\n             Ty::Unknown => write!(f, \"[unknown]\"),\n             Ty::Infer(..) => write!(f, \"_\"),\n         }\n@@ -440,28 +608,49 @@ fn type_for_fn(db: &impl HirDatabase, f: Function) -> Ty {\n     let signature = f.signature(db);\n     let module = f.module(db);\n     let impl_block = f.impl_block(db);\n-    // TODO we ignore type parameters for now\n+    let generics = f.generic_params(db);\n     let input = signature\n         .params()\n         .iter()\n-        .map(|tr| Ty::from_hir(db, &module, impl_block.as_ref(), tr))\n+        .map(|tr| Ty::from_hir(db, &module, impl_block.as_ref(), &generics, tr))\n         .collect::<Vec<_>>();\n-    let output = Ty::from_hir(db, &module, impl_block.as_ref(), signature.ret_type());\n+    let output = Ty::from_hir(\n+        db,\n+        &module,\n+        impl_block.as_ref(),\n+        &generics,\n+        signature.ret_type(),\n+    );\n     let sig = FnSig { input, output };\n     Ty::FnPtr(Arc::new(sig))\n }\n \n+fn make_substs(generics: &GenericParams) -> Substs {\n+    Substs(\n+        generics\n+            .params\n+            .iter()\n+            .map(|_p| Ty::Unknown)\n+            .collect::<Vec<_>>()\n+            .into(),\n+    )\n+}\n+\n fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n+    let generics = s.generic_params(db);\n     Ty::Adt {\n         def_id: s.def_id(),\n         name: s.name(db).unwrap_or_else(Name::missing),\n+        substs: make_substs(&generics),\n     }\n }\n \n pub(crate) fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n+    let generics = s.generic_params(db);\n     Ty::Adt {\n         def_id: s.def_id(),\n         name: s.name(db).unwrap_or_else(Name::missing),\n+        substs: make_substs(&generics),\n     }\n }\n \n@@ -495,9 +684,9 @@ pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Ty {\n \n pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name) -> Option<Ty> {\n     let def = def_id.resolve(db);\n-    let variant_data = match def {\n-        Def::Struct(s) => s.variant_data(db),\n-        Def::EnumVariant(ev) => ev.variant_data(db),\n+    let (variant_data, generics) = match def {\n+        Def::Struct(s) => (s.variant_data(db), s.generic_params(db)),\n+        Def::EnumVariant(ev) => (ev.variant_data(db), ev.parent_enum(db).generic_params(db)),\n         // TODO: unions\n         _ => panic!(\n             \"trying to get type for field in non-struct/variant {:?}\",\n@@ -507,7 +696,13 @@ pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name)\n     let module = def_id.module(db);\n     let impl_block = def_id.impl_block(db);\n     let type_ref = variant_data.get_field_type_ref(&field)?;\n-    Some(Ty::from_hir(db, &module, impl_block.as_ref(), &type_ref))\n+    Some(Ty::from_hir(\n+        db,\n+        &module,\n+        impl_block.as_ref(),\n+        &generics,\n+        &type_ref,\n+    ))\n }\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n@@ -684,8 +879,26 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.type_of_pat.insert(pat, ty);\n     }\n \n-    fn make_ty(&self, type_ref: &TypeRef) -> Ty {\n-        Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref)\n+    fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n+        // TODO provide generics of function\n+        let generics = GenericParams::default();\n+        let ty = Ty::from_hir(\n+            self.db,\n+            &self.module,\n+            self.impl_block.as_ref(),\n+            &generics,\n+            type_ref,\n+        );\n+        let ty = self.insert_type_vars(ty);\n+        ty\n+    }\n+\n+    fn unify_substs(&mut self, substs1: &Substs, substs2: &Substs) -> bool {\n+        substs1\n+            .0\n+            .iter()\n+            .zip(substs2.0.iter())\n+            .all(|(t1, t2)| self.unify(t1, t2))\n     }\n \n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n@@ -708,12 +921,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             (Ty::Bool, _) | (Ty::Str, _) | (Ty::Never, _) | (Ty::Char, _) => ty1 == ty2,\n             (\n                 Ty::Adt {\n-                    def_id: def_id1, ..\n+                    def_id: def_id1,\n+                    substs: substs1,\n+                    ..\n                 },\n                 Ty::Adt {\n-                    def_id: def_id2, ..\n+                    def_id: def_id2,\n+                    substs: substs2,\n+                    ..\n                 },\n-            ) if def_id1 == def_id2 => true,\n+            ) if def_id1 == def_id2 => self.unify_substs(substs1, substs2),\n             (Ty::Slice(t1), Ty::Slice(t2)) => self.unify(t1, t2),\n             (Ty::RawPtr(t1, m1), Ty::RawPtr(t2, m2)) if m1 == m2 => self.unify(t1, t2),\n             (Ty::Ref(t1, m1), Ty::Ref(t2, m2)) if m1 == m2 => self.unify(t1, t2),\n@@ -848,73 +1065,100 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         Some(ty)\n     }\n \n-    fn resolve_variant(&self, path: Option<&Path>) -> (Ty, Option<DefId>) {\n-        let path = if let Some(path) = path {\n-            path\n-        } else {\n-            return (Ty::Unknown, None);\n+    fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<DefId>) {\n+        let path = match path {\n+            Some(path) => path,\n+            None => return (Ty::Unknown, None),\n         };\n-        let def_id = if let Some(def_id) = self.module.resolve_path(self.db, &path).take_types() {\n-            def_id\n-        } else {\n-            return (Ty::Unknown, None);\n+        let def_id = match self.module.resolve_path(self.db, &path).take_types() {\n+            Some(def_id) => def_id,\n+            _ => return (Ty::Unknown, None),\n         };\n+        // TODO remove the duplication between here and `Ty::from_path`?\n+        // TODO provide generics of function\n+        let generics = GenericParams::default();\n+        let substs = Ty::substs_from_path(\n+            self.db,\n+            &self.module,\n+            self.impl_block.as_ref(),\n+            &generics,\n+            path,\n+            def_id,\n+        );\n         match def_id.resolve(self.db) {\n             Def::Struct(s) => {\n                 let ty = type_for_struct(self.db, s);\n+                let ty = self.insert_type_vars(ty.apply_substs(substs));\n                 (ty, Some(def_id))\n             }\n             Def::EnumVariant(ev) => {\n                 let ty = type_for_enum_variant(self.db, ev);\n+                let ty = self.insert_type_vars(ty.apply_substs(substs));\n                 (ty, Some(def_id))\n             }\n             _ => (Ty::Unknown, None),\n         }\n     }\n \n-    fn resolve_fields(&self, path: Option<&Path>) -> Option<(Ty, Vec<StructField>)> {\n-        let def_id = self.module.resolve_path(self.db, path?).take_types()?;\n+    fn resolve_fields(&mut self, path: Option<&Path>) -> Option<(Ty, Vec<StructField>)> {\n+        let (ty, def_id) = self.resolve_variant(path);\n+        let def_id = def_id?;\n         let def = def_id.resolve(self.db);\n \n         match def {\n             Def::Struct(s) => {\n                 let fields = s.fields(self.db);\n-                Some((type_for_struct(self.db, s), fields))\n+                Some((ty, fields))\n             }\n             Def::EnumVariant(ev) => {\n                 let fields = ev.fields(self.db);\n-                Some((type_for_enum_variant(self.db, ev), fields))\n+                Some((ty, fields))\n             }\n             _ => None,\n         }\n     }\n \n-    fn infer_tuple_struct_pat(&mut self, path: Option<&Path>, subpats: &[PatId]) -> Ty {\n+    fn infer_tuple_struct_pat(\n+        &mut self,\n+        path: Option<&Path>,\n+        subpats: &[PatId],\n+        expected: &Ty,\n+    ) -> Ty {\n         let (ty, fields) = self\n             .resolve_fields(path)\n             .unwrap_or((Ty::Unknown, Vec::new()));\n \n+        self.unify(&ty, expected);\n+\n+        let substs = ty.substs().expect(\"adt should have substs\");\n+\n         for (i, &subpat) in subpats.iter().enumerate() {\n             let expected_ty = fields\n                 .get(i)\n                 .and_then(|field| field.ty(self.db))\n-                .unwrap_or(Ty::Unknown);\n+                .unwrap_or(Ty::Unknown)\n+                .subst(&substs);\n             self.infer_pat(subpat, &expected_ty);\n         }\n \n         ty\n     }\n \n-    fn infer_struct_pat(&mut self, path: Option<&Path>, subpats: &[FieldPat]) -> Ty {\n+    fn infer_struct_pat(&mut self, path: Option<&Path>, subpats: &[FieldPat], expected: &Ty) -> Ty {\n         let (ty, fields) = self\n             .resolve_fields(path)\n             .unwrap_or((Ty::Unknown, Vec::new()));\n \n+        self.unify(&ty, expected);\n+\n+        let substs = ty.substs().expect(\"adt should have substs\");\n+\n         for subpat in subpats {\n             let matching_field = fields.iter().find(|field| field.name() == &subpat.name);\n             let expected_ty = matching_field\n                 .and_then(|field| field.ty(self.db))\n-                .unwrap_or(Ty::Unknown);\n+                .unwrap_or(Ty::Unknown)\n+                .subst(&substs);\n             self.infer_pat(subpat.pat, &expected_ty);\n         }\n \n@@ -959,11 +1203,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Pat::TupleStruct {\n                 path: ref p,\n                 args: ref subpats,\n-            } => self.infer_tuple_struct_pat(p.as_ref(), subpats),\n+            } => self.infer_tuple_struct_pat(p.as_ref(), subpats, expected),\n             Pat::Struct {\n                 path: ref p,\n                 args: ref fields,\n-            } => self.infer_struct_pat(p.as_ref(), fields),\n+            } => self.infer_struct_pat(p.as_ref(), fields, expected),\n             Pat::Path(path) => self\n                 .module\n                 .resolve_path(self.db, &path)\n@@ -1155,11 +1399,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 spread,\n             } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_ref());\n+                let substs = ty.substs().expect(\"adt should have substs\");\n                 for field in fields {\n                     let field_ty = if let Some(def_id) = def_id {\n                         self.db\n                             .type_for_field(def_id, field.name.clone())\n                             .unwrap_or(Ty::Unknown)\n+                            .subst(&substs)\n                     } else {\n                         Ty::Unknown\n                     };\n@@ -1180,7 +1426,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             let i = name.to_string().parse::<usize>().ok();\n                             i.and_then(|i| fields.get(i).cloned())\n                         }\n-                        Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, name.clone()),\n+                        Ty::Adt {\n+                            def_id, ref substs, ..\n+                        } => self\n+                            .db\n+                            .type_for_field(def_id, name.clone())\n+                            .map(|ty| ty.subst(substs)),\n                         _ => None,\n                     })\n                     .unwrap_or(Ty::Unknown);\n@@ -1193,7 +1444,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Expr::Cast { expr, type_ref } => {\n                 let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n                 let cast_ty = self.make_ty(type_ref);\n-                let cast_ty = self.insert_type_vars(cast_ty);\n                 // TODO check the cast...\n                 cast_ty\n             }\n@@ -1305,12 +1555,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     type_ref,\n                     initializer,\n                 } => {\n-                    let decl_ty = Ty::from_hir_opt(\n-                        self.db,\n-                        &self.module,\n-                        self.impl_block.as_ref(),\n-                        type_ref.as_ref(),\n-                    );\n+                    let decl_ty = type_ref\n+                        .as_ref()\n+                        .map(|tr| self.make_ty(tr))\n+                        .unwrap_or(Ty::Unknown);\n                     let decl_ty = self.insert_type_vars(decl_ty);\n                     let ty = if let Some(expr) = initializer {\n                         let expr_ty = self.infer_expr(*expr, &Expectation::has_type(decl_ty));\n@@ -1338,13 +1586,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         for (type_ref, pat) in signature.params().iter().zip(body.params()) {\n             let ty = self.make_ty(type_ref);\n-            let ty = self.insert_type_vars(ty);\n \n             self.infer_pat(*pat, &ty);\n         }\n         self.return_ty = {\n             let ty = self.make_ty(signature.ret_type());\n-            let ty = self.insert_type_vars(ty);\n             ty\n         };\n     }"}, {"sha": "9f65c5fe1da713a9936c4f91a011cda9fefd93fa", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -8,7 +8,11 @@ use rustc_hash::FxHashMap;\n \n use ra_db::SourceRootId;\n \n-use crate::{HirDatabase, DefId, module_tree::ModuleId, Module, Crate, Name, Function, impl_block::{ImplId, ImplBlock, ImplItem}};\n+use crate::{\n+    HirDatabase, DefId, module_tree::ModuleId, Module, Crate, Name, Function,\n+    impl_block::{ImplId, ImplBlock, ImplItem},\n+    generics::GenericParams\n+};\n use super::Ty;\n \n /// This is used as a key for indexing impls.\n@@ -64,8 +68,15 @@ impl CrateImplBlocks {\n             if let Some(_target_trait) = impl_data.target_trait() {\n                 // ignore for now\n             } else {\n-                let target_ty =\n-                    Ty::from_hir(db, &module, Some(&impl_block), impl_data.target_type());\n+                // TODO provide generics of impl\n+                let generics = GenericParams::default();\n+                let target_ty = Ty::from_hir(\n+                    db,\n+                    &module,\n+                    Some(&impl_block),\n+                    &generics,\n+                    impl_data.target_type(),\n+                );\n                 if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n                     self.impls\n                         .entry(target_ty_fp)"}, {"sha": "06e32df597017035910348842b0968fb5886ceb0", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -418,6 +418,95 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_struct_generics() {\n+    check_inference(\n+        r#\"\n+struct A<T> {\n+    x: T,\n+}\n+\n+fn test(a1: A<u32>, i: i32) {\n+    a1.x;\n+    let a2 = A { x: i };\n+    a2.x;\n+    let a3 = A::<i128> { x: 1 };\n+    a3.x;\n+}\n+\"#,\n+        \"struct_generics.txt\",\n+    );\n+}\n+\n+#[test]\n+fn infer_generics_in_patterns() {\n+    check_inference(\n+        r#\"\n+struct A<T> {\n+    x: T,\n+}\n+\n+enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+\n+fn test(a1: A<u32>, o: Option<u64>) {\n+    let A { x: x2 } = a1;\n+    let A::<i64> { x: x3 } = A { x: 1 };\n+    match o {\n+        Option::Some(t) => t,\n+        _ => 1,\n+    };\n+}\n+\"#,\n+        \"generics_in_patterns.txt\",\n+    );\n+}\n+\n+#[test]\n+fn infer_function_generics() {\n+    check_inference(\n+        r#\"\n+fn id<T>(t: T) -> T { t }\n+\n+fn test() {\n+    id(1u32);\n+    id::<i128>(1);\n+    let x: u64 = id(1);\n+}\n+\"#,\n+        \"function_generics.txt\",\n+    );\n+}\n+\n+#[test]\n+fn infer_generic_chain() {\n+    check_inference(\n+        r#\"\n+struct A<T> {\n+    x: T,\n+}\n+impl<T2> A<T2> {\n+    fn x(self) -> T2 {\n+        self.x\n+    }\n+}\n+fn id<T>(t: T) -> T { t }\n+\n+fn test() -> i128 {\n+     let x = 1;\n+     let y = id(x);\n+     let a = A { x: id(y) };\n+     let z = id(a.x);\n+     let b = A { x: z };\n+     b.x()\n+}\n+\"#,\n+        \"generic_chain.txt\",\n+    );\n+}\n+\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.source_file(file_id);"}, {"sha": "e44d26cfdc96d22e67f149f693b4f8955777cddf", "filename": "crates/ra_hir/src/ty/tests/data/function_generics.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ffunction_generics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ffunction_generics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Ffunction_generics.txt?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -0,0 +1,14 @@\n+[10; 11) 't': [unknown]\n+[21; 26) '{ t }': [unknown]\n+[23; 24) 't': [unknown]\n+[38; 98) '{     ...(1); }': ()\n+[44; 46) 'id': fn(T) -> T\n+[44; 52) 'id(1u32)': T\n+[47; 51) '1u32': u32\n+[58; 68) 'id::<i128>': fn(T) -> T\n+[58; 71) 'id::<i128>(1)': T\n+[69; 70) '1': T\n+[81; 82) 'x': T\n+[90; 92) 'id': fn(T) -> T\n+[90; 95) 'id(1)': T\n+[93; 94) '1': T"}, {"sha": "568e00846be985dc6d4e47b105eb52309a22f911", "filename": "crates/ra_hir/src/ty/tests/data/generic_chain.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fgeneric_chain.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fgeneric_chain.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fgeneric_chain.txt?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -0,0 +1,29 @@\n+[53; 57) 'self': A<[unknown]>\n+[65; 87) '{     ...     }': [unknown]\n+[75; 79) 'self': A<[unknown]>\n+[75; 81) 'self.x': [unknown]\n+[99; 100) 't': [unknown]\n+[110; 115) '{ t }': [unknown]\n+[112; 113) 't': [unknown]\n+[135; 261) '{     ....x() }': i128\n+[146; 147) 'x': T\n+[150; 151) '1': T\n+[162; 163) 'y': T\n+[166; 168) 'id': fn(T) -> T\n+[166; 171) 'id(x)': T\n+[169; 170) 'x': T\n+[182; 183) 'a': A<T>\n+[186; 200) 'A { x: id(y) }': A<T>\n+[193; 195) 'id': fn(T) -> T\n+[193; 198) 'id(y)': T\n+[196; 197) 'y': T\n+[211; 212) 'z': T\n+[215; 217) 'id': fn(T) -> T\n+[215; 222) 'id(a.x)': T\n+[218; 219) 'a': A<T>\n+[218; 221) 'a.x': T\n+[233; 234) 'b': A<T>\n+[237; 247) 'A { x: z }': A<T>\n+[244; 245) 'z': T\n+[254; 255) 'b': A<T>\n+[254; 259) 'b.x()': i128"}, {"sha": "1b01ef19ec15e8d224867cd8fd3eb415c8b5cf06", "filename": "crates/ra_hir/src/ty/tests/data/generics_in_patterns.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fgenerics_in_patterns.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fgenerics_in_patterns.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fgenerics_in_patterns.txt?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -0,0 +1,17 @@\n+[79; 81) 'a1': A<u32>\n+[91; 92) 'o': Option<u64>\n+[107; 244) '{     ...  }; }': ()\n+[117; 128) 'A { x: x2 }': A<u32>\n+[124; 126) 'x2': u32\n+[131; 133) 'a1': A<u32>\n+[143; 161) 'A::<i6...: x3 }': A<i64>\n+[157; 159) 'x3': i64\n+[164; 174) 'A { x: 1 }': A<i64>\n+[171; 172) '1': i64\n+[180; 241) 'match ...     }': u64\n+[186; 187) 'o': Option<u64>\n+[198; 213) 'Option::Some(t)': Option<u64>\n+[211; 212) 't': u64\n+[217; 218) 't': u64\n+[228; 229) '_': Option<u64>\n+[233; 234) '1': u64"}, {"sha": "1024a39a96d65636946f98d21a263910a705d3f2", "filename": "crates/ra_hir/src/ty/tests/data/struct_generics.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct_generics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct_generics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct_generics.txt?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -0,0 +1,15 @@\n+[36; 38) 'a1': A<u32>\n+[48; 49) 'i': i32\n+[56; 147) '{     ...3.x; }': ()\n+[62; 64) 'a1': A<u32>\n+[62; 66) 'a1.x': u32\n+[76; 78) 'a2': A<i32>\n+[81; 91) 'A { x: i }': A<i32>\n+[88; 89) 'i': i32\n+[97; 99) 'a2': A<i32>\n+[97; 101) 'a2.x': i32\n+[111; 113) 'a3': A<i128>\n+[116; 134) 'A::<i1...x: 1 }': A<i128>\n+[131; 132) '1': i128\n+[140; 142) 'a3': A<i128>\n+[140; 144) 'a3.x': i128"}, {"sha": "76c2f8173c04fa43864d05d99229b8b0f1299f9f", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -24,7 +24,9 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n     for receiver in receiver.autoderef(ctx.db) {\n         match receiver {\n-            Ty::Adt { def_id, .. } => {\n+            Ty::Adt {\n+                def_id, ref substs, ..\n+            } => {\n                 match def_id.resolve(ctx.db) {\n                     Def::Struct(s) => {\n                         for field in s.fields(ctx.db) {\n@@ -33,7 +35,7 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n                                 field.name().to_string(),\n                             )\n                             .kind(CompletionItemKind::Field)\n-                            .set_detail(field.ty(ctx.db).map(|ty| ty.to_string()))\n+                            .set_detail(field.ty(ctx.db).map(|ty| ty.subst(substs).to_string()))\n                             .add_to(acc);\n                         }\n                     }"}, {"sha": "a1b6668995f120f0882547099aa37825427201ab", "filename": "crates/ra_ide_api/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_ide_api%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdb.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -129,6 +129,7 @@ salsa::database_storage! {\n             fn body_hir() for hir::db::BodyHirQuery;\n             fn body_syntax_mapping() for hir::db::BodySyntaxMappingQuery;\n             fn fn_signature() for hir::db::FnSignatureQuery;\n+            fn generic_params() for hir::db::GenericParamsQuery;\n         }\n     }\n }"}, {"sha": "9fe94617271fcfb88f4e630210d302910f95927b", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -105,6 +105,38 @@ impl ArrayType {\n     }\n }\n \n+// AssocTypeArg\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct AssocTypeArg {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for AssocTypeArg {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for AssocTypeArg {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            ASSOC_TYPE_ARG => Some(AssocTypeArg::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<AssocTypeArg> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl AssocTypeArg {\n+    pub fn name_ref(&self) -> Option<&NameRef> {\n+        super::child_opt(self)\n+    }\n+\n+    pub fn type_ref(&self) -> Option<&TypeRef> {\n+        super::child_opt(self)\n+    }\n+}\n+\n // Attr\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]\n@@ -1397,6 +1429,34 @@ impl AstNode for Lifetime {\n impl ast::AstToken for Lifetime {}\n impl Lifetime {}\n \n+// LifetimeArg\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct LifetimeArg {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for LifetimeArg {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for LifetimeArg {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            LIFETIME_ARG => Some(LifetimeArg::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<LifetimeArg> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl LifetimeArg {\n+    pub fn lifetime(&self) -> Option<&Lifetime> {\n+        super::child_opt(self)\n+    }\n+}\n+\n // LifetimeParam\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]\n@@ -2355,6 +2415,10 @@ impl PathSegment {\n     pub fn name_ref(&self) -> Option<&NameRef> {\n         super::child_opt(self)\n     }\n+\n+    pub fn type_arg_list(&self) -> Option<&TypeArgList> {\n+        super::child_opt(self)\n+    }\n }\n \n // PathType\n@@ -3335,6 +3399,70 @@ impl TupleType {\n     }\n }\n \n+// TypeArg\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct TypeArg {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for TypeArg {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for TypeArg {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            TYPE_ARG => Some(TypeArg::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<TypeArg> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl TypeArg {\n+    pub fn type_ref(&self) -> Option<&TypeRef> {\n+        super::child_opt(self)\n+    }\n+}\n+\n+// TypeArgList\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct TypeArgList {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+unsafe impl TransparentNewType for TypeArgList {\n+    type Repr = rowan::SyntaxNode<RaTypes>;\n+}\n+\n+impl AstNode for TypeArgList {\n+    fn cast(syntax: &SyntaxNode) -> Option<&Self> {\n+        match syntax.kind() {\n+            TYPE_ARG_LIST => Some(TypeArgList::from_repr(syntax.into_repr())),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+    fn to_owned(&self) -> TreeArc<TypeArgList> { TreeArc::cast(self.syntax.to_owned()) }\n+}\n+\n+\n+impl TypeArgList {\n+    pub fn type_args(&self) -> impl Iterator<Item = &TypeArg> {\n+        super::children(self)\n+    }\n+\n+    pub fn lifetime_args(&self) -> impl Iterator<Item = &LifetimeArg> {\n+        super::children(self)\n+    }\n+\n+    pub fn assoc_type_args(&self) -> impl Iterator<Item = &AssocTypeArg> {\n+        super::children(self)\n+    }\n+}\n+\n // TypeDef\n #[derive(Debug, PartialEq, Eq, Hash)]\n #[repr(transparent)]"}, {"sha": "0385183fdc6d08b40a5d75abc0a278171c22c66a", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/1c296d54e3dcc36c1a778873f26035000a352ba2/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=1c296d54e3dcc36c1a778873f26035000a352ba2", "patch": "@@ -597,8 +597,16 @@ Grammar(\n             ]\n         ),\n         \"PathSegment\": (\n-            options: [ \"NameRef\" ]\n+            options: [ \"NameRef\", \"TypeArgList\" ]\n         ),\n+        \"TypeArgList\": (collections: [\n+            [\"type_args\", \"TypeArg\"],\n+            [\"lifetime_args\", \"LifetimeArg\"],\n+            [\"assoc_type_args\", \"AssocTypeArg\"],\n+        ]),\n+        \"TypeArg\": (options: [\"TypeRef\"]),\n+        \"AssocTypeArg\": (options: [\"NameRef\", \"TypeRef\"]),\n+        \"LifetimeArg\": (options: [\"Lifetime\"]),\n         \"Comment\": ( traits: [\"AstToken\"] ),\n         \"Whitespace\": ( traits: [\"AstToken\"] ),\n     },"}]}