{"sha": "99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5YjJiZDRiZmEzMzJjNWE3MjMxMTRkMDllOGJiNzRkNWEwYzczNzY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-02T19:01:16Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-02T19:01:16Z"}, "message": "rollup merge of #21842: alexcrichton/issue-21839\n\nNow that associated types are fully implemented the iterator adaptors only need\ntype parameters which are associated with actual storage. All other type\nparameters can either be derived from these (e.g. they are an associated type)\nor can be bare on the `impl` block itself.\n\nThis is a breaking change due to the removal of type parameters on these\niterator adaptors, but code can fairly easily migrate by just deleting the\nrelevant type parameters for each adaptor. Other behavior should not be\naffected.\n\nCloses #21839\n[breaking-change]", "tree": {"sha": "a9155fbcc06b7ee671247186089e5436a5f32d4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9155fbcc06b7ee671247186089e5436a5f32d4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "html_url": "https://github.com/rust-lang/rust/commit/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "747e6b53e4b0e71b18c9941409b52144c514ac4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/747e6b53e4b0e71b18c9941409b52144c514ac4e", "html_url": "https://github.com/rust-lang/rust/commit/747e6b53e4b0e71b18c9941409b52144c514ac4e"}, {"sha": "0e4448409ef61c703b98e4c5b2fd99447308942d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e4448409ef61c703b98e4c5b2fd99447308942d", "html_url": "https://github.com/rust-lang/rust/commit/0e4448409ef61c703b98e4c5b2fd99447308942d"}], "stats": {"total": 427, "additions": 137, "deletions": 290}, "files": [{"sha": "99ee5957913dc5659e21c07f7bfb9c703d4c8886", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "patch": "@@ -116,13 +116,13 @@ pub struct IntoIter<K, V> {\n /// An iterator over a BTreeMap's keys.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n \n /// An iterator over a BTreeMap's values.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n /// An iterator over a sub-range of BTreeMap's entries."}, {"sha": "1997fe189be44d21baed70551e5bfb7f9ba14764", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "patch": "@@ -45,40 +45,40 @@ pub struct Iter<'a, T: 'a> {\n /// An owning iterator over a BTreeSet's items.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<T> {\n-    iter: Map<(T, ()), T, ::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n+    iter: Map<::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n }\n \n /// An iterator over a sub-range of BTreeSet's items.\n pub struct Range<'a, T: 'a> {\n-    iter: Map<(&'a T, &'a ()), &'a T, ::btree_map::Range<'a, T, ()>, fn((&'a T, &'a ())) -> &'a T>\n+    iter: Map<::btree_map::Range<'a, T, ()>, fn((&'a T, &'a ())) -> &'a T>\n }\n \n /// A lazy iterator producing elements in the set difference (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T:'a> {\n-    a: Peekable<&'a T, Iter<'a, T>>,\n-    b: Peekable<&'a T, Iter<'a, T>>,\n+    a: Peekable<Iter<'a, T>>,\n+    b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set symmetric difference (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SymmetricDifference<'a, T:'a> {\n-    a: Peekable<&'a T, Iter<'a, T>>,\n-    b: Peekable<&'a T, Iter<'a, T>>,\n+    a: Peekable<Iter<'a, T>>,\n+    b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set intersection (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T:'a> {\n-    a: Peekable<&'a T, Iter<'a, T>>,\n-    b: Peekable<&'a T, Iter<'a, T>>,\n+    a: Peekable<Iter<'a, T>>,\n+    b: Peekable<Iter<'a, T>>,\n }\n \n /// A lazy iterator producing elements in the set union (in-order).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Union<'a, T:'a> {\n-    a: Peekable<&'a T, Iter<'a, T>>,\n-    b: Peekable<&'a T, Iter<'a, T>>,\n+    a: Peekable<Iter<'a, T>>,\n+    b: Peekable<Iter<'a, T>>,\n }\n \n impl<T: Ord> BTreeSet<T> {"}, {"sha": "c74c870eef5d5cfa707c8b8fa40488a5c40b4617", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "patch": "@@ -687,7 +687,7 @@ double_ended_iterator! { impl IterMut -> (uint, &'a mut V), as_mut }\n /// An iterator over the keys of a map.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, V: 'a> {\n-    iter: Map<(uint, &'a V), uint, Iter<'a, V>, fn((uint, &'a V)) -> uint>\n+    iter: Map<Iter<'a, V>, fn((uint, &'a V)) -> uint>\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -702,7 +702,7 @@ impl<'a, V> Clone for Keys<'a, V> {\n /// An iterator over the values of a map.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, V: 'a> {\n-    iter: Map<(uint, &'a V), &'a V, Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n+    iter: Map<Iter<'a, V>, fn((uint, &'a V)) -> &'a V>\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -718,17 +718,13 @@ impl<'a, V> Clone for Values<'a, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<V> {\n     iter: FilterMap<\n-    (uint, Option<V>),\n-    (uint, V),\n     Enumerate<vec::IntoIter<Option<V>>>,\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n #[unstable(feature = \"collections\")]\n pub struct Drain<'a, V> {\n     iter: FilterMap<\n-    (uint, Option<V>),\n-    (uint, V),\n     Enumerate<vec::Drain<'a, Option<V>>>,\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }"}, {"sha": "d0734f9c0395faec4b2713420651137cf4a3e4ec", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 108, "deletions": 242, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "patch": "@@ -239,9 +239,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn zip<B, U>(self, other: U) -> Zip<Self, U> where\n-        U: Iterator<Item=B>,\n-    {\n+    fn zip<U: Iterator>(self, other: U) -> Zip<Self, U> {\n         Zip{a: self, b: other}\n     }\n \n@@ -259,7 +257,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn map<B, F>(self, f: F) -> Map<Self::Item, B, Self, F> where\n+    fn map<B, F>(self, f: F) -> Map<Self, F> where\n         F: FnMut(Self::Item) -> B,\n     {\n         Map{iter: self, f: f}\n@@ -279,7 +277,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn filter<P>(self, predicate: P) -> Filter<Self::Item, Self, P> where\n+    fn filter<P>(self, predicate: P) -> Filter<Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n         Filter{iter: self, predicate: predicate}\n@@ -299,7 +297,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn filter_map<B, F>(self, f: F) -> FilterMap<Self::Item, B, Self, F> where\n+    fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n         FilterMap { iter: self, f: f }\n@@ -342,7 +340,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn peekable(self) -> Peekable<Self::Item, Self> {\n+    fn peekable(self) -> Peekable<Self> {\n         Peekable{iter: self, peeked: None}\n     }\n \n@@ -362,7 +360,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self::Item, Self, P> where\n+    fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n         SkipWhile{iter: self, flag: false, predicate: predicate}\n@@ -383,7 +381,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn take_while<P>(self, predicate: P) -> TakeWhile<Self::Item, Self, P> where\n+    fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where\n         P: FnMut(&Self::Item) -> bool,\n     {\n         TakeWhile{iter: self, flag: false, predicate: predicate}\n@@ -448,12 +446,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn scan<St, B, F>(\n-        self,\n-        initial_state: St,\n-        f: F,\n-    ) -> Scan<Self::Item, B, Self, St, F> where\n-        F: FnMut(&mut St, Self::Item) -> Option<B>,\n+    fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>\n+        where F: FnMut(&mut St, Self::Item) -> Option<B>,\n     {\n         Scan{iter: self, f: f, state: initial_state}\n     }\n@@ -474,9 +468,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn flat_map<B, U, F>(self, f: F) -> FlatMap<Self::Item, B, Self, U, F> where\n-        U: Iterator<Item=B>,\n-        F: FnMut(Self::Item) -> U,\n+    fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>\n+        where U: Iterator, F: FnMut(Self::Item) -> U,\n     {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n@@ -534,7 +527,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn inspect<F>(self, f: F) -> Inspect<Self::Item, Self, F> where\n+    fn inspect<F>(self, f: F) -> Inspect<Self, F> where\n         F: FnMut(&Self::Item),\n     {\n         Inspect{iter: self, f: f}\n@@ -1077,16 +1070,14 @@ pub trait ExactSizeIterator: Iterator {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, F> ExactSizeIterator for Inspect<A, I, F> where\n-    I: ExactSizeIterator<Item=A>,\n-    F: FnMut(&A),\n+impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F> where\n+    F: FnMut(&I::Item),\n {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator + DoubleEndedIterator {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, F> ExactSizeIterator for Map<A, B, I, F> where\n-    I: ExactSizeIterator<Item=A>,\n-    F: FnMut(A) -> B,\n+impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F> where\n+    F: FnMut(I::Item) -> B,\n {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B> ExactSizeIterator for Zip<A, B> where A: ExactSizeIterator, B: ExactSizeIterator {}\n@@ -1561,28 +1552,15 @@ impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n /// An iterator that maps the values of `iter` with `f`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Map<A, B, I: Iterator<Item=A>, F: FnMut(A) -> B> {\n+#[derive(Clone)]\n+pub struct Map<I, F> {\n     iter: I,\n     f: F,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, F> Clone for Map<A, B, I, F> where\n-    I: Clone + Iterator<Item=A>,\n-    F: Clone + FnMut(A) -> B,\n-{\n-    fn clone(&self) -> Map<A, B, I, F> {\n-        Map {\n-            iter: self.iter.clone(),\n-            f: self.f.clone(),\n-        }\n-    }\n-}\n-\n-impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n+impl<I: Iterator, F, B> Map<I, F> where F: FnMut(I::Item) -> B {\n     #[inline]\n-    fn do_map(&mut self, elt: Option<A>) -> Option<B> {\n+    fn do_map(&mut self, elt: Option<I::Item>) -> Option<B> {\n         match elt {\n             Some(a) => Some((self.f)(a)),\n             _ => None\n@@ -1591,7 +1569,7 @@ impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n+impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n     type Item = B;\n \n     #[inline]\n@@ -1607,9 +1585,8 @@ impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMu\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n-    I: DoubleEndedIterator<Item=A>,\n-    F: FnMut(A) -> B,\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n+    F: FnMut(I::Item) -> B,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n@@ -1619,9 +1596,8 @@ impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n-    I: RandomAccessIterator<Item=A>,\n-    F: FnMut(A) -> B,\n+impl<B, I: RandomAccessIterator, F> RandomAccessIterator for Map<I, F> where\n+    F: FnMut(I::Item) -> B,\n {\n     #[inline]\n     fn indexable(&self) -> usize {\n@@ -1638,31 +1614,18 @@ impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n /// An iterator that filters the elements of `iter` with `predicate`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n+#[derive(Clone)]\n+pub struct Filter<I, P> {\n     iter: I,\n     predicate: P,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, P> Clone for Filter<A, I, P> where\n-    I: Clone + Iterator<Item=A>,\n-    P: Clone + FnMut(&A) -> bool,\n-{\n-    fn clone(&self) -> Filter<A, I, P> {\n-        Filter {\n-            iter: self.iter.clone(),\n-            predicate: self.predicate.clone(),\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n-    type Item = A;\n+impl<I: Iterator, P> Iterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {\n+    type Item = I::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option<I::Item> {\n         for x in self.iter.by_ref() {\n             if (self.predicate)(&x) {\n                 return Some(x);\n@@ -1681,12 +1644,11 @@ impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n-    I: DoubleEndedIterator<Item=A>,\n-    P: FnMut(&A) -> bool,\n+impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n+    where P: FnMut(&I::Item) -> bool,\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n+    fn next_back(&mut self) -> Option<I::Item> {\n         for x in self.iter.by_ref().rev() {\n             if (self.predicate)(&x) {\n                 return Some(x);\n@@ -1699,29 +1661,15 @@ impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n /// An iterator that uses `f` to both filter and map elements from `iter`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct FilterMap<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> Option<B> {\n+#[derive(Clone)]\n+pub struct FilterMap<I, F> {\n     iter: I,\n     f: F,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n-    I: Clone + Iterator<Item=A>,\n-    F: Clone + FnMut(A) -> Option<B>,\n-{\n-    fn clone(&self) -> FilterMap<A, B, I, F> {\n-        FilterMap {\n-            iter: self.iter.clone(),\n-            f: self.f.clone(),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n-    I: Iterator<Item=A>,\n-    F: FnMut(A) -> Option<B>,\n+impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n+    where F: FnMut(I::Item) -> Option<B>,\n {\n     type Item = B;\n \n@@ -1744,9 +1692,8 @@ impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n-    I: DoubleEndedIterator<Item=A>,\n-    F: FnMut(A) -> Option<B>,\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n+    where F: FnMut(I::Item) -> Option<B>,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n@@ -1824,20 +1771,28 @@ impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n }\n \n /// An iterator with a `peek()` that returns an optional reference to the next element.\n-#[derive(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Peekable<T, I> where I: Iterator<Item=T> {\n+pub struct Peekable<I: Iterator> {\n     iter: I,\n-    peeked: Option<T>,\n+    peeked: Option<I::Item>,\n+}\n+\n+impl<I: Iterator + Clone> Clone for Peekable<I> where I::Item: Clone {\n+    fn clone(&self) -> Peekable<I> {\n+        Peekable {\n+            iter: self.iter.clone(),\n+            peeked: self.peeked.clone(),\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n-    type Item = T;\n+impl<I: Iterator> Iterator for Peekable<I> {\n+    type Item = I::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<T> {\n+    fn next(&mut self) -> Option<I::Item> {\n         if self.peeked.is_some() { self.peeked.take() }\n         else { self.iter.next() }\n     }\n@@ -1859,14 +1814,14 @@ impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, I> ExactSizeIterator for Peekable<T, I> where I: ExactSizeIterator<Item = T> {}\n+impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n-    /// Return a reference to the next element of the iterator with out advancing it,\n-    /// or None if the iterator is exhausted.\n+impl<I: Iterator> Peekable<I> {\n+    /// Return a reference to the next element of the iterator with out\n+    /// advancing it, or None if the iterator is exhausted.\n     #[inline]\n-    pub fn peek(&mut self) -> Option<&T> {\n+    pub fn peek(&mut self) -> Option<&I::Item> {\n         if self.peeked.is_none() {\n             self.peeked = self.iter.next();\n         }\n@@ -1886,33 +1841,21 @@ impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n /// An iterator that rejects elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n+#[derive(Clone)]\n+pub struct SkipWhile<I, P> {\n     iter: I,\n     flag: bool,\n     predicate: P,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, P> Clone for SkipWhile<A, I, P> where\n-    I: Clone + Iterator<Item=A>,\n-    P: Clone + FnMut(&A) -> bool,\n+impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n+    where P: FnMut(&I::Item) -> bool\n {\n-    fn clone(&self) -> SkipWhile<A, I, P> {\n-        SkipWhile {\n-            iter: self.iter.clone(),\n-            flag: self.flag,\n-            predicate: self.predicate.clone(),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n-    type Item = A;\n+    type Item = I::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option<I::Item> {\n         for x in self.iter.by_ref() {\n             if self.flag || !(self.predicate)(&x) {\n                 self.flag = true;\n@@ -1932,33 +1875,21 @@ impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMu\n /// An iterator that only accepts elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n+#[derive(Clone)]\n+pub struct TakeWhile<I, P> {\n     iter: I,\n     flag: bool,\n     predicate: P,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, P> Clone for TakeWhile<A, I, P> where\n-    I: Clone + Iterator<Item=A>,\n-    P: Clone + FnMut(&A) -> bool,\n+impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n+    where P: FnMut(&I::Item) -> bool\n {\n-    fn clone(&self) -> TakeWhile<A, I, P> {\n-        TakeWhile {\n-            iter: self.iter.clone(),\n-            flag: self.flag,\n-            predicate: self.predicate.clone(),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n-    type Item = A;\n+    type Item = I::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option<I::Item> {\n         if self.flag {\n             None\n         } else {\n@@ -2118,34 +2049,18 @@ impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n /// An iterator to maintain state while iterating another iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Option<B> {\n+#[derive(Clone)]\n+pub struct Scan<I, St, F> {\n     iter: I,\n     f: F,\n \n     /// The current internal state to be passed to the closure next.\n     pub state: St,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n-    I: Clone + Iterator<Item=A>,\n-    St: Clone,\n-    F: Clone + FnMut(&mut St, A) -> Option<B>,\n-{\n-    fn clone(&self) -> Scan<A, B, I, St, F> {\n-        Scan {\n-            iter: self.iter.clone(),\n-            f: self.f.clone(),\n-            state: self.state.clone(),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n-    I: Iterator<Item=A>,\n-    F: FnMut(&mut St, A) -> Option<B>,\n+impl<B, I: Iterator, St, F> Iterator for Scan<I, St, F> where\n+    F: FnMut(&mut St, I::Item) -> Option<B>,\n {\n     type Item = B;\n \n@@ -2166,44 +2081,22 @@ impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n ///\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct FlatMap<A, B, I, U, F> where\n-    I: Iterator<Item=A>,\n-    U: Iterator<Item=B>,\n-    F: FnMut(A) -> U,\n-{\n+#[derive(Clone)]\n+pub struct FlatMap<I, U, F> {\n     iter: I,\n     f: F,\n     frontiter: Option<U>,\n     backiter: Option<U>,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n-    I: Clone + Iterator<Item=A>,\n-    U: Clone + Iterator<Item=B>,\n-    F: Clone + FnMut(A) -> U,\n-{\n-    fn clone(&self) -> FlatMap<A, B, I, U, F> {\n-        FlatMap {\n-            iter: self.iter.clone(),\n-            f: self.f.clone(),\n-            frontiter: self.frontiter.clone(),\n-            backiter: self.backiter.clone(),\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n-    I: Iterator<Item=A>,\n-    U: Iterator<Item=B>,\n-    F: FnMut(A) -> U,\n+impl<I: Iterator, U: Iterator, F> Iterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n {\n-    type Item = B;\n+    type Item = U::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<B> {\n+    fn next(&mut self) -> Option<U::Item> {\n         loop {\n             if let Some(ref mut inner) = self.frontiter {\n                 for x in inner.by_ref() {\n@@ -2230,13 +2123,12 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n-    I: DoubleEndedIterator<Item=A>,\n-    U: DoubleEndedIterator<Item=B>,\n-    F: FnMut(A) -> U,\n+impl<I: DoubleEndedIterator, U: DoubleEndedIterator, F> DoubleEndedIterator\n+    for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<B> {\n+    fn next_back(&mut self) -> Option<U::Item> {\n         loop {\n             if let Some(ref mut inner) = self.backiter {\n                 match inner.next_back() {\n@@ -2340,28 +2232,15 @@ impl<I> Fuse<I> {\n /// element before yielding it.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n+#[derive(Clone)]\n+pub struct Inspect<I, F> {\n     iter: I,\n     f: F,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, F> Clone for Inspect<A, I, F> where\n-    I: Clone + Iterator<Item=A>,\n-    F: Clone + FnMut(&A),\n-{\n-    fn clone(&self) -> Inspect<A, I, F> {\n-        Inspect {\n-            iter: self.iter.clone(),\n-            f: self.f.clone(),\n-        }\n-    }\n-}\n-\n-impl<A, I, F> Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n+impl<I: Iterator, F> Inspect<I, F> where F: FnMut(&I::Item) {\n     #[inline]\n-    fn do_inspect(&mut self, elt: Option<A>) -> Option<A> {\n+    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n         match elt {\n             Some(ref a) => (self.f)(a),\n             None => ()\n@@ -2372,11 +2251,11 @@ impl<A, I, F> Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n-    type Item = A;\n+impl<I: Iterator, F> Iterator for Inspect<I, F> where F: FnMut(&I::Item) {\n+    type Item = I::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option<I::Item> {\n         let next = self.iter.next();\n         self.do_inspect(next)\n     }\n@@ -2388,29 +2267,27 @@ impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n-    I: DoubleEndedIterator<Item=A>,\n-    F: FnMut(&A),\n+impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n+    where F: FnMut(&I::Item),\n {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n+    fn next_back(&mut self) -> Option<I::Item> {\n         let next = self.iter.next_back();\n         self.do_inspect(next)\n     }\n }\n \n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n-impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n-    I: RandomAccessIterator<Item=A>,\n-    F: FnMut(&A),\n+impl<I: RandomAccessIterator, F> RandomAccessIterator for Inspect<I, F>\n+    where F: FnMut(&I::Item),\n {\n     #[inline]\n     fn indexable(&self) -> usize {\n         self.iter.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: usize) -> Option<A> {\n+    fn idx(&mut self, index: usize) -> Option<I::Item> {\n         let element = self.iter.idx(index);\n         self.do_inspect(element)\n     }\n@@ -2426,9 +2303,11 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n /// use std::iter::Unfold;\n /// use std::num::Int; // For `.checked_add()`\n ///\n-/// // This iterator will yield up to the last Fibonacci number before the max value of `u32`.\n-/// // You can simply change `u32` to `u64` in this line if you want higher values than that.\n-/// let mut fibonacci = Unfold::new((Some(0u32), Some(1u32)), |&mut (ref mut x2, ref mut x1)| {\n+/// // This iterator will yield up to the last Fibonacci number before the max\n+/// // value of `u32`. You can simply change `u32` to `u64` in this line if\n+/// // you want higher values than that.\n+/// let mut fibonacci = Unfold::new((Some(0u32), Some(1u32)),\n+///                                 |&mut (ref mut x2, ref mut x1)| {\n ///     // Attempt to get the next Fibonacci number\n ///     // `x1` will be `None` if previously overflowed.\n ///     let next = match (*x2, *x1) {\n@@ -2449,32 +2328,19 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n /// }\n /// ```\n #[unstable(feature = \"core\")]\n-pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n+#[derive(Clone)]\n+pub struct Unfold<St, F> {\n     f: F,\n     /// Internal state that will be passed to the closure on the next iteration\n     pub state: St,\n }\n \n-// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, St, F> Clone for Unfold<A, St, F> where\n-    F: Clone + FnMut(&mut St) -> Option<A>,\n-    St: Clone,\n-{\n-    fn clone(&self) -> Unfold<A, St, F> {\n-        Unfold {\n-            f: self.f.clone(),\n-            state: self.state.clone(),\n-        }\n-    }\n-}\n-\n #[unstable(feature = \"core\")]\n-impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n+impl<A, St, F> Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the closure\n     #[inline]\n-    pub fn new(initial_state: St, f: F) -> Unfold<A, St, F> {\n+    pub fn new(initial_state: St, f: F) -> Unfold<St, F> {\n         Unfold {\n             f: f,\n             state: initial_state\n@@ -2483,7 +2349,7 @@ impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n+impl<A, St, F> Iterator for Unfold<St, F> where F: FnMut(&mut St) -> Option<A> {\n     type Item = A;\n \n     #[inline]\n@@ -2899,7 +2765,7 @@ type IterateState<T, F> = (F, Option<T>, bool);\n /// An iterator that repeatedly applies a given function, starting\n /// from a given seed value.\n #[unstable(feature = \"core\")]\n-pub type Iterate<T, F> = Unfold<T, IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n+pub type Iterate<T, F> = Unfold<IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n \n /// Create a new iterator that produces an infinite sequence of\n /// repeated applications of the given function `f`."}, {"sha": "8c0c16bafc4c586b860d57ebb81339ebe2c3719c", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "patch": "@@ -478,7 +478,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n /// Created with `StrExt::bytes`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n-pub struct Bytes<'a>(Map<&'a u8, u8, slice::Iter<'a, u8>, BytesDeref>);\n+pub struct Bytes<'a>(Map<slice::Iter<'a, u8>, BytesDeref>);\n delegate_iter!{exact u8 : Bytes<'a>}\n \n /// A temporary fn new type that ensures that the `Bytes` iterator\n@@ -526,7 +526,7 @@ pub struct Lines<'a> {\n /// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LinesAny<'a> {\n-    inner: Map<&'a str, &'a str, Lines<'a>, fn(&str) -> &str>,\n+    inner: Map<Lines<'a>, fn(&str) -> &str>,\n }\n \n impl<'a, Sep> CharSplits<'a, Sep> {"}, {"sha": "f11c3154274e7f741bb824532795d2e4803c6080", "filename": "src/librustc_trans/trans/basic_block.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbasic_block.rs?ref=99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "patch": "@@ -16,12 +16,7 @@ use std::iter::{Filter, Map};\n #[derive(Copy)]\n pub struct BasicBlock(pub BasicBlockRef);\n \n-pub type Preds = Map<\n-    Value,\n-    BasicBlock,\n-    Filter<Value, Users, fn(&Value) -> bool>,\n-    fn(Value) -> BasicBlock,\n->;\n+pub type Preds = Map<Filter<Users, fn(&Value) -> bool>, fn(Value) -> BasicBlock>;\n \n /// Wrapper for LLVM BasicBlockRef\n impl BasicBlock {"}, {"sha": "7b3cc434f0ca3e2201951d7f86f887a1578921e8", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "patch": "@@ -1300,18 +1300,13 @@ pub struct IterMut<'a, K: 'a, V: 'a> {\n /// HashMap move iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K, V> {\n-    inner: iter::Map<\n-        (SafeHash, K, V),\n-        (K, V),\n-        table::IntoIter<K, V>,\n-        fn((SafeHash, K, V)) -> (K, V),\n-    >\n+    inner: iter::Map<table::IntoIter<K, V>, fn((SafeHash, K, V)) -> (K, V)>\n }\n \n /// HashMap keys iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Keys<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -1326,7 +1321,7 @@ impl<'a, K, V> Clone for Keys<'a, K, V> {\n /// HashMap values iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Values<'a, K: 'a, V: 'a> {\n-    inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -1342,12 +1337,7 @@ impl<'a, K, V> Clone for Values<'a, K, V> {\n #[unstable(feature = \"std_misc\",\n            reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, K: 'a, V: 'a> {\n-    inner: iter::Map<\n-        (SafeHash, K, V),\n-        (K, V),\n-        table::Drain<'a, K, V>,\n-        fn((SafeHash, K, V)) -> (K, V),\n-    >\n+    inner: iter::Map<table::Drain<'a, K, V>, fn((SafeHash, K, V)) -> (K, V)>\n }\n \n /// A view into a single occupied location in a HashMap."}, {"sha": "f5877e1dd99d8e6fcb62f3ed608bd598a69af076", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "patch": "@@ -796,13 +796,13 @@ pub struct Iter<'a, K: 'a> {\n /// HashSet move iterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<K> {\n-    iter: Map<(K, ()), K, map::IntoIter<K, ()>, fn((K, ())) -> K>\n+    iter: Map<map::IntoIter<K, ()>, fn((K, ())) -> K>\n }\n \n /// HashSet drain iterator\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Drain<'a, K: 'a> {\n-    iter: Map<(K, ()), K, map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n+    iter: Map<map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n }\n \n /// Intersection iterator"}, {"sha": "69f815e3f8b771bc4fc2bf9289d1f54554697441", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "patch": "@@ -31,7 +31,7 @@ pub type Components<'a> = Split<'a, u8, fn(&u8) -> bool>;\n \n /// Iterator that yields successive components of a Path as Option<&str>\n pub type StrComponents<'a> =\n-    Map<&'a [u8], Option<&'a str>, Components<'a>, fn(&[u8]) -> Option<&str>>;\n+    Map<Components<'a>, fn(&[u8]) -> Option<&str>>;\n \n /// Represents a POSIX file path\n #[derive(Clone)]"}, {"sha": "fcdebaf2cd3eb9856f69330fc2750bea18446530", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "patch": "@@ -38,11 +38,11 @@ use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n /// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n /// every component in WindowsPath is guaranteed to be Some.\n pub type StrComponents<'a> =\n-    Map<&'a str, Option<&'a str>, SplitTerminator<'a, char>, fn(&'a str) -> Option<&'a str>>;\n+    Map<SplitTerminator<'a, char>, fn(&'a str) -> Option<&'a str>>;\n \n /// Iterator that yields successive components of a Path as &[u8]\n pub type Components<'a> =\n-    Map<Option<&'a str>, &'a [u8], StrComponents<'a>, fn(Option<&str>) -> &[u8]>;\n+    Map<StrComponents<'a>, fn(Option<&str>) -> &[u8]>;\n \n /// Represents a Windows path\n // Notes for Windows path impl:"}, {"sha": "eecd7d87185434c88501ed2fdcd4365eec2dd30f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "patch": "@@ -436,7 +436,7 @@ pub fn str_lit(lit: &str) -> String {\n     let error = |&: i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace\n-    fn eat<'a>(it: &mut iter::Peekable<(usize, char), str::CharIndices<'a>>) {\n+    fn eat<'a>(it: &mut iter::Peekable<str::CharIndices<'a>>) {\n         loop {\n             match it.peek().map(|x| x.1) {\n                 Some(' ') | Some('\\n') | Some('\\r') | Some('\\t') => {\n@@ -605,7 +605,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n     let error = |&: i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace\n-    fn eat<'a, I: Iterator<Item=(usize, u8)>>(it: &mut iter::Peekable<(usize, u8), I>) {\n+    fn eat<'a, I: Iterator<Item=(usize, u8)>>(it: &mut iter::Peekable<I>) {\n         loop {\n             match it.peek().map(|x| x.1) {\n                 Some(b' ') | Some(b'\\n') | Some(b'\\r') | Some(b'\\t') => {"}, {"sha": "0e3aacbc09a9afb6ed144a138ddc2c1d5ef3355e", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99b2bd4bfa332c5a723114d09e8bb74d5a0c7376/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=99b2bd4bfa332c5a723114d09e8bb74d5a0c7376", "patch": "@@ -32,7 +32,7 @@ use tables::grapheme::GraphemeCat;\n /// An iterator over the words of a string, separated by a sequence of whitespace\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Words<'a> {\n-    inner: Filter<&'a str, Split<'a, fn(char) -> bool>, fn(&&str) -> bool>,\n+    inner: Filter<Split<'a, fn(char) -> bool>, fn(&&str) -> bool>,\n }\n \n /// Methods for Unicode string slices"}]}