{"sha": "323d7f4e98c2e6039efb8c9afda405c156d21299", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyM2Q3ZjRlOThjMmU2MDM5ZWZiOGM5YWZkYTQwNWMxNTZkMjEyOTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-09T17:36:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-23T20:37:48Z"}, "message": "record a scope for each `VarDecl`", "tree": {"sha": "1ed8e41d22dbd10eb6f0ba897fac1658b13cda09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ed8e41d22dbd10eb6f0ba897fac1658b13cda09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/323d7f4e98c2e6039efb8c9afda405c156d21299", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/323d7f4e98c2e6039efb8c9afda405c156d21299", "html_url": "https://github.com/rust-lang/rust/commit/323d7f4e98c2e6039efb8c9afda405c156d21299", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/323d7f4e98c2e6039efb8c9afda405c156d21299/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "464c02e336f15c6fedb7235e93ec6f8f69411b57", "url": "https://api.github.com/repos/rust-lang/rust/commits/464c02e336f15c6fedb7235e93ec6f8f69411b57", "html_url": "https://github.com/rust-lang/rust/commit/464c02e336f15c6fedb7235e93ec6f8f69411b57"}], "stats": {"total": 81, "additions": 45, "deletions": 36}, "files": [{"sha": "ebf78792d72e20c881385ccdf3ba9fe5981b88fa", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=323d7f4e98c2e6039efb8c9afda405c156d21299", "patch": "@@ -159,6 +159,8 @@ pub struct VarDecl<'tcx> {\n     pub mutability: Mutability,\n     pub name: Name,\n     pub ty: Ty<'tcx>,\n+    pub scope: ScopeId, // scope in which variable was declared\n+    pub span: Span, // span where variable was declared\n }\n \n /// A \"temp\" is a temporary that we place on the stack. They are"}, {"sha": "b4c3e93b28005eab4b6333c727ea5e046d1ae20e", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=323d7f4e98c2e6039efb8c9afda405c156d21299", "patch": "@@ -20,7 +20,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                      ast_block: &'tcx hir::Block)\n                      -> BlockAnd<()> {\n         let Block { extent, span, stmts, expr } = self.hir.mirror(ast_block);\n-        self.in_scope(extent, block, move |this| {\n+        self.in_scope(extent, block, move |this, _| {\n             // This convoluted structure is to avoid using recursion as we walk down a list\n             // of statements. Basically, the structure we get back is something like:\n             //\n@@ -42,7 +42,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let Stmt { span: _, kind } = this.hir.mirror(stmt);\n                 match kind {\n                     StmtKind::Expr { scope, expr } => {\n-                        unpack!(block = this.in_scope(scope, block, |this| {\n+                        unpack!(block = this.in_scope(scope, block, |this, _| {\n                             let expr = this.hir.mirror(expr);\n                             let temp = this.temp(expr.ty.clone());\n                             unpack!(block = this.into(&temp, block, expr));\n@@ -51,14 +51,14 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         }));\n                     }\n                     StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n-                        this.push_scope(remainder_scope, block);\n+                        let remainder_scope_id = this.push_scope(remainder_scope, block);\n                         let_extent_stack.push(remainder_scope);\n-                        unpack!(block = this.in_scope(init_scope, block, move |this| {\n+                        unpack!(block = this.in_scope(init_scope, block, move |this, _| {\n                             // FIXME #30046                              ^~~~\n                             if let Some(init) = initializer {\n-                                this.expr_into_pattern(block, remainder_scope, pattern, init)\n+                                this.expr_into_pattern(block, remainder_scope_id, pattern, init)\n                             } else {\n-                                this.declare_bindings(remainder_scope, &pattern);\n+                                this.declare_bindings(remainder_scope_id, &pattern);\n                                 block.unit()\n                             }\n                         }));"}, {"sha": "be2b70b86990eb87baa5f8998bc1eca78a495197", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=323d7f4e98c2e6039efb8c9afda405c156d21299", "patch": "@@ -37,7 +37,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let expr_span = expr.span;\n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this| this.as_lvalue(block, value))\n+                this.in_scope(extent, block, |this, _| this.as_lvalue(block, value))\n             }\n             ExprKind::Field { lhs, name } => {\n                 let lvalue = unpack!(block = this.as_lvalue(block, lhs));"}, {"sha": "661d01ce989cd17595224db55a8b85c7d511d566", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=323d7f4e98c2e6039efb8c9afda405c156d21299", "patch": "@@ -35,7 +35,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let this = self;\n \n         if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope(extent, block, |this| this.as_operand(block, value));\n+            return this.in_scope(extent, block, |this, _| this.as_operand(block, value));\n         }\n \n         let category = Category::of(&expr.kind).unwrap();"}, {"sha": "a77a64ec3d8990354b51e97e363e05ff4f932c52", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=323d7f4e98c2e6039efb8c9afda405c156d21299", "patch": "@@ -37,7 +37,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this| this.as_rvalue(block, value))\n+                this.in_scope(extent, block, |this, _| this.as_rvalue(block, value))\n             }\n             ExprKind::InlineAsm { asm, outputs, inputs } => {\n                 let outputs = outputs.into_iter().map(|output| {\n@@ -76,7 +76,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let result = this.temp(expr.ty);\n                 // to start, malloc some memory of suitable type (thus far, uninitialized):\n                 this.cfg.push_assign(block, expr_span, &result, Rvalue::Box(value.ty));\n-                this.in_scope(value_extents, block, |this| {\n+                this.in_scope(value_extents, block, |this, _| {\n                     // schedule a shallow free of that memory, lest we unwind:\n                     this.schedule_box_free(expr_span, value_extents, &result, value.ty);\n                     // initialize the box contents:"}, {"sha": "2041fef885d08ccec1b3f83b9f13e80297a98512", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=323d7f4e98c2e6039efb8c9afda405c156d21299", "patch": "@@ -30,7 +30,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let this = self;\n \n         if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope(extent, block, |this| this.as_temp(block, value));\n+            return this.in_scope(extent, block, |this, _| this.as_temp(block, value));\n         }\n \n         let expr_ty = expr.ty.clone();"}, {"sha": "ce2b7dc34ebf0ea57b5a89c62248de26f6c6f5dd", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=323d7f4e98c2e6039efb8c9afda405c156d21299", "patch": "@@ -39,7 +39,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this| this.into(destination, block, value))\n+                this.in_scope(extent, block, |this, _| this.into(destination, block, value))\n             }\n             ExprKind::Block { body: ast_block } => {\n                 this.ast_block(destination, block, ast_block)"}, {"sha": "bc92da30caba8d7aca9af9ad1ffb9e365acd4eae", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=323d7f4e98c2e6039efb8c9afda405c156d21299", "patch": "@@ -16,7 +16,6 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc::middle::const_eval::ConstVal;\n-use rustc::middle::region::CodeExtent;\n use rustc::middle::ty::{AdtDef, Ty};\n use rustc::mir::repr::*;\n use hair::*;\n@@ -42,9 +41,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // suitable extent for all of the bindings in this match. It's\n         // easiest to do this up front because some of these arms may\n         // be unreachable or reachable multiple times.\n-        let var_extent = self.extent_of_innermost_scope();\n+        let var_scope_id = self.innermost_scope_id();\n         for arm in &arms {\n-            self.declare_bindings(var_extent, &arm.patterns[0]);\n+            self.declare_bindings(var_scope_id, &arm.patterns[0]);\n         }\n \n         let mut arm_blocks = ArmBlocks {\n@@ -106,7 +105,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n     pub fn expr_into_pattern(&mut self,\n                              mut block: BasicBlock,\n-                             var_extent: CodeExtent, // lifetime of vars\n+                             var_scope_id: ScopeId, // lifetime of vars\n                              irrefutable_pat: Pattern<'tcx>,\n                              initializer: ExprRef<'tcx>)\n                              -> BlockAnd<()> {\n@@ -118,7 +117,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                    var,\n                                    ty,\n                                    subpattern: None } => {\n-                let index = self.declare_binding(var_extent,\n+                let index = self.declare_binding(var_scope_id,\n                                                  mutability,\n                                                  name,\n                                                  var,\n@@ -131,19 +130,19 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }\n         let lvalue = unpack!(block = self.as_lvalue(block, initializer));\n         self.lvalue_into_pattern(block,\n-                                 var_extent,\n+                                 var_scope_id,\n                                  irrefutable_pat,\n                                  &lvalue)\n     }\n \n     pub fn lvalue_into_pattern(&mut self,\n                                mut block: BasicBlock,\n-                               var_extent: CodeExtent,\n+                               var_scope_id: ScopeId,\n                                irrefutable_pat: Pattern<'tcx>,\n                                initializer: &Lvalue<'tcx>)\n                                -> BlockAnd<()> {\n         // first, creating the bindings\n-        self.declare_bindings(var_extent, &irrefutable_pat);\n+        self.declare_bindings(var_scope_id, &irrefutable_pat);\n \n         // create a dummy candidate\n         let mut candidate = Candidate {\n@@ -170,29 +169,29 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         block.unit()\n     }\n \n-    pub fn declare_bindings(&mut self, var_extent: CodeExtent, pattern: &Pattern<'tcx>) {\n+    pub fn declare_bindings(&mut self, var_scope_id: ScopeId, pattern: &Pattern<'tcx>) {\n         match *pattern.kind {\n             PatternKind::Binding { mutability, name, mode: _, var, ty, ref subpattern } => {\n-                self.declare_binding(var_extent, mutability, name, var, ty, pattern.span);\n+                self.declare_binding(var_scope_id, mutability, name, var, ty, pattern.span);\n                 if let Some(subpattern) = subpattern.as_ref() {\n-                    self.declare_bindings(var_extent, subpattern);\n+                    self.declare_bindings(var_scope_id, subpattern);\n                 }\n             }\n             PatternKind::Array { ref prefix, ref slice, ref suffix } |\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 for subpattern in prefix.iter().chain(slice).chain(suffix) {\n-                    self.declare_bindings(var_extent, subpattern);\n+                    self.declare_bindings(var_scope_id, subpattern);\n                 }\n             }\n             PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n             }\n             PatternKind::Deref { ref subpattern } => {\n-                self.declare_bindings(var_extent, subpattern);\n+                self.declare_bindings(var_scope_id, subpattern);\n             }\n             PatternKind::Leaf { ref subpatterns } |\n             PatternKind::Variant { ref subpatterns, .. } => {\n                 for subpattern in subpatterns {\n-                    self.declare_bindings(var_extent, &subpattern.pattern);\n+                    self.declare_bindings(var_scope_id, &subpattern.pattern);\n                 }\n             }\n         }\n@@ -590,25 +589,28 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     }\n \n     fn declare_binding(&mut self,\n-                       var_extent: CodeExtent,\n+                       var_scope_id: ScopeId,\n                        mutability: Mutability,\n                        name: Name,\n                        var_id: NodeId,\n                        var_ty: Ty<'tcx>,\n                        span: Span)\n                        -> u32\n     {\n-        debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, var_extent={:?}, span={:?})\",\n-               var_id, name, var_ty, var_extent, span);\n+        debug!(\"declare_binding(var_id={:?}, name={:?}, var_ty={:?}, var_scope_id={:?}, span={:?})\",\n+               var_id, name, var_ty, var_scope_id, span);\n \n         let index = self.var_decls.len();\n         self.var_decls.push(VarDecl::<'tcx> {\n+            scope: var_scope_id,\n             mutability: mutability,\n             name: name,\n             ty: var_ty.clone(),\n+            span: span,\n         });\n         let index = index as u32;\n-        self.schedule_drop(span, var_extent, &Lvalue::Var(index), var_ty);\n+        let extent = self.scope_auxiliary[var_scope_id.index()].extent;\n+        self.schedule_drop(span, extent, &Lvalue::Var(index), var_ty);\n         self.var_indices.insert(var_id, index);\n \n         debug!(\"declare_binding: index={:?}\", index);"}, {"sha": "4bb6b20a5d5b2fb3e873ce6fd92bfe23dcbf2724", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=323d7f4e98c2e6039efb8c9afda405c156d21299", "patch": "@@ -192,7 +192,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                      ast_block: &'tcx hir::Block)\n                      -> BlockAnd<Vec<ArgDecl<'tcx>>>\n     {\n-        self.in_scope(argument_extent, block, |this| {\n+        self.in_scope(argument_extent, block, |this, argument_scope_id| {\n             // to start, translate the argument patterns and collect the argument types.\n             let implicits = implicit_arguments.into_iter().map(|ty| (ty, None));\n             let explicits = explicit_arguments.into_iter().map(|(ty, pat)| (ty, Some(pat)));\n@@ -205,7 +205,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     if let Some(pattern) = pattern {\n                         let pattern = this.hir.irrefutable_pat(pattern);\n                         unpack!(block = this.lvalue_into_pattern(block,\n-                                                                 argument_extent,\n+                                                                 argument_scope_id,\n                                                                  pattern,\n                                                                  &lvalue));\n                     }"}, {"sha": "1dd9ec5bae5d1fc811ab9f0ad9b5473347f26b35", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/323d7f4e98c2e6039efb8c9afda405c156d21299/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=323d7f4e98c2e6039efb8c9afda405c156d21299", "patch": "@@ -208,11 +208,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n     pub fn in_scope<F, R>(&mut self, extent: CodeExtent, mut block: BasicBlock, f: F) -> BlockAnd<R>\n-        where F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>\n+        where F: FnOnce(&mut Builder<'a, 'tcx>, ScopeId) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n-        self.push_scope(extent, block);\n-        let rv = unpack!(block = f(self));\n+        let id = self.push_scope(extent, block);\n+        let rv = unpack!(block = f(self, id));\n         unpack!(block = self.pop_scope(extent, block));\n         debug!(\"in_scope: exiting extent={:?} block={:?}\", extent, block);\n         block.and(rv)\n@@ -222,7 +222,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, extent: CodeExtent, entry: BasicBlock) {\n+    pub fn push_scope(&mut self, extent: CodeExtent, entry: BasicBlock) -> ScopeId {\n         debug!(\"push_scope({:?})\", extent);\n         let parent_id = self.scopes.last().map(|s| s.id);\n         let id = ScopeId::new(self.scope_data_vec.vec.len());\n@@ -240,6 +240,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             dom: self.cfg.current_location(entry),\n             postdoms: vec![]\n         });\n+        id\n     }\n \n     /// Pops a scope, which should have extent `extent`, adding any\n@@ -321,6 +322,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }.unwrap_or_else(|| hir.span_bug(span, \"no enclosing loop scope found?\"))\n     }\n \n+    pub fn innermost_scope_id(&self) -> ScopeId {\n+        self.scopes.last().map(|scope| scope.id).unwrap()\n+    }\n+\n     pub fn extent_of_innermost_scope(&self) -> CodeExtent {\n         self.scopes.last().map(|scope| scope.extent).unwrap()\n     }"}]}