{"sha": "3819c222a84a9c21992b81939420643c0a969e7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MTljMjIyYTg0YTljMjE5OTJiODE5Mzk0MjA2NDNjMGE5NjllN2Q=", "commit": {"author": {"name": "Alexis", "email": "a.beingessner@gmail.com", "date": "2015-01-16T02:18:57Z"}, "committer": {"name": "Alexis", "email": "a.beingessner@gmail.com", "date": "2015-01-16T02:18:57Z"}, "message": "add a section on performance to collection docs", "tree": {"sha": "cdc6fe2015bc61431fe17415fab6bca454d3f225", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdc6fe2015bc61431fe17415fab6bca454d3f225"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3819c222a84a9c21992b81939420643c0a969e7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3819c222a84a9c21992b81939420643c0a969e7d", "html_url": "https://github.com/rust-lang/rust/commit/3819c222a84a9c21992b81939420643c0a969e7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3819c222a84a9c21992b81939420643c0a969e7d/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8903c21d618fd25dca61d9bb668c5299d21feac9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8903c21d618fd25dca61d9bb668c5299d21feac9", "html_url": "https://github.com/rust-lang/rust/commit/8903c21d618fd25dca61d9bb668c5299d21feac9"}], "stats": {"total": 54, "additions": 52, "deletions": 2}, "files": [{"sha": "8d40a35075ad1dd30cbb0c0e4f19234f04c04f2c", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3819c222a84a9c21992b81939420643c0a969e7d/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3819c222a84a9c21992b81939420643c0a969e7d/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=3819c222a84a9c21992b81939420643c0a969e7d", "patch": "@@ -49,8 +49,8 @@\n //! * You want a double-ended queue (deque).\n //!\n //! ### Use a `DList` when:\n-//! * You want a `Vec` or `RingBuf` of unknown size, and can't tolerate inconsistent\n-//! performance during insertions.\n+//! * You want a `Vec` or `RingBuf` of unknown size, and can't tolerate amortization.\n+//! * You want to efficiently split and append lists.\n //! * You are *absolutely* certain you *really*, *truly*, want a doubly linked list.\n //!\n //! ### Use a `HashMap` when:\n@@ -85,6 +85,56 @@\n //! or \"most important\" one at any given time.\n //! * You want a priority queue.\n //!\n+//! # Performance\n+//!\n+//! Choosing the right collection for the job requires an understanding of what each collection\n+//! is good at. Here we briefly summarize the performance of different collections for certain\n+//! important operations. For further details, see each type's documentation.\n+//!\n+//! Throughout the documentation, we will follow a few conventions. For all operations,\n+//! the collection's size is denoted by n. If another collection is involved in the operation, it\n+//! contains m elements. Operations which have an *amortized* cost are suffixed with a `*`.\n+//! Operations with an *expected* cost are suffixed with a `~`.\n+//!\n+//! All amortized costs are for the potential need to resize when capacity is exhausted.\n+//! If a resize occurs it will take O(n) time. Our collections never automatically shrink,\n+//! so removal operations aren't amortized. Over a sufficiently large series of\n+//! operations, the average cost per operation will deterministically equal the given cost.\n+//!\n+//! Only HashMap has expected costs, due to the probabilistic nature of hashing. It is\n+//! theoretically possible, though very unlikely, for HashMap to experience worse performance.\n+//!\n+//! ## Sequences\n+//!\n+//! |         | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n+//! |---------|----------------|-----------------|----------------|--------|----------------|\n+//! | Vec     | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n+//! | RingBuf | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n+//! | DList   | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n+//! | Bitv    | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n+//!\n+//! Note that where ties occur, Vec is generally going to be faster than RingBuf, and RingBuf\n+//! is generally going to be faster than DList. Bitv is not a general purpose collection, and\n+//! therefore cannot reasonably be compared.\n+//!\n+//! ## Maps\n+//!\n+//! For Sets, all operations have the cost of the equivalent Map operation. For BitvSet,\n+//! refer to VecMap.\n+//!\n+//! |          | get       | insert   | remove   | predecessor |\n+//! |----------|-----------|----------|----------|-------------|\n+//! | HashMap  | O(1)~     | O(1)~*   | O(1)~    | N/A         |\n+//! | BTreeMap | O(log n)  | O(log n) | O(log n) | O(log n)    |\n+//! | VecMap   | O(1)      | O(1)?    | O(1)     | O(n)        |\n+//!\n+//! Note that VecMap is *incredibly* inefficient in terms of space. The O(1) insertion time\n+//! assumes space for the element is already allocated. Otherwise, a large key may require a\n+//! massive reallocation, with no direct relation to the number of elements in the collection.\n+//! VecMap should only be seriously considered for small keys.\n+//!\n+//! Note also that BTreeMap's precise preformance depends on the value of B.\n+//!\n //! # Correct and Efficient Usage of Collections\n //!\n //! Of course, knowing which collection is the right one for the job doesn't instantly"}]}