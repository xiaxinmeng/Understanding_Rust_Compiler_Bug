{"sha": "68042ba0d35f16d66dadf62334ca6bbf20d97268", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MDQyYmEwZDM1ZjE2ZDY2ZGFkZjYyMzM0Y2E2YmJmMjBkOTcyNjg=", "commit": {"author": {"name": "James Cowgill", "email": "jcowgill@debian.org", "date": "2018-02-08T11:01:34Z"}, "committer": {"name": "James Cowgill", "email": "jcowgill@debian.org", "date": "2018-02-14T14:38:55Z"}, "message": "rustc_trans: rewrite mips64 abi", "tree": {"sha": "3b9bd6b6eb296d229cef70d475e613a7076a604b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b9bd6b6eb296d229cef70d475e613a7076a604b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68042ba0d35f16d66dadf62334ca6bbf20d97268", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68042ba0d35f16d66dadf62334ca6bbf20d97268", "html_url": "https://github.com/rust-lang/rust/commit/68042ba0d35f16d66dadf62334ca6bbf20d97268", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68042ba0d35f16d66dadf62334ca6bbf20d97268/comments", "author": {"login": "jcowgill", "id": 1226825, "node_id": "MDQ6VXNlcjEyMjY4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1226825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcowgill", "html_url": "https://github.com/jcowgill", "followers_url": "https://api.github.com/users/jcowgill/followers", "following_url": "https://api.github.com/users/jcowgill/following{/other_user}", "gists_url": "https://api.github.com/users/jcowgill/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcowgill/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcowgill/subscriptions", "organizations_url": "https://api.github.com/users/jcowgill/orgs", "repos_url": "https://api.github.com/users/jcowgill/repos", "events_url": "https://api.github.com/users/jcowgill/events{/privacy}", "received_events_url": "https://api.github.com/users/jcowgill/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jcowgill", "id": 1226825, "node_id": "MDQ6VXNlcjEyMjY4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1226825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcowgill", "html_url": "https://github.com/jcowgill", "followers_url": "https://api.github.com/users/jcowgill/followers", "following_url": "https://api.github.com/users/jcowgill/following{/other_user}", "gists_url": "https://api.github.com/users/jcowgill/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcowgill/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcowgill/subscriptions", "organizations_url": "https://api.github.com/users/jcowgill/orgs", "repos_url": "https://api.github.com/users/jcowgill/repos", "events_url": "https://api.github.com/users/jcowgill/events{/privacy}", "received_events_url": "https://api.github.com/users/jcowgill/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f45a474bd6c7ccfe35e7be5f341e3d04aa5d178e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f45a474bd6c7ccfe35e7be5f341e3d04aa5d178e", "html_url": "https://github.com/rust-lang/rust/commit/f45a474bd6c7ccfe35e7be5f341e3d04aa5d178e"}], "stats": {"total": 150, "additions": 127, "deletions": 23}, "files": [{"sha": "ad35dbeadfc8d375838c4a2e70330b2b9b00fdab", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 127, "deletions": 23, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/68042ba0d35f16d66dadf62334ca6bbf20d97268/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68042ba0d35f16d66dadf62334ca6bbf20d97268/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=68042ba0d35f16d66dadf62334ca6bbf20d97268", "patch": "@@ -8,50 +8,154 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{ArgType, FnType, LayoutExt, Reg, Uniform};\n+use abi::{ArgAttribute, ArgType, CastTarget, FnType, LayoutExt, PassMode, Reg, RegKind, Uniform};\n use context::CodegenCx;\n+use rustc::ty::layout::{self, Size};\n \n-use rustc::ty::layout::Size;\n+fn extend_integer_width_mips(arg: &mut ArgType, bits: u64) {\n+    // Always sign extend u32 values on 64-bit mips\n+    if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n+        if let layout::Int(i, signed) = scalar.value {\n+            if !signed && i.size().bits() == 32 {\n+                if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                    attrs.set(ArgAttribute::SExt);\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    arg.extend_integer_width_to(bits);\n+}\n+\n+fn bits_to_int_reg(bits: u64) -> Reg {\n+    if bits <= 8 {\n+        Reg::i8()\n+    } else if bits <= 16 {\n+        Reg::i16()\n+    } else if bits <= 32 {\n+        Reg::i32()\n+    } else {\n+        Reg::i64()\n+    }\n+}\n \n-fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                             ret: &mut ArgType<'tcx>,\n-                             offset: &mut Size) {\n+fn float_reg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &ArgType<'tcx>, i: usize) -> Option<Reg> {\n+    match ret.layout.field(cx, i).abi {\n+        layout::Abi::Scalar(ref scalar) => match scalar.value {\n+            layout::F32 => Some(Reg::f32()),\n+            layout::F64 => Some(Reg::f64()),\n+            _ => None\n+        },\n+        _ => None\n+    }\n+}\n+\n+fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if !ret.layout.is_aggregate() {\n-        ret.extend_integer_width_to(64);\n+        extend_integer_width_mips(ret, 64);\n+        return;\n+    }\n+\n+    let size = ret.layout.size;\n+    let bits = size.bits();\n+    if bits <= 128 {\n+        // Unlike other architectures which return aggregates in registers, MIPS n64 limits the\n+        // use of float registers to structures (not unions) containing exactly one or two\n+        // float fields.\n+\n+        if let layout::FieldPlacement::Arbitrary { .. } = ret.layout.fields {\n+            if ret.layout.fields.count() == 1 {\n+                if let Some(reg) = float_reg(cx, ret, 0) {\n+                    ret.cast_to(reg);\n+                    return;\n+                }\n+            } else if ret.layout.fields.count() == 2 {\n+                if let Some(reg0) = float_reg(cx, ret, 0) {\n+                    if let Some(reg1) = float_reg(cx, ret, 1) {\n+                        ret.cast_to(CastTarget::Pair(reg0, reg1));\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Cast to a uniform int structure\n+        ret.cast_to(Uniform {\n+            unit: bits_to_int_reg(bits),\n+            total: size\n+        });\n     } else {\n         ret.make_indirect();\n-        *offset += cx.tcx.data_layout.pointer_size;\n     }\n }\n \n-fn classify_arg_ty(cx: &CodegenCx, arg: &mut ArgType, offset: &mut Size) {\n+fn classify_arg_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if !arg.layout.is_aggregate() {\n+        extend_integer_width_mips(arg, 64);\n+        return;\n+    }\n+\n     let dl = &cx.tcx.data_layout;\n     let size = arg.layout.size;\n-    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n+    let mut prefix = [RegKind::Integer; 8];\n+    let mut prefix_index = 0;\n \n-    if arg.layout.is_aggregate() {\n-        arg.cast_to(Uniform {\n-            unit: Reg::i64(),\n-            total: size\n-        });\n-        if !offset.is_abi_aligned(align) {\n-            arg.pad_with(Reg::i64());\n+    match arg.layout.fields {\n+        layout::FieldPlacement::Array { .. } => {\n+            // Arrays are passed indirectly\n+            arg.make_indirect();\n+            return;\n         }\n-    } else {\n-        arg.extend_integer_width_to(64);\n-    }\n+        layout::FieldPlacement::Union(_) => {\n+            // Unions and are always treated as a series of 64-bit integer chunks\n+        },\n+        layout::FieldPlacement::Arbitrary { .. } => {\n+            // Structures are split up into a series of 64-bit integer chunks, but any aligned\n+            // doubles not part of another aggregate are passed as floats.\n+            let mut last_offset = Size::from_bytes(0);\n+\n+            for i in 0..arg.layout.fields.count() {\n+                let field = arg.layout.field(cx, i);\n+                let offset = arg.layout.fields.offset(i);\n+\n+                // We only care about aligned doubles\n+                if let layout::Abi::Scalar(ref scalar) = field.abi {\n+                    if let layout::F64 = scalar.value {\n+                        if offset.is_abi_aligned(dl.f64_align) {\n+                            // Skip over enough integers to cover [last_offset, offset)\n+                            assert!(last_offset.is_abi_aligned(dl.f64_align));\n+                            prefix_index += ((offset - last_offset).bits() / 64) as usize;\n+\n+                            if prefix_index >= prefix.len() {\n+                                break;\n+                            }\n+\n+                            prefix[prefix_index] = RegKind::Float;\n+                            prefix_index += 1;\n+                            last_offset = offset + Reg::f64().size;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    };\n \n-    *offset = offset.abi_align(align) + size.abi_align(align);\n+    // Extract first 8 chunks as the prefix\n+    arg.cast_to(CastTarget::ChunkedPrefix {\n+        prefix: prefix,\n+        chunk: Size::from_bytes(8),\n+        total: size\n+    });\n }\n \n pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n-    let mut offset = Size::from_bytes(0);\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(cx, &mut fty.ret, &mut offset);\n+        classify_ret_ty(cx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(cx, arg, &mut offset);\n+        classify_arg_ty(cx, arg);\n     }\n }"}]}