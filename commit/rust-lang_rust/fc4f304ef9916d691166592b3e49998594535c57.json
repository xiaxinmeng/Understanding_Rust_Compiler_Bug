{"sha": "fc4f304ef9916d691166592b3e49998594535c57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNGYzMDRlZjk5MTZkNjkxMTY2NTkyYjNlNDk5OTg1OTQ1MzVjNTc=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-05-17T00:42:08Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-05-20T18:49:21Z"}, "message": "hygiene infrastructure.\n\n- added a hash table to memoize rename and mark operations.\n- added rename, mark, and resolve fold fns", "tree": {"sha": "0ffb6923b5bc5f54e44c8ee254d40bd20759c806", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ffb6923b5bc5f54e44c8ee254d40bd20759c806"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc4f304ef9916d691166592b3e49998594535c57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc4f304ef9916d691166592b3e49998594535c57", "html_url": "https://github.com/rust-lang/rust/commit/fc4f304ef9916d691166592b3e49998594535c57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc4f304ef9916d691166592b3e49998594535c57/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b621820dc4727677f14bee0ac5e2fa5e424ed22e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b621820dc4727677f14bee0ac5e2fa5e424ed22e", "html_url": "https://github.com/rust-lang/rust/commit/b621820dc4727677f14bee0ac5e2fa5e424ed22e"}], "stats": {"total": 304, "additions": 194, "deletions": 110}, "files": [{"sha": "2b98803364c11f59992718375a93d0ffad141aa8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc4f304ef9916d691166592b3e49998594535c57/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc4f304ef9916d691166592b3e49998594535c57/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fc4f304ef9916d691166592b3e49998594535c57", "patch": "@@ -19,6 +19,7 @@ use core::option::{None, Option, Some};\n use core::to_bytes;\n use core::to_bytes::IterBytes;\n use core::to_str::ToStr;\n+use core::hashmap::HashMap;\n use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n \n@@ -38,14 +39,20 @@ pub struct ident { repr: Name, ctxt: SyntaxContext }\n // that's causing unreleased memory to cause core dumps\n // and also perhaps to save some work in destructor checks.\n // the special uint '0' will be used to indicate an empty\n-// syntax context\n+// syntax context.\n \n // this uint is a reference to a table stored in thread-local\n // storage.\n pub type SyntaxContext = uint;\n \n-pub type SCTable = ~[SyntaxContext_];\n+pub struct SCTable {\n+    table : ~[SyntaxContext_],\n+    mark_memo : HashMap<(SyntaxContext,Mrk),SyntaxContext>,\n+    rename_memo : HashMap<(SyntaxContext,ident,Name),SyntaxContext>\n+}\n+// NB: these must be placed in any SCTable...\n pub static empty_ctxt : uint = 0;\n+pub static illegal_ctxt : uint = 1;\n \n #[deriving(Eq, Encodable, Decodable)]\n pub enum SyntaxContext_ {\n@@ -59,7 +66,8 @@ pub enum SyntaxContext_ {\n     // \"to\" slot must have the same name and context\n     // in the \"from\" slot. In essence, they're all\n     // pointers to a single \"rename\" event node.\n-    Rename (ident,Name,SyntaxContext)\n+    Rename (ident,Name,SyntaxContext),\n+    IllegalCtxt()    \n }\n \n // a name represents an identifier"}, {"sha": "eaacb054ca1aea8e70cdca0529ed8b8b8e2059d4", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 93, "deletions": 41, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/fc4f304ef9916d691166592b3e49998594535c57/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc4f304ef9916d691166592b3e49998594535c57/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=fc4f304ef9916d691166592b3e49998594535c57", "patch": "@@ -15,6 +15,7 @@ use codemap::{span, spanned};\n use parse::token;\n use visit;\n use opt_vec;\n+use core::hashmap::HashMap;\n \n use core::to_bytes;\n \n@@ -577,22 +578,61 @@ pub enum Privacy {\n // HYGIENE FUNCTIONS\n \n /// Construct an identifier with the given repr and an empty context:\n-pub fn mk_ident(repr: uint) -> ident { ident {repr: repr, ctxt: 0}}\n+pub fn new_ident(repr: uint) -> ident { ident {repr: repr, ctxt: 0}}\n \n /// Extend a syntax context with a given mark\n-pub fn mk_mark (m:Mrk,ctxt:SyntaxContext,table:&mut SCTable)\n+pub fn new_mark (m:Mrk, tail:SyntaxContext,table:&mut SCTable)\n     -> SyntaxContext {\n-    idx_push(table,Mark(m,ctxt))\n+    let key = (tail,m);\n+    // FIXME #5074 : can't use more natural style because we're missing\n+    // flow-sensitivity. Results in two lookups on a hash table hit.\n+    // also applies to new_rename, below.\n+    // let try_lookup = table.mark_memo.find(&key);\n+    match table.mark_memo.contains_key(&key) {\n+        false => {\n+            let new_idx = idx_push(&mut table.table,Mark(m,tail));\n+            table.mark_memo.insert(key,new_idx);\n+            new_idx\n+        }\n+        true => {\n+            match table.mark_memo.find(&key) {\n+                None => fail!(~\"internal error: key disappeared 2013042901\"),\n+                Some(idxptr) => {*idxptr}\n+            }\n+        }\n+    }\n }\n \n /// Extend a syntax context with a given rename\n-pub fn mk_rename (id:ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n+pub fn new_rename (id:ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n     -> SyntaxContext {\n-    idx_push(table,Rename(id,to,tail))\n+    let key = (tail,id,to);\n+    // FIXME #5074\n+    //let try_lookup = table.rename_memo.find(&key);\n+    match table.rename_memo.contains_key(&key) {\n+        false => {\n+            let new_idx = idx_push(&mut table.table,Rename(id,to,tail));\n+            table.rename_memo.insert(key,new_idx);\n+            new_idx\n+        }\n+        true => {\n+            match table.rename_memo.find(&key) {\n+                None => fail!(~\"internal error: key disappeared 2013042902\"),\n+                Some(idxptr) => {*idxptr}\n+            }\n+        }\n+    }\n }\n \n /// Make a fresh syntax context table with EmptyCtxt in slot zero\n-pub fn mk_sctable() -> SCTable { ~[EmptyCtxt] }\n+/// and IllegalCtxt in slot one.\n+pub fn new_sctable() -> SCTable {\n+    SCTable {\n+        table: ~[EmptyCtxt,IllegalCtxt],\n+        mark_memo: HashMap::new(),\n+        rename_memo: HashMap::new()\n+    }\n+}\n \n /// Add a value to the end of a vec, return its index\n fn idx_push<T>(vec: &mut ~[T], val: T) -> uint {\n@@ -601,8 +641,8 @@ fn idx_push<T>(vec: &mut ~[T], val: T) -> uint {\n }\n \n /// Resolve a syntax object to a name, per MTWT.\n-pub fn resolve (id : ident, table : &SCTable) -> Name {\n-    match table[id.ctxt] {\n+pub fn resolve (id : ident, table : &mut SCTable) -> Name {\n+    match table.table[id.ctxt] {\n         EmptyCtxt => id.repr,\n         // ignore marks here:\n         Mark(_,subctxt) => resolve (ident{repr:id.repr, ctxt: subctxt},table),\n@@ -619,6 +659,7 @@ pub fn resolve (id : ident, table : &SCTable) -> Name {\n                 resolvedthis\n             }\n         }\n+        IllegalCtxt() => fail!(~\"expected resolvable context, got IllegalCtxt\")\n     }\n }\n \n@@ -629,7 +670,7 @@ pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> ~[Mrk] {\n     let mut result = ~[];\n     let mut loopvar = ctxt;\n     loop {\n-        match table[loopvar] {\n+        match table.table[loopvar] {\n             EmptyCtxt => {return result;},\n             Mark(mark,tl) => {\n                 xorPush(&mut result,mark);\n@@ -644,6 +685,7 @@ pub fn marksof(ctxt: SyntaxContext, stopname: Name, table: &SCTable) -> ~[Mrk] {\n                     loopvar = tl;\n                 }\n             }\n+            IllegalCtxt => fail!(~\"expected resolvable context, got IllegalCtxt\")\n         }\n     }\n }\n@@ -713,15 +755,15 @@ mod test {\n         -> SyntaxContext {\n         tscs.foldr(tail, |tsc : &TestSC,tail : SyntaxContext|\n                   {match *tsc {\n-                      M(mrk) => mk_mark(mrk,tail,table),\n-                      R(ident,name) => mk_rename(ident,name,tail,table)}})\n+                      M(mrk) => new_mark(mrk,tail,table),\n+                      R(ident,name) => new_rename(ident,name,tail,table)}})\n     }\n \n     // gather a SyntaxContext back into a vector of TestSCs\n     fn refold_test_sc(mut sc: SyntaxContext, table : &SCTable) -> ~[TestSC] {\n         let mut result = ~[];\n         loop {\n-            match table[sc] {\n+            match table.table[sc] {\n                 EmptyCtxt => {return result;},\n                 Mark(mrk,tail) => {\n                     result.push(M(mrk));\n@@ -733,40 +775,41 @@ mod test {\n                     sc = tail;\n                     loop;\n                 }\n+                IllegalCtxt => fail!(\"expected resolvable context, got IllegalCtxt\")\n             }\n         }\n     }\n \n     #[test] fn test_unfold_refold(){\n-        let mut t = mk_sctable();\n+        let mut t = new_sctable();\n \n         let test_sc = ~[M(3),R(id(101,0),14),M(9)];\n-        assert_eq!(unfold_test_sc(copy test_sc,empty_ctxt,&mut t),3);\n-        assert_eq!(t[1],Mark(9,0));\n-        assert_eq!(t[2],Rename(id(101,0),14,1));\n-        assert_eq!(t[3],Mark(3,2));\n-        assert_eq!(refold_test_sc(3,&t),test_sc);\n+        assert_eq!(unfold_test_sc(copy test_sc,empty_ctxt,&mut t),4);\n+        assert_eq!(t.table[2],Mark(9,0));\n+        assert_eq!(t.table[3],Rename(id(101,0),14,2));\n+        assert_eq!(t.table[4],Mark(3,3));\n+        assert_eq!(refold_test_sc(4,&t),test_sc);\n     }\n \n     // extend a syntax context with a sequence of marks given\n     // in a vector. v[0] will be the outermost mark.\n     fn unfold_marks(mrks:~[Mrk],tail:SyntaxContext,table: &mut SCTable) -> SyntaxContext {\n         mrks.foldr(tail, |mrk:&Mrk,tail:SyntaxContext|\n-                   {mk_mark(*mrk,tail,table)})\n+                   {new_mark(*mrk,tail,table)})\n     }\n \n     #[test] fn unfold_marks_test() {\n-        let mut t = ~[EmptyCtxt];\n+        let mut t = new_sctable();\n \n-        assert_eq!(unfold_marks(~[3,7],empty_ctxt,&mut t),2);\n-        assert_eq!(t[1],Mark(7,0));\n-        assert_eq!(t[2],Mark(3,1));\n+        assert_eq!(unfold_marks(~[3,7],empty_ctxt,&mut t),3);\n+        assert_eq!(t.table[2],Mark(7,0));\n+        assert_eq!(t.table[3],Mark(3,2));\n     }\n \n     #[test] fn test_marksof () {\n         let stopname = 242;\n         let name1 = 243;\n-        let mut t = mk_sctable();\n+        let mut t = new_sctable();\n         assert_eq!(marksof (empty_ctxt,stopname,&t),~[]);\n         // FIXME #5074: ANF'd to dodge nested calls\n         { let ans = unfold_marks(~[4,98],empty_ctxt,&mut t);\n@@ -780,13 +823,13 @@ mod test {\n         // rename where stop doesn't match:\n         { let chain = ~[M(9),\n                         R(id(name1,\n-                             mk_mark (4, empty_ctxt,&mut t)),\n+                             new_mark (4, empty_ctxt,&mut t)),\n                           100101102),\n                         M(14)];\n          let ans = unfold_test_sc(chain,empty_ctxt,&mut t);\n          assert_eq! (marksof (ans, stopname, &t), ~[9,14]);}\n         // rename where stop does match\n-        { let name1sc = mk_mark(4, empty_ctxt, &mut t);\n+        { let name1sc = new_mark(4, empty_ctxt, &mut t);\n          let chain = ~[M(9),\n                        R(id(name1, name1sc),\n                          stopname),\n@@ -798,51 +841,60 @@ mod test {\n \n     #[test] fn resolve_tests () {\n         let a = 40;\n-        let mut t = mk_sctable();\n+        let mut t = new_sctable();\n         // - ctxt is MT\n-        assert_eq!(resolve(id(a,empty_ctxt),&t),a);\n+        assert_eq!(resolve(id(a,empty_ctxt),&mut t),a);\n         // - simple ignored marks\n         { let sc = unfold_marks(~[1,2,3],empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&t),a);}\n+         assert_eq!(resolve(id(a,sc),&mut t),a);}\n         // - orthogonal rename where names don't match\n         { let sc = unfold_test_sc(~[R(id(50,empty_ctxt),51),M(12)],empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&t),a);}\n+         assert_eq!(resolve(id(a,sc),&mut t),a);}\n         // - rename where names do match, but marks don't\n-        { let sc1 = mk_mark(1,empty_ctxt,&mut t);\n+        { let sc1 = new_mark(1,empty_ctxt,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50),\n                                    M(1),\n                                    M(2)],\n                                  empty_ctxt,&mut t);\n-        assert_eq!(resolve(id(a,sc),&t), a);}\n+        assert_eq!(resolve(id(a,sc),&mut t), a);}\n         // - rename where names and marks match\n         { let sc1 = unfold_test_sc(~[M(1),M(2)],empty_ctxt,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50),M(1),M(2)],empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&t), 50); }\n+         assert_eq!(resolve(id(a,sc),&mut t), 50); }\n         // - rename where names and marks match by literal sharing\n         { let sc1 = unfold_test_sc(~[M(1),M(2)],empty_ctxt,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50)],sc1,&mut t);\n-         assert_eq!(resolve(id(a,sc),&t), 50); }\n+         assert_eq!(resolve(id(a,sc),&mut t), 50); }\n         // - two renames of the same var.. can only happen if you use\n         // local-expand to prevent the inner binding from being renamed\n         // during the rename-pass caused by the first:\n         io::println(\"about to run bad test\");\n         { let sc = unfold_test_sc(~[R(id(a,empty_ctxt),50),\n                                     R(id(a,empty_ctxt),51)],\n                                   empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&t), 51); }\n+         assert_eq!(resolve(id(a,sc),&mut t), 51); }\n         // the simplest double-rename:\n-        { let a_to_a50 = mk_rename(id(a,empty_ctxt),50,empty_ctxt,&mut t);\n-         let a50_to_a51 = mk_rename(id(a,a_to_a50),51,a_to_a50,&mut t);\n-         assert_eq!(resolve(id(a,a50_to_a51),&t),51);\n+        { let a_to_a50 = new_rename(id(a,empty_ctxt),50,empty_ctxt,&mut t);\n+         let a50_to_a51 = new_rename(id(a,a_to_a50),51,a_to_a50,&mut t);\n+         assert_eq!(resolve(id(a,a50_to_a51),&mut t),51);\n          // mark on the outside doesn't stop rename:\n-         let sc = mk_mark(9,a50_to_a51,&mut t);\n-         assert_eq!(resolve(id(a,sc),&t),51);\n+         let sc = new_mark(9,a50_to_a51,&mut t);\n+         assert_eq!(resolve(id(a,sc),&mut t),51);\n          // but mark on the inside does:\n          let a50_to_a51_b = unfold_test_sc(~[R(id(a,a_to_a50),51),\n                                               M(9)],\n                                            a_to_a50,\n                                            &mut t);\n-         assert_eq!(resolve(id(a,a50_to_a51_b),&t),50);}\n+         assert_eq!(resolve(id(a,a50_to_a51_b),&mut t),50);}\n+    }\n+\n+    #[test] fn hashing_tests () {\n+        let mut t = new_sctable();\n+        assert_eq!(new_mark(12,empty_ctxt,&mut t),2);\n+        assert_eq!(new_mark(13,empty_ctxt,&mut t),3);\n+        // using the same one again should result in the same index:\n+        assert_eq!(new_mark(12,empty_ctxt,&mut t),2);\n+        // I'm assuming that the rename table will behave the same....\n     }\n \n }"}, {"sha": "7a323b364706dc846e4c421197c70b93ffbd451a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 58, "deletions": 35, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/fc4f304ef9916d691166592b3e49998594535c57/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc4f304ef9916d691166592b3e49998594535c57/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=fc4f304ef9916d691166592b3e49998594535c57", "patch": "@@ -11,7 +11,9 @@\n use ast::{blk_, attribute_, attr_outer, meta_word};\n use ast::{crate, expr_, expr_mac, mac_invoc_tt};\n use ast::{item_mac, stmt_, stmt_mac, stmt_expr, stmt_semi};\n+use ast::{SCTable, illegal_ctxt};\n use ast;\n+use ast_util::{new_rename, new_mark, resolve};\n use attr;\n use codemap;\n use codemap::{span, CallInfo, ExpandedFrom, NameAndSpan, spanned};\n@@ -635,62 +637,65 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     @f.fold_crate(&*c)\n }\n \n-// given a function from paths to paths, produce\n+// given a function from idents to idents, produce\n // an ast_fold that applies that function:\n-fn fun_to_path_folder(f: @fn(&ast::Path)->ast::Path) -> @ast_fold{\n+pub fn fun_to_ident_folder(f: @fn(ast::ident)->ast::ident) -> @ast_fold{\n     let afp = default_ast_fold();\n     let f_pre = @AstFoldFns{\n-        fold_path : |p, _| f(p),\n+        fold_ident : |id, _| f(id),\n         .. *afp\n     };\n     make_fold(f_pre)\n }\n-/* going to have to figure out whether the table is passed in or\n-extracted from TLS...\n+\n // update the ctxts in a path to get a rename node\n-fn ctxt_update_rename(from: ast::Name,\n-                       fromctx: ast::SyntaxContext, to: ast::Name) ->\n-    @fn(&ast::Path,@ast_fold)->ast::Path {\n-    return |p:&ast::Path,_|\n-    ast::Path {span: p.span,\n-               global: p.global,\n-               idents: p.idents.map(|id|\n-                                    ast::ident{\n-                                        repr: id.repr,\n-                                        // this needs to be cached....\n-                                        ctxt: Some(@ast::Rename(from,fromctx,\n-                                                           to,id.ctxt))\n-                                    }),\n-               rp: p.rp,\n-               types: p.types};\n+pub fn new_ident_renamer(from: ast::ident,\n+                      to: ast::Name,\n+                      table: @mut SCTable) ->\n+    @fn(ast::ident)->ast::ident {\n+    |id : ast::ident|\n+    ast::ident{\n+        repr: id.repr,\n+        ctxt: new_rename(from,to,id.ctxt,table)\n+    }\n }\n \n+\n // update the ctxts in a path to get a mark node\n-fn ctxt_update_mark(mark: uint) ->\n-    @fn(&ast::Path,@ast_fold)->ast::Path {\n-    return |p:&ast::Path,_|\n-    ast::Path {span: p.span,\n-               global: p.global,\n-               idents: p.idents.map(|id|\n-                                    ast::ident{\n-                                        repr: id.repr,\n-                                        // this needs to be cached....\n-                                        ctxt: Some(@ast::Mark(mark,id.ctxt))\n-                                    }),\n-               rp: p.rp,\n-               types: p.types};\n+pub fn new_ident_marker(mark: uint,\n+                        table: @mut SCTable) ->\n+    @fn(ast::ident)->ast::ident {\n+    |id : ast::ident|\n+    ast::ident{\n+        repr: id.repr,\n+        ctxt: new_mark(mark,id.ctxt,table)\n+    }\n }\n-*/\n+\n+// perform resolution (in the MTWT sense) on all of the\n+// idents in the tree. This is the final step in expansion.\n+pub fn new_ident_resolver(table: @mut SCTable) ->\n+    @fn(ast::ident)->ast::ident {\n+    |id : ast::ident|\n+    ast::ident {\n+        repr : resolve(id,table),\n+        ctxt : illegal_ctxt\n+    }\n+}\n+\n \n #[cfg(test)]\n mod test {\n     use super::*;\n     use ast;\n-    use ast::{attribute_, attr_outer, meta_word};\n+    use ast::{attribute_, attr_outer, meta_word, empty_ctxt};\n+    use ast_util::{new_sctable};\n     use codemap;\n     use codemap::spanned;\n     use parse;\n+    use core::io;\n     use core::option::{None, Some};\n+    use util::parser_testing::{string_to_item_and_sess};\n \n     // make sure that fail! is present\n     #[test] fn fail_exists_test () {\n@@ -792,4 +797,22 @@ mod test {\n         }\n     }\n \n+    #[test]\n+    fn renaming () {\n+        let (maybe_item_ast,sess) = string_to_item_and_sess(@~\"fn a() -> int { let b = 13; b} \");\n+        let item_ast = match maybe_item_ast {\n+            Some(x) => x,\n+            None => fail!(\"test case fail\")\n+        };\n+        let table = @mut new_sctable();\n+        let a_name = 100; // enforced by testing_interner\n+        let a2_name = sess.interner.gensym(@~\"a2\").repr;\n+        let renamer = new_ident_renamer(ast::ident{repr:a_name,ctxt:empty_ctxt},\n+                                        a2_name,table);\n+        let renamed_ast = fun_to_ident_folder(renamer).fold_item(item_ast).get();\n+        let resolver = new_ident_resolver(table);\n+        let resolved_ast = fun_to_ident_folder(resolver).fold_item(renamed_ast).get();\n+        io::print(fmt!(\"ast: %?\\n\",resolved_ast))\n+    }\n+\n }"}, {"sha": "0a9e16f8f7cf6ca9b174fb559a4655860a9b6bb6", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fc4f304ef9916d691166592b3e49998594535c57/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc4f304ef9916d691166592b3e49998594535c57/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=fc4f304ef9916d691166592b3e49998594535c57", "patch": "@@ -346,21 +346,16 @@ mod test {\n     use std::serialize::Encodable;\n     use std;\n     use core::io;\n-    use core::option::Option;\n     use core::option::Some;\n     use core::option::None;\n-    use core::int;\n-    use core::num::NumCast;\n-    use codemap::{CodeMap, span, BytePos, spanned};\n+    use codemap::{span, BytePos, spanned};\n     use opt_vec;\n     use ast;\n     use abi;\n-    use ast_util::mk_ident;\n+    use ast_util::new_ident;\n     use parse::parser::Parser;\n-    use parse::token::{ident_interner, mk_ident_interner, mk_fresh_ident_interner};\n-    use diagnostic::{span_handler, mk_span_handler, mk_handler, Emitter};\n     use util::parser_testing::{string_to_tts_and_sess,string_to_parser};\n-    use util::parser_testing::{string_to_crate, string_to_expr, string_to_item};\n+    use util::parser_testing::{string_to_expr, string_to_item};\n     use util::parser_testing::{string_to_stmt};\n \n     // map a string to tts, return the tt without its parsesess\n@@ -384,7 +379,7 @@ mod test {\n \n     // convert a vector of uints to a vector of ast::idents\n     fn ints_to_idents(ids: ~[uint]) -> ~[ast::ident] {\n-        ids.map(|u| mk_ident(*u))\n+        ids.map(|u| new_ident(*u))\n     }\n \n     #[test] fn path_exprs_1 () {\n@@ -393,7 +388,7 @@ mod test {\n                               callee_id:2,\n                               node:ast::expr_path(@ast::Path {span:sp(0,1),\n                                                               global:false,\n-                                                              idents:~[mk_ident(100)],\n+                                                              idents:~[new_ident(100)],\n                                                               rp:None,\n                                                               types:~[]}),\n                               span:sp(0,1)})\n@@ -456,7 +451,7 @@ mod test {\n                                                   node:ast::expr_path(\n                                                       @ast::Path{span:sp(7,8),\n                                                                  global:false,\n-                                                                 idents:~[mk_ident(103)],\n+                                                                 idents:~[new_ident(103)],\n                                                                  rp:None,\n                                                                  types:~[]\n                                                                 }),\n@@ -474,7 +469,7 @@ mod test {\n                                @ast::Path{\n                                    span:sp(0,1),\n                                    global:false,\n-                                   idents:~[mk_ident(101)],\n+                                   idents:~[new_ident(101)],\n                                    rp:None,\n                                    types: ~[]}),\n                            span: sp(0,1)},\n@@ -495,7 +490,7 @@ mod test {\n                                                   @ast::Path{\n                                                       span:sp(0,1),\n                                                       global:false,\n-                                                      idents:~[mk_ident(101)],\n+                                                      idents:~[new_ident(101)],\n                                                       rp: None,\n                                                       types: ~[]},\n                                                   None // no idea\n@@ -514,7 +509,7 @@ mod test {\n                                         span:sp(4,4), // this is bizarre...\n                                         // check this in the original parser?\n                                         global:false,\n-                                        idents:~[mk_ident(105)],\n+                                        idents:~[new_ident(105)],\n                                         rp: None,\n                                         types: ~[]},\n                                                        2),\n@@ -524,7 +519,7 @@ mod test {\n                                                            @ast::Path{\n                                                                span:sp(0,1),\n                                                                global:false,\n-                                                               idents:~[mk_ident(101)],\n+                                                               idents:~[new_ident(101)],\n                                                                rp: None,\n                                                                types: ~[]},\n                                                            None // no idea\n@@ -540,7 +535,7 @@ mod test {\n         // assignment order of the node_ids.\n         assert_eq!(string_to_item(@~\"fn a (b : int) { b; }\"),\n                   Some(\n-                      @ast::item{ident:mk_ident(100),\n+                      @ast::item{ident:new_ident(100),\n                             attrs:~[],\n                             id: 10, // fixme\n                             node: ast::item_fn(ast::fn_decl{\n@@ -550,7 +545,7 @@ mod test {\n                                                 node: ast::ty_path(@ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n-                                        idents:~[mk_ident(106)],\n+                                        idents:~[new_ident(106)],\n                                         rp: None,\n                                         types: ~[]},\n                                                        2),\n@@ -561,7 +556,7 @@ mod test {\n                                                        @ast::Path{\n                                                            span:sp(6,7),\n                                                            global:false,\n-                                                           idents:~[mk_ident(101)],\n+                                                           idents:~[new_ident(101)],\n                                                            rp: None,\n                                                            types: ~[]},\n                                                        None // no idea\n@@ -592,7 +587,7 @@ mod test {\n                                                         @ast::Path{\n                                                             span:sp(17,18),\n                                                             global:false,\n-                                                            idents:~[mk_ident(101)],\n+                                                            idents:~[new_ident(101)],\n                                                             rp:None,\n                                                             types: ~[]}),\n                                                     span: sp(17,18)},"}, {"sha": "12c28f096f6839d833c7eb269b283544f44af025", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fc4f304ef9916d691166592b3e49998594535c57/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc4f304ef9916d691166592b3e49998594535c57/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=fc4f304ef9916d691166592b3e49998594535c57", "patch": "@@ -8,22 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::serialize::Encodable;\n-use std;\n-use core::io;\n use core::option::{Option,None};\n use core::int;\n use core::num::NumCast;\n-use codemap::{dummy_sp, CodeMap, BytePos, spanned};\n-use opt_vec;\n+use codemap::CodeMap;\n use ast;\n-use abi;\n-use ast_util::mk_ident;\n use parse::parser::Parser;\n-use parse::token::{ident_interner, mk_ident_interner, mk_fresh_ident_interner};\n-use diagnostic::{span_handler, mk_span_handler, mk_handler, Emitter};\n+use parse::token::{ident_interner, mk_fresh_ident_interner};\n+use diagnostic::{mk_handler, mk_span_handler};\n \n-use syntax::parse::{ParseSess,new_parse_sess,string_to_filemap,filemap_to_tts};\n+use syntax::parse::{ParseSess,string_to_filemap,filemap_to_tts};\n use syntax::parse::{new_parser_from_source_str};\n \n // add known names to interner for testing\n@@ -71,10 +65,15 @@ pub fn string_to_tts_and_sess (source_str : @~str) -> (~[ast::token_tree],@mut P\n     (filemap_to_tts(ps,string_to_filemap(ps,source_str,~\"bogofile\")),ps)\n }\n \n+pub fn string_to_parser_and_sess(source_str: @~str) -> (Parser,@mut ParseSess) {\n+    let ps = mk_testing_parse_sess();\n+    (new_parser_from_source_str(ps,~[],~\"bogofile\",source_str),ps)\n+}\n+\n // map string to parser (via tts)\n pub fn string_to_parser(source_str: @~str) -> Parser {\n-    let ps = mk_testing_parse_sess();\n-    new_parser_from_source_str(ps,~[],~\"bogofile\",source_str)\n+    let (p,_) = string_to_parser_and_sess(source_str);\n+    p\n }\n \n pub fn string_to_crate (source_str : @~str) -> @ast::crate {\n@@ -86,10 +85,17 @@ pub fn string_to_expr (source_str : @~str) -> @ast::expr {\n     string_to_parser(source_str).parse_expr()\n }\n \n+// parse a string, return an item\n pub fn string_to_item (source_str : @~str) -> Option<@ast::item> {\n     string_to_parser(source_str).parse_item(~[])\n }\n \n+// parse a string, return an item and the ParseSess\n+pub fn string_to_item_and_sess (source_str : @~str) -> (Option<@ast::item>,@mut ParseSess) {\n+    let (p,ps) = string_to_parser_and_sess(source_str);\n+    (p.parse_item(~[]),ps)\n+}\n+\n pub fn string_to_stmt (source_str : @~str) -> @ast::stmt {\n     string_to_parser(source_str).parse_stmt(~[])\n }"}]}