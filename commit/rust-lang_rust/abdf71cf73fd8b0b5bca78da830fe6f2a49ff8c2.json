{"sha": "abdf71cf73fd8b0b5bca78da830fe6f2a49ff8c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZGY3MWNmNzNmZDhiMGI1YmNhNzhkYTgzMGZlNmYyYTQ5ZmY4YzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-27T17:56:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-27T17:56:26Z"}, "message": "auto merge of #15212 : huonw/rust/struct-paren-lint, r=alexcrichton\n\nrustc: update the unnecessary parens lint for struct literals.\r\n\r\nThings like `match X { x: 1 } { ... }` now need to be written with\r\nparentheses, so the lint should avoid warning in cases like that.", "tree": {"sha": "e2441ed043a2a7eb038e62efde9cedf505c26d25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2441ed043a2a7eb038e62efde9cedf505c26d25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abdf71cf73fd8b0b5bca78da830fe6f2a49ff8c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abdf71cf73fd8b0b5bca78da830fe6f2a49ff8c2", "html_url": "https://github.com/rust-lang/rust/commit/abdf71cf73fd8b0b5bca78da830fe6f2a49ff8c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abdf71cf73fd8b0b5bca78da830fe6f2a49ff8c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0983872efeea757600031a081a2eff9676fe895", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0983872efeea757600031a081a2eff9676fe895", "html_url": "https://github.com/rust-lang/rust/commit/d0983872efeea757600031a081a2eff9676fe895"}, {"sha": "64019e764f1837a4a19297fc9f7a99595e37cf51", "url": "https://api.github.com/repos/rust-lang/rust/commits/64019e764f1837a4a19297fc9f7a99595e37cf51", "html_url": "https://github.com/rust-lang/rust/commit/64019e764f1837a4a19297fc9f7a99595e37cf51"}], "stats": {"total": 87, "additions": 74, "deletions": 13}, "files": [{"sha": "339db67b3f1a1db8eee9ae655f9ed1012184ef4b", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 51, "deletions": 13, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/abdf71cf73fd8b0b5bca78da830fe6f2a49ff8c2/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abdf71cf73fd8b0b5bca78da830fe6f2a49ff8c2/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=abdf71cf73fd8b0b5bca78da830fe6f2a49ff8c2", "patch": "@@ -975,14 +975,52 @@ declare_lint!(UNNECESSARY_PARENS, Warn,\n pub struct UnnecessaryParens;\n \n impl UnnecessaryParens {\n-    fn check_unnecessary_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str) {\n+    fn check_unnecessary_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str,\n+                                     struct_lit_needs_parens: bool) {\n         match value.node {\n-            ast::ExprParen(_) => {\n-                cx.span_lint(UNNECESSARY_PARENS, value.span,\n-                    format!(\"unnecessary parentheses around {}\", msg).as_slice())\n+            ast::ExprParen(ref inner) => {\n+                let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n+                if !necessary {\n+                    cx.span_lint(UNNECESSARY_PARENS, value.span,\n+                                 format!(\"unnecessary parentheses around {}\",\n+                                         msg).as_slice())\n+                }\n             }\n             _ => {}\n         }\n+\n+        /// Expressions that syntatically contain an \"exterior\" struct\n+        /// literal i.e. not surrounded by any parens or other\n+        /// delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo\n+        /// == X { y: 1 }` and `X { y: 1 } == foo` all do, but `(X {\n+        /// y: 1 }) == foo` does not.\n+        fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n+            match value.node {\n+                ast::ExprStruct(..) => true,\n+\n+                ast::ExprAssign(ref lhs, ref rhs) |\n+                ast::ExprAssignOp(_, ref lhs, ref rhs) |\n+                ast::ExprBinary(_, ref lhs, ref rhs) => {\n+                    // X { y: 1 } + X { y: 2 }\n+                    contains_exterior_struct_lit(&**lhs) ||\n+                        contains_exterior_struct_lit(&**rhs)\n+                }\n+                ast::ExprUnary(_, ref x) |\n+                ast::ExprCast(ref x, _) |\n+                ast::ExprField(ref x, _, _) |\n+                ast::ExprIndex(ref x, _) => {\n+                    // &X { y: 1 }, X { y: 1 }.y\n+                    contains_exterior_struct_lit(&**x)\n+                }\n+\n+                ast::ExprMethodCall(_, _, ref exprs) => {\n+                    // X { y: 1 }.bar(...)\n+                    contains_exterior_struct_lit(&**exprs.get(0))\n+                }\n+\n+                _ => false\n+            }\n+        }\n     }\n }\n \n@@ -992,16 +1030,16 @@ impl LintPass for UnnecessaryParens {\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        let (value, msg) = match e.node {\n-            ast::ExprIf(cond, _, _) => (cond, \"`if` condition\"),\n-            ast::ExprWhile(cond, _) => (cond, \"`while` condition\"),\n-            ast::ExprMatch(head, _) => (head, \"`match` head expression\"),\n-            ast::ExprRet(Some(value)) => (value, \"`return` value\"),\n-            ast::ExprAssign(_, value) => (value, \"assigned value\"),\n-            ast::ExprAssignOp(_, _, value) => (value, \"assigned value\"),\n+        let (value, msg, struct_lit_needs_parens) = match e.node {\n+            ast::ExprIf(cond, _, _) => (cond, \"`if` condition\", true),\n+            ast::ExprWhile(cond, _) => (cond, \"`while` condition\", true),\n+            ast::ExprMatch(head, _) => (head, \"`match` head expression\", true),\n+            ast::ExprRet(Some(value)) => (value, \"`return` value\", false),\n+            ast::ExprAssign(_, value) => (value, \"assigned value\", false),\n+            ast::ExprAssignOp(_, _, value) => (value, \"assigned value\", false),\n             _ => return\n         };\n-        self.check_unnecessary_parens_core(cx, &*value, msg);\n+        self.check_unnecessary_parens_core(cx, &*value, msg, struct_lit_needs_parens);\n     }\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n@@ -1015,7 +1053,7 @@ impl LintPass for UnnecessaryParens {\n             },\n             _ => return\n         };\n-        self.check_unnecessary_parens_core(cx, &*value, msg);\n+        self.check_unnecessary_parens_core(cx, &*value, msg, false);\n     }\n }\n "}, {"sha": "4d9383aeda2a1473d85d43eedc0eb5bc3b708a39", "filename": "src/test/compile-fail/lint-unnecessary-parens.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/abdf71cf73fd8b0b5bca78da830fe6f2a49ff8c2/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abdf71cf73fd8b0b5bca78da830fe6f2a49ff8c2/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs?ref=abdf71cf73fd8b0b5bca78da830fe6f2a49ff8c2", "patch": "@@ -10,18 +10,41 @@\n \n #![deny(unnecessary_parens)]\n \n+#[deriving(Eq, PartialEq)]\n+struct X { y: bool }\n+impl X {\n+    fn foo(&self) -> bool { self.y }\n+}\n+\n fn foo() -> int {\n     return (1); //~ ERROR unnecessary parentheses around `return` value\n }\n+fn bar() -> X {\n+    return (X { y: true }); //~ ERROR unnecessary parentheses around `return` value\n+}\n \n fn main() {\n     foo();\n+    bar();\n \n     if (true) {} //~ ERROR unnecessary parentheses around `if` condition\n     while (true) {} //~ ERROR unnecessary parentheses around `while` condition\n     match (true) { //~ ERROR unnecessary parentheses around `match` head expression\n         _ => {}\n     }\n+    let v = X { y: false };\n+    // struct lits needs parens, so these shouldn't warn.\n+    if (v == X { y: true }) {}\n+    if (X { y: true } == v) {}\n+    if (X { y: false }.y) {}\n+\n+    while (X { y: false }.foo()) {}\n+    while (true | X { y: false }.y) {}\n+\n+    match (X { y: false }) {\n+        _ => {}\n+    }\n+\n     let mut _a = (0); //~ ERROR unnecessary parentheses around assigned value\n     _a = (0); //~ ERROR unnecessary parentheses around assigned value\n     _a += (1); //~ ERROR unnecessary parentheses around assigned value"}]}