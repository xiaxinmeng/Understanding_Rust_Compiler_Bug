{"sha": "84322efad553c7a79c80189f2d1b9197c1aa005f", "node_id": "C_kwDOAAsO6NoAKDg0MzIyZWZhZDU1M2M3YTc5YzgwMTg5ZjJkMWI5MTk3YzFhYTAwNWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-23T15:37:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-23T15:37:43Z"}, "message": "Auto merge of #93066 - nnethercote:infallible-decoder, r=bjorn3\n\nMake `Decodable` and `Decoder` infallible.\n\n`Decoder` has two impls:\n- opaque: this impl is already partly infallible, i.e. in some places it\n  currently panics on failure (e.g. if the input is too short, or on a\n  bad `Result` discriminant), and in some places it returns an error\n  (e.g. on a bad `Option` discriminant). The number of places where\n  either happens is surprisingly small, just because the binary\n  representation has very little redundancy and a lot of input reading\n  can occur even on malformed data.\n- json: this impl is fully fallible, but it's only used (a) for the\n  `.rlink` file production, and there's a `FIXME` comment suggesting it\n  should change to a binary format, and (b) in a few tests in\n  non-fundamental ways. Indeed #85993 is open to remove it entirely.\n\nAnd the top-level places in the compiler that call into decoding just\nabort on error anyway. So the fallibility is providing little value, and\ngetting rid of it leads to some non-trivial performance improvements.\n\nMuch of this PR is pretty boring and mechanical. Some notes about\na few interesting parts:\n- The commit removes `Decoder::{Error,error}`.\n- `InternIteratorElement::intern_with`: the impl for `T` now has the same\n  optimization for small counts that the impl for `Result<T, E>` has,\n  because it's now much hotter.\n- Decodable impls for SmallVec, LinkedList, VecDeque now all use\n  `collect`, which is nice; the one for `Vec` uses unsafe code, because\n  that gave better perf on some benchmarks.\n\nr? `@bjorn3`", "tree": {"sha": "91c0878bef11d5d61a3a9cfc62b57f6527ced686", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91c0878bef11d5d61a3a9cfc62b57f6527ced686"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84322efad553c7a79c80189f2d1b9197c1aa005f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84322efad553c7a79c80189f2d1b9197c1aa005f", "html_url": "https://github.com/rust-lang/rust/commit/84322efad553c7a79c80189f2d1b9197c1aa005f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84322efad553c7a79c80189f2d1b9197c1aa005f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e4067957bd5d0e12c1657e720903209ecc291dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e4067957bd5d0e12c1657e720903209ecc291dc", "html_url": "https://github.com/rust-lang/rust/commit/1e4067957bd5d0e12c1657e720903209ecc291dc"}, {"sha": "37fbd91eb526cc7e246f7c6c97b1deb9e37879ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/37fbd91eb526cc7e246f7c6c97b1deb9e37879ff", "html_url": "https://github.com/rust-lang/rust/commit/37fbd91eb526cc7e246f7c6c97b1deb9e37879ff"}], "stats": {"total": 1509, "additions": 726, "deletions": 783}, "files": [{"sha": "7c19559ed91f59fc10c2d3fdfb0d4a7c4ebc094d", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -2418,8 +2418,9 @@ impl<S: Encoder> rustc_serialize::Encodable<S> for AttrId {\n }\n \n impl<D: Decoder> rustc_serialize::Decodable<D> for AttrId {\n-    fn decode(d: &mut D) -> Result<AttrId, D::Error> {\n-        d.read_nil().map(|_| crate::attr::mk_attr_id())\n+    fn decode(d: &mut D) -> AttrId {\n+        d.read_unit();\n+        crate::attr::mk_attr_id()\n     }\n }\n "}, {"sha": "70dbda8222445c58deebca03ee09a5163b4f6a29", "filename": "compiler/rustc_ast/src/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_ast%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_ast%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fptr.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -115,8 +115,8 @@ impl<T> fmt::Pointer for P<T> {\n }\n \n impl<D: Decoder, T: 'static + Decodable<D>> Decodable<D> for P<T> {\n-    fn decode(d: &mut D) -> Result<P<T>, D::Error> {\n-        Decodable::decode(d).map(P)\n+    fn decode(d: &mut D) -> P<T> {\n+        P(Decodable::decode(d))\n     }\n }\n \n@@ -204,8 +204,8 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for P<[T]> {\n }\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for P<[T]> {\n-    fn decode(d: &mut D) -> Result<P<[T]>, D::Error> {\n-        Ok(P::from_vec(Decodable::decode(d)?))\n+    fn decode(d: &mut D) -> P<[T]> {\n+        P::from_vec(Decodable::decode(d))\n     }\n }\n "}, {"sha": "2174378a560d34a9fe9d134346015c18fd329604", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -163,7 +163,7 @@ impl<S: Encoder> Encodable<S> for LazyTokenStream {\n }\n \n impl<D: Decoder> Decodable<D> for LazyTokenStream {\n-    fn decode(_d: &mut D) -> Result<Self, D::Error> {\n+    fn decode(_d: &mut D) -> Self {\n         panic!(\"Attempted to decode LazyTokenStream\");\n     }\n }"}, {"sha": "525cd650dd25d3ecfed8b2e72cab96a4707dd0f0", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -149,10 +149,10 @@ impl<E: rustc_serialize::Encoder> Encodable<E> for Fingerprint {\n \n impl<D: rustc_serialize::Decoder> Decodable<D> for Fingerprint {\n     #[inline]\n-    fn decode(d: &mut D) -> Result<Self, D::Error> {\n+    fn decode(d: &mut D) -> Self {\n         let mut bytes = [0u8; 16];\n-        d.read_raw_bytes_into(&mut bytes)?;\n-        Ok(Fingerprint::from_le_bytes(bytes))\n+        d.read_raw_bytes_into(&mut bytes);\n+        Fingerprint::from_le_bytes(bytes)\n     }\n }\n \n@@ -195,8 +195,8 @@ impl<E: rustc_serialize::Encoder> Encodable<E> for PackedFingerprint {\n \n impl<D: rustc_serialize::Decoder> Decodable<D> for PackedFingerprint {\n     #[inline]\n-    fn decode(d: &mut D) -> Result<Self, D::Error> {\n-        Fingerprint::decode(d).map(PackedFingerprint)\n+    fn decode(d: &mut D) -> Self {\n+        Self(Fingerprint::decode(d))\n     }\n }\n "}, {"sha": "12ef286091c5d532a92c3da8411cee93f2d46049", "filename": "compiler/rustc_data_structures/src/svh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -55,8 +55,8 @@ impl<S: Encoder> Encodable<S> for Svh {\n }\n \n impl<D: Decoder> Decodable<D> for Svh {\n-    fn decode(d: &mut D) -> Result<Svh, D::Error> {\n-        d.read_u64().map(u64::from_le).map(Svh::new)\n+    fn decode(d: &mut D) -> Svh {\n+        Svh::new(u64::from_le(d.read_u64()))\n     }\n }\n "}, {"sha": "2b64312dbef93af17d95e184c009c4bfcbd1541c", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -597,10 +597,7 @@ impl RustcDefaultCalls {\n                 let rlink_data = fs::read_to_string(file).unwrap_or_else(|err| {\n                     sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n                 });\n-                let codegen_results: CodegenResults =\n-                    json::decode(&rlink_data).unwrap_or_else(|err| {\n-                        sess.fatal(&format!(\"failed to decode rlink: {}\", err));\n-                    });\n+                let codegen_results: CodegenResults = json::decode(&rlink_data);\n                 let result = compiler.codegen_backend().link(sess, codegen_results, &outputs);\n                 abort_on_err(result, sess);\n             } else {"}, {"sha": "c5b3d2044073f06be90870bee1dd626cd5cd7354", "filename": "compiler/rustc_errors/src/json/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -64,7 +64,7 @@ fn test_positions(code: &str, span: (u32, u32), expected_output: SpanTestData) {\n \n         let bytes = output.lock().unwrap();\n         let actual_output = str::from_utf8(&bytes).unwrap();\n-        let actual_output: TestData = decode(actual_output).unwrap();\n+        let actual_output: TestData = decode(actual_output);\n \n         assert_eq!(expected_output, actual_output)\n     })"}, {"sha": "dbacbba2ce03856879806eb0bfdc2c2467133618", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -99,8 +99,8 @@ impl Hash for ToolMetadata {\n \n // Doesn't really need to round-trip\n impl<D: Decoder> Decodable<D> for ToolMetadata {\n-    fn decode(_d: &mut D) -> Result<Self, D::Error> {\n-        Ok(ToolMetadata(None))\n+    fn decode(_d: &mut D) -> Self {\n+        ToolMetadata(None)\n     }\n }\n "}, {"sha": "870c3f8068245f3d6a988b80753eea53a242182c", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -158,14 +158,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n             // Decode the list of work_products\n             let mut work_product_decoder = Decoder::new(&work_products_data[..], start_pos);\n             let work_products: Vec<SerializedWorkProduct> =\n-                Decodable::decode(&mut work_product_decoder).unwrap_or_else(|e| {\n-                    let msg = format!(\n-                        \"Error decoding `work-products` from incremental \\\n-                                    compilation session directory: {}\",\n-                        e\n-                    );\n-                    sess.fatal(&msg)\n-                });\n+                Decodable::decode(&mut work_product_decoder);\n \n             for swp in work_products {\n                 let mut all_files_exist = true;\n@@ -203,8 +196,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n             LoadResult::Error { message } => LoadResult::Error { message },\n             LoadResult::Ok { data: (bytes, start_pos) } => {\n                 let mut decoder = Decoder::new(&bytes, start_pos);\n-                let prev_commandline_args_hash = u64::decode(&mut decoder)\n-                    .expect(\"Error reading commandline arg hash from cached dep-graph\");\n+                let prev_commandline_args_hash = u64::decode(&mut decoder);\n \n                 if prev_commandline_args_hash != expected_hash {\n                     if report_incremental_info {\n@@ -220,8 +212,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n                     return LoadResult::DataOutOfDate;\n                 }\n \n-                let dep_graph = SerializedDepGraph::decode(&mut decoder)\n-                    .expect(\"Error reading cached dep-graph\");\n+                let dep_graph = SerializedDepGraph::decode(&mut decoder);\n \n                 LoadResult::Ok { data: (dep_graph, prev_work_products) }\n             }"}, {"sha": "8b61530577d8e2848a6a43a3ebdd62ac6507e903", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -395,8 +395,8 @@ macro_rules! newtype_index {\n \n     (@serializable $type:ident) => (\n         impl<D: ::rustc_serialize::Decoder> ::rustc_serialize::Decodable<D> for $type {\n-            fn decode(d: &mut D) -> Result<Self, D::Error> {\n-                d.read_u32().map(Self::from_u32)\n+            fn decode(d: &mut D) -> Self {\n+                Self::from_u32(d.read_u32())\n             }\n         }\n         impl<E: ::rustc_serialize::Encoder> ::rustc_serialize::Encodable<E> for $type {\n@@ -527,8 +527,8 @@ impl<S: Encoder, I: Idx, T: Encodable<S>> Encodable<S> for &IndexVec<I, T> {\n }\n \n impl<D: Decoder, I: Idx, T: Decodable<D>> Decodable<D> for IndexVec<I, T> {\n-    fn decode(d: &mut D) -> Result<Self, D::Error> {\n-        Decodable::decode(d).map(|v| IndexVec { raw: v, _marker: PhantomData })\n+    fn decode(d: &mut D) -> Self {\n+        IndexVec { raw: Decodable::decode(d), _marker: PhantomData }\n     }\n }\n "}, {"sha": "6c5461505fa268b6bfd183d3c72edf845d82f1db", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -47,7 +47,7 @@ fn decodable_body(\n             quote! {\n                 ::rustc_serialize::Decoder::read_struct(\n                     __decoder,\n-                    |__decoder| { ::std::result::Result::Ok(#construct) },\n+                    |__decoder| { #construct },\n                 )\n             }\n         }\n@@ -57,7 +57,7 @@ fn decodable_body(\n                 .enumerate()\n                 .map(|(idx, vi)| {\n                     let construct = vi.construct(|field, index| decode_field(field, index, false));\n-                    quote! { #idx => { ::std::result::Result::Ok(#construct) } }\n+                    quote! { #idx => { #construct } }\n                 })\n                 .collect();\n             let names: TokenStream = variants\n@@ -82,8 +82,7 @@ fn decodable_body(\n                             |__decoder, __variant_idx| {\n                                 match __variant_idx {\n                                     #match_inner\n-                                    _ => return ::std::result::Result::Err(\n-                                        ::rustc_serialize::Decoder::error(__decoder, #message)),\n+                                    _ => panic!(#message),\n                                 }\n                             })\n                     }\n@@ -95,9 +94,7 @@ fn decodable_body(\n     s.bound_impl(\n         quote!(::rustc_serialize::Decodable<#decoder_ty>),\n         quote! {\n-            fn decode(\n-                __decoder: &mut #decoder_ty,\n-            ) -> ::std::result::Result<Self, <#decoder_ty as ::rustc_serialize::Decoder>::Error> {\n+            fn decode(__decoder: &mut #decoder_ty) -> Self {\n                 #decode_body\n             }\n         },\n@@ -127,12 +124,7 @@ fn decode_field(field: &syn::Field, index: usize, is_struct: bool) -> proc_macro\n                 #__decoder, #opt_field_name #decode_inner_method)\n     };\n \n-    quote! {\n-        match #decode_call  {\n-            ::std::result::Result::Ok(__res) => __res,\n-            ::std::result::Result::Err(__err) => return ::std::result::Result::Err(__err),\n-        }\n-    }\n+    quote! { #decode_call }\n }\n \n pub fn type_encodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {"}, {"sha": "5474d92072ee11e144d3baa91ba3c1140f62da69", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 42, "deletions": 49, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -263,7 +263,7 @@ impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Lazy<T> {\n     fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> T {\n         let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n-        T::decode(&mut dcx).unwrap()\n+        T::decode(&mut dcx)\n     }\n }\n \n@@ -274,7 +274,7 @@ impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable<DecodeContext<'a, 'tcx>>> Lazy<[T]> {\n     ) -> impl ExactSizeIterator<Item = T> + Captures<'a> + Captures<'tcx> + 'x {\n         let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n-        (0..self.meta).map(move |_| T::decode(&mut dcx).unwrap())\n+        (0..self.meta).map(move |_| T::decode(&mut dcx))\n     }\n }\n \n@@ -300,11 +300,8 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         if cnum == LOCAL_CRATE { self.cdata().cnum } else { self.cdata().cnum_map[cnum] }\n     }\n \n-    fn read_lazy_with_meta<T: ?Sized + LazyMeta>(\n-        &mut self,\n-        meta: T::Meta,\n-    ) -> Result<Lazy<T>, <Self as Decoder>::Error> {\n-        let distance = self.read_usize()?;\n+    fn read_lazy_with_meta<T: ?Sized + LazyMeta>(&mut self, meta: T::Meta) -> Lazy<T> {\n+        let distance = self.read_usize();\n         let position = match self.lazy_state {\n             LazyState::NoNode => bug!(\"read_lazy_with_meta: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n@@ -315,7 +312,7 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n             LazyState::Previous(last_pos) => last_pos.get() + distance,\n         };\n         self.lazy_state = LazyState::Previous(NonZeroUsize::new(position).unwrap());\n-        Ok(Lazy::from_position_and_meta(NonZeroUsize::new(position).unwrap(), meta))\n+        Lazy::from_position_and_meta(NonZeroUsize::new(position).unwrap(), meta)\n     }\n \n     #[inline]\n@@ -342,25 +339,21 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n         self.opaque.position()\n     }\n \n-    fn cached_ty_for_shorthand<F>(\n-        &mut self,\n-        shorthand: usize,\n-        or_insert_with: F,\n-    ) -> Result<Ty<'tcx>, Self::Error>\n+    fn cached_ty_for_shorthand<F>(&mut self, shorthand: usize, or_insert_with: F) -> Ty<'tcx>\n     where\n-        F: FnOnce(&mut Self) -> Result<Ty<'tcx>, Self::Error>,\n+        F: FnOnce(&mut Self) -> Ty<'tcx>,\n     {\n         let tcx = self.tcx();\n \n         let key = ty::CReaderCacheKey { cnum: Some(self.cdata().cnum), pos: shorthand };\n \n         if let Some(&ty) = tcx.ty_rcache.borrow().get(&key) {\n-            return Ok(ty);\n+            return ty;\n         }\n \n-        let ty = or_insert_with(self)?;\n+        let ty = or_insert_with(self);\n         tcx.ty_rcache.borrow_mut().insert(key, ty);\n-        Ok(ty)\n+        ty\n     }\n \n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n@@ -376,7 +369,7 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n         r\n     }\n \n-    fn decode_alloc_id(&mut self) -> Result<rustc_middle::mir::interpret::AllocId, Self::Error> {\n+    fn decode_alloc_id(&mut self) -> rustc_middle::mir::interpret::AllocId {\n         if let Some(alloc_decoding_session) = self.alloc_decoding_session {\n             alloc_decoding_session.decode_alloc_id(self)\n         } else {\n@@ -386,48 +379,48 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for CrateNum {\n-    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<CrateNum, String> {\n-        let cnum = CrateNum::from_u32(d.read_u32()?);\n-        Ok(d.map_encoded_cnum_to_current(cnum))\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> CrateNum {\n+        let cnum = CrateNum::from_u32(d.read_u32());\n+        d.map_encoded_cnum_to_current(cnum)\n     }\n }\n \n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefIndex {\n-    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<DefIndex, String> {\n-        Ok(DefIndex::from_u32(d.read_u32()?))\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> DefIndex {\n+        DefIndex::from_u32(d.read_u32())\n     }\n }\n \n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnIndex {\n-    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<ExpnIndex, String> {\n-        Ok(ExpnIndex::from_u32(d.read_u32()?))\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> ExpnIndex {\n+        ExpnIndex::from_u32(d.read_u32())\n     }\n }\n \n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for SyntaxContext {\n-    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<SyntaxContext, String> {\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> SyntaxContext {\n         let cdata = decoder.cdata();\n         let sess = decoder.sess.unwrap();\n         let cname = cdata.root.name;\n         rustc_span::hygiene::decode_syntax_context(decoder, &cdata.hygiene_context, |_, id| {\n             debug!(\"SpecializedDecoder<SyntaxContext>: decoding {}\", id);\n-            Ok(cdata\n+            cdata\n                 .root\n                 .syntax_contexts\n                 .get(cdata, id)\n                 .unwrap_or_else(|| panic!(\"Missing SyntaxContext {:?} for crate {:?}\", id, cname))\n-                .decode((cdata, sess)))\n+                .decode((cdata, sess))\n         })\n     }\n }\n \n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n-    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<ExpnId, String> {\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> ExpnId {\n         let local_cdata = decoder.cdata();\n         let sess = decoder.sess.unwrap();\n \n-        let cnum = CrateNum::decode(decoder)?;\n-        let index = u32::decode(decoder)?;\n+        let cnum = CrateNum::decode(decoder);\n+        let index = u32::decode(decoder);\n \n         let expn_id = rustc_span::hygiene::decode_expn_id(cnum, index, |expn_id| {\n             let ExpnId { krate: cnum, local_id: index } = expn_id;\n@@ -453,23 +446,23 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n                 .decode((crate_data, sess));\n             (expn_data, expn_hash)\n         });\n-        Ok(expn_id)\n+        expn_id\n     }\n }\n \n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n-    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<Span, String> {\n-        let ctxt = SyntaxContext::decode(decoder)?;\n-        let tag = u8::decode(decoder)?;\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Span {\n+        let ctxt = SyntaxContext::decode(decoder);\n+        let tag = u8::decode(decoder);\n \n         if tag == TAG_PARTIAL_SPAN {\n-            return Ok(DUMMY_SP.with_ctxt(ctxt));\n+            return DUMMY_SP.with_ctxt(ctxt);\n         }\n \n         debug_assert!(tag == TAG_VALID_SPAN_LOCAL || tag == TAG_VALID_SPAN_FOREIGN);\n \n-        let lo = BytePos::decode(decoder)?;\n-        let len = BytePos::decode(decoder)?;\n+        let lo = BytePos::decode(decoder);\n+        let len = BytePos::decode(decoder);\n         let hi = lo + len;\n \n         let Some(sess) = decoder.sess else {\n@@ -512,15 +505,15 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n             if decoder.cdata().root.is_proc_macro_crate() {\n                 // Decode `CrateNum` as u32 - using `CrateNum::decode` will ICE\n                 // since we don't have `cnum_map` populated.\n-                let cnum = u32::decode(decoder)?;\n+                let cnum = u32::decode(decoder);\n                 panic!(\n                     \"Decoding of crate {:?} tried to access proc-macro dep {:?}\",\n                     decoder.cdata().root.name,\n                     cnum\n                 );\n             }\n             // tag is TAG_VALID_SPAN_FOREIGN, checked by `debug_assert` above\n-            let cnum = CrateNum::decode(decoder)?;\n+            let cnum = CrateNum::decode(decoder);\n             debug!(\n                 \"SpecializedDecoder<Span>::specialized_decode: loading source files from cnum {:?}\",\n                 cnum\n@@ -582,36 +575,36 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n             (hi + source_file.translated_source_file.start_pos) - source_file.original_start_pos;\n \n         // Do not try to decode parent for foreign spans.\n-        Ok(Span::new(lo, hi, ctxt, None))\n+        Span::new(lo, hi, ctxt, None)\n     }\n }\n \n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n-    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Self {\n         ty::codec::RefDecodable::decode(d)\n     }\n }\n \n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n-    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Self {\n         ty::codec::RefDecodable::decode(d)\n     }\n }\n \n impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Decodable<DecodeContext<'a, 'tcx>>\n     for Lazy<T>\n {\n-    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Self {\n         decoder.read_lazy_with_meta(())\n     }\n }\n \n impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Decodable<DecodeContext<'a, 'tcx>>\n     for Lazy<[T]>\n {\n-    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n-        let len = decoder.read_usize()?;\n-        if len == 0 { Ok(Lazy::empty()) } else { decoder.read_lazy_with_meta(len) }\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Self {\n+        let len = decoder.read_usize();\n+        if len == 0 { Lazy::empty() } else { decoder.read_lazy_with_meta(len) }\n     }\n }\n \n@@ -620,8 +613,8 @@ impl<'a, 'tcx, I: Idx, T: Decodable<DecodeContext<'a, 'tcx>>> Decodable<DecodeCo\n where\n     Option<T>: FixedSizeEncoding,\n {\n-    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n-        let len = decoder.read_usize()?;\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Self {\n+        let len = decoder.read_usize();\n         decoder.read_lazy_with_meta(len)\n     }\n }"}, {"sha": "d66f2b031a8930d5e646dfc55f408bdf8eb820d2", "filename": "compiler/rustc_metadata/src/rmeta/def_path_hash_map.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -39,11 +39,11 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for DefPathHashMapRef<'tcx> {\n }\n \n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefPathHashMapRef<'static> {\n-    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<DefPathHashMapRef<'static>, String> {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> DefPathHashMapRef<'static> {\n         // Import TyDecoder so we can access the DecodeContext::position() method\n         use crate::rustc_middle::ty::codec::TyDecoder;\n \n-        let len = d.read_usize()?;\n+        let len = d.read_usize();\n         let pos = d.position();\n         let o = OwningRef::new(d.blob().clone()).map(|x| &x[pos..pos + len]);\n \n@@ -52,7 +52,9 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefPathHashMapRef<'static>\n         // the method. We use read_raw_bytes() for that.\n         let _ = d.read_raw_bytes(len);\n \n-        let inner = odht::HashTable::from_raw_bytes(o).map_err(|e| format!(\"{}\", e))?;\n-        Ok(DefPathHashMapRef::OwnedFromMetadata(inner))\n+        let inner = odht::HashTable::from_raw_bytes(o).unwrap_or_else(|e| {\n+            panic!(\"decode error: {}\", e);\n+        });\n+        DefPathHashMapRef::OwnedFromMetadata(inner)\n     }\n }"}, {"sha": "e2f3d6e078f9767f93a38bb2110496f9aeb2eb17", "filename": "compiler/rustc_middle/src/mir/graph_cyclic_cache.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraph_cyclic_cache.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -45,8 +45,9 @@ impl<S: serialize::Encoder> serialize::Encodable<S> for GraphIsCyclicCache {\n \n impl<D: serialize::Decoder> serialize::Decodable<D> for GraphIsCyclicCache {\n     #[inline]\n-    fn decode(d: &mut D) -> Result<Self, D::Error> {\n-        serialize::Decodable::decode(d).map(|_v: ()| Self::new())\n+    fn decode(d: &mut D) -> Self {\n+        let () = serialize::Decodable::decode(d);\n+        Self::new()\n     }\n }\n "}, {"sha": "66f2c6e78a2e85c6f61eb2e8206681171d081a7a", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -273,20 +273,20 @@ pub struct AllocDecodingSession<'s> {\n \n impl<'s> AllocDecodingSession<'s> {\n     /// Decodes an `AllocId` in a thread-safe way.\n-    pub fn decode_alloc_id<'tcx, D>(&self, decoder: &mut D) -> Result<AllocId, D::Error>\n+    pub fn decode_alloc_id<'tcx, D>(&self, decoder: &mut D) -> AllocId\n     where\n         D: TyDecoder<'tcx>,\n     {\n         // Read the index of the allocation.\n-        let idx = usize::try_from(decoder.read_u32()?).unwrap();\n+        let idx = usize::try_from(decoder.read_u32()).unwrap();\n         let pos = usize::try_from(self.state.data_offsets[idx]).unwrap();\n \n         // Decode the `AllocDiscriminant` now so that we know if we have to reserve an\n         // `AllocId`.\n         let (alloc_kind, pos) = decoder.with_position(pos, |decoder| {\n-            let alloc_kind = AllocDiscriminant::decode(decoder)?;\n-            Ok((alloc_kind, decoder.position()))\n-        })?;\n+            let alloc_kind = AllocDiscriminant::decode(decoder);\n+            (alloc_kind, decoder.position())\n+        });\n \n         // Check the decoding state to see if it's already decoded or if we should\n         // decode it here.\n@@ -295,7 +295,7 @@ impl<'s> AllocDecodingSession<'s> {\n \n             match *entry {\n                 State::Done(alloc_id) => {\n-                    return Ok(alloc_id);\n+                    return alloc_id;\n                 }\n                 ref mut entry @ State::Empty => {\n                     // We are allowed to decode.\n@@ -329,7 +329,7 @@ impl<'s> AllocDecodingSession<'s> {\n                 State::InProgress(ref mut sessions, alloc_id) => {\n                     if sessions.contains(&self.session_id) {\n                         // Don't recurse.\n-                        return Ok(alloc_id);\n+                        return alloc_id;\n                     } else {\n                         // Start decoding concurrently.\n                         sessions.insert(self.session_id);\n@@ -343,37 +343,37 @@ impl<'s> AllocDecodingSession<'s> {\n         let alloc_id = decoder.with_position(pos, |decoder| {\n             match alloc_kind {\n                 AllocDiscriminant::Alloc => {\n-                    let alloc = <&'tcx Allocation as Decodable<_>>::decode(decoder)?;\n+                    let alloc = <&'tcx Allocation as Decodable<_>>::decode(decoder);\n                     // We already have a reserved `AllocId`.\n                     let alloc_id = alloc_id.unwrap();\n                     trace!(\"decoded alloc {:?}: {:#?}\", alloc_id, alloc);\n                     decoder.tcx().set_alloc_id_same_memory(alloc_id, alloc);\n-                    Ok(alloc_id)\n+                    alloc_id\n                 }\n                 AllocDiscriminant::Fn => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating fn alloc ID\");\n-                    let instance = ty::Instance::decode(decoder)?;\n+                    let instance = ty::Instance::decode(decoder);\n                     trace!(\"decoded fn alloc instance: {:?}\", instance);\n                     let alloc_id = decoder.tcx().create_fn_alloc(instance);\n-                    Ok(alloc_id)\n+                    alloc_id\n                 }\n                 AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc ID\");\n-                    let did = <DefId as Decodable<D>>::decode(decoder)?;\n+                    let did = <DefId as Decodable<D>>::decode(decoder);\n                     trace!(\"decoded static def-ID: {:?}\", did);\n                     let alloc_id = decoder.tcx().create_static_alloc(did);\n-                    Ok(alloc_id)\n+                    alloc_id\n                 }\n             }\n-        })?;\n+        });\n \n         self.state.decoding_state[idx].with_lock(|entry| {\n             *entry = State::Done(alloc_id);\n         });\n \n-        Ok(alloc_id)\n+        alloc_id\n     }\n }\n "}, {"sha": "c7b1e25b9938269c95dee39eb163c0e0791248fd", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -619,20 +619,20 @@ impl<'tcx, E: TyEncoder<'tcx>, T: Encodable<E>> Encodable<E> for ClearCrossCrate\n }\n impl<'tcx, D: TyDecoder<'tcx>, T: Decodable<D>> Decodable<D> for ClearCrossCrate<T> {\n     #[inline]\n-    fn decode(d: &mut D) -> Result<ClearCrossCrate<T>, D::Error> {\n+    fn decode(d: &mut D) -> ClearCrossCrate<T> {\n         if D::CLEAR_CROSS_CRATE {\n-            return Ok(ClearCrossCrate::Clear);\n+            return ClearCrossCrate::Clear;\n         }\n \n-        let discr = u8::decode(d)?;\n+        let discr = u8::decode(d);\n \n         match discr {\n-            TAG_CLEAR_CROSS_CRATE_CLEAR => Ok(ClearCrossCrate::Clear),\n+            TAG_CLEAR_CROSS_CRATE_CLEAR => ClearCrossCrate::Clear,\n             TAG_CLEAR_CROSS_CRATE_SET => {\n-                let val = T::decode(d)?;\n-                Ok(ClearCrossCrate::Set(val))\n+                let val = T::decode(d);\n+                ClearCrossCrate::Set(val)\n             }\n-            tag => Err(d.error(&format!(\"Invalid tag for ClearCrossCrate: {:?}\", tag))),\n+            tag => panic!(\"Invalid tag for ClearCrossCrate: {:?}\", tag),\n         }\n     }\n }"}, {"sha": "2562baac91131881e6a7aaf76e4b9ac0ccf86b23", "filename": "compiler/rustc_middle/src/mir/predecessors.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpredecessors.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -57,14 +57,15 @@ impl PredecessorCache {\n impl<S: serialize::Encoder> serialize::Encodable<S> for PredecessorCache {\n     #[inline]\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        serialize::Encodable::encode(&(), s)\n+        s.emit_unit()\n     }\n }\n \n impl<D: serialize::Decoder> serialize::Decodable<D> for PredecessorCache {\n     #[inline]\n-    fn decode(d: &mut D) -> Result<Self, D::Error> {\n-        serialize::Decodable::decode(d).map(|_v: ()| Self::new())\n+    fn decode(d: &mut D) -> Self {\n+        let () = d.read_unit();\n+        Self::new()\n     }\n }\n "}, {"sha": "65b91eedf8a27e066998e779c373b69d6c6d8990", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 85, "deletions": 97, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -14,7 +14,7 @@ use crate::mir::{\n };\n use crate::thir;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, List, Ty, TyCtxt};\n+use crate::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::Span;\n@@ -71,7 +71,7 @@ pub trait TyEncoder<'tcx>: Encoder {\n /// `Decodable` can still be implemented in cases where `Decodable` is required\n /// by a trait bound.\n pub trait RefDecodable<'tcx, D: TyDecoder<'tcx>> {\n-    fn decode(d: &mut D) -> Result<&'tcx Self, D::Error>;\n+    fn decode(d: &mut D) -> &'tcx Self;\n }\n \n /// Encode the given value or a previously cached shorthand.\n@@ -172,13 +172,9 @@ pub trait TyDecoder<'tcx>: Decoder {\n \n     fn position(&self) -> usize;\n \n-    fn cached_ty_for_shorthand<F>(\n-        &mut self,\n-        shorthand: usize,\n-        or_insert_with: F,\n-    ) -> Result<Ty<'tcx>, Self::Error>\n+    fn cached_ty_for_shorthand<F>(&mut self, shorthand: usize, or_insert_with: F) -> Ty<'tcx>\n     where\n-        F: FnOnce(&mut Self) -> Result<Ty<'tcx>, Self::Error>;\n+        F: FnOnce(&mut Self) -> Ty<'tcx>;\n \n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n     where\n@@ -188,35 +184,35 @@ pub trait TyDecoder<'tcx>: Decoder {\n         (self.peek_byte() & (SHORTHAND_OFFSET as u8)) != 0\n     }\n \n-    fn decode_alloc_id(&mut self) -> Result<AllocId, Self::Error>;\n+    fn decode_alloc_id(&mut self) -> AllocId;\n }\n \n #[inline]\n fn decode_arena_allocable<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n     decoder: &mut D,\n-) -> Result<&'tcx T, D::Error>\n+) -> &'tcx T\n where\n     D: TyDecoder<'tcx>,\n {\n-    Ok(decoder.tcx().arena.alloc(Decodable::decode(decoder)?))\n+    decoder.tcx().arena.alloc(Decodable::decode(decoder))\n }\n \n #[inline]\n fn decode_arena_allocable_slice<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n     decoder: &mut D,\n-) -> Result<&'tcx [T], D::Error>\n+) -> &'tcx [T]\n where\n     D: TyDecoder<'tcx>,\n {\n-    Ok(decoder.tcx().arena.alloc_from_iter(<Vec<T> as Decodable<D>>::decode(decoder)?))\n+    decoder.tcx().arena.alloc_from_iter(<Vec<T> as Decodable<D>>::decode(decoder))\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for Ty<'tcx> {\n     #[allow(rustc::usage_of_ty_tykind)]\n-    fn decode(decoder: &mut D) -> Result<Ty<'tcx>, D::Error> {\n+    fn decode(decoder: &mut D) -> Ty<'tcx> {\n         // Handle shorthands first, if we have a usize > 0x80.\n         if decoder.positioned_at_shorthand() {\n-            let pos = decoder.read_usize()?;\n+            let pos = decoder.read_usize();\n             assert!(pos >= SHORTHAND_OFFSET);\n             let shorthand = pos - SHORTHAND_OFFSET;\n \n@@ -225,165 +221,163 @@ impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for Ty<'tcx> {\n             })\n         } else {\n             let tcx = decoder.tcx();\n-            Ok(tcx.mk_ty(ty::TyKind::decode(decoder)?))\n+            tcx.mk_ty(ty::TyKind::decode(decoder))\n         }\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n-    fn decode(decoder: &mut D) -> Result<ty::Binder<'tcx, ty::PredicateKind<'tcx>>, D::Error> {\n-        let bound_vars = Decodable::decode(decoder)?;\n+    fn decode(decoder: &mut D) -> ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n+        let bound_vars = Decodable::decode(decoder);\n         // Handle shorthands first, if we have a usize > 0x80.\n-        Ok(ty::Binder::bind_with_vars(\n+        ty::Binder::bind_with_vars(\n             if decoder.positioned_at_shorthand() {\n-                let pos = decoder.read_usize()?;\n+                let pos = decoder.read_usize();\n                 assert!(pos >= SHORTHAND_OFFSET);\n                 let shorthand = pos - SHORTHAND_OFFSET;\n \n-                decoder.with_position(shorthand, ty::PredicateKind::decode)?\n+                decoder.with_position(shorthand, ty::PredicateKind::decode)\n             } else {\n-                ty::PredicateKind::decode(decoder)?\n+                ty::PredicateKind::decode(decoder)\n             },\n             bound_vars,\n-        ))\n+        )\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Predicate<'tcx> {\n-    fn decode(decoder: &mut D) -> Result<ty::Predicate<'tcx>, D::Error> {\n-        let predicate_kind = Decodable::decode(decoder)?;\n-        let predicate = decoder.tcx().mk_predicate(predicate_kind);\n-        Ok(predicate)\n+    fn decode(decoder: &mut D) -> ty::Predicate<'tcx> {\n+        let predicate_kind = Decodable::decode(decoder);\n+        decoder.tcx().mk_predicate(predicate_kind)\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for SubstsRef<'tcx> {\n-    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n-        let len = decoder.read_usize()?;\n+    fn decode(decoder: &mut D) -> Self {\n+        let len = decoder.read_usize();\n         let tcx = decoder.tcx();\n-        tcx.mk_substs((0..len).map(|_| Decodable::decode(decoder)))\n+        tcx.mk_substs(\n+            (0..len).map::<ty::subst::GenericArg<'tcx>, _>(|_| Decodable::decode(decoder)),\n+        )\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for mir::Place<'tcx> {\n-    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n-        let local: mir::Local = Decodable::decode(decoder)?;\n-        let len = decoder.read_usize()?;\n-        let projection: &'tcx List<mir::PlaceElem<'tcx>> =\n-            decoder.tcx().mk_place_elems((0..len).map(|_| Decodable::decode(decoder)))?;\n-        Ok(mir::Place { local, projection })\n+    fn decode(decoder: &mut D) -> Self {\n+        let local: mir::Local = Decodable::decode(decoder);\n+        let len = decoder.read_usize();\n+        let projection = decoder.tcx().mk_place_elems(\n+            (0..len).map::<mir::PlaceElem<'tcx>, _>(|_| Decodable::decode(decoder)),\n+        );\n+        mir::Place { local, projection }\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Region<'tcx> {\n-    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n-        Ok(decoder.tcx().mk_region(Decodable::decode(decoder)?))\n+    fn decode(decoder: &mut D) -> Self {\n+        decoder.tcx().mk_region(Decodable::decode(decoder))\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for CanonicalVarInfos<'tcx> {\n-    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n-        let len = decoder.read_usize()?;\n-        let interned: Result<Vec<CanonicalVarInfo<'tcx>>, _> =\n+    fn decode(decoder: &mut D) -> Self {\n+        let len = decoder.read_usize();\n+        let interned: Vec<CanonicalVarInfo<'tcx>> =\n             (0..len).map(|_| Decodable::decode(decoder)).collect();\n-        Ok(decoder.tcx().intern_canonical_var_infos(interned?.as_slice()))\n+        decoder.tcx().intern_canonical_var_infos(interned.as_slice())\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for AllocId {\n-    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+    fn decode(decoder: &mut D) -> Self {\n         decoder.decode_alloc_id()\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::SymbolName<'tcx> {\n-    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n-        Ok(ty::SymbolName::new(decoder.tcx(), &decoder.read_str()?))\n+    fn decode(decoder: &mut D) -> Self {\n+        ty::SymbolName::new(decoder.tcx(), &decoder.read_str())\n     }\n }\n \n macro_rules! impl_decodable_via_ref {\n     ($($t:ty),+) => {\n         $(impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for $t {\n-            fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+            fn decode(decoder: &mut D) -> Self {\n                 RefDecodable::decode(decoder)\n             }\n         })*\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<Ty<'tcx>> {\n-    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n-        let len = decoder.read_usize()?;\n-        decoder.tcx().mk_type_list((0..len).map(|_| Decodable::decode(decoder)))\n+    fn decode(decoder: &mut D) -> &'tcx Self {\n+        let len = decoder.read_usize();\n+        decoder.tcx().mk_type_list((0..len).map::<Ty<'tcx>, _>(|_| Decodable::decode(decoder)))\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D>\n     for ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>\n {\n-    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n-        let len = decoder.read_usize()?;\n-        decoder.tcx().mk_poly_existential_predicates((0..len).map(|_| Decodable::decode(decoder)))\n+    fn decode(decoder: &mut D) -> &'tcx Self {\n+        let len = decoder.read_usize();\n+        decoder.tcx().mk_poly_existential_predicates(\n+            (0..len).map::<ty::Binder<'tcx, _>, _>(|_| Decodable::decode(decoder)),\n+        )\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::Const<'tcx> {\n-    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n-        Ok(decoder.tcx().mk_const(Decodable::decode(decoder)?))\n+    fn decode(decoder: &mut D) -> &'tcx Self {\n+        decoder.tcx().mk_const(Decodable::decode(decoder))\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [ty::ValTree<'tcx>] {\n-    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n-        Ok(decoder.tcx().arena.alloc_from_iter(\n-            (0..decoder.read_usize()?)\n-                .map(|_| Decodable::decode(decoder))\n-                .collect::<Result<Vec<_>, _>>()?,\n-        ))\n+    fn decode(decoder: &mut D) -> &'tcx Self {\n+        decoder.tcx().arena.alloc_from_iter(\n+            (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n+        )\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for Allocation {\n-    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n-        Ok(decoder.tcx().intern_const_alloc(Decodable::decode(decoder)?))\n+    fn decode(decoder: &mut D) -> &'tcx Self {\n+        decoder.tcx().intern_const_alloc(Decodable::decode(decoder))\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [(ty::Predicate<'tcx>, Span)] {\n-    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n-        Ok(decoder.tcx().arena.alloc_from_iter(\n-            (0..decoder.read_usize()?)\n-                .map(|_| Decodable::decode(decoder))\n-                .collect::<Result<Vec<_>, _>>()?,\n-        ))\n+    fn decode(decoder: &mut D) -> &'tcx Self {\n+        decoder.tcx().arena.alloc_from_iter(\n+            (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n+        )\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [thir::abstract_const::Node<'tcx>] {\n-    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n-        Ok(decoder.tcx().arena.alloc_from_iter(\n-            (0..decoder.read_usize()?)\n-                .map(|_| Decodable::decode(decoder))\n-                .collect::<Result<Vec<_>, _>>()?,\n-        ))\n+    fn decode(decoder: &mut D) -> &'tcx Self {\n+        decoder.tcx().arena.alloc_from_iter(\n+            (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n+        )\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [thir::abstract_const::NodeId] {\n-    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n-        Ok(decoder.tcx().arena.alloc_from_iter(\n-            (0..decoder.read_usize()?)\n-                .map(|_| Decodable::decode(decoder))\n-                .collect::<Result<Vec<_>, _>>()?,\n-        ))\n+    fn decode(decoder: &mut D) -> &'tcx Self {\n+        decoder.tcx().arena.alloc_from_iter(\n+            (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n+        )\n     }\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<ty::BoundVariableKind> {\n-    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n-        let len = decoder.read_usize()?;\n-        decoder.tcx().mk_bound_variable_kinds((0..len).map(|_| Decodable::decode(decoder)))\n+    fn decode(decoder: &mut D) -> &'tcx Self {\n+        let len = decoder.read_usize();\n+        decoder.tcx().mk_bound_variable_kinds(\n+            (0..len).map::<ty::BoundVariableKind, _>(|_| Decodable::decode(decoder)),\n+        )\n     }\n }\n \n@@ -405,7 +399,7 @@ macro_rules! __impl_decoder_methods {\n     ($($name:ident -> $ty:ty;)*) => {\n         $(\n             #[inline]\n-            fn $name(&mut self) -> Result<$ty, Self::Error> {\n+            fn $name(&mut self) -> $ty {\n                 self.opaque.$name()\n             }\n         )*\n@@ -418,14 +412,14 @@ macro_rules! impl_arena_allocatable_decoder {\n      [$name:ident: $ty:ty]) => {\n         impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for $ty {\n             #[inline]\n-            fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+            fn decode(decoder: &mut D) -> &'tcx Self {\n                 decode_arena_allocable(decoder)\n             }\n         }\n \n         impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [$ty] {\n             #[inline]\n-            fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+            fn decode(decoder: &mut D) -> &'tcx Self {\n                 decode_arena_allocable_slice(decoder)\n             }\n         }\n@@ -456,10 +450,8 @@ macro_rules! implement_ty_decoder {\n             use super::$DecoderName;\n \n             impl<$($typaram ),*> Decoder for $DecoderName<$($typaram),*> {\n-                type Error = String;\n-\n                 $crate::__impl_decoder_methods! {\n-                    read_nil -> ();\n+                    read_unit -> ();\n \n                     read_u128 -> u128;\n                     read_u64 -> u64;\n@@ -483,13 +475,9 @@ macro_rules! implement_ty_decoder {\n                 }\n \n                 #[inline]\n-                fn read_raw_bytes_into(&mut self, bytes: &mut [u8]) -> Result<(), Self::Error> {\n+                fn read_raw_bytes_into(&mut self, bytes: &mut [u8]) {\n                     self.opaque.read_raw_bytes_into(bytes)\n                 }\n-\n-                fn error(&mut self, err: &str) -> Self::Error {\n-                    self.opaque.error(err)\n-                }\n             }\n         }\n     }\n@@ -505,9 +493,9 @@ macro_rules! impl_binder_encode_decode {\n                 }\n             }\n             impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, $t> {\n-                fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n-                    let bound_vars = Decodable::decode(decoder)?;\n-                    Ok(ty::Binder::bind_with_vars(Decodable::decode(decoder)?, bound_vars))\n+                fn decode(decoder: &mut D) -> Self {\n+                    let bound_vars = Decodable::decode(decoder);\n+                    ty::Binder::bind_with_vars(Decodable::decode(decoder), bound_vars)\n                 }\n             }\n         )*"}, {"sha": "de45e1bb851ac4c601d864c50d5ab1bc56cbd798", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -147,8 +147,8 @@ impl<S: Encoder> Encodable<S> for ScalarInt {\n }\n \n impl<D: Decoder> Decodable<D> for ScalarInt {\n-    fn decode(d: &mut D) -> Result<ScalarInt, D::Error> {\n-        Ok(ScalarInt { data: d.read_u128()?, size: d.read_u8()? })\n+    fn decode(d: &mut D) -> ScalarInt {\n+        ScalarInt { data: d.read_u128(), size: d.read_u8() }\n     }\n }\n "}, {"sha": "6c8573805cb9485f045cb147b3ed8fc39ceead05", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -2794,8 +2794,33 @@ pub trait InternIteratorElement<T, R>: Sized {\n \n impl<T, R> InternIteratorElement<T, R> for T {\n     type Output = R;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n-        f(&iter.collect::<SmallVec<[_; 8]>>())\n+    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(\n+        mut iter: I,\n+        f: F,\n+    ) -> Self::Output {\n+        // This code is hot enough that it's worth specializing for the most\n+        // common length lists, to avoid the overhead of `SmallVec` creation.\n+        // Lengths 0, 1, and 2 typically account for ~95% of cases. If\n+        // `size_hint` is incorrect a panic will occur via an `unwrap` or an\n+        // `assert`.\n+        match iter.size_hint() {\n+            (0, Some(0)) => {\n+                assert!(iter.next().is_none());\n+                f(&[])\n+            }\n+            (1, Some(1)) => {\n+                let t0 = iter.next().unwrap();\n+                assert!(iter.next().is_none());\n+                f(&[t0])\n+            }\n+            (2, Some(2)) => {\n+                let t0 = iter.next().unwrap();\n+                let t1 = iter.next().unwrap();\n+                assert!(iter.next().is_none());\n+                f(&[t0, t1])\n+            }\n+            _ => f(&iter.collect::<SmallVec<[_; 8]>>()),\n+        }\n     }\n }\n \n@@ -2805,6 +2830,7 @@ where\n {\n     type Output = R;\n     fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n+        // This code isn't hot.\n         f(&iter.cloned().collect::<SmallVec<[_; 8]>>())\n     }\n }\n@@ -2817,10 +2843,15 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n     ) -> Self::Output {\n         // This code is hot enough that it's worth specializing for the most\n         // common length lists, to avoid the overhead of `SmallVec` creation.\n-        // The match arms are in order of frequency. The 1, 2, and 0 cases are\n-        // typically hit in ~95% of cases. We assume that if the upper and\n-        // lower bounds from `size_hint` agree they are correct.\n+        // Lengths 0, 1, and 2 typically account for ~95% of cases. If\n+        // `size_hint` is incorrect a panic will occur via an `unwrap` or an\n+        // `assert`, unless a failure happens first, in which case the result\n+        // will be an error anyway.\n         Ok(match iter.size_hint() {\n+            (0, Some(0)) => {\n+                assert!(iter.next().is_none());\n+                f(&[])\n+            }\n             (1, Some(1)) => {\n                 let t0 = iter.next().unwrap()?;\n                 assert!(iter.next().is_none());\n@@ -2832,10 +2863,6 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n                 assert!(iter.next().is_none());\n                 f(&[t0, t1])\n             }\n-            (0, Some(0)) => {\n-                assert!(iter.next().is_none());\n-                f(&[])\n-            }\n             _ => f(&iter.collect::<Result<SmallVec<[_; 8]>, _>>()?),\n         })\n     }"}, {"sha": "cf97344f18e76fd63ca42fdcf3bbd610985d7f9e", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -180,8 +180,8 @@ impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for GenericArg<'tcx> {\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for GenericArg<'tcx> {\n-    fn decode(d: &mut D) -> Result<GenericArg<'tcx>, D::Error> {\n-        Ok(GenericArgKind::decode(d)?.pack())\n+    fn decode(d: &mut D) -> GenericArg<'tcx> {\n+        GenericArgKind::decode(d).pack()\n     }\n }\n "}, {"sha": "06e276ab42b3b46954e871eabafb0d761f200c6e", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 53, "deletions": 64, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -163,15 +163,12 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n             // Decode the *position* of the footer, which can be found in the\n             // last 8 bytes of the file.\n             decoder.set_position(data.len() - IntEncodedWithFixedSize::ENCODED_SIZE);\n-            let footer_pos = IntEncodedWithFixedSize::decode(&mut decoder)\n-                .expect(\"error while trying to decode footer position\")\n-                .0 as usize;\n+            let footer_pos = IntEncodedWithFixedSize::decode(&mut decoder).0 as usize;\n \n             // Decode the file footer, which contains all the lookup tables, etc.\n             decoder.set_position(footer_pos);\n \n             decode_tagged(&mut decoder, TAG_FILE_FOOTER)\n-                .expect(\"error while trying to decode footer position\")\n         };\n \n         Self {\n@@ -372,7 +369,7 @@ impl<'sess> OnDiskCache<'sess> {\n         dep_node_index: SerializedDepNodeIndex,\n     ) -> QuerySideEffects {\n         let side_effects: Option<QuerySideEffects> =\n-            self.load_indexed(tcx, dep_node_index, &self.prev_side_effects_index, \"side_effects\");\n+            self.load_indexed(tcx, dep_node_index, &self.prev_side_effects_index);\n \n         side_effects.unwrap_or_default()\n     }\n@@ -398,7 +395,7 @@ impl<'sess> OnDiskCache<'sess> {\n     where\n         T: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n-        self.load_indexed(tcx, dep_node_index, &self.query_result_index, \"query result\")\n+        self.load_indexed(tcx, dep_node_index, &self.query_result_index)\n     }\n \n     /// Stores side effect emitted during computation of an anonymous query.\n@@ -423,17 +420,13 @@ impl<'sess> OnDiskCache<'sess> {\n         tcx: TyCtxt<'tcx>,\n         dep_node_index: SerializedDepNodeIndex,\n         index: &FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n-        debug_tag: &'static str,\n     ) -> Option<T>\n     where\n         T: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n         let pos = index.get(&dep_node_index).cloned()?;\n \n-        self.with_decoder(tcx, pos, |decoder| match decode_tagged(decoder, dep_node_index) {\n-            Ok(v) => Some(v),\n-            Err(e) => bug!(\"could not decode cached {}: {}\", debug_tag, e),\n-        })\n+        self.with_decoder(tcx, pos, |decoder| Some(decode_tagged(decoder, dep_node_index)))\n     }\n \n     fn with_decoder<'a, 'tcx, T, F: for<'s> FnOnce(&mut CacheDecoder<'s, 'tcx>) -> T>(\n@@ -535,23 +528,23 @@ impl<'a, 'tcx> DecoderWithPosition for CacheDecoder<'a, 'tcx> {\n \n // Decodes something that was encoded with `encode_tagged()` and verify that the\n // tag matches and the correct amount of bytes was read.\n-fn decode_tagged<D, T, V>(decoder: &mut D, expected_tag: T) -> Result<V, D::Error>\n+fn decode_tagged<D, T, V>(decoder: &mut D, expected_tag: T) -> V\n where\n     T: Decodable<D> + Eq + std::fmt::Debug,\n     V: Decodable<D>,\n     D: DecoderWithPosition,\n {\n     let start_pos = decoder.position();\n \n-    let actual_tag = T::decode(decoder)?;\n+    let actual_tag = T::decode(decoder);\n     assert_eq!(actual_tag, expected_tag);\n-    let value = V::decode(decoder)?;\n+    let value = V::decode(decoder);\n     let end_pos = decoder.position();\n \n-    let expected_len: u64 = Decodable::decode(decoder)?;\n+    let expected_len: u64 = Decodable::decode(decoder);\n     assert_eq!((end_pos - start_pos) as u64, expected_len);\n \n-    Ok(value)\n+    value\n }\n \n impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n@@ -572,26 +565,22 @@ impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n         self.opaque.data[self.opaque.position()]\n     }\n \n-    fn cached_ty_for_shorthand<F>(\n-        &mut self,\n-        shorthand: usize,\n-        or_insert_with: F,\n-    ) -> Result<Ty<'tcx>, Self::Error>\n+    fn cached_ty_for_shorthand<F>(&mut self, shorthand: usize, or_insert_with: F) -> Ty<'tcx>\n     where\n-        F: FnOnce(&mut Self) -> Result<Ty<'tcx>, Self::Error>,\n+        F: FnOnce(&mut Self) -> Ty<'tcx>,\n     {\n         let tcx = self.tcx();\n \n         let cache_key = ty::CReaderCacheKey { cnum: None, pos: shorthand };\n \n         if let Some(&ty) = tcx.ty_rcache.borrow().get(&cache_key) {\n-            return Ok(ty);\n+            return ty;\n         }\n \n-        let ty = or_insert_with(self)?;\n+        let ty = or_insert_with(self);\n         // This may overwrite the entry, but it should overwrite with the same value.\n         tcx.ty_rcache.borrow_mut().insert_same(cache_key, ty);\n-        Ok(ty)\n+        ty\n     }\n \n     fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n@@ -607,7 +596,7 @@ impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n         r\n     }\n \n-    fn decode_alloc_id(&mut self) -> Result<interpret::AllocId, Self::Error> {\n+    fn decode_alloc_id(&mut self) -> interpret::AllocId {\n         let alloc_decoding_session = self.alloc_decoding_session;\n         alloc_decoding_session.decode_alloc_id(self)\n     }\n@@ -619,35 +608,35 @@ rustc_middle::implement_ty_decoder!(CacheDecoder<'a, 'tcx>);\n // when a `CacheDecoder` is passed to `Decodable::decode`. Unfortunately, we have to manually opt\n // into specializations this way, given how `CacheDecoder` and the decoding traits currently work.\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Vec<u8> {\n-    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         Decodable::decode(&mut d.opaque)\n     }\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for SyntaxContext {\n-    fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+    fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         let syntax_contexts = decoder.syntax_contexts;\n         rustc_span::hygiene::decode_syntax_context(decoder, decoder.hygiene_context, |this, id| {\n             // This closure is invoked if we haven't already decoded the data for the `SyntaxContext` we are deserializing.\n             // We look up the position of the associated `SyntaxData` and decode it.\n             let pos = syntax_contexts.get(&id).unwrap();\n             this.with_position(pos.to_usize(), |decoder| {\n-                let data: SyntaxContextData = decode_tagged(decoder, TAG_SYNTAX_CONTEXT)?;\n-                Ok(data)\n+                let data: SyntaxContextData = decode_tagged(decoder, TAG_SYNTAX_CONTEXT);\n+                data\n             })\n         })\n     }\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n-    fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n-        let hash = ExpnHash::decode(decoder)?;\n+    fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Self {\n+        let hash = ExpnHash::decode(decoder);\n         if hash.is_root() {\n-            return Ok(ExpnId::root());\n+            return ExpnId::root();\n         }\n \n         if let Some(expn_id) = ExpnId::from_hash(hash) {\n-            return Ok(expn_id);\n+            return expn_id;\n         }\n \n         let krate = decoder.tcx.stable_crate_id_to_crate_num(hash.stable_crate_id());\n@@ -660,7 +649,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n                 .unwrap_or_else(|| panic!(\"Bad hash {:?} (map {:?})\", hash, decoder.expn_data));\n \n             let data: ExpnData = decoder\n-                .with_position(pos.to_usize(), |decoder| decode_tagged(decoder, TAG_EXPN_DATA))?;\n+                .with_position(pos.to_usize(), |decoder| decode_tagged(decoder, TAG_EXPN_DATA));\n             let expn_id = rustc_span::hygiene::register_local_expn_id(data, hash);\n \n             #[cfg(debug_assertions)]\n@@ -687,21 +676,21 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n         };\n \n         debug_assert_eq!(expn_id.krate, krate);\n-        Ok(expn_id)\n+        expn_id\n     }\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Span {\n-    fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n-        let ctxt = SyntaxContext::decode(decoder)?;\n-        let parent = Option::<LocalDefId>::decode(decoder)?;\n-        let tag: u8 = Decodable::decode(decoder)?;\n+    fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Self {\n+        let ctxt = SyntaxContext::decode(decoder);\n+        let parent = Option::<LocalDefId>::decode(decoder);\n+        let tag: u8 = Decodable::decode(decoder);\n \n         if tag == TAG_PARTIAL_SPAN {\n-            return Ok(Span::new(BytePos(0), BytePos(0), ctxt, parent));\n+            return Span::new(BytePos(0), BytePos(0), ctxt, parent);\n         } else if tag == TAG_RELATIVE_SPAN {\n-            let dlo = u32::decode(decoder)?;\n-            let dto = u32::decode(decoder)?;\n+            let dlo = u32::decode(decoder);\n+            let dto = u32::decode(decoder);\n \n             let enclosing =\n                 decoder.tcx.definitions_untracked().def_span(parent.unwrap()).data_untracked();\n@@ -712,29 +701,29 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Span {\n                 parent,\n             );\n \n-            return Ok(span);\n+            return span;\n         } else {\n             debug_assert_eq!(tag, TAG_FULL_SPAN);\n         }\n \n-        let file_lo_index = SourceFileIndex::decode(decoder)?;\n-        let line_lo = usize::decode(decoder)?;\n-        let col_lo = BytePos::decode(decoder)?;\n-        let len = BytePos::decode(decoder)?;\n+        let file_lo_index = SourceFileIndex::decode(decoder);\n+        let line_lo = usize::decode(decoder);\n+        let col_lo = BytePos::decode(decoder);\n+        let len = BytePos::decode(decoder);\n \n         let file_lo = decoder.file_index_to_file(file_lo_index);\n         let lo = file_lo.lines[line_lo - 1] + col_lo;\n         let hi = lo + len;\n \n-        Ok(Span::new(lo, hi, ctxt, parent))\n+        Span::new(lo, hi, ctxt, parent)\n     }\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for CrateNum {\n-    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n-        let stable_id = StableCrateId::decode(d)?;\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n+        let stable_id = StableCrateId::decode(d);\n         let cnum = d.tcx.stable_crate_id_to_crate_num(stable_id);\n-        Ok(cnum)\n+        cnum\n     }\n }\n \n@@ -743,64 +732,64 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for CrateNum {\n // because we would not know how to transform the `DefIndex` to the current\n // context.\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefIndex {\n-    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<DefIndex, String> {\n-        Err(d.error(\"trying to decode `DefIndex` outside the context of a `DefId`\"))\n+    fn decode(_d: &mut CacheDecoder<'a, 'tcx>) -> DefIndex {\n+        panic!(\"trying to decode `DefIndex` outside the context of a `DefId`\")\n     }\n }\n \n // Both the `CrateNum` and the `DefIndex` of a `DefId` can change in between two\n // compilation sessions. We use the `DefPathHash`, which is stable across\n // sessions, to map the old `DefId` to the new one.\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n-    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         // Load the `DefPathHash` which is was we encoded the `DefId` as.\n-        let def_path_hash = DefPathHash::decode(d)?;\n+        let def_path_hash = DefPathHash::decode(d);\n \n         // Using the `DefPathHash`, we can lookup the new `DefId`.\n         // Subtle: We only encode a `DefId` as part of a query result.\n         // If we get to this point, then all of the query inputs were green,\n         // which means that the definition with this hash is guaranteed to\n         // still exist in the current compilation session.\n-        Ok(d.tcx().def_path_hash_to_def_id(def_path_hash, &mut || {\n+        d.tcx().def_path_hash_to_def_id(def_path_hash, &mut || {\n             panic!(\"Failed to convert DefPathHash {:?}\", def_path_hash)\n-        }))\n+        })\n     }\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx FxHashSet<LocalDefId> {\n-    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n     for &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>>\n {\n-    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [thir::abstract_const::Node<'tcx>] {\n-    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n-    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [rustc_ast::InlineAsmTemplatePiece] {\n-    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }\n }\n \n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [Span] {\n-    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)\n     }\n }"}, {"sha": "283eda7c85e647cd3f9aceb2ccb7583722e0749b", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -100,16 +100,16 @@ impl<'a, K: DepKind + Decodable<opaque::Decoder<'a>>> Decodable<opaque::Decoder<\n     for SerializedDepGraph<K>\n {\n     #[instrument(level = \"debug\", skip(d))]\n-    fn decode(d: &mut opaque::Decoder<'a>) -> Result<SerializedDepGraph<K>, String> {\n+    fn decode(d: &mut opaque::Decoder<'a>) -> SerializedDepGraph<K> {\n         let start_position = d.position();\n \n         // The last 16 bytes are the node count and edge count.\n         debug!(\"position: {:?}\", d.position());\n         d.set_position(d.data.len() - 2 * IntEncodedWithFixedSize::ENCODED_SIZE);\n         debug!(\"position: {:?}\", d.position());\n \n-        let node_count = IntEncodedWithFixedSize::decode(d)?.0 as usize;\n-        let edge_count = IntEncodedWithFixedSize::decode(d)?.0 as usize;\n+        let node_count = IntEncodedWithFixedSize::decode(d).0 as usize;\n+        let edge_count = IntEncodedWithFixedSize::decode(d).0 as usize;\n         debug!(?node_count, ?edge_count);\n \n         debug!(\"position: {:?}\", d.position());\n@@ -123,35 +123,34 @@ impl<'a, K: DepKind + Decodable<opaque::Decoder<'a>>> Decodable<opaque::Decoder<\n \n         for _index in 0..node_count {\n             d.read_struct(|d| {\n-                let dep_node: DepNode<K> = d.read_struct_field(\"node\", Decodable::decode)?;\n+                let dep_node: DepNode<K> = d.read_struct_field(\"node\", Decodable::decode);\n                 let _i: SerializedDepNodeIndex = nodes.push(dep_node);\n                 debug_assert_eq!(_i.index(), _index);\n \n                 let fingerprint: Fingerprint =\n-                    d.read_struct_field(\"fingerprint\", Decodable::decode)?;\n+                    d.read_struct_field(\"fingerprint\", Decodable::decode);\n                 let _i: SerializedDepNodeIndex = fingerprints.push(fingerprint);\n                 debug_assert_eq!(_i.index(), _index);\n \n                 d.read_struct_field(\"edges\", |d| {\n                     d.read_seq(|d, len| {\n                         let start = edge_list_data.len().try_into().unwrap();\n                         for _ in 0..len {\n-                            let edge = d.read_seq_elt(Decodable::decode)?;\n+                            let edge = d.read_seq_elt(Decodable::decode);\n                             edge_list_data.push(edge);\n                         }\n                         let end = edge_list_data.len().try_into().unwrap();\n                         let _i: SerializedDepNodeIndex = edge_list_indices.push((start, end));\n                         debug_assert_eq!(_i.index(), _index);\n-                        Ok(())\n                     })\n                 })\n-            })?;\n+            });\n         }\n \n         let index: FxHashMap<_, _> =\n             nodes.iter_enumerated().map(|(idx, &dep_node)| (dep_node, idx)).collect();\n \n-        Ok(SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data, index })\n+        SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data, index }\n     }\n }\n "}, {"sha": "02b28f7c6267770b2a52759c3a98619131142d9a", "filename": "compiler/rustc_serialize/src/collection_impls.rs", "status": "modified", "additions": 33, "deletions": 52, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -17,15 +17,8 @@ impl<S: Encoder, A: Array<Item: Encodable<S>>> Encodable<S> for SmallVec<A> {\n }\n \n impl<D: Decoder, A: Array<Item: Decodable<D>>> Decodable<D> for SmallVec<A> {\n-    fn decode(d: &mut D) -> Result<SmallVec<A>, D::Error> {\n-        d.read_seq(|d, len| {\n-            let mut vec = SmallVec::with_capacity(len);\n-            // FIXME(#48994) - could just be collected into a Result<SmallVec, D::Error>\n-            for _ in 0..len {\n-                vec.push(d.read_seq_elt(|d| Decodable::decode(d))?);\n-            }\n-            Ok(vec)\n-        })\n+    fn decode(d: &mut D) -> SmallVec<A> {\n+        d.read_seq(|d, len| (0..len).map(|_| d.read_seq_elt(|d| Decodable::decode(d))).collect())\n     }\n }\n \n@@ -41,14 +34,8 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for LinkedList<T> {\n }\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for LinkedList<T> {\n-    fn decode(d: &mut D) -> Result<LinkedList<T>, D::Error> {\n-        d.read_seq(|d, len| {\n-            let mut list = LinkedList::new();\n-            for _ in 0..len {\n-                list.push_back(d.read_seq_elt(|d| Decodable::decode(d))?);\n-            }\n-            Ok(list)\n-        })\n+    fn decode(d: &mut D) -> LinkedList<T> {\n+        d.read_seq(|d, len| (0..len).map(|_| d.read_seq_elt(|d| Decodable::decode(d))).collect())\n     }\n }\n \n@@ -64,14 +51,8 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for VecDeque<T> {\n }\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for VecDeque<T> {\n-    fn decode(d: &mut D) -> Result<VecDeque<T>, D::Error> {\n-        d.read_seq(|d, len| {\n-            let mut deque: VecDeque<T> = VecDeque::with_capacity(len);\n-            for _ in 0..len {\n-                deque.push_back(d.read_seq_elt(|d| Decodable::decode(d))?);\n-            }\n-            Ok(deque)\n-        })\n+    fn decode(d: &mut D) -> VecDeque<T> {\n+        d.read_seq(|d, len| (0..len).map(|_| d.read_seq_elt(|d| Decodable::decode(d))).collect())\n     }\n }\n \n@@ -96,15 +77,15 @@ where\n     K: Decodable<D> + PartialEq + Ord,\n     V: Decodable<D>,\n {\n-    fn decode(d: &mut D) -> Result<BTreeMap<K, V>, D::Error> {\n+    fn decode(d: &mut D) -> BTreeMap<K, V> {\n         d.read_map(|d, len| {\n             let mut map = BTreeMap::new();\n             for _ in 0..len {\n-                let key = d.read_map_elt_key(|d| Decodable::decode(d))?;\n-                let val = d.read_map_elt_val(|d| Decodable::decode(d))?;\n+                let key = d.read_map_elt_key(|d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(|d| Decodable::decode(d));\n                 map.insert(key, val);\n             }\n-            Ok(map)\n+            map\n         })\n     }\n }\n@@ -127,13 +108,13 @@ impl<D: Decoder, T> Decodable<D> for BTreeSet<T>\n where\n     T: Decodable<D> + PartialEq + Ord,\n {\n-    fn decode(d: &mut D) -> Result<BTreeSet<T>, D::Error> {\n+    fn decode(d: &mut D) -> BTreeSet<T> {\n         d.read_seq(|d, len| {\n             let mut set = BTreeSet::new();\n             for _ in 0..len {\n-                set.insert(d.read_seq_elt(|d| Decodable::decode(d))?);\n+                set.insert(d.read_seq_elt(|d| Decodable::decode(d)));\n             }\n-            Ok(set)\n+            set\n         })\n     }\n }\n@@ -161,16 +142,16 @@ where\n     V: Decodable<D>,\n     S: BuildHasher + Default,\n {\n-    fn decode(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> {\n+    fn decode(d: &mut D) -> HashMap<K, V, S> {\n         d.read_map(|d, len| {\n             let state = Default::default();\n             let mut map = HashMap::with_capacity_and_hasher(len, state);\n             for _ in 0..len {\n-                let key = d.read_map_elt_key(|d| Decodable::decode(d))?;\n-                let val = d.read_map_elt_val(|d| Decodable::decode(d))?;\n+                let key = d.read_map_elt_key(|d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(|d| Decodable::decode(d));\n                 map.insert(key, val);\n             }\n-            Ok(map)\n+            map\n         })\n     }\n }\n@@ -205,14 +186,14 @@ where\n     T: Decodable<D> + Hash + Eq,\n     S: BuildHasher + Default,\n {\n-    fn decode(d: &mut D) -> Result<HashSet<T, S>, D::Error> {\n+    fn decode(d: &mut D) -> HashSet<T, S> {\n         d.read_seq(|d, len| {\n             let state = Default::default();\n             let mut set = HashSet::with_capacity_and_hasher(len, state);\n             for _ in 0..len {\n-                set.insert(d.read_seq_elt(|d| Decodable::decode(d))?);\n+                set.insert(d.read_seq_elt(|d| Decodable::decode(d)));\n             }\n-            Ok(set)\n+            set\n         })\n     }\n }\n@@ -240,16 +221,16 @@ where\n     V: Decodable<D>,\n     S: BuildHasher + Default,\n {\n-    fn decode(d: &mut D) -> Result<indexmap::IndexMap<K, V, S>, D::Error> {\n+    fn decode(d: &mut D) -> indexmap::IndexMap<K, V, S> {\n         d.read_map(|d, len| {\n             let state = Default::default();\n             let mut map = indexmap::IndexMap::with_capacity_and_hasher(len, state);\n             for _ in 0..len {\n-                let key = d.read_map_elt_key(|d| Decodable::decode(d))?;\n-                let val = d.read_map_elt_val(|d| Decodable::decode(d))?;\n+                let key = d.read_map_elt_key(|d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(|d| Decodable::decode(d));\n                 map.insert(key, val);\n             }\n-            Ok(map)\n+            map\n         })\n     }\n }\n@@ -274,14 +255,14 @@ where\n     T: Decodable<D> + Hash + Eq,\n     S: BuildHasher + Default,\n {\n-    fn decode(d: &mut D) -> Result<indexmap::IndexSet<T, S>, D::Error> {\n+    fn decode(d: &mut D) -> indexmap::IndexSet<T, S> {\n         d.read_seq(|d, len| {\n             let state = Default::default();\n             let mut set = indexmap::IndexSet::with_capacity_and_hasher(len, state);\n             for _ in 0..len {\n-                set.insert(d.read_seq_elt(|d| Decodable::decode(d))?);\n+                set.insert(d.read_seq_elt(|d| Decodable::decode(d)));\n             }\n-            Ok(set)\n+            set\n         })\n     }\n }\n@@ -294,9 +275,9 @@ impl<E: Encoder, T: Encodable<E>> Encodable<E> for Rc<[T]> {\n }\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for Rc<[T]> {\n-    fn decode(d: &mut D) -> Result<Rc<[T]>, D::Error> {\n-        let vec: Vec<T> = Decodable::decode(d)?;\n-        Ok(vec.into())\n+    fn decode(d: &mut D) -> Rc<[T]> {\n+        let vec: Vec<T> = Decodable::decode(d);\n+        vec.into()\n     }\n }\n \n@@ -308,8 +289,8 @@ impl<E: Encoder, T: Encodable<E>> Encodable<E> for Arc<[T]> {\n }\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for Arc<[T]> {\n-    fn decode(d: &mut D) -> Result<Arc<[T]>, D::Error> {\n-        let vec: Vec<T> = Decodable::decode(d)?;\n-        Ok(vec.into())\n+    fn decode(d: &mut D) -> Arc<[T]> {\n+        let vec: Vec<T> = Decodable::decode(d);\n+        vec.into()\n     }\n }"}, {"sha": "044de8e4e24839eedd178a8dd92d56819cb26255", "filename": "compiler/rustc_serialize/src/json.rs", "status": "modified", "additions": 85, "deletions": 100, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -89,7 +89,7 @@\n //! let encoded = json::encode(&object).unwrap();\n //!\n //! // Deserialize using `json::decode`\n-//! let decoded: TestStruct = json::decode(&encoded[..]).unwrap();\n+//! let decoded: TestStruct = json::decode(&encoded[..]);\n //! ```\n //!\n //! ## Using the `ToJson` trait\n@@ -173,7 +173,7 @@\n //! let json_str: String = json_obj.to_string();\n //!\n //! // Deserialize like before\n-//! let decoded: TestStruct = json::decode(&json_str).unwrap();\n+//! let decoded: TestStruct = json::decode(&json_str);\n //! ```\n \n use self::DecoderError::*;\n@@ -265,6 +265,12 @@ pub enum DecoderError {\n     ApplicationError(string::String),\n }\n \n+macro_rules! bad {\n+    ($e:expr) => {{\n+        panic!(\"json decode error: {:?}\", $e);\n+    }};\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub enum EncoderError {\n     FmtError(fmt::Error),\n@@ -295,10 +301,10 @@ pub fn error_str(error: ErrorCode) -> &'static str {\n }\n \n /// Shortcut function to decode a JSON `&str` into an object\n-pub fn decode<T: crate::Decodable<Decoder>>(s: &str) -> DecodeResult<T> {\n+pub fn decode<T: crate::Decodable<Decoder>>(s: &str) -> T {\n     let json = match from_str(s) {\n         Ok(x) => x,\n-        Err(e) => return Err(ParseError(e)),\n+        Err(e) => bad!(ParseError(e)),\n     };\n \n     let mut decoder = Decoder::new(json);\n@@ -334,15 +340,6 @@ impl fmt::Display for ParserError {\n     }\n }\n \n-impl fmt::Display for DecoderError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // FIXME this should be a nicer error\n-        fmt::Debug::fmt(self, f)\n-    }\n-}\n-\n-impl std::error::Error for DecoderError {}\n-\n impl fmt::Display for EncoderError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // FIXME this should be a nicer error\n@@ -2206,41 +2203,39 @@ impl Decoder {\n macro_rules! expect {\n     ($e:expr, Null) => {{\n         match $e {\n-            Json::Null => Ok(()),\n-            other => Err(ExpectedError(\"Null\".to_owned(), other.to_string())),\n+            Json::Null => (),\n+            other => bad!(ExpectedError(\"Null\".to_owned(), other.to_string())),\n         }\n     }};\n     ($e:expr, $t:ident) => {{\n         match $e {\n-            Json::$t(v) => Ok(v),\n-            other => Err(ExpectedError(stringify!($t).to_owned(), other.to_string())),\n+            Json::$t(v) => v,\n+            other => bad!(ExpectedError(stringify!($t).to_owned(), other.to_string())),\n         }\n     }};\n }\n \n macro_rules! read_primitive {\n     ($name:ident, $ty:ty) => {\n-        fn $name(&mut self) -> DecodeResult<$ty> {\n+        fn $name(&mut self) -> $ty {\n             match self.pop() {\n-                Json::I64(f) => Ok(f as $ty),\n-                Json::U64(f) => Ok(f as $ty),\n-                Json::F64(f) => Err(ExpectedError(\"Integer\".to_owned(), f.to_string())),\n+                Json::I64(f) => f as $ty,\n+                Json::U64(f) => f as $ty,\n+                Json::F64(f) => bad!(ExpectedError(\"Integer\".to_owned(), f.to_string())),\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<usize, V> etc)\n                 // is going to have a string here, as per JSON spec.\n                 Json::String(s) => match s.parse().ok() {\n-                    Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_owned(), s)),\n+                    Some(f) => f,\n+                    None => bad!(ExpectedError(\"Number\".to_owned(), s)),\n                 },\n-                value => Err(ExpectedError(\"Number\".to_owned(), value.to_string())),\n+                value => bad!(ExpectedError(\"Number\".to_owned(), value.to_string())),\n             }\n         }\n     };\n }\n \n impl crate::Decoder for Decoder {\n-    type Error = DecoderError;\n-\n-    fn read_nil(&mut self) -> DecodeResult<()> {\n+    fn read_unit(&mut self) -> () {\n         expect!(self.pop(), Null)\n     }\n \n@@ -2257,156 +2252,150 @@ impl crate::Decoder for Decoder {\n     read_primitive! { read_i64, i64 }\n     read_primitive! { read_i128, i128 }\n \n-    fn read_f32(&mut self) -> DecodeResult<f32> {\n-        self.read_f64().map(|x| x as f32)\n+    fn read_f32(&mut self) -> f32 {\n+        self.read_f64() as f32\n     }\n \n-    fn read_f64(&mut self) -> DecodeResult<f64> {\n+    fn read_f64(&mut self) -> f64 {\n         match self.pop() {\n-            Json::I64(f) => Ok(f as f64),\n-            Json::U64(f) => Ok(f as f64),\n-            Json::F64(f) => Ok(f),\n+            Json::I64(f) => f as f64,\n+            Json::U64(f) => f as f64,\n+            Json::F64(f) => f,\n             Json::String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<usize, V> etc)\n                 // is going to have a string here, as per JSON spec.\n                 match s.parse().ok() {\n-                    Some(f) => Ok(f),\n-                    None => Err(ExpectedError(\"Number\".to_owned(), s)),\n+                    Some(f) => f,\n+                    None => bad!(ExpectedError(\"Number\".to_owned(), s)),\n                 }\n             }\n-            Json::Null => Ok(f64::NAN),\n-            value => Err(ExpectedError(\"Number\".to_owned(), value.to_string())),\n+            Json::Null => f64::NAN,\n+            value => bad!(ExpectedError(\"Number\".to_owned(), value.to_string())),\n         }\n     }\n \n-    fn read_bool(&mut self) -> DecodeResult<bool> {\n+    fn read_bool(&mut self) -> bool {\n         expect!(self.pop(), Boolean)\n     }\n \n-    fn read_char(&mut self) -> DecodeResult<char> {\n-        let s = self.read_str()?;\n-        {\n-            let mut it = s.chars();\n-            if let (Some(c), None) = (it.next(), it.next()) {\n-                // exactly one character\n-                return Ok(c);\n-            }\n+    fn read_char(&mut self) -> char {\n+        let s = self.read_str();\n+        let mut it = s.chars();\n+        if let (Some(c), None) = (it.next(), it.next()) {\n+            // exactly one character\n+            return c;\n         }\n-        Err(ExpectedError(\"single character string\".to_owned(), s.to_string()))\n+        bad!(ExpectedError(\"single character string\".to_owned(), s.to_string()));\n     }\n \n-    fn read_str(&mut self) -> DecodeResult<Cow<'_, str>> {\n-        expect!(self.pop(), String).map(Cow::Owned)\n+    fn read_str(&mut self) -> Cow<'_, str> {\n+        Cow::Owned(expect!(self.pop(), String))\n     }\n \n-    fn read_raw_bytes_into(&mut self, s: &mut [u8]) -> Result<(), Self::Error> {\n+    fn read_raw_bytes_into(&mut self, s: &mut [u8]) {\n         for c in s.iter_mut() {\n-            *c = self.read_u8()?;\n+            *c = self.read_u8();\n         }\n-        Ok(())\n     }\n \n-    fn read_enum<T, F>(&mut self, f: F) -> DecodeResult<T>\n+    fn read_enum<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder) -> T,\n     {\n         f(self)\n     }\n \n-    fn read_enum_variant<T, F>(&mut self, names: &[&str], mut f: F) -> DecodeResult<T>\n+    fn read_enum_variant<T, F>(&mut self, names: &[&str], mut f: F) -> T\n     where\n-        F: FnMut(&mut Decoder, usize) -> DecodeResult<T>,\n+        F: FnMut(&mut Decoder, usize) -> T,\n     {\n         let name = match self.pop() {\n             Json::String(s) => s,\n             Json::Object(mut o) => {\n                 let n = match o.remove(\"variant\") {\n                     Some(Json::String(s)) => s,\n-                    Some(val) => return Err(ExpectedError(\"String\".to_owned(), val.to_string())),\n-                    None => return Err(MissingFieldError(\"variant\".to_owned())),\n+                    Some(val) => bad!(ExpectedError(\"String\".to_owned(), val.to_string())),\n+                    None => bad!(MissingFieldError(\"variant\".to_owned())),\n                 };\n                 match o.remove(\"fields\") {\n                     Some(Json::Array(l)) => {\n                         self.stack.extend(l.into_iter().rev());\n                     }\n-                    Some(val) => return Err(ExpectedError(\"Array\".to_owned(), val.to_string())),\n-                    None => return Err(MissingFieldError(\"fields\".to_owned())),\n+                    Some(val) => bad!(ExpectedError(\"Array\".to_owned(), val.to_string())),\n+                    None => bad!(MissingFieldError(\"fields\".to_owned())),\n                 }\n                 n\n             }\n-            json => return Err(ExpectedError(\"String or Object\".to_owned(), json.to_string())),\n+            json => bad!(ExpectedError(\"String or Object\".to_owned(), json.to_string())),\n         };\n         let idx = match names.iter().position(|n| *n == &name[..]) {\n             Some(idx) => idx,\n-            None => return Err(UnknownVariantError(name)),\n+            None => bad!(UnknownVariantError(name)),\n         };\n         f(self, idx)\n     }\n \n-    fn read_enum_variant_arg<T, F>(&mut self, f: F) -> DecodeResult<T>\n+    fn read_enum_variant_arg<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder) -> T,\n     {\n         f(self)\n     }\n \n-    fn read_struct<T, F>(&mut self, f: F) -> DecodeResult<T>\n+    fn read_struct<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder) -> T,\n     {\n-        let value = f(self)?;\n+        let value = f(self);\n         self.pop();\n-        Ok(value)\n+        value\n     }\n \n-    fn read_struct_field<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T>\n+    fn read_struct_field<T, F>(&mut self, name: &str, f: F) -> T\n     where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder) -> T,\n     {\n-        let mut obj = expect!(self.pop(), Object)?;\n+        let mut obj = expect!(self.pop(), Object);\n \n         let value = match obj.remove(name) {\n             None => {\n                 // Add a Null and try to parse it as an Option<_>\n                 // to get None as a default value.\n                 self.stack.push(Json::Null);\n-                match f(self) {\n-                    Ok(x) => x,\n-                    Err(_) => return Err(MissingFieldError(name.to_string())),\n-                }\n+                f(self)\n             }\n             Some(json) => {\n                 self.stack.push(json);\n-                f(self)?\n+                f(self)\n             }\n         };\n         self.stack.push(Json::Object(obj));\n-        Ok(value)\n+        value\n     }\n \n-    fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T>\n+    fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> T\n     where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder) -> T,\n     {\n         self.read_seq(move |d, len| {\n             if len == tuple_len {\n                 f(d)\n             } else {\n-                Err(ExpectedError(format!(\"Tuple{}\", tuple_len), format!(\"Tuple{}\", len)))\n+                bad!(ExpectedError(format!(\"Tuple{}\", tuple_len), format!(\"Tuple{}\", len)));\n             }\n         })\n     }\n \n-    fn read_tuple_arg<T, F>(&mut self, f: F) -> DecodeResult<T>\n+    fn read_tuple_arg<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder) -> T,\n     {\n         self.read_seq_elt(f)\n     }\n \n-    fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T>\n+    fn read_option<T, F>(&mut self, mut f: F) -> T\n     where\n-        F: FnMut(&mut Decoder, bool) -> DecodeResult<T>,\n+        F: FnMut(&mut Decoder, bool) -> T,\n     {\n         match self.pop() {\n             Json::Null => f(self, false),\n@@ -2417,28 +2406,28 @@ impl crate::Decoder for Decoder {\n         }\n     }\n \n-    fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T>\n+    fn read_seq<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Decoder, usize) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder, usize) -> T,\n     {\n-        let array = expect!(self.pop(), Array)?;\n+        let array = expect!(self.pop(), Array);\n         let len = array.len();\n         self.stack.extend(array.into_iter().rev());\n         f(self, len)\n     }\n \n-    fn read_seq_elt<T, F>(&mut self, f: F) -> DecodeResult<T>\n+    fn read_seq_elt<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder) -> T,\n     {\n         f(self)\n     }\n \n-    fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T>\n+    fn read_map<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Decoder, usize) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder, usize) -> T,\n     {\n-        let obj = expect!(self.pop(), Object)?;\n+        let obj = expect!(self.pop(), Object);\n         let len = obj.len();\n         for (key, value) in obj {\n             self.stack.push(value);\n@@ -2447,23 +2436,19 @@ impl crate::Decoder for Decoder {\n         f(self, len)\n     }\n \n-    fn read_map_elt_key<T, F>(&mut self, f: F) -> DecodeResult<T>\n+    fn read_map_elt_key<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder) -> T,\n     {\n         f(self)\n     }\n \n-    fn read_map_elt_val<T, F>(&mut self, f: F) -> DecodeResult<T>\n+    fn read_map_elt_val<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder) -> T,\n     {\n         f(self)\n     }\n-\n-    fn error(&mut self, err: &str) -> DecoderError {\n-        ApplicationError(err.to_string())\n-    }\n }\n \n /// A trait for converting values to JSON"}, {"sha": "c272c687a7e981ba2598425c3d08357530195afb", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 40, "deletions": 48, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -560,134 +560,126 @@ impl<'a> Decoder<'a> {\n }\n \n macro_rules! read_leb128 {\n-    ($dec:expr, $fun:ident) => {{ Ok(leb128::$fun($dec.data, &mut $dec.position)) }};\n+    ($dec:expr, $fun:ident) => {{ leb128::$fun($dec.data, &mut $dec.position) }};\n }\n \n impl<'a> serialize::Decoder for Decoder<'a> {\n-    type Error = String;\n-\n     #[inline]\n-    fn read_nil(&mut self) -> Result<(), Self::Error> {\n-        Ok(())\n+    fn read_unit(&mut self) -> () {\n+        ()\n     }\n \n     #[inline]\n-    fn read_u128(&mut self) -> Result<u128, Self::Error> {\n+    fn read_u128(&mut self) -> u128 {\n         read_leb128!(self, read_u128_leb128)\n     }\n \n     #[inline]\n-    fn read_u64(&mut self) -> Result<u64, Self::Error> {\n+    fn read_u64(&mut self) -> u64 {\n         read_leb128!(self, read_u64_leb128)\n     }\n \n     #[inline]\n-    fn read_u32(&mut self) -> Result<u32, Self::Error> {\n+    fn read_u32(&mut self) -> u32 {\n         read_leb128!(self, read_u32_leb128)\n     }\n \n     #[inline]\n-    fn read_u16(&mut self) -> Result<u16, Self::Error> {\n+    fn read_u16(&mut self) -> u16 {\n         let bytes = [self.data[self.position], self.data[self.position + 1]];\n         let value = u16::from_le_bytes(bytes);\n         self.position += 2;\n-        Ok(value)\n+        value\n     }\n \n     #[inline]\n-    fn read_u8(&mut self) -> Result<u8, Self::Error> {\n+    fn read_u8(&mut self) -> u8 {\n         let value = self.data[self.position];\n         self.position += 1;\n-        Ok(value)\n+        value\n     }\n \n     #[inline]\n-    fn read_usize(&mut self) -> Result<usize, Self::Error> {\n+    fn read_usize(&mut self) -> usize {\n         read_leb128!(self, read_usize_leb128)\n     }\n \n     #[inline]\n-    fn read_i128(&mut self) -> Result<i128, Self::Error> {\n+    fn read_i128(&mut self) -> i128 {\n         read_leb128!(self, read_i128_leb128)\n     }\n \n     #[inline]\n-    fn read_i64(&mut self) -> Result<i64, Self::Error> {\n+    fn read_i64(&mut self) -> i64 {\n         read_leb128!(self, read_i64_leb128)\n     }\n \n     #[inline]\n-    fn read_i32(&mut self) -> Result<i32, Self::Error> {\n+    fn read_i32(&mut self) -> i32 {\n         read_leb128!(self, read_i32_leb128)\n     }\n \n     #[inline]\n-    fn read_i16(&mut self) -> Result<i16, Self::Error> {\n+    fn read_i16(&mut self) -> i16 {\n         let bytes = [self.data[self.position], self.data[self.position + 1]];\n         let value = i16::from_le_bytes(bytes);\n         self.position += 2;\n-        Ok(value)\n+        value\n     }\n \n     #[inline]\n-    fn read_i8(&mut self) -> Result<i8, Self::Error> {\n+    fn read_i8(&mut self) -> i8 {\n         let as_u8 = self.data[self.position];\n         self.position += 1;\n-        unsafe { Ok(::std::mem::transmute(as_u8)) }\n+        unsafe { ::std::mem::transmute(as_u8) }\n     }\n \n     #[inline]\n-    fn read_isize(&mut self) -> Result<isize, Self::Error> {\n+    fn read_isize(&mut self) -> isize {\n         read_leb128!(self, read_isize_leb128)\n     }\n \n     #[inline]\n-    fn read_bool(&mut self) -> Result<bool, Self::Error> {\n-        let value = self.read_u8()?;\n-        Ok(value != 0)\n+    fn read_bool(&mut self) -> bool {\n+        let value = self.read_u8();\n+        value != 0\n     }\n \n     #[inline]\n-    fn read_f64(&mut self) -> Result<f64, Self::Error> {\n-        let bits = self.read_u64()?;\n-        Ok(f64::from_bits(bits))\n+    fn read_f64(&mut self) -> f64 {\n+        let bits = self.read_u64();\n+        f64::from_bits(bits)\n     }\n \n     #[inline]\n-    fn read_f32(&mut self) -> Result<f32, Self::Error> {\n-        let bits = self.read_u32()?;\n-        Ok(f32::from_bits(bits))\n+    fn read_f32(&mut self) -> f32 {\n+        let bits = self.read_u32();\n+        f32::from_bits(bits)\n     }\n \n     #[inline]\n-    fn read_char(&mut self) -> Result<char, Self::Error> {\n-        let bits = self.read_u32()?;\n-        Ok(std::char::from_u32(bits).unwrap())\n+    fn read_char(&mut self) -> char {\n+        let bits = self.read_u32();\n+        std::char::from_u32(bits).unwrap()\n     }\n \n     #[inline]\n-    fn read_str(&mut self) -> Result<Cow<'_, str>, Self::Error> {\n-        let len = self.read_usize()?;\n+    fn read_str(&mut self) -> Cow<'_, str> {\n+        let len = self.read_usize();\n         let sentinel = self.data[self.position + len];\n         assert!(sentinel == STR_SENTINEL);\n         let s = unsafe {\n             std::str::from_utf8_unchecked(&self.data[self.position..self.position + len])\n         };\n         self.position += len + 1;\n-        Ok(Cow::Borrowed(s))\n-    }\n-\n-    #[inline]\n-    fn error(&mut self, err: &str) -> Self::Error {\n-        err.to_string()\n+        Cow::Borrowed(s)\n     }\n \n     #[inline]\n-    fn read_raw_bytes_into(&mut self, s: &mut [u8]) -> Result<(), String> {\n+    fn read_raw_bytes_into(&mut self, s: &mut [u8]) {\n         let start = self.position;\n         self.position += s.len();\n         s.copy_from_slice(&self.data[start..self.position]);\n-        Ok(())\n     }\n }\n \n@@ -715,9 +707,9 @@ impl serialize::Encodable<FileEncoder> for [u8] {\n // Specialize decoding `Vec<u8>`. This specialization also applies to decoding `Box<[u8]>`s, etc.,\n // since the default implementations call `decode` to produce a `Vec<u8>` internally.\n impl<'a> serialize::Decodable<Decoder<'a>> for Vec<u8> {\n-    fn decode(d: &mut Decoder<'a>) -> Result<Self, String> {\n-        let len = serialize::Decoder::read_usize(d)?;\n-        Ok(d.read_raw_bytes(len).to_owned())\n+    fn decode(d: &mut Decoder<'a>) -> Self {\n+        let len = serialize::Decoder::read_usize(d);\n+        d.read_raw_bytes(len).to_owned()\n     }\n }\n \n@@ -752,13 +744,13 @@ impl serialize::Encodable<FileEncoder> for IntEncodedWithFixedSize {\n \n impl<'a> serialize::Decodable<Decoder<'a>> for IntEncodedWithFixedSize {\n     #[inline]\n-    fn decode(decoder: &mut Decoder<'a>) -> Result<IntEncodedWithFixedSize, String> {\n+    fn decode(decoder: &mut Decoder<'a>) -> IntEncodedWithFixedSize {\n         let _start_pos = decoder.position();\n         let bytes = decoder.read_raw_bytes(IntEncodedWithFixedSize::ENCODED_SIZE);\n         let _end_pos = decoder.position();\n         debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n \n         let value = u64::from_le_bytes(bytes.try_into().unwrap());\n-        Ok(IntEncodedWithFixedSize(value))\n+        IntEncodedWithFixedSize(value)\n     }\n }"}, {"sha": "a6172403fd63d91633a5448f2d578f177c2e8338", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 113, "deletions": 108, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -173,144 +173,145 @@ pub trait Encoder {\n     }\n }\n \n+// Note: all the methods in this trait are infallible, which may be surprising.\n+// They used to be fallible (i.e. return a `Result`) but many of the impls just\n+// panicked when something went wrong, and for the cases that didn't the\n+// top-level invocation would also just panic on failure. Switching to\n+// infallibility made things faster and lots of code a little simpler and more\n+// concise.\n pub trait Decoder {\n-    type Error;\n-\n     // Primitive types:\n-    fn read_nil(&mut self) -> Result<(), Self::Error>;\n-    fn read_usize(&mut self) -> Result<usize, Self::Error>;\n-    fn read_u128(&mut self) -> Result<u128, Self::Error>;\n-    fn read_u64(&mut self) -> Result<u64, Self::Error>;\n-    fn read_u32(&mut self) -> Result<u32, Self::Error>;\n-    fn read_u16(&mut self) -> Result<u16, Self::Error>;\n-    fn read_u8(&mut self) -> Result<u8, Self::Error>;\n-    fn read_isize(&mut self) -> Result<isize, Self::Error>;\n-    fn read_i128(&mut self) -> Result<i128, Self::Error>;\n-    fn read_i64(&mut self) -> Result<i64, Self::Error>;\n-    fn read_i32(&mut self) -> Result<i32, Self::Error>;\n-    fn read_i16(&mut self) -> Result<i16, Self::Error>;\n-    fn read_i8(&mut self) -> Result<i8, Self::Error>;\n-    fn read_bool(&mut self) -> Result<bool, Self::Error>;\n-    fn read_f64(&mut self) -> Result<f64, Self::Error>;\n-    fn read_f32(&mut self) -> Result<f32, Self::Error>;\n-    fn read_char(&mut self) -> Result<char, Self::Error>;\n-    fn read_str(&mut self) -> Result<Cow<'_, str>, Self::Error>;\n-    fn read_raw_bytes_into(&mut self, s: &mut [u8]) -> Result<(), Self::Error>;\n+    fn read_unit(&mut self) -> ();\n+    fn read_usize(&mut self) -> usize;\n+    fn read_u128(&mut self) -> u128;\n+    fn read_u64(&mut self) -> u64;\n+    fn read_u32(&mut self) -> u32;\n+    fn read_u16(&mut self) -> u16;\n+    fn read_u8(&mut self) -> u8;\n+    fn read_isize(&mut self) -> isize;\n+    fn read_i128(&mut self) -> i128;\n+    fn read_i64(&mut self) -> i64;\n+    fn read_i32(&mut self) -> i32;\n+    fn read_i16(&mut self) -> i16;\n+    fn read_i8(&mut self) -> i8;\n+    fn read_bool(&mut self) -> bool;\n+    fn read_f64(&mut self) -> f64;\n+    fn read_f32(&mut self) -> f32;\n+    fn read_char(&mut self) -> char;\n+    fn read_str(&mut self) -> Cow<'_, str>;\n+    fn read_raw_bytes_into(&mut self, s: &mut [u8]);\n \n     // Compound types:\n     #[inline]\n-    fn read_enum<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n+    fn read_enum<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn read_enum_variant<T, F>(&mut self, _names: &[&str], mut f: F) -> Result<T, Self::Error>\n+    fn read_enum_variant<T, F>(&mut self, _names: &[&str], mut f: F) -> T\n     where\n-        F: FnMut(&mut Self, usize) -> Result<T, Self::Error>,\n+        F: FnMut(&mut Self, usize) -> T,\n     {\n-        let disr = self.read_usize()?;\n+        let disr = self.read_usize();\n         f(self, disr)\n     }\n \n     #[inline]\n-    fn read_enum_variant_arg<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n+    fn read_enum_variant_arg<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn read_struct<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n+    fn read_struct<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn read_struct_field<T, F>(&mut self, _f_name: &str, f: F) -> Result<T, Self::Error>\n+    fn read_struct_field<T, F>(&mut self, _f_name: &str, f: F) -> T\n     where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn read_tuple<T, F>(&mut self, _len: usize, f: F) -> Result<T, Self::Error>\n+    fn read_tuple<T, F>(&mut self, _len: usize, f: F) -> T\n     where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn read_tuple_arg<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n+    fn read_tuple_arg<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         f(self)\n     }\n \n     // Specialized types:\n-    fn read_option<T, F>(&mut self, mut f: F) -> Result<T, Self::Error>\n+    fn read_option<T, F>(&mut self, mut f: F) -> T\n     where\n-        F: FnMut(&mut Self, bool) -> Result<T, Self::Error>,\n+        F: FnMut(&mut Self, bool) -> T,\n     {\n         self.read_enum(move |this| {\n             this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| match idx {\n                 0 => f(this, false),\n                 1 => f(this, true),\n-                _ => Err(this.error(\"read_option: expected 0 for None or 1 for Some\")),\n+                _ => panic!(\"read_option: expected 0 for None or 1 for Some\"),\n             })\n         })\n     }\n \n-    fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n+    fn read_seq<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>,\n+        F: FnOnce(&mut Self, usize) -> T,\n     {\n-        let len = self.read_usize()?;\n+        let len = self.read_usize();\n         f(self, len)\n     }\n \n     #[inline]\n-    fn read_seq_elt<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n+    fn read_seq_elt<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         f(self)\n     }\n \n-    fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n+    fn read_map<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>,\n+        F: FnOnce(&mut Self, usize) -> T,\n     {\n-        let len = self.read_usize()?;\n+        let len = self.read_usize();\n         f(self, len)\n     }\n \n     #[inline]\n-    fn read_map_elt_key<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n+    fn read_map_elt_key<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn read_map_elt_val<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n+    fn read_map_elt_val<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         f(self)\n     }\n-\n-    // Failure\n-    fn error(&mut self, err: &str) -> Self::Error;\n }\n \n /// Trait for types that can be serialized\n@@ -340,7 +341,7 @@ pub trait Encodable<S: Encoder> {\n /// * `TyDecodable` should be used for types that are only serialized in crate\n ///   metadata or the incremental cache. This is most types in `rustc_middle`.\n pub trait Decodable<D: Decoder>: Sized {\n-    fn decode(d: &mut D) -> Result<Self, D::Error>;\n+    fn decode(d: &mut D) -> Self;\n }\n \n macro_rules! direct_serialize_impls {\n@@ -353,7 +354,7 @@ macro_rules! direct_serialize_impls {\n             }\n \n             impl<D: Decoder> Decodable<D> for $ty {\n-                fn decode(d: &mut D) -> Result<$ty, D::Error> {\n+                fn decode(d: &mut D) -> $ty {\n                     d.$read_method()\n                 }\n             }\n@@ -387,7 +388,7 @@ impl<S: Encoder> Encodable<S> for ! {\n }\n \n impl<D: Decoder> Decodable<D> for ! {\n-    fn decode(_d: &mut D) -> Result<!, D::Error> {\n+    fn decode(_d: &mut D) -> ! {\n         unreachable!()\n     }\n }\n@@ -399,8 +400,8 @@ impl<S: Encoder> Encodable<S> for ::std::num::NonZeroU32 {\n }\n \n impl<D: Decoder> Decodable<D> for ::std::num::NonZeroU32 {\n-    fn decode(d: &mut D) -> Result<Self, D::Error> {\n-        d.read_u32().map(|d| ::std::num::NonZeroU32::new(d).unwrap())\n+    fn decode(d: &mut D) -> Self {\n+        ::std::num::NonZeroU32::new(d.read_u32()).unwrap()\n     }\n }\n \n@@ -423,8 +424,8 @@ impl<S: Encoder> Encodable<S> for String {\n }\n \n impl<D: Decoder> Decodable<D> for String {\n-    fn decode(d: &mut D) -> Result<String, D::Error> {\n-        Ok(d.read_str()?.into_owned())\n+    fn decode(d: &mut D) -> String {\n+        d.read_str().into_owned()\n     }\n }\n \n@@ -435,8 +436,8 @@ impl<S: Encoder> Encodable<S> for () {\n }\n \n impl<D: Decoder> Decodable<D> for () {\n-    fn decode(d: &mut D) -> Result<(), D::Error> {\n-        d.read_nil()\n+    fn decode(d: &mut D) -> () {\n+        d.read_unit()\n     }\n }\n \n@@ -447,16 +448,16 @@ impl<S: Encoder, T> Encodable<S> for PhantomData<T> {\n }\n \n impl<D: Decoder, T> Decodable<D> for PhantomData<T> {\n-    fn decode(d: &mut D) -> Result<PhantomData<T>, D::Error> {\n-        d.read_nil()?;\n-        Ok(PhantomData)\n+    fn decode(d: &mut D) -> PhantomData<T> {\n+        d.read_unit();\n+        PhantomData\n     }\n }\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for Box<[T]> {\n-    fn decode(d: &mut D) -> Result<Box<[T]>, D::Error> {\n-        let v: Vec<T> = Decodable::decode(d)?;\n-        Ok(v.into_boxed_slice())\n+    fn decode(d: &mut D) -> Box<[T]> {\n+        let v: Vec<T> = Decodable::decode(d);\n+        v.into_boxed_slice()\n     }\n }\n \n@@ -467,8 +468,8 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for Rc<T> {\n }\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for Rc<T> {\n-    fn decode(d: &mut D) -> Result<Rc<T>, D::Error> {\n-        Ok(Rc::new(Decodable::decode(d)?))\n+    fn decode(d: &mut D) -> Rc<T> {\n+        Rc::new(Decodable::decode(d))\n     }\n }\n \n@@ -491,13 +492,22 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for Vec<T> {\n }\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for Vec<T> {\n-    default fn decode(d: &mut D) -> Result<Vec<T>, D::Error> {\n+    default fn decode(d: &mut D) -> Vec<T> {\n         d.read_seq(|d, len| {\n-            let mut v = Vec::with_capacity(len);\n-            for _ in 0..len {\n-                v.push(d.read_seq_elt(|d| Decodable::decode(d))?);\n+            // SAFETY: we set the capacity in advance, only write elements, and\n+            // only set the length at the end once the writing has succeeded.\n+            let mut vec = Vec::with_capacity(len);\n+            unsafe {\n+                let ptr: *mut T = vec.as_mut_ptr();\n+                for i in 0..len {\n+                    std::ptr::write(\n+                        ptr.offset(i as isize),\n+                        d.read_seq_elt(|d| Decodable::decode(d)),\n+                    );\n+                }\n+                vec.set_len(len);\n             }\n-            Ok(v)\n+            vec\n         })\n     }\n }\n@@ -510,14 +520,14 @@ impl<S: Encoder, T: Encodable<S>, const N: usize> Encodable<S> for [T; N] {\n }\n \n impl<D: Decoder, const N: usize> Decodable<D> for [u8; N] {\n-    fn decode(d: &mut D) -> Result<[u8; N], D::Error> {\n+    fn decode(d: &mut D) -> [u8; N] {\n         d.read_seq(|d, len| {\n             assert!(len == N);\n             let mut v = [0u8; N];\n             for i in 0..len {\n-                v[i] = d.read_seq_elt(|d| Decodable::decode(d))?;\n+                v[i] = d.read_seq_elt(|d| Decodable::decode(d));\n             }\n-            Ok(v)\n+            v\n         })\n     }\n }\n@@ -536,9 +546,9 @@ impl<D: Decoder, T: Decodable<D> + ToOwned> Decodable<D> for Cow<'static, [T]>\n where\n     [T]: ToOwned<Owned = Vec<T>>,\n {\n-    fn decode(d: &mut D) -> Result<Cow<'static, [T]>, D::Error> {\n-        let v: Vec<T> = Decodable::decode(d)?;\n-        Ok(Cow::Owned(v))\n+    fn decode(d: &mut D) -> Cow<'static, [T]> {\n+        let v: Vec<T> = Decodable::decode(d);\n+        Cow::Owned(v)\n     }\n }\n \n@@ -552,8 +562,8 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for Option<T> {\n }\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for Option<T> {\n-    fn decode(d: &mut D) -> Result<Option<T>, D::Error> {\n-        d.read_option(|d, b| if b { Ok(Some(Decodable::decode(d)?)) } else { Ok(None) })\n+    fn decode(d: &mut D) -> Option<T> {\n+        d.read_option(|d, b| if b { Some(Decodable::decode(d)) } else { None })\n     }\n }\n \n@@ -571,17 +581,12 @@ impl<S: Encoder, T1: Encodable<S>, T2: Encodable<S>> Encodable<S> for Result<T1,\n }\n \n impl<D: Decoder, T1: Decodable<D>, T2: Decodable<D>> Decodable<D> for Result<T1, T2> {\n-    fn decode(d: &mut D) -> Result<Result<T1, T2>, D::Error> {\n+    fn decode(d: &mut D) -> Result<T1, T2> {\n         d.read_enum(|d| {\n             d.read_enum_variant(&[\"Ok\", \"Err\"], |d, disr| match disr {\n-                0 => Ok(Ok(d.read_enum_variant_arg(|d| T1::decode(d))?)),\n-                1 => Ok(Err(d.read_enum_variant_arg(|d| T2::decode(d))?)),\n-                _ => {\n-                    panic!(\n-                        \"Encountered invalid discriminant while \\\n-                                decoding `Result`.\"\n-                    );\n-                }\n+                0 => Ok(d.read_enum_variant_arg(|d| T1::decode(d))),\n+                1 => Err(d.read_enum_variant_arg(|d| T2::decode(d))),\n+                _ => panic!(\"Encountered invalid discriminant while decoding `Result`.\"),\n             })\n         })\n     }\n@@ -609,13 +614,13 @@ macro_rules! tuple {\n     ( $($name:ident,)+ ) => (\n         impl<D: Decoder, $($name: Decodable<D>),+> Decodable<D> for ($($name,)+) {\n             #[allow(non_snake_case)]\n-            fn decode(d: &mut D) -> Result<($($name,)+), D::Error> {\n+            fn decode(d: &mut D) -> ($($name,)+) {\n                 let len: usize = count!($($name)+);\n                 d.read_tuple(len, |d| {\n-                    let ret = ($(d.read_tuple_arg(|d| -> Result<$name, D::Error> {\n+                    let ret = ($(d.read_tuple_arg(|d| -> $name {\n                         Decodable::decode(d)\n-                    })?,)+);\n-                    Ok(ret)\n+                    }),)+);\n+                    ret\n                 })\n             }\n         }\n@@ -651,9 +656,9 @@ impl<S: Encoder> Encodable<S> for path::PathBuf {\n }\n \n impl<D: Decoder> Decodable<D> for path::PathBuf {\n-    fn decode(d: &mut D) -> Result<path::PathBuf, D::Error> {\n-        let bytes: String = Decodable::decode(d)?;\n-        Ok(path::PathBuf::from(bytes))\n+    fn decode(d: &mut D) -> path::PathBuf {\n+        let bytes: String = Decodable::decode(d);\n+        path::PathBuf::from(bytes)\n     }\n }\n \n@@ -664,8 +669,8 @@ impl<S: Encoder, T: Encodable<S> + Copy> Encodable<S> for Cell<T> {\n }\n \n impl<D: Decoder, T: Decodable<D> + Copy> Decodable<D> for Cell<T> {\n-    fn decode(d: &mut D) -> Result<Cell<T>, D::Error> {\n-        Ok(Cell::new(Decodable::decode(d)?))\n+    fn decode(d: &mut D) -> Cell<T> {\n+        Cell::new(Decodable::decode(d))\n     }\n }\n \n@@ -681,8 +686,8 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for RefCell<T> {\n }\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for RefCell<T> {\n-    fn decode(d: &mut D) -> Result<RefCell<T>, D::Error> {\n-        Ok(RefCell::new(Decodable::decode(d)?))\n+    fn decode(d: &mut D) -> RefCell<T> {\n+        RefCell::new(Decodable::decode(d))\n     }\n }\n \n@@ -693,8 +698,8 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for Arc<T> {\n }\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for Arc<T> {\n-    fn decode(d: &mut D) -> Result<Arc<T>, D::Error> {\n-        Ok(Arc::new(Decodable::decode(d)?))\n+    fn decode(d: &mut D) -> Arc<T> {\n+        Arc::new(Decodable::decode(d))\n     }\n }\n \n@@ -704,7 +709,7 @@ impl<S: Encoder, T: ?Sized + Encodable<S>> Encodable<S> for Box<T> {\n     }\n }\n impl<D: Decoder, T: Decodable<D>> Decodable<D> for Box<T> {\n-    fn decode(d: &mut D) -> Result<Box<T>, D::Error> {\n-        Ok(Box::new(Decodable::decode(d)?))\n+    fn decode(d: &mut D) -> Box<T> {\n+        Box::new(Decodable::decode(d))\n     }\n }"}, {"sha": "ede912bdfb6ee8f0179c8542d48e032ec5e4f16a", "filename": "compiler/rustc_serialize/tests/json.rs", "status": "modified", "additions": 106, "deletions": 102, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_serialize%2Ftests%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_serialize%2Ftests%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fjson.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -1,14 +1,10 @@\n #![allow(rustc::internal)]\n \n-use json::DecoderError::*;\n use json::ErrorCode::*;\n use json::Json::*;\n use json::JsonEvent::*;\n use json::ParserError::*;\n-use json::{\n-    from_str, DecodeResult, Decoder, DecoderError, Encoder, EncoderError, Json, JsonEvent, Parser,\n-    StackElement,\n-};\n+use json::{from_str, Decoder, Encoder, EncoderError, Json, JsonEvent, Parser, StackElement};\n use rustc_macros::{Decodable, Encodable};\n use rustc_serialize::json;\n use rustc_serialize::{Decodable, Encodable};\n@@ -26,27 +22,27 @@ struct OptionData {\n #[test]\n fn test_decode_option_none() {\n     let s = \"{}\";\n-    let obj: OptionData = json::decode(s).unwrap();\n+    let obj: OptionData = json::decode(s);\n     assert_eq!(obj, OptionData { opt: None });\n }\n \n #[test]\n fn test_decode_option_some() {\n     let s = \"{ \\\"opt\\\": 10 }\";\n-    let obj: OptionData = json::decode(s).unwrap();\n+    let obj: OptionData = json::decode(s);\n     assert_eq!(obj, OptionData { opt: Some(10) });\n }\n \n #[test]\n-fn test_decode_option_malformed() {\n-    check_err::<OptionData>(\n-        \"{ \\\"opt\\\": [] }\",\n-        ExpectedError(\"Number\".to_string(), \"[]\".to_string()),\n-    );\n-    check_err::<OptionData>(\n-        \"{ \\\"opt\\\": false }\",\n-        ExpectedError(\"Number\".to_string(), \"false\".to_string()),\n-    );\n+#[should_panic(expected = r#\"ExpectedError(\"Number\", \"[]\")\"#)]\n+fn test_decode_option_malformed1() {\n+    check_err::<OptionData>(r#\"{ \"opt\": [] }\"#);\n+}\n+\n+#[test]\n+#[should_panic(expected = r#\"ExpectedError(\"Number\", \"false\")\"#)]\n+fn test_decode_option_malformed2() {\n+    check_err::<OptionData>(r#\"{ \"opt\": false }\"#);\n }\n \n #[derive(PartialEq, Encodable, Decodable, Debug)]\n@@ -329,13 +325,13 @@ fn test_read_identifiers() {\n \n #[test]\n fn test_decode_identifiers() {\n-    let v: () = json::decode(\"null\").unwrap();\n+    let v: () = json::decode(\"null\");\n     assert_eq!(v, ());\n \n-    let v: bool = json::decode(\"true\").unwrap();\n+    let v: bool = json::decode(\"true\");\n     assert_eq!(v, true);\n \n-    let v: bool = json::decode(\"false\").unwrap();\n+    let v: bool = json::decode(\"false\");\n     assert_eq!(v, false);\n }\n \n@@ -368,42 +364,42 @@ fn test_read_number() {\n }\n \n #[test]\n+#[should_panic(expected = r#\"ExpectedError(\"Integer\", \"765.25\")\"#)]\n fn test_decode_numbers() {\n-    let v: f64 = json::decode(\"3\").unwrap();\n+    let v: f64 = json::decode(\"3\");\n     assert_eq!(v, 3.0);\n \n-    let v: f64 = json::decode(\"3.1\").unwrap();\n+    let v: f64 = json::decode(\"3.1\");\n     assert_eq!(v, 3.1);\n \n-    let v: f64 = json::decode(\"-1.2\").unwrap();\n+    let v: f64 = json::decode(\"-1.2\");\n     assert_eq!(v, -1.2);\n \n-    let v: f64 = json::decode(\"0.4\").unwrap();\n+    let v: f64 = json::decode(\"0.4\");\n     assert_eq!(v, 0.4);\n \n-    let v: f64 = json::decode(\"0.4e5\").unwrap();\n+    let v: f64 = json::decode(\"0.4e5\");\n     assert_eq!(v, 0.4e5);\n \n-    let v: f64 = json::decode(\"0.4e15\").unwrap();\n+    let v: f64 = json::decode(\"0.4e15\");\n     assert_eq!(v, 0.4e15);\n \n-    let v: f64 = json::decode(\"0.4e-01\").unwrap();\n+    let v: f64 = json::decode(\"0.4e-01\");\n     assert_eq!(v, 0.4e-01);\n \n-    let v: u64 = json::decode(\"0\").unwrap();\n+    let v: u64 = json::decode(\"0\");\n     assert_eq!(v, 0);\n \n-    let v: u64 = json::decode(\"18446744073709551615\").unwrap();\n+    let v: u64 = json::decode(\"18446744073709551615\");\n     assert_eq!(v, u64::MAX);\n \n-    let v: i64 = json::decode(\"-9223372036854775808\").unwrap();\n+    let v: i64 = json::decode(\"-9223372036854775808\");\n     assert_eq!(v, i64::MIN);\n \n-    let v: i64 = json::decode(\"9223372036854775807\").unwrap();\n+    let v: i64 = json::decode(\"9223372036854775807\");\n     assert_eq!(v, i64::MAX);\n \n-    let res: DecodeResult<i64> = json::decode(\"765.25\");\n-    assert_eq!(res, Err(ExpectedError(\"Integer\".to_string(), \"765.25\".to_string())));\n+    json::decode::<i64>(\"765.25\");\n }\n \n #[test]\n@@ -438,7 +434,7 @@ fn test_decode_str() {\n     ];\n \n     for (i, o) in s {\n-        let v: string::String = json::decode(i).unwrap();\n+        let v: string::String = json::decode(i);\n         assert_eq!(v, o);\n     }\n }\n@@ -463,39 +459,41 @@ fn test_read_array() {\n \n #[test]\n fn test_decode_array() {\n-    let v: Vec<()> = json::decode(\"[]\").unwrap();\n+    let v: Vec<()> = json::decode(\"[]\");\n     assert_eq!(v, []);\n \n-    let v: Vec<()> = json::decode(\"[null]\").unwrap();\n+    let v: Vec<()> = json::decode(\"[null]\");\n     assert_eq!(v, [()]);\n \n-    let v: Vec<bool> = json::decode(\"[true]\").unwrap();\n+    let v: Vec<bool> = json::decode(\"[true]\");\n     assert_eq!(v, [true]);\n \n-    let v: Vec<isize> = json::decode(\"[3, 1]\").unwrap();\n+    let v: Vec<isize> = json::decode(\"[3, 1]\");\n     assert_eq!(v, [3, 1]);\n \n-    let v: Vec<Vec<usize>> = json::decode(\"[[3], [1, 2]]\").unwrap();\n+    let v: Vec<Vec<usize>> = json::decode(\"[[3], [1, 2]]\");\n     assert_eq!(v, [vec![3], vec![1, 2]]);\n }\n \n #[test]\n fn test_decode_tuple() {\n-    let t: (usize, usize, usize) = json::decode(\"[1, 2, 3]\").unwrap();\n+    let t: (usize, usize, usize) = json::decode(\"[1, 2, 3]\");\n     assert_eq!(t, (1, 2, 3));\n \n-    let t: (usize, string::String) = json::decode(\"[1, \\\"two\\\"]\").unwrap();\n+    let t: (usize, string::String) = json::decode(\"[1, \\\"two\\\"]\");\n     assert_eq!(t, (1, \"two\".to_string()));\n }\n \n #[test]\n+#[should_panic]\n fn test_decode_tuple_malformed_types() {\n-    assert!(json::decode::<(usize, string::String)>(\"[1, 2]\").is_err());\n+    json::decode::<(usize, string::String)>(\"[1, 2]\");\n }\n \n #[test]\n+#[should_panic]\n fn test_decode_tuple_malformed_length() {\n-    assert!(json::decode::<(usize, usize)>(\"[1, 2, 3]\").is_err());\n+    json::decode::<(usize, usize)>(\"[1, 2, 3]\");\n }\n \n #[test]\n@@ -562,7 +560,7 @@ fn test_decode_struct() {\n         ]\n     }\";\n \n-    let v: Outer = json::decode(s).unwrap();\n+    let v: Outer = json::decode(s);\n     assert_eq!(\n         v,\n         Outer { inner: vec![Inner { a: (), b: 2, c: vec![\"abc\".to_string(), \"xyz\".to_string()] }] }\n@@ -577,36 +575,36 @@ struct FloatStruct {\n #[test]\n fn test_decode_struct_with_nan() {\n     let s = \"{\\\"f\\\":null,\\\"a\\\":[null,123]}\";\n-    let obj: FloatStruct = json::decode(s).unwrap();\n+    let obj: FloatStruct = json::decode(s);\n     assert!(obj.f.is_nan());\n     assert!(obj.a[0].is_nan());\n     assert_eq!(obj.a[1], 123f64);\n }\n \n #[test]\n fn test_decode_option() {\n-    let value: Option<string::String> = json::decode(\"null\").unwrap();\n+    let value: Option<string::String> = json::decode(\"null\");\n     assert_eq!(value, None);\n \n-    let value: Option<string::String> = json::decode(\"\\\"jodhpurs\\\"\").unwrap();\n+    let value: Option<string::String> = json::decode(\"\\\"jodhpurs\\\"\");\n     assert_eq!(value, Some(\"jodhpurs\".to_string()));\n }\n \n #[test]\n fn test_decode_enum() {\n-    let value: Animal = json::decode(\"\\\"Dog\\\"\").unwrap();\n+    let value: Animal = json::decode(\"\\\"Dog\\\"\");\n     assert_eq!(value, Dog);\n \n     let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n-    let value: Animal = json::decode(s).unwrap();\n+    let value: Animal = json::decode(s);\n     assert_eq!(value, Frog(\"Henry\".to_string(), 349));\n }\n \n #[test]\n fn test_decode_map() {\n     let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n               \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-    let mut map: BTreeMap<string::String, Animal> = json::decode(s).unwrap();\n+    let mut map: BTreeMap<string::String, Animal> = json::decode(s);\n \n     assert_eq!(map.remove(&\"a\".to_string()), Some(Dog));\n     assert_eq!(map.remove(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n@@ -630,59 +628,65 @@ enum DecodeEnum {\n     A(f64),\n     B(string::String),\n }\n-fn check_err<T: Decodable<Decoder>>(to_parse: &'static str, expected: DecoderError) {\n-    let res: DecodeResult<T> = match from_str(to_parse) {\n-        Err(e) => Err(ParseError(e)),\n-        Ok(json) => Decodable::decode(&mut Decoder::new(json)),\n-    };\n-    match res {\n-        Ok(_) => panic!(\"`{:?}` parsed & decoded ok, expecting error `{:?}`\", to_parse, expected),\n-        Err(ParseError(e)) => panic!(\"`{:?}` is not valid json: {:?}\", to_parse, e),\n-        Err(e) => {\n-            assert_eq!(e, expected);\n-        }\n-    }\n+fn check_err<T: Decodable<Decoder>>(to_parse: &str) {\n+    let json = from_str(to_parse).unwrap();\n+    let _: T = Decodable::decode(&mut Decoder::new(json));\n }\n #[test]\n-fn test_decode_errors_struct() {\n-    check_err::<DecodeStruct>(\"[]\", ExpectedError(\"Object\".to_string(), \"[]\".to_string()));\n-    check_err::<DecodeStruct>(\n-        \"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-        ExpectedError(\"Number\".to_string(), \"true\".to_string()),\n-    );\n-    check_err::<DecodeStruct>(\n-        \"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-        ExpectedError(\"Boolean\".to_string(), \"[]\".to_string()),\n-    );\n-    check_err::<DecodeStruct>(\n-        \"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n-        ExpectedError(\"String\".to_string(), \"{}\".to_string()),\n-    );\n-    check_err::<DecodeStruct>(\n-        \"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n-        ExpectedError(\"Array\".to_string(), \"null\".to_string()),\n-    );\n-    check_err::<DecodeStruct>(\n-        \"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n-        MissingFieldError(\"w\".to_string()),\n-    );\n+#[should_panic(expected = r#\"ExpectedError(\"Object\", \"[]\")\"#)]\n+fn test_decode_errors_struct1() {\n+    check_err::<DecodeStruct>(\"[]\");\n }\n #[test]\n-fn test_decode_errors_enum() {\n-    check_err::<DecodeEnum>(\"{}\", MissingFieldError(\"variant\".to_string()));\n-    check_err::<DecodeEnum>(\n-        \"{\\\"variant\\\": 1}\",\n-        ExpectedError(\"String\".to_string(), \"1\".to_string()),\n-    );\n-    check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\", MissingFieldError(\"fields\".to_string()));\n-    check_err::<DecodeEnum>(\n-        \"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n-        ExpectedError(\"Array\".to_string(), \"null\".to_string()),\n-    );\n-    check_err::<DecodeEnum>(\n-        \"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n-        UnknownVariantError(\"C\".to_string()),\n-    );\n+#[should_panic(expected = r#\"ExpectedError(\"Number\", \"true\")\"#)]\n+fn test_decode_errors_struct2() {\n+    check_err::<DecodeStruct>(r#\"{\"x\": true, \"y\": true, \"z\": \"\", \"w\": []}\"#);\n+}\n+#[test]\n+#[should_panic(expected = r#\"ExpectedError(\"Boolean\", \"[]\")\"#)]\n+fn test_decode_errors_struct3() {\n+    check_err::<DecodeStruct>(r#\"{\"x\": 1, \"y\": [], \"z\": \"\", \"w\": []}\"#);\n+}\n+#[test]\n+#[should_panic(expected = r#\"ExpectedError(\"String\", \"{}\")\"#)]\n+fn test_decode_errors_struct4() {\n+    check_err::<DecodeStruct>(r#\"{\"x\": 1, \"y\": true, \"z\": {}, \"w\": []}\"#);\n+}\n+#[test]\n+#[should_panic(expected = r#\"ExpectedError(\"Array\", \"null\")\"#)]\n+fn test_decode_errors_struct5() {\n+    check_err::<DecodeStruct>(r#\"{\"x\": 1, \"y\": true, \"z\": \"\", \"w\": null}\"#);\n+}\n+#[test]\n+#[should_panic(expected = r#\"ExpectedError(\"Array\", \"null\")\"#)]\n+fn test_decode_errors_struct6() {\n+    check_err::<DecodeStruct>(r#\"{\"x\": 1, \"y\": true, \"z\": \"\"}\"#);\n+}\n+\n+#[test]\n+#[should_panic(expected = r#\"MissingFieldError(\"variant\")\"#)]\n+fn test_decode_errors_enum1() {\n+    check_err::<DecodeEnum>(r#\"{}\"#);\n+}\n+#[test]\n+#[should_panic(expected = r#\"ExpectedError(\"String\", \"1\")\"#)]\n+fn test_decode_errors_enum2() {\n+    check_err::<DecodeEnum>(r#\"{\"variant\": 1}\"#);\n+}\n+#[test]\n+#[should_panic(expected = r#\"MissingFieldError(\"fields\")\"#)]\n+fn test_decode_errors_enum3() {\n+    check_err::<DecodeEnum>(r#\"{\"variant\": \"A\"}\"#);\n+}\n+#[test]\n+#[should_panic(expected = r#\"ExpectedError(\"Array\", \"null\")\"#)]\n+fn test_decode_errors_enum4() {\n+    check_err::<DecodeEnum>(r#\"{\"variant\": \"A\", \"fields\": null}\"#);\n+}\n+#[test]\n+#[should_panic(expected = r#\"UnknownVariantError(\"C\")\"#)]\n+fn test_decode_errors_enum5() {\n+    check_err::<DecodeEnum>(r#\"{\"variant\": \"C\", \"fields\": []}\"#);\n }\n \n #[test]\n@@ -944,7 +948,7 @@ fn test_hashmap_with_enum_key() {\n     map.insert(Enum::Foo, 0);\n     let result = json::encode(&map).unwrap();\n     assert_eq!(&result[..], r#\"{\"Foo\":0}\"#);\n-    let decoded: HashMap<Enum, _> = json::decode(&result).unwrap();\n+    let decoded: HashMap<Enum, _> = json::decode(&result);\n     assert_eq!(map, decoded);\n }\n \n@@ -957,10 +961,11 @@ fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n         Ok(o) => o,\n     };\n     let mut decoder = Decoder::new(json_obj);\n-    let _hm: HashMap<usize, bool> = Decodable::decode(&mut decoder).unwrap();\n+    let _hm: HashMap<usize, bool> = Decodable::decode(&mut decoder);\n }\n \n #[test]\n+#[should_panic(expected = r#\"ExpectedError(\"Number\", \"a\")\"#)]\n fn test_hashmap_with_numeric_key_will_error_with_string_keys() {\n     use std::collections::HashMap;\n     let json_str = \"{\\\"a\\\":true}\";\n@@ -969,8 +974,7 @@ fn test_hashmap_with_numeric_key_will_error_with_string_keys() {\n         Ok(o) => o,\n     };\n     let mut decoder = Decoder::new(json_obj);\n-    let result: Result<HashMap<usize, bool>, DecoderError> = Decodable::decode(&mut decoder);\n-    assert_eq!(result, Err(ExpectedError(\"Number\".to_string(), \"a\".to_string())));\n+    let _: HashMap<usize, bool> = Decodable::decode(&mut decoder);\n }\n \n fn assert_stream_equal(src: &str, expected: Vec<(JsonEvent, Vec<StackElement<'_>>)>) {"}, {"sha": "298eb1151118a8dc935337f75f7effb8038e7d36", "filename": "compiler/rustc_serialize/tests/opaque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -41,7 +41,7 @@ fn check_round_trip<T: Encodable<Encoder> + for<'a> Decodable<Decoder<'a>> + Par\n     let mut decoder = Decoder::new(&data[..], 0);\n \n     for value in values {\n-        let decoded = Decodable::decode(&mut decoder).unwrap();\n+        let decoded = Decodable::decode(&mut decoder);\n         assert_eq!(value, decoded);\n     }\n }"}, {"sha": "147c1f9e043395d99a6d611f785f3ed76ea64f1b", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -47,8 +47,8 @@ impl<E: Encoder> Encodable<E> for CrateNum {\n }\n \n impl<D: Decoder> Decodable<D> for CrateNum {\n-    default fn decode(d: &mut D) -> Result<CrateNum, D::Error> {\n-        Ok(CrateNum::from_u32(d.read_u32()?))\n+    default fn decode(d: &mut D) -> CrateNum {\n+        CrateNum::from_u32(d.read_u32())\n     }\n }\n \n@@ -209,7 +209,7 @@ impl<E: Encoder> Encodable<E> for DefIndex {\n }\n \n impl<D: Decoder> Decodable<D> for DefIndex {\n-    default fn decode(_: &mut D) -> Result<DefIndex, D::Error> {\n+    default fn decode(_: &mut D) -> DefIndex {\n         panic!(\"cannot decode `DefIndex` with `{}`\", std::any::type_name::<D>());\n     }\n }\n@@ -298,12 +298,10 @@ impl<E: Encoder> Encodable<E> for DefId {\n }\n \n impl<D: Decoder> Decodable<D> for DefId {\n-    default fn decode(d: &mut D) -> Result<DefId, D::Error> {\n-        d.read_struct(|d| {\n-            Ok(DefId {\n-                krate: d.read_struct_field(\"krate\", Decodable::decode)?,\n-                index: d.read_struct_field(\"index\", Decodable::decode)?,\n-            })\n+    default fn decode(d: &mut D) -> DefId {\n+        d.read_struct(|d| DefId {\n+            krate: d.read_struct_field(\"krate\", Decodable::decode),\n+            index: d.read_struct_field(\"index\", Decodable::decode),\n         })\n     }\n }\n@@ -378,8 +376,8 @@ impl<E: Encoder> Encodable<E> for LocalDefId {\n }\n \n impl<D: Decoder> Decodable<D> for LocalDefId {\n-    fn decode(d: &mut D) -> Result<LocalDefId, D::Error> {\n-        DefId::decode(d).map(|d| d.expect_local())\n+    fn decode(d: &mut D) -> LocalDefId {\n+        DefId::decode(d).expect_local()\n     }\n }\n "}, {"sha": "e0d6bd8cb7bba6f709f3942499d285e45a2e3c29", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -1314,27 +1314,24 @@ pub fn decode_expn_id(\n // to track which `SyntaxContext`s we have already decoded.\n // The provided closure will be invoked to deserialize a `SyntaxContextData`\n // if we haven't already seen the id of the `SyntaxContext` we are deserializing.\n-pub fn decode_syntax_context<\n-    D: Decoder,\n-    F: FnOnce(&mut D, u32) -> Result<SyntaxContextData, D::Error>,\n->(\n+pub fn decode_syntax_context<D: Decoder, F: FnOnce(&mut D, u32) -> SyntaxContextData>(\n     d: &mut D,\n     context: &HygieneDecodeContext,\n     decode_data: F,\n-) -> Result<SyntaxContext, D::Error> {\n-    let raw_id: u32 = Decodable::decode(d)?;\n+) -> SyntaxContext {\n+    let raw_id: u32 = Decodable::decode(d);\n     if raw_id == 0 {\n         debug!(\"decode_syntax_context: deserialized root\");\n         // The root is special\n-        return Ok(SyntaxContext::root());\n+        return SyntaxContext::root();\n     }\n \n     let outer_ctxts = &context.remapped_ctxts;\n \n     // Ensure that the lock() temporary is dropped early\n     {\n         if let Some(ctxt) = outer_ctxts.lock().get(raw_id as usize).copied().flatten() {\n-            return Ok(ctxt);\n+            return ctxt;\n         }\n     }\n \n@@ -1364,7 +1361,7 @@ pub fn decode_syntax_context<\n \n     // Don't try to decode data while holding the lock, since we need to\n     // be able to recursively decode a SyntaxContext\n-    let mut ctxt_data = decode_data(d, raw_id)?;\n+    let mut ctxt_data = decode_data(d, raw_id);\n     // Reset `dollar_crate_name` so that it will be updated by `update_dollar_crate_names`\n     // We don't care what the encoding crate set this to - we want to resolve it\n     // from the perspective of the current compilation session\n@@ -1380,7 +1377,7 @@ pub fn decode_syntax_context<\n         assert_eq!(dummy.dollar_crate_name, kw::Empty);\n     });\n \n-    Ok(new_ctxt)\n+    new_ctxt\n }\n \n fn for_all_ctxts_in<E, F: FnMut(u32, SyntaxContext, &SyntaxContextData) -> Result<(), E>>(\n@@ -1422,13 +1419,13 @@ impl<E: Encoder> Encodable<E> for ExpnId {\n }\n \n impl<D: Decoder> Decodable<D> for LocalExpnId {\n-    fn decode(d: &mut D) -> Result<Self, D::Error> {\n-        ExpnId::decode(d).map(ExpnId::expect_local)\n+    fn decode(d: &mut D) -> Self {\n+        ExpnId::expect_local(ExpnId::decode(d))\n     }\n }\n \n impl<D: Decoder> Decodable<D> for ExpnId {\n-    default fn decode(_: &mut D) -> Result<Self, D::Error> {\n+    default fn decode(_: &mut D) -> Self {\n         panic!(\"cannot decode `ExpnId` with `{}`\", std::any::type_name::<D>());\n     }\n }\n@@ -1451,7 +1448,7 @@ impl<E: Encoder> Encodable<E> for SyntaxContext {\n }\n \n impl<D: Decoder> Decodable<D> for SyntaxContext {\n-    default fn decode(_: &mut D) -> Result<Self, D::Error> {\n+    default fn decode(_: &mut D) -> Self {\n         panic!(\"cannot decode `SyntaxContext` with `{}`\", std::any::type_name::<D>());\n     }\n }"}, {"sha": "92360164a019bbf29cbf992d2bffff7621b5cd83", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -975,12 +975,12 @@ impl<E: Encoder> Encodable<E> for Span {\n     }\n }\n impl<D: Decoder> Decodable<D> for Span {\n-    default fn decode(s: &mut D) -> Result<Span, D::Error> {\n+    default fn decode(s: &mut D) -> Span {\n         s.read_struct(|d| {\n-            let lo = d.read_struct_field(\"lo\", Decodable::decode)?;\n-            let hi = d.read_struct_field(\"hi\", Decodable::decode)?;\n+            let lo = d.read_struct_field(\"lo\", Decodable::decode);\n+            let hi = d.read_struct_field(\"hi\", Decodable::decode);\n \n-            Ok(Span::new(lo, hi, SyntaxContext::root(), None))\n+            Span::new(lo, hi, SyntaxContext::root(), None)\n         })\n     }\n }\n@@ -1448,30 +1448,30 @@ impl<S: Encoder> Encodable<S> for SourceFile {\n }\n \n impl<D: Decoder> Decodable<D> for SourceFile {\n-    fn decode(d: &mut D) -> Result<SourceFile, D::Error> {\n+    fn decode(d: &mut D) -> SourceFile {\n         d.read_struct(|d| {\n-            let name: FileName = d.read_struct_field(\"name\", |d| Decodable::decode(d))?;\n+            let name: FileName = d.read_struct_field(\"name\", |d| Decodable::decode(d));\n             let src_hash: SourceFileHash =\n-                d.read_struct_field(\"src_hash\", |d| Decodable::decode(d))?;\n-            let start_pos: BytePos = d.read_struct_field(\"start_pos\", |d| Decodable::decode(d))?;\n-            let end_pos: BytePos = d.read_struct_field(\"end_pos\", |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"src_hash\", |d| Decodable::decode(d));\n+            let start_pos: BytePos = d.read_struct_field(\"start_pos\", |d| Decodable::decode(d));\n+            let end_pos: BytePos = d.read_struct_field(\"end_pos\", |d| Decodable::decode(d));\n             let lines: Vec<BytePos> = d.read_struct_field(\"lines\", |d| {\n-                let num_lines: u32 = Decodable::decode(d)?;\n+                let num_lines: u32 = Decodable::decode(d);\n                 let mut lines = Vec::with_capacity(num_lines as usize);\n \n                 if num_lines > 0 {\n                     // Read the number of bytes used per diff.\n-                    let bytes_per_diff: u8 = Decodable::decode(d)?;\n+                    let bytes_per_diff: u8 = Decodable::decode(d);\n \n                     // Read the first element.\n-                    let mut line_start: BytePos = Decodable::decode(d)?;\n+                    let mut line_start: BytePos = Decodable::decode(d);\n                     lines.push(line_start);\n \n                     for _ in 1..num_lines {\n                         let diff = match bytes_per_diff {\n-                            1 => d.read_u8()? as u32,\n-                            2 => d.read_u16()? as u32,\n-                            4 => d.read_u32()?,\n+                            1 => d.read_u8() as u32,\n+                            2 => d.read_u16() as u32,\n+                            4 => d.read_u32(),\n                             _ => unreachable!(),\n                         };\n \n@@ -1481,17 +1481,17 @@ impl<D: Decoder> Decodable<D> for SourceFile {\n                     }\n                 }\n \n-                Ok(lines)\n-            })?;\n+                lines\n+            });\n             let multibyte_chars: Vec<MultiByteChar> =\n-                d.read_struct_field(\"multibyte_chars\", |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"multibyte_chars\", |d| Decodable::decode(d));\n             let non_narrow_chars: Vec<NonNarrowChar> =\n-                d.read_struct_field(\"non_narrow_chars\", |d| Decodable::decode(d))?;\n-            let name_hash: u128 = d.read_struct_field(\"name_hash\", |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"non_narrow_chars\", |d| Decodable::decode(d));\n+            let name_hash: u128 = d.read_struct_field(\"name_hash\", |d| Decodable::decode(d));\n             let normalized_pos: Vec<NormalizedPos> =\n-                d.read_struct_field(\"normalized_pos\", |d| Decodable::decode(d))?;\n-            let cnum: CrateNum = d.read_struct_field(\"cnum\", |d| Decodable::decode(d))?;\n-            Ok(SourceFile {\n+                d.read_struct_field(\"normalized_pos\", |d| Decodable::decode(d));\n+            let cnum: CrateNum = d.read_struct_field(\"cnum\", |d| Decodable::decode(d));\n+            SourceFile {\n                 name,\n                 start_pos,\n                 end_pos,\n@@ -1506,7 +1506,7 @@ impl<D: Decoder> Decodable<D> for SourceFile {\n                 normalized_pos,\n                 name_hash,\n                 cnum,\n-            })\n+            }\n         })\n     }\n }\n@@ -1949,8 +1949,8 @@ impl<S: rustc_serialize::Encoder> Encodable<S> for BytePos {\n }\n \n impl<D: rustc_serialize::Decoder> Decodable<D> for BytePos {\n-    fn decode(d: &mut D) -> Result<BytePos, D::Error> {\n-        Ok(BytePos(d.read_u32()?))\n+    fn decode(d: &mut D) -> BytePos {\n+        BytePos(d.read_u32())\n     }\n }\n "}, {"sha": "ac4729f717da78081fa44e9e8e44680a48de8ea6", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -1756,8 +1756,8 @@ impl<S: Encoder> Encodable<S> for Symbol {\n \n impl<D: Decoder> Decodable<D> for Symbol {\n     #[inline]\n-    fn decode(d: &mut D) -> Result<Symbol, D::Error> {\n-        Ok(Symbol::intern(&d.read_str()?))\n+    fn decode(d: &mut D) -> Symbol {\n+        Symbol::intern(&d.read_str())\n     }\n }\n "}, {"sha": "899c9e4c62956cb3ec4b385501de85ee730c76a4", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -292,7 +292,7 @@ crate fn load_call_locations(\n         for path in with_examples {\n             let bytes = fs::read(&path).map_err(|e| format!(\"{} (for path {})\", e, path))?;\n             let mut decoder = Decoder::new(&bytes, 0);\n-            let calls = AllCallLocations::decode(&mut decoder)?;\n+            let calls = AllCallLocations::decode(&mut decoder);\n \n             for (function, fn_calls) in calls.into_iter() {\n                 all_calls.entry(function).or_default().extend(fn_calls.into_iter());"}, {"sha": "dd20eef070084b4cc6ea5d56b787b45ea548c5cd", "filename": "src/test/ui-fulldeps/deriving-encodable-decodable-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -18,6 +18,6 @@ struct A {\n fn main() {\n     let obj = A { foo: Box::new([true, false]) };\n     let s = json::encode(&obj).unwrap();\n-    let obj2: A = json::decode(&s).unwrap();\n+    let obj2: A = json::decode(&s);\n     assert_eq!(obj.foo, obj2.foo);\n }"}, {"sha": "18aa974c31dbedb9c3b9396b5e0a3a9313c09f21", "filename": "src/test/ui-fulldeps/deriving-encodable-decodable-cell-refcell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -27,7 +27,7 @@ struct B {\n fn main() {\n     let obj = B { foo: Cell::new(true), bar: RefCell::new(A { baz: 2 }) };\n     let s = json::encode(&obj).unwrap();\n-    let obj2: B = json::decode(&s).unwrap();\n+    let obj2: B = json::decode(&s);\n     assert_eq!(obj.foo.get(), obj2.foo.get());\n     assert_eq!(obj.bar.borrow().baz, obj2.bar.borrow().baz);\n }"}, {"sha": "acd75170d68b23870394250e01f2e779df41e2c6", "filename": "src/test/ui-fulldeps/issue-14021.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -20,7 +20,7 @@ pub fn main() {\n \n     let json_object = json::from_str(&json_str);\n     let mut decoder = json::Decoder::new(json_object.unwrap());\n-    let mut decoded_obj: UnitLikeStruct = Decodable::decode(&mut decoder).unwrap();\n+    let mut decoded_obj: UnitLikeStruct = Decodable::decode(&mut decoder);\n \n     assert_eq!(obj, decoded_obj);\n }"}, {"sha": "65dab8d7704766f70c9e6ee9e981d65cabbc35df", "filename": "src/test/ui-fulldeps/issue-4016.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/src%2Ftest%2Fui-fulldeps%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/src%2Ftest%2Fui-fulldeps%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-4016.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -12,7 +12,7 @@ trait JD: Decodable<json::Decoder> {}\n fn exec<T: JD>() {\n     let doc = json::from_str(\"\").unwrap();\n     let mut decoder = json::Decoder::new(doc);\n-    let _v: T = Decodable::decode(&mut decoder).unwrap();\n+    let _v: T = Decodable::decode(&mut decoder);\n     panic!()\n }\n "}, {"sha": "702bb2d6ef6cb3b5ae20bd438a9a6f0ca33151d4", "filename": "src/test/ui-fulldeps/issue-4036.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/84322efad553c7a79c80189f2d1b9197c1aa005f/src%2Ftest%2Fui-fulldeps%2Fissue-4036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84322efad553c7a79c80189f2d1b9197c1aa005f/src%2Ftest%2Fui-fulldeps%2Fissue-4036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-4036.rs?ref=84322efad553c7a79c80189f2d1b9197c1aa005f", "patch": "@@ -13,5 +13,5 @@ use rustc_serialize::{json, Decodable};\n pub fn main() {\n     let json = json::from_str(\"[1]\").unwrap();\n     let mut decoder = json::Decoder::new(json);\n-    let _x: Vec<isize> = Decodable::decode(&mut decoder).unwrap();\n+    let _x: Vec<isize> = Decodable::decode(&mut decoder);\n }"}]}