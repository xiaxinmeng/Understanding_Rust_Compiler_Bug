{"sha": "aa0cc0c6096ca8ba80ef225c813fe30310ba6c33", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMGNjMGM2MDk2Y2E4YmE4MGVmMjI1YzgxM2ZlMzAzMTBiYTZjMzM=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-21T11:03:15Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-21T11:03:15Z"}, "message": "Merge #1002\n\n1002: Fill partial fields r=matklad a=c410-f3r\n\nFixes #992 \n\nCo-authored-by: Caio <c410.f3r@gmail.com>", "tree": {"sha": "a0295adbbf75d77dd74e6e5a5c6fcd46a126a604", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0295adbbf75d77dd74e6e5a5c6fcd46a126a604"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa0cc0c6096ca8ba80ef225c813fe30310ba6c33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa0cc0c6096ca8ba80ef225c813fe30310ba6c33", "html_url": "https://github.com/rust-lang/rust/commit/aa0cc0c6096ca8ba80ef225c813fe30310ba6c33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa0cc0c6096ca8ba80ef225c813fe30310ba6c33/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "b03883279528986bd829e14f967db4b4c980049d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b03883279528986bd829e14f967db4b4c980049d", "html_url": "https://github.com/rust-lang/rust/commit/b03883279528986bd829e14f967db4b4c980049d"}, {"sha": "99c45609ef88f543a825cd177fc0f426f1b565fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/99c45609ef88f543a825cd177fc0f426f1b565fc", "html_url": "https://github.com/rust-lang/rust/commit/99c45609ef88f543a825cd177fc0f426f1b565fc"}], "stats": {"total": 155, "additions": 122, "deletions": 33}, "files": [{"sha": "6e61a58fced06d29def6d43815264a68230a31fc", "filename": "crates/ra_assists/src/fill_struct_fields.rs", "status": "modified", "additions": 122, "deletions": 33, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/aa0cc0c6096ca8ba80ef225c813fe30310ba6c33/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa0cc0c6096ca8ba80ef225c813fe30310ba6c33/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs?ref=aa0cc0c6096ca8ba80ef225c813fe30310ba6c33", "patch": "@@ -1,49 +1,96 @@\n use std::fmt::Write;\n \n-use hir::{AdtDef, Ty, source_binder};\n-use hir::db::HirDatabase;\n+use hir::{AdtDef, Ty, db::HirDatabase, source_binder::function_from_child_node};\n \n use ra_syntax::ast::{self, AstNode};\n \n use crate::{AssistCtx, Assist, AssistId};\n \n pub(crate) fn fill_struct_fields(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let struct_lit = ctx.node_at_offset::<ast::StructLit>()?;\n-    let named_field_list = struct_lit.named_field_list()?;\n-\n-    // If we already have existing struct fields, don't provide the assist.\n-    if named_field_list.fields().count() > 0 {\n+    let mut fsf = FillStructFields {\n+        ctx: &mut ctx,\n+        named_field_list: struct_lit.named_field_list()?,\n+        struct_fields: vec![],\n+        struct_lit,\n+    };\n+    fsf.evaluate_struct_def_fields()?;\n+    if fsf.struct_lit_and_def_have_the_same_number_of_fields() {\n         return None;\n     }\n+    fsf.remove_already_included_fields()?;\n+    fsf.add_action()?;\n+    ctx.build()\n+}\n \n-    let function =\n-        source_binder::function_from_child_node(ctx.db, ctx.frange.file_id, struct_lit.syntax())?;\n+struct FillStructFields<'a, 'b: 'a, DB> {\n+    ctx: &'a mut AssistCtx<'b, DB>,\n+    named_field_list: &'a ast::NamedFieldList,\n+    struct_fields: Vec<(String, String)>,\n+    struct_lit: &'a ast::StructLit,\n+}\n \n-    let infer_result = function.infer(ctx.db);\n-    let source_map = function.body_source_map(ctx.db);\n-    let node_expr = source_map.node_expr(struct_lit.into())?;\n-    let struct_lit_ty = infer_result[node_expr].clone();\n-    let struct_def = match struct_lit_ty {\n-        Ty::Adt { def_id: AdtDef::Struct(s), .. } => s,\n-        _ => return None,\n-    };\n+impl<DB> FillStructFields<'_, '_, DB>\n+where\n+    DB: HirDatabase,\n+{\n+    fn add_action(&mut self) -> Option<()> {\n+        let named_field_list = self.named_field_list;\n+        let struct_fields_string = self.struct_fields_string()?;\n+        let struct_lit = self.struct_lit;\n+        self.ctx.add_action(AssistId(\"fill_struct_fields\"), \"fill struct fields\", |edit| {\n+            edit.target(struct_lit.syntax().range());\n+            edit.set_cursor(struct_lit.syntax().range().start());\n+            edit.replace_node_and_indent(named_field_list.syntax(), struct_fields_string);\n+        });\n+        Some(())\n+    }\n \n-    let db = ctx.db;\n-    ctx.add_action(AssistId(\"fill_struct_fields\"), \"fill struct fields\", |edit| {\n+    fn struct_lit_and_def_have_the_same_number_of_fields(&self) -> bool {\n+        self.named_field_list.fields().count() == self.struct_fields.len()\n+    }\n+\n+    fn evaluate_struct_def_fields(&mut self) -> Option<()> {\n+        let function = function_from_child_node(\n+            self.ctx.db,\n+            self.ctx.frange.file_id,\n+            self.struct_lit.syntax(),\n+        )?;\n+        let infer_result = function.infer(self.ctx.db);\n+        let source_map = function.body_source_map(self.ctx.db);\n+        let node_expr = source_map.node_expr(self.struct_lit.into())?;\n+        let struct_lit_ty = infer_result[node_expr].clone();\n+        let struct_def = match struct_lit_ty {\n+            Ty::Adt { def_id: AdtDef::Struct(s), .. } => s,\n+            _ => return None,\n+        };\n+        self.struct_fields = struct_def\n+            .fields(self.ctx.db)\n+            .into_iter()\n+            .map(|f| (f.name(self.ctx.db).to_string(), \"()\".into()))\n+            .collect();\n+        Some(())\n+    }\n+\n+    fn remove_already_included_fields(&mut self) -> Option<()> {\n+        for ast_field in self.named_field_list.fields() {\n+            let expr = ast_field.expr()?.syntax().text().to_string();\n+            let name_from_ast = ast_field.name_ref()?.text().to_string();\n+            if let Some(idx) = self.struct_fields.iter().position(|(n, _)| n == &name_from_ast) {\n+                self.struct_fields[idx] = (name_from_ast, expr);\n+            }\n+        }\n+        Some(())\n+    }\n+\n+    fn struct_fields_string(&mut self) -> Option<String> {\n         let mut buf = String::from(\"{\\n\");\n-        let struct_fields = struct_def.fields(db);\n-        for field in struct_fields {\n-            let field_name = field.name(db).to_string();\n-            write!(&mut buf, \"    {}: (),\\n\", field_name).unwrap();\n+        for (name, expr) in &self.struct_fields {\n+            write!(&mut buf, \"    {}: {},\\n\", name, expr).unwrap();\n         }\n         buf.push_str(\"}\");\n-\n-        edit.target(struct_lit.syntax().range());\n-        edit.set_cursor(struct_lit.syntax().range().start());\n-        edit.replace_node_and_indent(named_field_list.syntax(), buf);\n-    });\n-\n-    ctx.build()\n+        Some(buf)\n+    }\n }\n \n #[cfg(test)]\n@@ -62,7 +109,7 @@ mod tests {\n                 b: String,\n                 c: (i32, i32),\n                 d: D,\n-                r: &'a str,\n+                e: &'a str,\n             }\n \n             fn main() {\n@@ -75,7 +122,7 @@ mod tests {\n                 b: String,\n                 c: (i32, i32),\n                 d: D,\n-                r: &'a str,\n+                e: &'a str,\n             }\n \n             fn main() {\n@@ -84,7 +131,7 @@ mod tests {\n                     b: (),\n                     c: (),\n                     d: (),\n-                    r: (),\n+                    e: (),\n                 }\n             }\n             \"#,\n@@ -101,7 +148,7 @@ mod tests {\n                 b: String,\n                 c: (i32, i32),\n                 d: D,\n-                r: &'a str,\n+                e: &'a str,\n             }\n \n             fn main() {\n@@ -148,4 +195,46 @@ mod tests {\n             \"#,\n         );\n     }\n+\n+    #[test]\n+    fn fill_struct_fields_partial() {\n+        check_assist(\n+            fill_struct_fields,\n+            r#\"\n+            struct S<'a, D> {\n+                a: u32,\n+                b: String,\n+                c: (i32, i32),\n+                d: D,\n+                e: &'a str,\n+            }\n+\n+            fn main() {\n+                let s = S {\n+                    c: (1, 2),\n+                    e: \"foo\",<|>\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            struct S<'a, D> {\n+                a: u32,\n+                b: String,\n+                c: (i32, i32),\n+                d: D,\n+                e: &'a str,\n+            }\n+\n+            fn main() {\n+                let s = <|>S {\n+                    a: (),\n+                    b: (),\n+                    c: (1, 2),\n+                    d: (),\n+                    e: \"foo\",\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n }"}]}