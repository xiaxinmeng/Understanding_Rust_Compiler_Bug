{"sha": "71569e420107ab034910a4687f382385975fa0b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNTY5ZTQyMDEwN2FiMDM0OTEwYTQ2ODdmMzgyMzg1OTc1ZmEwYjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-08T00:58:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-08T00:58:43Z"}, "message": "Auto merge of #75138 - jumbatm:session-diagnostic-derive, r=oli-obk\n\nAdd derive macro for specifying diagnostics using attributes.\n\nIntroduces `#[derive(SessionDiagnostic)]`, a derive macro for specifying structs that can be converted to Diagnostics using directions given by attributes on the struct and its fields. Currently, the following attributes have been implemented:\n- `#[code = \"...\"]` -- this sets the Diagnostic's error code, and must be provided on the struct iself (ie, not on a field). Equivalent to calling `code`.\n- `#[message = \"...\"]` -- this sets the Diagnostic's primary error message.\n- `#[label = \"...\"]` -- this must be applied to fields of type `Span`, and is equivalent to `span_label`\n- `#[suggestion(..)]` -- this allows a suggestion message to be supplied. This attribute must be applied to a field of type `Span` or `(Span, Applicability)`, and is equivalent to calling `span_suggestion`. Valid arguments are:\n    - `message = \"...\"` -- this sets the suggestion message.\n    - (Optional) `code = \"...\"` -- this suggests code for the suggestion. Defaults to empty.\n\n`suggestion`also  comes with other variants: `#[suggestion_short(..)]`, `#[suggestion_hidden(..)]` and `#[suggestion_verbose(..)]` which all take the same keys.\n\nWithin the strings passed to each attribute, fields can be referenced without needing to be passed explicitly into the format string -- eg, `#[error = \"{ident} already declared\"] ` will set the error message to `format!(\"{} already declared\", &self.ident)`. Any fields on the struct can be referenced in this way.\n\nAdditionally, for any of these attributes, Option fields can be used to only optionally apply the decoration -- for example:\n\n```rust\n#[derive(SessionDiagnostic)]\n#[code = \"E0123\"]\nstruct SomeKindOfError {\n    ...\n    #[suggestion(message = \"informative error message\")]\n    opt_sugg: Option<(Span, Applicability)>\n    ...\n}\n```\nwill not emit a suggestion if `opt_sugg` is `None`.\n\nWe plan on iterating on this macro further; this PR is a start.\n\nCloses #61132.\n\nr? `@oli-obk`", "tree": {"sha": "e98903281ee0502675b01212bded5148710b6d90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e98903281ee0502675b01212bded5148710b6d90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71569e420107ab034910a4687f382385975fa0b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71569e420107ab034910a4687f382385975fa0b3", "html_url": "https://github.com/rust-lang/rust/commit/71569e420107ab034910a4687f382385975fa0b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71569e420107ab034910a4687f382385975fa0b3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e2c1281e909ca38479b97962fc9248f75d66412", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2c1281e909ca38479b97962fc9248f75d66412", "html_url": "https://github.com/rust-lang/rust/commit/0e2c1281e909ca38479b97962fc9248f75d66412"}, {"sha": "5956254172ab2bb6fd7c98faf51509925341c321", "url": "https://api.github.com/repos/rust-lang/rust/commits/5956254172ab2bb6fd7c98faf51509925341c321", "html_url": "https://github.com/rust-lang/rust/commit/5956254172ab2bb6fd7c98faf51509925341c321"}], "stats": {"total": 1566, "additions": 1361, "deletions": 205}, "files": [{"sha": "d0b9f0ab10cecf90c51d1c6cd7d963a3da0bef4f", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -4087,6 +4087,7 @@ dependencies = [\n  \"rustc_hir_pretty\",\n  \"rustc_index\",\n  \"rustc_infer\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\","}, {"sha": "628488575b2f80c97aaecc6521fd5fc13b5413a1", "filename": "compiler/rustc_error_codes/src/error_codes/E0224.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0224.md", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0224.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0224.md?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -1,4 +1,4 @@\n-A trait object was declaired with no traits.\n+A trait object was declared with no traits.\n \n Erroneous code example:\n \n@@ -8,7 +8,7 @@ type Foo = dyn 'static +;\n \n Rust does not currently support this.\n \n-To solve ensure the the trait object has at least one trait:\n+To solve, ensure that the trait object has at least one trait:\n \n ```\n type Foo = dyn 'static + Copy;"}, {"sha": "5c28839c9b7e4a3249d958a89aa39d7a70fe84e2", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -1,3 +1,4 @@\n+#![feature(proc_macro_diagnostic)]\n #![allow(rustc::default_hash_types)]\n #![recursion_limit = \"128\"]\n \n@@ -9,6 +10,7 @@ mod hash_stable;\n mod lift;\n mod query;\n mod serialize;\n+mod session_diagnostic;\n mod symbols;\n mod type_foldable;\n \n@@ -36,3 +38,14 @@ decl_derive!([MetadataDecodable] => serialize::meta_decodable_derive);\n decl_derive!([MetadataEncodable] => serialize::meta_encodable_derive);\n decl_derive!([TypeFoldable, attributes(type_foldable)] => type_foldable::type_foldable_derive);\n decl_derive!([Lift, attributes(lift)] => lift::lift_derive);\n+decl_derive!(\n+    [SessionDiagnostic, attributes(\n+        message,\n+        lint,\n+        error,\n+        label,\n+        suggestion,\n+        suggestion_short,\n+        suggestion_hidden,\n+        suggestion_verbose)] => session_diagnostic::session_diagnostic_derive\n+);"}, {"sha": "396de77d5eee027b68ce06fecb90c8569a27ae61", "filename": "compiler/rustc_macros/src/session_diagnostic.rs", "status": "added", "additions": 665, "deletions": 0, "changes": 665, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsession_diagnostic.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -0,0 +1,665 @@\n+#![deny(unused_must_use)]\n+use quote::format_ident;\n+use quote::quote;\n+\n+use proc_macro::Diagnostic;\n+use syn::spanned::Spanned;\n+\n+use std::collections::{HashMap, HashSet};\n+\n+/// Implements #[derive(SessionDiagnostic)], which allows for errors to be specified as a struct, independent\n+/// from the actual diagnostics emitting code.\n+/// ```ignore (pseudo-rust)\n+/// # extern crate rustc_errors;\n+/// # use rustc_errors::Applicability;\n+/// # extern crate rustc_span;\n+/// # use rustc_span::{symbol::Ident, Span};\n+/// # extern crate rust_middle;\n+/// # use rustc_middle::ty::Ty;\n+/// #[derive(SessionDiagnostic)]\n+/// #[code = \"E0505\"]\n+/// #[error = \"cannot move out of {name} because it is borrowed\"]\n+/// pub struct MoveOutOfBorrowError<'tcx> {\n+///     pub name: Ident,\n+///     pub ty: Ty<'tcx>,\n+///     #[label = \"cannot move out of borrow\"]\n+///     pub span: Span,\n+///     #[label = \"`{ty}` first borrowed here\"]\n+///     pub other_span: Span,\n+///     #[suggestion(message = \"consider cloning here\", code = \"{name}.clone()\")]\n+///     pub opt_sugg: Option<(Span, Applicability)>\n+/// }\n+/// ```\n+/// Then, later, to emit the error:\n+///\n+/// ```ignore (pseudo-rust)\n+/// sess.emit_err(MoveOutOfBorrowError {\n+///     expected,\n+///     actual,\n+///     span,\n+///     other_span,\n+///     opt_sugg: Some(suggestion, Applicability::MachineApplicable),\n+/// });\n+/// ```\n+pub fn session_diagnostic_derive(s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    // Names for the diagnostic we build and the session we build it from.\n+    let diag = format_ident!(\"diag\");\n+    let sess = format_ident!(\"sess\");\n+\n+    SessionDiagnosticDerive::new(diag, sess, s).into_tokens()\n+}\n+\n+// Checks whether the type name of `ty` matches `name`.\n+//\n+// Given some struct at a::b::c::Foo, this will return true for c::Foo, b::c::Foo, or\n+// a::b::c::Foo. This reasonably allows qualified names to be used in the macro.\n+fn type_matches_path(ty: &syn::Type, name: &[&str]) -> bool {\n+    if let syn::Type::Path(ty) = ty {\n+        ty.path\n+            .segments\n+            .iter()\n+            .map(|s| s.ident.to_string())\n+            .rev()\n+            .zip(name.iter().rev())\n+            .all(|(x, y)| &x.as_str() == y)\n+    } else {\n+        false\n+    }\n+}\n+\n+/// The central struct for constructing the as_error method from an annotated struct.\n+struct SessionDiagnosticDerive<'a> {\n+    structure: synstructure::Structure<'a>,\n+    builder: SessionDiagnosticDeriveBuilder<'a>,\n+}\n+\n+impl std::convert::From<syn::Error> for SessionDiagnosticDeriveError {\n+    fn from(e: syn::Error) -> Self {\n+        SessionDiagnosticDeriveError::SynError(e)\n+    }\n+}\n+\n+/// Equivalent to rustc:errors::diagnostic::DiagnosticId, except stores the quoted expression to\n+/// initialise the code with.\n+enum DiagnosticId {\n+    Error(proc_macro2::TokenStream),\n+    Lint(proc_macro2::TokenStream),\n+}\n+\n+#[derive(Debug)]\n+enum SessionDiagnosticDeriveError {\n+    SynError(syn::Error),\n+    ErrorHandled,\n+}\n+\n+impl SessionDiagnosticDeriveError {\n+    fn to_compile_error(self) -> proc_macro2::TokenStream {\n+        match self {\n+            SessionDiagnosticDeriveError::SynError(e) => e.to_compile_error(),\n+            SessionDiagnosticDeriveError::ErrorHandled => {\n+                // Return ! to avoid having to create a blank DiagnosticBuilder to return when an\n+                // error has already been emitted to the compiler.\n+                quote! {\n+                    unreachable!()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn span_err(span: impl proc_macro::MultiSpan, msg: &str) -> proc_macro::Diagnostic {\n+    Diagnostic::spanned(span, proc_macro::Level::Error, msg)\n+}\n+\n+/// For methods that return a Result<_, SessionDiagnosticDeriveError>: emit a diagnostic on\n+/// span $span with msg $msg (and, optionally, perform additional decoration using the FnOnce\n+/// passed in `diag`). Then, return Err(ErrorHandled).\n+macro_rules! throw_span_err {\n+    ($span:expr, $msg:expr) => {{ throw_span_err!($span, $msg, |diag| diag) }};\n+    ($span:expr, $msg:expr, $f:expr) => {{\n+        return Err(_throw_span_err($span, $msg, $f));\n+    }};\n+}\n+\n+/// When possible, prefer using throw_span_err! over using this function directly. This only exists\n+/// as a function to constrain `f` to an impl FnOnce.\n+fn _throw_span_err(\n+    span: impl proc_macro::MultiSpan,\n+    msg: &str,\n+    f: impl FnOnce(proc_macro::Diagnostic) -> proc_macro::Diagnostic,\n+) -> SessionDiagnosticDeriveError {\n+    let diag = span_err(span, msg);\n+    f(diag).emit();\n+    SessionDiagnosticDeriveError::ErrorHandled\n+}\n+\n+impl<'a> SessionDiagnosticDerive<'a> {\n+    fn new(diag: syn::Ident, sess: syn::Ident, structure: synstructure::Structure<'a>) -> Self {\n+        // Build the mapping of field names to fields. This allows attributes to peek values from\n+        // other fields.\n+        let mut fields_map = HashMap::new();\n+\n+        // Convenience bindings.\n+        let ast = structure.ast();\n+\n+        if let syn::Data::Struct(syn::DataStruct { fields, .. }) = &ast.data {\n+            for field in fields.iter() {\n+                if let Some(ident) = &field.ident {\n+                    fields_map.insert(ident.to_string(), field);\n+                }\n+            }\n+        }\n+\n+        Self {\n+            builder: SessionDiagnosticDeriveBuilder { diag, sess, fields: fields_map, kind: None },\n+            structure,\n+        }\n+    }\n+    fn into_tokens(self) -> proc_macro2::TokenStream {\n+        let SessionDiagnosticDerive { structure, mut builder } = self;\n+\n+        let ast = structure.ast();\n+        let attrs = &ast.attrs;\n+\n+        let implementation = {\n+            if let syn::Data::Struct(..) = ast.data {\n+                let preamble = {\n+                    let preamble = attrs.iter().map(|attr| {\n+                        builder\n+                            .generate_structure_code(attr)\n+                            .unwrap_or_else(|v| v.to_compile_error())\n+                    });\n+                    quote! {\n+                        #(#preamble)*;\n+                    }\n+                };\n+\n+                let body = structure.each(|field_binding| {\n+                    let field = field_binding.ast();\n+                    let result = field.attrs.iter().map(|attr| {\n+                        builder\n+                            .generate_field_code(\n+                                attr,\n+                                FieldInfo {\n+                                    vis: &field.vis,\n+                                    binding: field_binding,\n+                                    ty: &field.ty,\n+                                    span: &field.span(),\n+                                },\n+                            )\n+                            .unwrap_or_else(|v| v.to_compile_error())\n+                    });\n+                    return quote! {\n+                        #(#result);*\n+                    };\n+                });\n+                // Finally, putting it altogether.\n+                match builder.kind {\n+                    None => {\n+                        span_err(ast.span().unwrap(), \"`code` not specified\")\n+                        .help(\"use the [code = \\\"...\\\"] attribute to set this diagnostic's error code \")\n+                        .emit();\n+                        SessionDiagnosticDeriveError::ErrorHandled.to_compile_error()\n+                    }\n+                    Some((kind, _)) => match kind {\n+                        DiagnosticId::Lint(_lint) => todo!(),\n+                        DiagnosticId::Error(code) => {\n+                            let (diag, sess) = (&builder.diag, &builder.sess);\n+                            quote! {\n+                                let mut #diag = #sess.struct_err_with_code(\"\", rustc_errors::DiagnosticId::Error(#code));\n+                                #preamble\n+                                match self {\n+                                    #body\n+                                }\n+                                #diag\n+                            }\n+                        }\n+                    },\n+                }\n+            } else {\n+                span_err(\n+                    ast.span().unwrap(),\n+                    \"`#[derive(SessionDiagnostic)]` can only be used on structs\",\n+                )\n+                .emit();\n+                SessionDiagnosticDeriveError::ErrorHandled.to_compile_error()\n+            }\n+        };\n+\n+        let sess = &builder.sess;\n+        structure.gen_impl(quote! {\n+            gen impl<'__session_diagnostic_sess> rustc_session::SessionDiagnostic<'__session_diagnostic_sess>\n+                    for @Self\n+            {\n+                fn into_diagnostic(\n+                    self,\n+                    #sess: &'__session_diagnostic_sess rustc_session::Session\n+                ) -> rustc_errors::DiagnosticBuilder<'__session_diagnostic_sess> {\n+                    #implementation\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+/// Field information passed to the builder. Deliberately omits attrs to discourage the generate_*\n+/// methods from walking the attributes themselves.\n+struct FieldInfo<'a> {\n+    vis: &'a syn::Visibility,\n+    binding: &'a synstructure::BindingInfo<'a>,\n+    ty: &'a syn::Type,\n+    span: &'a proc_macro2::Span,\n+}\n+\n+/// Tracks persistent information required for building up the individual calls to diagnostic\n+/// methods for the final generated method. This is a separate struct to SessionDerive only to be\n+/// able to destructure and split self.builder and the self.structure up to avoid a double mut\n+/// borrow later on.\n+struct SessionDiagnosticDeriveBuilder<'a> {\n+    /// Name of the session parameter that's passed in to the as_error method.\n+    sess: syn::Ident,\n+\n+    /// Store a map of field name to its corresponding field. This is built on construction of the\n+    /// derive builder.\n+    fields: HashMap<String, &'a syn::Field>,\n+\n+    /// The identifier to use for the generated DiagnosticBuilder instance.\n+    diag: syn::Ident,\n+\n+    /// Whether this is a lint or an error. This dictates how the diag will be initialised. Span\n+    /// stores at what Span the kind was first set at (for error reporting purposes, if the kind\n+    /// was multiply specified).\n+    kind: Option<(DiagnosticId, proc_macro2::Span)>,\n+}\n+\n+impl<'a> SessionDiagnosticDeriveBuilder<'a> {\n+    fn generate_structure_code(\n+        &mut self,\n+        attr: &syn::Attribute,\n+    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n+        Ok(match attr.parse_meta()? {\n+            syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                let formatted_str = self.build_format(&s.value(), attr.span());\n+                let name = attr.path.segments.last().unwrap().ident.to_string();\n+                let name = name.as_str();\n+                match name {\n+                    \"message\" => {\n+                        let diag = &self.diag;\n+                        quote! {\n+                            #diag.set_primary_message(#formatted_str);\n+                        }\n+                    }\n+                    attr @ \"error\" | attr @ \"lint\" => {\n+                        self.set_kind_once(\n+                            if attr == \"error\" {\n+                                DiagnosticId::Error(formatted_str)\n+                            } else if attr == \"lint\" {\n+                                DiagnosticId::Lint(formatted_str)\n+                            } else {\n+                                unreachable!()\n+                            },\n+                            s.span(),\n+                        )?;\n+                        // This attribute is only allowed to be applied once, and the attribute\n+                        // will be set in the initialisation code.\n+                        quote! {}\n+                    }\n+                    other => throw_span_err!(\n+                        attr.span().unwrap(),\n+                        &format!(\n+                            \"`#[{} = ...]` is not a valid SessionDiagnostic struct attribute\",\n+                            other\n+                        )\n+                    ),\n+                }\n+            }\n+            _ => todo!(\"unhandled meta kind\"),\n+        })\n+    }\n+\n+    #[must_use]\n+    fn set_kind_once(\n+        &mut self,\n+        kind: DiagnosticId,\n+        span: proc_macro2::Span,\n+    ) -> Result<(), SessionDiagnosticDeriveError> {\n+        if self.kind.is_none() {\n+            self.kind = Some((kind, span));\n+            Ok(())\n+        } else {\n+            let kind_str = |kind: &DiagnosticId| match kind {\n+                DiagnosticId::Lint(..) => \"lint\",\n+                DiagnosticId::Error(..) => \"error\",\n+            };\n+\n+            let existing_kind = kind_str(&self.kind.as_ref().unwrap().0);\n+            let this_kind = kind_str(&kind);\n+\n+            let msg = if this_kind == existing_kind {\n+                format!(\"`{}` specified multiple times\", existing_kind)\n+            } else {\n+                format!(\"`{}` specified when `{}` was already specified\", this_kind, existing_kind)\n+            };\n+            throw_span_err!(span.unwrap(), &msg);\n+        }\n+    }\n+\n+    fn generate_field_code(\n+        &mut self,\n+        attr: &syn::Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n+        let field_binding = &info.binding.binding;\n+\n+        let option_ty = option_inner_ty(&info.ty);\n+\n+        let generated_code = self.generate_non_option_field_code(\n+            attr,\n+            FieldInfo {\n+                vis: info.vis,\n+                binding: info.binding,\n+                ty: option_ty.unwrap_or(&info.ty),\n+                span: info.span,\n+            },\n+        )?;\n+        Ok(if option_ty.is_none() {\n+            quote! { #generated_code }\n+        } else {\n+            quote! {\n+                if let Some(#field_binding) = #field_binding {\n+                    #generated_code\n+                }\n+            }\n+        })\n+    }\n+\n+    fn generate_non_option_field_code(\n+        &mut self,\n+        attr: &syn::Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<proc_macro2::TokenStream, SessionDiagnosticDeriveError> {\n+        let diag = &self.diag;\n+        let field_binding = &info.binding.binding;\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let name = name.as_str();\n+        // At this point, we need to dispatch based on the attribute key + the\n+        // type.\n+        let meta = attr.parse_meta()?;\n+        Ok(match meta {\n+            syn::Meta::NameValue(syn::MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n+                let formatted_str = self.build_format(&s.value(), attr.span());\n+                match name {\n+                    \"message\" => {\n+                        if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+                            quote! {\n+                                #diag.set_span(*#field_binding);\n+                                #diag.set_primary_message(#formatted_str);\n+                            }\n+                        } else {\n+                            throw_span_err!(\n+                                attr.span().unwrap(),\n+                                \"the `#[message = \\\"...\\\"]` attribute can only be applied to fields of type Span\"\n+                            );\n+                        }\n+                    }\n+                    \"label\" => {\n+                        if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+                            quote! {\n+                                #diag.span_label(*#field_binding, #formatted_str);\n+                            }\n+                        } else {\n+                            throw_span_err!(\n+                                attr.span().unwrap(),\n+                                \"The `#[label = ...]` attribute can only be applied to fields of type Span\"\n+                            );\n+                        }\n+                    }\n+                    other => throw_span_err!(\n+                        attr.span().unwrap(),\n+                        &format!(\n+                            \"`#[{} = ...]` is not a valid SessionDiagnostic field attribute\",\n+                            other\n+                        )\n+                    ),\n+                }\n+            }\n+            syn::Meta::List(list) => {\n+                match list.path.segments.iter().last().unwrap().ident.to_string().as_str() {\n+                    suggestion_kind @ \"suggestion\"\n+                    | suggestion_kind @ \"suggestion_short\"\n+                    | suggestion_kind @ \"suggestion_hidden\"\n+                    | suggestion_kind @ \"suggestion_verbose\" => {\n+                        // For suggest, we need to ensure we are running on a (Span,\n+                        // Applicability) pair.\n+                        let (span, applicability) = (|| match &info.ty {\n+                            ty @ syn::Type::Path(..)\n+                                if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) =>\n+                            {\n+                                let binding = &info.binding.binding;\n+                                Ok((\n+                                    quote!(*#binding),\n+                                    quote!(rustc_errors::Applicability::Unspecified),\n+                                ))\n+                            }\n+                            syn::Type::Tuple(tup) => {\n+                                let mut span_idx = None;\n+                                let mut applicability_idx = None;\n+                                for (idx, elem) in tup.elems.iter().enumerate() {\n+                                    if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n+                                        if span_idx.is_none() {\n+                                            span_idx = Some(syn::Index::from(idx));\n+                                        } else {\n+                                            throw_span_err!(\n+                                                info.span.clone().unwrap(),\n+                                                \"type of field annotated with `#[suggestion(...)]` contains more than one Span\"\n+                                            );\n+                                        }\n+                                    } else if type_matches_path(\n+                                        elem,\n+                                        &[\"rustc_errors\", \"Applicability\"],\n+                                    ) {\n+                                        if applicability_idx.is_none() {\n+                                            applicability_idx = Some(syn::Index::from(idx));\n+                                        } else {\n+                                            throw_span_err!(\n+                                                info.span.clone().unwrap(),\n+                                                \"type of field annotated with `#[suggestion(...)]` contains more than one Applicability\"\n+                                            );\n+                                        }\n+                                    }\n+                                }\n+                                if let Some(span_idx) = span_idx {\n+                                    let binding = &info.binding.binding;\n+                                    let span = quote!(#binding.#span_idx);\n+                                    let applicability = applicability_idx\n+                                        .map(\n+                                            |applicability_idx| quote!(#binding.#applicability_idx),\n+                                        )\n+                                        .unwrap_or(quote!(\n+                                            rustc_errors::Applicability::Unspecified\n+                                        ));\n+                                    return Ok((span, applicability));\n+                                }\n+                                throw_span_err!(\n+                                    info.span.clone().unwrap(),\n+                                    \"wrong types for suggestion\",\n+                                    |diag| {\n+                                        diag.help(\"#[suggestion(...)] on a tuple field must be applied to fields of type (Span, Applicability)\")\n+                                    }\n+                                );\n+                            }\n+                            _ => throw_span_err!(\n+                                info.span.clone().unwrap(),\n+                                \"wrong field type for suggestion\",\n+                                |diag| {\n+                                    diag.help(\"#[suggestion(...)] should be applied to fields of type Span or (Span, Applicability)\")\n+                                }\n+                            ),\n+                        })()?;\n+                        // Now read the key-value pairs.\n+                        let mut msg = None;\n+                        let mut code = None;\n+\n+                        for arg in list.nested.iter() {\n+                            if let syn::NestedMeta::Meta(syn::Meta::NameValue(arg_name_value)) = arg\n+                            {\n+                                if let syn::MetaNameValue { lit: syn::Lit::Str(s), .. } =\n+                                    arg_name_value\n+                                {\n+                                    let name = arg_name_value\n+                                        .path\n+                                        .segments\n+                                        .last()\n+                                        .unwrap()\n+                                        .ident\n+                                        .to_string();\n+                                    let name = name.as_str();\n+                                    let formatted_str = self.build_format(&s.value(), arg.span());\n+                                    match name {\n+                                        \"message\" => {\n+                                            msg = Some(formatted_str);\n+                                        }\n+                                        \"code\" => {\n+                                            code = Some(formatted_str);\n+                                        }\n+                                        other => throw_span_err!(\n+                                            arg.span().unwrap(),\n+                                            &format!(\n+                                                \"`{}` is not a valid key for `#[suggestion(...)]`\",\n+                                                other\n+                                            )\n+                                        ),\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        let msg = if let Some(msg) = msg {\n+                            quote!(#msg.as_str())\n+                        } else {\n+                            throw_span_err!(\n+                                list.span().unwrap(),\n+                                \"missing suggestion message\",\n+                                |diag| {\n+                                    diag.help(\"provide a suggestion message using #[suggestion(message = \\\"...\\\")]\")\n+                                }\n+                            );\n+                        };\n+                        let code = code.unwrap_or_else(|| quote! { String::new() });\n+                        // Now build it out:\n+                        let suggestion_method = format_ident!(\"span_{}\", suggestion_kind);\n+                        quote! {\n+                            #diag.#suggestion_method(#span, #msg, #code, #applicability);\n+                        }\n+                    }\n+                    other => throw_span_err!(\n+                        list.span().unwrap(),\n+                        &format!(\"invalid annotation list `#[{}(...)]`\", other)\n+                    ),\n+                }\n+            }\n+            _ => panic!(\"unhandled meta kind\"),\n+        })\n+    }\n+\n+    /// In the strings in the attributes supplied to this macro, we want callers to be able to\n+    /// reference fields in the format string. Take this, for example:\n+    /// ```ignore (not-usage-example)\n+    /// struct Point {\n+    ///     #[error = \"Expected a point greater than ({x}, {y})\"]\n+    ///     x: i32,\n+    ///     y: i32,\n+    /// }\n+    /// ```\n+    /// We want to automatically pick up that {x} refers `self.x` and {y} refers to `self.y`, then\n+    /// generate this call to format!:\n+    /// ```ignore (not-usage-example)\n+    /// format!(\"Expected a point greater than ({x}, {y})\", x = self.x, y = self.y)\n+    /// ```\n+    /// This function builds the entire call to format!.\n+    fn build_format(&self, input: &String, span: proc_macro2::Span) -> proc_macro2::TokenStream {\n+        let mut referenced_fields: HashSet<String> = HashSet::new();\n+\n+        // At this point, we can start parsing the format string.\n+        let mut it = input.chars().peekable();\n+        // Once the start of a format string has been found, process the format string and spit out\n+        // the referenced fields. Leaves `it` sitting on the closing brace of the format string, so the\n+        // next call to `it.next()` retrieves the next character.\n+        while let Some(c) = it.next() {\n+            if c == '{' && *it.peek().unwrap_or(&'\\0') != '{' {\n+                #[must_use]\n+                let mut eat_argument = || -> Option<String> {\n+                    let mut result = String::new();\n+                    // Format specifiers look like\n+                    // format   := '{' [ argument ] [ ':' format_spec ] '}' .\n+                    // Therefore, we only need to eat until ':' or '}' to find the argument.\n+                    while let Some(c) = it.next() {\n+                        result.push(c);\n+                        let next = *it.peek().unwrap_or(&'\\0');\n+                        if next == '}' {\n+                            break;\n+                        } else if next == ':' {\n+                            // Eat the ':' character.\n+                            assert_eq!(it.next().unwrap(), ':');\n+                            break;\n+                        }\n+                    }\n+                    // Eat until (and including) the matching '}'\n+                    while it.next()? != '}' {\n+                        continue;\n+                    }\n+                    Some(result)\n+                };\n+\n+                if let Some(referenced_field) = eat_argument() {\n+                    referenced_fields.insert(referenced_field);\n+                }\n+            }\n+        }\n+        // At this point, `referenced_fields` contains a set of the unique fields that were\n+        // referenced in the format string. Generate the corresponding \"x = self.x\" format\n+        // string parameters:\n+        let args = referenced_fields.into_iter().map(|field: String| {\n+            let field_ident = format_ident!(\"{}\", field);\n+            let value = if self.fields.contains_key(&field) {\n+                quote! {\n+                    &self.#field_ident\n+                }\n+            } else {\n+                // This field doesn't exist. Emit a diagnostic.\n+                Diagnostic::spanned(\n+                    span.unwrap(),\n+                    proc_macro::Level::Error,\n+                    format!(\"`{}` doesn't refer to a field on this type\", field),\n+                )\n+                .emit();\n+                quote! {\n+                    \"{#field}\"\n+                }\n+            };\n+            quote! {\n+                #field_ident = #value\n+            }\n+        });\n+        quote! {\n+            format!(#input #(,#args)*)\n+        }\n+    }\n+}\n+\n+/// If `ty` is an Option, returns Some(inner type). Else, returns None.\n+fn option_inner_ty(ty: &syn::Type) -> Option<&syn::Type> {\n+    if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n+        if let syn::Type::Path(ty_path) = ty {\n+            let path = &ty_path.path;\n+            let ty = path.segments.iter().last().unwrap();\n+            if let syn::PathArguments::AngleBracketed(bracketed) = &ty.arguments {\n+                if bracketed.args.len() == 1 {\n+                    if let syn::GenericArgument::Type(ty) = &bracketed.args[0] {\n+                        return Some(ty);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    None\n+}"}, {"sha": "974f4c31bb6a4eb448eb4aa4cdaa5605637ffef7", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -237,6 +237,14 @@ enum DiagnosticBuilderMethod {\n                             // Add more variants as needed to support one-time diagnostics.\n }\n \n+/// Trait implemented by error types. This should not be implemented manually. Instead, use\n+/// `#[derive(SessionDiagnostic)]` -- see [rustc_macros::SessionDiagnostic].\n+pub trait SessionDiagnostic<'a> {\n+    /// Write out as a diagnostic out of `sess`.\n+    #[must_use]\n+    fn into_diagnostic(self, sess: &'a Session) -> DiagnosticBuilder<'a>;\n+}\n+\n /// Diagnostic message ID, used by `Session.one_time_diagnostics` to avoid\n /// emitting the same message more than once.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n@@ -392,6 +400,9 @@ impl Session {\n     pub fn err(&self, msg: &str) {\n         self.diagnostic().err(msg)\n     }\n+    pub fn emit_err<'a>(&'a self, err: impl SessionDiagnostic<'a>) {\n+        err.into_diagnostic(self).emit()\n+    }\n     pub fn err_count(&self) -> usize {\n         self.diagnostic().err_count()\n     }"}, {"sha": "e3ba0bea7e8e29106cf3169c8fb52a163aaa178c", "filename": "compiler/rustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2FCargo.toml?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -11,6 +11,7 @@ doctest = false\n [dependencies]\n rustc_arena = { path = \"../rustc_arena\" }\n tracing = \"0.1\"\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "a434406c284ac09b5307d980bb31c2759177c12c", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -1,6 +1,7 @@\n use crate::astconv::{\n     AstConv, ExplicitLateBound, GenericArgCountMismatch, GenericArgCountResult, GenericArgPosition,\n };\n+use crate::errors::AssocTypeBindingNotAllowed;\n use rustc_ast::ast::ParamKindOrd;\n use rustc_errors::{pluralize, struct_span_err, DiagnosticId, ErrorReported};\n use rustc_hir as hir;\n@@ -544,13 +545,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     /// Emits an error regarding forbidden type binding associations\n     pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_>, span: Span) {\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            span,\n-            E0229,\n-            \"associated type bindings are not allowed here\"\n-        );\n-        err.span_label(span, \"associated type not allowed here\").emit();\n+        tcx.sess.emit_err(AssocTypeBindingNotAllowed { span });\n     }\n \n     /// Prohibits explicit lifetime arguments if late-bound lifetime parameters"}, {"sha": "9e339b1082cb8673b680521b868545df19276b93", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 14, "deletions": 43, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -7,6 +7,10 @@ mod generics;\n \n use crate::bounds::Bounds;\n use crate::collect::PlaceholderHirTyCollector;\n+use crate::errors::{\n+    AmbiguousLifetimeBound, MultipleRelaxedDefaultBounds, TraitObjectDeclaredWithNoTraits,\n+    TypeofReservedKeywordUsed, ValueOfAssociatedStructAlreadySpecified,\n+};\n use crate::middle::resolve_lifetime as rl;\n use crate::require_c_abi_if_c_variadic;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n@@ -684,14 +688,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 if unbound.is_none() {\n                     unbound = Some(&ptr.trait_ref);\n                 } else {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        span,\n-                        E0203,\n-                        \"type parameter has more than one relaxed default \\\n-                        bound, only one is supported\"\n-                    )\n-                    .emit();\n+                    tcx.sess.emit_err(MultipleRelaxedDefaultBounds { span });\n                 }\n             }\n         }\n@@ -927,18 +924,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             dup_bindings\n                 .entry(assoc_ty.def_id)\n                 .and_modify(|prev_span| {\n-                    struct_span_err!(\n-                        self.tcx().sess,\n-                        binding.span,\n-                        E0719,\n-                        \"the value of the associated type `{}` (from trait `{}`) \\\n-                         is already specified\",\n-                        binding.item_name,\n-                        tcx.def_path_str(assoc_ty.container.id())\n-                    )\n-                    .span_label(binding.span, \"re-bound here\")\n-                    .span_label(*prev_span, format!(\"`{}` bound here first\", binding.item_name))\n-                    .emit();\n+                    self.tcx().sess.emit_err(ValueOfAssociatedStructAlreadySpecified {\n+                        span: binding.span,\n+                        prev_span: *prev_span,\n+                        item_name: binding.item_name,\n+                        def_path: tcx.def_path_str(assoc_ty.container.id()),\n+                    });\n                 })\n                 .or_insert(binding.span);\n         }\n@@ -1051,13 +1042,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         if regular_traits.is_empty() && auto_traits.is_empty() {\n-            struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0224,\n-                \"at least one trait is required for an object type\"\n-            )\n-            .emit();\n+            tcx.sess.emit_err(TraitObjectDeclaredWithNoTraits { span });\n             return tcx.ty_error();\n         }\n \n@@ -2059,15 +2044,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 self.normalize_ty(ast_ty.span, array_ty)\n             }\n             hir::TyKind::Typeof(ref _e) => {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    ast_ty.span,\n-                    E0516,\n-                    \"`typeof` is a reserved keyword but unimplemented\"\n-                )\n-                .span_label(ast_ty.span, \"reserved keyword\")\n-                .emit();\n-\n+                tcx.sess.emit_err(TypeofReservedKeywordUsed { span: ast_ty.span });\n                 tcx.ty_error()\n             }\n             hir::TyKind::Infer => {\n@@ -2283,13 +2260,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // error.\n         let r = derived_region_bounds[0];\n         if derived_region_bounds[1..].iter().any(|r1| r != *r1) {\n-            struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0227,\n-                \"ambiguous lifetime bound, explicit lifetime bound required\"\n-            )\n-            .emit();\n+            tcx.sess.emit_err(AmbiguousLifetimeBound { span });\n         }\n         Some(r)\n     }"}, {"sha": "bbf5153d35d9b361b2e23ad539fc40fec8b106bf", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -366,24 +367,18 @@ fn check_region_bounds_on_impl_item<'tcx>(\n         let item_kind = assoc_item_kind_str(impl_m);\n         let def_span = tcx.sess.source_map().guess_head_span(span);\n         let span = tcx.hir().get_generics(impl_m.def_id).map(|g| g.span).unwrap_or(def_span);\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n+        let generics_span = if let Some(sp) = tcx.hir().span_if_local(trait_m.def_id) {\n+            let def_sp = tcx.sess.source_map().guess_head_span(sp);\n+            Some(tcx.hir().get_generics(trait_m.def_id).map(|g| g.span).unwrap_or(def_sp))\n+        } else {\n+            None\n+        };\n+        tcx.sess.emit_err(LifetimesOrBoundsMismatchOnTrait {\n             span,\n-            E0195,\n-            \"lifetime parameters or bounds on {} `{}` do not match the trait declaration\",\n             item_kind,\n-            impl_m.ident,\n-        );\n-        err.span_label(span, &format!(\"lifetimes do not match {} in trait\", item_kind));\n-        if let Some(sp) = tcx.hir().span_if_local(trait_m.def_id) {\n-            let def_sp = tcx.sess.source_map().guess_head_span(sp);\n-            let sp = tcx.hir().get_generics(trait_m.def_id).map(|g| g.span).unwrap_or(def_sp);\n-            err.span_label(\n-                sp,\n-                &format!(\"lifetimes in impl do not match this {} in trait\", item_kind),\n-            );\n-        }\n-        err.emit();\n+            ident: impl_m.ident,\n+            generics_span,\n+        });\n         return Err(ErrorReported);\n     }\n "}, {"sha": "fa8b8dbd9f8d4f3d6d9efa7b92d497501ef58a4d", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 20, "deletions": 49, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -14,8 +14,13 @@ use crate::check::Expectation::{self, ExpectCastableToType, ExpectHasType, NoExp\n use crate::check::FnCtxt;\n use crate::check::Needs;\n use crate::check::TupleArgumentsFlag::DontTupleArguments;\n+use crate::errors::{\n+    FieldMultiplySpecifiedInInitializer, FunctionalRecordUpdateOnNonStruct,\n+    YieldExprOutsideOfGenerator,\n+};\n use crate::type_error_struct;\n \n+use crate::errors::{AddressOfTemporaryTaken, ReturnStmtOutsideOfFnBody, StructExprNonExhaustive};\n use rustc_ast as ast;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::FxHashMap;\n@@ -439,14 +444,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             })\n         });\n         if !is_named {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                oprnd.span,\n-                E0745,\n-                \"cannot take address of a temporary\"\n-            )\n-            .span_label(oprnd.span, \"temporary value\")\n-            .emit();\n+            self.tcx.sess.emit_err(AddressOfTemporaryTaken { span: oprnd.span })\n         }\n     }\n \n@@ -665,13 +663,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         if self.ret_coercion.is_none() {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                expr.span,\n-                E0572,\n-                \"return statement outside of function body\",\n-            )\n-            .emit();\n+            self.tcx.sess.emit_err(ReturnStmtOutsideOfFnBody { span: expr.span });\n         } else if let Some(ref e) = expr_opt {\n             if self.ret_coercion_span.borrow().is_none() {\n                 *self.ret_coercion_span.borrow_mut() = Some(e.span);\n@@ -740,6 +732,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr_span: &Span,\n     ) {\n         if !lhs.is_syntactic_place_expr() {\n+            // FIXME: Make this use SessionDiagnostic once error codes can be dynamically set.\n             let mut err = self.tcx.sess.struct_span_err_with_code(\n                 *expr_span,\n                 \"invalid left-hand side of assignment\",\n@@ -1120,14 +1113,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Prohibit struct expressions when non-exhaustive flag is set.\n         let adt = adt_ty.ty_adt_def().expect(\"`check_struct_path` returned non-ADT type\");\n         if !adt.did.is_local() && variant.is_field_list_non_exhaustive() {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                expr.span,\n-                E0639,\n-                \"cannot create non-exhaustive {} using struct expression\",\n-                adt.variant_descr()\n-            )\n-            .emit();\n+            self.tcx\n+                .sess\n+                .emit_err(StructExprNonExhaustive { span: expr.span, what: adt.variant_descr() });\n         }\n \n         let error_happened = self.check_expr_struct_fields(\n@@ -1165,13 +1153,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .insert(expr.hir_id, fru_field_types);\n                     }\n                     _ => {\n-                        struct_span_err!(\n-                            self.tcx.sess,\n-                            base_expr.span,\n-                            E0436,\n-                            \"functional record update syntax requires a struct\"\n-                        )\n-                        .emit();\n+                        self.tcx\n+                            .sess\n+                            .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n                     }\n                 }\n             }\n@@ -1234,18 +1218,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 error_happened = true;\n                 if let Some(prev_span) = seen_fields.get(&ident) {\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        field.ident.span,\n-                        E0062,\n-                        \"field `{}` specified more than once\",\n-                        ident\n-                    );\n-\n-                    err.span_label(field.ident.span, \"used more than once\");\n-                    err.span_label(*prev_span, format!(\"first use of `{}`\", ident));\n-\n-                    err.emit();\n+                    tcx.sess.emit_err(FieldMultiplySpecifiedInInitializer {\n+                        span: field.ident.span,\n+                        prev_span: *prev_span,\n+                        ident,\n+                    });\n                 } else {\n                     self.report_unknown_field(adt_ty, variant, field, ast_fields, kind_name, span);\n                 }\n@@ -1876,13 +1853,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx.mk_unit()\n             }\n             _ => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    expr.span,\n-                    E0627,\n-                    \"yield expression outside of generator literal\"\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(YieldExprOutsideOfGenerator { span: expr.span });\n                 self.tcx.mk_unit()\n             }\n         }"}, {"sha": "b8230f524446a6d33ea287b4d548d5ae4682b4ab", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 36, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -1,6 +1,10 @@\n //! Type-checking for the rust-intrinsic and platform-intrinsic\n //! intrinsics that the compiler exposes.\n \n+use crate::errors::{\n+    SimdShuffleMissingLength, UnrecognizedAtomicOperation, UnrecognizedIntrinsicFunction,\n+    WrongNumberOfTypeArgumentsToInstrinsic,\n+};\n use crate::require_same_types;\n \n use rustc_errors::struct_span_err;\n@@ -41,17 +45,11 @@ fn equate_intrinsic_type<'tcx>(\n             _ => bug!(),\n         };\n \n-        struct_span_err!(\n-            tcx.sess,\n+        tcx.sess.emit_err(WrongNumberOfTypeArgumentsToInstrinsic {\n             span,\n-            E0094,\n-            \"intrinsic has wrong number of type \\\n-                         parameters: found {}, expected {}\",\n-            i_n_tps,\n-            n_tps\n-        )\n-        .span_label(span, format!(\"expected {} type parameter\", n_tps))\n-        .emit();\n+            found: i_n_tps,\n+            expected: n_tps,\n+        });\n         return;\n     }\n \n@@ -146,15 +144,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             | \"umin\" => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], param(0)),\n             \"fence\" | \"singlethreadfence\" => (0, Vec::new(), tcx.mk_unit()),\n             op => {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    it.span,\n-                    E0092,\n-                    \"unrecognized atomic operation function: `{}`\",\n-                    op\n-                )\n-                .span_label(it.span, \"unrecognized atomic operation\")\n-                .emit();\n+                tcx.sess.emit_err(UnrecognizedAtomicOperation { span: it.span, op });\n                 return;\n             }\n         };\n@@ -380,15 +370,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             sym::nontemporal_store => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n \n             other => {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    it.span,\n-                    E0093,\n-                    \"unrecognized intrinsic function: `{}`\",\n-                    other,\n-                )\n-                .span_label(it.span, \"unrecognized intrinsic\")\n-                .emit();\n+                tcx.sess.emit_err(UnrecognizedIntrinsicFunction { span: it.span, name: other });\n                 return;\n             }\n         };\n@@ -468,14 +450,7 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n                     (2, params, param(1))\n                 }\n                 Err(_) => {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        it.span,\n-                        E0439,\n-                        \"invalid `simd_shuffle`, needs length: `{}`\",\n-                        name\n-                    )\n-                    .emit();\n+                    tcx.sess.emit_err(SimdShuffleMissingLength { span: it.span, name });\n                     return;\n                 }\n             }"}, {"sha": "14d80fded71220f4c3f27571a1b3627150783c9d", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -4,14 +4,14 @@ use super::NoMatchData;\n use super::{CandidateSource, ImplSource, TraitSource};\n \n use crate::check::FnCtxt;\n+use crate::errors::MethodCallOnUnknownType;\n use crate::hir::def::DefKind;\n use crate::hir::def_id::DefId;\n \n use rustc_ast as ast;\n use rustc_ast::util::lev_distance::{find_best_match_for_name, lev_distance};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n use rustc_infer::infer::canonical::OriginalQueryValues;\n@@ -376,14 +376,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // so we do a future-compat lint here for the 2015 edition\n                 // (see https://github.com/rust-lang/rust/issues/46906)\n                 if self.tcx.sess.rust_2018() {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0699,\n-                        \"the type of this value must be known to call a method on a raw pointer on \\\n-                         it\"\n-                    )\n-                    .emit();\n+                    self.tcx.sess.emit_err(MethodCallOnUnknownType { span });\n                 } else {\n                     self.tcx.struct_span_lint_hir(\n                         lint::builtin::TYVAR_BEHIND_RAW_POINTER,"}, {"sha": "89270fb6c77a5759182918311e79a2291ae7d146", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -1,6 +1,7 @@\n //! Check properties that are required by built-in traits and set\n //! up data structures required by type-checking/codegen.\n \n+use crate::errors::{CopyImplOnNonAdt, CopyImplOnTypeWithDtor, DropImplOnWrongItem};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -58,14 +59,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n         _ => bug!(\"expected Drop impl item\"),\n     };\n \n-    struct_span_err!(\n-        tcx.sess,\n-        sp,\n-        E0120,\n-        \"the `Drop` trait may only be implemented for structs, enums, and unions\",\n-    )\n-    .span_label(sp, \"must be a struct, enum, or union\")\n-    .emit();\n+    tcx.sess.emit_err(DropImplOnWrongItem { span: sp });\n }\n \n fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n@@ -108,25 +102,10 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n             let span =\n                 if let ItemKind::Impl { self_ty, .. } = item.kind { self_ty.span } else { span };\n \n-            struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0206,\n-                \"the trait `Copy` may not be implemented for this type\"\n-            )\n-            .span_label(span, \"type is not a structure or enumeration\")\n-            .emit();\n+            tcx.sess.emit_err(CopyImplOnNonAdt { span });\n         }\n         Err(CopyImplementationError::HasDestructor) => {\n-            struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0184,\n-                \"the trait `Copy` may not be implemented for this type; the \\\n-                              type has a destructor\"\n-            )\n-            .span_label(span, \"Copy not allowed on types with destructors\")\n-            .emit();\n+            tcx.sess.emit_err(CopyImplOnTypeWithDtor { span });\n         }\n     }\n }"}, {"sha": "ea59375bad7367a5649fe5c0f181a19e98a34098", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -18,6 +18,7 @@ use crate::astconv::{AstConv, SizedByDefault};\n use crate::bounds::Bounds;\n use crate::check::intrinsic::intrinsic_operation_unsafety;\n use crate::constrained_generic_params as cgp;\n+use crate::errors;\n use crate::middle::resolve_lifetime as rl;\n use rustc_ast as ast;\n use rustc_ast::MetaItemKind;\n@@ -834,16 +835,11 @@ fn convert_variant(\n             let fid = tcx.hir().local_def_id(f.hir_id);\n             let dup_span = seen_fields.get(&f.ident.normalize_to_macros_2_0()).cloned();\n             if let Some(prev_span) = dup_span {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    f.span,\n-                    E0124,\n-                    \"field `{}` is already declared\",\n-                    f.ident\n-                )\n-                .span_label(f.span, \"field already declared\")\n-                .span_label(prev_span, format!(\"`{}` first declared here\", f.ident))\n-                .emit();\n+                tcx.sess.emit_err(errors::FieldAlreadyDeclared {\n+                    field_name: f.ident,\n+                    span: f.span,\n+                    prev_span,\n+                });\n             } else {\n                 seen_fields.insert(f.ident.normalize_to_macros_2_0(), f.span);\n             }"}, {"sha": "4b3250a1d443a75741ef9dbdd84803fd494ec805", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -1,5 +1,6 @@\n+use crate::errors::AssocTypeOnInherentImpl;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{struct_span_err, Applicability, ErrorReported, StashKey};\n+use rustc_errors::{Applicability, ErrorReported, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -627,11 +628,5 @@ fn infer_placeholder_type(\n }\n \n fn report_assoc_ty_on_inherent_impl(tcx: TyCtxt<'_>, span: Span) {\n-    struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0202,\n-        \"associated types are not yet supported in inherent impls (see #8995)\"\n-    )\n-    .emit();\n+    tcx.sess.emit_err(AssocTypeOnInherentImpl { span });\n }"}, {"sha": "a769e48d2ca80bc8350cfeaf459663eaacd28d7a", "filename": "compiler/rustc_typeck/src/errors.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -0,0 +1,199 @@\n+//! Errors emitted by typeck.\n+use rustc_macros::SessionDiagnostic;\n+use rustc_span::{symbol::Ident, Span, Symbol};\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0062\"]\n+pub struct FieldMultiplySpecifiedInInitializer {\n+    #[message = \"field `{ident}` specified more than once\"]\n+    #[label = \"used more than once\"]\n+    pub span: Span,\n+    #[label = \"first use of `{ident}`\"]\n+    pub prev_span: Span,\n+    pub ident: Ident,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0092\"]\n+pub struct UnrecognizedAtomicOperation<'a> {\n+    #[message = \"unrecognized atomic operation function: `{op}`\"]\n+    #[label = \"unrecognized atomic operation\"]\n+    pub span: Span,\n+    pub op: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0094\"]\n+pub struct WrongNumberOfTypeArgumentsToInstrinsic {\n+    #[message = \"intrinsic has wrong number of type \\\n+                         parameters: found {found}, expected {expected}\"]\n+    #[label = \"expected {expected} type parameter\"]\n+    pub span: Span,\n+    pub found: usize,\n+    pub expected: usize,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0093\"]\n+pub struct UnrecognizedIntrinsicFunction {\n+    #[message = \"unrecognized intrinsic function: `{name}`\"]\n+    #[label = \"unrecognized intrinsic\"]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0195\"]\n+pub struct LifetimesOrBoundsMismatchOnTrait {\n+    #[message = \"lifetime parameters or bounds on {item_kind} `{ident}` do not match the trait declaration\"]\n+    #[label = \"lifetimes do not match {item_kind} in trait\"]\n+    pub span: Span,\n+    #[label = \"lifetimes in impl do not match this {item_kind} in trait\"]\n+    pub generics_span: Option<Span>,\n+    pub item_kind: &'static str,\n+    pub ident: Ident,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0120\"]\n+pub struct DropImplOnWrongItem {\n+    #[message = \"the `Drop` trait may only be implemented for structs, enums, and unions\"]\n+    #[label = \"must be a struct, enum, or union\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0124\"]\n+pub struct FieldAlreadyDeclared {\n+    pub field_name: Ident,\n+    #[message = \"field `{field_name}` is already declared\"]\n+    #[label = \"field already declared\"]\n+    pub span: Span,\n+    #[label = \"`{field_name}` first declared here\"]\n+    pub prev_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0184\"]\n+pub struct CopyImplOnTypeWithDtor {\n+    #[message = \"the trait `Copy` may not be implemented for this type; the \\\n+                              type has a destructor\"]\n+    #[label = \"Copy not allowed on types with destructors\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0202\"]\n+pub struct AssocTypeOnInherentImpl {\n+    #[message = \"associated types are not yet supported in inherent impls (see #8995)\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0203\"]\n+pub struct MultipleRelaxedDefaultBounds {\n+    #[message = \"type parameter has more than one relaxed default bound, only one is supported\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0206\"]\n+pub struct CopyImplOnNonAdt {\n+    #[message = \"the trait `Copy` may not be implemented for this type\"]\n+    #[label = \"type is not a structure or enumeration\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0224\"]\n+pub struct TraitObjectDeclaredWithNoTraits {\n+    #[message = \"at least one trait is required for an object type\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0227\"]\n+pub struct AmbiguousLifetimeBound {\n+    #[message = \"ambiguous lifetime bound, explicit lifetime bound required\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0229\"]\n+pub struct AssocTypeBindingNotAllowed {\n+    #[message = \"associated type bindings are not allowed here\"]\n+    #[label = \"associated type not allowed here\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0439\"]\n+pub struct SimdShuffleMissingLength {\n+    #[message = \"invalid `simd_shuffle`, needs length: `{name}`\"]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0436\"]\n+pub struct FunctionalRecordUpdateOnNonStruct {\n+    #[message = \"functional record update syntax requires a struct\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0516\"]\n+pub struct TypeofReservedKeywordUsed {\n+    #[message = \"`typeof` is a reserved keyword but unimplemented\"]\n+    #[label = \"reserved keyword\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0572\"]\n+pub struct ReturnStmtOutsideOfFnBody {\n+    #[message = \"return statement outside of function body\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0627\"]\n+pub struct YieldExprOutsideOfGenerator {\n+    #[message = \"yield expression outside of generator literal\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0639\"]\n+pub struct StructExprNonExhaustive {\n+    #[message = \"cannot create non-exhaustive {what} using struct expression\"]\n+    pub span: Span,\n+    pub what: &'static str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0699\"]\n+pub struct MethodCallOnUnknownType {\n+    #[message = \"the type of this value must be known to call a method on a raw pointer on it\"]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0719\"]\n+pub struct ValueOfAssociatedStructAlreadySpecified {\n+    #[message = \"the value of the associated type `{item_name}` (from trait `{def_path}`) is already specified\"]\n+    #[label = \"re-bound here\"]\n+    pub span: Span,\n+    #[label = \"`{item_name}` bound here first\"]\n+    pub prev_span: Span,\n+    pub item_name: Ident,\n+    pub def_path: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0745\"]\n+pub struct AddressOfTemporaryTaken {\n+    #[message = \"cannot take address of a temporary\"]\n+    #[label = \"temporary value\"]\n+    pub span: Span,\n+}"}, {"sha": "0e9f4476c20758d826fdba701286637a9e3b4f44", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -84,6 +84,7 @@ mod check_unused;\n mod coherence;\n mod collect;\n mod constrained_generic_params;\n+mod errors;\n mod impl_wf_check;\n mod mem_categorization;\n mod outlives;"}, {"sha": "7967b32a4a49113ecb12c08910f7b499c1ef7784", "filename": "src/test/ui-fulldeps/session-derive-errors.rs", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.rs?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -0,0 +1,260 @@\n+// check-fail\n+// Tests error conditions for specifying diagnostics using #[derive(SessionDiagnostic)]\n+\n+#![feature(rustc_private)]\n+#![crate_type = \"lib\"]\n+\n+extern crate rustc_span;\n+use rustc_span::Span;\n+use rustc_span::symbol::Ident;\n+\n+extern crate rustc_macros;\n+use rustc_macros::SessionDiagnostic;\n+\n+extern crate rustc_middle;\n+use rustc_middle::ty::Ty;\n+\n+extern crate rustc_errors;\n+use rustc_errors::Applicability;\n+\n+extern crate rustc_session;\n+\n+#[derive(SessionDiagnostic)]\n+#[message = \"Hello, world!\"]\n+#[error = \"E0123\"]\n+struct Hello {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+//~^ ERROR `#[derive(SessionDiagnostic)]` can only be used on structs\n+enum SessionDiagnosticOnEnum {\n+    Foo,\n+    Bar,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+#[label = \"This is in the wrong place\"]\n+//~^ ERROR `#[label = ...]` is not a valid SessionDiagnostic struct attribute\n+struct WrongPlace {}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct WrongPlaceField {\n+    #[suggestion = \"this is the wrong kind of attribute\"]\n+//~^ ERROR `#[suggestion = ...]` is not a valid SessionDiagnostic field attribute\n+    sp: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[message = \"Hello, world!\"]\n+#[error = \"E0123\"]\n+#[error = \"E0456\"] //~ ERROR `error` specified multiple times\n+struct ErrorSpecifiedTwice {}\n+\n+#[derive(SessionDiagnostic)]\n+#[message = \"Hello, world!\"]\n+#[error = \"E0123\"]\n+#[lint = \"some_useful_lint\"] //~ ERROR `lint` specified when `error` was already specified\n+struct LintSpecifiedAfterError {}\n+\n+#[derive(SessionDiagnostic)]\n+#[message = \"Some lint message\"]\n+#[error = \"E0123\"]\n+struct LintButHasErrorCode {}\n+\n+#[derive(SessionDiagnostic)]\n+struct ErrorCodeNotProvided {} //~ ERROR `code` not specified\n+\n+// FIXME: Uncomment when emitting lints is supported.\n+/*\n+#[derive(SessionDiagnostic)]\n+#[message = \"Hello, world!\"]\n+#[lint = \"clashing_extern_declarations\"]\n+#[lint = \"improper_ctypes\"] // FIXME: ERROR `lint` specified multiple times\n+struct LintSpecifiedTwice {}\n+\n+#[derive(SessionDiagnostic)]\n+#[lint = \"Some lint message\"]\n+#[message = \"Some error message\"]\n+#[error = \"E0123\"] // ERROR `error` specified when `lint` was already specified\n+struct ErrorSpecifiedAfterLint {}\n+*/\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct ErrorWithField {\n+    name: String,\n+    #[message = \"This error has a field, and references {name}\"]\n+    span: Span\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct ErrorWithMessageAppliedToField {\n+    #[message = \"this message is applied to a String field\"]\n+    //~^ ERROR the `#[message = \"...\"]` attribute can only be applied to fields of type Span\n+    name: String,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+#[message = \"This error has a field, and references {name}\"]\n+//~^ ERROR `name` doesn't refer to a field on this type\n+struct ErrorWithNonexistentField {\n+    span: Span\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+#[message = \"This is missing a closing brace: {name\"]\n+//~^ ERROR invalid format string: expected `'}'`\n+struct ErrorMissingClosingBrace {\n+    name: String,\n+    span: Span\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+#[message = \"This is missing an opening brace: name}\"]\n+//~^ ERROR invalid format string: unmatched `}`\n+struct ErrorMissingOpeningBrace {\n+    name: String,\n+    span: Span\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+#[message = \"Something something\"]\n+struct LabelOnSpan {\n+    #[label = \"See here\"]\n+    sp: Span\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+#[message = \"Something something\"]\n+struct LabelOnNonSpan {\n+    #[label = \"See here\"]\n+    //~^ ERROR The `#[label = ...]` attribute can only be applied to fields of type Span\n+    id: u32,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct Suggest {\n+    #[suggestion(message = \"This is a suggestion\", code = \"This is the suggested code\")]\n+    #[suggestion_short(message = \"This is a suggestion\", code = \"This is the suggested code\")]\n+    #[suggestion_hidden(message = \"This is a suggestion\", code = \"This is the suggested code\")]\n+    #[suggestion_verbose(message = \"This is a suggestion\", code = \"This is the suggested code\")]\n+    suggestion: (Span, Applicability),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithoutCode {\n+    #[suggestion(message = \"This is a suggestion\")]\n+    suggestion: (Span, Applicability),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithBadKey {\n+    #[suggestion(nonsense = \"This is nonsense\")]\n+    //~^ ERROR `nonsense` is not a valid key for `#[suggestion(...)]`\n+    suggestion: (Span, Applicability),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithShorthandMsg {\n+    #[suggestion(msg = \"This is a suggestion\")]\n+    //~^ ERROR `msg` is not a valid key for `#[suggestion(...)]`\n+    suggestion: (Span, Applicability),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithoutMsg {\n+    #[suggestion(code = \"This is suggested code\")]\n+    //~^ ERROR missing suggestion message\n+    suggestion: (Span, Applicability),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithTypesSwapped {\n+    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+    suggestion: (Applicability, Span),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithWrongTypeApplicabilityOnly {\n+    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+    //~^ ERROR wrong field type for suggestion\n+    suggestion: Applicability,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithSpanOnly{\n+    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+    suggestion: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithDuplicateSpanAndApplicability {\n+    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+    //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one Span\n+    suggestion: (Span, Span, Applicability),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct SuggestWithDuplicateApplicabilityAndSpan {\n+    #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+    //~^ ERROR type of field annotated with `#[suggestion(...)]` contains more than one\n+    suggestion: (Applicability, Applicability, Span),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct WrongKindOfAnnotation {\n+    #[label(\"wrong kind of annotation for label\")]\n+    //~^ ERROR invalid annotation list `#[label(...)]`\n+    z: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+#[message = \"Something something else\"]\n+struct OptionsInErrors {\n+    #[label = \"Label message\"]\n+    label: Option<Span>,\n+    #[suggestion(message = \"suggestion message\")]\n+    opt_sugg: Option<(Span, Applicability)>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0456\"]\n+struct MoveOutOfBorrowError<'tcx> {\n+    name: Ident,\n+    ty: Ty<'tcx>,\n+    #[message = \"cannot move {ty} out of borrow\"]\n+    #[label = \"cannot move out of borrow\"]\n+    span: Span,\n+    #[label = \"`{ty}` first borrowed here\"]\n+    other_span: Span,\n+    #[suggestion(message = \"consider cloning here\", code = \"{name}.clone()\")]\n+    opt_sugg: Option<(Span, Applicability)>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error = \"E0123\"]\n+struct ErrorWithLifetime<'a> {\n+    #[message = \"Some message that references {name}\"]\n+    span: Span,\n+    name: &'a str,\n+}"}, {"sha": "c1be151f1c1ce5d28f2a41e10d6e00e5f34140f2", "filename": "src/test/ui-fulldeps/session-derive-errors.stderr", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/71569e420107ab034910a4687f382385975fa0b3/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/71569e420107ab034910a4687f382385975fa0b3/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-derive-errors.stderr?ref=71569e420107ab034910a4687f382385975fa0b3", "patch": "@@ -0,0 +1,135 @@\n+error: `#[derive(SessionDiagnostic)]` can only be used on structs\n+  --> $DIR/session-derive-errors.rs:28:1\n+   |\n+LL | / #[error = \"E0123\"]\n+LL | |\n+LL | | enum SessionDiagnosticOnEnum {\n+LL | |     Foo,\n+LL | |     Bar,\n+LL | | }\n+   | |_^\n+\n+error: `#[label = ...]` is not a valid SessionDiagnostic struct attribute\n+  --> $DIR/session-derive-errors.rs:37:1\n+   |\n+LL | #[label = \"This is in the wrong place\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `#[suggestion = ...]` is not a valid SessionDiagnostic field attribute\n+  --> $DIR/session-derive-errors.rs:44:5\n+   |\n+LL |     #[suggestion = \"this is the wrong kind of attribute\"]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `error` specified multiple times\n+  --> $DIR/session-derive-errors.rs:52:11\n+   |\n+LL | #[error = \"E0456\"]\n+   |           ^^^^^^^\n+\n+error: `lint` specified when `error` was already specified\n+  --> $DIR/session-derive-errors.rs:58:10\n+   |\n+LL | #[lint = \"some_useful_lint\"]\n+   |          ^^^^^^^^^^^^^^^^^^\n+\n+error: `code` not specified\n+  --> $DIR/session-derive-errors.rs:67:1\n+   |\n+LL | struct ErrorCodeNotProvided {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use the [code = \"...\"] attribute to set this diagnostic's error code \n+\n+error: the `#[message = \"...\"]` attribute can only be applied to fields of type Span\n+  --> $DIR/session-derive-errors.rs:95:5\n+   |\n+LL |     #[message = \"this message is applied to a String field\"]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `name` doesn't refer to a field on this type\n+  --> $DIR/session-derive-errors.rs:102:1\n+   |\n+LL | #[message = \"This error has a field, and references {name}\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid format string: expected `'}'` but string was terminated\n+  --> $DIR/session-derive-errors.rs:110:1\n+   |\n+LL | #[error = \"E0123\"]\n+   |               - because of this opening brace\n+LL | #[message = \"This is missing a closing brace: {name\"]\n+   | ^ expected `'}'` in format string\n+   |\n+   = note: if you intended to print `{`, you can escape it using `{{`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: invalid format string: unmatched `}` found\n+  --> $DIR/session-derive-errors.rs:119:1\n+   |\n+LL | #[message = \"This is missing an opening brace: name}\"]\n+   | ^ unmatched `}` in format string\n+   |\n+   = note: if you intended to print `}`, you can escape it using `}}`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: The `#[label = ...]` attribute can only be applied to fields of type Span\n+  --> $DIR/session-derive-errors.rs:138:5\n+   |\n+LL |     #[label = \"See here\"]\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `nonsense` is not a valid key for `#[suggestion(...)]`\n+  --> $DIR/session-derive-errors.rs:163:18\n+   |\n+LL |     #[suggestion(nonsense = \"This is nonsense\")]\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `msg` is not a valid key for `#[suggestion(...)]`\n+  --> $DIR/session-derive-errors.rs:171:18\n+   |\n+LL |     #[suggestion(msg = \"This is a suggestion\")]\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: missing suggestion message\n+  --> $DIR/session-derive-errors.rs:179:7\n+   |\n+LL |     #[suggestion(code = \"This is suggested code\")]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: provide a suggestion message using #[suggestion(message = \"...\")]\n+\n+error: wrong field type for suggestion\n+  --> $DIR/session-derive-errors.rs:194:5\n+   |\n+LL | /     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+LL | |\n+LL | |     suggestion: Applicability,\n+   | |_____________________________^\n+   |\n+   = help: #[suggestion(...)] should be applied to fields of type Span or (Span, Applicability)\n+\n+error: type of field annotated with `#[suggestion(...)]` contains more than one Span\n+  --> $DIR/session-derive-errors.rs:209:5\n+   |\n+LL | /     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+LL | |\n+LL | |     suggestion: (Span, Span, Applicability),\n+   | |___________________________________________^\n+\n+error: type of field annotated with `#[suggestion(...)]` contains more than one Applicability\n+  --> $DIR/session-derive-errors.rs:217:5\n+   |\n+LL | /     #[suggestion(message = \"This is a message\", code = \"This is suggested code\")]\n+LL | |\n+LL | |     suggestion: (Applicability, Applicability, Span),\n+   | |____________________________________________________^\n+\n+error: invalid annotation list `#[label(...)]`\n+  --> $DIR/session-derive-errors.rs:225:7\n+   |\n+LL |     #[label(\"wrong kind of annotation for label\")]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 18 previous errors\n+"}]}