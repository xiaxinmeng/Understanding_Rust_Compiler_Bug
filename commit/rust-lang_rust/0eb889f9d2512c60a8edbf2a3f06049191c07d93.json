{"sha": "0eb889f9d2512c60a8edbf2a3f06049191c07d93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYjg4OWY5ZDI1MTJjNjBhOGVkYmYyYTNmMDYwNDkxOTFjMDdkOTM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-01T23:15:09Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-06T18:09:06Z"}, "message": "rustc: Make type parameter substitutions interior vectors", "tree": {"sha": "5f2eb7217109d6ecae945cea4d75fc6251f1bc40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f2eb7217109d6ecae945cea4d75fc6251f1bc40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0eb889f9d2512c60a8edbf2a3f06049191c07d93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0eb889f9d2512c60a8edbf2a3f06049191c07d93", "html_url": "https://github.com/rust-lang/rust/commit/0eb889f9d2512c60a8edbf2a3f06049191c07d93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0eb889f9d2512c60a8edbf2a3f06049191c07d93/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bee69da25871dc135dd95ac869ecbb17e2a87c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bee69da25871dc135dd95ac869ecbb17e2a87c0", "html_url": "https://github.com/rust-lang/rust/commit/8bee69da25871dc135dd95ac869ecbb17e2a87c0"}], "stats": {"total": 69, "additions": 34, "deletions": 35}, "files": [{"sha": "b5bc3340665bde0eff1974c8ef0b756b0e5b3bf8", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eb889f9d2512c60a8edbf2a3f06049191c07d93/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb889f9d2512c60a8edbf2a3f06049191c07d93/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0eb889f9d2512c60a8edbf2a3f06049191c07d93", "patch": "@@ -4891,7 +4891,7 @@ fn lval_generic_fn(&@block_ctxt cx, &ty::ty_param_count_and_ty tpt,\n         lv = trans_external_path(cx, fn_id, tpt);\n     }\n     auto tys = ty::node_id_to_type_params(cx.fcx.lcx.ccx.tcx, id);\n-    if (vec::len[ty::t](tys) != 0u) {\n+    if (std::ivec::len[ty::t](tys) != 0u) {\n         auto bcx = lv.res.bcx;\n         let vec[ValueRef] tydescs = [];\n         let vec[option::t[@tydesc_info]] tis = [];"}, {"sha": "3d60eba98af14cd2e079930a44a36820e97ffc25", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0eb889f9d2512c60a8edbf2a3f06049191c07d93/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb889f9d2512c60a8edbf2a3f06049191c07d93/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=0eb889f9d2512c60a8edbf2a3f06049191c07d93", "patch": "@@ -351,7 +351,7 @@ const uint idx_first_others = 21u;\n \n type type_store = interner::interner[raw_t];\n \n-type ty_param_substs_opt_and_ty = tup(option::t[vec[ty::t]], ty::t);\n+type ty_param_substs_opt_and_ty = tup(option::t[ty::t[]], ty::t);\n \n type node_type_table =\n     @smallintmap::smallintmap[ty::ty_param_substs_opt_and_ty];\n@@ -1748,16 +1748,16 @@ fn node_id_to_type(&ctxt cx, &ast::node_id id) -> t {\n     ret node_id_to_ty_param_substs_opt_and_ty(cx, id)._1;\n }\n \n-fn node_id_to_type_params(&ctxt cx, &ast::node_id id) -> vec[t] {\n+fn node_id_to_type_params(&ctxt cx, &ast::node_id id) -> t[] {\n     alt (node_id_to_ty_param_substs_opt_and_ty(cx, id)._0) {\n-        case (none) { let vec[t] result = []; ret result; }\n+        case (none)       { ret ~[]; }\n         case (some(?tps)) { ret tps; }\n     }\n }\n \n fn node_id_has_type_params(&ctxt cx, &ast::node_id id) -> bool {\n     auto tpt = node_id_to_ty_param_substs_opt_and_ty(cx, id);\n-    ret !option::is_none[vec[t]](tpt._0);\n+    ret !option::is_none[t[]](tpt._0);\n }\n \n \n@@ -1883,7 +1883,7 @@ fn expr_ty(&ctxt cx, &@ast::expr expr) -> t {\n     ret node_id_to_monotype(cx, expr.id);\n }\n \n-fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr) -> tup(vec[t], t) {\n+fn expr_ty_params_and_ty(&ctxt cx, &@ast::expr expr) -> tup(t[], t) {\n     ret tup(node_id_to_type_params(cx, expr.id),\n             node_id_to_type(cx, expr.id));\n }"}, {"sha": "daf2cc75be5c61b278078d633a222285b133d757", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0eb889f9d2512c60a8edbf2a3f06049191c07d93/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eb889f9d2512c60a8edbf2a3f06049191c07d93/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=0eb889f9d2512c60a8edbf2a3f06049191c07d93", "patch": "@@ -157,7 +157,7 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n     auto ty_substs_opt;\n     auto ty_substs_len = vec::len[@ast::ty](pth.node.types);\n     if (ty_substs_len > 0u) {\n-        let vec[ty::t] ty_substs = [];\n+        let ty::t[] ty_substs = ~[];\n         auto i = 0u;\n         while (i < ty_substs_len) {\n             // TODO: Report an error if the number of type params in the item\n@@ -166,10 +166,10 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n             auto ty_var = ty::mk_var(fcx.ccx.tcx, ty_param_vars.(i));\n             auto ty_subst = ast_ty_to_ty_crate(fcx.ccx, pth.node.types.(i));\n             auto res_ty = demand::simple(fcx, pth.span, ty_var, ty_subst);\n-            ty_substs += [res_ty];\n+            ty_substs += ~[res_ty];\n             i += 1u;\n         }\n-        ty_substs_opt = some[vec[ty::t]](ty_substs);\n+        ty_substs_opt = some[ty::t[]](ty_substs);\n         if (ty_param_count == 0u) {\n             fcx.ccx.tcx.sess.span_fatal(sp,\n                                       \"this item does not take type \" +\n@@ -179,13 +179,13 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n     } else {\n         // We will acquire the type parameters through unification.\n \n-        let vec[ty::t] ty_substs = [];\n+        let ty::t[] ty_substs = ~[];\n         auto i = 0u;\n         while (i < ty_param_count) {\n-            ty_substs += [ty::mk_var(fcx.ccx.tcx, ty_param_vars.(i))];\n+            ty_substs += ~[ty::mk_var(fcx.ccx.tcx, ty_param_vars.(i))];\n             i += 1u;\n         }\n-        ty_substs_opt = some[vec[ty::t]](ty_substs);\n+        ty_substs_opt = some[ty::t[]](ty_substs);\n     }\n     ret tup(ty_substs_opt, tpt._1);\n }\n@@ -435,23 +435,23 @@ mod write {\n \n     // Writes a type with no type parameters into the node type table.\n     fn ty_only(&ty::ctxt tcx, ast::node_id node_id, ty::t typ) {\n-        ret ty(tcx, node_id, tup(none[vec[ty::t]], typ));\n+        ret ty(tcx, node_id, tup(none[ty::t[]], typ));\n     }\n \n     // Writes a type with no type parameters into the node type table. This\n     // function allows for the possibility of type variables.\n     fn ty_only_fixup(@fn_ctxt fcx, ast::node_id node_id, ty::t typ) {\n-        ret ty_fixup(fcx, node_id, tup(none[vec[ty::t]], typ));\n+        ret ty_fixup(fcx, node_id, tup(none[ty::t[]], typ));\n     }\n \n     // Writes a nil type into the node type table.\n     fn nil_ty(&ty::ctxt tcx, ast::node_id node_id) {\n-        ret ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_nil(tcx)));\n+        ret ty(tcx, node_id, tup(none[ty::t[]], ty::mk_nil(tcx)));\n     }\n \n     // Writes the bottom type into the node type table.\n     fn bot_ty(&ty::ctxt tcx, ast::node_id node_id) {\n-        ret ty(tcx, node_id, tup(none[vec[ty::t]], ty::mk_bot(tcx)));\n+        ret ty(tcx, node_id, tup(none[ty::t[]], ty::mk_bot(tcx)));\n     }\n }\n \n@@ -912,24 +912,22 @@ fn resolve_type_vars_if_possible(&@fn_ctxt fcx, ty::t typ) -> ty::t {\n \n // Demands - procedures that require that two types unify and emit an error\n // message if they don't.\n-type ty_param_substs_and_ty = tup(vec[ty::t], ty::t);\n+type ty_param_substs_and_ty = tup(ty::t[], ty::t);\n \n mod demand {\n     fn simple(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual) ->\n        ty::t {\n-        let vec[ty::t] tps = [];\n-        ret full(fcx, sp, expected, actual, tps, NO_AUTODEREF)._1;\n+        ret full(fcx, sp, expected, actual, ~[], NO_AUTODEREF)._1;\n     }\n     fn autoderef(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual,\n                  autoderef_kind adk) -> ty::t {\n-        let vec[ty::t] tps = [];\n-        ret full(fcx, sp, expected, actual, tps, adk)._1;\n+        ret full(fcx, sp, expected, actual, ~[], adk)._1;\n     }\n \n     // Requires that the two types unify, and prints an error message if they\n     // don't. Returns the unified type and the type parameter substitutions.\n     fn full(&@fn_ctxt fcx, &span sp, &ty::t expected, &ty::t actual,\n-            &vec[ty::t] ty_param_substs_0, autoderef_kind adk) ->\n+            &ty::t[] ty_param_substs_0, autoderef_kind adk) ->\n        ty_param_substs_and_ty {\n         auto expected_1 = expected;\n         auto actual_1 = actual;\n@@ -954,10 +952,10 @@ mod demand {\n         fn mk_result(&@fn_ctxt fcx, &ty::t result_ty,\n                      &vec[int] ty_param_subst_var_ids,\n                      uint implicit_boxes) -> ty_param_substs_and_ty {\n-            let vec[ty::t] result_ty_param_substs = [];\n+            let ty::t[] result_ty_param_substs = ~[];\n             for (int var_id in ty_param_subst_var_ids) {\n                 auto tp_subst = ty::mk_var(fcx.ccx.tcx, var_id);\n-                result_ty_param_substs += [tp_subst];\n+                result_ty_param_substs += ~[tp_subst];\n             }\n             ret tup(result_ty_param_substs,\n                     add_boxes(fcx.ccx, implicit_boxes, result_ty));\n@@ -1047,13 +1045,14 @@ mod writeback {\n         auto new_ty = resolve_type_vars_in_type(fcx, sp, tpot._1);\n         auto new_substs_opt;\n         alt (tpot._0) {\n-            case (none[vec[ty::t]]) { new_substs_opt = none[vec[ty::t]]; }\n-            case (some[vec[ty::t]](?substs)) {\n-                let vec[ty::t] new_substs = [];\n+            case (none[ty::t[]]) { new_substs_opt = none[ty::t[]]; }\n+            case (some[ty::t[]](?substs)) {\n+                let ty::t[] new_substs = ~[];\n                 for (ty::t subst in substs) {\n-                    new_substs += [resolve_type_vars_in_type(fcx, sp, subst)];\n+                    new_substs += ~[resolve_type_vars_in_type(fcx, sp,\n+                                                              subst)];\n                 }\n-                new_substs_opt = some[vec[ty::t]](new_substs);\n+                new_substs_opt = some[ty::t[]](new_substs);\n             }\n         }\n         write::ty(fcx.ccx.tcx, id, tup(new_substs_opt, new_ty));\n@@ -1234,11 +1233,11 @@ fn gather_locals(&@crate_ctxt ccx, &ast::fn_decl decl, &ast::block body,\n \n // AST fragment utilities\n fn replace_expr_type(&@fn_ctxt fcx, &@ast::expr expr,\n-                     &tup(vec[ty::t], ty::t) new_tyt) {\n+                     &tup(ty::t[], ty::t) new_tyt) {\n     auto new_tps;\n     if (ty::expr_has_ty_params(fcx.ccx.tcx, expr)) {\n-        new_tps = some[vec[ty::t]](new_tyt._0);\n-    } else { new_tps = none[vec[ty::t]]; }\n+        new_tps = some[ty::t[]](new_tyt._0);\n+    } else { new_tps = none[ty::t[]]; }\n     write::ty_fixup(fcx, expr.id, tup(new_tps, new_tyt._1));\n }\n \n@@ -1295,13 +1294,13 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n                                                                path_tpot);\n \n                 // FIXME: Remove this ivec->vec conversion.\n-                auto tps_vec = [];\n-                for (ty::t tp in expected_tps) { tps_vec += [tp]; }\n+                auto tps_vec = ~[];\n+                for (ty::t tp in expected_tps) { tps_vec += ~[tp]; }\n \n                 auto path_tpt =\n                     demand::full(fcx, pat.span, expected, ctor_ty, tps_vec,\n                                  NO_AUTODEREF);\n-                path_tpot = tup(some[vec[ty::t]](path_tpt._0), path_tpt._1);\n+                path_tpot = tup(some[ty::t[]](path_tpt._0), path_tpt._1);\n                 // Get the number of arguments in this tag variant.\n \n                 auto arg_types ="}]}