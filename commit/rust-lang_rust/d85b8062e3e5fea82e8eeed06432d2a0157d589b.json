{"sha": "d85b8062e3e5fea82e8eeed06432d2a0157d589b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NWI4MDYyZTNlNWZlYTgyZThlZWVkMDY0MzJkMmEwMTU3ZDU4OWI=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-06-06T00:09:19Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-06-09T22:09:17Z"}, "message": "Format all `if_let_chain` consistently", "tree": {"sha": "cbb7357005f5421d407cdb187e5ea3a7e1ede3f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbb7357005f5421d407cdb187e5ea3a7e1ede3f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d85b8062e3e5fea82e8eeed06432d2a0157d589b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJXWekNAAoJEF5CfHlMukXol2MP/1Ql2G1fZQ4fn3UKUTHYP2pG\nfl+NxOLUcAOj2f4Wyp6tiYymLpu6iMoHEPUj2DhFzKX4ggnGXQnmu476kq8lZ0UE\nu6yp8VwlLjtJSyPsb522X/DCoCUN8XmaP3zQpB3WNevEqCaq3trm0Ln4t9i/K4Dl\nAfbpCrc59Stq9JMcc2zTIOQ92uUn/yzxcM2MZiEOvfBWjDlUBsEhpQ/Uh4IJfdgp\nqGi4HmEj7JcI9mx1sr6VqYLarDxgwB3oNNMWmpHv+RpN0tueoCfuNEQ9nALmLunB\nX+Y9Lnhs6ibUBxEE5ShlleVD95pDlliZc3rOR0PKF9MjXUFm0kUUjpLBI5O2KCcT\nrgvRtp+uBIKuJg9txbnIipYK7lnzvZwb7sWXAP/io7tQTgfgnOipQ610DtHjmFBt\nNdke249tVtNefbhObFtYZGURHHWQGKvdoK6iJ2IBRX7WKYZzy8sM+yF2/fW90SrK\nyoktcIgPJFmWJ0A0gLHppU5hmUnhqmjxfMhTcrCHuDNxUPkzCEblI1p4kmJTV5q9\nLKUEjifQ3pTa8TQDxTP63lLarmSlcwngxNBj5pSR2k4zkFtXPnTFOo8x2ld5GgIy\nCB7G/co3+pBp4HdEBlXEo6YC5w2F9YBHUtniZSBE+kN9NkJvLe9sHC5reSBRHOfg\nuey55gqoLCI/6BjPJw2P\n=XK/j\n-----END PGP SIGNATURE-----", "payload": "tree cbb7357005f5421d407cdb187e5ea3a7e1ede3f2\nparent 44cb6106a7e6b9d090b87cc904e4b1df3b2c164a\nauthor mcarton <cartonmartin+git@gmail.com> 1465171759 +0200\ncommitter mcarton <cartonmartin+git@gmail.com> 1465510157 +0200\n\nFormat all `if_let_chain` consistently\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d85b8062e3e5fea82e8eeed06432d2a0157d589b", "html_url": "https://github.com/rust-lang/rust/commit/d85b8062e3e5fea82e8eeed06432d2a0157d589b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d85b8062e3e5fea82e8eeed06432d2a0157d589b/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44cb6106a7e6b9d090b87cc904e4b1df3b2c164a", "url": "https://api.github.com/repos/rust-lang/rust/commits/44cb6106a7e6b9d090b87cc904e4b1df3b2c164a", "html_url": "https://github.com/rust-lang/rust/commit/44cb6106a7e6b9d090b87cc904e4b1df3b2c164a"}], "stats": {"total": 374, "additions": 175, "deletions": 199}, "files": [{"sha": "bc209fd4846e8b0e98725e60315fba65d7e9bfa2", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=d85b8062e3e5fea82e8eeed06432d2a0157d589b", "patch": "@@ -120,7 +120,6 @@ impl<'a, 'tcx, 'v, 'b> Visitor<'v> for InsertVisitor<'a, 'tcx, 'b> {\n             get_item_name(self.cx, self.map) == get_item_name(self.cx, &*params[0]),\n             SpanlessEq::new(self.cx).eq_expr(self.key, &params[1])\n         ], {\n-\n             span_lint_and_then(self.cx, MAP_ENTRY, self.span,\n                                &format!(\"usage of `contains_key` followed by `insert` on `{}`\", self.ty), |db| {\n                 if self.sole_expr {"}, {"sha": "f3f10fae16e447f077fa21fbf7d0960ad473eead", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=d85b8062e3e5fea82e8eeed06432d2a0157d589b", "patch": "@@ -667,30 +667,28 @@ impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n         if let ExprPath(None, ref path) = expr.node {\n             if path.segments.len() == 1 && path.segments[0].name == self.var {\n                 // we are referencing our variable! now check if it's as an index\n-                if_let_chain! {\n-                    [\n-                        let Some(parexpr) = get_parent_expr(self.cx, expr),\n-                        let ExprIndex(ref seqexpr, _) = parexpr.node,\n-                        let ExprPath(None, ref seqvar) = seqexpr.node,\n-                        seqvar.segments.len() == 1\n-                    ], {\n-                        let def_map = self.cx.tcx.def_map.borrow();\n-                        if let Some(def) = def_map.get(&seqexpr.id) {\n-                            match def.base_def {\n-                                Def::Local(..) | Def::Upvar(..) => {\n-                                    let extent = self.cx.tcx.region_maps.var_scope(def.base_def.var_id());\n-                                    self.indexed.insert(seqvar.segments[0].name, Some(extent));\n-                                    return;  // no need to walk further\n-                                }\n-                                Def::Static(..) | Def::Const(..) => {\n-                                    self.indexed.insert(seqvar.segments[0].name, None);\n-                                    return;  // no need to walk further\n-                                }\n-                                _ => (),\n+                if_let_chain! {[\n+                    let Some(parexpr) = get_parent_expr(self.cx, expr),\n+                    let ExprIndex(ref seqexpr, _) = parexpr.node,\n+                    let ExprPath(None, ref seqvar) = seqexpr.node,\n+                    seqvar.segments.len() == 1\n+                ], {\n+                    let def_map = self.cx.tcx.def_map.borrow();\n+                    if let Some(def) = def_map.get(&seqexpr.id) {\n+                        match def.base_def {\n+                            Def::Local(..) | Def::Upvar(..) => {\n+                                let extent = self.cx.tcx.region_maps.var_scope(def.base_def.var_id());\n+                                self.indexed.insert(seqvar.segments[0].name, Some(extent));\n+                                return;  // no need to walk further\n                             }\n+                            Def::Static(..) | Def::Const(..) => {\n+                                self.indexed.insert(seqvar.segments[0].name, None);\n+                                return;  // no need to walk further\n+                            }\n+                            _ => (),\n                         }\n                     }\n-                }\n+                }}\n                 // we are not indexing anything, record that\n                 self.nonindex = true;\n                 return;"}, {"sha": "168aade325deebf74e61261ee00d29f534bb5e6a", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=d85b8062e3e5fea82e8eeed06432d2a0157d589b", "patch": "@@ -27,8 +27,7 @@ impl LateLintPass for MapClonePass {\n             if name.node.as_str() == \"map\" && args.len() == 2 {\n                 match args[1].node {\n                     ExprClosure(_, ref decl, ref blk, _) => {\n-                        if_let_chain! {\n-                            [\n+                        if_let_chain! {[\n                             // just one expression in the closure\n                             blk.stmts.is_empty(),\n                             let Some(ref closure_expr) = blk.expr,\n@@ -37,32 +36,31 @@ impl LateLintPass for MapClonePass {\n                             let Some(arg_ident) = get_arg_name(&*decl.inputs[0].pat),\n                             // the method is being called on a known type (option or iterator)\n                             let Some(type_name) = get_type_name(cx, expr, &args[0])\n-                            ], {\n-                                // look for derefs, for .map(|x| *x)\n-                                if only_derefs(cx, &*closure_expr, arg_ident) &&\n-                                    // .cloned() only removes one level of indirection, don't lint on more\n-                                    walk_ptrs_ty_depth(cx.tcx.pat_ty(&*decl.inputs[0].pat)).1 == 1\n+                        ], {\n+                            // look for derefs, for .map(|x| *x)\n+                            if only_derefs(cx, &*closure_expr, arg_ident) &&\n+                                // .cloned() only removes one level of indirection, don't lint on more\n+                                walk_ptrs_ty_depth(cx.tcx.pat_ty(&*decl.inputs[0].pat)).1 == 1\n+                            {\n+                                span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n+                                    \"you seem to be using .map() to clone the contents of an {}, consider \\\n+                                    using `.cloned()`\", type_name),\n+                                    &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n+                            }\n+                            // explicit clone() calls ( .map(|x| x.clone()) )\n+                            else if let ExprMethodCall(clone_call, _, ref clone_args) = closure_expr.node {\n+                                if clone_call.node.as_str() == \"clone\" &&\n+                                    clone_args.len() == 1 &&\n+                                    match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n+                                    expr_eq_name(&clone_args[0], arg_ident)\n                                 {\n                                     span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n                                         \"you seem to be using .map() to clone the contents of an {}, consider \\\n                                         using `.cloned()`\", type_name),\n                                         &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n                                 }\n-                                // explicit clone() calls ( .map(|x| x.clone()) )\n-                                else if let ExprMethodCall(clone_call, _, ref clone_args) = closure_expr.node {\n-                                    if clone_call.node.as_str() == \"clone\" &&\n-                                        clone_args.len() == 1 &&\n-                                        match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n-                                        expr_eq_name(&clone_args[0], arg_ident)\n-                                    {\n-                                        span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n-                                            \"you seem to be using .map() to clone the contents of an {}, consider \\\n-                                            using `.cloned()`\", type_name),\n-                                            &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n-                                    }\n-                                }\n                             }\n-                        }\n+                        }}\n                     }\n                     ExprPath(_, ref path) => {\n                         if match_path(path, &paths::CLONE) {"}, {"sha": "3d9795b0c38f142cd225de796d9843546e93deba", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=d85b8062e3e5fea82e8eeed06432d2a0157d589b", "patch": "@@ -55,33 +55,31 @@ impl LateLintPass for TopLevelRefPass {\n         }\n     }\n     fn check_stmt(&mut self, cx: &LateContext, s: &Stmt) {\n-        if_let_chain! {\n-            [\n+        if_let_chain! {[\n             let StmtDecl(ref d, _) = s.node,\n             let DeclLocal(ref l) = d.node,\n             let PatKind::Binding(BindByRef(_), i, None) = l.pat.node,\n             let Some(ref init) = l.init\n-            ], {\n-                let tyopt = if let Some(ref ty) = l.ty {\n-                    format!(\": {}\", snippet(cx, ty.span, \"_\"))\n-                } else {\n-                    \"\".to_owned()\n-                };\n-                span_lint_and_then(cx,\n-                    TOPLEVEL_REF_ARG,\n-                    l.pat.span,\n-                    \"`ref` on an entire `let` pattern is discouraged, take a reference with & instead\",\n-                    |db| {\n-                        db.span_suggestion(s.span,\n-                                           \"try\",\n-                                           format!(\"let {}{} = &{};\",\n-                                                   snippet(cx, i.span, \"_\"),\n-                                                   tyopt,\n-                                                   snippet(cx, init.span, \"_\")));\n-                    }\n-                );\n-            }\n-        };\n+        ], {\n+            let tyopt = if let Some(ref ty) = l.ty {\n+                format!(\": {}\", snippet(cx, ty.span, \"_\"))\n+            } else {\n+                \"\".to_owned()\n+            };\n+            span_lint_and_then(cx,\n+                TOPLEVEL_REF_ARG,\n+                l.pat.span,\n+                \"`ref` on an entire `let` pattern is discouraged, take a reference with & instead\",\n+                |db| {\n+                    db.span_suggestion(s.span,\n+                                       \"try\",\n+                                       format!(\"let {}{} = &{};\",\n+                                               snippet(cx, i.span, \"_\"),\n+                                               tyopt,\n+                                               snippet(cx, init.span, \"_\")));\n+                }\n+            );\n+        }}\n     }\n }\n "}, {"sha": "5e4386fb778b5ba0dded77ca6d64e17e1ae5b3f3", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=d85b8062e3e5fea82e8eeed06432d2a0157d589b", "patch": "@@ -26,14 +26,14 @@ impl LateLintPass for OverflowCheckConditional {\n     // a + b < a, a > a + b, a < a - b, a - b > a\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if_let_chain! {[\n-        let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n-        let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node,\n-        let Expr_::ExprPath(_,ref path1) = ident1.node,\n-        let Expr_::ExprPath(_, ref path2) = ident2.node,\n-        let Expr_::ExprPath(_, ref path3) = second.node,\n-        &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n-        cx.tcx.expr_ty(ident1).is_integral(),\n-        cx.tcx.expr_ty(ident2).is_integral()\n+            let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n+            let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node,\n+            let Expr_::ExprPath(_,ref path1) = ident1.node,\n+            let Expr_::ExprPath(_, ref path2) = ident2.node,\n+            let Expr_::ExprPath(_, ref path3) = second.node,\n+            &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n+            cx.tcx.expr_ty(ident1).is_integral(),\n+            cx.tcx.expr_ty(ident2).is_integral()\n         ], {\n             if let BinOp_::BiLt = op.node {\n                 if let BinOp_::BiAdd = op2.node {\n@@ -48,14 +48,14 @@ impl LateLintPass for OverflowCheckConditional {\n         }}\n \n         if_let_chain! {[\n-        let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n-        let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = second.node,\n-        let Expr_::ExprPath(_,ref path1) = ident1.node,\n-        let Expr_::ExprPath(_, ref path2) = ident2.node,\n-        let Expr_::ExprPath(_, ref path3) = first.node,\n-        &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n-        cx.tcx.expr_ty(ident1).is_integral(),\n-        cx.tcx.expr_ty(ident2).is_integral()\n+            let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n+            let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = second.node,\n+            let Expr_::ExprPath(_,ref path1) = ident1.node,\n+            let Expr_::ExprPath(_, ref path2) = ident2.node,\n+            let Expr_::ExprPath(_, ref path3) = first.node,\n+            &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n+            cx.tcx.expr_ty(ident1).is_integral(),\n+            cx.tcx.expr_ty(ident2).is_integral()\n         ], {\n             if let BinOp_::BiGt = op.node {\n                 if let BinOp_::BiAdd = op2.node {"}, {"sha": "8eacbadf8df6c2da3aee162a6a966173938a7c66", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=d85b8062e3e5fea82e8eeed06432d2a0157d589b", "patch": "@@ -49,29 +49,27 @@ impl LateLintPass for StepByZero {\n             } else if name.as_str() == \"zip\" && args.len() == 2 {\n                 let iter = &args[0].node;\n                 let zip_arg = &args[1];\n-                if_let_chain! {\n-                    [\n-                        // .iter() call\n-                        let ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = *iter,\n-                        iter_name.as_str() == \"iter\",\n-                        // range expression in .zip() call: 0..x.len()\n-                        let Some(UnsugaredRange { start: Some(ref start), end: Some(ref end), .. }) = unsugar_range(zip_arg),\n-                        is_integer_literal(start, 0),\n-                        // .len() call\n-                        let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,\n-                        len_name.as_str() == \"len\" && len_args.len() == 1,\n-                        // .iter() and .len() called on same Path\n-                        let ExprPath(_, Path { segments: ref iter_path, .. }) = iter_args[0].node,\n-                        let ExprPath(_, Path { segments: ref len_path, .. }) = len_args[0].node,\n-                        iter_path == len_path\n-                     ], {\n-                        span_lint(cx,\n-                                  RANGE_ZIP_WITH_LEN,\n-                                  expr.span,\n-                                  &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n-                                           snippet(cx, iter_args[0].span, \"_\")));\n-                    }\n-                }\n+                if_let_chain! {[\n+                    // .iter() call\n+                    let ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = *iter,\n+                    iter_name.as_str() == \"iter\",\n+                    // range expression in .zip() call: 0..x.len()\n+                    let Some(UnsugaredRange { start: Some(ref start), end: Some(ref end), .. }) = unsugar_range(zip_arg),\n+                    is_integer_literal(start, 0),\n+                    // .len() call\n+                    let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,\n+                    len_name.as_str() == \"len\" && len_args.len() == 1,\n+                    // .iter() and .len() called on same Path\n+                    let ExprPath(_, Path { segments: ref iter_path, .. }) = iter_args[0].node,\n+                    let ExprPath(_, Path { segments: ref len_path, .. }) = len_args[0].node,\n+                    iter_path == len_path\n+                 ], {\n+                    span_lint(cx,\n+                              RANGE_ZIP_WITH_LEN,\n+                              expr.span,\n+                              &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n+                                       snippet(cx, iter_args[0].span, \"_\")));\n+                }}\n             }\n         }\n     }"}, {"sha": "6beed822a81abf33687b18d459c1d3d851fe0434", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=d85b8062e3e5fea82e8eeed06432d2a0157d589b", "patch": "@@ -89,28 +89,25 @@ impl ReturnPass {\n     // Check for \"let x = EXPR; x\"\n     fn check_let_return(&mut self, cx: &EarlyContext, block: &Block) {\n         // we need both a let-binding stmt and an expr\n-        if_let_chain! {\n-            [\n-                let Some(stmt) = block.stmts.last(),\n-                let Some(ref retexpr) = block.expr,\n-                let StmtKind::Decl(ref decl, _) = stmt.node,\n-                let DeclKind::Local(ref local) = decl.node,\n-                local.ty.is_none(),\n-                let Some(ref initexpr) = local.init,\n-                let PatKind::Ident(_, Spanned { node: id, .. }, _) = local.pat.node,\n-                let ExprKind::Path(_, ref path) = retexpr.node,\n-                match_path_ast(path, &[&id.name.as_str()]),\n-                !in_external_macro(cx, initexpr.span),\n-            ], {\n+        if_let_chain! {[\n+            let Some(stmt) = block.stmts.last(),\n+            let Some(ref retexpr) = block.expr,\n+            let StmtKind::Decl(ref decl, _) = stmt.node,\n+            let DeclKind::Local(ref local) = decl.node,\n+            let Some(ref initexpr) = local.init,\n+            let PatKind::Ident(_, Spanned { node: id, .. }, _) = local.pat.node,\n+            let ExprKind::Path(_, ref path) = retexpr.node,\n+            match_path_ast(path, &[&id.name.as_str()]),\n+            !in_external_macro(cx, initexpr.span),\n+        ], {\n                 span_note_and_lint(cx,\n                                    LET_AND_RETURN,\n                                    retexpr.span,\n                                    \"returning the result of a let binding from a block. \\\n                                    Consider returning the expression directly.\",\n                                    initexpr.span,\n                                    \"this expression can be directly returned\");\n-            }\n-        }\n+        }}\n     }\n }\n "}, {"sha": "8a1a13187b355e817448497e82319f3c0f6f945c", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=d85b8062e3e5fea82e8eeed06432d2a0157d589b", "patch": "@@ -57,24 +57,21 @@ impl LateLintPass for TypePass {\n         if let Some(did) = cx.tcx.def_map.borrow().get(&ast_ty.id) {\n             if let def::Def::Struct(..) = did.full_def() {\n                 if Some(did.def_id()) == cx.tcx.lang_items.owned_box() {\n-                    if_let_chain! {\n-                        [\n-                            let TyPath(_, ref path) = ast_ty.node,\n-                            let Some(ref last) = path.segments.last(),\n-                            let PathParameters::AngleBracketedParameters(ref ag) = last.parameters,\n-                            let Some(ref vec) = ag.types.get(0),\n-                            let Some(did) = cx.tcx.def_map.borrow().get(&vec.id),\n-                            let def::Def::Struct(..) = did.full_def(),\n-                            match_def_path(cx, did.def_id(), &paths::VEC),\n-                        ],\n-                        {\n-                            span_help_and_lint(cx,\n-                                               BOX_VEC,\n-                                               ast_ty.span,\n-                                               \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n-                                               \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n-                        }\n-                    }\n+                    if_let_chain! {[\n+                        let TyPath(_, ref path) = ast_ty.node,\n+                        let Some(ref last) = path.segments.last(),\n+                        let PathParameters::AngleBracketedParameters(ref ag) = last.parameters,\n+                        let Some(ref vec) = ag.types.get(0),\n+                        let Some(did) = cx.tcx.def_map.borrow().get(&vec.id),\n+                        let def::Def::Struct(..) = did.full_def(),\n+                        match_def_path(cx, did.def_id(), &paths::VEC),\n+                    ], {\n+                        span_help_and_lint(cx,\n+                                           BOX_VEC,\n+                                           ast_ty.span,\n+                                           \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n+                                           \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n+                    }}\n                 } else if match_def_path(cx, did.def_id(), &paths::LINKED_LIST) {\n                     span_help_and_lint(cx,\n                                        LINKEDLIST,"}, {"sha": "a2b2ecfbcc00d691516942ca553ae6e37fbfbaaf", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=d85b8062e3e5fea82e8eeed06432d2a0157d589b", "patch": "@@ -30,16 +30,13 @@ pub type MethodArgs = HirVec<P<Expr>>;\n \n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///\n-///     if_let_chain! {\n-///         [\n-///             let Some(y) = x,\n-///             y.len() == 2,\n-///             let Some(z) = y,\n-///         ],\n-///         {\n-///             block\n-///         }\n-///     }\n+///     if_let_chain! {[\n+///         let Some(y) = x,\n+///         y.len() == 2,\n+///         let Some(z) = y,\n+///     ], {\n+///         block\n+///     }}\n ///\n /// becomes\n ///\n@@ -323,14 +320,13 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n \n /// Checks if a `let` decl is from a `for` loop desugaring.\n pub fn is_from_for_desugar(decl: &Decl) -> bool {\n-    if_let_chain! {\n-        [\n-            let DeclLocal(ref loc) = decl.node,\n-            let Some(ref expr) = loc.init,\n-            let ExprMatch(_, _, MatchSource::ForLoopDesugar) = expr.node\n-        ],\n-        { return true; }\n-    };\n+    if_let_chain! {[\n+        let DeclLocal(ref loc) = decl.node,\n+        let Some(ref expr) = loc.init,\n+        let ExprMatch(_, _, MatchSource::ForLoopDesugar) = expr.node\n+    ], {\n+        return true;\n+    }}\n     false\n }\n \n@@ -821,23 +817,21 @@ pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: ty::Ty<'tcx>, b: ty::Ty\n /// Recover the essential nodes of a desugared for loop:\n /// `for pat in arg { body }` becomes `(pat, arg, body)`.\n pub fn recover_for_loop(expr: &Expr) -> Option<(&Pat, &Expr, &Expr)> {\n-    if_let_chain! {\n-        [\n-            let ExprMatch(ref iterexpr, ref arms, _) = expr.node,\n-            let ExprCall(_, ref iterargs) = iterexpr.node,\n-            iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none(),\n-            let ExprLoop(ref block, _) = arms[0].body.node,\n-            block.stmts.is_empty(),\n-            let Some(ref loopexpr) = block.expr,\n-            let ExprMatch(_, ref innerarms, MatchSource::ForLoopDesugar) = loopexpr.node,\n-            innerarms.len() == 2 && innerarms[0].pats.len() == 1,\n-            let PatKind::TupleStruct(_, ref somepats, _) = innerarms[0].pats[0].node,\n-            somepats.len() == 1\n-        ], {\n-            return Some((&somepats[0],\n-                         &iterargs[0],\n-                         &innerarms[0].body));\n-        }\n-    }\n+    if_let_chain! {[\n+        let ExprMatch(ref iterexpr, ref arms, _) = expr.node,\n+        let ExprCall(_, ref iterargs) = iterexpr.node,\n+        iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none(),\n+        let ExprLoop(ref block, _) = arms[0].body.node,\n+        block.stmts.is_empty(),\n+        let Some(ref loopexpr) = block.expr,\n+        let ExprMatch(_, ref innerarms, MatchSource::ForLoopDesugar) = loopexpr.node,\n+        innerarms.len() == 2 && innerarms[0].pats.len() == 1,\n+        let PatKind::TupleStruct(_, ref somepats, _) = innerarms[0].pats[0].node,\n+        somepats.len() == 1\n+    ], {\n+        return Some((&somepats[0],\n+                     &iterargs[0],\n+                     &innerarms[0].body));\n+    }}\n     None\n }"}, {"sha": "041ac94836cd21265155e0f953d6ec045a7d8452", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d85b8062e3e5fea82e8eeed06432d2a0157d589b/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=d85b8062e3e5fea82e8eeed06432d2a0157d589b", "patch": "@@ -30,30 +30,27 @@ impl LintPass for ZeroDivZeroPass {\n impl LateLintPass for ZeroDivZeroPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         // check for instances of 0.0/0.0\n-        if_let_chain! {\n-            [\n-                let ExprBinary(ref op, ref left, ref right) = expr.node,\n-                let BinOp_::BiDiv = op.node,\n-                // TODO - constant_simple does not fold many operations involving floats.\n-                // That's probably fine for this lint - it's pretty unlikely that someone would\n-                // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too.\n-                let Some(Constant::Float(ref lhs_value, lhs_width)) = constant_simple(left),\n-                let Some(Constant::Float(ref rhs_value, rhs_width)) = constant_simple(right),\n-                let Some(0.0) = lhs_value.parse().ok(),\n-                let Some(0.0) = rhs_value.parse().ok()\n-            ],\n-            {\n-                // since we're about to suggest a use of std::f32::NaN or std::f64::NaN,\n-                // match the precision of the literals that are given.\n-                let float_type = match (lhs_width, rhs_width) {\n-                    (FloatWidth::F64, _)\n-                    | (_, FloatWidth::F64) => \"f64\",\n-                    _ => \"f32\"\n-                };\n-                span_help_and_lint(cx, ZERO_DIVIDED_BY_ZERO, expr.span,\n-                    \"constant division of 0.0 with 0.0 will always result in NaN\",\n-                    &format!(\"Consider using `std::{}::NAN` if you would like a constant representing NaN\", float_type));\n-            }\n-        }\n+        if_let_chain! {[\n+            let ExprBinary(ref op, ref left, ref right) = expr.node,\n+            let BinOp_::BiDiv = op.node,\n+            // TODO - constant_simple does not fold many operations involving floats.\n+            // That's probably fine for this lint - it's pretty unlikely that someone would\n+            // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too.\n+            let Some(Constant::Float(ref lhs_value, lhs_width)) = constant_simple(left),\n+            let Some(Constant::Float(ref rhs_value, rhs_width)) = constant_simple(right),\n+            let Some(0.0) = lhs_value.parse().ok(),\n+            let Some(0.0) = rhs_value.parse().ok()\n+        ], {\n+            // since we're about to suggest a use of std::f32::NaN or std::f64::NaN,\n+            // match the precision of the literals that are given.\n+            let float_type = match (lhs_width, rhs_width) {\n+                (FloatWidth::F64, _)\n+                | (_, FloatWidth::F64) => \"f64\",\n+                _ => \"f32\"\n+            };\n+            span_help_and_lint(cx, ZERO_DIVIDED_BY_ZERO, expr.span,\n+                \"constant division of 0.0 with 0.0 will always result in NaN\",\n+                &format!(\"Consider using `std::{}::NAN` if you would like a constant representing NaN\", float_type));\n+        }}\n     }\n }"}]}