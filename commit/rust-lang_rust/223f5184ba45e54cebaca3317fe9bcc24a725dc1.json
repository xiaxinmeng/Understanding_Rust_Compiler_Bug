{"sha": "223f5184ba45e54cebaca3317fe9bcc24a725dc1", "node_id": "C_kwDOAAsO6NoAKDIyM2Y1MTg0YmE0NWU1NGNlYmFjYTMzMTdmZTliY2MyNGE3MjVkYzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-18T01:46:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-18T01:46:01Z"}, "message": "Auto merge of #10682 - J-ZhengLi:issue10680, r=dswij\n\nfix [`invalid_regex`] not recognizing new syntax introduced after regex-1.8.0\n\nfixes: #10680\n\n---\n\nchangelog: fix [`invalid_regex`] not recognizing new syntax introduced after regex-1.8.0\n\nbump up `regex-syntax` dependency version to 0.7.0", "tree": {"sha": "7bed8fa743cc25f647258d066e9213a42c148977", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bed8fa743cc25f647258d066e9213a42c148977"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/223f5184ba45e54cebaca3317fe9bcc24a725dc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/223f5184ba45e54cebaca3317fe9bcc24a725dc1", "html_url": "https://github.com/rust-lang/rust/commit/223f5184ba45e54cebaca3317fe9bcc24a725dc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/223f5184ba45e54cebaca3317fe9bcc24a725dc1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "407c3526881882a995cde117f0b9d0a69c9c6f84", "url": "https://api.github.com/repos/rust-lang/rust/commits/407c3526881882a995cde117f0b9d0a69c9c6f84", "html_url": "https://github.com/rust-lang/rust/commit/407c3526881882a995cde117f0b9d0a69c9c6f84"}, {"sha": "5fc1c79019519f7e02f8bfe59ca6df50c629c470", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fc1c79019519f7e02f8bfe59ca6df50c629c470", "html_url": "https://github.com/rust-lang/rust/commit/5fc1c79019519f7e02f8bfe59ca6df50c629c470"}], "stats": {"total": 67, "additions": 28, "deletions": 39}, "files": [{"sha": "1b818e8ab64dfddd9f61241a3e2533ff86179871", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/223f5184ba45e54cebaca3317fe9bcc24a725dc1/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/223f5184ba45e54cebaca3317fe9bcc24a725dc1/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=223f5184ba45e54cebaca3317fe9bcc24a725dc1", "patch": "@@ -17,7 +17,7 @@ if_chain = \"1.0\"\n itertools = \"0.10.1\"\n pulldown-cmark = { version = \"0.9\", default-features = false }\n quine-mc_cluskey = \"0.2\"\n-regex-syntax = \"0.6\"\n+regex-syntax = \"0.7\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = { version = \"1.0\", optional = true }\n tempfile = { version = \"3.3.0\", optional = true }"}, {"sha": "fe5be24870022af290a4e0d52d49f11d66f837e5", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/223f5184ba45e54cebaca3317fe9bcc24a725dc1/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/223f5184ba45e54cebaca3317fe9bcc24a725dc1/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=223f5184ba45e54cebaca3317fe9bcc24a725dc1", "patch": "@@ -129,30 +129,32 @@ fn const_str<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> Option<String>\n }\n \n fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n-    use regex_syntax::hir::Anchor::{EndText, StartText};\n-    use regex_syntax::hir::HirKind::{Alternation, Anchor, Concat, Empty, Literal};\n+    use regex_syntax::hir::HirKind::{Alternation, Concat, Empty, Literal, Look};\n+    use regex_syntax::hir::Look as HirLook;\n \n     let is_literal = |e: &[regex_syntax::hir::Hir]| e.iter().all(|e| matches!(*e.kind(), Literal(_)));\n \n     match *s.kind() {\n-        Empty | Anchor(_) => Some(\"the regex is unlikely to be useful as it is\"),\n+        Empty | Look(_) => Some(\"the regex is unlikely to be useful as it is\"),\n         Literal(_) => Some(\"consider using `str::contains`\"),\n         Alternation(ref exprs) => {\n-            if exprs.iter().all(|e| e.kind().is_empty()) {\n+            if exprs.iter().all(|e| matches!(e.kind(), Empty)) {\n                 Some(\"the regex is unlikely to be useful as it is\")\n             } else {\n                 None\n             }\n         },\n         Concat(ref exprs) => match (exprs[0].kind(), exprs[exprs.len() - 1].kind()) {\n-            (&Anchor(StartText), &Anchor(EndText)) if exprs[1..(exprs.len() - 1)].is_empty() => {\n+            (&Look(HirLook::Start), &Look(HirLook::End)) if exprs[1..(exprs.len() - 1)].is_empty() => {\n                 Some(\"consider using `str::is_empty`\")\n             },\n-            (&Anchor(StartText), &Anchor(EndText)) if is_literal(&exprs[1..(exprs.len() - 1)]) => {\n+            (&Look(HirLook::Start), &Look(HirLook::End)) if is_literal(&exprs[1..(exprs.len() - 1)]) => {\n                 Some(\"consider using `==` on `str`s\")\n             },\n-            (&Anchor(StartText), &Literal(_)) if is_literal(&exprs[1..]) => Some(\"consider using `str::starts_with`\"),\n-            (&Literal(_), &Anchor(EndText)) if is_literal(&exprs[1..(exprs.len() - 1)]) => {\n+            (&Look(HirLook::Start), &Literal(_)) if is_literal(&exprs[1..]) => {\n+                Some(\"consider using `str::starts_with`\")\n+            },\n+            (&Literal(_), &Look(HirLook::End)) if is_literal(&exprs[1..(exprs.len() - 1)]) => {\n                 Some(\"consider using `str::ends_with`\")\n             },\n             _ if is_literal(exprs) => Some(\"consider using `str::contains`\"),\n@@ -175,10 +177,7 @@ fn check_set<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n }\n \n fn check_regex<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n-    let mut parser = regex_syntax::ParserBuilder::new()\n-        .unicode(true)\n-        .allow_invalid_utf8(!utf8)\n-        .build();\n+    let mut parser = regex_syntax::ParserBuilder::new().unicode(true).utf8(!utf8).build();\n \n     if let ExprKind::Lit(lit) = expr.kind {\n         if let LitKind::Str(ref r, style) = lit.node {"}, {"sha": "a5f79b139bc2aec9968adf086c98f39967ea4534", "filename": "tests/ui/regex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/223f5184ba45e54cebaca3317fe9bcc24a725dc1/tests%2Fui%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/223f5184ba45e54cebaca3317fe9bcc24a725dc1/tests%2Fui%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregex.rs?ref=223f5184ba45e54cebaca3317fe9bcc24a725dc1", "patch": "@@ -34,8 +34,10 @@ fn syntax_error() {\n     let set_error = RegexSet::new(&[OPENING_PAREN, r\"[a-z]+\\.(com|org|net)\"]);\n     let bset_error = BRegexSet::new(&[OPENING_PAREN, r\"[a-z]+\\.(com|org|net)\"]);\n \n+    // These following three cases are considering valid since regex-1.8.0\n     let raw_string_error = Regex::new(r\"[...\\/...]\");\n     let raw_string_error = Regex::new(r#\"[...\\/...]\"#);\n+    let _ = Regex::new(r\"(?<hi>hi)\").unwrap();\n \n     let escaped_string_span = Regex::new(\"\\\\b\\\\c\");\n "}, {"sha": "6b8a772e7f0d50582f3a6b9535e8ae1790cb72c8", "filename": "tests/ui/regex.stderr", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/223f5184ba45e54cebaca3317fe9bcc24a725dc1/tests%2Fui%2Fregex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/223f5184ba45e54cebaca3317fe9bcc24a725dc1/tests%2Fui%2Fregex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregex.stderr?ref=223f5184ba45e54cebaca3317fe9bcc24a725dc1", "patch": "@@ -82,122 +82,110 @@ error: regex parse error:\n LL |     let bset_error = BRegexSet::new(&[OPENING_PAREN, r\"[a-z]+/.(com|org|net)\"]);\n    |                                       ^^^^^^^^^^^^^\n \n-error: regex syntax error: unrecognized escape sequence\n-  --> $DIR/regex.rs:37:45\n-   |\n-LL |     let raw_string_error = Regex::new(r\"[...//...]\");\n-   |                                             ^^\n-\n-error: regex syntax error: unrecognized escape sequence\n-  --> $DIR/regex.rs:38:46\n-   |\n-LL |     let raw_string_error = Regex::new(r#\"[...//...]\"#);\n-   |                                              ^^\n-\n error: regex parse error:\n            /b/c\n              ^^\n        error: unrecognized escape sequence\n-  --> $DIR/regex.rs:40:42\n+  --> $DIR/regex.rs:42:42\n    |\n LL |     let escaped_string_span = Regex::new(\"/b/c\");\n    |                                          ^^^^^^^^\n    |\n    = help: consider using a raw string literal: `r\"..\"`\n \n error: regex syntax error: duplicate flag\n-  --> $DIR/regex.rs:42:34\n+  --> $DIR/regex.rs:44:34\n    |\n LL |     let aux_span = Regex::new(\"(?ixi)\");\n    |                                  ^ ^\n \n error: trivial regex\n-  --> $DIR/regex.rs:46:33\n+  --> $DIR/regex.rs:48:33\n    |\n LL |     let trivial_eq = Regex::new(\"^foobar$\");\n    |                                 ^^^^^^^^^^\n    |\n    = help: consider using `==` on `str`s\n \n error: trivial regex\n-  --> $DIR/regex.rs:48:48\n+  --> $DIR/regex.rs:50:48\n    |\n LL |     let trivial_eq_builder = RegexBuilder::new(\"^foobar$\");\n    |                                                ^^^^^^^^^^\n    |\n    = help: consider using `==` on `str`s\n \n error: trivial regex\n-  --> $DIR/regex.rs:50:42\n+  --> $DIR/regex.rs:52:42\n    |\n LL |     let trivial_starts_with = Regex::new(\"^foobar\");\n    |                                          ^^^^^^^^^\n    |\n    = help: consider using `str::starts_with`\n \n error: trivial regex\n-  --> $DIR/regex.rs:52:40\n+  --> $DIR/regex.rs:54:40\n    |\n LL |     let trivial_ends_with = Regex::new(\"foobar$\");\n    |                                        ^^^^^^^^^\n    |\n    = help: consider using `str::ends_with`\n \n error: trivial regex\n-  --> $DIR/regex.rs:54:39\n+  --> $DIR/regex.rs:56:39\n    |\n LL |     let trivial_contains = Regex::new(\"foobar\");\n    |                                       ^^^^^^^^\n    |\n    = help: consider using `str::contains`\n \n error: trivial regex\n-  --> $DIR/regex.rs:56:39\n+  --> $DIR/regex.rs:58:39\n    |\n LL |     let trivial_contains = Regex::new(NOT_A_REAL_REGEX);\n    |                                       ^^^^^^^^^^^^^^^^\n    |\n    = help: consider using `str::contains`\n \n error: trivial regex\n-  --> $DIR/regex.rs:58:40\n+  --> $DIR/regex.rs:60:40\n    |\n LL |     let trivial_backslash = Regex::new(\"a/.b\");\n    |                                        ^^^^^^^\n    |\n    = help: consider using `str::contains`\n \n error: trivial regex\n-  --> $DIR/regex.rs:61:36\n+  --> $DIR/regex.rs:63:36\n    |\n LL |     let trivial_empty = Regex::new(\"\");\n    |                                    ^^\n    |\n    = help: the regex is unlikely to be useful as it is\n \n error: trivial regex\n-  --> $DIR/regex.rs:63:36\n+  --> $DIR/regex.rs:65:36\n    |\n LL |     let trivial_empty = Regex::new(\"^\");\n    |                                    ^^^\n    |\n    = help: the regex is unlikely to be useful as it is\n \n error: trivial regex\n-  --> $DIR/regex.rs:65:36\n+  --> $DIR/regex.rs:67:36\n    |\n LL |     let trivial_empty = Regex::new(\"^$\");\n    |                                    ^^^^\n    |\n    = help: consider using `str::is_empty`\n \n error: trivial regex\n-  --> $DIR/regex.rs:67:44\n+  --> $DIR/regex.rs:69:44\n    |\n LL |     let binary_trivial_empty = BRegex::new(\"^$\");\n    |                                            ^^^^\n    |\n    = help: consider using `str::is_empty`\n \n-error: aborting due to 25 previous errors\n+error: aborting due to 23 previous errors\n "}]}