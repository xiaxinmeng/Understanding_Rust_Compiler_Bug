{"sha": "a09dbf28e64e7ac9b9786320d90a87854615d77a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwOWRiZjI4ZTY0ZTdhYzliOTc4NjMyMGQ5MGE4Nzg1NDYxNWQ3N2E=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-12T10:10:30Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-12T11:24:45Z"}, "message": "Remove largely unused context from Visitor.", "tree": {"sha": "9c323160b55481f65782469bb7b88ac94c37b159", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c323160b55481f65782469bb7b88ac94c37b159"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a09dbf28e64e7ac9b9786320d90a87854615d77a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a09dbf28e64e7ac9b9786320d90a87854615d77a", "html_url": "https://github.com/rust-lang/rust/commit/a09dbf28e64e7ac9b9786320d90a87854615d77a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a09dbf28e64e7ac9b9786320d90a87854615d77a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22e749ded10822a3063fa26800aaa3f229e97c4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/22e749ded10822a3063fa26800aaa3f229e97c4d", "html_url": "https://github.com/rust-lang/rust/commit/22e749ded10822a3063fa26800aaa3f229e97c4d"}], "stats": {"total": 2957, "additions": 1451, "deletions": 1506}, "files": [{"sha": "b3653b5dcffb296cbb9bf481cdad17f7e525b4e6", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -143,15 +143,15 @@ impl<'a> Context<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for Context<'a> {\n-    fn visit_ident(&mut self, sp: Span, id: ast::Ident, _: ()) {\n+impl<'a> Visitor for Context<'a> {\n+    fn visit_ident(&mut self, sp: Span, id: ast::Ident) {\n         if !token::get_ident(id).get().is_ascii() {\n             self.gate_feature(\"non_ascii_idents\", sp,\n                               \"non-ascii idents are not fully supported.\");\n         }\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::ViewItem, _: ()) {\n+    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n         match i.node {\n             ast::ViewItemUse(ref path) => {\n                 match path.node {\n@@ -173,10 +173,10 @@ impl<'a> Visitor<()> for Context<'a> {\n                 }\n             }\n         }\n-        visit::walk_view_item(self, i, ())\n+        visit::walk_view_item(self, i)\n     }\n \n-    fn visit_item(&mut self, i: &ast::Item, _:()) {\n+    fn visit_item(&mut self, i: &ast::Item) {\n         for attr in i.attrs.iter() {\n             if attr.name().equiv(&(\"thread_local\")) {\n                 self.gate_feature(\"thread_local\", i.span,\n@@ -252,10 +252,10 @@ impl<'a> Visitor<()> for Context<'a> {\n             _ => {}\n         }\n \n-        visit::walk_item(self, i, ());\n+        visit::walk_item(self, i);\n     }\n \n-    fn visit_mac(&mut self, macro: &ast::Mac, _: ()) {\n+    fn visit_mac(&mut self, macro: &ast::Mac) {\n         let ast::MacInvocTT(ref path, _, _) = macro.node;\n         let id = path.segments.last().unwrap().identifier;\n         let quotes = [\"quote_tokens\", \"quote_expr\", \"quote_ty\",\n@@ -299,16 +299,16 @@ impl<'a> Visitor<()> for Context<'a> {\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, i: &ast::ForeignItem, _: ()) {\n+    fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n         if attr::contains_name(i.attrs.as_slice(), \"linkage\") {\n             self.gate_feature(\"linkage\", i.span,\n                               \"the `linkage` attribute is experimental \\\n                                and not portable across platforms\")\n         }\n-        visit::walk_foreign_item(self, i, ())\n+        visit::walk_foreign_item(self, i)\n     }\n \n-    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n         match t.node {\n             ast::TyClosure(closure) if closure.onceness == ast::Once => {\n                 self.gate_feature(\"once_fns\", t.span,\n@@ -325,10 +325,10 @@ impl<'a> Visitor<()> for Context<'a> {\n             _ => {}\n         }\n \n-        visit::walk_ty(self, t, ());\n+        visit::walk_ty(self, t);\n     }\n \n-    fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n+    fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprUnary(ast::UnBox, _) => {\n                 self.gate_box(e.span);\n@@ -346,10 +346,10 @@ impl<'a> Visitor<()> for Context<'a> {\n             }\n             _ => {}\n         }\n-        visit::walk_expr(self, e, ());\n+        visit::walk_expr(self, e);\n     }\n \n-    fn visit_generics(&mut self, generics: &ast::Generics, _: ()) {\n+    fn visit_generics(&mut self, generics: &ast::Generics) {\n         for type_parameter in generics.ty_params.iter() {\n             match type_parameter.default {\n                 Some(ty) => {\n@@ -360,18 +360,18 @@ impl<'a> Visitor<()> for Context<'a> {\n                 None => {}\n             }\n         }\n-        visit::walk_generics(self, generics, ());\n+        visit::walk_generics(self, generics);\n     }\n \n-    fn visit_attribute(&mut self, attr: &ast::Attribute, _: ()) {\n+    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         if attr::contains_name([*attr], \"lang\") {\n             self.gate_feature(\"lang_items\",\n                               attr.span,\n                               \"language items are subject to change\");\n         }\n     }\n \n-    fn visit_pat(&mut self, pattern: &ast::Pat, (): ()) {\n+    fn visit_pat(&mut self, pattern: &ast::Pat) {\n         match pattern.node {\n             ast::PatVec(_, Some(_), ref last) if !last.is_empty() => {\n                 self.gate_feature(\"advanced_slice_patterns\",\n@@ -382,16 +382,15 @@ impl<'a> Visitor<()> for Context<'a> {\n             }\n             _ => {}\n         }\n-        visit::walk_pat(self, pattern, ())\n+        visit::walk_pat(self, pattern)\n     }\n \n     fn visit_fn(&mut self,\n                 fn_kind: &visit::FnKind,\n                 fn_decl: &ast::FnDecl,\n                 block: &ast::Block,\n                 span: Span,\n-                _: NodeId,\n-                (): ()) {\n+                _: NodeId) {\n         match *fn_kind {\n             visit::FkItemFn(_, _, _, ref abi) if *abi == RustIntrinsic => {\n                 self.gate_feature(\"intrinsics\",\n@@ -400,7 +399,7 @@ impl<'a> Visitor<()> for Context<'a> {\n             }\n             _ => {}\n         }\n-        visit::walk_fn(self, fn_kind, fn_decl, block, span, ());\n+        visit::walk_fn(self, fn_kind, fn_decl, block, span);\n     }\n }\n \n@@ -453,7 +452,7 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n         }\n     }\n \n-    visit::walk_crate(&mut cx, krate, ());\n+    visit::walk_crate(&mut cx, krate);\n \n     sess.abort_if_errors();\n "}, {"sha": "2ccba474bfe5926c25a7a633a2c456020f10c760", "filename": "src/librustc/front/show_span.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Ffront%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Ffront%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fshow_span.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -23,18 +23,18 @@ struct ShowSpanVisitor<'a> {\n     sess: &'a Session\n }\n \n-impl<'a> Visitor<()> for ShowSpanVisitor<'a> {\n-    fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n+impl<'a> Visitor for ShowSpanVisitor<'a> {\n+    fn visit_expr(&mut self, e: &ast::Expr) {\n         self.sess.span_note(e.span, \"expression\");\n-        visit::walk_expr(self, e, ());\n+        visit::walk_expr(self, e);\n     }\n \n-    fn visit_mac(&mut self, macro: &ast::Mac, e: ()) {\n-        visit::walk_mac(self, macro, e);\n+    fn visit_mac(&mut self, macro: &ast::Mac) {\n+        visit::walk_mac(self, macro);\n     }\n }\n \n pub fn run(sess: &Session, krate: &ast::Crate) {\n     let mut v = ShowSpanVisitor { sess: sess };\n-    visit::walk_crate(&mut v, krate, ());\n+    visit::walk_crate(&mut v, krate);\n }"}, {"sha": "b1ea8b5d8181219f7862fcf674491456b00b6736", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -366,13 +366,13 @@ impl<'a, 'tcx> CTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<()> for CTypesVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n+impl<'a, 'tcx> Visitor for CTypesVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: &ast::Ty) {\n         match ty.node {\n             ast::TyPath(_, _, id) => self.check_def(ty.span, ty.id, id),\n             _ => (),\n         }\n-        visit::walk_ty(self, ty, ());\n+        visit::walk_ty(self, ty);\n     }\n }\n \n@@ -386,7 +386,7 @@ impl LintPass for CTypes {\n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         fn check_ty(cx: &Context, ty: &ast::Ty) {\n             let mut vis = CTypesVisitor { cx: cx };\n-            vis.visit_ty(ty, ());\n+            vis.visit_ty(ty);\n         }\n \n         fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n@@ -500,18 +500,18 @@ struct RawPtrDerivingVisitor<'a, 'tcx: 'a> {\n     cx: &'a Context<'a, 'tcx>\n }\n \n-impl<'a, 'tcx> Visitor<()> for RawPtrDerivingVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n+impl<'a, 'tcx> Visitor for RawPtrDerivingVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: &ast::Ty) {\n         static MSG: &'static str = \"use of `#[deriving]` with a raw pointer\";\n         match ty.node {\n             ast::TyPtr(..) => self.cx.span_lint(RAW_POINTER_DERIVING, ty.span, MSG),\n             _ => {}\n         }\n-        visit::walk_ty(self, ty, ());\n+        visit::walk_ty(self, ty);\n     }\n     // explicit override to a no-op to reduce code bloat\n-    fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n-    fn visit_block(&mut self, _: &ast::Block, _: ()) {}\n+    fn visit_expr(&mut self, _: &ast::Expr) {}\n+    fn visit_block(&mut self, _: &ast::Block) {}\n }\n \n pub struct RawPointerDeriving {\n@@ -554,7 +554,7 @@ impl LintPass for RawPointerDeriving {\n         match item.node {\n             ast::ItemStruct(..) | ast::ItemEnum(..) => {\n                 let mut visitor = RawPtrDerivingVisitor { cx: cx };\n-                visit::walk_item(&mut visitor, &*item, ());\n+                visit::walk_item(&mut visitor, &*item);\n             }\n             _ => {}\n         }"}, {"sha": "bd7f6296d92fed047a5b4ceb85e206796f4c686b", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 56, "deletions": 57, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -492,172 +492,171 @@ impl<'a, 'tcx> AstConv<'tcx> for Context<'a, 'tcx>{\n     }\n }\n \n-impl<'a, 'tcx> Visitor<()> for Context<'a, 'tcx> {\n-    fn visit_item(&mut self, it: &ast::Item, _: ()) {\n+impl<'a, 'tcx> Visitor for Context<'a, 'tcx> {\n+    fn visit_item(&mut self, it: &ast::Item) {\n         self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n             run_lints!(cx, check_item, it);\n-            cx.visit_ids(|v| v.visit_item(it, ()));\n-            visit::walk_item(cx, it, ());\n+            cx.visit_ids(|v| v.visit_item(it));\n+            visit::walk_item(cx, it);\n         })\n     }\n \n-    fn visit_foreign_item(&mut self, it: &ast::ForeignItem, _: ()) {\n+    fn visit_foreign_item(&mut self, it: &ast::ForeignItem) {\n         self.with_lint_attrs(it.attrs.as_slice(), |cx| {\n             run_lints!(cx, check_foreign_item, it);\n-            visit::walk_foreign_item(cx, it, ());\n+            visit::walk_foreign_item(cx, it);\n         })\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::ViewItem, _: ()) {\n+    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n         self.with_lint_attrs(i.attrs.as_slice(), |cx| {\n             run_lints!(cx, check_view_item, i);\n-            cx.visit_ids(|v| v.visit_view_item(i, ()));\n-            visit::walk_view_item(cx, i, ());\n+            cx.visit_ids(|v| v.visit_view_item(i));\n+            visit::walk_view_item(cx, i);\n         })\n     }\n \n-    fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n         run_lints!(self, check_pat, p);\n-        visit::walk_pat(self, p, ());\n+        visit::walk_pat(self, p);\n     }\n \n-    fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n+    fn visit_expr(&mut self, e: &ast::Expr) {\n         run_lints!(self, check_expr, e);\n-        visit::walk_expr(self, e, ());\n+        visit::walk_expr(self, e);\n     }\n \n-    fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) {\n+    fn visit_stmt(&mut self, s: &ast::Stmt) {\n         run_lints!(self, check_stmt, s);\n-        visit::walk_stmt(self, s, ());\n+        visit::walk_stmt(self, s);\n     }\n \n     fn visit_fn(&mut self, fk: &FnKind, decl: &ast::FnDecl,\n-                body: &ast::Block, span: Span, id: ast::NodeId, _: ()) {\n+                body: &ast::Block, span: Span, id: ast::NodeId) {\n         match *fk {\n             visit::FkMethod(_, _, m) => {\n                 self.with_lint_attrs(m.attrs.as_slice(), |cx| {\n                     run_lints!(cx, check_fn, fk, decl, body, span, id);\n                     cx.visit_ids(|v| {\n-                        v.visit_fn(fk, decl, body, span, id, ());\n+                        v.visit_fn(fk, decl, body, span, id);\n                     });\n-                    visit::walk_fn(cx, fk, decl, body, span, ());\n+                    visit::walk_fn(cx, fk, decl, body, span);\n                 })\n             },\n             _ => {\n                 run_lints!(self, check_fn, fk, decl, body, span, id);\n-                visit::walk_fn(self, fk, decl, body, span, ());\n+                visit::walk_fn(self, fk, decl, body, span);\n             }\n         }\n     }\n \n-    fn visit_ty_method(&mut self, t: &ast::TypeMethod, _: ()) {\n+    fn visit_ty_method(&mut self, t: &ast::TypeMethod) {\n         self.with_lint_attrs(t.attrs.as_slice(), |cx| {\n             run_lints!(cx, check_ty_method, t);\n-            visit::walk_ty_method(cx, t, ());\n+            visit::walk_ty_method(cx, t);\n         })\n     }\n \n     fn visit_struct_def(&mut self,\n                         s: &ast::StructDef,\n                         ident: ast::Ident,\n                         g: &ast::Generics,\n-                        id: ast::NodeId,\n-                        _: ()) {\n+                        id: ast::NodeId) {\n         run_lints!(self, check_struct_def, s, ident, g, id);\n-        visit::walk_struct_def(self, s, ());\n+        visit::walk_struct_def(self, s);\n         run_lints!(self, check_struct_def_post, s, ident, g, id);\n     }\n \n-    fn visit_struct_field(&mut self, s: &ast::StructField, _: ()) {\n+    fn visit_struct_field(&mut self, s: &ast::StructField) {\n         self.with_lint_attrs(s.node.attrs.as_slice(), |cx| {\n             run_lints!(cx, check_struct_field, s);\n-            visit::walk_struct_field(cx, s, ());\n+            visit::walk_struct_field(cx, s);\n         })\n     }\n \n-    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, _: ()) {\n+    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n         self.with_lint_attrs(v.node.attrs.as_slice(), |cx| {\n             run_lints!(cx, check_variant, v, g);\n-            visit::walk_variant(cx, v, g, ());\n+            visit::walk_variant(cx, v, g);\n         })\n     }\n \n     // FIXME(#10894) should continue recursing\n-    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n         run_lints!(self, check_ty, t);\n     }\n \n-    fn visit_ident(&mut self, sp: Span, id: ast::Ident, _: ()) {\n+    fn visit_ident(&mut self, sp: Span, id: ast::Ident) {\n         run_lints!(self, check_ident, sp, id);\n     }\n \n-    fn visit_mod(&mut self, m: &ast::Mod, s: Span, n: ast::NodeId, _: ()) {\n+    fn visit_mod(&mut self, m: &ast::Mod, s: Span, n: ast::NodeId) {\n         run_lints!(self, check_mod, m, s, n);\n-        visit::walk_mod(self, m, ());\n+        visit::walk_mod(self, m);\n     }\n \n-    fn visit_local(&mut self, l: &ast::Local, _: ()) {\n+    fn visit_local(&mut self, l: &ast::Local) {\n         run_lints!(self, check_local, l);\n-        visit::walk_local(self, l, ());\n+        visit::walk_local(self, l);\n     }\n \n-    fn visit_block(&mut self, b: &ast::Block, _: ()) {\n+    fn visit_block(&mut self, b: &ast::Block) {\n         run_lints!(self, check_block, b);\n-        visit::walk_block(self, b, ());\n+        visit::walk_block(self, b);\n     }\n \n-    fn visit_arm(&mut self, a: &ast::Arm, _: ()) {\n+    fn visit_arm(&mut self, a: &ast::Arm) {\n         run_lints!(self, check_arm, a);\n-        visit::walk_arm(self, a, ());\n+        visit::walk_arm(self, a);\n     }\n \n-    fn visit_decl(&mut self, d: &ast::Decl, _: ()) {\n+    fn visit_decl(&mut self, d: &ast::Decl) {\n         run_lints!(self, check_decl, d);\n-        visit::walk_decl(self, d, ());\n+        visit::walk_decl(self, d);\n     }\n \n-    fn visit_expr_post(&mut self, e: &ast::Expr, _: ()) {\n+    fn visit_expr_post(&mut self, e: &ast::Expr) {\n         run_lints!(self, check_expr_post, e);\n     }\n \n-    fn visit_generics(&mut self, g: &ast::Generics, _: ()) {\n+    fn visit_generics(&mut self, g: &ast::Generics) {\n         run_lints!(self, check_generics, g);\n-        visit::walk_generics(self, g, ());\n+        visit::walk_generics(self, g);\n     }\n \n-    fn visit_trait_item(&mut self, m: &ast::TraitItem, _: ()) {\n+    fn visit_trait_item(&mut self, m: &ast::TraitItem) {\n         run_lints!(self, check_trait_method, m);\n-        visit::walk_trait_item(self, m, ());\n+        visit::walk_trait_item(self, m);\n     }\n \n-    fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<ast::Lifetime>, _: ()) {\n+    fn visit_opt_lifetime_ref(&mut self, sp: Span, lt: &Option<ast::Lifetime>) {\n         run_lints!(self, check_opt_lifetime_ref, sp, lt);\n     }\n \n-    fn visit_lifetime_ref(&mut self, lt: &ast::Lifetime, _: ()) {\n+    fn visit_lifetime_ref(&mut self, lt: &ast::Lifetime) {\n         run_lints!(self, check_lifetime_ref, lt);\n     }\n \n-    fn visit_lifetime_decl(&mut self, lt: &ast::LifetimeDef, _: ()) {\n+    fn visit_lifetime_decl(&mut self, lt: &ast::LifetimeDef) {\n         run_lints!(self, check_lifetime_decl, lt);\n     }\n \n-    fn visit_explicit_self(&mut self, es: &ast::ExplicitSelf, _: ()) {\n+    fn visit_explicit_self(&mut self, es: &ast::ExplicitSelf) {\n         run_lints!(self, check_explicit_self, es);\n-        visit::walk_explicit_self(self, es, ());\n+        visit::walk_explicit_self(self, es);\n     }\n \n-    fn visit_mac(&mut self, mac: &ast::Mac, _: ()) {\n+    fn visit_mac(&mut self, mac: &ast::Mac) {\n         run_lints!(self, check_mac, mac);\n-        visit::walk_mac(self, mac, ());\n+        visit::walk_mac(self, mac);\n     }\n \n-    fn visit_path(&mut self, p: &ast::Path, id: ast::NodeId, _: ()) {\n+    fn visit_path(&mut self, p: &ast::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, p, id);\n-        visit::walk_path(self, p, ());\n+        visit::walk_path(self, p);\n     }\n \n-    fn visit_attribute(&mut self, attr: &ast::Attribute, _: ()) {\n+    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n         run_lints!(self, check_attribute, attr);\n     }\n }\n@@ -719,14 +718,14 @@ pub fn check_crate(tcx: &ty::ctxt,\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             v.visited_outermost = true;\n-            visit::walk_crate(v, krate, ());\n+            visit::walk_crate(v, krate);\n         });\n \n         // since the root module isn't visited as an item (because it isn't an\n         // item), warn for it here.\n         run_lints!(cx, check_crate, krate);\n \n-        visit::walk_crate(cx, krate, ());\n+        visit::walk_crate(cx, krate);\n     });\n \n     // If we missed any lints added to the session, then there's a bug somewhere"}, {"sha": "7b8c7a0ab472b00e70c8e04fe45a73ea2ec89470", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -49,19 +49,19 @@ pub fn read_crates(sess: &Session,\n         next_crate_num: sess.cstore.next_crate_num(),\n     };\n     visit_crate(&e, krate);\n-    visit::walk_crate(&mut e, krate, ());\n+    visit::walk_crate(&mut e, krate);\n     dump_crates(&sess.cstore);\n     warn_if_multiple_versions(sess.diagnostic(), &sess.cstore)\n }\n \n-impl<'a> visit::Visitor<()> for Env<'a> {\n-    fn visit_view_item(&mut self, a: &ast::ViewItem, _: ()) {\n+impl<'a> visit::Visitor for Env<'a> {\n+    fn visit_view_item(&mut self, a: &ast::ViewItem) {\n         visit_view_item(self, a);\n-        visit::walk_view_item(self, a, ());\n+        visit::walk_view_item(self, a);\n     }\n-    fn visit_item(&mut self, a: &ast::Item, _: ()) {\n+    fn visit_item(&mut self, a: &ast::Item) {\n         visit_item(self, a);\n-        visit::walk_item(self, a, ());\n+        visit::walk_item(self, a);\n     }\n }\n "}, {"sha": "25e80b26a9335473277437758525791408fab566", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -1473,20 +1473,20 @@ struct EncodeVisitor<'a,'b:'a> {\n     index: &'a mut Vec<entry<i64>>,\n }\n \n-impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n-    fn visit_expr(&mut self, ex: &Expr, _: ()) {\n-        visit::walk_expr(self, ex, ());\n+impl<'a,'b> visit::Visitor for EncodeVisitor<'a,'b> {\n+    fn visit_expr(&mut self, ex: &Expr) {\n+        visit::walk_expr(self, ex);\n         my_visit_expr(ex);\n     }\n-    fn visit_item(&mut self, i: &Item, _: ()) {\n-        visit::walk_item(self, i, ());\n+    fn visit_item(&mut self, i: &Item) {\n+        visit::walk_item(self, i);\n         my_visit_item(i,\n                       self.rbml_w_for_visit_item,\n                       self.ecx_ptr,\n                       self.index);\n     }\n-    fn visit_foreign_item(&mut self, ni: &ForeignItem, _: ()) {\n-        visit::walk_foreign_item(self, ni, ());\n+    fn visit_foreign_item(&mut self, ni: &ForeignItem) {\n+        visit::walk_foreign_item(self, ni);\n         my_visit_foreign_item(ni,\n                               self.rbml_w_for_visit_item,\n                               self.ecx_ptr,\n@@ -1519,7 +1519,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n         index: &mut index,\n         ecx_ptr: ecx_ptr,\n         rbml_w_for_visit_item: &mut *rbml_w,\n-    }, krate, ());\n+    }, krate);\n \n     rbml_w.end_tag();\n     index\n@@ -1775,8 +1775,8 @@ fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &Crate) {\n         rbml_w: &'a mut Encoder<'b>,\n     }\n \n-    impl<'a, 'b> Visitor<()> for StructFieldVisitor<'a, 'b> {\n-        fn visit_struct_field(&mut self, field: &ast::StructField, _: ()) {\n+    impl<'a, 'b> Visitor for StructFieldVisitor<'a, 'b> {\n+        fn visit_struct_field(&mut self, field: &ast::StructField) {\n             self.rbml_w.start_tag(tag_struct_field);\n             self.rbml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n             encode_attributes(self.rbml_w, field.node.attrs.as_slice());\n@@ -1787,7 +1787,7 @@ fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &Crate) {\n     rbml_w.start_tag(tag_struct_fields);\n     visit::walk_crate(&mut StructFieldVisitor {\n         rbml_w: rbml_w\n-    }, krate, ());\n+    }, krate);\n     rbml_w.end_tag();\n }\n \n@@ -1798,8 +1798,8 @@ struct ImplVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n     rbml_w: &'a mut Encoder<'c>,\n }\n \n-impl<'a, 'b, 'c, 'tcx> Visitor<()> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n-    fn visit_item(&mut self, item: &Item, _: ()) {\n+impl<'a, 'b, 'c, 'tcx> Visitor for ImplVisitor<'a, 'b, 'c, 'tcx> {\n+    fn visit_item(&mut self, item: &Item) {\n         match item.node {\n             ItemImpl(_, Some(ref trait_ref), _, _) => {\n                 let def_map = &self.ecx.tcx.def_map;\n@@ -1817,7 +1817,7 @@ impl<'a, 'b, 'c, 'tcx> Visitor<()> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n             }\n             _ => {}\n         }\n-        visit::walk_item(self, item, ());\n+        visit::walk_item(self, item);\n     }\n }\n \n@@ -1841,7 +1841,7 @@ fn encode_impls<'a>(ecx: &'a EncodeContext,\n             ecx: ecx,\n             rbml_w: rbml_w,\n         };\n-        visit::walk_crate(&mut visitor, krate, ());\n+        visit::walk_crate(&mut visitor, krate);\n     }\n \n     rbml_w.end_tag();"}, {"sha": "5910aba811611831b43c608314e6ddc1e4da741c", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -26,7 +26,7 @@ use util::ppaux::{Repr};\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::visit;\n-use syntax::visit::{Visitor};\n+use syntax::visit::Visitor;\n use syntax::ast::{Expr, FnDecl, Block, NodeId, Pat};\n \n mod lifetime;\n@@ -471,8 +471,8 @@ struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>\n }\n \n-impl<'a, 'tcx> visit::Visitor<()> for StaticInitializerCtxt<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &Expr, _: ()) {\n+impl<'a, 'tcx> Visitor for StaticInitializerCtxt<'a, 'tcx> {\n+    fn visit_expr(&mut self, ex: &Expr) {\n         match ex.node {\n             ast::ExprAddrOf(mutbl, ref base) => {\n                 let base_cmt = self.bccx.cat_expr(&**base);\n@@ -486,7 +486,7 @@ impl<'a, 'tcx> visit::Visitor<()> for StaticInitializerCtxt<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_expr(self, ex, ());\n+        visit::walk_expr(self, ex);\n     }\n }\n \n@@ -498,5 +498,5 @@ pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, expr: &ast::E\n         bccx: bccx\n     };\n \n-    sicx.visit_expr(expr, ());\n+    sicx.visit_expr(expr);\n }"}, {"sha": "0c61f96ada6013d2fc59cd235064147c8ac07f7b", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -60,13 +60,13 @@ pub struct LoanDataFlowOperator;\n \n pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n \n-impl<'a, 'tcx> Visitor<()> for BorrowckCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor for BorrowckCtxt<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl,\n-                b: &Block, s: Span, n: NodeId, _: ()) {\n+                b: &Block, s: Span, n: NodeId) {\n         borrowck_fn(self, fk, fd, b, s, n);\n     }\n \n-    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         borrowck_item(self, item);\n     }\n }\n@@ -83,7 +83,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         }\n     };\n \n-    visit::walk_crate(&mut bccx, krate, ());\n+    visit::walk_crate(&mut bccx, krate);\n \n     if tcx.sess.borrowck_stats() {\n         println!(\"--- borrowck stats ---\");\n@@ -114,7 +114,7 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n             gather_loans::gather_loans_in_static_initializer(this, &*ex);\n         }\n         _ => {\n-            visit::walk_item(this, item, ());\n+            visit::walk_item(this, item);\n         }\n     }\n }\n@@ -142,7 +142,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n                              all_loans.as_slice(), decl, body);\n \n-    visit::walk_fn(this, fk, decl, body, sp, ());\n+    visit::walk_fn(this, fk, decl, body, sp);\n }\n \n fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,"}, {"sha": "abe5118734b8d0b6bea2ddcc34e1c5fec4a59ac3", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 48, "deletions": 32, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -21,45 +21,61 @@ use syntax::{ast_util, ast_map};\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-pub struct CheckCrateVisitor<'a, 'tcx: 'a> {\n+struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n+    in_const: bool\n }\n \n-impl<'a, 'tcx> Visitor<bool> for CheckCrateVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &Item, env: bool) {\n-        check_item(self, i, env);\n+impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n+    fn with_const(&mut self, in_const: bool, f: |&mut CheckCrateVisitor<'a, 'tcx>|) {\n+        let was_const = self.in_const;\n+        self.in_const = in_const;\n+        f(self);\n+        self.in_const = was_const;\n     }\n-    fn visit_pat(&mut self, p: &Pat, env: bool) {\n-        check_pat(self, p, env);\n+    fn inside_const(&mut self, f: |&mut CheckCrateVisitor<'a, 'tcx>|) {\n+        self.with_const(true, f);\n     }\n-    fn visit_expr(&mut self, ex: &Expr, env: bool) {\n-        check_expr(self, ex, env);\n+    fn outside_const(&mut self, f: |&mut CheckCrateVisitor<'a, 'tcx>|) {\n+        self.with_const(false, f);\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor for CheckCrateVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &Item) {\n+        check_item(self, i);\n+    }\n+    fn visit_pat(&mut self, p: &Pat) {\n+        check_pat(self, p);\n+    }\n+    fn visit_expr(&mut self, ex: &Expr) {\n+        check_expr(self, ex);\n     }\n }\n \n pub fn check_crate(krate: &Crate, tcx: &ty::ctxt) {\n-    visit::walk_crate(&mut CheckCrateVisitor { tcx: tcx }, krate, false);\n+    visit::walk_crate(&mut CheckCrateVisitor { tcx: tcx, in_const: false }, krate);\n     tcx.sess.abort_if_errors();\n }\n \n-fn check_item(v: &mut CheckCrateVisitor, it: &Item, _is_const: bool) {\n+fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n     match it.node {\n         ItemStatic(_, _, ex) => {\n-            v.visit_expr(&*ex, true);\n+            v.inside_const(|v| v.visit_expr(&*ex));\n             check_item_recursion(&v.tcx.sess, &v.tcx.map, &v.tcx.def_map, it);\n         }\n         ItemEnum(ref enum_definition, _) => {\n             for var in (*enum_definition).variants.iter() {\n                 for ex in var.node.disr_expr.iter() {\n-                    v.visit_expr(&**ex, true);\n+                    v.inside_const(|v| v.visit_expr(&**ex));\n                 }\n             }\n         }\n-        _ => visit::walk_item(v, it, false)\n+        _ => v.outside_const(|v| visit::walk_item(v, it))\n     }\n }\n \n-fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n+fn check_pat(v: &mut CheckCrateVisitor, p: &Pat) {\n     fn is_str(e: &Expr) -> bool {\n         match e.node {\n             ExprBox(_, expr) => {\n@@ -72,18 +88,18 @@ fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n         }\n     }\n     match p.node {\n-      // Let through plain ~-string literals here\n-      PatLit(ref a) => if !is_str(&**a) { v.visit_expr(&**a, true); },\n-      PatRange(ref a, ref b) => {\n-        if !is_str(&**a) { v.visit_expr(&**a, true); }\n-        if !is_str(&**b) { v.visit_expr(&**b, true); }\n-      }\n-      _ => visit::walk_pat(v, p, false)\n+        // Let through plain ~-string literals here\n+        PatLit(ref a) => if !is_str(&**a) { v.inside_const(|v| v.visit_expr(&**a)); },\n+        PatRange(ref a, ref b) => {\n+            if !is_str(&**a) { v.inside_const(|v| v.visit_expr(&**a)); }\n+            if !is_str(&**b) { v.inside_const(|v| v.visit_expr(&**b)); }\n+        }\n+        _ => v.outside_const(|v| visit::walk_pat(v, p))\n     }\n }\n \n-fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n-    if is_const {\n+fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) {\n+    if v.in_const {\n         match e.node {\n           ExprUnary(UnDeref, _) => { }\n           ExprUnary(UnBox, _) | ExprUnary(UnUniq, _) => {\n@@ -165,7 +181,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n                 }\n             }\n             match block.expr {\n-                Some(ref expr) => check_expr(v, &**expr, true),\n+                Some(ref expr) => check_expr(v, &**expr),\n                 None => {}\n             }\n           }\n@@ -195,7 +211,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n           }\n         }\n     }\n-    visit::walk_expr(v, e, is_const);\n+    visit::walk_expr(v, e);\n }\n \n struct CheckItemRecursionVisitor<'a> {\n@@ -219,32 +235,32 @@ pub fn check_item_recursion<'a>(sess: &'a Session,\n         def_map: def_map,\n         idstack: Vec::new()\n     };\n-    visitor.visit_item(it, ());\n+    visitor.visit_item(it);\n }\n \n-impl<'a> Visitor<()> for CheckItemRecursionVisitor<'a> {\n-    fn visit_item(&mut self, it: &Item, _: ()) {\n+impl<'a> Visitor for CheckItemRecursionVisitor<'a> {\n+    fn visit_item(&mut self, it: &Item) {\n         if self.idstack.iter().any(|x| x == &(it.id)) {\n             self.sess.span_fatal(self.root_it.span, \"recursive constant\");\n         }\n         self.idstack.push(it.id);\n-        visit::walk_item(self, it, ());\n+        visit::walk_item(self, it);\n         self.idstack.pop();\n     }\n \n-    fn visit_expr(&mut self, e: &Expr, _: ()) {\n+    fn visit_expr(&mut self, e: &Expr) {\n         match e.node {\n             ExprPath(..) => {\n                 match self.def_map.borrow().find(&e.id) {\n                     Some(&DefStatic(def_id, _)) if\n                             ast_util::is_local(def_id) => {\n-                        self.visit_item(&*self.ast_map.expect_item(def_id.node), ());\n+                        self.visit_item(&*self.ast_map.expect_item(def_id.node));\n                     }\n                     _ => ()\n                 }\n             },\n             _ => ()\n         }\n-        visit::walk_expr(self, e, ());\n+        visit::walk_expr(self, e);\n     }\n }"}, {"sha": "67c62262dcdf9f56aff6a74e673b1a9bf13be7bb", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -22,45 +22,53 @@ enum Context {\n \n struct CheckLoopVisitor<'a> {\n     sess: &'a Session,\n+    cx: Context\n }\n \n pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n-    visit::walk_crate(&mut CheckLoopVisitor { sess: sess }, krate, Normal)\n+    visit::walk_crate(&mut CheckLoopVisitor { sess: sess, cx: Normal }, krate)\n }\n \n-impl<'a> Visitor<Context> for CheckLoopVisitor<'a> {\n-    fn visit_item(&mut self, i: &ast::Item, _cx: Context) {\n-        visit::walk_item(self, i, Normal);\n+impl<'a> Visitor for CheckLoopVisitor<'a> {\n+    fn visit_item(&mut self, i: &ast::Item) {\n+        self.with_context(Normal, |v| visit::walk_item(v, i));\n     }\n \n-    fn visit_expr(&mut self, e: &ast::Expr, cx:Context) {\n+    fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprWhile(ref e, ref b, _) => {\n-                self.visit_expr(&**e, cx);\n-                self.visit_block(&**b, Loop);\n+                self.visit_expr(&**e);\n+                self.with_context(Loop, |v| v.visit_block(&**b));\n             }\n             ast::ExprLoop(ref b, _) => {\n-                self.visit_block(&**b, Loop);\n+                self.with_context(Loop, |v| v.visit_block(&**b));\n             }\n             ast::ExprForLoop(_, ref e, ref b, _) => {\n-                self.visit_expr(&**e, cx);\n-                self.visit_block(&**b, Loop);\n+                self.visit_expr(&**e);\n+                self.with_context(Loop, |v| v.visit_block(&**b));\n             }\n             ast::ExprFnBlock(_, _, ref b) |\n             ast::ExprProc(_, ref b) |\n             ast::ExprUnboxedFn(_, _, _, ref b) => {\n-                self.visit_block(&**b, Closure);\n+                self.with_context(Closure, |v| v.visit_block(&**b));\n             }\n-            ast::ExprBreak(_) => self.require_loop(\"break\", cx, e.span),\n-            ast::ExprAgain(_) => self.require_loop(\"continue\", cx, e.span),\n-            _ => visit::walk_expr(self, e, cx)\n+            ast::ExprBreak(_) => self.require_loop(\"break\", e.span),\n+            ast::ExprAgain(_) => self.require_loop(\"continue\", e.span),\n+            _ => visit::walk_expr(self, e)\n         }\n     }\n }\n \n impl<'a> CheckLoopVisitor<'a> {\n-    fn require_loop(&self, name: &str, cx: Context, span: Span) {\n-        match cx {\n+    fn with_context(&mut self, cx: Context, f: |&mut CheckLoopVisitor<'a>|) {\n+        let old_cx = self.cx;\n+        self.cx = cx;\n+        f(self);\n+        self.cx = old_cx;\n+    }\n+\n+    fn require_loop(&self, name: &str, span: Span) {\n+        match self.cx {\n             Loop => {}\n             Closure => {\n                 self.sess.span_err(span,"}, {"sha": "b0a5e7f119240d6ead5039e76c7e01cd613d1a18", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -119,26 +119,26 @@ enum WitnessPreference {\n     LeaveOutWitness\n }\n \n-impl<'a, 'tcx> Visitor<()> for MatchCheckCtxt<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &Expr, _: ()) {\n+impl<'a, 'tcx> Visitor for MatchCheckCtxt<'a, 'tcx> {\n+    fn visit_expr(&mut self, ex: &Expr) {\n         check_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l: &Local, _: ()) {\n+    fn visit_local(&mut self, l: &Local) {\n         check_local(self, l);\n     }\n-    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId, _: ()) {\n+    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId) {\n         check_fn(self, fk, fd, b, s);\n     }\n }\n \n pub fn check_crate(tcx: &ty::ctxt, krate: &Crate) {\n     let mut cx = MatchCheckCtxt { tcx: tcx };\n-    visit::walk_crate(&mut cx, krate, ());\n+    visit::walk_crate(&mut cx, krate);\n     tcx.sess.abort_if_errors();\n }\n \n fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n-    visit::walk_expr(cx, ex, ());\n+    visit::walk_expr(cx, ex);\n     match ex.node {\n         ExprMatch(scrut, ref arms) => {\n             // First, check legality of move bindings.\n@@ -844,7 +844,7 @@ fn default(cx: &MatchCheckCtxt, r: &[Gc<Pat>]) -> Option<Vec<Gc<Pat>>> {\n }\n \n fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n-    visit::walk_local(cx, loc, ());\n+    visit::walk_local(cx, loc);\n \n     let name = match loc.source {\n         LocalLet => \"local\",\n@@ -872,7 +872,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n             decl: &FnDecl,\n             body: &Block,\n             sp: Span) {\n-    visit::walk_fn(cx, kind, decl, body, sp, ());\n+    visit::walk_fn(cx, kind, decl, body, sp);\n     for input in decl.inputs.iter() {\n         match is_refutable(cx, input.pat) {\n             Some(pat) => {\n@@ -1014,27 +1014,30 @@ impl<'a, 'tcx> Delegate for MutationChecker<'a, 'tcx> {\n /// because of the way rvalues are handled in the borrow check. (See issue\n /// #14587.)\n fn check_legality_of_bindings_in_at_patterns(cx: &MatchCheckCtxt, pat: &Pat) {\n-    let mut visitor = AtBindingPatternVisitor {\n-        cx: cx,\n-    };\n-    visitor.visit_pat(pat, true);\n+    AtBindingPatternVisitor { cx: cx, bindings_allowed: true }.visit_pat(pat);\n }\n \n struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n     cx: &'a MatchCheckCtxt<'b, 'tcx>,\n+    bindings_allowed: bool\n }\n \n-impl<'a, 'b, 'tcx> Visitor<bool> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n-    fn visit_pat(&mut self, pat: &Pat, bindings_allowed: bool) {\n-        if !bindings_allowed && pat_is_binding(&self.cx.tcx.def_map, pat) {\n+impl<'a, 'b, 'tcx> Visitor for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n+    fn visit_pat(&mut self, pat: &Pat) {\n+        if !self.bindings_allowed && pat_is_binding(&self.cx.tcx.def_map, pat) {\n             self.cx.tcx.sess.span_err(pat.span,\n                                       \"pattern bindings are not allowed \\\n                                        after an `@`\");\n         }\n \n         match pat.node {\n-            PatIdent(_, _, Some(_)) => visit::walk_pat(self, pat, false),\n-            _ => visit::walk_pat(self, pat, bindings_allowed),\n+            PatIdent(_, _, Some(_)) => {\n+                let bindings_were_allowed = self.bindings_allowed;\n+                self.bindings_allowed = false;\n+                visit::walk_pat(self, pat);\n+                self.bindings_allowed = bindings_were_allowed;\n+            }\n+            _ => visit::walk_pat(self, pat),\n         }\n     }\n }"}, {"sha": "07ccfb0b27be9f1774c58d2fbde8fde58f071f52", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -23,21 +23,20 @@ use syntax::visit;\n pub fn check_crate(tcx: &ty::ctxt,\n                    krate: &ast::Crate) {\n     let mut rvcx = RvalueContext { tcx: tcx };\n-    visit::walk_crate(&mut rvcx, krate, ());\n+    visit::walk_crate(&mut rvcx, krate);\n }\n \n struct RvalueContext<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>\n }\n \n-impl<'a, 'tcx> visit::Visitor<()> for RvalueContext<'a, 'tcx> {\n+impl<'a, 'tcx> visit::Visitor for RvalueContext<'a, 'tcx> {\n     fn visit_fn(&mut self,\n                 _: &visit::FnKind,\n                 fd: &ast::FnDecl,\n                 b: &ast::Block,\n                 _: Span,\n-                _: ast::NodeId,\n-                _: ()) {\n+                _: ast::NodeId) {\n         let mut euv = euv::ExprUseVisitor::new(self, self.tcx);\n         euv.walk_fn(fd, b);\n     }"}, {"sha": "c4a74abed69be14b960fdfa4f0e23f3122ba1d82", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -27,7 +27,6 @@\n use middle::ty;\n \n use syntax::ast;\n-use syntax::codemap::Span;\n use syntax::visit::Visitor;\n use syntax::visit;\n use syntax::print::pprust;\n@@ -54,41 +53,42 @@ fn safe_type_for_static_mut(cx: &ty::ctxt, e: &ast::Expr) -> Option<String> {\n \n struct CheckStaticVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n+    in_const: bool\n }\n \n pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n-    visit::walk_crate(&mut CheckStaticVisitor { tcx: tcx }, krate, false)\n+    visit::walk_crate(&mut CheckStaticVisitor { tcx: tcx, in_const: false }, krate)\n }\n \n impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n-    fn report_error(&self, span: Span, result: Option<String>) -> bool {\n-        match result {\n-            None => { false }\n-            Some(msg) => {\n-                self.tcx.sess.span_err(span, msg.as_slice());\n-                true\n-            }\n-        }\n+    fn with_const(&mut self, in_const: bool, f: |&mut CheckStaticVisitor<'a, 'tcx>|) {\n+        let was_const = self.in_const;\n+        self.in_const = in_const;\n+        f(self);\n+        self.in_const = was_const;\n     }\n }\n \n-impl<'a, 'tcx> Visitor<bool> for CheckStaticVisitor<'a, 'tcx> {\n-\n-    fn visit_item(&mut self, i: &ast::Item, _is_const: bool) {\n+impl<'a, 'tcx> Visitor for CheckStaticVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &ast::Item) {\n         debug!(\"visit_item(item={})\", pprust::item_to_string(i));\n         match i.node {\n             ast::ItemStatic(_, mutability, ref expr) => {\n                 match mutability {\n                     ast::MutImmutable => {\n-                        self.visit_expr(&**expr, true);\n+                        self.with_const(true, |v| v.visit_expr(&**expr));\n                     }\n                     ast::MutMutable => {\n-                        let safe = safe_type_for_static_mut(self.tcx, &**expr);\n-                        self.report_error(expr.span, safe);\n+                        match safe_type_for_static_mut(self.tcx, &**expr) {\n+                            Some(msg) => {\n+                                self.tcx.sess.span_err(expr.span, msg.as_slice());\n+                            }\n+                            None => {}\n+                        }\n                     }\n                 }\n             }\n-            _ => { visit::walk_item(self, i, false) }\n+            _ => self.with_const(false, |v| visit::walk_item(v, i))\n         }\n     }\n \n@@ -98,17 +98,17 @@ impl<'a, 'tcx> Visitor<bool> for CheckStaticVisitor<'a, 'tcx> {\n     /// every nested expression. if the expression is not part\n     /// of a static item, this method does nothing but walking\n     /// down through it.\n-    fn visit_expr(&mut self, e: &ast::Expr, is_const: bool) {\n+    fn visit_expr(&mut self, e: &ast::Expr) {\n         debug!(\"visit_expr(expr={})\", pprust::expr_to_string(e));\n \n-        if !is_const {\n-            return visit::walk_expr(self, e, is_const);\n+        if !self.in_const {\n+            return visit::walk_expr(self, e);\n         }\n \n         match e.node {\n             ast::ExprField(..) | ast::ExprTupField(..) | ast::ExprVec(..) |\n             ast::ExprBlock(..) | ast::ExprTup(..)  => {\n-                visit::walk_expr(self, e, is_const);\n+                visit::walk_expr(self, e);\n             }\n             ast::ExprAddrOf(ast::MutMutable, _) => {\n                 span_err!(self.tcx.sess, e.span, E0020,\n@@ -130,15 +130,14 @@ impl<'a, 'tcx> Visitor<bool> for CheckStaticVisitor<'a, 'tcx> {\n                     ty::ty_struct(did, _) |\n                     ty::ty_enum(did, _) => {\n                         if ty::has_dtor(self.tcx, did) {\n-                            self.report_error(e.span,\n-                             Some(\"static items are not allowed to have \\\n-                                   destructors\".to_string()));\n+                            self.tcx.sess.span_err(e.span,\n+                                \"static items are not allowed to have destructors\");\n                             return;\n                         }\n                     }\n                     _ => {}\n                 }\n-                visit::walk_expr(self, e, is_const);\n+                visit::walk_expr(self, e);\n             }\n         }\n     }"}, {"sha": "375678b2a61096e2039fe3874bb5b7bd56346fc1", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -268,19 +268,19 @@ impl<'a, 'tcx> ConstEvalVisitor<'a, 'tcx> {\n \n }\n \n-impl<'a, 'tcx> Visitor<()> for ConstEvalVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, t: &Ty, _: ()) {\n+impl<'a, 'tcx> Visitor for ConstEvalVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, t: &Ty) {\n         match t.node {\n             TyFixedLengthVec(_, expr) => {\n                 check::check_const_in_type(self.tcx, &*expr, ty::mk_uint());\n             }\n             _ => {}\n         }\n \n-        visit::walk_ty(self, t, ());\n+        visit::walk_ty(self, t);\n     }\n \n-    fn visit_expr_post(&mut self, e: &Expr, _: ()) {\n+    fn visit_expr_post(&mut self, e: &Expr) {\n         self.classify(e);\n     }\n }\n@@ -291,7 +291,7 @@ pub fn process_crate(krate: &ast::Crate,\n         tcx: tcx,\n         ccache: DefIdMap::new(),\n     };\n-    visit::walk_crate(&mut v, krate, ());\n+    visit::walk_crate(&mut v, krate);\n     tcx.sess.abort_if_errors();\n }\n "}, {"sha": "c26acedb1b8c7353134f46623d5c53615e8f369c", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -172,11 +172,11 @@ fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n             index: &'a mut NodeMap<CFGIndex>,\n         }\n         let mut formals = Formals { entry: entry, index: index };\n-        visit::walk_fn_decl(&mut formals, decl, ());\n-        impl<'a> visit::Visitor<()> for Formals<'a> {\n-            fn visit_pat(&mut self, p: &ast::Pat, e: ()) {\n+        visit::walk_fn_decl(&mut formals, decl);\n+        impl<'a> visit::Visitor for Formals<'a> {\n+            fn visit_pat(&mut self, p: &ast::Pat) {\n                 self.index.insert(p.id, self.entry);\n-                visit::walk_pat(self, p, e)\n+                visit::walk_pat(self, p)\n             }\n         }\n     }"}, {"sha": "4684e64ed2b9fcf169cbd59b53209fae9901ff4f", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 43, "deletions": 48, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -51,10 +51,6 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n     tcx: &'a ty::ctxt<'tcx>,\n     live_symbols: Box<HashSet<ast::NodeId>>,\n-}\n-\n-#[deriving(Clone)]\n-struct MarkSymbolVisitorContext {\n     struct_has_extern_repr: bool\n }\n \n@@ -65,6 +61,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             worklist: worklist,\n             tcx: tcx,\n             live_symbols: box HashSet::new(),\n+            struct_has_extern_repr: false\n         }\n     }\n \n@@ -199,66 +196,64 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_node(&mut self, node: &ast_map::Node) {\n-        let ctxt = MarkSymbolVisitorContext {\n-            struct_has_extern_repr: false\n-        };\n+        let had_extern_repr = self.struct_has_extern_repr;\n+        self.struct_has_extern_repr = false;\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n                     ast::ItemStruct(..) => {\n-                        let has_extern_repr = item.attrs.iter().fold(false, |acc, attr| {\n-                            acc || attr::find_repr_attrs(self.tcx.sess.diagnostic(), attr)\n-                                         .iter().any(|&x| x == attr::ReprExtern)\n+                        self.struct_has_extern_repr = item.attrs.iter().any(|attr| {\n+                            attr::find_repr_attrs(self.tcx.sess.diagnostic(), attr)\n+                                .contains(&attr::ReprExtern)\n                         });\n \n-                        visit::walk_item(self, &*item, MarkSymbolVisitorContext {\n-                            struct_has_extern_repr: has_extern_repr,\n-                            ..(ctxt)\n-                        });\n+                        visit::walk_item(self, &*item);\n                     }\n                     ast::ItemFn(..)\n                     | ast::ItemEnum(..)\n                     | ast::ItemTy(..)\n                     | ast::ItemStatic(..) => {\n-                        visit::walk_item(self, &*item, ctxt);\n+                        visit::walk_item(self, &*item);\n                     }\n                     _ => ()\n                 }\n             }\n             ast_map::NodeTraitItem(trait_method) => {\n-                visit::walk_trait_item(self, &*trait_method, ctxt);\n+                visit::walk_trait_item(self, &*trait_method);\n             }\n             ast_map::NodeImplItem(impl_item) => {\n                 match *impl_item {\n                     ast::MethodImplItem(method) => {\n-                        visit::walk_block(self, &*method.pe_body(), ctxt);\n+                        visit::walk_block(self, &*method.pe_body());\n                     }\n                 }\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n-                visit::walk_foreign_item(self, &*foreign_item, ctxt);\n+                visit::walk_foreign_item(self, &*foreign_item);\n             }\n             _ => ()\n         }\n+        self.struct_has_extern_repr = had_extern_repr;\n     }\n }\n \n-impl<'a, 'tcx> Visitor<MarkSymbolVisitorContext> for MarkSymbolVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor for MarkSymbolVisitor<'a, 'tcx> {\n \n-    fn visit_struct_def(&mut self, def: &ast::StructDef, _: ast::Ident, _: &ast::Generics,\n-                        _: ast::NodeId, ctxt: MarkSymbolVisitorContext) {\n+    fn visit_struct_def(&mut self, def: &ast::StructDef, _: ast::Ident,\n+                        _: &ast::Generics, _: ast::NodeId) {\n+        let has_extern_repr = self.struct_has_extern_repr;\n         let live_fields = def.fields.iter().filter(|f| {\n-            ctxt.struct_has_extern_repr || match f.node.kind {\n+            has_extern_repr || match f.node.kind {\n                 ast::NamedField(_, ast::Public) => true,\n                 _ => false\n             }\n         });\n         self.live_symbols.extend(live_fields.map(|f| f.node.id));\n \n-        visit::walk_struct_def(self, def, ctxt);\n+        visit::walk_struct_def(self, def);\n     }\n \n-    fn visit_expr(&mut self, expr: &ast::Expr, ctxt: MarkSymbolVisitorContext) {\n+    fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(expr.id, expr.span);\n@@ -272,10 +267,10 @@ impl<'a, 'tcx> Visitor<MarkSymbolVisitorContext> for MarkSymbolVisitor<'a, 'tcx>\n             _ => ()\n         }\n \n-        visit::walk_expr(self, expr, ctxt);\n+        visit::walk_expr(self, expr);\n     }\n \n-    fn visit_pat(&mut self, pat: &ast::Pat, ctxt: MarkSymbolVisitorContext) {\n+    fn visit_pat(&mut self, pat: &ast::Pat) {\n         match pat.node {\n             ast::PatStruct(_, ref fields, _) => {\n                 self.handle_field_pattern_match(pat, fields.as_slice());\n@@ -287,15 +282,15 @@ impl<'a, 'tcx> Visitor<MarkSymbolVisitorContext> for MarkSymbolVisitor<'a, 'tcx>\n             _ => ()\n         }\n \n-        visit::walk_pat(self, pat, ctxt);\n+        visit::walk_pat(self, pat);\n     }\n \n-    fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId, ctxt: MarkSymbolVisitorContext) {\n+    fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId) {\n         self.lookup_and_handle_definition(&id);\n-        visit::walk_path(self, path, ctxt);\n+        visit::walk_path(self, path);\n     }\n \n-    fn visit_item(&mut self, _: &ast::Item, _: MarkSymbolVisitorContext) {\n+    fn visit_item(&mut self, _: &ast::Item) {\n         // Do not recurse into items. These items will be added to the\n         // worklist and recursed into manually if necessary.\n     }\n@@ -334,8 +329,8 @@ struct LifeSeeder {\n     worklist: Vec<ast::NodeId> ,\n }\n \n-impl Visitor<()> for LifeSeeder {\n-    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+impl Visitor for LifeSeeder {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         if has_allow_dead_code_or_lang_attr(item.attrs.as_slice()) {\n             self.worklist.push(item.id);\n         }\n@@ -351,12 +346,12 @@ impl Visitor<()> for LifeSeeder {\n             }\n             _ => ()\n         }\n-        visit::walk_item(self, item, ());\n+        visit::walk_item(self, item);\n     }\n \n     fn visit_fn(&mut self, fk: &visit::FnKind,\n                 _: &ast::FnDecl, block: &ast::Block,\n-                _: codemap::Span, id: ast::NodeId, _: ()) {\n+                _: codemap::Span, id: ast::NodeId) {\n         // Check for method here because methods are not ast::Item\n         match *fk {\n             visit::FkMethod(_, _, method) => {\n@@ -366,7 +361,7 @@ impl Visitor<()> for LifeSeeder {\n             }\n             _ => ()\n         }\n-        visit::walk_block(self, block, ());\n+        visit::walk_block(self, block);\n     }\n }\n \n@@ -398,7 +393,7 @@ fn create_and_seed_worklist(tcx: &ty::ctxt,\n     let mut life_seeder = LifeSeeder {\n         worklist: worklist\n     };\n-    visit::walk_crate(&mut life_seeder, krate, ());\n+    visit::walk_crate(&mut life_seeder, krate);\n \n     return life_seeder.worklist;\n }\n@@ -504,25 +499,25 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<()> for DeadVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+impl<'a, 'tcx> Visitor for DeadVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         let ctor_id = get_struct_ctor_id(item);\n         if !self.symbol_is_live(item.id, ctor_id) && should_warn(item) {\n             self.warn_dead_code(item.id, item.span, item.ident);\n         }\n-        visit::walk_item(self, item, ());\n+        visit::walk_item(self, item);\n     }\n \n-    fn visit_foreign_item(&mut self, fi: &ast::ForeignItem, _: ()) {\n+    fn visit_foreign_item(&mut self, fi: &ast::ForeignItem) {\n         if !self.symbol_is_live(fi.id, None) {\n             self.warn_dead_code(fi.id, fi.span, fi.ident);\n         }\n-        visit::walk_foreign_item(self, fi, ());\n+        visit::walk_foreign_item(self, fi);\n     }\n \n     fn visit_fn(&mut self, fk: &visit::FnKind,\n                 _: &ast::FnDecl, block: &ast::Block,\n-                span: codemap::Span, id: ast::NodeId, _: ()) {\n+                span: codemap::Span, id: ast::NodeId) {\n         // Have to warn method here because methods are not ast::Item\n         match *fk {\n             visit::FkMethod(..) => {\n@@ -533,22 +528,22 @@ impl<'a, 'tcx> Visitor<()> for DeadVisitor<'a, 'tcx> {\n             }\n             _ => ()\n         }\n-        visit::walk_block(self, block, ());\n+        visit::walk_block(self, block);\n     }\n \n-    fn visit_struct_field(&mut self, field: &ast::StructField, _: ()) {\n+    fn visit_struct_field(&mut self, field: &ast::StructField) {\n         if self.should_warn_about_field(&field.node) {\n             self.warn_dead_code(field.node.id, field.span, field.node.ident().unwrap());\n         }\n \n-        visit::walk_struct_field(self, field, ());\n+        visit::walk_struct_field(self, field);\n     }\n \n     // Overwrite so that we don't warn the trait method itself.\n-    fn visit_trait_item(&mut self, trait_method: &ast::TraitItem, _: ()) {\n+    fn visit_trait_item(&mut self, trait_method: &ast::TraitItem) {\n         match *trait_method {\n             ast::ProvidedMethod(ref method) => {\n-                visit::walk_block(self, &*method.pe_body(), ())\n+                visit::walk_block(self, &*method.pe_body())\n             }\n             ast::RequiredMethod(_) => ()\n         }\n@@ -562,5 +557,5 @@ pub fn check_crate(tcx: &ty::ctxt,\n     let live_symbols = find_live(tcx, exported_items,\n                                  reachable_symbols, krate);\n     let mut visitor = DeadVisitor { tcx: tcx, live_symbols: live_symbols };\n-    visit::walk_crate(&mut visitor, krate, ());\n+    visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "7ce7a112bdc2cece4d3dd1aad108236c0362d91c", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -86,9 +86,9 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<()> for EffectCheckVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_fn(&mut self, fn_kind: &visit::FnKind, fn_decl: &ast::FnDecl,\n-                block: &ast::Block, span: Span, _: ast::NodeId, _:()) {\n+                block: &ast::Block, span: Span, _: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match *fn_kind {\n             visit::FkItemFn(_, _, fn_style, _) =>\n@@ -105,12 +105,12 @@ impl<'a, 'tcx> Visitor<()> for EffectCheckVisitor<'a, 'tcx> {\n             self.unsafe_context = SafeContext\n         }\n \n-        visit::walk_fn(self, fn_kind, fn_decl, block, span, ());\n+        visit::walk_fn(self, fn_kind, fn_decl, block, span);\n \n         self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_block(&mut self, block: &ast::Block, _:()) {\n+    fn visit_block(&mut self, block: &ast::Block) {\n         let old_unsafe_context = self.unsafe_context;\n         match block.rules {\n             ast::DefaultBlock => {}\n@@ -136,12 +136,12 @@ impl<'a, 'tcx> Visitor<()> for EffectCheckVisitor<'a, 'tcx> {\n             }\n         }\n \n-        visit::walk_block(self, block, ());\n+        visit::walk_block(self, block);\n \n         self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_expr(&mut self, expr: &ast::Expr, _:()) {\n+    fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> Visitor<()> for EffectCheckVisitor<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_expr(self, expr, ());\n+        visit::walk_expr(self, expr);\n     }\n }\n \n@@ -203,5 +203,5 @@ pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n         unsafe_context: SafeContext,\n     };\n \n-    visit::walk_crate(&mut visitor, krate, ());\n+    visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "cfa96619f1973b34eb2ff3776c5a94fb2562bfcb", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -41,8 +41,8 @@ struct EntryContext<'a> {\n     non_main_fns: Vec<(NodeId, Span)> ,\n }\n \n-impl<'a> Visitor<()> for EntryContext<'a> {\n-    fn visit_item(&mut self, item: &Item, _:()) {\n+impl<'a> Visitor for EntryContext<'a> {\n+    fn visit_item(&mut self, item: &Item) {\n         find_item(item, self);\n     }\n }\n@@ -72,7 +72,7 @@ pub fn find_entry_point(session: &Session, krate: &Crate, ast_map: &ast_map::Map\n         non_main_fns: Vec::new(),\n     };\n \n-    visit::walk_crate(&mut ctxt, krate, ());\n+    visit::walk_crate(&mut ctxt, krate);\n \n     configure_main(&mut ctxt);\n }\n@@ -118,7 +118,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext) {\n         _ => ()\n     }\n \n-    visit::walk_item(ctxt, item, ());\n+    visit::walk_item(ctxt, item);\n }\n \n fn configure_main(this: &mut EntryContext) {"}, {"sha": "7f3691ba5a9d36dae3b4d5fcc7fd78f6cd2c1c7d", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -50,18 +50,21 @@ struct CollectFreevarsVisitor<'a> {\n     refs: Vec<freevar_entry>,\n     def_map: &'a resolve::DefMap,\n     capture_mode_map: &'a mut CaptureModeMap,\n+    depth: uint\n }\n \n-impl<'a> Visitor<int> for CollectFreevarsVisitor<'a> {\n-    fn visit_item(&mut self, _: &ast::Item, _: int) {\n+impl<'a> Visitor for CollectFreevarsVisitor<'a> {\n+    fn visit_item(&mut self, _: &ast::Item) {\n         // ignore_item\n     }\n \n-    fn visit_expr(&mut self, expr: &ast::Expr, depth: int) {\n+    fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprProc(..) => {\n                 self.capture_mode_map.insert(expr.id, CaptureByValue);\n-                visit::walk_expr(self, expr, depth + 1)\n+                self.depth += 1;\n+                visit::walk_expr(self, expr);\n+                self.depth -= 1;\n             }\n             ast::ExprFnBlock(_, _, _) => {\n                 // NOTE(stage0): After snapshot, change to:\n@@ -72,43 +75,43 @@ impl<'a> Visitor<int> for CollectFreevarsVisitor<'a> {\n                 //};\n                 let capture_mode = CaptureByRef;\n                 self.capture_mode_map.insert(expr.id, capture_mode);\n-                visit::walk_expr(self, expr, depth + 1)\n+                self.depth += 1;\n+                visit::walk_expr(self, expr);\n+                self.depth -= 1;\n             }\n             ast::ExprUnboxedFn(capture_clause, _, _, _) => {\n                 let capture_mode = match capture_clause {\n                     ast::CaptureByValue => CaptureByValue,\n                     ast::CaptureByRef => CaptureByRef,\n                 };\n                 self.capture_mode_map.insert(expr.id, capture_mode);\n-                visit::walk_expr(self, expr, depth + 1)\n+                self.depth += 1;\n+                visit::walk_expr(self, expr);\n+                self.depth -= 1;\n             }\n             ast::ExprPath(..) => {\n+                let mut def = *self.def_map.borrow().find(&expr.id)\n+                                                    .expect(\"path not found\");\n                 let mut i = 0;\n-                match self.def_map.borrow().find(&expr.id) {\n-                    None => fail!(\"path not found\"),\n-                    Some(&df) => {\n-                        let mut def = df;\n-                        while i < depth {\n-                            match def {\n-                                def::DefUpvar(_, inner, _, _) => { def = *inner; }\n-                                _ => break\n-                            }\n-                            i += 1;\n-                        }\n-                        if i == depth { // Made it to end of loop\n-                            let dnum = def.def_id().node;\n-                            if !self.seen.contains(&dnum) {\n-                                self.refs.push(freevar_entry {\n-                                    def: def,\n-                                    span: expr.span,\n-                                });\n-                                self.seen.insert(dnum);\n-                            }\n-                        }\n+                while i < self.depth {\n+                    match def {\n+                        def::DefUpvar(_, inner, _, _) => { def = *inner; }\n+                        _ => break\n+                    }\n+                    i += 1;\n+                }\n+                if i == self.depth { // Made it to end of loop\n+                    let dnum = def.def_id().node;\n+                    if !self.seen.contains(&dnum) {\n+                        self.refs.push(freevar_entry {\n+                            def: def,\n+                            span: expr.span,\n+                        });\n+                        self.seen.insert(dnum);\n                     }\n                 }\n             }\n-            _ => visit::walk_expr(self, expr, depth)\n+            _ => visit::walk_expr(self, expr)\n         }\n     }\n }\n@@ -127,9 +130,10 @@ fn collect_freevars(def_map: &resolve::DefMap,\n         refs: Vec::new(),\n         def_map: def_map,\n         capture_mode_map: &mut *capture_mode_map,\n+        depth: 1\n     };\n \n-    v.visit_block(blk, 1);\n+    v.visit_block(blk);\n \n     v.refs\n }\n@@ -140,14 +144,14 @@ struct AnnotateFreevarsVisitor<'a> {\n     capture_mode_map: CaptureModeMap,\n }\n \n-impl<'a> Visitor<()> for AnnotateFreevarsVisitor<'a> {\n+impl<'a> Visitor for AnnotateFreevarsVisitor<'a> {\n     fn visit_fn(&mut self, fk: &visit::FnKind, fd: &ast::FnDecl,\n-                blk: &ast::Block, s: Span, nid: ast::NodeId, _: ()) {\n+                blk: &ast::Block, s: Span, nid: ast::NodeId) {\n         let vars = collect_freevars(self.def_map,\n                                     blk,\n                                     &mut self.capture_mode_map);\n         self.freevars.insert(nid, vars);\n-        visit::walk_fn(self, fk, fd, blk, s, ());\n+        visit::walk_fn(self, fk, fd, blk, s);\n     }\n }\n \n@@ -163,7 +167,7 @@ pub fn annotate_freevars(def_map: &resolve::DefMap, krate: &ast::Crate)\n         freevars: NodeMap::new(),\n         capture_mode_map: NodeMap::new(),\n     };\n-    visit::walk_crate(&mut visitor, krate, ());\n+    visit::walk_crate(&mut visitor, krate);\n \n     let AnnotateFreevarsVisitor {\n         freevars,"}, {"sha": "89e1fb8ae97fe9c33815abeaa434cb52ec20f2c4", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -116,8 +116,8 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<()> for IntrinsicCheckingVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &ast::Expr, (): ()) {\n+impl<'a, 'tcx> Visitor for IntrinsicCheckingVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprPath(..) => {\n                 match ty::resolve_expr(self.tcx, expr) {\n@@ -144,7 +144,7 @@ impl<'a, 'tcx> Visitor<()> for IntrinsicCheckingVisitor<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_expr(self, expr, ());\n+        visit::walk_expr(self, expr);\n     }\n }\n \n@@ -153,6 +153,6 @@ pub fn check_crate(tcx: &ctxt, krate: &ast::Crate) {\n         tcx: tcx,\n     };\n \n-    visit::walk_crate(&mut visitor, krate, ());\n+    visit::walk_crate(&mut visitor, krate);\n }\n "}, {"sha": "88da3abcac36382d739c7b7c1e1dd86090162dd4", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -56,29 +56,29 @@ pub struct Context<'a, 'tcx: 'a> {\n     parameter_environments: Vec<ParameterEnvironment>,\n }\n \n-impl<'a, 'tcx> Visitor<()> for Context<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &Expr, _: ()) {\n+impl<'a, 'tcx> Visitor for Context<'a, 'tcx> {\n+    fn visit_expr(&mut self, ex: &Expr) {\n         check_expr(self, ex);\n     }\n \n     fn visit_fn(&mut self, fk: &visit::FnKind, fd: &FnDecl,\n-                b: &Block, s: Span, n: NodeId, _: ()) {\n+                b: &Block, s: Span, n: NodeId) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n \n-    fn visit_ty(&mut self, t: &Ty, _: ()) {\n+    fn visit_ty(&mut self, t: &Ty) {\n         check_ty(self, t);\n     }\n \n-    fn visit_item(&mut self, i: &Item, _: ()) {\n+    fn visit_item(&mut self, i: &Item) {\n         check_item(self, i);\n     }\n \n-    fn visit_pat(&mut self, p: &Pat, _: ()) {\n+    fn visit_pat(&mut self, p: &Pat) {\n         check_pat(self, p);\n     }\n \n-    fn visit_local(&mut self, l: &Local, _: ()) {\n+    fn visit_local(&mut self, l: &Local) {\n         check_local(self, l);\n     }\n }\n@@ -90,7 +90,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         struct_and_enum_bounds_checked: HashSet::new(),\n         parameter_environments: Vec::new(),\n     };\n-    visit::walk_crate(&mut ctx, krate, ());\n+    visit::walk_crate(&mut ctx, krate);\n     tcx.sess.abort_if_errors();\n }\n \n@@ -265,7 +265,7 @@ fn check_item(cx: &mut Context, item: &Item) {\n         }\n     }\n \n-    visit::walk_item(cx, item, ())\n+    visit::walk_item(cx, item)\n }\n \n fn check_local(cx: &mut Context, local: &Local) {\n@@ -274,7 +274,7 @@ fn check_local(cx: &mut Context, local: &Local) {\n         local.span,\n         ty::node_id_to_type(cx.tcx, local.id));\n \n-    visit::walk_local(cx, local, ())\n+    visit::walk_local(cx, local)\n }\n \n // Yields the appropriate function to check the kind of closed over\n@@ -361,7 +361,7 @@ fn check_fn(\n             let ty = ty::node_id_to_type(cx.tcx, fn_id);\n             check_bounds_on_structs_or_enums_in_type_if_possible(cx, sp, ty);\n \n-            visit::walk_fn(cx, fk, decl, body, sp, ())\n+            visit::walk_fn(cx, fk, decl, body, sp)\n         }\n         visit::FkItemFn(..) | visit::FkMethod(..) => {\n             let parameter_environment = ParameterEnvironment::for_item(cx.tcx,\n@@ -371,7 +371,7 @@ fn check_fn(\n             let ty = ty::node_id_to_type(cx.tcx, fn_id);\n             check_bounds_on_structs_or_enums_in_type_if_possible(cx, sp, ty);\n \n-            visit::walk_fn(cx, fk, decl, body, sp, ());\n+            visit::walk_fn(cx, fk, decl, body, sp);\n             drop(cx.parameter_environments.pop());\n         }\n     }\n@@ -451,7 +451,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n         None => {}\n     }\n \n-    visit::walk_expr(cx, e, ());\n+    visit::walk_expr(cx, e);\n }\n \n fn check_bounds_on_type_parameters(cx: &mut Context, e: &Expr) {\n@@ -616,7 +616,7 @@ fn check_ty(cx: &mut Context, aty: &Ty) {\n         _ => {}\n     }\n \n-    visit::walk_ty(cx, aty, ());\n+    visit::walk_ty(cx, aty);\n }\n \n // Calls \"any_missing\" if any bounds were missing.\n@@ -804,5 +804,5 @@ fn check_pat(cx: &mut Context, pat: &Pat) {\n         None => {}\n     }\n \n-    visit::walk_pat(cx, pat, ());\n+    visit::walk_pat(cx, pat);\n }"}, {"sha": "6b0eec451a484a3a3d2c40458ff43b1d18186fa3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -115,8 +115,8 @@ struct LanguageItemCollector<'a> {\n     item_refs: HashMap<&'static str, uint>,\n }\n \n-impl<'a> Visitor<()> for LanguageItemCollector<'a> {\n-    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+impl<'a> Visitor for LanguageItemCollector<'a> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         match extract(item.attrs.as_slice()) {\n             Some(value) => {\n                 let item_index = self.item_refs.find_equiv(&value).map(|x| *x);\n@@ -131,7 +131,7 @@ impl<'a> Visitor<()> for LanguageItemCollector<'a> {\n             None => {}\n         }\n \n-        visit::walk_item(self, item, ());\n+        visit::walk_item(self, item);\n     }\n }\n \n@@ -166,7 +166,7 @@ impl<'a> LanguageItemCollector<'a> {\n     }\n \n     pub fn collect_local_language_items(&mut self, krate: &ast::Crate) {\n-        visit::walk_crate(self, krate, ());\n+        visit::walk_crate(self, krate);\n     }\n \n     pub fn collect_external_language_items(&mut self) {"}, {"sha": "121a6d80d01803be8e05ff4fa2bbfa3bda7fe0bf", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -179,18 +179,18 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, cx: &ty::ctxt) -> String {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<()> for IrMaps<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, _: ()) {\n+impl<'a, 'tcx> Visitor for IrMaps<'a, 'tcx> {\n+    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId) {\n         visit_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_local(&mut self, l: &Local, _: ()) { visit_local(self, l); }\n-    fn visit_expr(&mut self, ex: &Expr, _: ()) { visit_expr(self, ex); }\n-    fn visit_arm(&mut self, a: &Arm, _: ()) { visit_arm(self, a); }\n+    fn visit_local(&mut self, l: &Local) { visit_local(self, l); }\n+    fn visit_expr(&mut self, ex: &Expr) { visit_expr(self, ex); }\n+    fn visit_arm(&mut self, a: &Arm) { visit_arm(self, a); }\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n                    krate: &Crate) {\n-    visit::walk_crate(&mut IrMaps::new(tcx), krate, ());\n+    visit::walk_crate(&mut IrMaps::new(tcx), krate);\n     tcx.sess.abort_if_errors();\n }\n \n@@ -343,17 +343,17 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<()> for Liveness<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, _: ()) {\n+impl<'a, 'tcx> Visitor for Liveness<'a, 'tcx> {\n+    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_local(&mut self, l: &Local, _: ()) {\n+    fn visit_local(&mut self, l: &Local) {\n         check_local(self, l);\n     }\n-    fn visit_expr(&mut self, ex: &Expr, _: ()) {\n+    fn visit_expr(&mut self, ex: &Expr) {\n         check_expr(self, ex);\n     }\n-    fn visit_arm(&mut self, a: &Arm, _: ()) {\n+    fn visit_arm(&mut self, a: &Arm) {\n         check_arm(self, a);\n     }\n }\n@@ -387,7 +387,7 @@ fn visit_fn(ir: &mut IrMaps,\n \n     // gather up the various local variables, significant expressions,\n     // and so forth:\n-    visit::walk_fn(&mut fn_maps, fk, decl, body, sp, ());\n+    visit::walk_fn(&mut fn_maps, fk, decl, body, sp);\n \n     // Special nodes and variables:\n     // - exit_ln represents the end of the fn, either by return or fail\n@@ -404,7 +404,7 @@ fn visit_fn(ir: &mut IrMaps,\n     let entry_ln = lsets.compute(decl, body);\n \n     // check for various error conditions\n-    lsets.visit_block(body, ());\n+    lsets.visit_block(body);\n     lsets.check_ret(id, sp, fk, entry_ln, body);\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n@@ -419,7 +419,7 @@ fn visit_local(ir: &mut IrMaps, local: &Local) {\n           ident: name\n         }));\n     });\n-    visit::walk_local(ir, local, ());\n+    visit::walk_local(ir, local);\n }\n \n fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n@@ -435,7 +435,7 @@ fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n             }));\n         })\n     }\n-    visit::walk_arm(ir, arm, ());\n+    visit::walk_arm(ir, arm);\n }\n \n fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {\n@@ -457,7 +457,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         if moved_variable_node_id_from_def(def).is_some() {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n-        visit::walk_expr(ir, expr, ());\n+        visit::walk_expr(ir, expr);\n       }\n       ExprFnBlock(..) | ExprProc(..) | ExprUnboxedFn(..) => {\n         // Interesting control flow (for loops can contain labeled\n@@ -483,13 +483,13 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         });\n         ir.set_captures(expr.id, call_caps);\n \n-        visit::walk_expr(ir, expr, ());\n+        visit::walk_expr(ir, expr);\n       }\n \n       // live nodes required for interesting control flow:\n       ExprIf(..) | ExprMatch(..) | ExprWhile(..) | ExprLoop(..) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::walk_expr(ir, expr, ());\n+        visit::walk_expr(ir, expr);\n       }\n       ExprForLoop(ref pat, _, _, _) => {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n@@ -503,11 +503,11 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n             }));\n         });\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::walk_expr(ir, expr, ());\n+        visit::walk_expr(ir, expr);\n       }\n       ExprBinary(op, _, _) if ast_util::lazy_binop(op) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::walk_expr(ir, expr, ());\n+        visit::walk_expr(ir, expr);\n       }\n \n       // otherwise, live nodes are not required:\n@@ -519,7 +519,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       ExprAssign(..) | ExprAssignOp(..) | ExprMac(..) |\n       ExprStruct(..) | ExprRepeat(..) | ExprParen(..) |\n       ExprInlineAsm(..) | ExprBox(..) => {\n-          visit::walk_expr(ir, expr, ());\n+          visit::walk_expr(ir, expr);\n       }\n     }\n }\n@@ -1408,43 +1408,43 @@ fn check_local(this: &mut Liveness, local: &Local) {\n         }\n     }\n \n-    visit::walk_local(this, local, ());\n+    visit::walk_local(this, local);\n }\n \n fn check_arm(this: &mut Liveness, arm: &Arm) {\n     this.arm_pats_bindings(arm.pats.as_slice(), |this, ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     });\n-    visit::walk_arm(this, arm, ());\n+    visit::walk_arm(this, arm);\n }\n \n fn check_expr(this: &mut Liveness, expr: &Expr) {\n     match expr.node {\n       ExprAssign(ref l, ref r) => {\n         this.check_lvalue(&**l);\n-        this.visit_expr(&**r, ());\n+        this.visit_expr(&**r);\n \n-        visit::walk_expr(this, expr, ());\n+        visit::walk_expr(this, expr);\n       }\n \n       ExprAssignOp(_, ref l, _) => {\n         this.check_lvalue(&**l);\n \n-        visit::walk_expr(this, expr, ());\n+        visit::walk_expr(this, expr);\n       }\n \n       ExprInlineAsm(ref ia) => {\n         for &(_, ref input) in ia.inputs.iter() {\n-          this.visit_expr(&**input, ());\n+          this.visit_expr(&**input);\n         }\n \n         // Output operands must be lvalues\n         for &(_, ref out, _) in ia.outputs.iter() {\n           this.check_lvalue(&**out);\n-          this.visit_expr(&**out, ());\n+          this.visit_expr(&**out);\n         }\n \n-        visit::walk_expr(this, expr, ());\n+        visit::walk_expr(this, expr);\n       }\n \n       // no correctness conditions related to liveness\n@@ -1456,7 +1456,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ExprMac(..) | ExprAddrOf(..) | ExprStruct(..) | ExprRepeat(..) |\n       ExprParen(..) | ExprFnBlock(..) | ExprProc(..) | ExprUnboxedFn(..) |\n       ExprPath(..) | ExprBox(..) | ExprForLoop(..) => {\n-        visit::walk_expr(this, expr, ());\n+        visit::walk_expr(this, expr);\n       }\n     }\n }\n@@ -1546,7 +1546,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           _ => {\n             // For other kinds of lvalues, no checks are required,\n             // and any embedded expressions are actually rvalues\n-            visit::walk_expr(self, expr, ());\n+            visit::walk_expr(self, expr);\n           }\n        }\n     }"}, {"sha": "458b1dbc210eb0369c49b5001b68f6cd3f645a55", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 67, "deletions": 72, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -57,8 +57,8 @@ struct ParentVisitor {\n     curparent: ast::NodeId,\n }\n \n-impl Visitor<()> for ParentVisitor {\n-    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+impl Visitor for ParentVisitor {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         self.parents.insert(item.id, self.curparent);\n \n         let prev = self.curparent;\n@@ -91,28 +91,28 @@ impl Visitor<()> for ParentVisitor {\n \n             _ => {}\n         }\n-        visit::walk_item(self, item, ());\n+        visit::walk_item(self, item);\n         self.curparent = prev;\n     }\n \n-    fn visit_foreign_item(&mut self, a: &ast::ForeignItem, _: ()) {\n+    fn visit_foreign_item(&mut self, a: &ast::ForeignItem) {\n         self.parents.insert(a.id, self.curparent);\n-        visit::walk_foreign_item(self, a, ());\n+        visit::walk_foreign_item(self, a);\n     }\n \n     fn visit_fn(&mut self, a: &visit::FnKind, b: &ast::FnDecl,\n-                c: &ast::Block, d: Span, id: ast::NodeId, _: ()) {\n+                c: &ast::Block, d: Span, id: ast::NodeId) {\n         // We already took care of some trait methods above, otherwise things\n         // like impl methods and pub trait methods are parented to the\n         // containing module, not the containing trait.\n         if !self.parents.contains_key(&id) {\n             self.parents.insert(id, self.curparent);\n         }\n-        visit::walk_fn(self, a, b, c, d, ());\n+        visit::walk_fn(self, a, b, c, d);\n     }\n \n     fn visit_struct_def(&mut self, s: &ast::StructDef, _: ast::Ident,\n-                        _: &ast::Generics, n: ast::NodeId, _: ()) {\n+                        _: &ast::Generics, n: ast::NodeId) {\n         // Struct constructors are parented to their struct definitions because\n         // they essentially are the struct definitions.\n         match s.ctor_id {\n@@ -125,7 +125,7 @@ impl Visitor<()> for ParentVisitor {\n         for field in s.fields.iter() {\n             self.parents.insert(field.node.id, self.curparent);\n         }\n-        visit::walk_struct_def(self, s, ())\n+        visit::walk_struct_def(self, s)\n     }\n }\n \n@@ -180,8 +180,8 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<()> for EmbargoVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+impl<'a, 'tcx> Visitor for EmbargoVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         let orig_all_pub = self.prev_public;\n         self.prev_public = orig_all_pub && item.vis == ast::Public;\n         if self.prev_public {\n@@ -323,19 +323,19 @@ impl<'a, 'tcx> Visitor<()> for EmbargoVisitor<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_item(self, item, ());\n+        visit::walk_item(self, item);\n \n         self.prev_exported = orig_all_exported;\n         self.prev_public = orig_all_pub;\n     }\n \n-    fn visit_foreign_item(&mut self, a: &ast::ForeignItem, _: ()) {\n+    fn visit_foreign_item(&mut self, a: &ast::ForeignItem) {\n         if (self.prev_exported && a.vis == ast::Public) || self.reexports.contains(&a.id) {\n             self.exported_items.insert(a.id);\n         }\n     }\n \n-    fn visit_mod(&mut self, m: &ast::Mod, _sp: Span, id: ast::NodeId, _: ()) {\n+    fn visit_mod(&mut self, m: &ast::Mod, _sp: Span, id: ast::NodeId) {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_exported {\n@@ -347,7 +347,7 @@ impl<'a, 'tcx> Visitor<()> for EmbargoVisitor<'a, 'tcx> {\n                 }\n             }\n         }\n-        visit::walk_mod(self, m, ())\n+        visit::walk_mod(self, m)\n     }\n }\n \n@@ -802,14 +802,14 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<()> for PrivacyVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+impl<'a, 'tcx> Visitor for PrivacyVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         let orig_curitem = replace(&mut self.curitem, item.id);\n-        visit::walk_item(self, item, ());\n+        visit::walk_item(self, item);\n         self.curitem = orig_curitem;\n     }\n \n-    fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n+    fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprField(ref base, ident, _) => {\n                 match ty::get(ty::expr_ty_adjusted(self.tcx, &**base)).sty {\n@@ -912,10 +912,10 @@ impl<'a, 'tcx> Visitor<()> for PrivacyVisitor<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_expr(self, expr, ());\n+        visit::walk_expr(self, expr);\n     }\n \n-    fn visit_view_item(&mut self, a: &ast::ViewItem, _: ()) {\n+    fn visit_view_item(&mut self, a: &ast::ViewItem) {\n         match a.node {\n             ast::ViewItemExternCrate(..) => {}\n             ast::ViewItemUse(ref vpath) => {\n@@ -949,10 +949,10 @@ impl<'a, 'tcx> Visitor<()> for PrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n         }\n-        visit::walk_view_item(self, a, ());\n+        visit::walk_view_item(self, a);\n     }\n \n-    fn visit_pat(&mut self, pattern: &ast::Pat, _: ()) {\n+    fn visit_pat(&mut self, pattern: &ast::Pat) {\n         // Foreign functions do not have their patterns mapped in the def_map,\n         // and there's nothing really relevant there anyway, so don't bother\n         // checking privacy. If you can name the type then you can pass it to an\n@@ -1012,18 +1012,18 @@ impl<'a, 'tcx> Visitor<()> for PrivacyVisitor<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_pat(self, pattern, ());\n+        visit::walk_pat(self, pattern);\n     }\n \n-    fn visit_foreign_item(&mut self, fi: &ast::ForeignItem, _: ()) {\n+    fn visit_foreign_item(&mut self, fi: &ast::ForeignItem) {\n         self.in_foreign = true;\n-        visit::walk_foreign_item(self, fi, ());\n+        visit::walk_foreign_item(self, fi);\n         self.in_foreign = false;\n     }\n \n-    fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId, _: ()) {\n+    fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId) {\n         self.check_path(path.span, id, path);\n-        visit::walk_path(self, path, ());\n+        visit::walk_path(self, path);\n     }\n }\n \n@@ -1036,8 +1036,8 @@ struct SanePrivacyVisitor<'a, 'tcx: 'a> {\n     in_fn: bool,\n }\n \n-impl<'a, 'tcx> Visitor<()> for SanePrivacyVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+impl<'a, 'tcx> Visitor for SanePrivacyVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         if self.in_fn {\n             self.check_all_inherited(item);\n         } else {\n@@ -1049,19 +1049,19 @@ impl<'a, 'tcx> Visitor<()> for SanePrivacyVisitor<'a, 'tcx> {\n             ast::ItemMod(..) => false, // modules turn privacy back on\n             _ => in_fn,           // otherwise we inherit\n         });\n-        visit::walk_item(self, item, ());\n+        visit::walk_item(self, item);\n         self.in_fn = orig_in_fn;\n     }\n \n     fn visit_fn(&mut self, fk: &visit::FnKind, fd: &ast::FnDecl,\n-                b: &ast::Block, s: Span, _: ast::NodeId, _: ()) {\n+                b: &ast::Block, s: Span, _: ast::NodeId) {\n         // This catches both functions and methods\n         let orig_in_fn = replace(&mut self.in_fn, true);\n-        visit::walk_fn(self, fk, fd, b, s, ());\n+        visit::walk_fn(self, fk, fd, b, s);\n         self.in_fn = orig_in_fn;\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::ViewItem, _: ()) {\n+    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n         match i.vis {\n             ast::Inherited => {}\n             ast::Public => {\n@@ -1080,7 +1080,7 @@ impl<'a, 'tcx> Visitor<()> for SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n         }\n-        visit::walk_view_item(self, i, ());\n+        visit::walk_view_item(self, i);\n     }\n }\n \n@@ -1264,8 +1264,8 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> Visitor<()> for CheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n-    fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n+impl<'a, 'b, 'tcx> Visitor for CheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n+    fn visit_ty(&mut self, ty: &ast::Ty) {\n         match ty.node {\n             ast::TyPath(_, _, path_id) => {\n                 if self.inner.path_is_private_type(path_id) {\n@@ -1280,15 +1280,15 @@ impl<'a, 'b, 'tcx> Visitor<()> for CheckTypeForPrivatenessVisitor<'a, 'b, 'tcx>\n             _ => {}\n         }\n         self.at_outer_type = false;\n-        visit::walk_ty(self, ty, ())\n+        visit::walk_ty(self, ty)\n     }\n \n     // don't want to recurse into [, .. expr]\n-    fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n+    fn visit_expr(&mut self, _: &ast::Expr) {}\n }\n \n-impl<'a, 'tcx> Visitor<()> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+impl<'a, 'tcx> Visitor for VisiblePrivateTypesVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         match item.node {\n             // contents of a private mod can be reexported, so we need\n             // to check internals.\n@@ -1320,7 +1320,7 @@ impl<'a, 'tcx> Visitor<()> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                         at_outer_type: true,\n                         outer_type_is_public_path: false,\n                     };\n-                    visitor.visit_ty(&*self_, ());\n+                    visitor.visit_ty(&*self_);\n                     self_contains_private = visitor.contains_private;\n                     self_is_public_path = visitor.outer_type_is_public_path;\n                 }\n@@ -1359,16 +1359,14 @@ impl<'a, 'tcx> Visitor<()> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                         not_private_trait &&\n                         trait_or_some_public_method {\n \n-                    visit::walk_generics(self, g, ());\n+                    visit::walk_generics(self, g);\n \n                     match *trait_ref {\n                         None => {\n                             for impl_item in impl_items.iter() {\n                                 match *impl_item {\n                                     ast::MethodImplItem(method) => {\n-                                        visit::walk_method_helper(self,\n-                                                                  &*method,\n-                                                                  ())\n+                                        visit::walk_method_helper(self, &*method)\n                                     }\n                                 }\n                             }\n@@ -1386,7 +1384,7 @@ impl<'a, 'tcx> Visitor<()> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                             //\n                             // Those in 2. are warned via walk_generics and this\n                             // call here.\n-                            visit::walk_trait_ref_helper(self, tr, ())\n+                            visit::walk_trait_ref_helper(self, tr)\n                         }\n                     }\n                 } else if trait_ref.is_none() && self_is_public_path {\n@@ -1401,15 +1399,13 @@ impl<'a, 'tcx> Visitor<()> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                                         self.exported_items\n                                             .contains(&method.id) {\n                                     found_pub_static = true;\n-                                    visit::walk_method_helper(self,\n-                                                              &*method,\n-                                                              ());\n+                                    visit::walk_method_helper(self, &*method);\n                                 }\n                             }\n                         }\n                     }\n                     if found_pub_static {\n-                        visit::walk_generics(self, g, ())\n+                        visit::walk_generics(self, g)\n                     }\n                 }\n                 return\n@@ -1429,25 +1425,24 @@ impl<'a, 'tcx> Visitor<()> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n         // any `visit_ty`'s will be called on things that are in\n         // public signatures, i.e. things that we're interested in for\n         // this visitor.\n-        visit::walk_item(self, item, ());\n+        visit::walk_item(self, item);\n     }\n \n-    fn visit_foreign_item(&mut self, item: &ast::ForeignItem, _: ()) {\n+    fn visit_foreign_item(&mut self, item: &ast::ForeignItem) {\n         if self.exported_items.contains(&item.id) {\n-            visit::walk_foreign_item(self, item, ())\n+            visit::walk_foreign_item(self, item)\n         }\n     }\n \n-    fn visit_fn(&mut self,\n-                fk: &visit::FnKind, fd: &ast::FnDecl, b: &ast::Block, s: Span, id: ast::NodeId,\n-                _: ()) {\n+    fn visit_fn(&mut self, fk: &visit::FnKind, fd: &ast::FnDecl,\n+                b: &ast::Block, s: Span, id: ast::NodeId) {\n         // needs special handling for methods.\n         if self.exported_items.contains(&id) {\n-            visit::walk_fn(self, fk, fd, b, s, ());\n+            visit::walk_fn(self, fk, fd, b, s);\n         }\n     }\n \n-    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n         match t.node {\n             ast::TyPath(ref p, _, path_id) => {\n                 if self.path_is_private_type(path_id) {\n@@ -1460,19 +1455,19 @@ impl<'a, 'tcx> Visitor<()> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n             }\n             _ => {}\n         }\n-        visit::walk_ty(self, t, ())\n+        visit::walk_ty(self, t)\n     }\n \n-    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, _: ()) {\n+    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n         if self.exported_items.contains(&v.node.id) {\n-            visit::walk_variant(self, v, g, ());\n+            visit::walk_variant(self, v, g);\n         }\n     }\n \n-    fn visit_struct_field(&mut self, s: &ast::StructField, _: ()) {\n+    fn visit_struct_field(&mut self, s: &ast::StructField) {\n         match s.node.kind {\n             ast::NamedField(_, ast::Public)  => {\n-                visit::walk_struct_field(self, s, ());\n+                visit::walk_struct_field(self, s);\n             }\n             _ => {}\n         }\n@@ -1484,9 +1479,9 @@ impl<'a, 'tcx> Visitor<()> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n     // things, and neither do view_items. (Making them no-ops stops us\n     // from traversing the whole AST without having to be super\n     // careful about our `walk_...` calls above.)\n-    fn visit_view_item(&mut self, _: &ast::ViewItem, _: ()) {}\n-    fn visit_block(&mut self, _: &ast::Block, _: ()) {}\n-    fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n+    fn visit_view_item(&mut self, _: &ast::ViewItem) {}\n+    fn visit_block(&mut self, _: &ast::Block) {}\n+    fn visit_expr(&mut self, _: &ast::Expr) {}\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n@@ -1499,7 +1494,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         parents: NodeMap::new(),\n         curparent: ast::DUMMY_NODE_ID,\n     };\n-    visit::walk_crate(&mut visitor, krate, ());\n+    visit::walk_crate(&mut visitor, krate);\n \n     // Use the parent map to check the privacy of everything\n     let mut visitor = PrivacyVisitor {\n@@ -1510,15 +1505,15 @@ pub fn check_crate(tcx: &ty::ctxt,\n         external_exports: external_exports,\n         last_private_map: last_private_map,\n     };\n-    visit::walk_crate(&mut visitor, krate, ());\n+    visit::walk_crate(&mut visitor, krate);\n \n     // Sanity check to make sure that all privacy usage and controls are\n     // reasonable.\n     let mut visitor = SanePrivacyVisitor {\n         in_fn: false,\n         tcx: tcx,\n     };\n-    visit::walk_crate(&mut visitor, krate, ());\n+    visit::walk_crate(&mut visitor, krate);\n \n     tcx.sess.abort_if_errors();\n \n@@ -1535,7 +1530,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n     };\n     loop {\n         let before = visitor.exported_items.len();\n-        visit::walk_crate(&mut visitor, krate, ());\n+        visit::walk_crate(&mut visitor, krate);\n         if before == visitor.exported_items.len() {\n             break\n         }\n@@ -1549,7 +1544,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n             exported_items: &exported_items,\n             public_items: &public_items\n         };\n-        visit::walk_crate(&mut visitor, krate, ());\n+        visit::walk_crate(&mut visitor, krate);\n     }\n     return (exported_items, public_items);\n }"}, {"sha": "c27c7b3096a6d4c638800905622c4f768cdc6a06", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -101,9 +101,9 @@ struct ReachableContext<'a, 'tcx: 'a> {\n     any_library: bool,\n }\n \n-impl<'a, 'tcx> Visitor<()> for ReachableContext<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor for ReachableContext<'a, 'tcx> {\n \n-    fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n+    fn visit_expr(&mut self, expr: &ast::Expr) {\n \n         match expr.node {\n             ast::ExprPath(_) => {\n@@ -155,10 +155,10 @@ impl<'a, 'tcx> Visitor<()> for ReachableContext<'a, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_expr(self, expr, ())\n+        visit::walk_expr(self, expr)\n     }\n \n-    fn visit_item(&mut self, _item: &ast::Item, _: ()) {\n+    fn visit_item(&mut self, _item: &ast::Item) {\n         // Do not recurse into items. These items will be added to the worklist\n         // and recursed into manually if necessary.\n     }\n@@ -291,7 +291,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 match item.node {\n                     ast::ItemFn(_, _, _, _, ref search_block) => {\n                         if item_might_be_inlined(&*item) {\n-                            visit::walk_block(self, &**search_block, ())\n+                            visit::walk_block(self, &**search_block)\n                         }\n                     }\n \n@@ -303,7 +303,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                                 item.attrs.as_slice()) {\n                             self.reachable_symbols.remove(&search_item);\n                         }\n-                        visit::walk_expr(self, &**init, ());\n+                        visit::walk_expr(self, &**init);\n                     }\n \n                     // These are normal, nothing reachable about these\n@@ -327,7 +327,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         // Keep going, nothing to get exported\n                     }\n                     ast::ProvidedMethod(ref method) => {\n-                        visit::walk_block(self, &*method.pe_body(), ())\n+                        visit::walk_block(self, &*method.pe_body())\n                     }\n                 }\n             }\n@@ -336,7 +336,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     ast::MethodImplItem(method) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, &*method, did) {\n-                            visit::walk_block(self, &*method.pe_body(), ())\n+                            visit::walk_block(self, &*method.pe_body())\n                         }\n                     }\n                 }"}, {"sha": "7de8aab371effbfd43d5d2964b42bb3a0835a1ce", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 78, "deletions": 82, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -84,7 +84,6 @@ pub struct RegionMaps {\n     terminating_scopes: RefCell<HashSet<ast::NodeId>>,\n }\n \n-#[deriving(Clone)]\n pub struct Context {\n     var_parent: Option<ast::NodeId>,\n \n@@ -97,6 +96,8 @@ struct RegionResolutionVisitor<'a> {\n \n     // Generated maps:\n     region_maps: &'a RegionMaps,\n+\n+    cx: Context\n }\n \n \n@@ -370,20 +371,21 @@ impl RegionMaps {\n \n /// Records the current parent (if any) as the parent of `child_id`.\n fn record_superlifetime(visitor: &mut RegionResolutionVisitor,\n-                        cx: Context,\n                         child_id: ast::NodeId,\n                         _sp: Span) {\n-    for &parent_id in cx.parent.iter() {\n-        visitor.region_maps.record_encl_scope(child_id, parent_id);\n+    match visitor.cx.parent {\n+        Some(parent_id) => {\n+            visitor.region_maps.record_encl_scope(child_id, parent_id);\n+        }\n+        None => {}\n     }\n }\n \n /// Records the lifetime of a local variable as `cx.var_parent`\n fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n-                       cx: Context,\n                        var_id: ast::NodeId,\n                        _sp: Span) {\n-    match cx.var_parent {\n+    match visitor.cx.var_parent {\n         Some(parent_id) => {\n             visitor.region_maps.record_var_scope(var_id, parent_id);\n         }\n@@ -395,13 +397,11 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n     }\n }\n \n-fn resolve_block(visitor: &mut RegionResolutionVisitor,\n-                 blk: &ast::Block,\n-                 cx: Context) {\n+fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n     debug!(\"resolve_block(blk.id={})\", blk.id);\n \n     // Record the parent of this block.\n-    record_superlifetime(visitor, cx, blk.id, blk.span);\n+    record_superlifetime(visitor, blk.id, blk.span);\n \n     // We treat the tail expression in the block (if any) somewhat\n     // differently from the statements. The issue has to do with\n@@ -412,13 +412,13 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor,\n     //   }\n     //\n \n-    let subcx = Context {var_parent: Some(blk.id), parent: Some(blk.id)};\n-    visit::walk_block(visitor, blk, subcx);\n+    let prev_cx = visitor.cx;\n+    visitor.cx = Context {var_parent: Some(blk.id), parent: Some(blk.id)};\n+    visit::walk_block(visitor, blk);\n+    visitor.cx = prev_cx;\n }\n \n-fn resolve_arm(visitor: &mut RegionResolutionVisitor,\n-               arm: &ast::Arm,\n-               cx: Context) {\n+fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &ast::Arm) {\n     visitor.region_maps.mark_as_terminating_scope(arm.body.id);\n \n     match arm.guard {\n@@ -428,48 +428,44 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor,\n         None => { }\n     }\n \n-    visit::walk_arm(visitor, arm, cx);\n+    visit::walk_arm(visitor, arm);\n }\n \n-fn resolve_pat(visitor: &mut RegionResolutionVisitor,\n-               pat: &ast::Pat,\n-               cx: Context) {\n-    record_superlifetime(visitor, cx, pat.id, pat.span);\n+fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &ast::Pat) {\n+    record_superlifetime(visitor, pat.id, pat.span);\n \n     // If this is a binding (or maybe a binding, I'm too lazy to check\n     // the def map) then record the lifetime of that binding.\n     match pat.node {\n         ast::PatIdent(..) => {\n-            record_var_lifetime(visitor, cx, pat.id, pat.span);\n+            record_var_lifetime(visitor, pat.id, pat.span);\n         }\n         _ => { }\n     }\n \n-    visit::walk_pat(visitor, pat, cx);\n+    visit::walk_pat(visitor, pat);\n }\n \n-fn resolve_stmt(visitor: &mut RegionResolutionVisitor,\n-                stmt: &ast::Stmt,\n-                cx: Context) {\n+fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &ast::Stmt) {\n     let stmt_id = stmt_id(stmt);\n     debug!(\"resolve_stmt(stmt.id={})\", stmt_id);\n \n     visitor.region_maps.mark_as_terminating_scope(stmt_id);\n-    record_superlifetime(visitor, cx, stmt_id, stmt.span);\n+    record_superlifetime(visitor, stmt_id, stmt.span);\n \n-    let subcx = Context {parent: Some(stmt_id), ..cx};\n-    visit::walk_stmt(visitor, stmt, subcx);\n+    let prev_parent = visitor.cx.parent;\n+    visitor.cx.parent = Some(stmt_id);\n+    visit::walk_stmt(visitor, stmt);\n+    visitor.cx.parent = prev_parent;\n }\n \n-fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n-                expr: &ast::Expr,\n-                cx: Context) {\n+fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n     debug!(\"resolve_expr(expr.id={})\", expr.id);\n \n-    record_superlifetime(visitor, cx, expr.id, expr.span);\n+    record_superlifetime(visitor, expr.id, expr.span);\n \n-    let mut new_cx = cx;\n-    new_cx.parent = Some(expr.id);\n+    let prev_cx = visitor.cx;\n+    visitor.cx.parent = Some(expr.id);\n     match expr.node {\n         // Conditional or repeating scopes are always terminating\n         // scopes, meaning that temporaries cannot outlive them.\n@@ -506,11 +502,11 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n \n             // The variable parent of everything inside (most importantly, the\n             // pattern) is the body.\n-            new_cx.var_parent = Some(body.id);\n+            visitor.cx.var_parent = Some(body.id);\n         }\n \n         ast::ExprMatch(..) => {\n-            new_cx.var_parent = Some(expr.id);\n+            visitor.cx.var_parent = Some(expr.id);\n         }\n \n         ast::ExprAssignOp(..) | ast::ExprIndex(..) |\n@@ -538,17 +534,15 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n         _ => {}\n     };\n \n-\n-    visit::walk_expr(visitor, expr, new_cx);\n+    visit::walk_expr(visitor, expr);\n+    visitor.cx = prev_cx;\n }\n \n-fn resolve_local(visitor: &mut RegionResolutionVisitor,\n-                 local: &ast::Local,\n-                 cx: Context) {\n+fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     debug!(\"resolve_local(local.id={},local.init={})\",\n            local.id,local.init.is_some());\n \n-    let blk_id = match cx.var_parent {\n+    let blk_id = match visitor.cx.var_parent {\n         Some(id) => id,\n         None => {\n             visitor.sess.span_bug(\n@@ -635,7 +629,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n         None => { }\n     }\n \n-    visit::walk_local(visitor, local, cx);\n+    visit::walk_local(visitor, local);\n \n     fn is_binding_pat(pat: &ast::Pat) -> bool {\n         /*!\n@@ -793,42 +787,45 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n     }\n }\n \n-fn resolve_item(visitor: &mut RegionResolutionVisitor,\n-                item: &ast::Item,\n-                cx: Context) {\n+fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &ast::Item) {\n     // Items create a new outer block scope as far as we're concerned.\n-    let new_cx = Context {var_parent: None, parent: None, ..cx};\n-    visit::walk_item(visitor, item, new_cx);\n+    let prev_cx = visitor.cx;\n+    visitor.cx = Context {var_parent: None, parent: None};\n+    visit::walk_item(visitor, item);\n+    visitor.cx = prev_cx;\n }\n \n fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n               fk: &FnKind,\n               decl: &ast::FnDecl,\n               body: &ast::Block,\n               sp: Span,\n-              id: ast::NodeId,\n-              cx: Context) {\n+              id: ast::NodeId) {\n     debug!(\"region::resolve_fn(id={}, \\\n                                span={:?}, \\\n                                body.id={}, \\\n                                cx.parent={})\",\n            id,\n            visitor.sess.codemap().span_to_string(sp),\n            body.id,\n-           cx.parent);\n+           visitor.cx.parent);\n \n     visitor.region_maps.mark_as_terminating_scope(body.id);\n \n+    let outer_cx = visitor.cx;\n+\n     // The arguments and `self` are parented to the body of the fn.\n-    let decl_cx = Context {parent: Some(body.id),\n-                           var_parent: Some(body.id)};\n-    visit::walk_fn_decl(visitor, decl, decl_cx);\n+    visitor.cx = Context { parent: Some(body.id),\n+                           var_parent: Some(body.id) };\n+    visit::walk_fn_decl(visitor, decl);\n \n     // The body of the fn itself is either a root scope (top-level fn)\n     // or it continues with the inherited scope (closures).\n-    let body_cx = match *fk {\n+    match *fk {\n         visit::FkItemFn(..) | visit::FkMethod(..) => {\n-            Context {parent: None, var_parent: None, ..cx}\n+            visitor.cx = Context { parent: None, var_parent: None };\n+            visitor.visit_block(body);\n+            visitor.cx = outer_cx;\n         }\n         visit::FkFnBlock(..) => {\n             // FIXME(#3696) -- at present we are place the closure body\n@@ -838,40 +835,40 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n             // but the correct fix is a bit subtle, and I am also not sure\n             // that the present approach is unsound -- it may not permit\n             // any illegal programs. See issue for more details.\n-            cx\n+            visitor.cx = outer_cx;\n+            visitor.visit_block(body);\n         }\n-    };\n-    visitor.visit_block(body, body_cx);\n+    }\n }\n \n-impl<'a> Visitor<Context> for RegionResolutionVisitor<'a> {\n+impl<'a> Visitor for RegionResolutionVisitor<'a> {\n \n-    fn visit_block(&mut self, b: &Block, cx: Context) {\n-        resolve_block(self, b, cx);\n+    fn visit_block(&mut self, b: &Block) {\n+        resolve_block(self, b);\n     }\n \n-    fn visit_item(&mut self, i: &Item, cx: Context) {\n-        resolve_item(self, i, cx);\n+    fn visit_item(&mut self, i: &Item) {\n+        resolve_item(self, i);\n     }\n \n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl,\n-                b: &Block, s: Span, n: NodeId, cx: Context) {\n-        resolve_fn(self, fk, fd, b, s, n, cx);\n+                b: &Block, s: Span, n: NodeId) {\n+        resolve_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_arm(&mut self, a: &Arm, cx: Context) {\n-        resolve_arm(self, a, cx);\n+    fn visit_arm(&mut self, a: &Arm) {\n+        resolve_arm(self, a);\n     }\n-    fn visit_pat(&mut self, p: &Pat, cx: Context) {\n-        resolve_pat(self, p, cx);\n+    fn visit_pat(&mut self, p: &Pat) {\n+        resolve_pat(self, p);\n     }\n-    fn visit_stmt(&mut self, s: &Stmt, cx: Context) {\n-        resolve_stmt(self, s, cx);\n+    fn visit_stmt(&mut self, s: &Stmt) {\n+        resolve_stmt(self, s);\n     }\n-    fn visit_expr(&mut self, ex: &Expr, cx: Context) {\n-        resolve_expr(self, ex, cx);\n+    fn visit_expr(&mut self, ex: &Expr) {\n+        resolve_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l: &Local, cx: Context) {\n-        resolve_local(self, l, cx);\n+    fn visit_local(&mut self, l: &Local) {\n+        resolve_local(self, l);\n     }\n }\n \n@@ -886,23 +883,22 @@ pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n     {\n         let mut visitor = RegionResolutionVisitor {\n             sess: sess,\n-            region_maps: &maps\n+            region_maps: &maps,\n+            cx: Context { parent: None, var_parent: None }\n         };\n-        let cx = Context { parent: None, var_parent: None };\n-        visit::walk_crate(&mut visitor, krate, cx);\n+        visit::walk_crate(&mut visitor, krate);\n     }\n     return maps;\n }\n \n pub fn resolve_inlined_item(sess: &Session,\n                             region_maps: &RegionMaps,\n                             item: &ast::InlinedItem) {\n-    let cx = Context {parent: None,\n-                      var_parent: None};\n     let mut visitor = RegionResolutionVisitor {\n         sess: sess,\n         region_maps: region_maps,\n+        cx: Context { parent: None, var_parent: None }\n     };\n-    visit::walk_inlined_item(&mut visitor, item, cx);\n+    visit::walk_inlined_item(&mut visitor, item);\n }\n "}, {"sha": "b79db38e12964f41fac1fe9f890b8f138013f61c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 54, "deletions": 47, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -185,23 +185,23 @@ enum NameDefinition {\n     ImportNameDefinition(Def, LastPrivate) //< The name identifies an import.\n }\n \n-impl<'a> Visitor<()> for Resolver<'a> {\n-    fn visit_item(&mut self, item: &Item, _: ()) {\n+impl<'a> Visitor for Resolver<'a> {\n+    fn visit_item(&mut self, item: &Item) {\n         self.resolve_item(item);\n     }\n-    fn visit_arm(&mut self, arm: &Arm, _: ()) {\n+    fn visit_arm(&mut self, arm: &Arm) {\n         self.resolve_arm(arm);\n     }\n-    fn visit_block(&mut self, block: &Block, _: ()) {\n+    fn visit_block(&mut self, block: &Block) {\n         self.resolve_block(block);\n     }\n-    fn visit_expr(&mut self, expr: &Expr, _: ()) {\n+    fn visit_expr(&mut self, expr: &Expr) {\n         self.resolve_expr(expr);\n     }\n-    fn visit_local(&mut self, local: &Local, _: ()) {\n+    fn visit_local(&mut self, local: &Local) {\n         self.resolve_local(local);\n     }\n-    fn visit_ty(&mut self, ty: &Ty, _: ()) {\n+    fn visit_ty(&mut self, ty: &Ty) {\n         self.resolve_type(ty);\n     }\n }\n@@ -903,32 +903,40 @@ struct Resolver<'a> {\n \n struct BuildReducedGraphVisitor<'a, 'b:'a> {\n     resolver: &'a mut Resolver<'b>,\n+    parent: ReducedGraphParent\n }\n \n-impl<'a, 'b> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a, 'b> {\n+impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n \n-    fn visit_item(&mut self, item: &Item, context: ReducedGraphParent) {\n-        let p = self.resolver.build_reduced_graph_for_item(item, context);\n-        visit::walk_item(self, item, p);\n+    fn visit_item(&mut self, item: &Item) {\n+        let p = self.resolver.build_reduced_graph_for_item(item, self.parent.clone());\n+        let old_parent = replace(&mut self.parent, p);\n+        visit::walk_item(self, item);\n+        self.parent = old_parent;\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem,\n-                          context: ReducedGraphParent) {\n+    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n+        let parent = self.parent.clone();\n         self.resolver.build_reduced_graph_for_foreign_item(foreign_item,\n-                                                           context.clone(),\n+                                                           parent.clone(),\n                                                            |r| {\n-            let mut v = BuildReducedGraphVisitor{ resolver: r };\n-            visit::walk_foreign_item(&mut v, foreign_item, context.clone());\n+            let mut v = BuildReducedGraphVisitor {\n+                resolver: r,\n+                parent: parent.clone()\n+            };\n+            visit::walk_foreign_item(&mut v, foreign_item);\n         })\n     }\n \n-    fn visit_view_item(&mut self, view_item: &ViewItem, context: ReducedGraphParent) {\n-        self.resolver.build_reduced_graph_for_view_item(view_item, context);\n+    fn visit_view_item(&mut self, view_item: &ViewItem) {\n+        self.resolver.build_reduced_graph_for_view_item(view_item, self.parent.clone());\n     }\n \n-    fn visit_block(&mut self, block: &Block, context: ReducedGraphParent) {\n-        let np = self.resolver.build_reduced_graph_for_block(block, context);\n-        visit::walk_block(self, block, np);\n+    fn visit_block(&mut self, block: &Block) {\n+        let np = self.resolver.build_reduced_graph_for_block(block, self.parent.clone());\n+        let old_parent = replace(&mut self.parent, np);\n+        visit::walk_block(self, block);\n+        self.parent = old_parent;\n     }\n \n }\n@@ -937,10 +945,10 @@ struct UnusedImportCheckVisitor<'a, 'b:'a> {\n     resolver: &'a mut Resolver<'b>\n }\n \n-impl<'a, 'b> Visitor<()> for UnusedImportCheckVisitor<'a, 'b> {\n-    fn visit_view_item(&mut self, vi: &ViewItem, _: ()) {\n+impl<'a, 'b> Visitor for UnusedImportCheckVisitor<'a, 'b> {\n+    fn visit_view_item(&mut self, vi: &ViewItem) {\n         self.resolver.check_for_item_unused_imports(vi);\n-        visit::walk_view_item(self, vi, ());\n+        visit::walk_view_item(self, vi);\n     }\n }\n \n@@ -1019,11 +1027,12 @@ impl<'a> Resolver<'a> {\n \n     /// Constructs the reduced graph for the entire crate.\n     fn build_reduced_graph(&mut self, krate: &ast::Crate) {\n-        let initial_parent =\n-            ModuleReducedGraphParent(self.graph_root.get_module());\n-\n-        let mut visitor = BuildReducedGraphVisitor { resolver: self, };\n-        visit::walk_crate(&mut visitor, krate, initial_parent);\n+        let parent = ModuleReducedGraphParent(self.graph_root.get_module());\n+        let mut visitor = BuildReducedGraphVisitor {\n+            resolver: self,\n+            parent: parent\n+        };\n+        visit::walk_crate(&mut visitor, krate);\n     }\n \n     /**\n@@ -3889,7 +3898,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_crate(&mut self, krate: &ast::Crate) {\n         debug!(\"(resolving crate) starting\");\n \n-        visit::walk_crate(self, krate, ());\n+        visit::walk_crate(self, krate);\n     }\n \n     fn resolve_item(&mut self, item: &Item) {\n@@ -3921,7 +3930,7 @@ impl<'a> Resolver<'a> {\n                                              |this| {\n                     this.resolve_type_parameters(&generics.ty_params);\n                     this.resolve_where_clause(&generics.where_clause);\n-                    visit::walk_item(this, item, ());\n+                    visit::walk_item(this, item);\n                 });\n             }\n \n@@ -3932,7 +3941,7 @@ impl<'a> Resolver<'a> {\n                                                                ItemRibKind),\n                                              |this| {\n                     this.resolve_type_parameters(&generics.ty_params);\n-                    visit::walk_item(this, item, ());\n+                    visit::walk_item(this, item);\n                 });\n             }\n \n@@ -4048,13 +4057,11 @@ impl<'a> Resolver<'a> {\n                                         generics, FnSpace, foreign_item.id,\n                                         ItemRibKind),\n                                     |this| visit::walk_foreign_item(this,\n-                                                                &**foreign_item,\n-                                                                ()));\n+                                                                    &**foreign_item));\n                             }\n                             ForeignItemStatic(..) => {\n                                 visit::walk_foreign_item(this,\n-                                                         &**foreign_item,\n-                                                         ());\n+                                                         &**foreign_item);\n                             }\n                         }\n                     }\n@@ -4074,7 +4081,7 @@ impl<'a> Resolver<'a> {\n \n             ItemStatic(..) => {\n                 self.with_constant_rib(|this| {\n-                    visit::walk_item(this, item, ());\n+                    visit::walk_item(this, item);\n                 });\n             }\n \n@@ -4489,7 +4496,7 @@ impl<'a> Resolver<'a> {\n                       _name: Ident, id: NodeId) {\n         // Write the implementations in scope into the module metadata.\n         debug!(\"(resolving module) resolving module ID {}\", id);\n-        visit::walk_mod(self, module, ());\n+        visit::walk_mod(self, module);\n     }\n \n     fn resolve_local(&mut self, local: &Local) {\n@@ -4586,7 +4593,7 @@ impl<'a> Resolver<'a> {\n         // pat_idents are variants\n         self.check_consistent_bindings(arm);\n \n-        visit::walk_expr_opt(self, arm.guard, ());\n+        visit::walk_expr_opt(self, arm.guard);\n         self.resolve_expr(&*arm.body);\n \n         self.value_ribs.borrow_mut().pop();\n@@ -4608,7 +4615,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Descend into the block.\n-        visit::walk_block(self, block, ());\n+        visit::walk_block(self, block);\n \n         // Move back up.\n         self.current_module = orig_module;\n@@ -4702,12 +4709,12 @@ impl<'a> Resolver<'a> {\n             TyClosure(c) | TyProc(c) => {\n                 self.resolve_type_parameter_bounds(ty.id, &c.bounds,\n                                                    TraitBoundingTypeParameter);\n-                visit::walk_ty(self, ty, ());\n+                visit::walk_ty(self, ty);\n             }\n \n             _ => {\n                 // Just resolve embedded types.\n-                visit::walk_ty(self, ty, ());\n+                visit::walk_ty(self, ty);\n             }\n         }\n     }\n@@ -5592,7 +5599,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n \n-                visit::walk_expr(self, expr, ());\n+                visit::walk_expr(self, expr);\n             }\n \n             ExprFnBlock(_, fn_decl, block) |\n@@ -5618,7 +5625,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n \n-                visit::walk_expr(self, expr, ());\n+                visit::walk_expr(self, expr);\n             }\n \n             ExprLoop(_, Some(label)) | ExprWhile(_, _, Some(label)) => {\n@@ -5633,7 +5640,7 @@ impl<'a> Resolver<'a> {\n                         rib.bindings.borrow_mut().insert(renamed, def_like);\n                     }\n \n-                    visit::walk_expr(this, expr, ());\n+                    visit::walk_expr(this, expr);\n                 })\n             }\n \n@@ -5697,7 +5704,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             _ => {\n-                visit::walk_expr(self, expr, ());\n+                visit::walk_expr(self, expr);\n             }\n         }\n     }\n@@ -5847,7 +5854,7 @@ impl<'a> Resolver<'a> {\n \n     fn check_for_unused_imports(&mut self, krate: &ast::Crate) {\n         let mut visitor = UnusedImportCheckVisitor{ resolver: self };\n-        visit::walk_crate(&mut visitor, krate, ());\n+        visit::walk_crate(&mut visitor, krate);\n     }\n \n     fn check_for_item_unused_imports(&mut self, vi: &ViewItem) {"}, {"sha": "628174b0f4e209f75d4f18a40cf84c28dfb2ff3a", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 73, "deletions": 85, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -52,7 +52,8 @@ fn lifetime_show(lt_name: &ast::Name) -> token::InternedString {\n \n struct LifetimeContext<'a> {\n     sess: &'a Session,\n-    named_region_map: NamedRegionMap,\n+    named_region_map: &'a mut NamedRegionMap,\n+    scope: Scope<'a>\n }\n \n enum ScopeChain<'a> {\n@@ -70,117 +71,107 @@ enum ScopeChain<'a> {\n \n type Scope<'a> = &'a ScopeChain<'a>;\n \n+static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n+\n pub fn krate(sess: &Session, krate: &ast::Crate) -> NamedRegionMap {\n-    let mut ctxt = LifetimeContext {\n+    let mut named_region_map = NodeMap::new();\n+    visit::walk_crate(&mut LifetimeContext {\n         sess: sess,\n-        named_region_map: NodeMap::new()\n-    };\n-    visit::walk_crate(&mut ctxt, krate, &RootScope);\n+        named_region_map: &mut named_region_map,\n+        scope: &ROOT_SCOPE\n+    }, krate);\n     sess.abort_if_errors();\n-    ctxt.named_region_map\n+    named_region_map\n }\n \n-impl<'a, 'b> Visitor<Scope<'a>> for LifetimeContext<'b> {\n-    fn visit_item(&mut self,\n-                  item: &ast::Item,\n-                  _: Scope<'a>) {\n-        let root = RootScope;\n-        let scope = match item.node {\n+impl<'a> Visitor for LifetimeContext<'a> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        let lifetimes = match item.node {\n             ast::ItemFn(..) | // fn lifetimes get added in visit_fn below\n             ast::ItemMod(..) |\n             ast::ItemMac(..) |\n             ast::ItemForeignMod(..) |\n             ast::ItemStatic(..) => {\n-                RootScope\n+                self.with(|_, f| f(RootScope), |v| visit::walk_item(v, item));\n+                return;\n             }\n             ast::ItemTy(_, ref generics) |\n             ast::ItemEnum(_, ref generics) |\n             ast::ItemStruct(_, ref generics) |\n             ast::ItemImpl(ref generics, _, _, _) |\n-            ast::ItemTrait(ref generics, _, _, _) => {\n-                let scope: ScopeChain =\n-                    EarlyScope(subst::TypeSpace, &generics.lifetimes, &root);\n-                self.check_lifetime_defs(&generics.lifetimes, &scope);\n-                scope\n-            }\n+            ast::ItemTrait(ref generics, _, _, _) => &generics.lifetimes\n         };\n-        debug!(\"entering scope {:?}\", scope);\n-        visit::walk_item(self, item, &scope);\n-        debug!(\"exiting scope {:?}\", scope);\n+\n+        self.with(|_, f| f(EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE)), |v| {\n+            debug!(\"entering scope {:?}\", v.scope);\n+            v.check_lifetime_defs(lifetimes);\n+            visit::walk_item(v, item);\n+            debug!(\"exiting scope {:?}\", v.scope);\n+        });\n     }\n \n     fn visit_fn(&mut self, fk: &visit::FnKind, fd: &ast::FnDecl,\n-                b: &ast::Block, s: Span, n: ast::NodeId,\n-                scope: Scope<'a>) {\n+                b: &ast::Block, s: Span, n: ast::NodeId) {\n         match *fk {\n             visit::FkItemFn(_, generics, _, _) |\n             visit::FkMethod(_, generics, _) => {\n-                self.visit_fn_decl(\n-                    n, generics, scope,\n-                    |this, scope1| visit::walk_fn(this, fk, fd, b, s, scope1))\n+                self.visit_fn_decl(n, generics, |v| visit::walk_fn(v, fk, fd, b, s))\n             }\n             visit::FkFnBlock(..) => {\n-                visit::walk_fn(self, fk, fd, b, s, scope)\n+                visit::walk_fn(self, fk, fd, b, s)\n             }\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: &ast::Ty, scope: Scope<'a>) {\n-        match ty.node {\n-            ast::TyClosure(c) | ast::TyProc(c) => {\n-                push_fn_scope(self, ty, scope, &c.lifetimes);\n-            }\n-            ast::TyBareFn(c) => push_fn_scope(self, ty, scope, &c.lifetimes),\n-            _ => visit::walk_ty(self, ty, scope),\n-        }\n+    fn visit_ty(&mut self, ty: &ast::Ty) {\n+        let lifetimes = match ty.node {\n+            ast::TyClosure(ref c) | ast::TyProc(ref c) => &c.lifetimes,\n+            ast::TyBareFn(ref c) => &c.lifetimes,\n+            _ => return visit::walk_ty(self, ty)\n+        };\n \n-        fn push_fn_scope(this: &mut LifetimeContext,\n-                         ty: &ast::Ty,\n-                         scope: Scope,\n-                         lifetimes: &Vec<ast::LifetimeDef>) {\n-            let scope1: ScopeChain = LateScope(ty.id, lifetimes, scope);\n-            this.check_lifetime_defs(lifetimes, &scope1);\n+        self.with(|scope, f| f(LateScope(ty.id, lifetimes, scope)), |v| {\n+            v.check_lifetime_defs(lifetimes);\n             debug!(\"pushing fn scope id={} due to type\", ty.id);\n-            visit::walk_ty(this, ty, &scope1);\n+            visit::walk_ty(v, ty);\n             debug!(\"popping fn scope id={} due to type\", ty.id);\n-        }\n+        });\n     }\n \n-    fn visit_ty_method(&mut self,\n-                       m: &ast::TypeMethod,\n-                       scope: Scope<'a>) {\n-        self.visit_fn_decl(\n-            m.id, &m.generics, scope,\n-            |this, scope1| visit::walk_ty_method(this, m, scope1))\n+    fn visit_ty_method(&mut self, m: &ast::TypeMethod) {\n+        self.visit_fn_decl(m.id, &m.generics, |v| visit::walk_ty_method(v, m))\n     }\n \n-    fn visit_block(&mut self,\n-                   b: &ast::Block,\n-                   scope: Scope<'a>) {\n-        let scope1 = BlockScope(b.id, scope);\n+    fn visit_block(&mut self, b: &ast::Block) {\n         debug!(\"pushing block scope {}\", b.id);\n-        visit::walk_block(self, b, &scope1);\n+        self.with(|scope, f| f(BlockScope(b.id, scope)), |v| visit::walk_block(v, b));\n         debug!(\"popping block scope {}\", b.id);\n     }\n \n-    fn visit_lifetime_ref(&mut self,\n-                          lifetime_ref: &ast::Lifetime,\n-                          scope: Scope<'a>) {\n+    fn visit_lifetime_ref(&mut self, lifetime_ref: &ast::Lifetime) {\n         if lifetime_ref.name == special_idents::static_lifetime.name {\n             self.insert_lifetime(lifetime_ref, DefStaticRegion);\n             return;\n         }\n-        self.resolve_lifetime_ref(lifetime_ref, scope);\n+        self.resolve_lifetime_ref(lifetime_ref);\n     }\n }\n \n impl<'a> LifetimeContext<'a> {\n+    fn with(&mut self, wrap_scope: |Scope, |ScopeChain||, f: |&mut LifetimeContext|) {\n+        let LifetimeContext { sess, ref mut named_region_map, scope} = *self;\n+        wrap_scope(scope, |scope1| f(&mut LifetimeContext {\n+            sess: sess,\n+            named_region_map: *named_region_map,\n+            scope: &scope1\n+        }))\n+    }\n+\n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n     fn visit_fn_decl(&mut self,\n                      n: ast::NodeId,\n                      generics: &ast::Generics,\n-                     scope: Scope,\n-                     walk: |&mut LifetimeContext, Scope|) {\n+                     walk: |&mut LifetimeContext|) {\n         /*!\n          * Handles visiting fns and methods. These are a bit\n          * complicated because we must distinguish early- vs late-bound\n@@ -210,33 +201,35 @@ impl<'a> LifetimeContext<'a> {\n                referenced_idents={:?}\",\n                n,\n                referenced_idents.iter().map(lifetime_show).collect::<Vec<token::InternedString>>());\n+        let lifetimes = &generics.lifetimes;\n         if referenced_idents.is_empty() {\n-            let scope1: ScopeChain = LateScope(n, &generics.lifetimes, scope);\n-            self.check_lifetime_defs(&generics.lifetimes, &scope1);\n-            walk(self, &scope1);\n+            self.with(|scope, f| f(LateScope(n, lifetimes, scope)), |v| {\n+                v.check_lifetime_defs(lifetimes);\n+                walk(v);\n+            });\n         } else {\n-            let (early, late) = generics.lifetimes.clone().partition(\n+            let (early, late) = lifetimes.clone().partition(\n                 |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n \n-            let scope1 = EarlyScope(subst::FnSpace, &early, scope);\n-            let scope2: ScopeChain = LateScope(n, &late, &scope1);\n-            self.check_lifetime_defs(&generics.lifetimes, &scope2);\n-            walk(self, &scope2);\n+            self.with(|scope, f| f(EarlyScope(subst::FnSpace, &early, scope)), |v| {\n+                v.with(|scope1, f| f(LateScope(n, &late, scope1)), |v| {\n+                    v.check_lifetime_defs(lifetimes);\n+                    walk(v);\n+                });\n+            });\n         }\n         debug!(\"popping fn scope id={} due to fn item/method\", n);\n     }\n \n-    fn resolve_lifetime_ref(&mut self,\n-                            lifetime_ref: &ast::Lifetime,\n-                            scope: Scope) {\n+    fn resolve_lifetime_ref(&mut self, lifetime_ref: &ast::Lifetime) {\n         // Walk up the scope chain, tracking the number of fn scopes\n         // that we pass through, until we find a lifetime with the\n         // given name or we run out of scopes. If we encounter a code\n         // block, then the lifetime is not bound but free, so switch\n         // over to `resolve_free_lifetime_ref()` to complete the\n         // search.\n         let mut depth = 0;\n-        let mut scope = scope;\n+        let mut scope = self.scope;\n         loop {\n             match *scope {\n                 BlockScope(id, s) => {\n@@ -326,17 +319,14 @@ impl<'a> LifetimeContext<'a> {\n \n     }\n \n-    fn unresolved_lifetime_ref(&self,\n-                               lifetime_ref: &ast::Lifetime) {\n+    fn unresolved_lifetime_ref(&self, lifetime_ref: &ast::Lifetime) {\n         self.sess.span_err(\n             lifetime_ref.span,\n             format!(\"use of undeclared lifetime name `{}`\",\n                     token::get_name(lifetime_ref.name)).as_slice());\n     }\n \n-    fn check_lifetime_defs<'b>(&mut self,\n-                               lifetimes: &Vec<ast::LifetimeDef>,\n-                               scope: Scope<'b>) {\n+    fn check_lifetime_defs(&mut self, lifetimes: &Vec<ast::LifetimeDef>) {\n         for i in range(0, lifetimes.len()) {\n             let lifetime_i = lifetimes.get(i);\n \n@@ -365,7 +355,7 @@ impl<'a> LifetimeContext<'a> {\n             }\n \n             for bound in lifetime_i.bounds.iter() {\n-                self.resolve_lifetime_ref(bound, scope);\n+                self.resolve_lifetime_ref(bound);\n             }\n         }\n     }\n@@ -434,10 +424,10 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n             FreeLifetimeCollector { early_bound: &mut early_bound,\n                                     late_bound: &mut late_bound };\n         for ty_param in generics.ty_params.iter() {\n-            visit::walk_ty_param_bounds(&mut collector, &ty_param.bounds, ());\n+            visit::walk_ty_param_bounds(&mut collector, &ty_param.bounds);\n         }\n         for predicate in generics.where_clause.predicates.iter() {\n-            visit::walk_ty_param_bounds(&mut collector, &predicate.bounds, ());\n+            visit::walk_ty_param_bounds(&mut collector, &predicate.bounds);\n         }\n     }\n \n@@ -460,10 +450,8 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n         late_bound: &'a mut Vec<ast::Name>,\n     }\n \n-    impl<'a> Visitor<()> for FreeLifetimeCollector<'a> {\n-        fn visit_lifetime_ref(&mut self,\n-                              lifetime_ref: &ast::Lifetime,\n-                              _: ()) {\n+    impl<'a> Visitor for FreeLifetimeCollector<'a> {\n+        fn visit_lifetime_ref(&mut self, lifetime_ref: &ast::Lifetime) {\n             shuffle(self.early_bound, self.late_bound,\n                     lifetime_ref.name);\n         }"}, {"sha": "d7be7af3d07fa9c2ada5c3c561cc3bdad9070ece", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 162, "deletions": 181, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -83,9 +83,18 @@ struct DxrVisitor<'l, 'tcx: 'l> {\n \n     span: SpanUtils<'l>,\n     fmt: FmtStrs<'l>,\n+\n+    cur_scope: NodeId\n }\n \n impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n+    fn nest(&mut self, scope_id: NodeId, f: |&mut DxrVisitor<'l, 'tcx>|) {\n+        let parent_scope = self.cur_scope;\n+        self.cur_scope = scope_id;\n+        f(self);\n+        self.cur_scope = parent_scope;\n+    }\n+\n     fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n         // the current crate\n         self.fmt.crate_str(krate.span, name);\n@@ -136,19 +145,19 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         result\n     }\n \n-    fn write_sub_paths(&mut self, path: &ast::Path, scope_id: NodeId) {\n+    fn write_sub_paths(&mut self, path: &ast::Path) {\n         let sub_paths = self.process_path_prefixes(path);\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n                                      qualname.as_slice(),\n-                                     scope_id);\n+                                     self.cur_scope);\n         }\n     }\n \n     // As write_sub_paths, but does not process the last ident in the path (assuming it\n     // will be processed elsewhere).\n-    fn write_sub_paths_truncated(&mut self, path: &ast::Path, scope_id: NodeId) {\n+    fn write_sub_paths_truncated(&mut self, path: &ast::Path) {\n         let sub_paths = self.process_path_prefixes(path);\n         let len = sub_paths.len();\n         if len <= 1 {\n@@ -160,13 +169,13 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n                                      qualname.as_slice(),\n-                                     scope_id);\n+                                     self.cur_scope);\n         }\n     }\n \n     // As write_sub_paths, but expects a path of the form module_path::trait::method\n     // Where trait could actually be a struct too.\n-    fn write_sub_path_trait_truncated(&mut self, path: &ast::Path, scope_id: NodeId) {\n+    fn write_sub_path_trait_truncated(&mut self, path: &ast::Path) {\n         let sub_paths = self.process_path_prefixes(path);\n         let len = sub_paths.len();\n         if len <= 1 {\n@@ -189,7 +198,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n                                      qualname.as_slice(),\n-                                     scope_id);\n+                                     self.cur_scope);\n         }\n     }\n \n@@ -243,11 +252,11 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_formals(&mut self, formals: &Vec<ast::Arg>, qualname: &str, e:DxrVisitorEnv) {\n+    fn process_formals(&mut self, formals: &Vec<ast::Arg>, qualname: &str) {\n         for arg in formals.iter() {\n             assert!(self.collected_paths.len() == 0 && !self.collecting);\n             self.collecting = true;\n-            self.visit_pat(&*arg.pat, e);\n+            self.visit_pat(&*arg.pat);\n             self.collecting = false;\n             let span_utils = self.span;\n             for &(id, ref p, _, _) in self.collected_paths.iter() {\n@@ -266,7 +275,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_method(&mut self, method: &ast::Method, e:DxrVisitorEnv) {\n+    fn process_method(&mut self, method: &ast::Method) {\n         if generated_code(method.span) {\n             return;\n         }\n@@ -361,27 +370,24 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             decl_id,\n                             scope_id);\n \n-        self.process_formals(&method.pe_fn_decl().inputs, qualname, e);\n+        self.process_formals(&method.pe_fn_decl().inputs, qualname);\n \n         // walk arg and return types\n         for arg in method.pe_fn_decl().inputs.iter() {\n-            self.visit_ty(&*arg.ty, e);\n+            self.visit_ty(&*arg.ty);\n         }\n-        self.visit_ty(&*method.pe_fn_decl().output, e);\n+        self.visit_ty(&*method.pe_fn_decl().output);\n         // walk the fn body\n-        self.visit_block(&*method.pe_body(),\n-                         DxrVisitorEnv::new_nested(method.id));\n+        self.nest(method.id, |v| v.visit_block(&*method.pe_body()));\n \n         self.process_generic_params(method.pe_generics(),\n                                     method.span,\n                                     qualname,\n-                                    method.id,\n-                                    e);\n+                                    method.id);\n     }\n \n     fn process_trait_ref(&mut self,\n                          trait_ref: &ast::TraitRef,\n-                         e: DxrVisitorEnv,\n                          impl_id: Option<NodeId>) {\n         match self.lookup_type_ref(trait_ref.ref_id) {\n             Some(id) => {\n@@ -390,16 +396,16 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                  trait_ref.path.span,\n                                  sub_span,\n                                  id,\n-                                 e.cur_scope);\n+                                 self.cur_scope);\n                 match impl_id {\n                     Some(impl_id) => self.fmt.impl_str(trait_ref.path.span,\n                                                        sub_span,\n                                                        impl_id,\n                                                        id,\n-                                                       e.cur_scope),\n+                                                       self.cur_scope),\n                     None => (),\n                 }\n-                visit::walk_path(self, &trait_ref.path, e);\n+                visit::walk_path(self, &trait_ref.path);\n             },\n             None => ()\n         }\n@@ -436,8 +442,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     fn process_generic_params(&mut self, generics:&ast::Generics,\n                               full_span: Span,\n                               prefix: &str,\n-                              id: NodeId,\n-                              e: DxrVisitorEnv) {\n+                              id: NodeId) {\n         // We can't only use visit_generics since we don't have spans for param\n         // bindings, so we reparse the full_span to get those sub spans.\n         // However full span is the entire enum/fn/struct block, so we only want\n@@ -456,12 +461,11 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                  name.as_slice(),\n                                  \"\");\n         }\n-        self.visit_generics(generics, e);\n+        self.visit_generics(generics);\n     }\n \n     fn process_fn(&mut self,\n                   item: &ast::Item,\n-                  e: DxrVisitorEnv,\n                   decl: ast::P<ast::FnDecl>,\n                   ty_params: &ast::Generics,\n                   body: ast::P<ast::Block>) {\n@@ -472,25 +476,24 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         sub_span,\n                         item.id,\n                         qualname.as_slice(),\n-                        e.cur_scope);\n+                        self.cur_scope);\n \n-        self.process_formals(&decl.inputs, qualname.as_slice(), e);\n+        self.process_formals(&decl.inputs, qualname.as_slice());\n \n         // walk arg and return types\n         for arg in decl.inputs.iter() {\n-            self.visit_ty(&*arg.ty, e);\n+            self.visit_ty(&*arg.ty);\n         }\n-        self.visit_ty(&*decl.output, e);\n+        self.visit_ty(&*decl.output);\n \n         // walk the body\n-        self.visit_block(&*body, DxrVisitorEnv::new_nested(item.id));\n+        self.nest(item.id, |v| v.visit_block(&*body));\n \n-        self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id, e);\n+        self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n     }\n \n     fn process_static(&mut self,\n                       item: &ast::Item,\n-                      e: DxrVisitorEnv,\n                       typ: ast::P<ast::Ty>,\n                       mt: ast::Mutability,\n                       expr: &ast::Expr)\n@@ -511,16 +514,15 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             qualname.as_slice(),\n                             value.as_slice(),\n                             ty_to_string(&*typ).as_slice(),\n-                            e.cur_scope);\n+                            self.cur_scope);\n \n         // walk type and init value\n-        self.visit_ty(&*typ, e);\n-        self.visit_expr(expr, e);\n+        self.visit_ty(&*typ);\n+        self.visit_expr(expr);\n     }\n \n     fn process_struct(&mut self,\n                       item: &ast::Item,\n-                      e: DxrVisitorEnv,\n                       def: &ast::StructDef,\n                       ty_params: &ast::Generics) {\n         let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n@@ -535,20 +537,19 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             item.id,\n                             ctor_id,\n                             qualname.as_slice(),\n-                            e.cur_scope);\n+                            self.cur_scope);\n \n         // fields\n         for field in def.fields.iter() {\n             self.process_struct_field_def(field, qualname.as_slice(), item.id);\n-            self.visit_ty(&*field.node.ty, e);\n+            self.visit_ty(&*field.node.ty);\n         }\n \n-        self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id, e);\n+        self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n     }\n \n     fn process_enum(&mut self,\n                     item: &ast::Item,\n-                    e: DxrVisitorEnv,\n                     enum_definition: &ast::EnumDef,\n                     ty_params: &ast::Generics) {\n         let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n@@ -557,7 +558,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                 Some(sub_span),\n                                                 item.id,\n                                                 qualname.as_slice(),\n-                                                e.cur_scope),\n+                                                self.cur_scope),\n             None => self.sess.span_bug(item.span,\n                                        format!(\"Could not find subspan for enum {}\",\n                                                qualname).as_slice()),\n@@ -578,7 +579,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                val.as_slice(),\n                                                item.id);\n                     for arg in args.iter() {\n-                        self.visit_ty(&*arg.ty, e);\n+                        self.visit_ty(&*arg.ty);\n                     }\n                 }\n                 ast::StructVariantKind(ref struct_def) => {\n@@ -597,18 +598,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n                     for field in struct_def.fields.iter() {\n                         self.process_struct_field_def(field, qualname.as_slice(), variant.node.id);\n-                        self.visit_ty(&*field.node.ty, e);\n+                        self.visit_ty(&*field.node.ty);\n                     }\n                 }\n             }\n         }\n \n-        self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id, e);\n+        self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n     }\n \n     fn process_impl(&mut self,\n                     item: &ast::Item,\n-                    e: DxrVisitorEnv,\n                     type_parameters: &ast::Generics,\n                     trait_ref: &Option<ast::TraitRef>,\n                     typ: ast::P<ast::Ty>,\n@@ -622,37 +622,36 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                          path.span,\n                                          sub_span,\n                                          id,\n-                                         e.cur_scope);\n+                                         self.cur_scope);\n                         self.fmt.impl_str(path.span,\n                                           sub_span,\n                                           item.id,\n                                           id,\n-                                          e.cur_scope);\n+                                          self.cur_scope);\n                     },\n                     None => ()\n                 }\n             },\n-            _ => self.visit_ty(&*typ, e),\n+            _ => self.visit_ty(&*typ),\n         }\n \n         match *trait_ref {\n-            Some(ref trait_ref) => self.process_trait_ref(trait_ref, e, Some(item.id)),\n+            Some(ref trait_ref) => self.process_trait_ref(trait_ref, Some(item.id)),\n             None => (),\n         }\n \n-        self.process_generic_params(type_parameters, item.span, \"\", item.id, e);\n+        self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items.iter() {\n             match *impl_item {\n                 ast::MethodImplItem(method) => {\n-                    visit::walk_method_helper(self, &*method, e)\n+                    visit::walk_method_helper(self, &*method)\n                 }\n             }\n         }\n     }\n \n     fn process_trait(&mut self,\n                      item: &ast::Item,\n-                     e: DxrVisitorEnv,\n                      generics: &ast::Generics,\n                      trait_refs: &OwnedSlice<ast::TyParamBound>,\n                      methods: &Vec<ast::TraitItem>) {\n@@ -663,7 +662,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                            sub_span,\n                            item.id,\n                            qualname.as_slice(),\n-                           e.cur_scope);\n+                           self.cur_scope);\n \n         // super-traits\n         for super_bound in trait_refs.iter() {\n@@ -683,7 +682,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                      trait_ref.path.span,\n                                      sub_span,\n                                      id,\n-                                     e.cur_scope);\n+                                     self.cur_scope);\n                     self.fmt.inherit_str(trait_ref.path.span,\n                                          sub_span,\n                                          id,\n@@ -694,15 +693,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n \n         // walk generics and methods\n-        self.process_generic_params(generics, item.span, qualname.as_slice(), item.id, e);\n+        self.process_generic_params(generics, item.span, qualname.as_slice(), item.id);\n         for method in methods.iter() {\n-            self.visit_trait_item(method, e)\n+            self.visit_trait_item(method)\n         }\n     }\n \n     fn process_mod(&mut self,\n                    item: &ast::Item,  // The module in question, represented as an item.\n-                   e: DxrVisitorEnv,\n                    m: &ast::Mod) {\n         let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n \n@@ -714,15 +712,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                          sub_span,\n                          item.id,\n                          qualname.as_slice(),\n-                         e.cur_scope,\n+                         self.cur_scope,\n                          filename.as_slice());\n \n-        visit::walk_mod(self, m, DxrVisitorEnv::new_nested(item.id));\n+        self.nest(item.id, |v| visit::walk_mod(v, m));\n     }\n \n     fn process_path(&mut self,\n                     ex: &ast::Expr,\n-                    e: DxrVisitorEnv,\n                     path: &ast::Path) {\n         if generated_code(path.span) {\n             return\n@@ -744,18 +741,18 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                        ex.span,\n                                                        sub_span,\n                                                        ast_util::local_def(id),\n-                                                       e.cur_scope),\n+                                                       self.cur_scope),\n             def::DefStatic(def_id,_) |\n             def::DefVariant(_, def_id, _) => self.fmt.ref_str(recorder::VarRef,\n                                                               ex.span,\n                                                               sub_span,\n                                                               def_id,\n-                                                              e.cur_scope),\n+                                                              self.cur_scope),\n             def::DefStruct(def_id) => self.fmt.ref_str(recorder::StructRef,\n                                                        ex.span,\n                                                        sub_span,\n                                                        def_id,\n-                                                        e.cur_scope),\n+                                                        self.cur_scope),\n             def::DefStaticMethod(declid, provenence, _) => {\n                 let sub_span = self.span.sub_span_for_meth_name(ex.span);\n                 let defid = if declid.krate == ast::LOCAL_CRATE {\n@@ -806,35 +803,34 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                        sub_span,\n                                        defid,\n                                        Some(declid),\n-                                       e.cur_scope);\n+                                       self.cur_scope);\n             },\n             def::DefFn(def_id, _) => self.fmt.fn_call_str(ex.span,\n                                                           sub_span,\n                                                           def_id,\n-                                                          e.cur_scope),\n+                                                          self.cur_scope),\n             _ => self.sess.span_bug(ex.span,\n                                     format!(\"Unexpected def kind while looking up path in '{}'\",\n                                             self.span.snippet(ex.span)).as_slice()),\n         }\n         // modules or types in the path prefix\n         match *def {\n             def::DefStaticMethod(_, _, _) => {\n-                self.write_sub_path_trait_truncated(path, e.cur_scope);\n+                self.write_sub_path_trait_truncated(path);\n             },\n             def::DefLocal(_, _) |\n             def::DefArg(_, _) |\n             def::DefStatic(_,_) |\n             def::DefStruct(_) |\n-            def::DefFn(_, _) => self.write_sub_paths_truncated(path, e.cur_scope),\n+            def::DefFn(_, _) => self.write_sub_paths_truncated(path),\n             _ => {},\n         }\n \n-        visit::walk_path(self, path, e);\n+        visit::walk_path(self, path);\n     }\n \n     fn process_struct_lit(&mut self,\n                           ex: &ast::Expr,\n-                          e: DxrVisitorEnv,\n                           path: &ast::Path,\n                           fields: &Vec<ast::Field>,\n                           base: Option<Gc<ast::Expr>>) {\n@@ -851,12 +847,12 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                  path.span,\n                                  sub_span,\n                                  id,\n-                                 e.cur_scope);\n+                                 self.cur_scope);\n             },\n             None => ()\n         }\n \n-        self.write_sub_paths_truncated(path, e.cur_scope);\n+        self.write_sub_paths_truncated(path);\n \n         for field in fields.iter() {\n             match struct_def {\n@@ -873,21 +869,20 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                              field.ident.span,\n                                              sub_span,\n                                              f.id,\n-                                             e.cur_scope);\n+                                             self.cur_scope);\n                         }\n                     }\n                 }\n                 None => {}\n             }\n \n-            self.visit_expr(&*field.expr, e)\n+            self.visit_expr(&*field.expr)\n         }\n-        visit::walk_expr_opt(self, base, e)\n+        visit::walk_expr_opt(self, base)\n     }\n \n     fn process_method_call(&mut self,\n                            ex: &ast::Expr,\n-                           e: DxrVisitorEnv,\n                            args: &Vec<Gc<ast::Expr>>) {\n         let method_map = self.analysis.ty_cx.method_map.borrow();\n         let method_callee = method_map.get(&typeck::MethodCall::expr(ex.id));\n@@ -941,21 +936,21 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                sub_span,\n                                def_id,\n                                decl_id,\n-                               e.cur_scope);\n+                               self.cur_scope);\n \n         // walk receiver and args\n-        visit::walk_exprs(self, args.as_slice(), e);\n+        visit::walk_exprs(self, args.as_slice());\n     }\n \n-    fn process_pat(&mut self, p:&ast::Pat, e: DxrVisitorEnv) {\n+    fn process_pat(&mut self, p:&ast::Pat) {\n         if generated_code(p.span) {\n             return\n         }\n \n         match p.node {\n             ast::PatStruct(ref path, ref fields, _) => {\n                 self.collected_paths.push((p.id, path.clone(), false, recorder::StructRef));\n-                visit::walk_path(self, path, e);\n+                visit::walk_path(self, path);\n                 let struct_def = match self.lookup_type_ref(p.id) {\n                     Some(sd) => sd,\n                     None => {\n@@ -976,7 +971,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                ).as_slice());\n                 }\n                 for (field, &span) in fields.iter().zip(field_spans.iter()) {\n-                    self.visit_pat(&*field.pat, e);\n+                    self.visit_pat(&*field.pat);\n                     if span.is_none() {\n                         continue;\n                     }\n@@ -987,15 +982,15 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                              p.span,\n                                              span,\n                                              f.id,\n-                                             e.cur_scope);\n+                                             self.cur_scope);\n                             break;\n                         }\n                     }\n                 }\n             }\n             ast::PatEnum(ref path, _) => {\n                 self.collected_paths.push((p.id, path.clone(), false, recorder::VarRef));\n-                visit::walk_pat(self, p, e);\n+                visit::walk_pat(self, p);\n             }\n             ast::PatIdent(bm, ref path1, ref optional_subpattern) => {\n                 let immut = match bm {\n@@ -1015,41 +1010,40 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 self.collected_paths.push((p.id, path, immut, recorder::VarRef));\n                 match *optional_subpattern {\n                     None => {}\n-                    Some(subpattern) => self.visit_pat(&*subpattern, e),\n+                    Some(subpattern) => self.visit_pat(&*subpattern),\n                 }\n             }\n-            _ => visit::walk_pat(self, p, e)\n+            _ => visit::walk_pat(self, p)\n         }\n     }\n }\n \n-impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n-    fn visit_item(&mut self, item:&ast::Item, e: DxrVisitorEnv) {\n+impl<'l, 'tcx> Visitor for DxrVisitor<'l, 'tcx> {\n+    fn visit_item(&mut self, item:&ast::Item) {\n         if generated_code(item.span) {\n             return\n         }\n \n         match item.node {\n             ast::ItemFn(decl, _, _, ref ty_params, body) =>\n-                self.process_fn(item, e, decl, ty_params, body),\n+                self.process_fn(item, decl, ty_params, body),\n             ast::ItemStatic(typ, mt, expr) =>\n-                self.process_static(item, e, typ, mt, &*expr),\n-            ast::ItemStruct(def, ref ty_params) => self.process_struct(item, e, &*def, ty_params),\n-            ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, e, def, ty_params),\n+                self.process_static(item, typ, mt, &*expr),\n+            ast::ItemStruct(def, ref ty_params) => self.process_struct(item, &*def, ty_params),\n+            ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n             ast::ItemImpl(ref ty_params,\n                           ref trait_ref,\n                           typ,\n                           ref impl_items) => {\n                 self.process_impl(item,\n-                                  e,\n                                   ty_params,\n                                   trait_ref,\n                                   typ,\n                                   impl_items)\n             }\n             ast::ItemTrait(ref generics, _, ref trait_refs, ref methods) =>\n-                self.process_trait(item, e, generics, trait_refs, methods),\n-            ast::ItemMod(ref m) => self.process_mod(item, e, m),\n+                self.process_trait(item, generics, trait_refs, methods),\n+            ast::ItemMod(ref m) => self.process_mod(item, m),\n             ast::ItemTy(ty, ref ty_params) => {\n                 let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n                 let value = ty_to_string(&*ty);\n@@ -1060,26 +1054,26 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n                                      qualname.as_slice(),\n                                      value.as_slice());\n \n-                self.visit_ty(&*ty, e);\n-                self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id, e);\n+                self.visit_ty(&*ty);\n+                self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n             },\n             ast::ItemMac(_) => (),\n-            _ => visit::walk_item(self, item, e),\n+            _ => visit::walk_item(self, item),\n         }\n     }\n \n-    fn visit_generics(&mut self, generics: &ast::Generics, e: DxrVisitorEnv) {\n+    fn visit_generics(&mut self, generics: &ast::Generics) {\n         for param in generics.ty_params.iter() {\n             for bound in param.bounds.iter() {\n                 match *bound {\n                     ast::TraitTyParamBound(ref trait_ref) => {\n-                        self.process_trait_ref(trait_ref, e, None);\n+                        self.process_trait_ref(trait_ref, None);\n                     }\n                     _ => {}\n                 }\n             }\n             match param.default {\n-                Some(ty) => self.visit_ty(&*ty, e),\n+                Some(ty) => self.visit_ty(&*ty),\n                 None => (),\n             }\n         }\n@@ -1092,19 +1086,18 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n                 fd: &ast::FnDecl,\n                 b: &ast::Block,\n                 s: Span,\n-                _: NodeId,\n-                e: DxrVisitorEnv) {\n+                _: NodeId) {\n         if generated_code(s) {\n             return;\n         }\n \n         match *fk {\n-            visit::FkMethod(_, _, method) => self.process_method(method, e),\n-            _ => visit::walk_fn(self, fk, fd, b, s, e),\n+            visit::FkMethod(_, _, method) => self.process_method(method),\n+            _ => visit::walk_fn(self, fk, fd, b, s),\n         }\n     }\n \n-    fn visit_trait_item(&mut self, tm: &ast::TraitItem, e: DxrVisitorEnv) {\n+    fn visit_trait_item(&mut self, tm: &ast::TraitItem) {\n         match *tm {\n             ast::RequiredMethod(ref method_type) => {\n                 if generated_code(method_type.span) {\n@@ -1137,21 +1130,20 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n \n                 // walk arg and return types\n                 for arg in method_type.decl.inputs.iter() {\n-                    self.visit_ty(&*arg.ty, e);\n+                    self.visit_ty(&*arg.ty);\n                 }\n-                self.visit_ty(&*method_type.decl.output, e);\n+                self.visit_ty(&*method_type.decl.output);\n \n                 self.process_generic_params(&method_type.generics,\n                                             method_type.span,\n                                             qualname,\n-                                            method_type.id,\n-                                            e);\n+                                            method_type.id);\n             }\n-            ast::ProvidedMethod(method) => self.process_method(&*method, e),\n+            ast::ProvidedMethod(method) => self.process_method(&*method),\n         }\n     }\n \n-    fn visit_view_item(&mut self, i:&ast::ViewItem, e:DxrVisitorEnv) {\n+    fn visit_view_item(&mut self, i:&ast::ViewItem) {\n         if generated_code(i.span) {\n             return\n         }\n@@ -1168,7 +1160,7 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n                                                                    path.span,\n                                                                    sub_span,\n                                                                    def_id,\n-                                                                   e.cur_scope),\n+                                                                   self.cur_scope),\n                                     None => {},\n                                 }\n                                 Some(def_id)\n@@ -1189,11 +1181,11 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n                                                id,\n                                                mod_id,\n                                                get_ident(ident).get(),\n-                                               e.cur_scope);\n-                        self.write_sub_paths_truncated(path, e.cur_scope);\n+                                               self.cur_scope);\n+                        self.write_sub_paths_truncated(path);\n                     }\n                     ast::ViewPathGlob(ref path, _) => {\n-                        self.write_sub_paths(path, e.cur_scope);\n+                        self.write_sub_paths(path);\n                     }\n                     ast::ViewPathList(ref path, ref list, _) => {\n                         for plid in list.iter() {\n@@ -1206,7 +1198,7 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n                                                     self.fmt.ref_str(\n                                                         kind, plid.span,\n                                                         Some(plid.span),\n-                                                        def_id, e.cur_scope);\n+                                                        def_id, self.cur_scope);\n                                                 }\n                                                 None => ()\n                                             },\n@@ -1217,7 +1209,7 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n                             }\n                         }\n \n-                        self.write_sub_paths(path, e.cur_scope);\n+                        self.write_sub_paths(path);\n                     }\n                 }\n             },\n@@ -1239,12 +1231,12 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n                                           cnum,\n                                           name,\n                                           s.as_slice(),\n-                                          e.cur_scope);\n+                                          self.cur_scope);\n             },\n         }\n     }\n \n-    fn visit_ty(&mut self, t: &ast::Ty, e: DxrVisitorEnv) {\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n         if generated_code(t.span) {\n             return\n         }\n@@ -1258,20 +1250,20 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n                                          t.span,\n                                          sub_span,\n                                          id,\n-                                         e.cur_scope);\n+                                         self.cur_scope);\n                     },\n                     None => ()\n                 }\n \n-                self.write_sub_paths_truncated(path, e.cur_scope);\n+                self.write_sub_paths_truncated(path);\n \n-                visit::walk_path(self, path, e);\n+                visit::walk_path(self, path);\n             },\n-            _ => visit::walk_ty(self, t, e),\n+            _ => visit::walk_ty(self, t),\n         }\n     }\n \n-    fn visit_expr(&mut self, ex: &ast::Expr, e: DxrVisitorEnv) {\n+    fn visit_expr(&mut self, ex: &ast::Expr) {\n         if generated_code(ex.span) {\n             return\n         }\n@@ -1280,18 +1272,18 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n             ast::ExprCall(_f, ref _args) => {\n                 // Don't need to do anything for function calls,\n                 // because just walking the callee path does what we want.\n-                visit::walk_expr(self, ex, e);\n+                visit::walk_expr(self, ex);\n             },\n-            ast::ExprPath(ref path) => self.process_path(ex, e, path),\n+            ast::ExprPath(ref path) => self.process_path(ex, path),\n             ast::ExprStruct(ref path, ref fields, base) =>\n-                self.process_struct_lit(ex, e, path, fields, base),\n-            ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, e, args),\n+                self.process_struct_lit(ex, path, fields, base),\n+            ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n             ast::ExprField(sub_ex, ident, _) => {\n                 if generated_code(sub_ex.span) {\n                     return\n                 }\n \n-                self.visit_expr(&*sub_ex, e);\n+                self.visit_expr(&*sub_ex);\n \n                 let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &*sub_ex);\n                 let t_box = ty::get(t);\n@@ -1305,7 +1297,7 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n                                                  ex.span,\n                                                  sub_span,\n                                                  f.id,\n-                                                 e.cur_scope);\n+                                                 self.cur_scope);\n                                 break;\n                             }\n                         }\n@@ -1319,7 +1311,7 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n                     return\n                 }\n \n-                self.visit_expr(&*sub_ex, e);\n+                self.visit_expr(&*sub_ex);\n \n                 let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &*sub_ex);\n                 let t_box = ty::get(t);\n@@ -1333,7 +1325,7 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n                                                  ex.span,\n                                                  sub_span,\n                                                  f.id,\n-                                                 e.cur_scope);\n+                                                 self.cur_scope);\n                                 break;\n                             }\n                         }\n@@ -1348,41 +1340,41 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n                 }\n \n                 let id = String::from_str(\"$\").append(ex.id.to_string().as_slice());\n-                self.process_formals(&decl.inputs, id.as_slice(), e);\n+                self.process_formals(&decl.inputs, id.as_slice());\n \n                 // walk arg and return types\n                 for arg in decl.inputs.iter() {\n-                    self.visit_ty(&*arg.ty, e);\n+                    self.visit_ty(&*arg.ty);\n                 }\n-                self.visit_ty(&*decl.output, e);\n+                self.visit_ty(&*decl.output);\n \n                 // walk the body\n-                self.visit_block(&*body, DxrVisitorEnv::new_nested(ex.id));\n+                self.nest(ex.id, |v| v.visit_block(&*body));\n             },\n             _ => {\n-                visit::walk_expr(self, ex, e)\n+                visit::walk_expr(self, ex)\n             },\n         }\n     }\n \n-    fn visit_mac(&mut self, _: &ast::Mac, _: DxrVisitorEnv) {\n+    fn visit_mac(&mut self, _: &ast::Mac) {\n         // Just stop, macros are poison to us.\n     }\n \n-    fn visit_pat(&mut self, p: &ast::Pat, e: DxrVisitorEnv) {\n-        self.process_pat(p, e);\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n+        self.process_pat(p);\n         if !self.collecting {\n             self.collected_paths.clear();\n         }\n     }\n \n-    fn visit_arm(&mut self, arm: &ast::Arm, e: DxrVisitorEnv) {\n+    fn visit_arm(&mut self, arm: &ast::Arm) {\n         assert!(self.collected_paths.len() == 0 && !self.collecting);\n         self.collecting = true;\n \n         for pattern in arm.pats.iter() {\n             // collect paths from the arm's patterns\n-            self.visit_pat(&**pattern, e);\n+            self.visit_pat(&**pattern);\n         }\n         self.collecting = false;\n         // process collected paths\n@@ -1411,26 +1403,26 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n                                                             p.span,\n                                                             sub_span,\n                                                             id,\n-                                                            e.cur_scope),\n+                                                            self.cur_scope),\n                 // FIXME(nrc) what is this doing here?\n                 def::DefStatic(_, _) => {}\n                 _ => error!(\"unexpected defintion kind when processing collected paths: {:?}\", *def)\n             }\n         }\n         self.collected_paths.clear();\n-        visit::walk_expr_opt(self, arm.guard, e);\n-        self.visit_expr(&*arm.body, e);\n+        visit::walk_expr_opt(self, arm.guard);\n+        self.visit_expr(&*arm.body);\n     }\n \n-    fn visit_stmt(&mut self, s:&ast::Stmt, e:DxrVisitorEnv) {\n+    fn visit_stmt(&mut self, s:&ast::Stmt) {\n         if generated_code(s.span) {\n             return\n         }\n \n-        visit::walk_stmt(self, s, e)\n+        visit::walk_stmt(self, s)\n     }\n \n-    fn visit_local(&mut self, l:&ast::Local, e: DxrVisitorEnv) {\n+    fn visit_local(&mut self, l:&ast::Local) {\n         if generated_code(l.span) {\n             return\n         }\n@@ -1439,7 +1431,7 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n         // pattern and collect them all.\n         assert!(self.collected_paths.len() == 0 && !self.collecting);\n         self.collecting = true;\n-        self.visit_pat(&*l.pat, e);\n+        self.visit_pat(&*l.pat);\n         self.collecting = false;\n \n         let value = self.span.snippet(l.span);\n@@ -1462,22 +1454,8 @@ impl<'l, 'tcx> Visitor<DxrVisitorEnv> for DxrVisitor<'l, 'tcx> {\n         self.collected_paths.clear();\n \n         // Just walk the initialiser and type (don't want to walk the pattern again).\n-        self.visit_ty(&*l.ty, e);\n-        visit::walk_expr_opt(self, l.init, e);\n-    }\n-}\n-\n-#[deriving(Clone)]\n-struct DxrVisitorEnv {\n-    cur_scope: NodeId,\n-}\n-\n-impl DxrVisitorEnv {\n-    fn new() -> DxrVisitorEnv {\n-        DxrVisitorEnv{cur_scope: 0}\n-    }\n-    fn new_nested(new_mod: NodeId) -> DxrVisitorEnv {\n-        DxrVisitorEnv{cur_scope: new_mod}\n+        self.visit_ty(&*l.ty);\n+        visit::walk_expr_opt(self, l.init);\n     }\n }\n \n@@ -1532,25 +1510,28 @@ pub fn process_crate(sess: &Session,\n     };\n     root_path.pop();\n \n-    let mut visitor = DxrVisitor{ sess: sess,\n-                                  analysis: analysis,\n-                                  collected_paths: vec!(),\n-                                  collecting: false,\n-                                  fmt: FmtStrs::new(box Recorder {\n-                                                        out: output_file as Box<Writer+'static>,\n-                                                        dump_spans: false,\n-                                                    },\n-                                                    SpanUtils {\n-                                                        sess: sess,\n-                                                        err_count: Cell::new(0)\n-                                                    },\n-                                                    cratename.clone()),\n-                                  span: SpanUtils {\n-                                      sess: sess,\n-                                      err_count: Cell::new(0)\n-                                  }};\n+    let mut visitor = DxrVisitor {\n+        sess: sess,\n+        analysis: analysis,\n+        collected_paths: vec!(),\n+        collecting: false,\n+        fmt: FmtStrs::new(box Recorder {\n+                            out: output_file as Box<Writer+'static>,\n+                            dump_spans: false,\n+                        },\n+                        SpanUtils {\n+                            sess: sess,\n+                            err_count: Cell::new(0)\n+                        },\n+                        cratename.clone()),\n+        span: SpanUtils {\n+            sess: sess,\n+            err_count: Cell::new(0)\n+        },\n+        cur_scope: 0\n+    };\n \n     visitor.dump_crate_info(cratename.as_slice(), krate);\n \n-    visit::walk_crate(&mut visitor, krate, DxrVisitorEnv::new());\n+    visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "6d0c02ff4e3d679e03218a339521ee90c607c601", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -24,6 +24,8 @@ use syntax::visit::{FnKind, FkMethod, Visitor};\n use middle::ty;\n use metadata::csearch;\n \n+use std::mem::replace;\n+\n /// A stability index, giving the stability level for items and methods.\n pub struct Index {\n     // stability for crate-local items; unmarked stability == no entry\n@@ -34,68 +36,68 @@ pub struct Index {\n \n // A private tree-walker for producing an Index.\n struct Annotator {\n-    index: Index\n+    index: Index,\n+    parent: Option<Stability>\n }\n \n impl Annotator {\n     // Determine the stability for a node based on its attributes and inherited\n-    // stability. The stability is recorded in the index and returned.\n-    fn annotate(&mut self, id: NodeId, attrs: &[Attribute],\n-                parent: Option<Stability>) -> Option<Stability> {\n-        match attr::find_stability(attrs).or(parent) {\n+    // stability. The stability is recorded in the index and used as the parent.\n+    fn annotate(&mut self, id: NodeId, attrs: &Vec<Attribute>, f: |&mut Annotator|) {\n+        match attr::find_stability(attrs.as_slice()) {\n             Some(stab) => {\n                 self.index.local.insert(id, stab.clone());\n-                Some(stab)\n+                let parent = replace(&mut self.parent, Some(stab));\n+                f(self);\n+                self.parent = parent;\n+            }\n+            None => {\n+                self.parent.clone().map(|stab| self.index.local.insert(id, stab));\n+                f(self);\n             }\n-            None => None\n         }\n     }\n }\n \n-impl Visitor<Option<Stability>> for Annotator {\n-    fn visit_item(&mut self, i: &Item, parent: Option<Stability>) {\n-        let stab = self.annotate(i.id, i.attrs.as_slice(), parent);\n-        visit::walk_item(self, i, stab)\n+impl Visitor for Annotator {\n+    fn visit_item(&mut self, i: &Item) {\n+        self.annotate(i.id, &i.attrs, |v| visit::walk_item(v, i));\n     }\n \n-    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block,\n-                s: Span, _: NodeId, parent: Option<Stability>) {\n-        let stab = match *fk {\n-            FkMethod(_, _, meth) =>\n-                self.annotate(meth.id, meth.attrs.as_slice(), parent),\n-            _ => parent\n-        };\n-        visit::walk_fn(self, fk, fd, b, s, stab)\n+    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId) {\n+        match *fk {\n+            FkMethod(_, _, meth) => {\n+                self.annotate(meth.id, &meth.attrs, |v| visit::walk_fn(v, fk, fd, b, s));\n+            }\n+            _ => visit::walk_fn(self, fk, fd, b, s)\n+        }\n     }\n \n-    fn visit_trait_item(&mut self, t: &TraitItem, parent: Option<Stability>) {\n-        let stab = match *t {\n-            RequiredMethod(TypeMethod {attrs: ref attrs, id: id, ..}) =>\n-                self.annotate(id, attrs.as_slice(), parent),\n+    fn visit_trait_item(&mut self, t: &TraitItem) {\n+        let (id, attrs) = match *t {\n+            RequiredMethod(TypeMethod {id, ref attrs, ..}) => (id, attrs),\n \n             // work around lack of pattern matching for @ types\n-            ProvidedMethod(method) => match *method {\n-                Method {attrs: ref attrs, id: id, ..} =>\n-                    self.annotate(id, attrs.as_slice(), parent)\n+            ProvidedMethod(ref method) => match **method {\n+                Method {id, ref attrs, ..} => (id, attrs)\n             }\n         };\n-        visit::walk_trait_item(self, t, stab)\n+        self.annotate(id, attrs, |v| visit::walk_trait_item(v, t));\n     }\n \n-    fn visit_variant(&mut self, v: &Variant, g: &Generics, parent: Option<Stability>) {\n-        let stab = self.annotate(v.node.id, v.node.attrs.as_slice(), parent);\n-        visit::walk_variant(self, v, g, stab)\n+    fn visit_variant(&mut self, var: &Variant, g: &Generics) {\n+        self.annotate(var.node.id, &var.node.attrs, |v| visit::walk_variant(v, var, g))\n     }\n \n-    fn visit_struct_def(&mut self, s: &StructDef, _: Ident, _: &Generics,\n-                        _: NodeId, parent: Option<Stability>) {\n-        s.ctor_id.map(|id| self.annotate(id, &[], parent.clone()));\n-        visit::walk_struct_def(self, s, parent)\n+    fn visit_struct_def(&mut self, s: &StructDef, _: Ident, _: &Generics, _: NodeId) {\n+        match s.ctor_id {\n+            Some(id) => self.annotate(id, &vec![], |v| visit::walk_struct_def(v, s)),\n+            None => visit::walk_struct_def(self, s)\n+        }\n     }\n \n-    fn visit_struct_field(&mut self, s: &StructField, parent: Option<Stability>) {\n-        let stab = self.annotate(s.node.id, s.node.attrs.as_slice(), parent);\n-        visit::walk_struct_field(self, s, stab)\n+    fn visit_struct_field(&mut self, s: &StructField) {\n+        self.annotate(s.node.id, &s.node.attrs, |v| visit::walk_struct_field(v, s));\n     }\n }\n \n@@ -106,10 +108,10 @@ impl Index {\n             index: Index {\n                 local: NodeMap::new(),\n                 extern_cache: DefIdMap::new()\n-            }\n+            },\n+            parent: None\n         };\n-        let stab = annotator.annotate(ast::CRATE_NODE_ID, krate.attrs.as_slice(), None);\n-        visit::walk_crate(&mut annotator, krate, stab);\n+        annotator.annotate(ast::CRATE_NODE_ID, &krate.attrs, |v| visit::walk_crate(v, krate));\n         annotator.index\n     }\n }"}, {"sha": "86877c032d13216dc4df920229cfedd43849ffeb", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 43, "deletions": 37, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -1322,18 +1322,32 @@ pub fn make_return_slot_pointer(fcx: &FunctionContext, output_type: ty::t) -> Va\n }\n \n struct CheckForNestedReturnsVisitor {\n-    found: bool\n+    found: bool,\n+    in_return: bool\n }\n \n-impl Visitor<bool> for CheckForNestedReturnsVisitor {\n-    fn visit_expr(&mut self, e: &ast::Expr, in_return: bool) {\n+impl CheckForNestedReturnsVisitor {\n+    fn explicit() -> CheckForNestedReturnsVisitor {\n+        CheckForNestedReturnsVisitor { found: false, in_return: false }\n+    }\n+    fn implicit() -> CheckForNestedReturnsVisitor {\n+        CheckForNestedReturnsVisitor { found: false, in_return: true }\n+    }\n+}\n+\n+impl Visitor for CheckForNestedReturnsVisitor {\n+    fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprRet(..) if in_return => {\n-                self.found = true;\n-                return;\n+            ast::ExprRet(..) => {\n+                if self.in_return {\n+                    self.found = true;\n+                } else {\n+                    self.in_return = true;\n+                    visit::walk_expr(self, e);\n+                    self.in_return = false;\n+                }\n             }\n-            ast::ExprRet(..) => visit::walk_expr(self, e, true),\n-            _ => visit::walk_expr(self, e, in_return)\n+            _ => visit::walk_expr(self, e)\n         }\n     }\n }\n@@ -1343,10 +1357,10 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n         Some(ast_map::NodeItem(i)) => {\n             match i.node {\n                 ast::ItemFn(_, _, _, _, blk) => {\n-                    let mut explicit = CheckForNestedReturnsVisitor { found: false };\n-                    let mut implicit = CheckForNestedReturnsVisitor { found: false };\n-                    visit::walk_item(&mut explicit, &*i, false);\n-                    visit::walk_expr_opt(&mut implicit, blk.expr, true);\n+                    let mut explicit = CheckForNestedReturnsVisitor::explicit();\n+                    let mut implicit = CheckForNestedReturnsVisitor::implicit();\n+                    visit::walk_item(&mut explicit, &*i);\n+                    visit::walk_expr_opt(&mut implicit, blk.expr);\n                     explicit.found || implicit.found\n                 }\n                 _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\")\n@@ -1357,10 +1371,10 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                 ast::ProvidedMethod(m) => {\n                     match m.node {\n                         ast::MethDecl(_, _, _, _, _, _, blk, _) => {\n-                            let mut explicit = CheckForNestedReturnsVisitor { found: false };\n-                            let mut implicit = CheckForNestedReturnsVisitor { found: false };\n-                            visit::walk_method_helper(&mut explicit, &*m, false);\n-                            visit::walk_expr_opt(&mut implicit, blk.expr, true);\n+                            let mut explicit = CheckForNestedReturnsVisitor::explicit();\n+                            let mut implicit = CheckForNestedReturnsVisitor::implicit();\n+                            visit::walk_method_helper(&mut explicit, &*m);\n+                            visit::walk_expr_opt(&mut implicit, blk.expr);\n                             explicit.found || implicit.found\n                         }\n                         ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n@@ -1377,18 +1391,10 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                 ast::MethodImplItem(ref m) => {\n                     match m.node {\n                         ast::MethDecl(_, _, _, _, _, _, blk, _) => {\n-                            let mut explicit = CheckForNestedReturnsVisitor {\n-                                found: false,\n-                            };\n-                            let mut implicit = CheckForNestedReturnsVisitor {\n-                                found: false,\n-                            };\n-                            visit::walk_method_helper(&mut explicit,\n-                                                      &**m,\n-                                                      false);\n-                            visit::walk_expr_opt(&mut implicit,\n-                                                 blk.expr,\n-                                                 true);\n+                            let mut explicit = CheckForNestedReturnsVisitor::explicit();\n+                            let mut implicit = CheckForNestedReturnsVisitor::implicit();\n+                            visit::walk_method_helper(&mut explicit, &**m);\n+                            visit::walk_expr_opt(&mut implicit, blk.expr);\n                             explicit.found || implicit.found\n                         }\n                         ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n@@ -1401,10 +1407,10 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                 ast::ExprFnBlock(_, _, blk) |\n                 ast::ExprProc(_, blk) |\n                 ast::ExprUnboxedFn(_, _, _, blk) => {\n-                    let mut explicit = CheckForNestedReturnsVisitor { found: false };\n-                    let mut implicit = CheckForNestedReturnsVisitor { found: false };\n-                    visit::walk_expr(&mut explicit, &*e, false);\n-                    visit::walk_expr_opt(&mut implicit, blk.expr, true);\n+                    let mut explicit = CheckForNestedReturnsVisitor::explicit();\n+                    let mut implicit = CheckForNestedReturnsVisitor::implicit();\n+                    visit::walk_expr(&mut explicit, &*e);\n+                    visit::walk_expr_opt(&mut implicit, blk.expr);\n                     explicit.found || implicit.found\n                 }\n                 _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\")\n@@ -2135,8 +2141,8 @@ pub struct TransItemVisitor<'a, 'tcx: 'a> {\n     pub ccx: &'a CrateContext<'a, 'tcx>,\n }\n \n-impl<'a, 'tcx> Visitor<()> for TransItemVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item, _:()) {\n+impl<'a, 'tcx> Visitor for TransItemVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &ast::Item) {\n         trans_item(self.ccx, i);\n     }\n }\n@@ -2236,7 +2242,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n         // Be sure to travel more than just one layer deep to catch nested\n         // items in blocks and such.\n         let mut v = TransItemVisitor{ ccx: ccx };\n-        v.visit_block(&**body, ());\n+        v.visit_block(&**body);\n       }\n       ast::ItemImpl(ref generics, _, _, ref impl_items) => {\n         meth::trans_impl(ccx,\n@@ -2254,7 +2260,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       ast::ItemStatic(_, m, ref expr) => {\n           // Recurse on the expression to catch items in blocks\n           let mut v = TransItemVisitor{ ccx: ccx };\n-          v.visit_expr(&**expr, ());\n+          v.visit_expr(&**expr);\n \n           let trans_everywhere = attr::requests_inline(item.attrs.as_slice());\n           for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n@@ -2293,7 +2299,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n         // methods with items will not get translated and will cause ICE's when\n         // metadata time comes around.\n         let mut v = TransItemVisitor{ ccx: ccx };\n-        visit::walk_item(&mut v, item, ());\n+        visit::walk_item(&mut v, item);\n       }\n       _ => {/* fall through */ }\n     }"}, {"sha": "164ddd65f3540b608a473f80ffc7b9128a184c7e", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -150,7 +150,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match els {\n                 Some(elexpr) => {\n                     let mut trans = TransItemVisitor { ccx: bcx.fcx.ccx };\n-                    trans.visit_expr(&*elexpr, ());\n+                    trans.visit_expr(&*elexpr);\n                 }\n                 None => {}\n             }\n@@ -159,7 +159,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans::debuginfo::clear_source_location(bcx.fcx);\n         } else {\n             let mut trans = TransItemVisitor { ccx: bcx.fcx.ccx } ;\n-            trans.visit_block(&*thn, ());\n+            trans.visit_block(&*thn);\n \n             match els {\n                 // if false { .. } else { .. }"}, {"sha": "384502025cb1f469627ae119a8545efd5bc34745", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -67,7 +67,7 @@ pub fn trans_impl(ccx: &CrateContext,\n         for impl_item in impl_items.iter() {\n             match *impl_item {\n                 ast::MethodImplItem(method) => {\n-                    visit::walk_method_helper(&mut v, &*method, ());\n+                    visit::walk_method_helper(&mut v, &*method);\n                 }\n             }\n         }\n@@ -96,7 +96,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                 let mut v = TransItemVisitor {\n                     ccx: ccx,\n                 };\n-                visit::walk_method_helper(&mut v, &*method, ());\n+                visit::walk_method_helper(&mut v, &*method);\n             }\n         }\n     }"}, {"sha": "da16e443ef21512d3a1bd7b5bcd9a906aa065236", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -375,47 +375,47 @@ fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n struct CheckTypeWellFormedVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n \n-impl<'a, 'tcx> Visitor<()> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item, _: ()) {\n+impl<'a, 'tcx> Visitor for CheckTypeWellFormedVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &ast::Item) {\n         check_type_well_formed(self.ccx, i);\n-        visit::walk_item(self, i, ());\n+        visit::walk_item(self, i);\n     }\n }\n \n \n-impl<'a, 'tcx> Visitor<()> for CheckItemTypesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item, _: ()) {\n+impl<'a, 'tcx> Visitor for CheckItemTypesVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &ast::Item) {\n         check_item(self.ccx, i);\n-        visit::walk_item(self, i, ());\n+        visit::walk_item(self, i);\n     }\n }\n \n struct CheckItemSizedTypesVisitor<'a, 'tcx: 'a> {\n     ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n-impl<'a, 'tcx> Visitor<()> for CheckItemSizedTypesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item, _: ()) {\n+impl<'a, 'tcx> Visitor for CheckItemSizedTypesVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &ast::Item) {\n         check_item_sized(self.ccx, i);\n-        visit::walk_item(self, i, ());\n+        visit::walk_item(self, i);\n     }\n }\n \n pub fn check_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n     let mut visit = CheckTypeWellFormedVisitor { ccx: ccx };\n-    visit::walk_crate(&mut visit, krate, ());\n+    visit::walk_crate(&mut visit, krate);\n \n     // If types are not well-formed, it leads to all manner of errors\n     // downstream, so stop reporting errors at this point.\n     ccx.tcx.sess.abort_if_errors();\n \n     let mut visit = CheckItemTypesVisitor { ccx: ccx };\n-    visit::walk_crate(&mut visit, krate, ());\n+    visit::walk_crate(&mut visit, krate);\n \n     ccx.tcx.sess.abort_if_errors();\n \n     let mut visit = CheckItemSizedTypesVisitor { ccx: ccx };\n-    visit::walk_crate(&mut visit, krate, ());\n+    visit::walk_crate(&mut visit, krate);\n }\n \n fn check_bare_fn(ccx: &CrateCtxt,\n@@ -464,9 +464,9 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<()> for GatherLocalsVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor for GatherLocalsVisitor<'a, 'tcx> {\n     // Add explicitly-declared locals.\n-    fn visit_local(&mut self, local: &ast::Local, _: ()) {\n+    fn visit_local(&mut self, local: &ast::Local) {\n         let o_ty = match local.ty.node {\n             ast::TyInfer => None,\n             _ => Some(self.fcx.to_ty(&*local.ty))\n@@ -476,11 +476,11 @@ impl<'a, 'tcx> Visitor<()> for GatherLocalsVisitor<'a, 'tcx> {\n                self.fcx.pat_to_string(&*local.pat),\n                self.fcx.infcx().ty_to_string(\n                    self.fcx.inh.locals.borrow().get_copy(&local.id)));\n-        visit::walk_local(self, local, ());\n+        visit::walk_local(self, local);\n     }\n \n     // Add pattern bindings.\n-    fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n             match p.node {\n               ast::PatIdent(_, ref path1, _)\n                   if pat_util::pat_is_binding(&self.fcx.ccx.tcx.def_map, p) => {\n@@ -492,33 +492,33 @@ impl<'a, 'tcx> Visitor<()> for GatherLocalsVisitor<'a, 'tcx> {\n               }\n               _ => {}\n             }\n-            visit::walk_pat(self, p, ());\n+            visit::walk_pat(self, p);\n \n     }\n \n-    fn visit_block(&mut self, b: &ast::Block, _: ()) {\n+    fn visit_block(&mut self, b: &ast::Block) {\n         // non-obvious: the `blk` variable maps to region lb, so\n         // we have to keep this up-to-date.  This\n         // is... unfortunate.  It'd be nice to not need this.\n-        visit::walk_block(self, b, ());\n+        visit::walk_block(self, b);\n     }\n \n     // Since an expr occurs as part of the type fixed size arrays we\n     // need to record the type for that node\n-    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n         match t.node {\n             ast::TyFixedLengthVec(ref ty, ref count_expr) => {\n-                self.visit_ty(&**ty, ());\n+                self.visit_ty(&**ty);\n                 check_expr_with_hint(self.fcx, &**count_expr, ty::mk_uint());\n             }\n-            _ => visit::walk_ty(self, t, ())\n+            _ => visit::walk_ty(self, t)\n         }\n     }\n \n     // Don't descend into fns and items\n     fn visit_fn(&mut self, _: &visit::FnKind, _: &ast::FnDecl,\n-                _: &ast::Block, _: Span, _: ast::NodeId, _: ()) { }\n-    fn visit_item(&mut self, _: &ast::Item, _: ()) { }\n+                _: &ast::Block, _: Span, _: ast::NodeId) { }\n+    fn visit_item(&mut self, _: &ast::Item) { }\n \n }\n \n@@ -603,7 +603,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n             _match::check_pat(&pcx, &*input.pat, *arg_ty);\n         }\n \n-        visit.visit_block(body, ());\n+        visit.visit_block(body);\n     }\n \n     check_block_with_expected(&fcx, body, ExpectHasType(ret_ty));\n@@ -4508,7 +4508,7 @@ pub fn check_const_with_ty(fcx: &FnCtxt,\n     // This is technically unnecessary because locals in static items are forbidden,\n     // but prevents type checking from blowing up before const checking can properly\n     // emit a error.\n-    GatherLocalsVisitor { fcx: fcx }.visit_expr(e, ());\n+    GatherLocalsVisitor { fcx: fcx }.visit_expr(e);\n \n     check_expr_with_hint(fcx, e, declty);\n     demand::coerce(fcx, e.span, declty, e);"}, {"sha": "241aa5b91898cb200b027f84bfb2e201a6e1622e", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -150,7 +150,7 @@ pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     let mut rcx = Rcx::new(fcx, e.id);\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n-        rcx.visit_expr(e, ());\n+        rcx.visit_expr(e);\n         rcx.visit_region_obligations(e.id);\n     }\n     fcx.infcx().resolve_regions_and_report_errors();\n@@ -346,7 +346,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n         let len = self.region_param_pairs.len();\n         self.relate_free_regions(fn_sig.as_slice(), body.id);\n-        self.visit_block(body, ());\n+        self.visit_block(body);\n         self.visit_region_obligations(body.id);\n         self.region_param_pairs.truncate(len);\n     }\n@@ -479,7 +479,7 @@ impl<'fcx, 'tcx> mc::Typer<'tcx> for Rcx<'fcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<()> for Rcx<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor for Rcx<'a, 'tcx> {\n     // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n     // regions are not properly related if they appear within the\n@@ -489,29 +489,29 @@ impl<'a, 'tcx> Visitor<()> for Rcx<'a, 'tcx> {\n     // regions, until regionck, as described in #3238.\n \n     fn visit_fn(&mut self, _fk: &visit::FnKind, _fd: &ast::FnDecl,\n-                b: &ast::Block, _s: Span, id: ast::NodeId, _e: ()) {\n+                b: &ast::Block, _s: Span, id: ast::NodeId) {\n         self.visit_fn_body(id, b)\n     }\n \n-    fn visit_item(&mut self, i: &ast::Item, _: ()) { visit_item(self, i); }\n+    fn visit_item(&mut self, i: &ast::Item) { visit_item(self, i); }\n \n-    fn visit_expr(&mut self, ex: &ast::Expr, _: ()) { visit_expr(self, ex); }\n+    fn visit_expr(&mut self, ex: &ast::Expr) { visit_expr(self, ex); }\n \n     //visit_pat: visit_pat, // (..) see above\n \n-    fn visit_arm(&mut self, a: &ast::Arm, _: ()) { visit_arm(self, a); }\n+    fn visit_arm(&mut self, a: &ast::Arm) { visit_arm(self, a); }\n \n-    fn visit_local(&mut self, l: &ast::Local, _: ()) { visit_local(self, l); }\n+    fn visit_local(&mut self, l: &ast::Local) { visit_local(self, l); }\n \n-    fn visit_block(&mut self, b: &ast::Block, _: ()) { visit_block(self, b); }\n+    fn visit_block(&mut self, b: &ast::Block) { visit_block(self, b); }\n }\n \n fn visit_item(_rcx: &mut Rcx, _item: &ast::Item) {\n     // Ignore items\n }\n \n fn visit_block(rcx: &mut Rcx, b: &ast::Block) {\n-    visit::walk_block(rcx, b, ());\n+    visit::walk_block(rcx, b);\n }\n \n fn visit_arm(rcx: &mut Rcx, arm: &ast::Arm) {\n@@ -520,14 +520,14 @@ fn visit_arm(rcx: &mut Rcx, arm: &ast::Arm) {\n         constrain_bindings_in_pat(&**p, rcx);\n     }\n \n-    visit::walk_arm(rcx, arm, ());\n+    visit::walk_arm(rcx, arm);\n }\n \n fn visit_local(rcx: &mut Rcx, l: &ast::Local) {\n     // see above\n     constrain_bindings_in_pat(&*l.pat, rcx);\n     link_local(rcx, l);\n-    visit::walk_local(rcx, l, ());\n+    visit::walk_local(rcx, l);\n }\n \n fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n@@ -625,19 +625,19 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                                false);\n             }\n \n-            visit::walk_expr(rcx, expr, ());\n+            visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprMethodCall(_, _, ref args) => {\n             constrain_call(rcx, expr, Some(*args.get(0)),\n                            args.slice_from(1), false);\n \n-            visit::walk_expr(rcx, expr, ());\n+            visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprAssign(ref lhs, _) => {\n             adjust_borrow_kind_for_assignment_lhs(rcx, &**lhs);\n-            visit::walk_expr(rcx, expr, ());\n+            visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprAssignOp(_, ref lhs, ref rhs) => {\n@@ -648,7 +648,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n             adjust_borrow_kind_for_assignment_lhs(rcx, &**lhs);\n \n-            visit::walk_expr(rcx, expr, ());\n+            visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprIndex(ref lhs, ref rhs) |\n@@ -660,22 +660,22 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             constrain_call(rcx, expr, Some(lhs.clone()),\n                            [rhs.clone()], true);\n \n-            visit::walk_expr(rcx, expr, ());\n+            visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprUnary(_, ref lhs) if has_method_map => {\n             // As above.\n             constrain_call(rcx, expr, Some(lhs.clone()), [], true);\n \n-            visit::walk_expr(rcx, expr, ());\n+            visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprUnary(ast::UnBox, ref base) => {\n             // Managed data must not have borrowed pointers within it:\n             let base_ty = rcx.resolve_node_type(base.id);\n             type_must_outlive(rcx, infer::Managed(expr.span),\n                               base_ty, ty::ReStatic);\n-            visit::walk_expr(rcx, expr, ());\n+            visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprUnary(ast::UnDeref, ref base) => {\n@@ -696,23 +696,23 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 _ => {}\n             }\n \n-            visit::walk_expr(rcx, expr, ());\n+            visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprIndex(ref vec_expr, _) => {\n             // For a[b], the lifetime of a must enclose the deref\n             let vec_type = rcx.resolve_expr_type_adjusted(&**vec_expr);\n             constrain_index(rcx, expr, vec_type);\n \n-            visit::walk_expr(rcx, expr, ());\n+            visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprCast(ref source, _) => {\n             // Determine if we are casting `source` to a trait\n             // instance.  If so, we have to be sure that the type of\n             // the source obeys the trait's region bound.\n             constrain_cast(rcx, expr, &**source);\n-            visit::walk_expr(rcx, expr, ());\n+            visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprAddrOf(m, ref base) => {\n@@ -728,13 +728,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             let ty0 = rcx.resolve_node_type(expr.id);\n             type_must_outlive(rcx, infer::AddrOf(expr.span),\n                               ty0, ty::ReScope(expr.id));\n-            visit::walk_expr(rcx, expr, ());\n+            visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprMatch(ref discr, ref arms) => {\n             link_match(rcx, &**discr, arms.as_slice());\n \n-            visit::walk_expr(rcx, expr, ());\n+            visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprFnBlock(_, _, ref body) |\n@@ -745,16 +745,16 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n         ast::ExprLoop(ref body, _) => {\n             let repeating_scope = rcx.set_repeating_scope(body.id);\n-            visit::walk_expr(rcx, expr, ());\n+            visit::walk_expr(rcx, expr);\n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n         ast::ExprWhile(ref cond, ref body, _) => {\n             let repeating_scope = rcx.set_repeating_scope(cond.id);\n-            rcx.visit_expr(&**cond, ());\n+            rcx.visit_expr(&**cond);\n \n             rcx.set_repeating_scope(body.id);\n-            rcx.visit_block(&**body, ());\n+            rcx.visit_block(&**body);\n \n             rcx.set_repeating_scope(repeating_scope);\n         }\n@@ -768,19 +768,19 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 link_pattern(rcx, mc, head_cmt, &**pat);\n             }\n \n-            rcx.visit_expr(&**head, ());\n+            rcx.visit_expr(&**head);\n             type_of_node_must_outlive(rcx,\n                                       infer::AddrOf(expr.span),\n                                       head.id,\n                                       ty::ReScope(expr.id));\n \n             let repeating_scope = rcx.set_repeating_scope(body.id);\n-            rcx.visit_block(&**body, ());\n+            rcx.visit_block(&**body);\n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n         _ => {\n-            visit::walk_expr(rcx, expr, ());\n+            visit::walk_expr(rcx, expr);\n         }\n     }\n }\n@@ -890,7 +890,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     }\n \n     let repeating_scope = rcx.set_repeating_scope(body.id);\n-    visit::walk_expr(rcx, expr, ());\n+    visit::walk_expr(rcx, expr);\n     rcx.set_repeating_scope(repeating_scope);\n \n     match ty::get(function_type).sty {"}, {"sha": "086887326a23cc28b7e0370cc4e028770b558bcf", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -1025,20 +1025,20 @@ pub fn trans_resolve_method(tcx: &ty::ctxt, id: ast::NodeId,\n                    false)\n }\n \n-impl<'a, 'b, 'tcx> visit::Visitor<()> for &'a FnCtxt<'b, 'tcx> {\n-    fn visit_expr(&mut self, ex: &ast::Expr, _: ()) {\n+impl<'a, 'b, 'tcx> visit::Visitor for &'a FnCtxt<'b, 'tcx> {\n+    fn visit_expr(&mut self, ex: &ast::Expr) {\n         early_resolve_expr(ex, *self, false);\n-        visit::walk_expr(self, ex, ());\n+        visit::walk_expr(self, ex);\n     }\n-    fn visit_item(&mut self, _: &ast::Item, _: ()) {\n+    fn visit_item(&mut self, _: &ast::Item) {\n         // no-op\n     }\n }\n \n // Detect points where a trait-bounded type parameter is\n // instantiated, resolve the impls for the parameters.\n pub fn resolve_in_block(mut fcx: &FnCtxt, bl: &ast::Block) {\n-    visit::walk_block(&mut fcx, bl, ());\n+    visit::walk_block(&mut fcx, bl);\n }\n \n /// Used in the kind checker after typechecking has finished. Calls"}, {"sha": "89518add83912ff024311c6f34fe9ff5a13fec04", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -41,7 +41,7 @@ use syntax::visit::Visitor;\n pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     assert_eq!(fcx.writeback_errors.get(), false);\n     let mut wbcx = WritebackCx::new(fcx);\n-    wbcx.visit_expr(e, ());\n+    wbcx.visit_expr(e);\n     wbcx.visit_upvar_borrow_map();\n     wbcx.visit_unboxed_closures();\n }\n@@ -51,9 +51,9 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n                                blk: &ast::Block) {\n     assert_eq!(fcx.writeback_errors.get(), false);\n     let mut wbcx = WritebackCx::new(fcx);\n-    wbcx.visit_block(blk, ());\n+    wbcx.visit_block(blk);\n     for arg in decl.inputs.iter() {\n-        wbcx.visit_pat(&*arg.pat, ());\n+        wbcx.visit_pat(&*arg.pat);\n \n         // Privacy needs the type for the whole pattern, not just each binding\n         if !pat_util::pat_is_binding(&fcx.tcx().def_map, &*arg.pat) {\n@@ -106,21 +106,21 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n // below. In general, a function is made into a `visitor` if it must\n // traffic in node-ids or update tables in the type context etc.\n \n-impl<'cx, 'tcx> Visitor<()> for WritebackCx<'cx, 'tcx> {\n-    fn visit_item(&mut self, _: &ast::Item, _: ()) {\n+impl<'cx, 'tcx> Visitor for WritebackCx<'cx, 'tcx> {\n+    fn visit_item(&mut self, _: &ast::Item) {\n         // Ignore items\n     }\n \n-    fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) {\n+    fn visit_stmt(&mut self, s: &ast::Stmt) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n \n         self.visit_node_id(ResolvingExpr(s.span), ty::stmt_node_id(s));\n-        visit::walk_stmt(self, s, ());\n+        visit::walk_stmt(self, s);\n     }\n \n-    fn visit_expr(&mut self, e:&ast::Expr, _: ()) {\n+    fn visit_expr(&mut self, e:&ast::Expr) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -143,19 +143,19 @@ impl<'cx, 'tcx> Visitor<()> for WritebackCx<'cx, 'tcx> {\n             _ => {}\n         }\n \n-        visit::walk_expr(self, e, ());\n+        visit::walk_expr(self, e);\n     }\n \n-    fn visit_block(&mut self, b: &ast::Block, _: ()) {\n+    fn visit_block(&mut self, b: &ast::Block) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n \n         self.visit_node_id(ResolvingExpr(b.span), b.id);\n-        visit::walk_block(self, b, ());\n+        visit::walk_block(self, b);\n     }\n \n-    fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n+    fn visit_pat(&mut self, p: &ast::Pat) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n@@ -167,27 +167,27 @@ impl<'cx, 'tcx> Visitor<()> for WritebackCx<'cx, 'tcx> {\n                p.id,\n                ty::node_id_to_type(self.tcx(), p.id).repr(self.tcx()));\n \n-        visit::walk_pat(self, p, ());\n+        visit::walk_pat(self, p);\n     }\n \n-    fn visit_local(&mut self, l: &ast::Local, _: ()) {\n+    fn visit_local(&mut self, l: &ast::Local) {\n         if self.fcx.writeback_errors.get() {\n             return;\n         }\n \n         let var_ty = self.fcx.local_ty(l.span, l.id);\n         let var_ty = self.resolve(&var_ty, ResolvingLocal(l.span));\n         write_ty_to_tcx(self.tcx(), l.id, var_ty);\n-        visit::walk_local(self, l, ());\n+        visit::walk_local(self, l);\n     }\n \n-    fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n+    fn visit_ty(&mut self, t: &ast::Ty) {\n         match t.node {\n             ast::TyFixedLengthVec(ref ty, ref count_expr) => {\n-                self.visit_ty(&**ty, ());\n+                self.visit_ty(&**ty);\n                 write_ty_to_tcx(self.tcx(), count_expr.id, ty::mk_uint());\n             }\n-            _ => visit::walk_ty(self, t, ())\n+            _ => visit::walk_ty(self, t)\n         }\n     }\n }"}, {"sha": "6a64265160948eaaf93ccdda43bc5a64c42c3d87", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -191,8 +191,8 @@ struct CoherenceCheckVisitor<'a, 'tcx: 'a> {\n     cc: &'a CoherenceChecker<'a, 'tcx>\n }\n \n-impl<'a, 'tcx> visit::Visitor<()> for CoherenceCheckVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &Item, _: ()) {\n+impl<'a, 'tcx> visit::Visitor for CoherenceCheckVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &Item) {\n \n         //debug!(\"(checking coherence) item '{}'\", token::get_ident(item.ident));\n \n@@ -210,21 +210,21 @@ impl<'a, 'tcx> visit::Visitor<()> for CoherenceCheckVisitor<'a, 'tcx> {\n             }\n         };\n \n-        visit::walk_item(self, item, ());\n+        visit::walk_item(self, item);\n     }\n }\n \n struct PrivilegedScopeVisitor<'a, 'tcx: 'a> {\n     cc: &'a CoherenceChecker<'a, 'tcx>\n }\n \n-impl<'a, 'tcx> visit::Visitor<()> for PrivilegedScopeVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &Item, _: ()) {\n+impl<'a, 'tcx> visit::Visitor for PrivilegedScopeVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &Item) {\n \n         match item.node {\n             ItemMod(ref module_) => {\n                 // Then visit the module items.\n-                visit::walk_mod(self, module_, ());\n+                visit::walk_mod(self, module_);\n             }\n             ItemImpl(_, None, ref ast_ty, _) => {\n                 if !self.cc.ast_type_is_defined_in_local_crate(&**ast_ty) {\n@@ -256,10 +256,10 @@ impl<'a, 'tcx> visit::Visitor<()> for PrivilegedScopeVisitor<'a, 'tcx> {\n                     }\n                 }\n \n-                visit::walk_item(self, item, ());\n+                visit::walk_item(self, item);\n             }\n             _ => {\n-                visit::walk_item(self, item, ());\n+                visit::walk_item(self, item);\n             }\n         }\n     }\n@@ -271,7 +271,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n         let mut visitor = CoherenceCheckVisitor { cc: self };\n-        visit::walk_crate(&mut visitor, krate, ());\n+        visit::walk_crate(&mut visitor, krate);\n \n         // Check that there are no overlapping trait instances\n         self.check_implementation_coherence();\n@@ -543,7 +543,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     // Privileged scope checking\n     fn check_privileged_scopes(&self, krate: &Crate) {\n         let mut visitor = PrivilegedScopeVisitor{ cc: self };\n-        visit::walk_crate(&mut visitor, krate, ());\n+        visit::walk_crate(&mut visitor, krate);\n     }\n \n     fn trait_ref_to_trait_def_id(&self, trait_ref: &TraitRef) -> DefId {"}, {"sha": "3af083be57a742591269027eaad535a8d7c90326", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -84,10 +84,10 @@ pub fn collect_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n     }\n \n     let mut visitor = CollectTraitDefVisitor{ ccx: ccx };\n-    visit::walk_crate(&mut visitor, krate, ());\n+    visit::walk_crate(&mut visitor, krate);\n \n     let mut visitor = CollectItemTypesVisitor{ ccx: ccx };\n-    visit::walk_crate(&mut visitor, krate, ());\n+    visit::walk_crate(&mut visitor, krate);\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -99,8 +99,8 @@ struct CollectTraitDefVisitor<'a, 'tcx: 'a> {\n     ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n-impl<'a, 'tcx> visit::Visitor<()> for CollectTraitDefVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item, _: ()) {\n+impl<'a, 'tcx> visit::Visitor for CollectTraitDefVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &ast::Item) {\n         match i.node {\n             ast::ItemTrait(..) => {\n                 // computing the trait def also fills in the table\n@@ -109,7 +109,7 @@ impl<'a, 'tcx> visit::Visitor<()> for CollectTraitDefVisitor<'a, 'tcx> {\n             _ => { }\n         }\n \n-        visit::walk_item(self, i, ());\n+        visit::walk_item(self, i);\n     }\n }\n \n@@ -120,14 +120,14 @@ struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n     ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n-impl<'a, 'tcx> visit::Visitor<()> for CollectItemTypesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item, _: ()) {\n+impl<'a, 'tcx> visit::Visitor for CollectItemTypesVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, i: &ast::Item) {\n         convert(self.ccx, i);\n-        visit::walk_item(self, i, ());\n+        visit::walk_item(self, i);\n     }\n-    fn visit_foreign_item(&mut self, i: &ast::ForeignItem, _: ()) {\n+    fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n         convert_foreign(self.ccx, i);\n-        visit::walk_foreign_item(self, i, ());\n+        visit::walk_foreign_item(self, i);\n     }\n }\n "}, {"sha": "83d7972e11c278d865eeb485c26ebf563c05af7f", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -301,7 +301,7 @@ fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n         })\n     };\n \n-    visit::walk_crate(&mut terms_cx, krate, ());\n+    visit::walk_crate(&mut terms_cx, krate);\n \n     terms_cx\n }\n@@ -337,8 +337,8 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<()> for TermsContext<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+impl<'a, 'tcx> Visitor for TermsContext<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         debug!(\"add_inferreds for item {}\", item.repr(self.tcx));\n \n         let inferreds_on_entry = self.num_inferred();\n@@ -379,7 +379,7 @@ impl<'a, 'tcx> Visitor<()> for TermsContext<'a, 'tcx> {\n                     assert!(newly_added);\n                 }\n \n-                visit::walk_item(self, item, ());\n+                visit::walk_item(self, item);\n             }\n \n             ast::ItemImpl(..) |\n@@ -389,7 +389,7 @@ impl<'a, 'tcx> Visitor<()> for TermsContext<'a, 'tcx> {\n             ast::ItemForeignMod(..) |\n             ast::ItemTy(..) |\n             ast::ItemMac(..) => {\n-                visit::walk_item(self, item, ());\n+                visit::walk_item(self, item);\n             }\n         }\n     }\n@@ -473,12 +473,12 @@ fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>,\n         bivariant: bivariant,\n         constraints: Vec::new(),\n     };\n-    visit::walk_crate(&mut constraint_cx, krate, ());\n+    visit::walk_crate(&mut constraint_cx, krate);\n     constraint_cx\n }\n \n-impl<'a, 'tcx> Visitor<()> for ConstraintContext<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+impl<'a, 'tcx> Visitor for ConstraintContext<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         let did = ast_util::local_def(item.id);\n         let tcx = self.terms_cx.tcx;\n \n@@ -533,7 +533,7 @@ impl<'a, 'tcx> Visitor<()> for ConstraintContext<'a, 'tcx> {\n             ast::ItemTy(..) |\n             ast::ItemImpl(..) |\n             ast::ItemMac(..) => {\n-                visit::walk_item(self, item, ());\n+                visit::walk_item(self, item);\n             }\n         }\n     }"}, {"sha": "0375ddbd37126ff20459cfd9757d3723b2f6546e", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -47,7 +47,7 @@ pub fn check_crate(krate: &ast::Crate,\n \n     {\n         let mut cx = Context { sess: sess, items: items };\n-        visit::walk_crate(&mut cx, krate, ());\n+        visit::walk_crate(&mut cx, krate);\n     }\n     verify(sess, items);\n }\n@@ -105,13 +105,13 @@ impl<'a> Context<'a> {\n     }\n }\n \n-impl<'a> Visitor<()> for Context<'a> {\n-    fn visit_foreign_item(&mut self, i: &ast::ForeignItem, _: ()) {\n+impl<'a> Visitor for Context<'a> {\n+    fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n         match lang_items::extract(i.attrs.as_slice()) {\n             None => {}\n             Some(lang_item) => self.register(lang_item.get(), i.span),\n         }\n-        visit::walk_foreign_item(self, i, ())\n+        visit::walk_foreign_item(self, i)\n     }\n }\n "}, {"sha": "f02251350a4bca868988ee61873713c502e27b58", "filename": "src/librustc/plugin/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fplugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fplugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fbuild.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -21,8 +21,8 @@ struct RegistrarFinder {\n     registrars: Vec<(ast::NodeId, Span)> ,\n }\n \n-impl Visitor<()> for RegistrarFinder {\n-    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n+impl Visitor for RegistrarFinder {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         match item.node {\n             ast::ItemFn(..) => {\n                 if attr::contains_name(item.attrs.as_slice(),\n@@ -33,15 +33,15 @@ impl Visitor<()> for RegistrarFinder {\n             _ => {}\n         }\n \n-        visit::walk_item(self, item, ());\n+        visit::walk_item(self, item);\n     }\n }\n \n /// Find the function marked with `#[plugin_registrar]`, if any.\n pub fn find_plugin_registrar(diagnostic: &diagnostic::SpanHandler,\n                              krate: &ast::Crate) -> Option<ast::NodeId> {\n     let mut finder = RegistrarFinder { registrars: Vec::new() };\n-    visit::walk_crate(&mut finder, krate, ());\n+    visit::walk_crate(&mut finder, krate);\n \n     match finder.registrars.len() {\n         0 => None,"}, {"sha": "31265cc757159f41b63e51d5fe98284793a224c5", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -69,7 +69,7 @@ impl<'a> PluginLoader<'a> {\n pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n                     addl_plugins: Option<Plugins>) -> Plugins {\n     let mut loader = PluginLoader::new(sess);\n-    visit::walk_crate(&mut loader, krate, ());\n+    visit::walk_crate(&mut loader, krate);\n \n     let mut plugins = loader.plugins;\n \n@@ -87,8 +87,8 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n }\n \n // note that macros aren't expanded yet, and therefore macros can't add plugins.\n-impl<'a> Visitor<()> for PluginLoader<'a> {\n-    fn visit_view_item(&mut self, vi: &ast::ViewItem, _: ()) {\n+impl<'a> Visitor for PluginLoader<'a> {\n+    fn visit_view_item(&mut self, vi: &ast::ViewItem) {\n         match vi.node {\n             ast::ViewItemExternCrate(name, _, _) => {\n                 let mut plugin_phase = false;\n@@ -124,7 +124,7 @@ impl<'a> Visitor<()> for PluginLoader<'a> {\n             _ => (),\n         }\n     }\n-    fn visit_mac(&mut self, _: &ast::Mac, _:()) {\n+    fn visit_mac(&mut self, _: &ast::Mac) {\n         // bummer... can't see plugins inside macros.\n         // do nothing.\n     }"}, {"sha": "b230b56a6cefbd9f3c3ace1c560a0fddf27115e3", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -62,14 +62,14 @@ struct LoopQueryVisitor<'a> {\n     flag: bool,\n }\n \n-impl<'a> Visitor<()> for LoopQueryVisitor<'a> {\n-    fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n+impl<'a> Visitor for LoopQueryVisitor<'a> {\n+    fn visit_expr(&mut self, e: &ast::Expr) {\n         self.flag |= (self.p)(&e.node);\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n           // break inside the outer loop\n           ast::ExprLoop(..) | ast::ExprWhile(..) | ast::ExprForLoop(..) => {}\n-          _ => visit::walk_expr(self, e, ())\n+          _ => visit::walk_expr(self, e)\n         }\n     }\n }\n@@ -81,7 +81,7 @@ pub fn loop_query(b: &ast::Block, p: |&ast::Expr_| -> bool) -> bool {\n         p: p,\n         flag: false,\n     };\n-    visit::walk_block(&mut v, b, ());\n+    visit::walk_block(&mut v, b);\n     return v.flag;\n }\n \n@@ -90,10 +90,10 @@ struct BlockQueryVisitor<'a> {\n     flag: bool,\n }\n \n-impl<'a> Visitor<()> for BlockQueryVisitor<'a> {\n-    fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n+impl<'a> Visitor for BlockQueryVisitor<'a> {\n+    fn visit_expr(&mut self, e: &ast::Expr) {\n         self.flag |= (self.p)(e);\n-        visit::walk_expr(self, e, ())\n+        visit::walk_expr(self, e)\n     }\n }\n \n@@ -104,7 +104,7 @@ pub fn block_query(b: ast::P<ast::Block>, p: |&ast::Expr| -> bool) -> bool {\n         p: p,\n         flag: false,\n     };\n-    visit::walk_block(&mut v, &*b, ());\n+    visit::walk_block(&mut v, &*b);\n     return v.flag;\n }\n "}, {"sha": "a34dcc41cc3d72efc011388bb54ae90c3b2066df", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 53, "deletions": 56, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -86,7 +86,7 @@ impl Svh {\n \n         {\n             let mut visit = svh_visitor::make(&mut state);\n-            visit::walk_crate(&mut visit, krate, ());\n+            visit::walk_crate(&mut visit, krate);\n         }\n \n         // FIXME (#14132): This hash is still sensitive to e.g. the\n@@ -322,12 +322,9 @@ mod svh_visitor {\n     }\n     fn content<K:InternKey>(k: K) -> token::InternedString { k.get_content() }\n \n-    // local short-hand eases writing signatures of syntax::visit mod.\n-    type E = ();\n+    impl<'a> Visitor for StrictVersionHashVisitor<'a> {\n \n-    impl<'a> Visitor<E> for StrictVersionHashVisitor<'a> {\n-\n-        fn visit_mac(&mut self, macro: &Mac, e: E) {\n+        fn visit_mac(&mut self, macro: &Mac) {\n             // macro invocations, namely macro_rules definitions,\n             // *can* appear as items, even in the expanded crate AST.\n \n@@ -350,7 +347,7 @@ mod svh_visitor {\n                       pprust::to_string(|pp_state| pp_state.print_mac(macro)));\n             }\n \n-            visit::walk_mac(self, macro, e);\n+            visit::walk_mac(self, macro);\n \n             fn macro_name(macro: &Mac) -> token::InternedString {\n                 match &macro.node {\n@@ -364,26 +361,26 @@ mod svh_visitor {\n         }\n \n         fn visit_struct_def(&mut self, s: &StructDef, ident: Ident,\n-                            g: &Generics, _: NodeId, e: E) {\n+                            g: &Generics, _: NodeId) {\n             SawStructDef(content(ident)).hash(self.st);\n-            visit::walk_generics(self, g, e.clone());\n-            visit::walk_struct_def(self, s, e)\n+            visit::walk_generics(self, g);\n+            visit::walk_struct_def(self, s)\n         }\n \n-        fn visit_variant(&mut self, v: &Variant, g: &Generics, e: E) {\n+        fn visit_variant(&mut self, v: &Variant, g: &Generics) {\n             SawVariant.hash(self.st);\n             // walk_variant does not call walk_generics, so do it here.\n-            visit::walk_generics(self, g, e.clone());\n-            visit::walk_variant(self, v, g, e)\n+            visit::walk_generics(self, g);\n+            visit::walk_variant(self, v, g)\n         }\n \n-        fn visit_opt_lifetime_ref(&mut self, _: Span, l: &Option<Lifetime>, env: E) {\n+        fn visit_opt_lifetime_ref(&mut self, _: Span, l: &Option<Lifetime>) {\n             SawOptLifetimeRef.hash(self.st);\n             // (This is a strange method in the visitor trait, in that\n             // it does not expose a walk function to do the subroutine\n             // calls.)\n             match *l {\n-                Some(ref l) => self.visit_lifetime_ref(l, env),\n+                Some(ref l) => self.visit_lifetime_ref(l),\n                 None => ()\n             }\n         }\n@@ -402,15 +399,15 @@ mod svh_visitor {\n         // (If you edit a method such that it deviates from the\n         // pattern, please move that method up above this comment.)\n \n-        fn visit_ident(&mut self, _: Span, ident: Ident, _: E) {\n+        fn visit_ident(&mut self, _: Span, ident: Ident) {\n             SawIdent(content(ident)).hash(self.st);\n         }\n \n-        fn visit_lifetime_ref(&mut self, l: &Lifetime, _: E) {\n+        fn visit_lifetime_ref(&mut self, l: &Lifetime) {\n             SawLifetimeRef(content(l.name)).hash(self.st);\n         }\n \n-        fn visit_lifetime_decl(&mut self, l: &LifetimeDef, _: E) {\n+        fn visit_lifetime_decl(&mut self, l: &LifetimeDef) {\n             SawLifetimeDecl(content(l.lifetime.name)).hash(self.st);\n         }\n \n@@ -419,15 +416,15 @@ mod svh_visitor {\n         // monomorphization and cross-crate inlining generally implies\n         // that a change to a crate body will require downstream\n         // crates to be recompiled.\n-        fn visit_expr(&mut self, ex: &Expr, e: E) {\n-            SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex, e)\n+        fn visit_expr(&mut self, ex: &Expr) {\n+            SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n         }\n \n-        fn visit_stmt(&mut self, s: &Stmt, e: E) {\n-            SawStmt(saw_stmt(&s.node)).hash(self.st); visit::walk_stmt(self, s, e)\n+        fn visit_stmt(&mut self, s: &Stmt) {\n+            SawStmt(saw_stmt(&s.node)).hash(self.st); visit::walk_stmt(self, s)\n         }\n \n-        fn visit_view_item(&mut self, i: &ViewItem, e: E) {\n+        fn visit_view_item(&mut self, i: &ViewItem) {\n             // Two kinds of view items can affect the ABI for a crate:\n             // exported `pub use` view items (since that may expose\n             // items that downstream crates can call), and `use\n@@ -437,79 +434,79 @@ mod svh_visitor {\n             // The simplest approach to handling both of the above is\n             // just to adopt the same simple-minded (fine-grained)\n             // hash that I am deploying elsewhere here.\n-            SawViewItem.hash(self.st); visit::walk_view_item(self, i, e)\n+            SawViewItem.hash(self.st); visit::walk_view_item(self, i)\n         }\n \n-        fn visit_foreign_item(&mut self, i: &ForeignItem, e: E) {\n+        fn visit_foreign_item(&mut self, i: &ForeignItem) {\n             // FIXME (#14132) ideally we would incorporate privacy (or\n             // perhaps reachability) somewhere here, so foreign items\n             // that do not leak into downstream crates would not be\n             // part of the ABI.\n-            SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i, e)\n+            SawForeignItem.hash(self.st); visit::walk_foreign_item(self, i)\n         }\n \n-        fn visit_item(&mut self, i: &Item, e: E) {\n+        fn visit_item(&mut self, i: &Item) {\n             // FIXME (#14132) ideally would incorporate reachability\n             // analysis somewhere here, so items that never leak into\n             // downstream crates (e.g. via monomorphisation or\n             // inlining) would not be part of the ABI.\n-            SawItem.hash(self.st); visit::walk_item(self, i, e)\n+            SawItem.hash(self.st); visit::walk_item(self, i)\n         }\n \n-        fn visit_mod(&mut self, m: &Mod, _s: Span, _n: NodeId, e: E) {\n-            SawMod.hash(self.st); visit::walk_mod(self, m, e)\n+        fn visit_mod(&mut self, m: &Mod, _s: Span, _n: NodeId) {\n+            SawMod.hash(self.st); visit::walk_mod(self, m)\n         }\n \n-        fn visit_decl(&mut self, d: &Decl, e: E) {\n-            SawDecl.hash(self.st); visit::walk_decl(self, d, e)\n+        fn visit_decl(&mut self, d: &Decl) {\n+            SawDecl.hash(self.st); visit::walk_decl(self, d)\n         }\n \n-        fn visit_ty(&mut self, t: &Ty, e: E) {\n-            SawTy.hash(self.st); visit::walk_ty(self, t, e)\n+        fn visit_ty(&mut self, t: &Ty) {\n+            SawTy.hash(self.st); visit::walk_ty(self, t)\n         }\n \n-        fn visit_generics(&mut self, g: &Generics, e: E) {\n-            SawGenerics.hash(self.st); visit::walk_generics(self, g, e)\n+        fn visit_generics(&mut self, g: &Generics) {\n+            SawGenerics.hash(self.st); visit::walk_generics(self, g)\n         }\n \n-        fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId, e: E) {\n-            SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s, e)\n+        fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId) {\n+            SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s)\n         }\n \n-        fn visit_ty_method(&mut self, t: &TypeMethod, e: E) {\n-            SawTyMethod.hash(self.st); visit::walk_ty_method(self, t, e)\n+        fn visit_ty_method(&mut self, t: &TypeMethod) {\n+            SawTyMethod.hash(self.st); visit::walk_ty_method(self, t)\n         }\n \n-        fn visit_trait_item(&mut self, t: &TraitItem, e: E) {\n-            SawTraitMethod.hash(self.st); visit::walk_trait_item(self, t, e)\n+        fn visit_trait_item(&mut self, t: &TraitItem) {\n+            SawTraitMethod.hash(self.st); visit::walk_trait_item(self, t)\n         }\n \n-        fn visit_struct_field(&mut self, s: &StructField, e: E) {\n-            SawStructField.hash(self.st); visit::walk_struct_field(self, s, e)\n+        fn visit_struct_field(&mut self, s: &StructField) {\n+            SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n         }\n \n-        fn visit_explicit_self(&mut self, es: &ExplicitSelf, e: E) {\n-            SawExplicitSelf.hash(self.st); visit::walk_explicit_self(self, es, e)\n+        fn visit_explicit_self(&mut self, es: &ExplicitSelf) {\n+            SawExplicitSelf.hash(self.st); visit::walk_explicit_self(self, es)\n         }\n \n-        fn visit_path(&mut self, path: &Path, _: ast::NodeId, e: E) {\n-            SawPath.hash(self.st); visit::walk_path(self, path, e)\n+        fn visit_path(&mut self, path: &Path, _: ast::NodeId) {\n+            SawPath.hash(self.st); visit::walk_path(self, path)\n         }\n \n-        fn visit_block(&mut self, b: &Block, e: E) {\n-            SawBlock.hash(self.st); visit::walk_block(self, b, e)\n+        fn visit_block(&mut self, b: &Block) {\n+            SawBlock.hash(self.st); visit::walk_block(self, b)\n         }\n \n-        fn visit_pat(&mut self, p: &Pat, e: E) {\n-            SawPat.hash(self.st); visit::walk_pat(self, p, e)\n+        fn visit_pat(&mut self, p: &Pat) {\n+            SawPat.hash(self.st); visit::walk_pat(self, p)\n         }\n \n-        fn visit_local(&mut self, l: &Local, e: E) {\n-            SawLocal.hash(self.st); visit::walk_local(self, l, e)\n+        fn visit_local(&mut self, l: &Local) {\n+            SawLocal.hash(self.st); visit::walk_local(self, l)\n         }\n \n-        fn visit_arm(&mut self, a: &Arm, e: E) {\n-            SawArm.hash(self.st); visit::walk_arm(self, a, e)\n+        fn visit_arm(&mut self, a: &Arm) {\n+            SawArm.hash(self.st); visit::walk_arm(self, a)\n         }\n     }\n }"}, {"sha": "3db71c6d3097e46ea38d9c2056dbbbf7618185e1", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -366,17 +366,16 @@ impl<'a, O: IdVisitingOperation> IdVisitor<'a, O> {\n     }\n }\n \n-impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n+impl<'a, O: IdVisitingOperation> Visitor for IdVisitor<'a, O> {\n     fn visit_mod(&mut self,\n                  module: &Mod,\n                  _: Span,\n-                 node_id: NodeId,\n-                 env: ()) {\n+                 node_id: NodeId) {\n         self.operation.visit_id(node_id);\n-        visit::walk_mod(self, module, env)\n+        visit::walk_mod(self, module)\n     }\n \n-    fn visit_view_item(&mut self, view_item: &ViewItem, env: ()) {\n+    fn visit_view_item(&mut self, view_item: &ViewItem) {\n         if !self.pass_through_items {\n             if self.visited_outermost {\n                 return;\n@@ -403,16 +402,16 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n                 }\n             }\n         }\n-        visit::walk_view_item(self, view_item, env);\n+        visit::walk_view_item(self, view_item);\n         self.visited_outermost = false;\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem, env: ()) {\n+    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n         self.operation.visit_id(foreign_item.id);\n-        visit::walk_foreign_item(self, foreign_item, env)\n+        visit::walk_foreign_item(self, foreign_item)\n     }\n \n-    fn visit_item(&mut self, item: &Item, env: ()) {\n+    fn visit_item(&mut self, item: &Item) {\n         if !self.pass_through_items {\n             if self.visited_outermost {\n                 return\n@@ -431,57 +430,56 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n             _ => {}\n         }\n \n-        visit::walk_item(self, item, env);\n+        visit::walk_item(self, item);\n \n         self.visited_outermost = false\n     }\n \n-    fn visit_local(&mut self, local: &Local, env: ()) {\n+    fn visit_local(&mut self, local: &Local) {\n         self.operation.visit_id(local.id);\n-        visit::walk_local(self, local, env)\n+        visit::walk_local(self, local)\n     }\n \n-    fn visit_block(&mut self, block: &Block, env: ()) {\n+    fn visit_block(&mut self, block: &Block) {\n         self.operation.visit_id(block.id);\n-        visit::walk_block(self, block, env)\n+        visit::walk_block(self, block)\n     }\n \n-    fn visit_stmt(&mut self, statement: &Stmt, env: ()) {\n+    fn visit_stmt(&mut self, statement: &Stmt) {\n         self.operation.visit_id(ast_util::stmt_id(statement));\n-        visit::walk_stmt(self, statement, env)\n+        visit::walk_stmt(self, statement)\n     }\n \n-    fn visit_pat(&mut self, pattern: &Pat, env: ()) {\n+    fn visit_pat(&mut self, pattern: &Pat) {\n         self.operation.visit_id(pattern.id);\n-        visit::walk_pat(self, pattern, env)\n+        visit::walk_pat(self, pattern)\n     }\n \n-    fn visit_expr(&mut self, expression: &Expr, env: ()) {\n+    fn visit_expr(&mut self, expression: &Expr) {\n         self.operation.visit_id(expression.id);\n-        visit::walk_expr(self, expression, env)\n+        visit::walk_expr(self, expression)\n     }\n \n-    fn visit_ty(&mut self, typ: &Ty, env: ()) {\n+    fn visit_ty(&mut self, typ: &Ty) {\n         self.operation.visit_id(typ.id);\n         match typ.node {\n             TyPath(_, _, id) => self.operation.visit_id(id),\n             _ => {}\n         }\n-        visit::walk_ty(self, typ, env)\n+        visit::walk_ty(self, typ)\n     }\n \n-    fn visit_generics(&mut self, generics: &Generics, env: ()) {\n+    fn visit_generics(&mut self, generics: &Generics) {\n         self.visit_generics_helper(generics);\n-        visit::walk_generics(self, generics, env)\n+        visit::walk_generics(self, generics)\n     }\n \n     fn visit_fn(&mut self,\n                 function_kind: &visit::FnKind,\n                 function_declaration: &FnDecl,\n                 block: &Block,\n                 span: Span,\n-                node_id: NodeId,\n-                env: ()) {\n+                node_id: NodeId) {\n         if !self.pass_through_items {\n             match *function_kind {\n                 visit::FkMethod(..) if self.visited_outermost => return,\n@@ -508,8 +506,7 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n                         function_kind,\n                         function_declaration,\n                         block,\n-                        span,\n-                        env);\n+                        span);\n \n         if !self.pass_through_items {\n             match *function_kind {\n@@ -519,28 +516,27 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n         }\n     }\n \n-    fn visit_struct_field(&mut self, struct_field: &StructField, env: ()) {\n+    fn visit_struct_field(&mut self, struct_field: &StructField) {\n         self.operation.visit_id(struct_field.node.id);\n-        visit::walk_struct_field(self, struct_field, env)\n+        visit::walk_struct_field(self, struct_field)\n     }\n \n     fn visit_struct_def(&mut self,\n                         struct_def: &StructDef,\n                         _: ast::Ident,\n                         _: &ast::Generics,\n-                        id: NodeId,\n-                        _: ()) {\n+                        id: NodeId) {\n         self.operation.visit_id(id);\n         struct_def.ctor_id.map(|ctor_id| self.operation.visit_id(ctor_id));\n-        visit::walk_struct_def(self, struct_def, ());\n+        visit::walk_struct_def(self, struct_def);\n     }\n \n-    fn visit_trait_item(&mut self, tm: &ast::TraitItem, _: ()) {\n+    fn visit_trait_item(&mut self, tm: &ast::TraitItem) {\n         match *tm {\n             ast::RequiredMethod(ref m) => self.operation.visit_id(m.id),\n             ast::ProvidedMethod(ref m) => self.operation.visit_id(m.id),\n         }\n-        visit::walk_trait_item(self, tm, ());\n+        visit::walk_trait_item(self, tm);\n     }\n }\n \n@@ -552,7 +548,7 @@ pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &InlinedItem,\n         visited_outermost: false,\n     };\n \n-    visit::walk_inlined_item(&mut id_visitor, item, ());\n+    visit::walk_inlined_item(&mut id_visitor, item);\n }\n \n struct IdRangeComputingVisitor {\n@@ -595,7 +591,7 @@ pub fn compute_id_range_for_fn_body(fk: &visit::FnKind,\n         pass_through_items: false,\n         visited_outermost: false,\n     };\n-    id_visitor.visit_fn(fk, decl, body, sp, id, ());\n+    id_visitor.visit_fn(fk, decl, body, sp, id);\n     visitor.result.get()\n }\n \n@@ -643,8 +639,8 @@ struct EachViewItemData<'a> {\n     callback: |&ast::ViewItem|: 'a -> bool,\n }\n \n-impl<'a> Visitor<()> for EachViewItemData<'a> {\n-    fn visit_view_item(&mut self, view_item: &ast::ViewItem, _: ()) {\n+impl<'a> Visitor for EachViewItemData<'a> {\n+    fn visit_view_item(&mut self, view_item: &ast::ViewItem) {\n         let _ = (self.callback)(view_item);\n     }\n }\n@@ -654,7 +650,7 @@ impl EachViewItem for ast::Crate {\n         let mut visit = EachViewItemData {\n             callback: f,\n         };\n-        visit::walk_crate(&mut visit, self, ());\n+        visit::walk_crate(&mut visit, self);\n         true\n     }\n }"}, {"sha": "04df6d618e92767e02f689bb1a641952d1852289", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -648,37 +648,37 @@ fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n /// array\n #[deriving(Clone)]\n struct PatIdentFinder {\n-    ident_accumulator: Vec<ast::Ident> ,\n+    ident_accumulator: Vec<ast::Ident>\n }\n \n-impl Visitor<()> for PatIdentFinder {\n-    fn visit_pat(&mut self, pattern: &ast::Pat, _: ()) {\n+impl Visitor for PatIdentFinder {\n+    fn visit_pat(&mut self, pattern: &ast::Pat) {\n         match *pattern {\n             ast::Pat { id: _, node: ast::PatIdent(_, ref path1, ref inner), span: _ } => {\n                 self.ident_accumulator.push(path1.node);\n                 // visit optional subpattern of PatIdent:\n                 for subpat in inner.iter() {\n-                    self.visit_pat(&**subpat, ())\n+                    self.visit_pat(&**subpat)\n                 }\n             }\n             // use the default traversal for non-PatIdents\n-            _ => visit::walk_pat(self, pattern, ())\n+            _ => visit::walk_pat(self, pattern)\n         }\n     }\n }\n \n /// find the PatIdent paths in a pattern\n-fn pattern_bindings(pat : &ast::Pat) -> Vec<ast::Ident> {\n+fn pattern_bindings(pat: &ast::Pat) -> Vec<ast::Ident> {\n     let mut name_finder = PatIdentFinder{ident_accumulator:Vec::new()};\n-    name_finder.visit_pat(pat,());\n+    name_finder.visit_pat(pat);\n     name_finder.ident_accumulator\n }\n \n /// find the PatIdent paths in a\n fn fn_decl_arg_bindings(fn_decl: &ast::FnDecl) -> Vec<ast::Ident> {\n     let mut pat_idents = PatIdentFinder{ident_accumulator:Vec::new()};\n     for arg in fn_decl.inputs.iter() {\n-        pat_idents.visit_pat(&*arg.pat, ());\n+        pat_idents.visit_pat(&*arg.pat);\n     }\n     pat_idents.ident_accumulator\n }\n@@ -1099,16 +1099,16 @@ fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {\n \n /// Check that there are no macro invocations left in the AST:\n pub fn check_for_macros(sess: &parse::ParseSess, krate: &ast::Crate) {\n-    visit::walk_crate(&mut MacroExterminator{sess:sess}, krate, ());\n+    visit::walk_crate(&mut MacroExterminator{sess:sess}, krate);\n }\n \n /// A visitor that ensures that no macro invocations remain in an AST.\n struct MacroExterminator<'a>{\n     sess: &'a parse::ParseSess\n }\n \n-impl<'a> visit::Visitor<()> for MacroExterminator<'a> {\n-    fn visit_mac(&mut self, macro: &ast::Mac, _:()) {\n+impl<'a> Visitor for MacroExterminator<'a> {\n+    fn visit_mac(&mut self, macro: &ast::Mac) {\n         self.sess.span_diagnostic.span_bug(macro.span,\n                                            \"macro exterminator: expected AST \\\n                                            with no macro invocations\");\n@@ -1144,42 +1144,41 @@ mod test {\n         path_accumulator: Vec<ast::Path> ,\n     }\n \n-    impl Visitor<()> for PathExprFinderContext {\n-\n-        fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n-            match *expr {\n-                ast::Expr{id:_,span:_,node:ast::ExprPath(ref p)} => {\n+    impl Visitor for PathExprFinderContext {\n+        fn visit_expr(&mut self, expr: &ast::Expr) {\n+            match expr.node {\n+                ast::ExprPath(ref p) => {\n                     self.path_accumulator.push(p.clone());\n                     // not calling visit_path, but it should be fine.\n                 }\n-                _ => visit::walk_expr(self,expr,())\n+                _ => visit::walk_expr(self, expr)\n             }\n         }\n     }\n \n     // find the variable references in a crate\n     fn crate_varrefs(the_crate : &ast::Crate) -> Vec<ast::Path> {\n         let mut path_finder = PathExprFinderContext{path_accumulator:Vec::new()};\n-        visit::walk_crate(&mut path_finder, the_crate, ());\n+        visit::walk_crate(&mut path_finder, the_crate);\n         path_finder.path_accumulator\n     }\n \n     /// A Visitor that extracts the identifiers from a thingy.\n     // as a side note, I'm starting to want to abstract over these....\n-    struct IdentFinder{\n+    struct IdentFinder {\n         ident_accumulator: Vec<ast::Ident>\n     }\n \n-    impl Visitor<()> for IdentFinder {\n-        fn visit_ident(&mut self, _: codemap::Span, id: ast::Ident, _: ()){\n+    impl Visitor for IdentFinder {\n+        fn visit_ident(&mut self, _: codemap::Span, id: ast::Ident){\n             self.ident_accumulator.push(id);\n         }\n     }\n \n     /// Find the idents in a crate\n     fn crate_idents(the_crate: &ast::Crate) -> Vec<ast::Ident> {\n         let mut ident_finder = IdentFinder{ident_accumulator: Vec::new()};\n-        visit::walk_crate(&mut ident_finder, the_crate, ());\n+        visit::walk_crate(&mut ident_finder, the_crate);\n         ident_finder.ident_accumulator\n     }\n \n@@ -1277,7 +1276,7 @@ mod test {\n     // find the pat_ident paths in a crate\n     fn crate_bindings(the_crate : &ast::Crate) -> Vec<ast::Ident> {\n         let mut name_finder = PatIdentFinder{ident_accumulator:Vec::new()};\n-        visit::walk_crate(&mut name_finder, the_crate, ());\n+        visit::walk_crate(&mut name_finder, the_crate);\n         name_finder.ident_accumulator\n     }\n "}, {"sha": "c31082ddf5952fc8f2a11feb2fe36862509bffd9", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 281, "deletions": 325, "changes": 606, "blob_url": "https://github.com/rust-lang/rust/blob/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a09dbf28e64e7ac9b9786320d90a87854615d77a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=a09dbf28e64e7ac9b9786320d90a87854615d77a", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Context-passing AST walker. Each overridden visit method has full control\n-//! over what happens with its node, it can do its own traversal of the node's\n-//! children (potentially passing in different contexts to each), call\n-//! `visit::visit_*` to apply the default traversal algorithm (again, it can\n-//! override the context), or prevent deeper traversal by doing nothing.\n+//! AST walker. Each overridden visit method has full control over what\n+//! happens with its node, it can do its own traversal of the node's children,\n+//! call `visit::walk_*` to apply the default traversal algorithm, or prevent\n+//! deeper traversal by doing nothing.\n //!\n //! Note: it is an important invariant that the default visitor walks the body\n //! of a function in \"execution order\" (more concretely, reverse post-order\n@@ -72,805 +71,762 @@ pub fn generics_of_fn(fk: &FnKind) -> Generics {\n /// explicitly, you need to override each method.  (And you also need\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n-pub trait Visitor<E: Clone> {\n+pub trait Visitor {\n \n-    fn visit_ident(&mut self, _sp: Span, _ident: Ident, _e: E) {\n+    fn visit_ident(&mut self, _sp: Span, _ident: Ident) {\n         /*! Visit the idents */\n     }\n-    fn visit_mod(&mut self, m: &Mod, _s: Span, _n: NodeId, e: E) { walk_mod(self, m, e) }\n-    fn visit_view_item(&mut self, i: &ViewItem, e: E) { walk_view_item(self, i, e) }\n-    fn visit_foreign_item(&mut self, i: &ForeignItem, e: E) { walk_foreign_item(self, i, e) }\n-    fn visit_item(&mut self, i: &Item, e: E) { walk_item(self, i, e) }\n-    fn visit_local(&mut self, l: &Local, e: E) { walk_local(self, l, e) }\n-    fn visit_block(&mut self, b: &Block, e: E) { walk_block(self, b, e) }\n-    fn visit_stmt(&mut self, s: &Stmt, e: E) { walk_stmt(self, s, e) }\n-    fn visit_arm(&mut self, a: &Arm, e: E) { walk_arm(self, a, e) }\n-    fn visit_pat(&mut self, p: &Pat, e: E) { walk_pat(self, p, e) }\n-    fn visit_decl(&mut self, d: &Decl, e: E) { walk_decl(self, d, e) }\n-    fn visit_expr(&mut self, ex: &Expr, e: E) { walk_expr(self, ex, e) }\n-    fn visit_expr_post(&mut self, _ex: &Expr, _e: E) { }\n-    fn visit_ty(&mut self, t: &Ty, e: E) { walk_ty(self, t, e) }\n-    fn visit_generics(&mut self, g: &Generics, e: E) { walk_generics(self, g, e) }\n-    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId, e: E) {\n-        walk_fn(self, fk, fd, b, s, e)\n-    }\n-    fn visit_ty_method(&mut self, t: &TypeMethod, e: E) { walk_ty_method(self, t, e) }\n-    fn visit_trait_item(&mut self, t: &TraitItem, e: E) { walk_trait_item(self, t, e) }\n-    fn visit_struct_def(&mut self, s: &StructDef, _: Ident, _: &Generics, _: NodeId, e: E) {\n-        walk_struct_def(self, s, e)\n-    }\n-    fn visit_struct_field(&mut self, s: &StructField, e: E) { walk_struct_field(self, s, e) }\n-    fn visit_variant(&mut self, v: &Variant, g: &Generics, e: E) { walk_variant(self, v, g, e) }\n+    fn visit_mod(&mut self, m: &Mod, _s: Span, _n: NodeId) { walk_mod(self, m) }\n+    fn visit_view_item(&mut self, i: &ViewItem) { walk_view_item(self, i) }\n+    fn visit_foreign_item(&mut self, i: &ForeignItem) { walk_foreign_item(self, i) }\n+    fn visit_item(&mut self, i: &Item) { walk_item(self, i) }\n+    fn visit_local(&mut self, l: &Local) { walk_local(self, l) }\n+    fn visit_block(&mut self, b: &Block) { walk_block(self, b) }\n+    fn visit_stmt(&mut self, s: &Stmt) { walk_stmt(self, s) }\n+    fn visit_arm(&mut self, a: &Arm) { walk_arm(self, a) }\n+    fn visit_pat(&mut self, p: &Pat) { walk_pat(self, p) }\n+    fn visit_decl(&mut self, d: &Decl) { walk_decl(self, d) }\n+    fn visit_expr(&mut self, ex: &Expr) { walk_expr(self, ex) }\n+    fn visit_expr_post(&mut self, _ex: &Expr) { }\n+    fn visit_ty(&mut self, t: &Ty) { walk_ty(self, t) }\n+    fn visit_generics(&mut self, g: &Generics) { walk_generics(self, g) }\n+    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, _: NodeId) {\n+        walk_fn(self, fk, fd, b, s)\n+    }\n+    fn visit_ty_method(&mut self, t: &TypeMethod) { walk_ty_method(self, t) }\n+    fn visit_trait_item(&mut self, t: &TraitItem) { walk_trait_item(self, t) }\n+    fn visit_struct_def(&mut self, s: &StructDef, _: Ident, _: &Generics, _: NodeId) {\n+        walk_struct_def(self, s)\n+    }\n+    fn visit_struct_field(&mut self, s: &StructField) { walk_struct_field(self, s) }\n+    fn visit_variant(&mut self, v: &Variant, g: &Generics) { walk_variant(self, v, g) }\n     fn visit_opt_lifetime_ref(&mut self,\n                               _span: Span,\n-                              opt_lifetime: &Option<Lifetime>,\n-                              env: E) {\n+                              opt_lifetime: &Option<Lifetime>) {\n         /*!\n          * Visits an optional reference to a lifetime. The `span` is\n          * the span of some surrounding reference should opt_lifetime\n          * be None.\n          */\n         match *opt_lifetime {\n-            Some(ref l) => self.visit_lifetime_ref(l, env),\n+            Some(ref l) => self.visit_lifetime_ref(l),\n             None => ()\n         }\n     }\n-    fn visit_lifetime_ref(&mut self, _lifetime: &Lifetime, _e: E) {\n+    fn visit_lifetime_ref(&mut self, _lifetime: &Lifetime) {\n         /*! Visits a reference to a lifetime */\n     }\n-    fn visit_lifetime_decl(&mut self, _lifetime: &LifetimeDef, _e: E) {\n+    fn visit_lifetime_decl(&mut self, _lifetime: &LifetimeDef) {\n         /*! Visits a declaration of a lifetime */\n     }\n-    fn visit_explicit_self(&mut self, es: &ExplicitSelf, e: E) {\n-        walk_explicit_self(self, es, e)\n+    fn visit_explicit_self(&mut self, es: &ExplicitSelf) {\n+        walk_explicit_self(self, es)\n     }\n-    fn visit_mac(&mut self, _macro: &Mac, _e: E) {\n+    fn visit_mac(&mut self, _macro: &Mac) {\n         fail!(\"visit_mac disabled by default\");\n         // NB: see note about macros above.\n         // if you really want a visitor that\n         // works on macros, use this\n         // definition in your trait impl:\n-        // visit::walk_mac(self, _macro, _e)\n+        // visit::walk_mac(self, _macro)\n     }\n-    fn visit_path(&mut self, path: &Path, _id: ast::NodeId, e: E) {\n-        walk_path(self, path, e)\n+    fn visit_path(&mut self, path: &Path, _id: ast::NodeId) {\n+        walk_path(self, path)\n     }\n-    fn visit_attribute(&mut self, _attr: &Attribute, _e: E) {}\n+    fn visit_attribute(&mut self, _attr: &Attribute) {}\n }\n \n-pub fn walk_inlined_item<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                                  item: &ast::InlinedItem,\n-                                                  env: E) {\n+pub fn walk_inlined_item<V: Visitor>(visitor: &mut V, item: &ast::InlinedItem) {\n     match *item {\n-        IIItem(i) => visitor.visit_item(&*i, env),\n-        IIForeign(i) => visitor.visit_foreign_item(&*i, env),\n+        IIItem(i) => visitor.visit_item(&*i),\n+        IIForeign(i) => visitor.visit_foreign_item(&*i),\n         IITraitItem(_, iti) => {\n             match iti {\n                 ProvidedInlinedTraitItem(m) => {\n-                    walk_method_helper(visitor, &*m, env)\n+                    walk_method_helper(visitor, &*m)\n                 }\n                 RequiredInlinedTraitItem(m) => {\n-                    walk_method_helper(visitor, &*m, env)\n+                    walk_method_helper(visitor, &*m)\n                 }\n             }\n         }\n     }\n }\n \n \n-pub fn walk_crate<E: Clone, V: Visitor<E>>(visitor: &mut V, krate: &Crate, env: E) {\n-    visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID, env.clone());\n+pub fn walk_crate<V: Visitor>(visitor: &mut V, krate: &Crate) {\n+    visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n     for attr in krate.attrs.iter() {\n-        visitor.visit_attribute(attr, env.clone());\n+        visitor.visit_attribute(attr);\n     }\n }\n \n-pub fn walk_mod<E: Clone, V: Visitor<E>>(visitor: &mut V, module: &Mod, env: E) {\n+pub fn walk_mod<V: Visitor>(visitor: &mut V, module: &Mod) {\n     for view_item in module.view_items.iter() {\n-        visitor.visit_view_item(view_item, env.clone())\n+        visitor.visit_view_item(view_item)\n     }\n \n     for item in module.items.iter() {\n-        visitor.visit_item(&**item, env.clone())\n+        visitor.visit_item(&**item)\n     }\n }\n \n-pub fn walk_view_item<E: Clone, V: Visitor<E>>(visitor: &mut V, vi: &ViewItem, env: E) {\n+pub fn walk_view_item<V: Visitor>(visitor: &mut V, vi: &ViewItem) {\n     match vi.node {\n         ViewItemExternCrate(name, _, _) => {\n-            visitor.visit_ident(vi.span, name, env.clone())\n+            visitor.visit_ident(vi.span, name)\n         }\n         ViewItemUse(ref vp) => {\n             match vp.node {\n                 ViewPathSimple(ident, ref path, id) => {\n-                    visitor.visit_ident(vp.span, ident, env.clone());\n-                    visitor.visit_path(path, id, env.clone());\n+                    visitor.visit_ident(vp.span, ident);\n+                    visitor.visit_path(path, id);\n                 }\n                 ViewPathGlob(ref path, id) => {\n-                    visitor.visit_path(path, id, env.clone());\n+                    visitor.visit_path(path, id);\n                 }\n                 ViewPathList(ref path, ref list, _) => {\n                     for id in list.iter() {\n                         match id.node {\n                             PathListIdent { name, .. } => {\n-                                visitor.visit_ident(id.span, name, env.clone());\n+                                visitor.visit_ident(id.span, name);\n                             }\n                             PathListMod { .. } => ()\n                         }\n                     }\n-                    walk_path(visitor, path, env.clone());\n+                    walk_path(visitor, path);\n                 }\n             }\n         }\n     }\n     for attr in vi.attrs.iter() {\n-        visitor.visit_attribute(attr, env.clone());\n+        visitor.visit_attribute(attr);\n     }\n }\n \n-pub fn walk_local<E: Clone, V: Visitor<E>>(visitor: &mut V, local: &Local, env: E) {\n-    visitor.visit_pat(&*local.pat, env.clone());\n-    visitor.visit_ty(&*local.ty, env.clone());\n+pub fn walk_local<V: Visitor>(visitor: &mut V, local: &Local) {\n+    visitor.visit_pat(&*local.pat);\n+    visitor.visit_ty(&*local.ty);\n     match local.init {\n         None => {}\n-        Some(initializer) => visitor.visit_expr(&*initializer, env),\n+        Some(initializer) => visitor.visit_expr(&*initializer),\n     }\n }\n \n-pub fn walk_explicit_self<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                                   explicit_self: &ExplicitSelf,\n-                                                   env: E) {\n+pub fn walk_explicit_self<V: Visitor>(visitor: &mut V, explicit_self: &ExplicitSelf) {\n     match explicit_self.node {\n         SelfStatic | SelfValue(_) => {},\n         SelfRegion(ref lifetime, _, _) => {\n-            visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime, env)\n+            visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime)\n         }\n-        SelfExplicit(ref typ, _) => visitor.visit_ty(&**typ, env.clone()),\n+        SelfExplicit(ref typ, _) => visitor.visit_ty(&**typ),\n     }\n }\n \n /// Like with walk_method_helper this doesn't correspond to a method\n /// in Visitor, and so it gets a _helper suffix.\n-pub fn walk_trait_ref_helper<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                                      trait_ref: &TraitRef,\n-                                                      env: E) {\n-    visitor.visit_path(&trait_ref.path, trait_ref.ref_id, env)\n+pub fn walk_trait_ref_helper<V: Visitor>(visitor: &mut V, trait_ref: &TraitRef) {\n+    visitor.visit_path(&trait_ref.path, trait_ref.ref_id)\n }\n \n-pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E) {\n-    visitor.visit_ident(item.span, item.ident, env.clone());\n+pub fn walk_item<V: Visitor>(visitor: &mut V, item: &Item) {\n+    visitor.visit_ident(item.span, item.ident);\n     match item.node {\n         ItemStatic(ref typ, _, ref expr) => {\n-            visitor.visit_ty(&**typ, env.clone());\n-            visitor.visit_expr(&**expr, env.clone());\n+            visitor.visit_ty(&**typ);\n+            visitor.visit_expr(&**expr);\n         }\n         ItemFn(declaration, fn_style, abi, ref generics, body) => {\n             visitor.visit_fn(&FkItemFn(item.ident, generics, fn_style, abi),\n                              &*declaration,\n                              &*body,\n                              item.span,\n-                             item.id,\n-                             env.clone())\n+                             item.id)\n         }\n         ItemMod(ref module) => {\n-            visitor.visit_mod(module, item.span, item.id, env.clone())\n+            visitor.visit_mod(module, item.span, item.id)\n         }\n         ItemForeignMod(ref foreign_module) => {\n             for view_item in foreign_module.view_items.iter() {\n-                visitor.visit_view_item(view_item, env.clone())\n+                visitor.visit_view_item(view_item)\n             }\n             for foreign_item in foreign_module.items.iter() {\n-                visitor.visit_foreign_item(&**foreign_item, env.clone())\n+                visitor.visit_foreign_item(&**foreign_item)\n             }\n         }\n         ItemTy(ref typ, ref type_parameters) => {\n-            visitor.visit_ty(&**typ, env.clone());\n-            visitor.visit_generics(type_parameters, env.clone())\n+            visitor.visit_ty(&**typ);\n+            visitor.visit_generics(type_parameters)\n         }\n         ItemEnum(ref enum_definition, ref type_parameters) => {\n-            visitor.visit_generics(type_parameters, env.clone());\n-            walk_enum_def(visitor, enum_definition, type_parameters, env.clone())\n+            visitor.visit_generics(type_parameters);\n+            walk_enum_def(visitor, enum_definition, type_parameters)\n         }\n         ItemImpl(ref type_parameters,\n                  ref trait_reference,\n                  typ,\n                  ref impl_items) => {\n-            visitor.visit_generics(type_parameters, env.clone());\n+            visitor.visit_generics(type_parameters);\n             match *trait_reference {\n                 Some(ref trait_reference) => walk_trait_ref_helper(visitor,\n-                                                                   trait_reference, env.clone()),\n+                                                                   trait_reference),\n                 None => ()\n             }\n-            visitor.visit_ty(&*typ, env.clone());\n+            visitor.visit_ty(&*typ);\n             for impl_item in impl_items.iter() {\n                 match *impl_item {\n                     MethodImplItem(method) => {\n-                        walk_method_helper(visitor, &*method, env.clone())\n+                        walk_method_helper(visitor, &*method)\n                     }\n                 }\n             }\n         }\n         ItemStruct(ref struct_definition, ref generics) => {\n-            visitor.visit_generics(generics, env.clone());\n+            visitor.visit_generics(generics);\n             visitor.visit_struct_def(&**struct_definition,\n                                      item.ident,\n                                      generics,\n-                                     item.id,\n-                                     env.clone())\n+                                     item.id)\n         }\n         ItemTrait(ref generics, _, ref bounds, ref methods) => {\n-            visitor.visit_generics(generics, env.clone());\n-            walk_ty_param_bounds(visitor, bounds, env.clone());\n+            visitor.visit_generics(generics);\n+            walk_ty_param_bounds(visitor, bounds);\n             for method in methods.iter() {\n-                visitor.visit_trait_item(method, env.clone())\n+                visitor.visit_trait_item(method)\n             }\n         }\n-        ItemMac(ref macro) => visitor.visit_mac(macro, env.clone()),\n+        ItemMac(ref macro) => visitor.visit_mac(macro),\n     }\n     for attr in item.attrs.iter() {\n-        visitor.visit_attribute(attr, env.clone());\n+        visitor.visit_attribute(attr);\n     }\n }\n \n-pub fn walk_enum_def<E: Clone, V:Visitor<E>>(visitor: &mut V,\n-                                             enum_definition: &EnumDef,\n-                                             generics: &Generics,\n-                                             env: E) {\n+pub fn walk_enum_def<V: Visitor>(visitor: &mut V,\n+                                 enum_definition: &EnumDef,\n+                                 generics: &Generics) {\n     for &variant in enum_definition.variants.iter() {\n-        visitor.visit_variant(&*variant, generics, env.clone());\n+        visitor.visit_variant(&*variant, generics);\n     }\n }\n \n-pub fn walk_variant<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                             variant: &Variant,\n-                                             generics: &Generics,\n-                                             env: E) {\n-    visitor.visit_ident(variant.span, variant.node.name, env.clone());\n+pub fn walk_variant<V: Visitor>(visitor: &mut V,\n+                                variant: &Variant,\n+                                generics: &Generics) {\n+    visitor.visit_ident(variant.span, variant.node.name);\n \n     match variant.node.kind {\n         TupleVariantKind(ref variant_arguments) => {\n             for variant_argument in variant_arguments.iter() {\n-                visitor.visit_ty(&*variant_argument.ty, env.clone())\n+                visitor.visit_ty(&*variant_argument.ty)\n             }\n         }\n         StructVariantKind(ref struct_definition) => {\n             visitor.visit_struct_def(&**struct_definition,\n                                      variant.node.name,\n                                      generics,\n-                                     variant.node.id,\n-                                     env.clone())\n+                                     variant.node.id)\n         }\n     }\n     match variant.node.disr_expr {\n-        Some(ref expr) => visitor.visit_expr(&**expr, env.clone()),\n+        Some(ref expr) => visitor.visit_expr(&**expr),\n         None => ()\n     }\n     for attr in variant.node.attrs.iter() {\n-        visitor.visit_attribute(attr, env.clone());\n+        visitor.visit_attribute(attr);\n     }\n }\n \n-pub fn skip_ty<E, V: Visitor<E>>(_: &mut V, _: &Ty, _: E) {\n+pub fn skip_ty<V: Visitor>(_: &mut V, _: &Ty) {\n     // Empty!\n }\n \n-pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n+pub fn walk_ty<V: Visitor>(visitor: &mut V, typ: &Ty) {\n     match typ.node {\n         TyUniq(ty) | TyVec(ty) | TyBox(ty) | TyParen(ty) => {\n-            visitor.visit_ty(&*ty, env)\n+            visitor.visit_ty(&*ty)\n         }\n         TyPtr(ref mutable_type) => {\n-            visitor.visit_ty(&*mutable_type.ty, env)\n+            visitor.visit_ty(&*mutable_type.ty)\n         }\n         TyRptr(ref lifetime, ref mutable_type) => {\n-            visitor.visit_opt_lifetime_ref(typ.span, lifetime, env.clone());\n-            visitor.visit_ty(&*mutable_type.ty, env)\n+            visitor.visit_opt_lifetime_ref(typ.span, lifetime);\n+            visitor.visit_ty(&*mutable_type.ty)\n         }\n         TyTup(ref tuple_element_types) => {\n             for &tuple_element_type in tuple_element_types.iter() {\n-                visitor.visit_ty(&*tuple_element_type, env.clone())\n+                visitor.visit_ty(&*tuple_element_type)\n             }\n         }\n         TyClosure(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(&*argument.ty, env.clone())\n+                visitor.visit_ty(&*argument.ty)\n             }\n-            visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n-            walk_ty_param_bounds(visitor, &function_declaration.bounds,\n-                                 env.clone());\n-            walk_lifetime_decls(visitor, &function_declaration.lifetimes,\n-                                env.clone());\n+            visitor.visit_ty(&*function_declaration.decl.output);\n+            walk_ty_param_bounds(visitor, &function_declaration.bounds);\n+            walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n         }\n         TyProc(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(&*argument.ty, env.clone())\n+                visitor.visit_ty(&*argument.ty)\n             }\n-            visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n-            walk_ty_param_bounds(visitor, &function_declaration.bounds,\n-                                 env.clone());\n-            walk_lifetime_decls(visitor, &function_declaration.lifetimes,\n-                                env.clone());\n+            visitor.visit_ty(&*function_declaration.decl.output);\n+            walk_ty_param_bounds(visitor, &function_declaration.bounds);\n+            walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n         }\n         TyBareFn(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(&*argument.ty, env.clone())\n+                visitor.visit_ty(&*argument.ty)\n             }\n-            visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n-            walk_lifetime_decls(visitor, &function_declaration.lifetimes,\n-                                env.clone());\n+            visitor.visit_ty(&*function_declaration.decl.output);\n+            walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n         }\n         TyUnboxedFn(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n-                visitor.visit_ty(&*argument.ty, env.clone())\n+                visitor.visit_ty(&*argument.ty)\n             }\n-            visitor.visit_ty(&*function_declaration.decl.output, env.clone());\n+            visitor.visit_ty(&*function_declaration.decl.output);\n         }\n         TyPath(ref path, ref opt_bounds, id) => {\n-            visitor.visit_path(path, id, env.clone());\n+            visitor.visit_path(path, id);\n             match *opt_bounds {\n                 Some(ref bounds) => {\n-                    walk_ty_param_bounds(visitor, bounds, env.clone());\n+                    walk_ty_param_bounds(visitor, bounds);\n                 }\n                 None => { }\n             }\n         }\n         TyFixedLengthVec(ref ty, ref expression) => {\n-            visitor.visit_ty(&**ty, env.clone());\n-            visitor.visit_expr(&**expression, env)\n+            visitor.visit_ty(&**ty);\n+            visitor.visit_expr(&**expression)\n         }\n         TyTypeof(ref expression) => {\n-            visitor.visit_expr(&**expression, env)\n+            visitor.visit_expr(&**expression)\n         }\n         TyNil | TyBot | TyInfer => {}\n     }\n }\n \n-fn walk_lifetime_decls<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                                lifetimes: &Vec<LifetimeDef>,\n-                                                env: E) {\n+fn walk_lifetime_decls<V: Visitor>(visitor: &mut V, lifetimes: &Vec<LifetimeDef>) {\n     for l in lifetimes.iter() {\n-        visitor.visit_lifetime_decl(l, env.clone());\n+        visitor.visit_lifetime_decl(l);\n     }\n }\n \n-pub fn walk_path<E: Clone, V: Visitor<E>>(visitor: &mut V, path: &Path, env: E) {\n+pub fn walk_path<V: Visitor>(visitor: &mut V, path: &Path) {\n     for segment in path.segments.iter() {\n-        visitor.visit_ident(path.span, segment.identifier, env.clone());\n+        visitor.visit_ident(path.span, segment.identifier);\n \n         for typ in segment.types.iter() {\n-            visitor.visit_ty(&**typ, env.clone());\n+            visitor.visit_ty(&**typ);\n         }\n         for lifetime in segment.lifetimes.iter() {\n-            visitor.visit_lifetime_ref(lifetime, env.clone());\n+            visitor.visit_lifetime_ref(lifetime);\n         }\n     }\n }\n \n-pub fn walk_pat<E: Clone, V: Visitor<E>>(visitor: &mut V, pattern: &Pat, env: E) {\n+pub fn walk_pat<V: Visitor>(visitor: &mut V, pattern: &Pat) {\n     match pattern.node {\n         PatEnum(ref path, ref children) => {\n-            visitor.visit_path(path, pattern.id, env.clone());\n+            visitor.visit_path(path, pattern.id);\n             for children in children.iter() {\n                 for child in children.iter() {\n-                    visitor.visit_pat(&**child, env.clone())\n+                    visitor.visit_pat(&**child)\n                 }\n             }\n         }\n         PatStruct(ref path, ref fields, _) => {\n-            visitor.visit_path(path, pattern.id, env.clone());\n+            visitor.visit_path(path, pattern.id);\n             for field in fields.iter() {\n-                visitor.visit_pat(&*field.pat, env.clone())\n+                visitor.visit_pat(&*field.pat)\n             }\n         }\n         PatTup(ref tuple_elements) => {\n             for tuple_element in tuple_elements.iter() {\n-                visitor.visit_pat(&**tuple_element, env.clone())\n+                visitor.visit_pat(&**tuple_element)\n             }\n         }\n         PatBox(ref subpattern) |\n         PatRegion(ref subpattern) => {\n-            visitor.visit_pat(&**subpattern, env)\n+            visitor.visit_pat(&**subpattern)\n         }\n         PatIdent(_, ref pth1, ref optional_subpattern) => {\n-            visitor.visit_ident(pth1.span, pth1.node, env.clone());\n+            visitor.visit_ident(pth1.span, pth1.node);\n             match *optional_subpattern {\n                 None => {}\n-                Some(ref subpattern) => visitor.visit_pat(&**subpattern, env),\n+                Some(ref subpattern) => visitor.visit_pat(&**subpattern),\n             }\n         }\n-        PatLit(ref expression) => visitor.visit_expr(&**expression, env),\n+        PatLit(ref expression) => visitor.visit_expr(&**expression),\n         PatRange(ref lower_bound, ref upper_bound) => {\n-            visitor.visit_expr(&**lower_bound, env.clone());\n-            visitor.visit_expr(&**upper_bound, env)\n+            visitor.visit_expr(&**lower_bound);\n+            visitor.visit_expr(&**upper_bound)\n         }\n         PatWild(_) => (),\n         PatVec(ref prepattern, ref slice_pattern, ref postpatterns) => {\n             for prepattern in prepattern.iter() {\n-                visitor.visit_pat(&**prepattern, env.clone())\n+                visitor.visit_pat(&**prepattern)\n             }\n             for slice_pattern in slice_pattern.iter() {\n-                visitor.visit_pat(&**slice_pattern, env.clone())\n+                visitor.visit_pat(&**slice_pattern)\n             }\n             for postpattern in postpatterns.iter() {\n-                visitor.visit_pat(&**postpattern, env.clone())\n+                visitor.visit_pat(&**postpattern)\n             }\n         }\n-        PatMac(ref macro) => visitor.visit_mac(macro, env),\n+        PatMac(ref macro) => visitor.visit_mac(macro),\n     }\n }\n \n-pub fn walk_foreign_item<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                                  foreign_item: &ForeignItem,\n-                                                  env: E) {\n-    visitor.visit_ident(foreign_item.span, foreign_item.ident, env.clone());\n+pub fn walk_foreign_item<V: Visitor>(visitor: &mut V, foreign_item: &ForeignItem) {\n+    visitor.visit_ident(foreign_item.span, foreign_item.ident);\n \n     match foreign_item.node {\n         ForeignItemFn(ref function_declaration, ref generics) => {\n-            walk_fn_decl(visitor, &**function_declaration, env.clone());\n-            visitor.visit_generics(generics, env.clone())\n+            walk_fn_decl(visitor, &**function_declaration);\n+            visitor.visit_generics(generics)\n         }\n-        ForeignItemStatic(ref typ, _) => visitor.visit_ty(&**typ, env.clone()),\n+        ForeignItemStatic(ref typ, _) => visitor.visit_ty(&**typ),\n     }\n \n     for attr in foreign_item.attrs.iter() {\n-        visitor.visit_attribute(attr, env.clone());\n+        visitor.visit_attribute(attr);\n     }\n }\n \n-pub fn walk_ty_param_bounds<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                                     bounds: &OwnedSlice<TyParamBound>,\n-                                                     env: E) {\n+pub fn walk_ty_param_bounds<V: Visitor>(visitor: &mut V,\n+                                        bounds: &OwnedSlice<TyParamBound>) {\n     for bound in bounds.iter() {\n         match *bound {\n             TraitTyParamBound(ref typ) => {\n-                walk_trait_ref_helper(visitor, typ, env.clone())\n+                walk_trait_ref_helper(visitor, typ)\n             }\n             UnboxedFnTyParamBound(ref function_declaration) => {\n                 for argument in function_declaration.decl.inputs.iter() {\n-                    visitor.visit_ty(&*argument.ty, env.clone())\n+                    visitor.visit_ty(&*argument.ty)\n                 }\n-                visitor.visit_ty(&*function_declaration.decl.output,\n-                                 env.clone());\n+                visitor.visit_ty(&*function_declaration.decl.output);\n             }\n             RegionTyParamBound(ref lifetime) => {\n-                visitor.visit_lifetime_ref(lifetime, env.clone());\n+                visitor.visit_lifetime_ref(lifetime);\n             }\n         }\n     }\n }\n \n-pub fn walk_generics<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                              generics: &Generics,\n-                                              env: E) {\n+pub fn walk_generics<V: Visitor>(visitor: &mut V, generics: &Generics) {\n     for type_parameter in generics.ty_params.iter() {\n-        walk_ty_param_bounds(visitor, &type_parameter.bounds, env.clone());\n+        walk_ty_param_bounds(visitor, &type_parameter.bounds);\n         match type_parameter.default {\n-            Some(ref ty) => visitor.visit_ty(&**ty, env.clone()),\n+            Some(ref ty) => visitor.visit_ty(&**ty),\n             None => {}\n         }\n     }\n-    walk_lifetime_decls(visitor, &generics.lifetimes, env.clone());\n+    walk_lifetime_decls(visitor, &generics.lifetimes);\n     for predicate in generics.where_clause.predicates.iter() {\n-        visitor.visit_ident(predicate.span, predicate.ident, env.clone());\n-        walk_ty_param_bounds(visitor, &predicate.bounds, env.clone());\n+        visitor.visit_ident(predicate.span, predicate.ident);\n+        walk_ty_param_bounds(visitor, &predicate.bounds);\n     }\n }\n \n-pub fn walk_fn_decl<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                             function_declaration: &FnDecl,\n-                                             env: E) {\n+pub fn walk_fn_decl<V: Visitor>(visitor: &mut V, function_declaration: &FnDecl) {\n     for argument in function_declaration.inputs.iter() {\n-        visitor.visit_pat(&*argument.pat, env.clone());\n-        visitor.visit_ty(&*argument.ty, env.clone())\n+        visitor.visit_pat(&*argument.pat);\n+        visitor.visit_ty(&*argument.ty)\n     }\n-    visitor.visit_ty(&*function_declaration.output, env)\n+    visitor.visit_ty(&*function_declaration.output)\n }\n \n // Note: there is no visit_method() method in the visitor, instead override\n // visit_fn() and check for FkMethod().  I named this visit_method_helper()\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n-pub fn walk_method_helper<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                                   method: &Method,\n-                                                   env: E) {\n+pub fn walk_method_helper<V: Visitor>(visitor: &mut V, method: &Method) {\n     match method.node {\n         MethDecl(ident, ref generics, _, _, _, decl, body, _) => {\n-            visitor.visit_ident(method.span, ident, env.clone());\n+            visitor.visit_ident(method.span, ident);\n             visitor.visit_fn(&FkMethod(ident, generics, method),\n                              &*decl,\n                              &*body,\n                              method.span,\n-                             method.id,\n-                             env.clone());\n+                             method.id);\n             for attr in method.attrs.iter() {\n-                visitor.visit_attribute(attr, env.clone());\n+                visitor.visit_attribute(attr);\n             }\n \n         },\n-        MethMac(ref mac) => visitor.visit_mac(mac, env.clone())\n+        MethMac(ref mac) => visitor.visit_mac(mac)\n     }\n }\n \n-pub fn walk_fn<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                        function_kind: &FnKind,\n-                                        function_declaration: &FnDecl,\n-                                        function_body: &Block,\n-                                        _span: Span,\n-                                        env: E) {\n-    walk_fn_decl(visitor, function_declaration, env.clone());\n+pub fn walk_fn<V: Visitor>(visitor: &mut V,\n+                           function_kind: &FnKind,\n+                           function_declaration: &FnDecl,\n+                           function_body: &Block,\n+                           _span: Span) {\n+    walk_fn_decl(visitor, function_declaration);\n \n     match *function_kind {\n         FkItemFn(_, generics, _, _) => {\n-            visitor.visit_generics(generics, env.clone());\n+            visitor.visit_generics(generics);\n         }\n         FkMethod(_, generics, method) => {\n-            visitor.visit_generics(generics, env.clone());\n+            visitor.visit_generics(generics);\n             match method.node {\n                 MethDecl(_, _, _, ref explicit_self, _, _, _, _) =>\n-                    visitor.visit_explicit_self(explicit_self, env.clone()),\n+                    visitor.visit_explicit_self(explicit_self),\n                 MethMac(ref mac) =>\n-                    visitor.visit_mac(mac, env.clone())\n+                    visitor.visit_mac(mac)\n             }\n         }\n         FkFnBlock(..) => {}\n     }\n \n-    visitor.visit_block(function_body, env)\n+    visitor.visit_block(function_body)\n }\n \n-pub fn walk_ty_method<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                               method_type: &TypeMethod,\n-                                               env: E) {\n-    visitor.visit_ident(method_type.span, method_type.ident, env.clone());\n-    visitor.visit_explicit_self(&method_type.explicit_self, env.clone());\n+pub fn walk_ty_method<V: Visitor>(visitor: &mut V, method_type: &TypeMethod) {\n+    visitor.visit_ident(method_type.span, method_type.ident);\n+    visitor.visit_explicit_self(&method_type.explicit_self);\n     for argument_type in method_type.decl.inputs.iter() {\n-        visitor.visit_ty(&*argument_type.ty, env.clone())\n+        visitor.visit_ty(&*argument_type.ty)\n     }\n-    visitor.visit_generics(&method_type.generics, env.clone());\n-    visitor.visit_ty(&*method_type.decl.output, env.clone());\n+    visitor.visit_generics(&method_type.generics);\n+    visitor.visit_ty(&*method_type.decl.output);\n     for attr in method_type.attrs.iter() {\n-        visitor.visit_attribute(attr, env.clone());\n+        visitor.visit_attribute(attr);\n     }\n }\n \n-pub fn walk_trait_item<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                                  trait_method: &TraitItem,\n-                                                  env: E) {\n+pub fn walk_trait_item<V: Visitor>(visitor: &mut V, trait_method: &TraitItem) {\n     match *trait_method {\n         RequiredMethod(ref method_type) => {\n-            visitor.visit_ty_method(method_type, env)\n+            visitor.visit_ty_method(method_type)\n         }\n-        ProvidedMethod(ref method) => walk_method_helper(visitor, &**method, env),\n+        ProvidedMethod(ref method) => walk_method_helper(visitor, &**method),\n     }\n }\n \n-pub fn walk_struct_def<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                                struct_definition: &StructDef,\n-                                                env: E) {\n+pub fn walk_struct_def<V: Visitor>(visitor: &mut V,\n+                                   struct_definition: &StructDef) {\n     match struct_definition.super_struct {\n-        Some(ref t) => visitor.visit_ty(&**t, env.clone()),\n+        Some(ref t) => visitor.visit_ty(&**t),\n         None => {},\n     }\n     for field in struct_definition.fields.iter() {\n-        visitor.visit_struct_field(field, env.clone())\n+        visitor.visit_struct_field(field)\n     }\n }\n \n-pub fn walk_struct_field<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                                  struct_field: &StructField,\n-                                                  env: E) {\n+pub fn walk_struct_field<V: Visitor>(visitor: &mut V,\n+                                     struct_field: &StructField) {\n     match struct_field.node.kind {\n         NamedField(name, _) => {\n-            visitor.visit_ident(struct_field.span, name, env.clone())\n+            visitor.visit_ident(struct_field.span, name)\n         }\n         _ => {}\n     }\n \n-    visitor.visit_ty(&*struct_field.node.ty, env.clone());\n+    visitor.visit_ty(&*struct_field.node.ty);\n \n     for attr in struct_field.node.attrs.iter() {\n-        visitor.visit_attribute(attr, env.clone());\n+        visitor.visit_attribute(attr);\n     }\n }\n \n-pub fn walk_block<E: Clone, V: Visitor<E>>(visitor: &mut V, block: &Block, env: E) {\n+pub fn walk_block<V: Visitor>(visitor: &mut V, block: &Block) {\n     for view_item in block.view_items.iter() {\n-        visitor.visit_view_item(view_item, env.clone())\n+        visitor.visit_view_item(view_item)\n     }\n     for statement in block.stmts.iter() {\n-        visitor.visit_stmt(&**statement, env.clone())\n+        visitor.visit_stmt(&**statement)\n     }\n-    walk_expr_opt(visitor, block.expr, env)\n+    walk_expr_opt(visitor, block.expr)\n }\n \n-pub fn walk_stmt<E: Clone, V: Visitor<E>>(visitor: &mut V, statement: &Stmt, env: E) {\n+pub fn walk_stmt<V: Visitor>(visitor: &mut V, statement: &Stmt) {\n     match statement.node {\n-        StmtDecl(ref declaration, _) => visitor.visit_decl(&**declaration, env),\n+        StmtDecl(ref declaration, _) => visitor.visit_decl(&**declaration),\n         StmtExpr(ref expression, _) | StmtSemi(ref expression, _) => {\n-            visitor.visit_expr(&**expression, env)\n+            visitor.visit_expr(&**expression)\n         }\n-        StmtMac(ref macro, _) => visitor.visit_mac(macro, env),\n+        StmtMac(ref macro, _) => visitor.visit_mac(macro),\n     }\n }\n \n-pub fn walk_decl<E: Clone, V: Visitor<E>>(visitor: &mut V, declaration: &Decl, env: E) {\n+pub fn walk_decl<V: Visitor>(visitor: &mut V, declaration: &Decl) {\n     match declaration.node {\n-        DeclLocal(ref local) => visitor.visit_local(&**local, env),\n-        DeclItem(ref item) => visitor.visit_item(&**item, env),\n+        DeclLocal(ref local) => visitor.visit_local(&**local),\n+        DeclItem(ref item) => visitor.visit_item(&**item),\n     }\n }\n \n-pub fn walk_expr_opt<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                              optional_expression: Option<Gc<Expr>>,\n-                                              env: E) {\n+pub fn walk_expr_opt<V: Visitor>(visitor: &mut V,\n+                                 optional_expression: Option<Gc<Expr>>) {\n     match optional_expression {\n         None => {}\n-        Some(ref expression) => visitor.visit_expr(&**expression, env),\n+        Some(ref expression) => visitor.visit_expr(&**expression),\n     }\n }\n \n-pub fn walk_exprs<E: Clone, V: Visitor<E>>(visitor: &mut V,\n-                                           expressions: &[Gc<Expr>],\n-                                           env: E) {\n+pub fn walk_exprs<V: Visitor>(visitor: &mut V, expressions: &[Gc<Expr>]) {\n     for expression in expressions.iter() {\n-        visitor.visit_expr(&**expression, env.clone())\n+        visitor.visit_expr(&**expression)\n     }\n }\n \n-pub fn walk_mac<E, V: Visitor<E>>(_: &mut V, _: &Mac, _: E) {\n+pub fn walk_mac<V: Visitor>(_: &mut V, _: &Mac) {\n     // Empty!\n }\n \n-pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, env: E) {\n+pub fn walk_expr<V: Visitor>(visitor: &mut V, expression: &Expr) {\n     match expression.node {\n         ExprBox(ref place, ref subexpression) => {\n-            visitor.visit_expr(&**place, env.clone());\n-            visitor.visit_expr(&**subexpression, env.clone())\n+            visitor.visit_expr(&**place);\n+            visitor.visit_expr(&**subexpression)\n         }\n         ExprVec(ref subexpressions) => {\n-            walk_exprs(visitor, subexpressions.as_slice(), env.clone())\n+            walk_exprs(visitor, subexpressions.as_slice())\n         }\n         ExprRepeat(ref element, ref count) => {\n-            visitor.visit_expr(&**element, env.clone());\n-            visitor.visit_expr(&**count, env.clone())\n+            visitor.visit_expr(&**element);\n+            visitor.visit_expr(&**count)\n         }\n         ExprStruct(ref path, ref fields, optional_base) => {\n-            visitor.visit_path(path, expression.id, env.clone());\n+            visitor.visit_path(path, expression.id);\n             for field in fields.iter() {\n-                visitor.visit_expr(&*field.expr, env.clone())\n+                visitor.visit_expr(&*field.expr)\n             }\n-            walk_expr_opt(visitor, optional_base, env.clone())\n+            walk_expr_opt(visitor, optional_base)\n         }\n         ExprTup(ref subexpressions) => {\n             for subexpression in subexpressions.iter() {\n-                visitor.visit_expr(&**subexpression, env.clone())\n+                visitor.visit_expr(&**subexpression)\n             }\n         }\n         ExprCall(ref callee_expression, ref arguments) => {\n             for argument in arguments.iter() {\n-                visitor.visit_expr(&**argument, env.clone())\n+                visitor.visit_expr(&**argument)\n             }\n-            visitor.visit_expr(&**callee_expression, env.clone())\n+            visitor.visit_expr(&**callee_expression)\n         }\n         ExprMethodCall(_, ref types, ref arguments) => {\n-            walk_exprs(visitor, arguments.as_slice(), env.clone());\n+            walk_exprs(visitor, arguments.as_slice());\n             for typ in types.iter() {\n-                visitor.visit_ty(&**typ, env.clone())\n+                visitor.visit_ty(&**typ)\n             }\n         }\n         ExprBinary(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(&**left_expression, env.clone());\n-            visitor.visit_expr(&**right_expression, env.clone())\n+            visitor.visit_expr(&**left_expression);\n+            visitor.visit_expr(&**right_expression)\n         }\n         ExprAddrOf(_, ref subexpression) | ExprUnary(_, ref subexpression) => {\n-            visitor.visit_expr(&**subexpression, env.clone())\n+            visitor.visit_expr(&**subexpression)\n         }\n         ExprLit(_) => {}\n         ExprCast(ref subexpression, ref typ) => {\n-            visitor.visit_expr(&**subexpression, env.clone());\n-            visitor.visit_ty(&**typ, env.clone())\n+            visitor.visit_expr(&**subexpression);\n+            visitor.visit_ty(&**typ)\n         }\n         ExprIf(ref head_expression, ref if_block, optional_else) => {\n-            visitor.visit_expr(&**head_expression, env.clone());\n-            visitor.visit_block(&**if_block, env.clone());\n-            walk_expr_opt(visitor, optional_else, env.clone())\n+            visitor.visit_expr(&**head_expression);\n+            visitor.visit_block(&**if_block);\n+            walk_expr_opt(visitor, optional_else)\n         }\n         ExprWhile(ref subexpression, ref block, _) => {\n-            visitor.visit_expr(&**subexpression, env.clone());\n-            visitor.visit_block(&**block, env.clone())\n+            visitor.visit_expr(&**subexpression);\n+            visitor.visit_block(&**block)\n         }\n         ExprForLoop(ref pattern, ref subexpression, ref block, _) => {\n-            visitor.visit_pat(&**pattern, env.clone());\n-            visitor.visit_expr(&**subexpression, env.clone());\n-            visitor.visit_block(&**block, env.clone())\n+            visitor.visit_pat(&**pattern);\n+            visitor.visit_expr(&**subexpression);\n+            visitor.visit_block(&**block)\n         }\n-        ExprLoop(ref block, _) => visitor.visit_block(&**block, env.clone()),\n+        ExprLoop(ref block, _) => visitor.visit_block(&**block),\n         ExprMatch(ref subexpression, ref arms) => {\n-            visitor.visit_expr(&**subexpression, env.clone());\n+            visitor.visit_expr(&**subexpression);\n             for arm in arms.iter() {\n-                visitor.visit_arm(arm, env.clone())\n+                visitor.visit_arm(arm)\n             }\n         }\n         ExprFnBlock(_, ref function_declaration, ref body) => {\n             visitor.visit_fn(&FkFnBlock,\n                              &**function_declaration,\n                              &**body,\n                              expression.span,\n-                             expression.id,\n-                             env.clone())\n+                             expression.id)\n         }\n         ExprUnboxedFn(_, _, ref function_declaration, ref body) => {\n             visitor.visit_fn(&FkFnBlock,\n                              &**function_declaration,\n                              &**body,\n                              expression.span,\n-                             expression.id,\n-                             env.clone())\n+                             expression.id)\n         }\n         ExprProc(ref function_declaration, ref body) => {\n             visitor.visit_fn(&FkFnBlock,\n                              &**function_declaration,\n                              &**body,\n                              expression.span,\n-                             expression.id,\n-                             env.clone())\n+                             expression.id)\n         }\n-        ExprBlock(ref block) => visitor.visit_block(&**block, env.clone()),\n+        ExprBlock(ref block) => visitor.visit_block(&**block),\n         ExprAssign(ref left_hand_expression, ref right_hand_expression) => {\n-            visitor.visit_expr(&**right_hand_expression, env.clone());\n-            visitor.visit_expr(&**left_hand_expression, env.clone())\n+            visitor.visit_expr(&**right_hand_expression);\n+            visitor.visit_expr(&**left_hand_expression)\n         }\n         ExprAssignOp(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(&**right_expression, env.clone());\n-            visitor.visit_expr(&**left_expression, env.clone())\n+            visitor.visit_expr(&**right_expression);\n+            visitor.visit_expr(&**left_expression)\n         }\n         ExprField(ref subexpression, _, ref types) => {\n-            visitor.visit_expr(&**subexpression, env.clone());\n+            visitor.visit_expr(&**subexpression);\n             for typ in types.iter() {\n-                visitor.visit_ty(&**typ, env.clone())\n+                visitor.visit_ty(&**typ)\n             }\n         }\n         ExprTupField(ref subexpression, _, ref types) => {\n-            visitor.visit_expr(&**subexpression, env.clone());\n+            visitor.visit_expr(&**subexpression);\n             for typ in types.iter() {\n-                visitor.visit_ty(&**typ, env.clone())\n+                visitor.visit_ty(&**typ)\n             }\n         }\n         ExprIndex(ref main_expression, ref index_expression) => {\n-            visitor.visit_expr(&**main_expression, env.clone());\n-            visitor.visit_expr(&**index_expression, env.clone())\n+            visitor.visit_expr(&**main_expression);\n+            visitor.visit_expr(&**index_expression)\n         }\n         ExprPath(ref path) => {\n-            visitor.visit_path(path, expression.id, env.clone())\n+            visitor.visit_path(path, expression.id)\n         }\n         ExprBreak(_) | ExprAgain(_) => {}\n         ExprRet(optional_expression) => {\n-            walk_expr_opt(visitor, optional_expression, env.clone())\n+            walk_expr_opt(visitor, optional_expression)\n         }\n-        ExprMac(ref macro) => visitor.visit_mac(macro, env.clone()),\n+        ExprMac(ref macro) => visitor.visit_mac(macro),\n         ExprParen(ref subexpression) => {\n-            visitor.visit_expr(&**subexpression, env.clone())\n+            visitor.visit_expr(&**subexpression)\n         }\n         ExprInlineAsm(ref ia) => {\n             for &(_, ref input) in ia.inputs.iter() {\n-                visitor.visit_expr(&**input, env.clone())\n+                visitor.visit_expr(&**input)\n             }\n             for &(_, ref output, _) in ia.outputs.iter() {\n-                visitor.visit_expr(&**output, env.clone())\n+                visitor.visit_expr(&**output)\n             }\n         }\n     }\n \n-    visitor.visit_expr_post(expression, env.clone())\n+    visitor.visit_expr_post(expression)\n }\n \n-pub fn walk_arm<E: Clone, V: Visitor<E>>(visitor: &mut V, arm: &Arm, env: E) {\n+pub fn walk_arm<V: Visitor>(visitor: &mut V, arm: &Arm) {\n     for pattern in arm.pats.iter() {\n-        visitor.visit_pat(&**pattern, env.clone())\n+        visitor.visit_pat(&**pattern)\n     }\n-    walk_expr_opt(visitor, arm.guard, env.clone());\n-    visitor.visit_expr(&*arm.body, env.clone());\n+    walk_expr_opt(visitor, arm.guard);\n+    visitor.visit_expr(&*arm.body);\n     for attr in arm.attrs.iter() {\n-        visitor.visit_attribute(attr, env.clone());\n+        visitor.visit_attribute(attr);\n     }\n }"}]}