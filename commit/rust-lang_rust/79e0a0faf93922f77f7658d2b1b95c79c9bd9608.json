{"sha": "79e0a0faf93922f77f7658d2b1b95c79c9bd9608", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZTBhMGZhZjkzOTIyZjc3Zjc2NThkMmIxYjk1Yzc5YzliZDk2MDg=", "commit": {"author": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-08-25T00:50:08Z"}, "committer": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-08-25T00:50:08Z"}, "message": "Refactor BitSet relational methods into trait with parameterized\nright-hand side", "tree": {"sha": "1816744898bf5d22c47bdd51be50222802589575", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1816744898bf5d22c47bdd51be50222802589575"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79e0a0faf93922f77f7658d2b1b95c79c9bd9608", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79e0a0faf93922f77f7658d2b1b95c79c9bd9608", "html_url": "https://github.com/rust-lang/rust/commit/79e0a0faf93922f77f7658d2b1b95c79c9bd9608", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79e0a0faf93922f77f7658d2b1b95c79c9bd9608/comments", "author": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ca51b6b66d081d8fcbcf9d715f9be8e22b0d609", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ca51b6b66d081d8fcbcf9d715f9be8e22b0d609", "html_url": "https://github.com/rust-lang/rust/commit/0ca51b6b66d081d8fcbcf9d715f9be8e22b0d609"}], "stats": {"total": 361, "additions": 235, "deletions": 126}, "files": [{"sha": "0b5745072ad11bbfd86e12805998316dd6341f68", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 231, "deletions": 122, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/79e0a0faf93922f77f7658d2b1b95c79c9bd9608/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79e0a0faf93922f77f7658d2b1b95c79c9bd9608/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=79e0a0faf93922f77f7658d2b1b95c79c9bd9608", "patch": "@@ -16,6 +16,43 @@ pub type Word = u64;\n pub const WORD_BYTES: usize = mem::size_of::<Word>();\n pub const WORD_BITS: usize = WORD_BYTES * 8;\n \n+pub trait BitRelations<Rhs> {\n+    fn union(&mut self, other: &Rhs) -> bool;\n+    fn subtract(&mut self, other: &Rhs) -> bool;\n+    fn intersect(&mut self, other: &Rhs) -> bool;\n+}\n+\n+macro_rules! bit_relations_inherent_impls {\n+    () => {\n+        /// Sets `self = self | other` and returns `true` if `self` changed\n+        /// (i.e., if new bits were added).\n+        pub fn union<Rhs>(&mut self, other: &Rhs) -> bool\n+        where\n+            Self: BitRelations<Rhs>,\n+        {\n+            <Self as BitRelations<Rhs>>::union(self, other)\n+        }\n+\n+        /// Sets `self = self - other` and returns `true` if `self` changed.\n+        /// (i.e., if any bits were removed).\n+        pub fn subtract<Rhs>(&mut self, other: &Rhs) -> bool\n+        where\n+            Self: BitRelations<Rhs>,\n+        {\n+            <Self as BitRelations<Rhs>>::subtract(self, other)\n+        }\n+\n+        /// Sets `self = self & other` and return `true` if `self` changed.\n+        /// (i.e., if any bits were removed).\n+        pub fn intersect<Rhs>(&mut self, other: &Rhs) -> bool\n+        where\n+            Self: BitRelations<Rhs>,\n+        {\n+            <Self as BitRelations<Rhs>>::intersect(self, other)\n+        }\n+    };\n+}\n+\n /// A fixed-size bitset type with a dense representation.\n ///\n /// NOTE: Use [`GrowableBitSet`] if you need support for resizing after creation.\n@@ -134,25 +171,6 @@ impl<T: Idx> BitSet<T> {\n         new_word != word\n     }\n \n-    /// Sets `self = self | other` and returns `true` if `self` changed\n-    /// (i.e., if new bits were added).\n-    pub fn union(&mut self, other: &impl UnionIntoBitSet<T>) -> bool {\n-        other.union_into(self)\n-    }\n-\n-    /// Sets `self = self - other` and returns `true` if `self` changed.\n-    /// (i.e., if any bits were removed).\n-    pub fn subtract(&mut self, other: &impl SubtractFromBitSet<T>) -> bool {\n-        other.subtract_from(self)\n-    }\n-\n-    /// Sets `self = self & other` and return `true` if `self` changed.\n-    /// (i.e., if any bits were removed).\n-    pub fn intersect(&mut self, other: &BitSet<T>) -> bool {\n-        assert_eq!(self.domain_size, other.domain_size);\n-        bitwise(&mut self.words, &other.words, |a, b| a & b)\n-    }\n-\n     /// Gets a slice of the underlying words.\n     pub fn words(&self) -> &[Word] {\n         &self.words\n@@ -208,33 +226,167 @@ impl<T: Idx> BitSet<T> {\n \n         not_already\n     }\n+\n+    bit_relations_inherent_impls! {}\n }\n \n-/// This is implemented by all the bitsets so that BitSet::union() can be\n-/// passed any type of bitset.\n-pub trait UnionIntoBitSet<T: Idx> {\n-    // Performs `other = other | self`.\n-    fn union_into(&self, other: &mut BitSet<T>) -> bool;\n+impl<T: Idx> BitRelations<BitSet<T>> for BitSet<T> {\n+    fn union(&mut self, other: &BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n+        bitwise(&mut self.words, &other.words, |a, b| a | b)\n+    }\n+\n+    fn subtract(&mut self, other: &BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n+        bitwise(&mut self.words, &other.words, |a, b| a & !b)\n+    }\n+\n+    fn intersect(&mut self, other: &BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n+        bitwise(&mut self.words, &other.words, |a, b| a & b)\n+    }\n }\n \n-/// This is implemented by all the bitsets so that BitSet::subtract() can be\n-/// passed any type of bitset.\n-pub trait SubtractFromBitSet<T: Idx> {\n-    // Performs `other = other - self`.\n-    fn subtract_from(&self, other: &mut BitSet<T>) -> bool;\n+fn sequential_update<T: Idx>(mut f: impl FnMut(T) -> bool, it: impl Iterator<Item = T>) -> bool {\n+    let mut changed = false;\n+    for elem in it {\n+        changed |= f(elem);\n+    }\n+    changed\n }\n \n-impl<T: Idx> UnionIntoBitSet<T> for BitSet<T> {\n-    fn union_into(&self, other: &mut BitSet<T>) -> bool {\n-        assert_eq!(self.domain_size, other.domain_size);\n-        bitwise(&mut other.words, &self.words, |a, b| a | b)\n+fn sparse_intersect<T: Idx>(\n+    set: &mut SparseBitSet<T>,\n+    other_contains: impl Fn(&T) -> bool,\n+) -> bool {\n+    let mut changed = false;\n+    for i in (0..set.len()).rev() {\n+        if !other_contains(&set.elems[i]) {\n+            set.elems.remove(i);\n+            changed = true;\n+        }\n     }\n+    changed\n }\n \n-impl<T: Idx> SubtractFromBitSet<T> for BitSet<T> {\n-    fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n-        assert_eq!(self.domain_size, other.domain_size);\n-        bitwise(&mut other.words, &self.words, |a, b| a & !b)\n+impl<T: Idx> BitRelations<SparseBitSet<T>> for BitSet<T> {\n+    fn union(&mut self, other: &SparseBitSet<T>) -> bool {\n+        sequential_update(|elem| self.insert(elem), other.iter().cloned())\n+    }\n+\n+    fn subtract(&mut self, other: &SparseBitSet<T>) -> bool {\n+        sequential_update(|elem| self.remove(elem), other.iter().cloned())\n+    }\n+\n+    fn intersect(&mut self, other: &SparseBitSet<T>) -> bool {\n+        self.intersect(&other.to_dense())\n+    }\n+}\n+\n+impl<T: Idx> BitRelations<BitSet<T>> for SparseBitSet<T> {\n+    fn union(&mut self, other: &BitSet<T>) -> bool {\n+        sequential_update(|elem| self.insert(elem), other.iter())\n+    }\n+\n+    fn subtract(&mut self, other: &BitSet<T>) -> bool {\n+        sequential_update(|elem| self.remove(elem), other.iter())\n+    }\n+\n+    fn intersect(&mut self, other: &BitSet<T>) -> bool {\n+        sparse_intersect(self, |el| other.contains(*el))\n+    }\n+}\n+\n+impl<T: Idx> BitRelations<SparseBitSet<T>> for SparseBitSet<T> {\n+    fn union(&mut self, other: &SparseBitSet<T>) -> bool {\n+        sequential_update(|elem| self.insert(elem), other.iter().cloned())\n+    }\n+\n+    fn subtract(&mut self, other: &SparseBitSet<T>) -> bool {\n+        sequential_update(|elem| self.insert(elem), other.iter().cloned())\n+    }\n+\n+    fn intersect(&mut self, other: &SparseBitSet<T>) -> bool {\n+        sparse_intersect(self, |el| other.contains(*el))\n+    }\n+}\n+\n+impl<T: Idx, S> BitRelations<HybridBitSet<T>> for S\n+where\n+    S: BitRelations<BitSet<T>> + BitRelations<SparseBitSet<T>>,\n+{\n+    fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n+        match other {\n+            HybridBitSet::Sparse(sparse) => self.union(sparse),\n+            HybridBitSet::Dense(dense) => self.union(dense),\n+        }\n+    }\n+\n+    fn subtract(&mut self, other: &HybridBitSet<T>) -> bool {\n+        match other {\n+            HybridBitSet::Sparse(sparse) => self.subtract(sparse),\n+            HybridBitSet::Dense(dense) => self.subtract(dense),\n+        }\n+    }\n+\n+    fn intersect(&mut self, other: &HybridBitSet<T>) -> bool {\n+        match other {\n+            HybridBitSet::Sparse(sparse) => self.intersect(sparse),\n+            HybridBitSet::Dense(dense) => self.intersect(dense),\n+        }\n+    }\n+}\n+\n+impl<T: Idx> BitRelations<HybridBitSet<T>> for HybridBitSet<T> {\n+    fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n+        match self {\n+            HybridBitSet::Sparse(self_sparse) => {\n+                match other {\n+                    HybridBitSet::Sparse(other_sparse) => self_sparse.union(other_sparse),\n+\n+                    HybridBitSet::Dense(other_dense) => {\n+                        // `self` is sparse and `other` is dense. To\n+                        // merge them, we have two available strategies:\n+                        // * Densify `self` then merge other\n+                        // * Clone other then integrate bits from `self`\n+                        // The second strategy requires dedicated method\n+                        // since the usual `union` returns the wrong\n+                        // result. In the dedicated case the computation\n+                        // is slightly faster if the bits of the sparse\n+                        // bitset map to only few words of the dense\n+                        // representation, i.e. indices are near each\n+                        // other.\n+                        //\n+                        // Benchmarking seems to suggest that the second\n+                        // option is worth it.\n+                        let mut new_dense = other_dense.clone();\n+                        let changed = new_dense.reverse_union_sparse(self_sparse);\n+                        *self = HybridBitSet::Dense(new_dense);\n+                        changed\n+                    }\n+                }\n+            }\n+\n+            HybridBitSet::Dense(self_dense) => self_dense.union(other),\n+        }\n+    }\n+\n+    fn subtract(&mut self, other: &HybridBitSet<T>) -> bool {\n+        // FIXME(willcrichton): should there be an optimized sparse / dense version?\n+        match self {\n+            HybridBitSet::Sparse(self_sparse) => self_sparse.subtract(other),\n+            HybridBitSet::Dense(self_dense) => self_dense.subtract(other),\n+        }\n+    }\n+\n+    fn intersect(&mut self, other: &HybridBitSet<T>) -> bool {\n+        // FIXME(willcrichton): should there be an optimized sparse / dense version?\n+        match self {\n+            HybridBitSet::Sparse(self_sparse) => self_sparse.intersect(other),\n+            HybridBitSet::Dense(self_dense) => {\n+                <BitSet<T> as BitRelations<HybridBitSet<T>>>::intersect(self_dense, other)\n+            }\n+        }\n     }\n }\n \n@@ -441,28 +593,8 @@ impl<T: Idx> SparseBitSet<T> {\n     fn iter(&self) -> slice::Iter<'_, T> {\n         self.elems.iter()\n     }\n-}\n \n-impl<T: Idx> UnionIntoBitSet<T> for SparseBitSet<T> {\n-    fn union_into(&self, other: &mut BitSet<T>) -> bool {\n-        assert_eq!(self.domain_size, other.domain_size);\n-        let mut changed = false;\n-        for elem in self.iter() {\n-            changed |= other.insert(*elem);\n-        }\n-        changed\n-    }\n-}\n-\n-impl<T: Idx> SubtractFromBitSet<T> for SparseBitSet<T> {\n-    fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n-        assert_eq!(self.domain_size, other.domain_size);\n-        let mut changed = false;\n-        for elem in self.iter() {\n-            changed |= other.remove(*elem);\n-        }\n-        changed\n-    }\n+    bit_relations_inherent_impls! {}\n }\n \n /// A fixed-size bitset type with a hybrid representation: sparse when there\n@@ -579,48 +711,6 @@ impl<T: Idx> HybridBitSet<T> {\n         }\n     }\n \n-    pub fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n-        match self {\n-            HybridBitSet::Sparse(self_sparse) => {\n-                match other {\n-                    HybridBitSet::Sparse(other_sparse) => {\n-                        // Both sets are sparse. Add the elements in\n-                        // `other_sparse` to `self` one at a time. This\n-                        // may or may not cause `self` to be densified.\n-                        assert_eq!(self.domain_size(), other.domain_size());\n-                        let mut changed = false;\n-                        for elem in other_sparse.iter() {\n-                            changed |= self.insert(*elem);\n-                        }\n-                        changed\n-                    }\n-                    HybridBitSet::Dense(other_dense) => {\n-                        // `self` is sparse and `other` is dense. To\n-                        // merge them, we have two available strategies:\n-                        // * Densify `self` then merge other\n-                        // * Clone other then integrate bits from `self`\n-                        // The second strategy requires dedicated method\n-                        // since the usual `union` returns the wrong\n-                        // result. In the dedicated case the computation\n-                        // is slightly faster if the bits of the sparse\n-                        // bitset map to only few words of the dense\n-                        // representation, i.e. indices are near each\n-                        // other.\n-                        //\n-                        // Benchmarking seems to suggest that the second\n-                        // option is worth it.\n-                        let mut new_dense = other_dense.clone();\n-                        let changed = new_dense.reverse_union_sparse(self_sparse);\n-                        *self = HybridBitSet::Dense(new_dense);\n-                        changed\n-                    }\n-                }\n-            }\n-\n-            HybridBitSet::Dense(self_dense) => self_dense.union(other),\n-        }\n-    }\n-\n     /// Converts to a dense set, consuming itself in the process.\n     pub fn to_dense(self) -> BitSet<T> {\n         match self {\n@@ -635,24 +725,8 @@ impl<T: Idx> HybridBitSet<T> {\n             HybridBitSet::Dense(dense) => HybridIter::Dense(dense.iter()),\n         }\n     }\n-}\n \n-impl<T: Idx> UnionIntoBitSet<T> for HybridBitSet<T> {\n-    fn union_into(&self, other: &mut BitSet<T>) -> bool {\n-        match self {\n-            HybridBitSet::Sparse(sparse) => sparse.union_into(other),\n-            HybridBitSet::Dense(dense) => dense.union_into(other),\n-        }\n-    }\n-}\n-\n-impl<T: Idx> SubtractFromBitSet<T> for HybridBitSet<T> {\n-    fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n-        match self {\n-            HybridBitSet::Sparse(sparse) => sparse.subtract_from(other),\n-            HybridBitSet::Dense(dense) => dense.subtract_from(other),\n-        }\n-    }\n+    bit_relations_inherent_impls! {}\n }\n \n pub enum HybridIter<'a, T: Idx> {\n@@ -974,6 +1048,19 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         self.ensure_row(row).insert(column)\n     }\n \n+    pub fn remove(&mut self, row: R, column: C) -> bool {\n+        match self.rows.get_mut(row) {\n+            Some(Some(row)) => row.remove(column),\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn clear(&mut self, row: R) {\n+        if let Some(Some(row)) = self.rows.get_mut(row) {\n+            row.clear();\n+        }\n+    }\n+\n     /// Do the bits from `row` contain `column`? Put another way, is\n     /// the matrix cell at `(row, column)` true?  Put yet another way,\n     /// if the matrix represents (transitive) reachability, can\n@@ -1002,11 +1089,6 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         }\n     }\n \n-    /// Union a row, `from`, into the `into` row.\n-    pub fn union_into_row(&mut self, into: R, from: &HybridBitSet<C>) -> bool {\n-        self.ensure_row(into).union(from)\n-    }\n-\n     /// Insert all bits in the given row.\n     pub fn insert_all_into_row(&mut self, row: R) {\n         self.ensure_row(row).insert_all();\n@@ -1025,6 +1107,33 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     pub fn row(&self, row: R) -> Option<&HybridBitSet<C>> {\n         if let Some(Some(row)) = self.rows.get(row) { Some(row) } else { None }\n     }\n+\n+    pub fn intersect_row<Set>(&mut self, row: R, set: &Set) -> bool\n+    where\n+        HybridBitSet<C>: BitRelations<Set>,\n+    {\n+        match self.rows.get_mut(row) {\n+            Some(Some(row)) => row.intersect(set),\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn subtract_row<Set>(&mut self, row: R, set: &Set) -> bool\n+    where\n+        HybridBitSet<C>: BitRelations<Set>,\n+    {\n+        match self.rows.get_mut(row) {\n+            Some(Some(row)) => row.subtract(set),\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn union_row<Set>(&mut self, row: R, set: &Set) -> bool\n+    where\n+        HybridBitSet<C>: BitRelations<Set>,\n+    {\n+        self.ensure_row(row).union(set)\n+    }\n }\n \n #[inline]"}, {"sha": "2864abde0022c15e2c54e60ce4d80e9bcfd66699", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79e0a0faf93922f77f7658d2b1b95c79c9bd9608/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79e0a0faf93922f77f7658d2b1b95c79c9bd9608/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fvalues.rs?ref=79e0a0faf93922f77f7658d2b1b95c79c9bd9608", "patch": "@@ -160,7 +160,7 @@ impl<N: Idx> LivenessValues<N> {\n     /// region. Returns whether any of them are newly added.\n     crate fn add_elements(&mut self, row: N, locations: &HybridBitSet<PointIndex>) -> bool {\n         debug!(\"LivenessValues::add_elements(row={:?}, locations={:?})\", row, locations);\n-        self.points.union_into_row(row, locations)\n+        self.points.union_row(row, locations)\n     }\n \n     /// Adds all the control-flow points to the values for `r`.\n@@ -294,7 +294,7 @@ impl<N: Idx> RegionValues<N> {\n     /// the region `to` in `self`.\n     crate fn merge_liveness<M: Idx>(&mut self, to: N, from: M, values: &LivenessValues<M>) {\n         if let Some(set) = values.points.row(from) {\n-            self.points.union_into_row(to, set);\n+            self.points.union_row(to, set);\n         }\n     }\n "}, {"sha": "acdaa5b456857becc07abb70e482f0440a711b32", "filename": "compiler/rustc_mir/src/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/79e0a0faf93922f77f7658d2b1b95c79c9bd9608/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79e0a0faf93922f77f7658d2b1b95c79c9bd9608/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs?ref=79e0a0faf93922f77f7658d2b1b95c79c9bd9608", "patch": "@@ -626,7 +626,7 @@ fn compute_storage_conflicts(\n     // Locals that are always live or ones that need to be stored across\n     // suspension points are not eligible for overlap.\n     let mut ineligible_locals = always_live_locals.into_inner();\n-    ineligible_locals.intersect(saved_locals);\n+    ineligible_locals.intersect(&**saved_locals);\n \n     // Compute the storage conflicts for all eligible locals.\n     let mut visitor = StorageConflictVisitor {\n@@ -701,7 +701,7 @@ impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n         }\n \n         let mut eligible_storage_live = flow_state.clone();\n-        eligible_storage_live.intersect(&self.saved_locals);\n+        eligible_storage_live.intersect(&**self.saved_locals);\n \n         for local in eligible_storage_live.iter() {\n             self.local_conflicts.union_row_with(&eligible_storage_live, local);"}]}