{"sha": "9b75a2bcd10918a8cde91962a1998615123a401e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNzVhMmJjZDEwOTE4YThjZGU5MTk2MmExOTk4NjE1MTIzYTQwMWU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-17T17:26:22Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-17T18:53:44Z"}, "message": "make trait matching smarter with projections\n\nalso, use the right caching logic for type_moves_by_default (this was\nbroken by @jroesch).\n\nbefore:\n593.10user 5.21system 7:51.41elapsed 126%CPU (0avgtext+0avgdata 1150016maxresident)k\nllvm: 427.045\n\nafter:\n577.76user 4.27system 7:36.13elapsed 127%CPU (0avgtext+0avgdata 1141608maxresident)k\nllvm: 431.001", "tree": {"sha": "3c3ee991f9d43135d8b16173f82a043eaa162b25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c3ee991f9d43135d8b16173f82a043eaa162b25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b75a2bcd10918a8cde91962a1998615123a401e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b75a2bcd10918a8cde91962a1998615123a401e", "html_url": "https://github.com/rust-lang/rust/commit/9b75a2bcd10918a8cde91962a1998615123a401e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b75a2bcd10918a8cde91962a1998615123a401e/comments", "author": null, "committer": null, "parents": [{"sha": "a49d9bab1e79d44321e6a8e1a8cb81a4ffa6bad9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a49d9bab1e79d44321e6a8e1a8cb81a4ffa6bad9", "html_url": "https://github.com/rust-lang/rust/commit/a49d9bab1e79d44321e6a8e1a8cb81a4ffa6bad9"}], "stats": {"total": 38, "additions": 30, "deletions": 8}, "files": [{"sha": "11d9512034440e445daf54e8e170669193103bd5", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b75a2bcd10918a8cde91962a1998615123a401e/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b75a2bcd10918a8cde91962a1998615123a401e/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=9b75a2bcd10918a8cde91962a1998615123a401e", "patch": "@@ -85,11 +85,13 @@ pub fn simplify_type(tcx: &ty::ctxt,\n         ty::TyBareFn(_, ref f) => {\n             Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n         }\n-        ty::TyProjection(_) => {\n-            None\n-        }\n-        ty::TyParam(_) => {\n+        ty::TyProjection(_) | ty::TyParam(_) => {\n             if can_simplify_params {\n+                // In normalized types, projections don't unify with\n+                // anything. when lazy normalization happens, this\n+                // will change. It would still be nice to have a way\n+                // to deal with known-not-to-unify-with-anything\n+                // projections (e.g. the likes of <__S as Encoder>::Error).\n                 Some(ParameterSimplifiedType)\n             } else {\n                 None"}, {"sha": "1b47ce75bc50d17d007a68c8190167cc7e83e52d", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b75a2bcd10918a8cde91962a1998615123a401e/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b75a2bcd10918a8cde91962a1998615123a401e/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=9b75a2bcd10918a8cde91962a1998615123a401e", "patch": "@@ -1456,9 +1456,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n-        !traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundCopy, span)\n-        // FIXME(@jroesch): should be able to use:\n-        // ty.moves_by_default(&self.parameter_environment, span)\n+        if ty.needs_infer() {\n+            // this can get called from typeck (by euv), and moves_by_default\n+            // rightly refuses to work with inference variables, but\n+            // moves_by_default has a cache, which we want to use in other\n+            // cases.\n+            !traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundCopy, span)\n+        } else {\n+            ty.moves_by_default(&self.parameter_environment, span)\n+        }\n     }\n \n     pub fn node_method_ty(&self, method_call: ty::MethodCall)"}, {"sha": "9f5b24c6b765b931970917b4f5bb342e31eb40e4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9b75a2bcd10918a8cde91962a1998615123a401e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b75a2bcd10918a8cde91962a1998615123a401e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9b75a2bcd10918a8cde91962a1998615123a401e", "patch": "@@ -3192,6 +3192,8 @@ impl<'tcx> TraitDef<'tcx> {\n         }\n     }\n \n+    /// Iterate over every impl that could possibly match the\n+    /// self-type `self_ty`.\n     pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n                                                    tcx: &ctxt<'tcx>,\n                                                    self_ty: Ty<'tcx>,\n@@ -3203,7 +3205,19 @@ impl<'tcx> TraitDef<'tcx> {\n             f(impl_def_id);\n         }\n \n-        if let Some(simp) = fast_reject::simplify_type(tcx, self_ty, false) {\n+        // simplify_type(.., false) basically replaces type parameters and\n+        // projections with infer-variables. This is, of course, done on\n+        // the impl trait-ref when it is instantiated, but not on the\n+        // predicate trait-ref which is passed here.\n+        //\n+        // for example, if we match `S: Copy` against an impl like\n+        // `impl<T:Copy> Copy for Option<T>`, we replace the type variable\n+        // in `Option<T>` with an infer variable, to `Option<_>` (this\n+        // doesn't actually change fast_reject output), but we don't\n+        // replace `S` with anything - this impl of course can't be\n+        // selected, and as there are hundreds of similar impls,\n+        // considering them would significantly harm performance.\n+        if let Some(simp) = fast_reject::simplify_type(tcx, self_ty, true) {\n             if let Some(impls) = self.nonblanket_impls.borrow().get(&simp) {\n                 for &impl_def_id in impls {\n                     f(impl_def_id);"}]}