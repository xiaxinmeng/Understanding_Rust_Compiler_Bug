{"sha": "433a46781544da61801400316e7e546f01b81952", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzM2E0Njc4MTU0NGRhNjE4MDE0MDAzMTZlN2U1NDZmMDFiODE5NTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-28T14:08:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-28T14:08:07Z"}, "message": "Auto merge of #62192 - Centril:rollup-kssnlta, r=Centril\n\nRollup of 16 pull requests\n\nSuccessful merges:\n\n - #61878 (improve pinning projection docs)\n - #62043 (Remove `FnBox`)\n - #62067 (Add suggestion for missing `.await` keyword)\n - #62076 (Updated RELEASES.md for 1.36.0)\n - #62102 (call out explicitly that general read needs to be called with an initialized buffer)\n - #62106 (Add more tests for async/await)\n - #62124 (refactor lexer to use idiomatic borrowing)\n - #62131 (libsyntax: Fix some Clippy warnings)\n - #62152 (Don't ICE on item in `.await` expression)\n - #62154 (Remove old fixme)\n - #62155 (Add regression test for MIR drop generation in async loops)\n - #62156 (Update books)\n - #62160 (Remove outdated question_mark_macro_sep lint)\n - #62164 (save-analysis: use buffered writes)\n - #62171 (rustc: Retry SIGILL linker invocations)\n - #62176 (Update RLS)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "7e2aa52a91f7af676fb2a73b88c4f5589f90a7ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e2aa52a91f7af676fb2a73b88c4f5589f90a7ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/433a46781544da61801400316e7e546f01b81952", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/433a46781544da61801400316e7e546f01b81952", "html_url": "https://github.com/rust-lang/rust/commit/433a46781544da61801400316e7e546f01b81952", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/433a46781544da61801400316e7e546f01b81952/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3849a5f83b82258fd76a3ff64933b81d7efeffa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3849a5f83b82258fd76a3ff64933b81d7efeffa1", "html_url": "https://github.com/rust-lang/rust/commit/3849a5f83b82258fd76a3ff64933b81d7efeffa1"}, {"sha": "65f1ff41d2174099744e4a22568707d29faeb46e", "url": "https://api.github.com/repos/rust-lang/rust/commits/65f1ff41d2174099744e4a22568707d29faeb46e", "html_url": "https://github.com/rust-lang/rust/commit/65f1ff41d2174099744e4a22568707d29faeb46e"}], "stats": {"total": 1532, "additions": 1113, "deletions": 419}, "files": [{"sha": "b6e2171f6eef9f75899a4fd8d247191fca55a1e4", "filename": "RELEASES.md", "status": "modified", "additions": 102, "deletions": 1, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -1,3 +1,104 @@\n+Version 1.36.0 (2019-07-04)\n+==========================\n+\n+Language\n+--------\n+- [Non-Lexical Lifetimes are now enabled on the 2015 edition.][59114]\n+- [The order of traits in trait objects no longer affects the semantics of that\n+  object.][59445] e.g. `dyn Send + fmt::Debug` is now equivalent to\n+  `dyn fmt::Debug + Send`, where this was previously not the case.\n+\n+Libraries\n+---------\n+- [`HashMap`'s implementation has been replaced with `hashbrown::HashMap` implementation.][58623]\n+- [`TryFromSliceError` now implements `From<Infallible>`.][60318]\n+- [`mem::needs_drop` is now available as a const fn.][60364]\n+- [`alloc::Layout::from_size_align_unchecked` is now available as a const fn.][60370]\n+- [`String` now implements `BorrowMut<str>`.][60404]\n+- [`io::Cursor` now implements `Default`.][60234]\n+- [Both `NonNull::{dangling, cast}` are now const fns.][60244]\n+- [The `alloc` crate is now stable.][59675] `alloc` allows you to use a subset\n+  of `std` (e.g. `Vec`, `Box`, `Arc`) in `#![no_std]` environments if the\n+  environment has access to heap memory allocation.\n+- [`String` now implements `From<&String>`.][59825]\n+- [You can now pass multiple arguments to the `dbg!` macro.][59826] `dbg!` will\n+  return a tuple of each argument when there is multiple arguments.\n+- [`Result::{is_err, is_ok}` are now `#[must_use]` and will produce a warning if\n+  not used.][59648]\n+\n+Stabilized APIs\n+---------------\n+- [`VecDeque::rotate_left`]\n+- [`VecDeque::rotate_right`]\n+- [`Iterator::copied`]\n+- [`io::IoSlice`]\n+- [`io::IoSliceMut`]\n+- [`Read::read_vectored`]\n+- [`Write::write_vectored`]\n+- [`str::as_mut_ptr`]\n+- [`mem::MaybeUninit`]\n+- [`pointer::align_offset`]\n+- [`future::Future`]\n+- [`task::Context`] \n+- [`task::RawWaker`]\n+- [`task::RawWakerVTable`]\n+- [`task::Waker`]\n+- [`task::Poll`]\n+\n+Cargo\n+-----\n+- [Cargo will now produce an error if you attempt to use the name of a required dependency as a feature.][cargo/6860]\n+- [You can now pass the `--offline` flag to run cargo without accessing the network.][cargo/6934]\n+\n+You can find further change's in [Cargo's 1.36.0 release notes][cargo-1-36-0].\n+\n+Clippy\n+------\n+There have been numerous additions and fixes to clippy, see [Clippy's 1.36.0 release notes][clippy-1-36-0] for more details.\n+\n+Misc\n+----\n+\n+Compatibility Notes\n+-------------------\n+- With the stabilisation of `mem::MaybeUninit`, `mem::uninitialized` use is no\n+  longer recommended, and will be deprecated in 1.38.0.\n+\n+[60318]: https://github.com/rust-lang/rust/pull/60318/\n+[60364]: https://github.com/rust-lang/rust/pull/60364/\n+[60370]: https://github.com/rust-lang/rust/pull/60370/\n+[60404]: https://github.com/rust-lang/rust/pull/60404/\n+[60234]: https://github.com/rust-lang/rust/pull/60234/\n+[60244]: https://github.com/rust-lang/rust/pull/60244/\n+[58623]: https://github.com/rust-lang/rust/pull/58623/\n+[59648]: https://github.com/rust-lang/rust/pull/59648/\n+[59675]: https://github.com/rust-lang/rust/pull/59675/\n+[59825]: https://github.com/rust-lang/rust/pull/59825/\n+[59826]: https://github.com/rust-lang/rust/pull/59826/\n+[59445]: https://github.com/rust-lang/rust/pull/59445/\n+[59114]: https://github.com/rust-lang/rust/pull/59114/\n+[cargo/6860]: https://github.com/rust-lang/cargo/pull/6860/\n+[cargo/6934]: https://github.com/rust-lang/cargo/pull/6934/\n+[`VecDeque::rotate_left`]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.rotate_left\n+[`VecDeque::rotate_right`]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.rotate_right\n+[`Iterator::copied`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.copied\n+[`io::IoSlice`]: https://doc.rust-lang.org/std/io/struct.IoSlice.html\n+[`io::IoSliceMut`]: https://doc.rust-lang.org/std/io/struct.IoSliceMut.html\n+[`Read::read_vectored`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_vectored\n+[`Write::write_vectored`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_vectored\n+[`str::as_mut_ptr`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_mut_ptr\n+[`mem::MaybeUninit`]: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\n+[`pointer::align_offset`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.align_offset\n+[`future::Future`]: https://doc.rust-lang.org/std/future/trait.Future.html\n+[`task::Context`]: https://doc.rust-lang.org/beta/std/task/struct.Context.html\n+[`task::RawWaker`]: https://doc.rust-lang.org/beta/std/task/struct.RawWaker.html\n+[`task::RawWakerVTable`]: https://doc.rust-lang.org/beta/std/task/struct.RawWakerVTable.html\n+[`task::Waker`]: https://doc.rust-lang.org/beta/std/task/struct.Waker.html\n+[`task::Poll`]: https://doc.rust-lang.org/beta/std/task/enum.Poll.html\n+[clippy-1-36-0]: https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-136\n+[cargo-1-36-0]: https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-136-2019-07-04\n+\n+\n Version 1.35.0 (2019-05-23)\n ==========================\n \n@@ -62,7 +163,7 @@ Cargo\n - [You can now set `cargo:rustc-cdylib-link-arg` at build time to pass custom\n   linker arguments when building a `cdylib`.][cargo/6298] Its usage is highly\n   platform specific.\n-  \n+\n Misc\n ----\n - [The Rust toolchain is now available natively for musl based distros.][58575]"}, {"sha": "6c0d83499c8e77e06a71d28c5e1adccec278d4f3", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -1 +1 @@\n-Subproject commit 9aacfcc4c5b102c8cda195932addefd32fe955d2\n+Subproject commit 6c0d83499c8e77e06a71d28c5e1adccec278d4f3"}, {"sha": "341c221116a8b9f1010cf1eece952b80c5ec7f54", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -1 +1 @@\n-Subproject commit c656171b749b7307f21371dd0d3278efee5573b8\n+Subproject commit 341c221116a8b9f1010cf1eece952b80c5ec7f54"}, {"sha": "7a5aab5fd50d6290679beb4cf42fa5f46ed22aec", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -1 +1 @@\n-Subproject commit 08ae27a4921ca53967656a7391c82f6c0ddd1ccc\n+Subproject commit 7a5aab5fd50d6290679beb4cf42fa5f46ed22aec"}, {"sha": "62b3ff2cb44dd8b648c3ef2a9347c3706d148014", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -1 +1 @@\n-Subproject commit b27472962986e85c94f4183b1a6d2207660d3ed6\n+Subproject commit 62b3ff2cb44dd8b648c3ef2a9347c3706d148014"}, {"sha": "abf512fc9cc969dcbea69aa15b44586bbeb13c2d", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -1 +1 @@\n-Subproject commit f55e97c145cf37fd664db2e0e2f2d05df328bf4f\n+Subproject commit abf512fc9cc969dcbea69aa15b44586bbeb13c2d"}, {"sha": "343084b7db5016f9fef3ea74be335ea3d4ded529", "filename": "src/doc/unstable-book/src/language-features/unsized-locals.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -117,9 +117,7 @@ fn main () {\n }\n ```\n \n-One of the objectives of this feature is to allow `Box<dyn FnOnce>`, instead of `Box<dyn FnBox>` in the future. See [#28796] for details.\n-\n-[#28796]: https://github.com/rust-lang/rust/issues/28796\n+One of the objectives of this feature is to allow `Box<dyn FnOnce>`.\n \n ## Variable length arrays\n "}, {"sha": "97e32cc0acb121ef319d51fa79275dbd5e2073ba", "filename": "src/doc/unstable-book/src/library-features/fnbox.md", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3849a5f83b82258fd76a3ff64933b81d7efeffa1/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffnbox.md", "raw_url": "https://github.com/rust-lang/rust/raw/3849a5f83b82258fd76a3ff64933b81d7efeffa1/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffnbox.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffnbox.md?ref=3849a5f83b82258fd76a3ff64933b81d7efeffa1", "patch": "@@ -1,32 +0,0 @@\n-# `fnbox`\n-\n-The tracking issue for this feature is [#28796]\n-\n-[#28796]: https://github.com/rust-lang/rust/issues/28796\n-\n-------------------------\n-\n-This had been a temporary alternative to the following impls:\n-\n-```rust,ignore\n-impl<A, F> FnOnce for Box<F> where F: FnOnce<A> + ?Sized {}\n-impl<A, F> FnMut for Box<F> where F: FnMut<A> + ?Sized {}\n-impl<A, F> Fn for Box<F> where F: Fn<A> + ?Sized {}\n-```\n-\n-The impls are parallel to these (relatively old) impls:\n-\n-```rust,ignore\n-impl<A, F> FnOnce for &mut F where F: FnMut<A> + ?Sized {}\n-impl<A, F> FnMut for &mut F where F: FnMut<A> + ?Sized {}\n-impl<A, F> Fn for &mut F where F: Fn<A> + ?Sized {}\n-impl<A, F> FnOnce for &F where F: Fn<A> + ?Sized {}\n-impl<A, F> FnMut for &F where F: Fn<A> + ?Sized {}\n-impl<A, F> Fn for &F where F: Fn<A> + ?Sized {}\n-```\n-\n-Before the introduction of [`unsized_locals`][unsized_locals], we had been unable to provide the former impls. That means, unlike `&dyn Fn()` or `&mut dyn FnMut()` we could not use `Box<dyn FnOnce()>` at that time.\n-\n-[unsized_locals]: ../language-features/unsized-locals.md\n-\n-`FnBox()` is an alternative approach to `Box<dyn FnBox()>` is delegated to `FnBox::call_box` which doesn't need unsized locals. As we now have `Box<dyn FnOnce()>` working, the `fnbox` feature is going to be removed."}, {"sha": "9109a730cce2dd92a269166ef6e295c30191ada8", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -761,85 +761,6 @@ impl<A, F: Fn<A> + ?Sized> Fn<A> for Box<F> {\n     }\n }\n \n-/// `FnBox` is deprecated and will be removed.\n-/// `Box<dyn FnOnce()>` can be called directly, since Rust 1.35.0.\n-///\n-/// `FnBox` is a version of the `FnOnce` intended for use with boxed\n-/// closure objects. The idea was that where one would normally store a\n-/// `Box<dyn FnOnce()>` in a data structure, you whould use\n-/// `Box<dyn FnBox()>`. The two traits behave essentially the same, except\n-/// that a `FnBox` closure can only be called if it is boxed.\n-///\n-/// # Examples\n-///\n-/// Here is a snippet of code which creates a hashmap full of boxed\n-/// once closures and then removes them one by one, calling each\n-/// closure as it is removed. Note that the type of the closures\n-/// stored in the map is `Box<dyn FnBox() -> i32>` and not `Box<dyn FnOnce()\n-/// -> i32>`.\n-///\n-/// ```\n-/// #![feature(fnbox)]\n-/// #![allow(deprecated)]\n-///\n-/// use std::boxed::FnBox;\n-/// use std::collections::HashMap;\n-///\n-/// fn make_map() -> HashMap<i32, Box<dyn FnBox() -> i32>> {\n-///     let mut map: HashMap<i32, Box<dyn FnBox() -> i32>> = HashMap::new();\n-///     map.insert(1, Box::new(|| 22));\n-///     map.insert(2, Box::new(|| 44));\n-///     map\n-/// }\n-///\n-/// fn main() {\n-///     let mut map = make_map();\n-///     for i in &[1, 2] {\n-///         let f = map.remove(&i).unwrap();\n-///         assert_eq!(f(), i * 22);\n-///     }\n-/// }\n-/// ```\n-///\n-/// In Rust 1.35.0 or later, use `FnOnce`, `FnMut`, or `Fn` instead:\n-///\n-/// ```\n-/// use std::collections::HashMap;\n-///\n-/// fn make_map() -> HashMap<i32, Box<dyn FnOnce() -> i32>> {\n-///     let mut map: HashMap<i32, Box<dyn FnOnce() -> i32>> = HashMap::new();\n-///     map.insert(1, Box::new(|| 22));\n-///     map.insert(2, Box::new(|| 44));\n-///     map\n-/// }\n-///\n-/// fn main() {\n-///     let mut map = make_map();\n-///     for i in &[1, 2] {\n-///         let f = map.remove(&i).unwrap();\n-///         assert_eq!(f(), i * 22);\n-///     }\n-/// }\n-/// ```\n-#[rustc_paren_sugar]\n-#[unstable(feature = \"fnbox\", issue = \"28796\")]\n-#[rustc_deprecated(reason = \"use `FnOnce`, `FnMut`, or `Fn` instead\", since = \"1.37.0\")]\n-pub trait FnBox<A>: FnOnce<A> {\n-    /// Performs the call operation.\n-    fn call_box(self: Box<Self>, args: A) -> Self::Output;\n-}\n-\n-#[unstable(feature = \"fnbox\", issue = \"28796\")]\n-#[rustc_deprecated(reason = \"use `FnOnce`, `FnMut`, or `Fn` instead\", since = \"1.37.0\")]\n-#[allow(deprecated, deprecated_in_future)]\n-impl<A, F> FnBox<A> for F\n-    where F: FnOnce<A>\n-{\n-    fn call_box(self: Box<F>, args: A) -> F::Output {\n-        self.call_once(args)\n-    }\n-}\n-\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n "}, {"sha": "acca8d7ba15339e1ddae04985f0fa081d4fd09fb", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -25,6 +25,7 @@ use crate::task::{Context, Poll};\n #[doc(spotlight)]\n #[must_use = \"futures do nothing unless you `.await` or poll them\"]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+#[cfg_attr(not(bootstrap), lang = \"future_trait\")]\n pub trait Future {\n     /// The type of value produced on completion.\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]"}, {"sha": "c063cee52270ea448f9ae90e486484d17c26a6d3", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 130, "deletions": 41, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -138,10 +138,11 @@\n //! To make this work, not just moving the data is restricted; deallocating, repurposing, or\n //! otherwise invalidating the memory used to store the data is restricted, too.\n //! Concretely, for pinned data you have to maintain the invariant\n-//! that *its memory will not get invalidated from the moment it gets pinned until\n+//! that *its memory will not get invalidated or repurposed from the moment it gets pinned until\n //! when `drop` is called*. Memory can be invalidated by deallocation, but also by\n //! replacing a [`Some(v)`] by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements\n-//! off of a vector.\n+//! off of a vector. It can be repurposed by using [`ptr::write`] to overwrite it without\n+//! calling the destructor first.\n //!\n //! This is exactly the kind of guarantee that the intrusive linked list from the previous\n //! section needs to function correctly.\n@@ -166,57 +167,130 @@\n //! implementation as well: if an element of your type could have been pinned,\n //! you must treat Drop as implicitly taking `Pin<&mut Self>`.\n //!\n-//! In particular, if your type is `#[repr(packed)]`, the compiler will automatically\n+//! For example, you could implement `Drop` as follows:\n+//! ```rust,no_run\n+//! # use std::pin::Pin;\n+//! # struct Type { }\n+//! impl Drop for Type {\n+//!     fn drop(&mut self) {\n+//!         // `new_unchecked` is okay because we know this value is never used\n+//!         // again after being dropped.\n+//!         inner_drop(unsafe { Pin::new_unchecked(self)});\n+//!         fn inner_drop(this: Pin<&mut Type>) {\n+//!             // Actual drop code goes here.\n+//!         }\n+//!     }\n+//! }\n+//! ```\n+//! The function `inner_drop` has the type that `drop` *should* have, so this makes sure that\n+//! you do not accidentally use `self`/`this` in a way that is in conflict with pinning.\n+//!\n+//! Moreover, if your type is `#[repr(packed)]`, the compiler will automatically\n //! move fields around to be able to drop them. As a consequence, you cannot use\n //! pinning with a `#[repr(packed)]` type.\n //!\n //! # Projections and Structural Pinning\n //!\n-//! One interesting question arises when considering the interaction of pinning\n-//! and the fields of a struct. When can a struct have a \"pinning projection\",\n-//! i.e., an operation with type `fn(Pin<&Struct>) -> Pin<&Field>`?  In a\n-//! similar vein, when can a generic wrapper type (such as `Vec<T>`, `Box<T>`,\n-//! or `RefCell<T>`) have an operation with type `fn(Pin<&Wrapper<T>>) ->\n-//! Pin<&T>`?\n-//!\n-//! Note: For the entirety of this discussion, the same applies for mutable references as it\n-//! does for shared references.\n+//! When working with pinned structs, the question arises how one can access the\n+//! fields of that struct in a method that takes just `Pin<&mut Struct>`.\n+//! The usual approach is to write helper methods (so called *projections*)\n+//! that turn `Pin<&mut Struct>` into a reference to the field, but what\n+//! type should that reference have? Is it `Pin<&mut Field>` or `&mut Field`?\n+//! The same question arises with the fields of an `enum`, and also when considering\n+//! container/wrapper types such as [`Vec<T>`], [`Box<T>`], or [`RefCell<T>`].\n+//! (This question applies to both mutable and shared references, we just\n+//! use the more common case of mutable references here for illustration.)\n+//!\n+//! It turns out that it is actually up to the author of the data structure\n+//! to decide whether the pinned projection for a particular field turns\n+//! `Pin<&mut Struct>` into `Pin<&mut Field>` or `&mut Field`. There are some\n+//! constraints though, and the most important constraint is *consistency*:\n+//! every field can be *either* projected to a pinned reference, *or* have\n+//! pinning removed as part of the projection. If both are done for the same field,\n+//! that will likely be unsound!\n+//!\n+//! As the author of a data structure you get to decide for each field whether pinning\n+//! \"propagates\" to this field or not. Pinning that propagates is also called \"structural\",\n+//! because it follows the structure of the type.\n+//! In the following subsections, we describe the considerations that have to be made\n+//! for either choice.\n+//!\n+//! ## Pinning *is not* structural for `field`\n+//!\n+//! It may seem counter-intuitive that the field of a pinned struct might not be pinned,\n+//! but that is actually the easiest choice: if a `Pin<&mut Field>` is never created,\n+//! nothing can go wrong! So, if you decide that some field does not have structural pinning,\n+//! all you have to ensure is that you never create a pinned reference to that field.\n+//!\n+//! Fields without structural pinning may have a projection method that turns\n+//! `Pin<&mut Struct>` into `&mut Field`:\n+//! ```rust,no_run\n+//! # use std::pin::Pin;\n+//! # type Field = i32;\n+//! # struct Struct { field: Field }\n+//! impl Struct {\n+//!     fn pin_get_field<'a>(self: Pin<&'a mut Self>) -> &'a mut Field {\n+//!         // This is okay because `field` is never considered pinned.\n+//!         unsafe { &mut self.get_unchecked_mut().field }\n+//!     }\n+//! }\n+//! ```\n //!\n-//! Having a pinning projection for some field means that pinning is \"structural\":\n-//! when the wrapper is pinned, the field must be considered pinned, too.\n-//! After all, the pinning projection lets us get a `Pin<&Field>`.\n+//! You may also `impl Unpin for Struct` *even if* the type of `field`\n+//! is not `Unpin`. What that type thinks about pinning is not relevant\n+//! when no `Pin<&mut Field>` is ever created.\n+//!\n+//! ## Pinning *is* structural for `field`\n+//!\n+//! The other option is to decide that pinning is \"structural\" for `field`,\n+//! meaning that if the struct is pinned then so is the field.\n+//!\n+//! This allows writing a projection that creates a `Pin<&mut Field>`, thus\n+//! witnessing that the field is pinned:\n+//! ```rust,no_run\n+//! # use std::pin::Pin;\n+//! # type Field = i32;\n+//! # struct Struct { field: Field }\n+//! impl Struct {\n+//!     fn pin_get_field<'a>(self: Pin<&'a mut Self>) -> Pin<&'a mut Field> {\n+//!         // This is okay because `field` is pinned when `self` is.\n+//!         unsafe { self.map_unchecked_mut(|s| &mut s.field) }\n+//!     }\n+//! }\n+//! ```\n //!\n-//! However, structural pinning comes with a few extra requirements, so not all\n-//! wrappers can be structural and hence not all wrappers can offer pinning projections:\n+//! However, structural pinning comes with a few extra requirements:\n //!\n-//! 1.  The wrapper must only be [`Unpin`] if all the structural fields are\n+//! 1.  The struct must only be [`Unpin`] if all the structural fields are\n //!     `Unpin`. This is the default, but `Unpin` is a safe trait, so as the author of\n-//!     the wrapper it is your responsibility *not* to add something like\n-//!     `impl<T> Unpin for Wrapper<T>`. (Notice that adding a projection operation\n+//!     the struct it is your responsibility *not* to add something like\n+//!     `impl<T> Unpin for Struct<T>`. (Notice that adding a projection operation\n //!     requires unsafe code, so the fact that `Unpin` is a safe trait does not break\n //!     the principle that you only have to worry about any of this if you use `unsafe`.)\n-//! 2.  The destructor of the wrapper must not move structural fields out of its argument. This\n+//! 2.  The destructor of the struct must not move structural fields out of its argument. This\n //!     is the exact point that was raised in the [previous section][drop-impl]: `drop` takes\n-//!     `&mut self`, but the wrapper (and hence its fields) might have been pinned before.\n+//!     `&mut self`, but the struct (and hence its fields) might have been pinned before.\n //!     You have to guarantee that you do not move a field inside your `Drop` implementation.\n-//!     In particular, as explained previously, this means that your wrapper type must *not*\n+//!     In particular, as explained previously, this means that your struct must *not*\n //!     be `#[repr(packed)]`.\n+//!     See that section for how to write `drop` in a way that the compiler can help you\n+//!     not accidentally break pinning.\n //! 3.  You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n-//!     once your wrapper is pinned, the memory that contains the\n+//!     once your struct is pinned, the memory that contains the\n //!     content is not overwritten or deallocated without calling the content's destructors.\n-//!     This can be tricky, as witnessed by `VecDeque<T>`: the destructor of `VecDeque<T>` can fail\n-//!     to call `drop` on all elements if one of the destructors panics. This violates the\n+//!     This can be tricky, as witnessed by [`VecDeque<T>`]: the destructor of `VecDeque<T>`\n+//!     can fail to call `drop` on all elements if one of the destructors panics. This violates the\n //!     `Drop` guarantee, because it can lead to elements being deallocated without\n //!     their destructor being called. (`VecDeque` has no pinning projections, so this\n //!     does not cause unsoundness.)\n //! 4.  You must not offer any other operations that could lead to data being moved out of\n-//!     the fields when your type is pinned. For example, if the wrapper contains an\n+//!     the structural fields when your type is pinned. For example, if the struct contains an\n //!     `Option<T>` and there is a `take`-like operation with type\n-//!     `fn(Pin<&mut Wrapper<T>>) -> Option<T>`,\n-//!     that operation can be used to move a `T` out of a pinned `Wrapper<T>` -- which means\n-//!     pinning cannot be structural.\n+//!     `fn(Pin<&mut Struct<T>>) -> Option<T>`,\n+//!     that operation can be used to move a `T` out of a pinned `Struct<T>` -- which means\n+//!     pinning cannot be structural for the field holding this data.\n //!\n-//!     For a more complex example of moving data out of a pinned type, imagine if `RefCell<T>`\n+//!     For a more complex example of moving data out of a pinned type, imagine if [`RefCell<T>`]\n //!     had a method `fn get_pin_mut(self: Pin<&mut Self>) -> Pin<&mut T>`.\n //!     Then we could do the following:\n //!     ```compile_fail\n@@ -231,13 +305,16 @@\n //!     (using `RefCell::get_pin_mut`) and then move that content using the mutable\n //!     reference we got later.\n //!\n-//! For a type like `Vec<T>`, both possibilites (structural pinning or not) make sense,\n-//! and the choice is up to the author. A `Vec<T>` with structural pinning could\n-//! have `get_pin`/`get_pin_mut` projections. However, it could *not* allow calling\n+//! ## Examples\n+//!\n+//! For a type like [`Vec<T>`], both possibilites (structural pinning or not) make sense.\n+//! A `Vec<T>` with structural pinning could have `get_pin`/`get_pin_mut` methods to get\n+//! pinned references to elements. However, it could *not* allow calling\n //! `pop` on a pinned `Vec<T>` because that would move the (structurally pinned) contents!\n //! Nor could it allow `push`, which might reallocate and thus also move the contents.\n //! A `Vec<T>` without structural pinning could `impl<T> Unpin for Vec<T>`, because the contents\n //! are never pinned and the `Vec<T>` itself is fine with being moved as well.\n+//! At that point pinning just has no effect on the vector at all.\n //!\n //! In the standard library, pointer types generally do not have structural pinning,\n //! and thus they do not offer pinning projections. This is why `Box<T>: Unpin` holds for all `T`.\n@@ -249,16 +326,28 @@\n //! whether the content is pinned is entirely independent of whether the pointer is\n //! pinned, meaning pinning is *not* structural.\n //!\n+//! When implementing a [`Future`] combinator, you will usually need structural pinning\n+//! for the nested futures, as you need to get pinned references to them to call `poll`.\n+//! But if your combinator contains any other data that does not need to be pinned,\n+//! you can make those fields not structural and hence freely access them with a\n+//! mutable reference even when you just have `Pin<&mut Self>` (such as in your own\n+//! `poll` implementation).\n+//!\n //! [`Pin<P>`]: struct.Pin.html\n-//! [`Unpin`]: ../../std/marker/trait.Unpin.html\n-//! [`Deref`]: ../../std/ops/trait.Deref.html\n-//! [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n-//! [`mem::swap`]: ../../std/mem/fn.swap.html\n-//! [`mem::forget`]: ../../std/mem/fn.forget.html\n+//! [`Unpin`]: ../marker/trait.Unpin.html\n+//! [`Deref`]: ../ops/trait.Deref.html\n+//! [`DerefMut`]: ../ops/trait.DerefMut.html\n+//! [`mem::swap`]: ../mem/fn.swap.html\n+//! [`mem::forget`]: ../mem/fn.forget.html\n //! [`Box<T>`]: ../../std/boxed/struct.Box.html\n+//! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n //! [`Vec::set_len`]: ../../std/vec/struct.Vec.html#method.set_len\n-//! [`None`]: ../../std/option/enum.Option.html#variant.None\n-//! [`Some(v)`]: ../../std/option/enum.Option.html#variant.Some\n+//! [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n+//! [`RefCell<T>`]: ../cell/struct.RefCell.html\n+//! [`None`]: ../option/enum.Option.html#variant.None\n+//! [`Some(v)`]: ../option/enum.Option.html#variant.Some\n+//! [`ptr::write`]: ../ptr/fn.write.html\n+//! [`Future`]: ../future/trait.Future.html\n //! [drop-impl]: #drop-implementation\n //! [drop-guarantee]: #drop-guarantee\n "}, {"sha": "9c4a208f0f9fc92fb4e193ab508918d06097b3ae", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -5795,7 +5795,6 @@ impl<'a> LoweringContext<'a> {\n                     err.span_label(item_sp, \"this is not `async`\");\n                 }\n                 err.emit();\n-                return hir::ExprKind::Err;\n             }\n         }\n         let span = self.mark_span_with_reason("}, {"sha": "6df1c2d8c77e5e3a69e7018622165f61b380196e", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -1713,7 +1713,7 @@ pub enum GeneratorMovability {\n }\n \n /// The yield kind that caused an `ExprKind::Yield`.\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum YieldSource {\n     /// An `<expr>.await`.\n     Await,"}, {"sha": "45e598531b969061f39e605f143100ad736fea7e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -348,12 +348,6 @@ declare_lint! {\n \n /// Some lints that are buffered from `libsyntax`. See `syntax::early_buffered_lints`.\n pub mod parser {\n-    declare_lint! {\n-        pub QUESTION_MARK_MACRO_SEP,\n-        Allow,\n-        \"detects the use of `?` as a macro separator\"\n-    }\n-\n     declare_lint! {\n         pub ILL_FORMED_ATTRIBUTE_INPUT,\n         Warn,\n@@ -444,7 +438,6 @@ declare_lint_pass! {\n         PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n         MACRO_USE_EXTERN_CRATE,\n         MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n-        parser::QUESTION_MARK_MACRO_SEP,\n         parser::ILL_FORMED_ATTRIBUTE_INPUT,\n         DEPRECATED_IN_FUTURE,\n         AMBIGUOUS_ASSOCIATED_ITEMS,"}, {"sha": "309af4b72c1271e88bc9809b46e0c1984316c2ab", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -27,7 +27,7 @@ use crate::hir::def_id::{CrateNum, LOCAL_CRATE};\n use crate::hir::intravisit;\n use crate::hir;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n-use crate::lint::builtin::parser::{QUESTION_MARK_MACRO_SEP, ILL_FORMED_ATTRIBUTE_INPUT};\n+use crate::lint::builtin::parser::ILL_FORMED_ATTRIBUTE_INPUT;\n use crate::session::{Session, DiagnosticMessageId};\n use crate::ty::TyCtxt;\n use crate::ty::query::Providers;\n@@ -80,7 +80,6 @@ impl Lint {\n     /// Returns the `rust::lint::Lint` for a `syntax::early_buffered_lints::BufferedEarlyLintId`.\n     pub fn from_parser_lint_id(lint_id: BufferedEarlyLintId) -> &'static Self {\n         match lint_id {\n-            BufferedEarlyLintId::QuestionMarkMacroSep => QUESTION_MARK_MACRO_SEP,\n             BufferedEarlyLintId::IllFormedAttributeInput => ILL_FORMED_ATTRIBUTE_INPUT,\n         }\n     }"}, {"sha": "a6e5bd275ae19008442a28c90751be2cb7905afe", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -320,6 +320,7 @@ language_item_table! {\n     FnMutTraitLangItem,          \"fn_mut\",             fn_mut_trait,            Target::Trait;\n     FnOnceTraitLangItem,         \"fn_once\",            fn_once_trait,           Target::Trait;\n \n+    FutureTraitLangItem,         \"future_trait\",       future_trait,            Target::Trait;\n     GeneratorStateLangItem,      \"generator_state\",    gen_state,               Target::Enum;\n     GeneratorTraitLangItem,      \"generator\",          gen_trait,               Target::Trait;\n     UnpinTraitLangItem,          \"unpin\",              unpin_trait,             Target::Trait;"}, {"sha": "618e8b8699fcc9713cd1ad550353ed71160f5341", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -29,7 +29,7 @@ use std::fmt;\n use std::fs;\n use std::io;\n use std::path::{Path, PathBuf};\n-use std::process::{Output, Stdio};\n+use std::process::{Output, Stdio, ExitStatus};\n use std::str;\n use std::env;\n \n@@ -510,21 +510,6 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n     sess.abort_if_errors();\n \n     // Invoke the system linker\n-    //\n-    // Note that there's a terribly awful hack that really shouldn't be present\n-    // in any compiler. Here an environment variable is supported to\n-    // automatically retry the linker invocation if the linker looks like it\n-    // segfaulted.\n-    //\n-    // Gee that seems odd, normally segfaults are things we want to know about!\n-    // Unfortunately though in rust-lang/rust#38878 we're experiencing the\n-    // linker segfaulting on Travis quite a bit which is causing quite a bit of\n-    // pain to land PRs when they spuriously fail due to a segfault.\n-    //\n-    // The issue #38878 has some more debugging information on it as well, but\n-    // this unfortunately looks like it's just a race condition in macOS's linker\n-    // with some thread pool working in the background. It seems that no one\n-    // currently knows a fix for this so in the meantime we're left with this...\n     info!(\"{:?}\", &cmd);\n     let retry_on_segfault = env::var(\"RUSTC_RETRY_LINKER_ON_SEGFAULT\").is_ok();\n     let mut prog;\n@@ -567,21 +552,59 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n             info!(\"{:?}\", &cmd);\n             continue;\n         }\n+\n+        // Here's a terribly awful hack that really shouldn't be present in any\n+        // compiler. Here an environment variable is supported to automatically\n+        // retry the linker invocation if the linker looks like it segfaulted.\n+        //\n+        // Gee that seems odd, normally segfaults are things we want to know\n+        // about!  Unfortunately though in rust-lang/rust#38878 we're\n+        // experiencing the linker segfaulting on Travis quite a bit which is\n+        // causing quite a bit of pain to land PRs when they spuriously fail\n+        // due to a segfault.\n+        //\n+        // The issue #38878 has some more debugging information on it as well,\n+        // but this unfortunately looks like it's just a race condition in\n+        // macOS's linker with some thread pool working in the background. It\n+        // seems that no one currently knows a fix for this so in the meantime\n+        // we're left with this...\n         if !retry_on_segfault || i > 3 {\n             break\n         }\n         let msg_segv = \"clang: error: unable to execute command: Segmentation fault: 11\";\n         let msg_bus  = \"clang: error: unable to execute command: Bus error: 10\";\n-        if !(out.contains(msg_segv) || out.contains(msg_bus)) {\n-            break\n+        if out.contains(msg_segv) || out.contains(msg_bus) {\n+            warn!(\n+                \"looks like the linker segfaulted when we tried to call it, \\\n+                 automatically retrying again. cmd = {:?}, out = {}.\",\n+                cmd,\n+                out,\n+            );\n+            continue;\n         }\n \n-        warn!(\n-            \"looks like the linker segfaulted when we tried to call it, \\\n-             automatically retrying again. cmd = {:?}, out = {}.\",\n-            cmd,\n-            out,\n-        );\n+        if is_illegal_instruction(&output.status) {\n+            warn!(\n+                \"looks like the linker hit an illegal instruction when we \\\n+                 tried to call it, automatically retrying again. cmd = {:?}, ]\\\n+                 out = {}, status = {}.\",\n+                cmd,\n+                out,\n+                output.status,\n+            );\n+            continue;\n+        }\n+\n+        #[cfg(unix)]\n+        fn is_illegal_instruction(status: &ExitStatus) -> bool {\n+            use std::os::unix::prelude::*;\n+            status.signal() == Some(libc::SIGILL)\n+        }\n+\n+        #[cfg(windows)]\n+        fn is_illegal_instruction(_status: &ExitStatus) -> bool {\n+            false\n+        }\n     }\n \n     match prog {"}, {"sha": "7975c62b90fb6fa8c3cd005725a2c2c0938e3f60", "filename": "src/librustc_data_structures/fingerprint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_data_structures%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_data_structures%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffingerprint.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -39,8 +39,8 @@ impl Fingerprint {\n     // you want.\n     #[inline]\n     pub fn combine_commutative(self, other: Fingerprint) -> Fingerprint {\n-        let a = (self.1 as u128) << 64 | self.0 as u128;\n-        let b = (other.1 as u128) << 64 | other.0 as u128;\n+        let a = u128::from(self.1) << 64 | u128::from(self.0);\n+        let b = u128::from(other.1) << 64 | u128::from(other.0);\n \n         let c = a.wrapping_add(b);\n "}, {"sha": "557e5e2186f11f14c38f53242efb009d14ef2f1a", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -263,7 +263,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             done_cache: Default::default(),\n             waiting_cache: Default::default(),\n             scratch: Some(vec![]),\n-            obligation_tree_id_generator: (0..).map(|i| ObligationTreeId(i)),\n+            obligation_tree_id_generator: (0..).map(ObligationTreeId),\n             error_cache: Default::default(),\n         }\n     }"}, {"sha": "e5de359e4759e81839ebad4c66c395170800b72f", "filename": "src/librustc_data_structures/sip128.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_data_structures%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_data_structures%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsip128.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -70,15 +70,15 @@ unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n     let mut i = 0; // current byte index (from LSB) in the output u64\n     let mut out = 0;\n     if i + 3 < len {\n-        out = load_int_le!(buf, start + i, u32) as u64;\n+        out = u64::from(load_int_le!(buf, start + i, u32));\n         i += 4;\n     }\n     if i + 1 < len {\n-        out |= (load_int_le!(buf, start + i, u16) as u64) << (i * 8);\n+        out |= u64::from(load_int_le!(buf, start + i, u16)) << (i * 8);\n         i += 2\n     }\n     if i < len {\n-        out |= (*buf.get_unchecked(start + i) as u64) << (i * 8);\n+        out |= u64::from(*buf.get_unchecked(start + i)) << (i * 8);\n         i += 1;\n     }\n     debug_assert_eq!(i, len);\n@@ -237,7 +237,7 @@ impl Hasher for SipHasher128 {\n \n         if self.ntail != 0 {\n             needed = 8 - self.ntail;\n-            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << 8 * self.ntail;\n+            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << (8 * self.ntail);\n             if length < needed {\n                 self.ntail += length;\n                 return"}, {"sha": "47dfc1d1688d07ab24a1fba2d4e19d002174eae2", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -44,7 +44,7 @@ impl<W: StableHasherResult> StableHasher<W> {\n impl StableHasherResult for u128 {\n     fn finish(hasher: StableHasher<Self>) -> Self {\n         let (_0, _1) = hasher.finalize();\n-        (_0 as u128) | ((_1 as u128) << 64)\n+        u128::from(_0) | (u128::from(_1) << 64)\n     }\n }\n "}, {"sha": "0fb8060031843a156cf2344ec194a07bb6e95c09", "filename": "src/librustc_data_structures/vec_linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_data_structures%2Fvec_linked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_data_structures%2Fvec_linked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fvec_linked_list.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -8,7 +8,7 @@ where\n     Ls: Links,\n {\n     VecLinkedListIterator {\n-        links: links,\n+        links,\n         current: first,\n     }\n }"}, {"sha": "3641d355ef19c9aa08a7758e0771f43267db4e3c", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -94,7 +94,7 @@ impl<'a>  DiagnosticConverter<'a> {\n                     annotation_type: Self::annotation_type_for_level(self.level),\n                 }),\n                 footer: vec![],\n-                slices: slices,\n+                slices,\n             })\n         } else {\n             // FIXME(#59346): Is it ok to return None if there's no source_map?"}, {"sha": "424d7c00383899897bafda051fedc4c61470dae1", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -388,7 +388,7 @@ impl Diagnostic {\n             }],\n             msg: msg.to_owned(),\n             style: SuggestionStyle::CompletelyHidden,\n-            applicability: applicability,\n+            applicability,\n         });\n         self\n     }"}, {"sha": "a2717ab7ad8a9000f06217a691ef533258fda152", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -1339,7 +1339,7 @@ impl EmitterWriter {\n         }\n \n         let mut dst = self.dst.writable();\n-        match write!(dst, \"\\n\") {\n+        match writeln!(dst) {\n             Err(e) => panic!(\"failed to emit error: {}\", e),\n             _ => {\n                 match dst.flush() {\n@@ -1598,7 +1598,7 @@ fn emit_to_destination(rendered_buffer: &[Vec<StyledString>],\n             dst.reset()?;\n         }\n         if !short_message && (!lvl.is_failure_note() || pos != rendered_buffer.len() - 1) {\n-            write!(dst, \"\\n\")?;\n+            writeln!(dst)?;\n         }\n     }\n     dst.flush()?;"}, {"sha": "d808a15982e37fc34a260e3c6888609f3ce34b9d", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -42,7 +42,6 @@ use rustc::lint::builtin::{\n     INTRA_DOC_LINK_RESOLUTION_FAILURE,\n     MISSING_DOC_CODE_EXAMPLES,\n     PRIVATE_DOC_TESTS,\n-    parser::QUESTION_MARK_MACRO_SEP,\n     parser::ILL_FORMED_ATTRIBUTE_INPUT,\n };\n use rustc::session;\n@@ -404,11 +403,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             reference: \"issue #50504 <https://github.com/rust-lang/rust/issues/50504>\",\n             edition: None,\n         },\n-        FutureIncompatibleInfo {\n-            id: LintId::of(QUESTION_MARK_MACRO_SEP),\n-            reference: \"issue #48075 <https://github.com/rust-lang/rust/issues/48075>\",\n-            edition: Some(Edition::Edition2018),\n-        },\n         FutureIncompatibleInfo {\n             id: LintId::of(MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS),\n             reference: \"issue #52234 <https://github.com/rust-lang/rust/issues/52234>\","}, {"sha": "ab82f75f74f4b26e3083c23de3c5c2de62e43b7f", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -29,6 +29,7 @@ use std::cell::Cell;\n use std::default::Default;\n use std::env;\n use std::fs::File;\n+use std::io::BufWriter;\n use std::path::{Path, PathBuf};\n \n use syntax::ast::{self, Attribute, DUMMY_NODE_ID, NodeId, PatKind};\n@@ -1025,7 +1026,7 @@ impl<'a> DumpHandler<'a> {\n         }\n     }\n \n-    fn output_file(&self, ctx: &SaveContext<'_, '_>) -> (File, PathBuf) {\n+    fn output_file(&self, ctx: &SaveContext<'_, '_>) -> (BufWriter<File>, PathBuf) {\n         let sess = &ctx.tcx.sess;\n         let file_name = match ctx.config.output_file {\n             Some(ref s) => PathBuf::from(s),\n@@ -1059,9 +1060,9 @@ impl<'a> DumpHandler<'a> {\n \n         info!(\"Writing output to {}\", file_name.display());\n \n-        let output_file = File::create(&file_name).unwrap_or_else(\n+        let output_file = BufWriter::new(File::create(&file_name).unwrap_or_else(\n             |e| sess.fatal(&format!(\"Could not open {}: {}\", file_name.display(), e)),\n-        );\n+        ));\n \n         (output_file, file_name)\n     }"}, {"sha": "48749dff941ac00cfe15e759160af5d2639cae8b", "filename": "src/librustc_target/spec/fuchsia_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_target%2Fspec%2Ffuchsia_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_target%2Fspec%2Ffuchsia_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Ffuchsia_base.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -19,7 +19,7 @@ pub fn opts() -> TargetOptions {\n         is_like_fuchsia: true,\n         linker_is_gnu: true,\n         has_rpath: false,\n-        pre_link_args: pre_link_args,\n+        pre_link_args,\n         pre_link_objects_exe: vec![\n             \"Scrt1.o\".to_string()\n         ],"}, {"sha": "14c38ae053d23d4cb5001411b8aa7c6db2a617d7", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -127,6 +127,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.suggest_compatible_variants(&mut err, expr, expected, expr_ty);\n         self.suggest_ref_or_into(&mut err, expr, expected, expr_ty);\n+        self.suggest_missing_await(&mut err, expr, expected, expr_ty);\n \n         (expected, Some(err))\n     }"}, {"sha": "21fa219a1cab27ee1e63baeb361eb68406834bfb", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -295,8 +295,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Index(ref base, ref idx) => {\n                 self.check_expr_index(base, idx, needs, expr)\n             }\n-            ExprKind::Yield(ref value, _) => {\n-                self.check_expr_yield(value, expr)\n+            ExprKind::Yield(ref value, ref src) => {\n+                self.check_expr_yield(value, expr, src)\n             }\n             hir::ExprKind::Err => {\n                 tcx.types.err\n@@ -1541,12 +1541,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_yield(&self, value: &'tcx hir::Expr, expr: &'tcx hir::Expr) -> Ty<'tcx> {\n+    fn check_expr_yield(\n+        &self,\n+        value: &'tcx hir::Expr,\n+        expr: &'tcx hir::Expr,\n+        src: &'tcx hir::YieldSource\n+    ) -> Ty<'tcx> {\n         match self.yield_ty {\n             Some(ty) => {\n                 self.check_expr_coercable_to_type(&value, ty);\n             }\n-            None => {\n+            // Given that this `yield` expression was generated as a result of lowering a `.await`,\n+            // we know that the yield type must be `()`; however, the context won't contain this\n+            // information. Hence, we check the source of the yield expression here and check its\n+            // value's type against `()` (this check should always hold).\n+            None if src == &hir::YieldSource::Await => {\n+                self.check_expr_coercable_to_type(&value, self.tcx.mk_unit());\n+            }\n+            _ => {\n                 struct_span_err!(self.tcx.sess, expr.span, E0627,\n                                     \"yield statement outside of generator literal\").emit();\n             }"}, {"sha": "37866bab9009d9f5175a6499508804503048c24a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -3932,6 +3932,72 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// A possible error is to forget to add `.await` when using futures:\n+    ///\n+    /// ```\n+    /// #![feature(async_await)]\n+    ///\n+    /// async fn make_u32() -> u32 {\n+    ///     22\n+    /// }\n+    ///\n+    /// fn take_u32(x: u32) {}\n+    ///\n+    /// async fn foo() {\n+    ///     let x = make_u32();\n+    ///     take_u32(x);\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n+    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n+    /// `.await` to the tail of the expression.\n+    fn suggest_missing_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        expr: &hir::Expr,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) {\n+        // `.await` is not permitted outside of `async` bodies, so don't bother to suggest if the\n+        // body isn't `async`.\n+        let item_id = self.tcx().hir().get_parent_node(self.body_id);\n+        if let Some(body_id) = self.tcx().hir().maybe_body_owned_by(item_id) {\n+            let body = self.tcx().hir().body(body_id);\n+            if let Some(hir::GeneratorKind::Async) = body.generator_kind {\n+                let sp = expr.span;\n+                // Check for `Future` implementations by constructing a predicate to\n+                // prove: `<T as Future>::Output == U`\n+                let future_trait = self.tcx.lang_items().future_trait().unwrap();\n+                let item_def_id = self.tcx.associated_items(future_trait).next().unwrap().def_id;\n+                let predicate = ty::Predicate::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n+                    // `<T as Future>::Output`\n+                    projection_ty: ty::ProjectionTy {\n+                        // `T`\n+                        substs: self.tcx.mk_substs_trait(\n+                            found,\n+                            self.fresh_substs_for_item(sp, item_def_id)\n+                        ),\n+                        // `Future::Output`\n+                        item_def_id,\n+                    },\n+                    ty: expected,\n+                }));\n+                let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n+                if self.infcx.predicate_may_hold(&obligation) {\n+                    if let Ok(code) = self.sess().source_map().span_to_snippet(sp) {\n+                        err.span_suggestion(\n+                            sp,\n+                            \"consider using `.await` here\",\n+                            format!(\"{}.await\", code),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /// A common error is to add an extra semicolon:\n     ///\n     /// ```"}, {"sha": "a7e7c09f9ae4411e9546f493278db7bebdfc3d61", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -461,7 +461,7 @@ impl<'a> Encoder<'a> {\n     /// Creates a new JSON encoder whose output will be written to the writer\n     /// specified.\n     pub fn new(writer: &'a mut dyn fmt::Write) -> Encoder<'a> {\n-        Encoder { writer: writer, is_emitting_map_key: false, }\n+        Encoder { writer, is_emitting_map_key: false, }\n     }\n }\n \n@@ -513,7 +513,7 @@ impl<'a> crate::Encoder for Encoder<'a> {\n         emit_enquoted_if_mapkey!(self, fmt_number_or_null(v))\n     }\n     fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-        self.emit_f64(v as f64)\n+        self.emit_f64(f64::from(v))\n     }\n \n     fn emit_char(&mut self, v: char) -> EncodeResult {\n@@ -763,7 +763,7 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n         emit_enquoted_if_mapkey!(self, fmt_number_or_null(v))\n     }\n     fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-        self.emit_f64(v as f64)\n+        self.emit_f64(f64::from(v))\n     }\n \n     fn emit_char(&mut self, v: char) -> EncodeResult {\n@@ -1698,12 +1698,12 @@ impl<T: Iterator<Item=char>> Parser<T> {\n                             if n2 < 0xDC00 || n2 > 0xDFFF {\n                                 return self.error(LoneLeadingSurrogateInHexEscape)\n                             }\n-                            let c = (((n1 - 0xD800) as u32) << 10 |\n-                                     (n2 - 0xDC00) as u32) + 0x1_0000;\n+                            let c = (u32::from(n1 - 0xD800) << 10 |\n+                                     u32::from(n2 - 0xDC00)) + 0x1_0000;\n                             res.push(char::from_u32(c).unwrap());\n                         }\n \n-                        n => match char::from_u32(n as u32) {\n+                        n => match char::from_u32(u32::from(n)) {\n                             Some(c) => res.push(c),\n                             None => return self.error(InvalidUnicodeCodePoint),\n                         },\n@@ -2405,7 +2405,7 @@ impl ToJson for Json {\n }\n \n impl ToJson for f32 {\n-    fn to_json(&self) -> Json { (*self as f64).to_json() }\n+    fn to_json(&self) -> Json { f64::from(*self).to_json() }\n }\n \n impl ToJson for f64 {"}, {"sha": "f9d80842d7558ec5f15aea7fc4c9ca17c955dbf1", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -123,7 +123,7 @@ pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i128, usize) {\n     loop {\n         byte = data[position];\n         position += 1;\n-        result |= ((byte & 0x7F) as i128) << shift;\n+        result |= i128::from(byte & 0x7F) << shift;\n         shift += 7;\n \n         if (byte & 0x80) == 0 {"}, {"sha": "75988198eb9b5f98174a98913347f58d09f9fae2", "filename": "src/libserialize/opaque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -296,13 +296,13 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     #[inline]\n     fn read_f64(&mut self) -> Result<f64, Self::Error> {\n         let bits = self.read_u64()?;\n-        Ok(unsafe { ::std::mem::transmute(bits) })\n+        Ok(f64::from_bits(bits))\n     }\n \n     #[inline]\n     fn read_f32(&mut self) -> Result<f32, Self::Error> {\n         let bits = self.read_u32()?;\n-        Ok(unsafe { ::std::mem::transmute(bits) })\n+        Ok(f32::from_bits(bits))\n     }\n \n     #[inline]"}, {"sha": "3d0568c16cdf67ebe2de4b196bf12ebbdb6e1075", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -506,9 +506,18 @@ pub trait Read {\n     ///\n     /// No guarantees are provided about the contents of `buf` when this\n     /// function is called, implementations cannot rely on any property of the\n-    /// contents of `buf` being true. It is recommended that implementations\n+    /// contents of `buf` being true. It is recommended that *implementations*\n     /// only write data to `buf` instead of reading its contents.\n     ///\n+    /// Correspondingly, however, *callers* of this method may not assume any guarantees\n+    /// about how the implementation uses `buf`. The trait is safe to implement,\n+    //  so it is possible that the code that's supposed to write to the buffer might also read\n+    //  from it. It is your responsibility to make sure that `buf` is initialized\n+    /// before calling `read`. Calling `read` with an uninitialized `buf` (of the kind one\n+    /// obtains via [`MaybeUninit<T>`]) is not safe, and can lead to undefined behavior.\n+    ///\n+    /// [`MaybeUninit<T>`]: ../mem/union.MaybeUninit.html\n+    ///\n     /// # Errors\n     ///\n     /// If this function encounters any form of I/O or other error, an error"}, {"sha": "60e06139eba99c205bfc83501f4c0f72641cd5a5", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -262,7 +262,6 @@\n #![feature(exhaustive_patterns)]\n #![feature(external_doc)]\n #![feature(fn_traits)]\n-#![feature(fnbox)]\n #![feature(generator_trait)]\n #![feature(hash_raw_entry)]\n #![feature(hashmap_internals)]"}, {"sha": "c627596bbdf20ea7720e5175660b07787c8f5a09", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -1832,7 +1832,7 @@ impl Arg {\n                         lt,\n                         MutTy {\n                             ty: infer_ty,\n-                            mutbl: mutbl,\n+                            mutbl,\n                         },\n                     ),\n                     span,\n@@ -2120,7 +2120,7 @@ impl PolyTraitRef {\n         PolyTraitRef {\n             bound_generic_params: generic_params,\n             trait_ref: TraitRef {\n-                path: path,\n+                path,\n                 ref_id: DUMMY_NODE_ID,\n             },\n             span,"}, {"sha": "b26a1165fed1db27ffc68657322ae91c86182d48", "filename": "src/libsyntax/early_buffered_lints.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fearly_buffered_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fearly_buffered_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fearly_buffered_lints.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -9,8 +9,6 @@ use syntax_pos::MultiSpan;\n /// Since we cannot import `LintId`s from `rustc::lint`, we define some Ids here which can later be\n /// passed to `rustc::lint::Lint::from_parser_lint_id` to get a `rustc::lint::Lint`.\n pub enum BufferedEarlyLintId {\n-    /// Usage of `?` as a macro separator is deprecated.\n-    QuestionMarkMacroSep,\n     IllFormedAttributeInput,\n }\n "}, {"sha": "baf1031de1e7c40ddbe0f5f84be5bfa792f25ed6", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -815,7 +815,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n \n     fn pat(&self, span: Span, pat: PatKind) -> P<ast::Pat> {\n-        P(ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span: span })\n+        P(ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span })\n     }\n     fn pat_wild(&self, span: Span) -> P<ast::Pat> {\n         self.pat(span, PatKind::Wild)"}, {"sha": "5473f55aa33704053b03cdf982f7f108fc162a9a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -231,7 +231,7 @@ pub struct MacroExpander<'a, 'b> {\n \n impl<'a, 'b> MacroExpander<'a, 'b> {\n     pub fn new(cx: &'a mut ExtCtxt<'b>, monotonic: bool) -> Self {\n-        MacroExpander { cx: cx, monotonic: monotonic }\n+        MacroExpander { cx, monotonic }\n     }\n \n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n@@ -377,7 +377,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                             _ => item.clone(),\n                         };\n                         invocations.push(Invocation {\n-                            kind: InvocationKind::Derive { path: path.clone(), item: item },\n+                            kind: InvocationKind::Derive { path: path.clone(), item },\n                             fragment_kind: invoc.fragment_kind,\n                             expansion_data: ExpansionData {\n                                 mark,\n@@ -944,7 +944,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n \n     fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: AstFragmentKind) -> AstFragment {\n-        self.collect(kind, InvocationKind::Bang { mac: mac, ident: None, span: span })\n+        self.collect(kind, InvocationKind::Bang { mac, ident: None, span })\n     }\n \n     fn collect_attr(&mut self,"}, {"sha": "ccf9db842ab6e467acbe3446d0938916dfeaa341", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -319,7 +319,7 @@ fn parse_tree(\n         tokenstream::TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n             span,\n             Lrc::new(Delimited {\n-                delim: delim,\n+                delim,\n                 tts: parse(\n                     tts.into(),\n                     expect_matchers,"}, {"sha": "ea7f8e356aa63214fbecbf501ec553829d47ec05", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -23,8 +23,8 @@ enum Frame {\n impl Frame {\n     /// Construct a new frame around the delimited set of tokens.\n     fn new(tts: Vec<quoted::TokenTree>) -> Frame {\n-        let forest = Lrc::new(quoted::Delimited { delim: token::NoDelim, tts: tts });\n-        Frame::Delimited { forest: forest, idx: 0, span: DelimSpan::dummy() }\n+        let forest = Lrc::new(quoted::Delimited { delim: token::NoDelim, tts });\n+        Frame::Delimited { forest, idx: 0, span: DelimSpan::dummy() }\n     }\n }\n \n@@ -248,7 +248,7 @@ pub fn transcribe(\n             // the previous results (from outside the Delimited).\n             quoted::TokenTree::Delimited(mut span, delimited) => {\n                 span = span.apply_mark(cx.current_expansion.mark);\n-                stack.push(Frame::Delimited { forest: delimited, idx: 0, span: span });\n+                stack.push(Frame::Delimited { forest: delimited, idx: 0, span });\n                 result_stack.push(mem::replace(&mut result, Vec::new()));\n             }\n "}, {"sha": "a6e8441a915e0c1464ce6b3acd4952286ff498e8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -1665,7 +1665,7 @@ impl<'a> Context<'a> {\n }\n \n pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features: &Features) {\n-    let cx = Context { features: features, parse_sess: parse_sess, plugin_attributes: &[] };\n+    let cx = Context { features, parse_sess, plugin_attributes: &[] };\n     cx.check_attribute(\n         attr,\n         attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name).map(|a| *a)),"}, {"sha": "0ea0b2a694d7d0df87029de7914cf2da69c6a972", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -942,7 +942,7 @@ impl<'a> Parser<'a> {\n                 //  {foo(bar {}}\n                 //      -      ^\n                 //      |      |\n-                //      |      help: `)` may belong here (FIXME: #58270)\n+                //      |      help: `)` may belong here\n                 //      |\n                 //      unclosed delimiter\n                 if let Some(sp) = unmatched.unclosed_span {"}, {"sha": "4e4fe4256c9b0a521834cbc283fcc956736e658b", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 121, "deletions": 139, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -1,4 +1,3 @@\n-use crate::ast;\n use crate::parse::ParseSess;\n use crate::parse::token::{self, Token, TokenKind};\n use crate::symbol::{sym, Symbol};\n@@ -321,33 +320,29 @@ impl<'a> StringReader<'a> {\n         (pos - self.source_file.start_pos).to_usize()\n     }\n \n-    /// Calls `f` with a string slice of the source text spanning from `start`\n-    /// up to but excluding `self.pos`, meaning the slice does not include\n-    /// the character `self.ch`.\n-    fn with_str_from<T, F>(&self, start: BytePos, f: F) -> T\n-        where F: FnOnce(&str) -> T\n+    /// Slice of the source text from `start` up to but excluding `self.pos`,\n+    /// meaning the slice does not include the character `self.ch`.\n+    fn str_from(&self, start: BytePos) -> &str\n     {\n-        self.with_str_from_to(start, self.pos, f)\n+        self.str_from_to(start, self.pos)\n     }\n \n-    /// Creates a Name from a given offset to the current offset.\n-    fn name_from(&self, start: BytePos) -> ast::Name {\n+    /// Creates a Symbol from a given offset to the current offset.\n+    fn symbol_from(&self, start: BytePos) -> Symbol {\n         debug!(\"taking an ident from {:?} to {:?}\", start, self.pos);\n-        self.with_str_from(start, Symbol::intern)\n+        Symbol::intern(self.str_from(start))\n     }\n \n-    /// As name_from, with an explicit endpoint.\n-    fn name_from_to(&self, start: BytePos, end: BytePos) -> ast::Name {\n+    /// As symbol_from, with an explicit endpoint.\n+    fn symbol_from_to(&self, start: BytePos, end: BytePos) -> Symbol {\n         debug!(\"taking an ident from {:?} to {:?}\", start, end);\n-        self.with_str_from_to(start, end, Symbol::intern)\n+        Symbol::intern(self.str_from_to(start, end))\n     }\n \n-    /// Calls `f` with a string slice of the source text spanning from `start`\n-    /// up to but excluding `end`.\n-    fn with_str_from_to<T, F>(&self, start: BytePos, end: BytePos, f: F) -> T\n-        where F: FnOnce(&str) -> T\n+    /// Slice of the source text spanning from `start` up to but excluding `end`.\n+    fn str_from_to(&self, start: BytePos, end: BytePos) -> &str\n     {\n-        f(&self.src[self.src_index(start)..self.src_index(end)])\n+        &self.src[self.src_index(start)..self.src_index(end)]\n     }\n \n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n@@ -444,7 +439,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Eats <XID_start><XID_continue>*, if possible.\n-    fn scan_optional_raw_name(&mut self) -> Option<ast::Name> {\n+    fn scan_optional_raw_name(&mut self) -> Option<Symbol> {\n         if !ident_start(self.ch) {\n             return None;\n         }\n@@ -456,8 +451,8 @@ impl<'a> StringReader<'a> {\n             self.bump();\n         }\n \n-        self.with_str_from(start, |string| {\n-            if string == \"_\" {\n+        match self.str_from(start) {\n+            \"_\" => {\n                 self.sess.span_diagnostic\n                     .struct_span_warn(self.mk_sp(start, self.pos),\n                                       \"underscore literal suffix is not allowed\")\n@@ -468,10 +463,9 @@ impl<'a> StringReader<'a> {\n                           <https://github.com/rust-lang/rust/issues/42326>\")\n                     .emit();\n                 None\n-            } else {\n-                Some(Symbol::intern(string))\n             }\n-        })\n+            name => Some(Symbol::intern(name))\n+        }\n     }\n \n     /// PRECONDITION: self.ch is not whitespace\n@@ -513,9 +507,7 @@ impl<'a> StringReader<'a> {\n                     }\n \n                     let kind = if doc_comment {\n-                        self.with_str_from(start_bpos, |string| {\n-                            token::DocComment(Symbol::intern(string))\n-                        })\n+                        token::DocComment(self.symbol_from(start_bpos))\n                     } else {\n                         token::Comment\n                     };\n@@ -544,7 +536,7 @@ impl<'a> StringReader<'a> {\n                         self.bump();\n                     }\n                     return Some(Token::new(\n-                        token::Shebang(self.name_from(start)),\n+                        token::Shebang(self.symbol_from(start)),\n                         self.mk_sp(start, self.pos),\n                     ));\n                 }\n@@ -615,23 +607,22 @@ impl<'a> StringReader<'a> {\n             self.bump();\n         }\n \n-        self.with_str_from(start_bpos, |string| {\n-            // but comments with only \"*\"s between two \"/\"s are not\n-            let kind = if is_block_doc_comment(string) {\n-                let string = if has_cr {\n-                    self.translate_crlf(start_bpos,\n-                                        string,\n-                                        \"bare CR not allowed in block doc-comment\")\n-                } else {\n-                    string.into()\n-                };\n-                token::DocComment(Symbol::intern(&string[..]))\n+        let string = self.str_from(start_bpos);\n+        // but comments with only \"*\"s between two \"/\"s are not\n+        let kind = if is_block_doc_comment(string) {\n+            let string = if has_cr {\n+                self.translate_crlf(start_bpos,\n+                                    string,\n+                                    \"bare CR not allowed in block doc-comment\")\n             } else {\n-                token::Comment\n+                string.into()\n             };\n+            token::DocComment(Symbol::intern(&string[..]))\n+        } else {\n+            token::Comment\n+        };\n \n-            Some(Token::new(kind, self.mk_sp(start_bpos, self.pos)))\n-        })\n+        Some(Token::new(kind, self.mk_sp(start_bpos, self.pos)))\n     }\n \n     /// Scan through any digits (base `scan_radix`) or underscores,\n@@ -727,17 +718,17 @@ impl<'a> StringReader<'a> {\n             let pos = self.pos;\n             self.check_float_base(start_bpos, pos, base);\n \n-            (token::Float, self.name_from(start_bpos))\n+            (token::Float, self.symbol_from(start_bpos))\n         } else {\n             // it might be a float if it has an exponent\n             if self.ch_is('e') || self.ch_is('E') {\n                 self.scan_float_exponent();\n                 let pos = self.pos;\n                 self.check_float_base(start_bpos, pos, base);\n-                return (token::Float, self.name_from(start_bpos));\n+                return (token::Float, self.symbol_from(start_bpos));\n             }\n             // but we certainly have an integer!\n-            (token::Integer, self.name_from(start_bpos))\n+            (token::Integer, self.symbol_from(start_bpos))\n         }\n     }\n \n@@ -838,20 +829,17 @@ impl<'a> StringReader<'a> {\n                     self.bump();\n                 }\n \n-                return Ok(self.with_str_from(start, |string| {\n-                    // FIXME: perform NFKC normalization here. (Issue #2253)\n-                    let name = ast::Name::intern(string);\n-\n-                    if is_raw_ident {\n-                        let span = self.mk_sp(raw_start, self.pos);\n-                        if !name.can_be_raw() {\n-                            self.err_span(span, &format!(\"`{}` cannot be a raw identifier\", name));\n-                        }\n-                        self.sess.raw_identifier_spans.borrow_mut().push(span);\n+                // FIXME: perform NFKC normalization here. (Issue #2253)\n+                let name = self.symbol_from(start);\n+                if is_raw_ident {\n+                    let span = self.mk_sp(raw_start, self.pos);\n+                    if !name.can_be_raw() {\n+                        self.err_span(span, &format!(\"`{}` cannot be a raw identifier\", name));\n                     }\n+                    self.sess.raw_identifier_spans.borrow_mut().push(span);\n+                }\n \n-                    token::Ident(name, is_raw_ident)\n-                }));\n+                return Ok(token::Ident(name, is_raw_ident));\n             }\n         }\n \n@@ -1017,7 +1005,7 @@ impl<'a> StringReader<'a> {\n                     // lifetimes shouldn't end with a single quote\n                     // if we find one, then this is an invalid character literal\n                     if self.ch_is('\\'') {\n-                        let symbol = self.name_from(start);\n+                        let symbol = self.symbol_from(start);\n                         self.bump();\n                         self.validate_char_escape(start_with_quote);\n                         return Ok(TokenKind::lit(token::Char, symbol, None));\n@@ -1035,7 +1023,7 @@ impl<'a> StringReader<'a> {\n                     // Include the leading `'` in the real identifier, for macro\n                     // expansion purposes. See #12512 for the gory details of why\n                     // this is necessary.\n-                    return Ok(token::Lifetime(self.name_from(start_with_quote)));\n+                    return Ok(token::Lifetime(self.symbol_from(start_with_quote)));\n                 }\n                 let msg = \"unterminated character literal\";\n                 let symbol = self.scan_single_quoted_string(start_with_quote, msg);\n@@ -1063,7 +1051,7 @@ impl<'a> StringReader<'a> {\n                     },\n                     Some('r') => {\n                         let (start, end, hash_count) = self.scan_raw_string();\n-                        let symbol = self.name_from_to(start, end);\n+                        let symbol = self.symbol_from_to(start, end);\n                         self.validate_raw_byte_str_escape(start, end);\n \n                         (token::ByteStrRaw(hash_count), symbol)\n@@ -1084,7 +1072,7 @@ impl<'a> StringReader<'a> {\n             }\n             'r' => {\n                 let (start, end, hash_count) = self.scan_raw_string();\n-                let symbol = self.name_from_to(start, end);\n+                let symbol = self.symbol_from_to(start, end);\n                 self.validate_raw_str_escape(start, end);\n                 let suffix = self.scan_optional_raw_name();\n \n@@ -1185,7 +1173,7 @@ impl<'a> StringReader<'a> {\n \n     fn scan_single_quoted_string(&mut self,\n                                  start_with_quote: BytePos,\n-                                 unterminated_msg: &str) -> ast::Name {\n+                                 unterminated_msg: &str) -> Symbol {\n         // assumes that first `'` is consumed\n         let start = self.pos;\n         // lex `'''` as a single char, for recovery\n@@ -1217,12 +1205,12 @@ impl<'a> StringReader<'a> {\n             }\n         }\n \n-        let id = self.name_from(start);\n+        let id = self.symbol_from(start);\n         self.bump();\n         id\n     }\n \n-    fn scan_double_quoted_string(&mut self, unterminated_msg: &str) -> ast::Name {\n+    fn scan_double_quoted_string(&mut self, unterminated_msg: &str) -> Symbol {\n         debug_assert!(self.ch_is('\\\"'));\n         let start_with_quote = self.pos;\n         self.bump();\n@@ -1237,7 +1225,7 @@ impl<'a> StringReader<'a> {\n             }\n             self.bump();\n         }\n-        let id = self.name_from(start);\n+        let id = self.symbol_from(start);\n         self.bump();\n         id\n     }\n@@ -1300,101 +1288,95 @@ impl<'a> StringReader<'a> {\n     }\n \n     fn validate_char_escape(&self, start_with_quote: BytePos) {\n-        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n-            if let Err((off, err)) = unescape::unescape_char(lit) {\n+        let lit = self.str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1));\n+        if let Err((off, err)) = unescape::unescape_char(lit) {\n+            emit_unescape_error(\n+                &self.sess.span_diagnostic,\n+                lit,\n+                self.mk_sp(start_with_quote, self.pos),\n+                unescape::Mode::Char,\n+                0..off,\n+                err,\n+            )\n+        }\n+    }\n+\n+    fn validate_byte_escape(&self, start_with_quote: BytePos) {\n+        let lit = self.str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1));\n+        if let Err((off, err)) = unescape::unescape_byte(lit) {\n+            emit_unescape_error(\n+                &self.sess.span_diagnostic,\n+                lit,\n+                self.mk_sp(start_with_quote, self.pos),\n+                unescape::Mode::Byte,\n+                0..off,\n+                err,\n+            )\n+        }\n+    }\n+\n+    fn validate_str_escape(&self, start_with_quote: BytePos) {\n+        let lit = self.str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1));\n+        unescape::unescape_str(lit, &mut |range, c| {\n+            if let Err(err) = c {\n                 emit_unescape_error(\n                     &self.sess.span_diagnostic,\n                     lit,\n                     self.mk_sp(start_with_quote, self.pos),\n-                    unescape::Mode::Char,\n-                    0..off,\n+                    unescape::Mode::Str,\n+                    range,\n                     err,\n                 )\n             }\n-        });\n+        })\n     }\n \n-    fn validate_byte_escape(&self, start_with_quote: BytePos) {\n-        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n-            if let Err((off, err)) = unescape::unescape_byte(lit) {\n+    fn validate_raw_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n+        let lit = self.str_from_to(content_start, content_end);\n+        unescape::unescape_raw_str(lit, &mut |range, c| {\n+            if let Err(err) = c {\n                 emit_unescape_error(\n                     &self.sess.span_diagnostic,\n                     lit,\n-                    self.mk_sp(start_with_quote, self.pos),\n-                    unescape::Mode::Byte,\n-                    0..off,\n+                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n+                    unescape::Mode::Str,\n+                    range,\n                     err,\n                 )\n             }\n-        });\n-    }\n-\n-    fn validate_str_escape(&self, start_with_quote: BytePos) {\n-        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n-            unescape::unescape_str(lit, &mut |range, c| {\n-                if let Err(err) = c {\n-                    emit_unescape_error(\n-                        &self.sess.span_diagnostic,\n-                        lit,\n-                        self.mk_sp(start_with_quote, self.pos),\n-                        unescape::Mode::Str,\n-                        range,\n-                        err,\n-                    )\n-                }\n-            })\n-        });\n-    }\n-\n-    fn validate_raw_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        self.with_str_from_to(content_start, content_end, |lit: &str| {\n-            unescape::unescape_raw_str(lit, &mut |range, c| {\n-                if let Err(err) = c {\n-                    emit_unescape_error(\n-                        &self.sess.span_diagnostic,\n-                        lit,\n-                        self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                        unescape::Mode::Str,\n-                        range,\n-                        err,\n-                    )\n-                }\n-            })\n-        });\n+        })\n     }\n \n     fn validate_raw_byte_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n-        self.with_str_from_to(content_start, content_end, |lit: &str| {\n-            unescape::unescape_raw_byte_str(lit, &mut |range, c| {\n-                if let Err(err) = c {\n-                    emit_unescape_error(\n-                        &self.sess.span_diagnostic,\n-                        lit,\n-                        self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n-                        unescape::Mode::ByteStr,\n-                        range,\n-                        err,\n-                    )\n-                }\n-            })\n-        });\n+        let lit = self.str_from_to(content_start, content_end);\n+        unescape::unescape_raw_byte_str(lit, &mut |range, c| {\n+            if let Err(err) = c {\n+                emit_unescape_error(\n+                    &self.sess.span_diagnostic,\n+                    lit,\n+                    self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n+                    unescape::Mode::ByteStr,\n+                    range,\n+                    err,\n+                )\n+            }\n+        })\n     }\n \n     fn validate_byte_str_escape(&self, start_with_quote: BytePos) {\n-        self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n-            unescape::unescape_byte_str(lit, &mut |range, c| {\n-                if let Err(err) = c {\n-                    emit_unescape_error(\n-                        &self.sess.span_diagnostic,\n-                        lit,\n-                        self.mk_sp(start_with_quote, self.pos),\n-                        unescape::Mode::ByteStr,\n-                        range,\n-                        err,\n-                    )\n-                }\n-            })\n-        });\n+        let lit = self.str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1));\n+        unescape::unescape_byte_str(lit, &mut |range, c| {\n+            if let Err(err) = c {\n+                emit_unescape_error(\n+                    &self.sess.span_diagnostic,\n+                    lit,\n+                    self.mk_sp(start_with_quote, self.pos),\n+                    unescape::Mode::ByteStr,\n+                    range,\n+                    err,\n+                )\n+            }\n+        })\n     }\n }\n "}, {"sha": "fc206580e3811a79c107d1598c0ef2a775e949eb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -290,10 +290,10 @@ crate enum LastToken {\n }\n \n impl TokenCursorFrame {\n-    fn new(sp: DelimSpan, delim: DelimToken, tts: &TokenStream) -> Self {\n+    fn new(span: DelimSpan, delim: DelimToken, tts: &TokenStream) -> Self {\n         TokenCursorFrame {\n-            delim: delim,\n-            span: sp,\n+            delim,\n+            span,\n             open_delim: delim == token::NoDelim,\n             tree_cursor: tts.clone().into_trees(),\n             close_delim: delim == token::NoDelim,\n@@ -1449,7 +1449,7 @@ impl<'a> Parser<'a> {\n         let opt_lifetime = if self.check_lifetime() { Some(self.expect_lifetime()) } else { None };\n         let mutbl = self.parse_mutability();\n         let ty = self.parse_ty_no_plus()?;\n-        return Ok(TyKind::Rptr(opt_lifetime, MutTy { ty: ty, mutbl: mutbl }));\n+        return Ok(TyKind::Rptr(opt_lifetime, MutTy { ty, mutbl }));\n     }\n \n     fn parse_ptr(&mut self) -> PResult<'a, MutTy> {\n@@ -1467,7 +1467,7 @@ impl<'a> Parser<'a> {\n             Mutability::Immutable\n         };\n         let t = self.parse_ty_no_plus()?;\n-        Ok(MutTy { ty: t, mutbl: mutbl })\n+        Ok(MutTy { ty: t, mutbl })\n     }\n \n     fn is_named_argument(&self) -> bool {\n@@ -4366,7 +4366,7 @@ impl<'a> Parser<'a> {\n                     self.report_invalid_macro_expansion_item();\n                 }\n \n-                (ident, ast::MacroDef { tokens: tokens, legacy: true })\n+                (ident, ast::MacroDef { tokens, legacy: true })\n             }\n             _ => return Ok(None),\n         };\n@@ -6789,12 +6789,12 @@ impl<'a> Parser<'a> {\n         let hi = self.token.span;\n         self.expect(&token::Semi)?;\n         Ok(ast::ForeignItem {\n-            ident: ident,\n-            attrs: attrs,\n+            ident,\n+            attrs,\n             node: ForeignItemKind::Ty,\n             id: ast::DUMMY_NODE_ID,\n             span: lo.to(hi),\n-            vis: vis\n+            vis\n         })\n     }\n "}, {"sha": "f5412f3e216026aa4502b3f1435413acc9447373", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -497,7 +497,7 @@ impl<'a> Printer<'a> {\n \n     pub fn print_newline(&mut self, amount: isize) -> io::Result<()> {\n         debug!(\"NEWLINE {}\", amount);\n-        let ret = write!(self.out, \"\\n\");\n+        let ret = writeln!(self.out);\n         self.pending_indentation = 0;\n         self.indent(amount);\n         ret"}, {"sha": "ac30cbb471aeab3bf53e948dd37960d4b3a1c241", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -150,7 +150,7 @@ impl SourceMap {\n                             -> SourceMap {\n         SourceMap {\n             files: Default::default(),\n-            file_loader: file_loader,\n+            file_loader,\n             path_mapping,\n         }\n     }\n@@ -396,7 +396,7 @@ impl SourceMap {\n         let f = (*self.files.borrow().source_files)[idx].clone();\n \n         match f.lookup_line(pos) {\n-            Some(line) => Ok(SourceFileAndLine { sf: f, line: line }),\n+            Some(line) => Ok(SourceFileAndLine { sf: f, line }),\n             None => Err(f)\n         }\n     }\n@@ -511,7 +511,7 @@ impl SourceMap {\n                               start_col,\n                               end_col: hi.col });\n \n-        Ok(FileLines {file: lo.file, lines: lines})\n+        Ok(FileLines {file: lo.file, lines})\n     }\n \n     /// Extracts the source surrounding the given `Span` using the `extract_source` function. The\n@@ -820,7 +820,7 @@ impl SourceMap {\n         let idx = self.lookup_source_file_idx(bpos);\n         let sf = (*self.files.borrow().source_files)[idx].clone();\n         let offset = bpos - sf.start_pos;\n-        SourceFileAndBytePos {sf: sf, pos: offset}\n+        SourceFileAndBytePos {sf, pos: offset}\n     }\n \n     /// Converts an absolute BytePos to a CharPos relative to the source_file."}, {"sha": "74a4dd5d8515b3825743b6b1f1f971a58cae4093", "filename": "src/test/run-pass/unsized-locals/fnbox-compat.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3849a5f83b82258fd76a3ff64933b81d7efeffa1/src%2Ftest%2Frun-pass%2Funsized-locals%2Ffnbox-compat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3849a5f83b82258fd76a3ff64933b81d7efeffa1/src%2Ftest%2Frun-pass%2Funsized-locals%2Ffnbox-compat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized-locals%2Ffnbox-compat.rs?ref=3849a5f83b82258fd76a3ff64933b81d7efeffa1", "patch": "@@ -1,13 +0,0 @@\n-#![feature(fnbox)]\n-#![allow(deprecated, deprecated_in_future)]\n-\n-use std::boxed::FnBox;\n-\n-fn call_it<T>(f: Box<dyn FnBox() -> T>) -> T {\n-    f()\n-}\n-\n-fn main() {\n-    let s = \"hello\".to_owned();\n-    assert_eq!(&call_it(Box::new(|| s)) as &str, \"hello\");\n-}"}, {"sha": "612c1e29d82bd1ba2288c54e1172417649fecd17", "filename": "src/test/ui/async-await/async-fn-nonsend.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,59 @@\n+// compile-fail\n+// edition:2018\n+// compile-flags: --crate-type lib\n+\n+#![feature(async_await)]\n+\n+use std::{\n+    cell::RefCell,\n+    fmt::Debug,\n+    rc::Rc,\n+};\n+\n+fn non_sync() -> impl Debug { RefCell::new(()) }\n+\n+fn non_send() -> impl Debug { Rc::new(()) }\n+\n+fn take_ref<T>(_: &T) {}\n+\n+async fn fut() {}\n+\n+async fn fut_arg<T>(_: T) {}\n+\n+async fn local_dropped_before_await() {\n+    // FIXME: it'd be nice for this to be allowed in a `Send` `async fn`\n+    let x = non_send();\n+    drop(x);\n+    fut().await;\n+}\n+\n+async fn non_send_temporary_in_match() {\n+    // We could theoretically make this work as well (produce a `Send` future)\n+    // for scrutinees / temporaries that can or will\n+    // be dropped prior to the match body\n+    // (e.g. `Copy` types).\n+    match Some(non_send()) {\n+        Some(_) => fut().await,\n+        None => {}\n+    }\n+}\n+\n+async fn non_sync_with_method_call() {\n+    // FIXME: it'd be nice for this to work.\n+    let f: &mut std::fmt::Formatter = panic!();\n+    if non_sync().fmt(f).unwrap() == () {\n+        fut().await;\n+    }\n+}\n+\n+fn assert_send(_: impl Send) {}\n+\n+pub fn pass_assert() {\n+    assert_send(local_dropped_before_await());\n+    //~^ ERROR `std::rc::Rc<()>` cannot be sent between threads safely\n+    assert_send(non_send_temporary_in_match());\n+    //~^ ERROR `std::rc::Rc<()>` cannot be sent between threads safely\n+    assert_send(non_sync_with_method_call());\n+    //~^ ERROR `dyn std::fmt::Write` cannot be sent between threads safely\n+    //~^^ ERROR `*mut (dyn std::ops::Fn() + 'static)` cannot be shared between threads safely\n+}"}, {"sha": "7776a36a28f2b4bb1aa93c196daf9718a01e0950", "filename": "src/test/ui/async-await/async-fn-nonsend.stderr", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-nonsend.stderr?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,87 @@\n+error[E0277]: `std::rc::Rc<()>` cannot be sent between threads safely\n+  --> $DIR/async-fn-nonsend.rs:52:5\n+   |\n+LL |     assert_send(local_dropped_before_await());\n+   |     ^^^^^^^^^^^ `std::rc::Rc<()>` cannot be sent between threads safely\n+   |\n+   = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<()>`\n+   = note: required because it appears within the type `impl std::fmt::Debug`\n+   = note: required because it appears within the type `{impl std::fmt::Debug, impl std::future::Future, ()}`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:23:39: 28:2 {impl std::fmt::Debug, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:23:39: 28:2 {impl std::fmt::Debug, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `impl std::future::Future`\n+   = note: required because it appears within the type `impl std::future::Future`\n+note: required by `assert_send`\n+  --> $DIR/async-fn-nonsend.rs:49:1\n+   |\n+LL | fn assert_send(_: impl Send) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `std::rc::Rc<()>` cannot be sent between threads safely\n+  --> $DIR/async-fn-nonsend.rs:54:5\n+   |\n+LL |     assert_send(non_send_temporary_in_match());\n+   |     ^^^^^^^^^^^ `std::rc::Rc<()>` cannot be sent between threads safely\n+   |\n+   = help: within `impl std::future::Future`, the trait `std::marker::Send` is not implemented for `std::rc::Rc<()>`\n+   = note: required because it appears within the type `impl std::fmt::Debug`\n+   = note: required because it appears within the type `{fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, impl std::future::Future, ()}`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:30:40: 39:2 {fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:30:40: 39:2 {fn(impl std::fmt::Debug) -> std::option::Option<impl std::fmt::Debug> {std::option::Option::<impl std::fmt::Debug>::Some}, fn() -> impl std::fmt::Debug {non_send}, impl std::fmt::Debug, std::option::Option<impl std::fmt::Debug>, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `impl std::future::Future`\n+   = note: required because it appears within the type `impl std::future::Future`\n+note: required by `assert_send`\n+  --> $DIR/async-fn-nonsend.rs:49:1\n+   |\n+LL | fn assert_send(_: impl Send) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `dyn std::fmt::Write` cannot be sent between threads safely\n+  --> $DIR/async-fn-nonsend.rs:56:5\n+   |\n+LL |     assert_send(non_sync_with_method_call());\n+   |     ^^^^^^^^^^^ `dyn std::fmt::Write` cannot be sent between threads safely\n+   |\n+   = help: the trait `std::marker::Send` is not implemented for `dyn std::fmt::Write`\n+   = note: required because of the requirements on the impl of `std::marker::Send` for `&mut dyn std::fmt::Write`\n+   = note: required because it appears within the type `std::fmt::Formatter<'_>`\n+   = note: required because of the requirements on the impl of `std::marker::Send` for `&mut std::fmt::Formatter<'_>`\n+   = note: required because it appears within the type `for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:41:38: 47:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:41:38: 47:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `impl std::future::Future`\n+   = note: required because it appears within the type `impl std::future::Future`\n+note: required by `assert_send`\n+  --> $DIR/async-fn-nonsend.rs:49:1\n+   |\n+LL | fn assert_send(_: impl Send) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `*mut (dyn std::ops::Fn() + 'static)` cannot be shared between threads safely\n+  --> $DIR/async-fn-nonsend.rs:56:5\n+   |\n+LL |     assert_send(non_sync_with_method_call());\n+   |     ^^^^^^^^^^^ `*mut (dyn std::ops::Fn() + 'static)` cannot be shared between threads safely\n+   |\n+   = help: within `std::fmt::ArgumentV1<'_>`, the trait `std::marker::Sync` is not implemented for `*mut (dyn std::ops::Fn() + 'static)`\n+   = note: required because it appears within the type `std::marker::PhantomData<*mut (dyn std::ops::Fn() + 'static)>`\n+   = note: required because it appears within the type `core::fmt::Void`\n+   = note: required because it appears within the type `&core::fmt::Void`\n+   = note: required because it appears within the type `std::fmt::ArgumentV1<'_>`\n+   = note: required because of the requirements on the impl of `std::marker::Send` for `std::slice::Iter<'_, std::fmt::ArgumentV1<'_>>`\n+   = note: required because it appears within the type `std::fmt::Formatter<'_>`\n+   = note: required because of the requirements on the impl of `std::marker::Send` for `&mut std::fmt::Formatter<'_>`\n+   = note: required because it appears within the type `for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}`\n+   = note: required because it appears within the type `[static generator@$DIR/async-fn-nonsend.rs:41:38: 47:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}]`\n+   = note: required because it appears within the type `std::future::GenFuture<[static generator@$DIR/async-fn-nonsend.rs:41:38: 47:2 for<'r, 's> {&'r mut std::fmt::Formatter<'s>, bool, impl std::future::Future, ()}]>`\n+   = note: required because it appears within the type `impl std::future::Future`\n+   = note: required because it appears within the type `impl std::future::Future`\n+note: required by `assert_send`\n+  --> $DIR/async-fn-nonsend.rs:49:1\n+   |\n+LL | fn assert_send(_: impl Send) {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "f07fc2fceb5b6aacd9829014e88bb8fcd8b7613c", "filename": "src/test/ui/async-await/async-fn-send-uses-nonsend.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-send-uses-nonsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-send-uses-nonsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-fn-send-uses-nonsend.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,59 @@\n+// compile-pass\n+// edition:2018\n+// compile-flags: --crate-type lib\n+\n+#![feature(async_await)]\n+\n+use std::{\n+    cell::RefCell,\n+    fmt::Debug,\n+    rc::Rc,\n+};\n+\n+fn non_sync() -> impl Debug { RefCell::new(()) }\n+\n+fn non_send() -> impl Debug { Rc::new(()) }\n+\n+fn take_ref<T>(_: &T) {}\n+\n+async fn fut() {}\n+\n+async fn fut_arg<T>(_: T) {}\n+\n+async fn still_send() {\n+    fut().await;\n+    println!(\"{:?} {:?}\", non_send(), non_sync());\n+    fut().await;\n+    drop(non_send());\n+    drop(non_sync());\n+    fut().await;\n+    fut_arg(non_sync()).await;\n+\n+    // Note: all temporaries in `if let` and `match` scrutinee\n+    // are dropped at the *end* of the blocks, so using `non_send()`\n+    // in either of those positions with an await in the middle will\n+    // cause a `!Send` future. It might be nice in the future to allow\n+    // this for `Copy` types, since they can be \"dropped\" early without\n+    // affecting the end user.\n+    if let Some(_) = Some(non_sync()) {\n+        fut().await;\n+    }\n+    match Some(non_sync()) {\n+        Some(_) => fut().await,\n+        None => fut().await,\n+    }\n+\n+    let _ = non_send();\n+    fut().await;\n+\n+    {\n+        let _x = non_send();\n+    }\n+    fut().await;\n+}\n+\n+fn assert_send(_: impl Send) {}\n+\n+pub fn pass_assert() {\n+    assert_send(still_send());\n+}"}, {"sha": "d551ef57985a1b8f73d19516b1f0452968e62b90", "filename": "src/test/ui/async-await/dont-suggest-missing-await.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,21 @@\n+// edition:2018\n+\n+// This test ensures we don't make the suggestion in bodies that aren't `async`.\n+\n+#![feature(async_await)]\n+\n+fn take_u32(x: u32) {}\n+\n+async fn make_u32() -> u32 {\n+    22\n+}\n+\n+async fn dont_suggest_await_in_closure() {\n+    || {\n+        let x = make_u32();\n+        take_u32(x)\n+        //~^ ERROR mismatched types [E0308]\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "c60b0d1f30e803e25c33e8062af793ec2bac45ae", "filename": "src/test/ui/async-await/dont-suggest-missing-await.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdont-suggest-missing-await.stderr?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/dont-suggest-missing-await.rs:16:18\n+   |\n+LL |         take_u32(x)\n+   |                  ^ expected u32, found opaque type\n+   |\n+   = note: expected type `u32`\n+              found type `impl std::future::Future`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "913f1435c6adf5b77fed4a81b5ae5fe3424493cf", "filename": "src/test/ui/async-await/generics-and-bounds.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fgenerics-and-bounds.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,90 @@\n+// compile-pass\n+// edition:2018\n+// compile-flags: --crate-type lib\n+\n+#![feature(async_await)]\n+\n+use std::future::Future;\n+\n+pub async fn simple_generic<T>() {}\n+\n+pub trait Foo {\n+    fn foo(&self) {}\n+}\n+\n+struct FooType;\n+impl Foo for FooType {}\n+\n+pub async fn call_generic_bound<F: Foo>(f: F) {\n+    f.foo()\n+}\n+\n+pub async fn call_where_clause<F>(f: F)\n+where\n+    F: Foo,\n+{\n+    f.foo()\n+}\n+\n+pub async fn call_impl_trait(f: impl Foo) {\n+    f.foo()\n+}\n+\n+pub async fn call_with_ref(f: &impl Foo) {\n+    f.foo()\n+}\n+\n+pub fn async_fn_with_same_generic_params_unifies() {\n+    let mut a = call_generic_bound(FooType);\n+    a = call_generic_bound(FooType);\n+\n+    let mut b = call_where_clause(FooType);\n+    b = call_where_clause(FooType);\n+\n+    let mut c = call_impl_trait(FooType);\n+    c = call_impl_trait(FooType);\n+\n+    let f_one = FooType;\n+    let f_two = FooType;\n+    let mut d = call_with_ref(&f_one);\n+    d = call_with_ref(&f_two);\n+}\n+\n+pub fn simple_generic_block<T>() -> impl Future<Output = ()> {\n+    async move {}\n+}\n+\n+pub fn call_generic_bound_block<F: Foo>(f: F) -> impl Future<Output = ()> {\n+    async move { f.foo() }\n+}\n+\n+pub fn call_where_clause_block<F>(f: F) -> impl Future<Output = ()>\n+where\n+    F: Foo,\n+{\n+    async move { f.foo() }\n+}\n+\n+pub fn call_impl_trait_block(f: impl Foo) -> impl Future<Output = ()> {\n+    async move { f.foo() }\n+}\n+\n+pub fn call_with_ref_block<'a>(f: &'a (impl Foo + 'a)) -> impl Future<Output = ()> + 'a {\n+    async move { f.foo() }\n+}\n+\n+pub fn async_block_with_same_generic_params_unifies() {\n+    let mut a = call_generic_bound_block(FooType);\n+    a = call_generic_bound_block(FooType);\n+\n+    let mut b = call_where_clause_block(FooType);\n+    b = call_where_clause_block(FooType);\n+\n+    let mut c = call_impl_trait_block(FooType);\n+    c = call_impl_trait_block(FooType);\n+\n+    let f_one = FooType;\n+    let f_two = FooType;\n+    let mut d = call_with_ref_block(&f_one);\n+    d = call_with_ref_block(&f_two);\n+}"}, {"sha": "361a49c2774ecc778ee087732591d1b10d081345", "filename": "src/test/ui/async-await/issues/issue-51719.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -7,7 +7,8 @@\n async fn foo() {}\n \n fn make_generator() {\n-    let _gen = || foo.await; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    let _gen = || foo().await;\n+    //~^ ERROR `await` is only allowed inside `async` functions and blocks\n }\n \n fn main() {}"}, {"sha": "2a9fb6cf0df6e511be761d89149d2b8fc97b9144", "filename": "src/test/ui/async-await/issues/issue-51719.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-51719.stderr?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -1,8 +1,8 @@\n error[E0728]: `await` is only allowed inside `async` functions and blocks\n   --> $DIR/issue-51719.rs:10:19\n    |\n-LL |     let _gen = || foo.await;\n-   |                -- ^^^^^^^^^ only allowed inside `async` functions and blocks\n+LL |     let _gen = || foo().await;\n+   |                -- ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n    |                |\n    |                this is not `async`\n "}, {"sha": "da8b22bc104bf0ee4f582f25e48febe1d5618908", "filename": "src/test/ui/async-await/issues/issue-61986.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61986.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61986.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61986.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,21 @@\n+// compile-pass\n+// edition:2018\n+//\n+// Tests that we properly handle StorageDead/StorageLives for temporaries\n+// created in async loop bodies.\n+\n+#![feature(async_await)]\n+\n+async fn bar() -> Option<()> {\n+    Some(())\n+}\n+\n+async fn listen() {\n+    while let Some(_) = bar().await {\n+        String::new();\n+    }\n+}\n+\n+fn main() {\n+    listen();\n+}"}, {"sha": "e2d58cac24d941a8b9663c1b60a04e9114f4dcd0", "filename": "src/test/ui/async-await/issues/issue-62009.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,19 @@\n+// edition:2018\n+\n+#![feature(async_await)]\n+\n+async fn print_dur() {}\n+\n+fn main() {\n+    async { let (); }.await;\n+    //~^ ERROR `await` is only allowed inside `async` functions and blocks\n+    async {\n+    //~^ ERROR `await` is only allowed inside `async` functions and blocks\n+        let task1 = print_dur().await;\n+    }.await;\n+    (async || 2333)().await;\n+    //~^ ERROR `await` is only allowed inside `async` functions and blocks\n+    (|_| 2333).await;\n+    //~^ ERROR `await` is only allowed inside `async` functions and blocks\n+    //~^^ ERROR\n+}"}, {"sha": "53d1f34fe4f9b79f2d2f3cfbee10224e173cba7c", "filename": "src/test/ui/async-await/issues/issue-62009.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62009.stderr?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,49 @@\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/issue-62009.rs:8:5\n+   |\n+LL | fn main() {\n+   |    ---- this is not `async`\n+LL |     async { let (); }.await;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/issue-62009.rs:10:5\n+   |\n+LL |   fn main() {\n+   |      ---- this is not `async`\n+...\n+LL | /     async {\n+LL | |\n+LL | |         let task1 = print_dur().await;\n+LL | |     }.await;\n+   | |___________^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/issue-62009.rs:14:5\n+   |\n+LL | fn main() {\n+   |    ---- this is not `async`\n+...\n+LL |     (async || 2333)().await;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/issue-62009.rs:16:5\n+   |\n+LL | fn main() {\n+   |    ---- this is not `async`\n+...\n+LL |     (|_| 2333).await;\n+   |     ^^^^^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0277]: the trait bound `[closure@$DIR/issue-62009.rs:16:5: 16:15]: std::future::Future` is not satisfied\n+  --> $DIR/issue-62009.rs:16:5\n+   |\n+LL |     (|_| 2333).await;\n+   |     ^^^^^^^^^^^^^^^^ the trait `std::future::Future` is not implemented for `[closure@$DIR/issue-62009.rs:16:5: 16:15]`\n+   |\n+   = note: required by `std::future::poll_with_tls_context`\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "1db314a5aa20850470c13a6a598eaadc58c5fd52", "filename": "src/test/ui/async-await/no-async-const.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fno-async-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fno-async-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-async-const.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,8 @@\n+// compile-fail\n+// edition:2018\n+// compile-flags: --crate-type lib\n+\n+#![feature(async_await)]\n+\n+pub async const fn x() {}\n+//~^ ERROR expected one of `fn` or `unsafe`, found `const`"}, {"sha": "cdb1c6e2d7bd912d03d4c3317ffc8e1e48ef7082", "filename": "src/test/ui/async-await/no-async-const.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fno-async-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fno-async-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-async-const.stderr?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,8 @@\n+error: expected one of `fn` or `unsafe`, found `const`\n+  --> $DIR/no-async-const.rs:7:11\n+   |\n+LL | pub async const fn x() {}\n+   |           ^^^^^ expected one of `fn` or `unsafe` here\n+\n+error: aborting due to previous error\n+"}, {"sha": "9f09d2188c7c080f6a7e2380d2f39d42fa5fabc6", "filename": "src/test/ui/async-await/no-const-async.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,9 @@\n+// compile-fail\n+// edition:2018\n+// compile-flags: --crate-type lib\n+\n+#![feature(async_await)]\n+\n+pub const async fn x() {}\n+//~^ ERROR expected identifier, found reserved keyword `async`\n+//~^^ expected `:`, found keyword `fn`"}, {"sha": "693fbf186f91327bb5ad8f0d511baa1178b0fa70", "filename": "src/test/ui/async-await/no-const-async.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,18 @@\n+error: expected identifier, found reserved keyword `async`\n+  --> $DIR/no-const-async.rs:7:11\n+   |\n+LL | pub const async fn x() {}\n+   |           ^^^^^ expected identifier, found reserved keyword\n+help: you can escape reserved keywords to use them as identifiers\n+   |\n+LL | pub const r#async fn x() {}\n+   |           ^^^^^^^\n+\n+error: expected `:`, found keyword `fn`\n+  --> $DIR/no-const-async.rs:7:17\n+   |\n+LL | pub const async fn x() {}\n+   |                 ^^ expected `:`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "282be368c69cdaeb24b41264e214834eadb4462f", "filename": "src/test/ui/async-await/suggest-missing-await.fixed", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.fixed?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,32 @@\n+// edition:2018\n+// run-rustfix\n+\n+#![feature(async_await)]\n+\n+fn take_u32(_x: u32) {}\n+\n+async fn make_u32() -> u32 {\n+    22\n+}\n+\n+#[allow(unused)]\n+async fn suggest_await_in_async_fn() {\n+    let x = make_u32();\n+    take_u32(x.await)\n+    //~^ ERROR mismatched types [E0308]\n+    //~| HELP consider using `.await` here\n+    //~| SUGGESTION x.await\n+}\n+\n+#[allow(unused)]\n+async fn suggest_await_in_async_closure() {\n+    async || {\n+        let x = make_u32();\n+        take_u32(x.await)\n+        //~^ ERROR mismatched types [E0308]\n+        //~| HELP consider using `.await` here\n+        //~| SUGGESTION x.await\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "36103f050c1472e2a525b184c049546fa5613778", "filename": "src/test/ui/async-await/suggest-missing-await.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.rs?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,32 @@\n+// edition:2018\n+// run-rustfix\n+\n+#![feature(async_await)]\n+\n+fn take_u32(_x: u32) {}\n+\n+async fn make_u32() -> u32 {\n+    22\n+}\n+\n+#[allow(unused)]\n+async fn suggest_await_in_async_fn() {\n+    let x = make_u32();\n+    take_u32(x)\n+    //~^ ERROR mismatched types [E0308]\n+    //~| HELP consider using `.await` here\n+    //~| SUGGESTION x.await\n+}\n+\n+#[allow(unused)]\n+async fn suggest_await_in_async_closure() {\n+    async || {\n+        let x = make_u32();\n+        take_u32(x)\n+        //~^ ERROR mismatched types [E0308]\n+        //~| HELP consider using `.await` here\n+        //~| SUGGESTION x.await\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "59c20dcfbc9473545da76246499188045b449071", "filename": "src/test/ui/async-await/suggest-missing-await.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433a46781544da61801400316e7e546f01b81952/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fsuggest-missing-await.stderr?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -0,0 +1,27 @@\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-missing-await.rs:15:14\n+   |\n+LL |     take_u32(x)\n+   |              ^\n+   |              |\n+   |              expected u32, found opaque type\n+   |              help: consider using `.await` here: `x.await`\n+   |\n+   = note: expected type `u32`\n+              found type `impl std::future::Future`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-missing-await.rs:25:18\n+   |\n+LL |         take_u32(x)\n+   |                  ^\n+   |                  |\n+   |                  expected u32, found opaque type\n+   |                  help: consider using `.await` here: `x.await`\n+   |\n+   = note: expected type `u32`\n+              found type `impl std::future::Future`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "597c9be8c75be3e664f189c4325c96cf9b464dc3", "filename": "src/tools/rls", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frls?ref=433a46781544da61801400316e7e546f01b81952", "patch": "@@ -1 +1 @@\n-Subproject commit 3e519650cea91a4b785cd773a3e5965553f74249\n+Subproject commit 597c9be8c75be3e664f189c4325c96cf9b464dc3"}]}