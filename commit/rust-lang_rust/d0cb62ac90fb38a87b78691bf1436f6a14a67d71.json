{"sha": "d0cb62ac90fb38a87b78691bf1436f6a14a67d71", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwY2I2MmFjOTBmYjM4YTg3Yjc4NjkxYmYxNDM2ZjZhMTRhNjdkNzE=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-28T22:44:51Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-28T22:49:06Z"}, "message": "Factor out box initializing code into trans_malloc_boxed.", "tree": {"sha": "5ef28b6b04db3adafb285f83ff491b541b7284d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ef28b6b04db3adafb285f83ff491b541b7284d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0cb62ac90fb38a87b78691bf1436f6a14a67d71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0cb62ac90fb38a87b78691bf1436f6a14a67d71", "html_url": "https://github.com/rust-lang/rust/commit/d0cb62ac90fb38a87b78691bf1436f6a14a67d71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0cb62ac90fb38a87b78691bf1436f6a14a67d71/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ea5a8a6edef802eea4a01e7c56f9479f19a1789", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ea5a8a6edef802eea4a01e7c56f9479f19a1789", "html_url": "https://github.com/rust-lang/rust/commit/0ea5a8a6edef802eea4a01e7c56f9479f19a1789"}], "stats": {"total": 102, "additions": 36, "deletions": 66}, "files": [{"sha": "901a8cce8b8df7a40eaadf5820d421498267c2b4", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 36, "deletions": 66, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d0cb62ac90fb38a87b78691bf1436f6a14a67d71/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0cb62ac90fb38a87b78691bf1436f6a14a67d71/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d0cb62ac90fb38a87b78691bf1436f6a14a67d71", "patch": "@@ -825,10 +825,10 @@ fn trans_shared_malloc(cx: &@block_ctxt, llptr_ty: TypeRef, llsize: ValueRef)\n     ret rslt(cx, cx.build.PointerCast(rval, llptr_ty));\n }\n \n-// trans_malloc_boxed: expects an unboxed type and returns a pointer to enough\n-// space for something of that type, along with space for a reference count;\n-// in other words, it allocates a box for something of that type.\n-fn trans_malloc_boxed(cx: &@block_ctxt, t: ty::t) -> result {\n+// trans_malloc_boxed_raw: expects an unboxed type and returns a pointer to\n+// enough space for something of that type, along with space for a reference\n+// count; in other words, it allocates a box for something of that type.\n+fn trans_malloc_boxed_raw(cx: &@block_ctxt, t: ty::t) -> result {\n     // Synthesize a fake box type structurally so we have something\n     // to measure the size of.\n \n@@ -843,13 +843,26 @@ fn trans_malloc_boxed(cx: &@block_ctxt, t: ty::t) -> result {\n         ty::mk_imm_tup(bcx_tcx(cx), ~[ty::mk_int(bcx_tcx(cx)), t]);\n     let box_ptr = ty::mk_imm_box(bcx_tcx(cx), t);\n     let sz = size_of(cx, boxed_body);\n+\n     // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n     // wants.\n-\n     let llty = type_of(bcx_ccx(cx), cx.sp, box_ptr);\n     ret trans_raw_malloc(sz.bcx, llty, sz.val);\n }\n \n+// trans_malloc_boxed: usefully wraps trans_malloc_box_raw; allocates a box,\n+// initializes the reference count to 1, and pulls out the body and rc\n+fn trans_malloc_boxed(cx: &@block_ctxt, t: ty::t) ->\n+    {bcx: @block_ctxt, box: ValueRef, rc: ValueRef, body: ValueRef} {\n+    let res = trans_malloc_boxed_raw(cx, t);\n+    let box = res.val;\n+    let rc = res.bcx.build.GEP(box,\n+                               ~[C_int(0), C_int(abi::box_rc_field_refcnt)]);\n+    res.bcx.build.Store(C_int(1), rc);\n+    let body = res.bcx.build.GEP(box,\n+                                 ~[C_int(0), C_int(abi::box_rc_field_body)]);\n+    ret {bcx: res.bcx, box: res.val, rc: rc, body: body};\n+}\n \n // Type descriptor and type glue stuff\n \n@@ -2701,25 +2714,18 @@ fn trans_unary(cx: &@block_ctxt, op: ast::unop, e: &@ast::expr,\n         let lv = trans_lval(cx, e);\n         let box_ty = node_id_type(bcx_ccx(lv.res.bcx), id);\n         let sub = trans_malloc_boxed(lv.res.bcx, e_ty);\n-        add_clean_temp(cx, sub.val, box_ty);\n-        let box = sub.val;\n-        let rc =\n-            sub.bcx.build.GEP(box,\n-                              ~[C_int(0), C_int(abi::box_rc_field_refcnt)]);\n-        let body =\n-            sub.bcx.build.GEP(box,\n-                              ~[C_int(0), C_int(abi::box_rc_field_body)]);\n-        sub.bcx.build.Store(C_int(1), rc);\n+        let body = sub.body;\n+        add_clean_temp(cx, sub.box, box_ty);\n+\n         // Cast the body type to the type of the value. This is needed to\n         // make tags work, since tags have a different LLVM type depending\n         // on whether they're boxed or not.\n-\n         if !ty::type_has_dynamic_size(bcx_tcx(cx), e_ty) {\n             let llety = T_ptr(type_of(bcx_ccx(sub.bcx), e.span, e_ty));\n             body = sub.bcx.build.PointerCast(body, llety);\n         }\n-        sub = move_val_if_temp(sub.bcx, INIT, body, lv, e_ty);\n-        ret rslt(sub.bcx, box);\n+        let res = move_val_if_temp(sub.bcx, INIT, body, lv, e_ty);\n+        ret rslt(res.bcx, sub.box);\n       }\n       ast::deref. {\n         bcx_ccx(cx).sess.bug(\"deref expressions should have been \\\n@@ -4629,17 +4635,10 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     // Finally, synthesize a type for that whole vector.\n     let closure_ty: ty::t = ty::mk_imm_tup(bcx_tcx(cx), closure_tys);\n \n-    // Allocate a box that can hold something closure-sized, including\n-    // space for a refcount.\n+    // Allocate a box that can hold something closure-sized.\n     let r = trans_malloc_boxed(bcx, closure_ty);\n-    let box = r.val;\n     bcx = r.bcx;\n-\n-    // Grab onto the refcount and body parts of the box we allocated.\n-    let rc = bcx.build.GEP(box, ~[C_int(0), C_int(abi::box_rc_field_refcnt)]);\n-    let closure =\n-        bcx.build.GEP(box, ~[C_int(0), C_int(abi::box_rc_field_body)]);\n-    bcx.build.Store(C_int(1), rc);\n+    let closure = r.body;\n \n     // Store bindings tydesc.\n     let bound_tydesc =\n@@ -4684,7 +4683,7 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n                          args, closure_ty, bound_tys, ty_param_count);\n \n     // Construct the function pair\n-    let pair_v = create_real_fn_pair(bcx, llthunk.ty, llthunk.val, box);\n+    let pair_v = create_real_fn_pair(bcx, llthunk.ty, llthunk.val, r.box);\n     add_clean_temp(cx, pair_v, pair_ty);\n     ret rslt(bcx, pair_v);\n }\n@@ -5801,22 +5800,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         // allocates a box, including space for a refcount.\n         let box = trans_malloc_boxed(bcx, body_ty);\n         bcx = box.bcx;\n-\n-        // mk_imm_box throws a refcount into the type we're synthesizing,\n-        // so that it looks like:\n-        // [rc, [tydesc, [typaram, ...], [field, ...], inner_obj]]\n-        let boxed_body_ty: ty::t = ty::mk_imm_box(ccx.tcx, body_ty);\n-\n-        // Grab onto the refcount and body parts of the box we allocated.\n-        let rc =\n-            GEP_tup_like(bcx, boxed_body_ty, box.val,\n-                         ~[0, abi::box_rc_field_refcnt]);\n-        bcx = rc.bcx;\n-        let body =\n-            GEP_tup_like(bcx, boxed_body_ty, box.val,\n-                         ~[0, abi::box_rc_field_body]);\n-        bcx = body.bcx;\n-        bcx.build.Store(C_int(1), rc.val);\n+        let body = box.body;\n \n         // Put together a tydesc for the body, so that the object can later be\n         // freed by calling through its tydesc.\n@@ -5827,7 +5811,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         // the types of the object's fields, so that the fields can be freed\n         // later.\n         let body_tydesc =\n-            GEP_tup_like(bcx, body_ty, body.val,\n+            GEP_tup_like(bcx, body_ty, body,\n                          ~[0, abi::obj_body_elt_tydesc]);\n         bcx = body_tydesc.bcx;\n         let ti = none[@tydesc_info];\n@@ -5842,7 +5826,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         // function in its closure: the fields were passed to the object\n         // constructor and are now available to the object's methods.\n         let body_fields =\n-            GEP_tup_like(bcx, body_ty, body.val,\n+            GEP_tup_like(bcx, body_ty, body,\n                          ~[0, abi::obj_body_elt_fields]);\n         bcx = body_fields.bcx;\n         let i: int = 0;\n@@ -5872,7 +5856,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n             let inner_obj_val: result = trans_expr(bcx, e);\n \n             let body_inner_obj =\n-                GEP_tup_like(bcx, body_ty, body.val,\n+                GEP_tup_like(bcx, body_ty, body,\n                              ~[0, abi::obj_body_elt_inner_obj]);\n             bcx = body_inner_obj.bcx;\n             bcx =\n@@ -5882,7 +5866,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n         }\n \n         // Store box ptr in outer pair.\n-        let p = bcx.build.PointerCast(box.val, llbox_ty);\n+        let p = bcx.build.PointerCast(box.box, llbox_ty);\n         bcx.build.Store(p, pair_box);\n     }\n \n@@ -7120,21 +7104,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         // allocates a box, including space for a refcount.\n         let box = trans_malloc_boxed(bcx, body_ty);\n         bcx = box.bcx;\n-\n-        // mk_imm_box throws a refcount into the type we're synthesizing, so\n-        // that it looks like: [rc, [tydesc_ty, [typaram, ...], [field, ...]]]\n-        let boxed_body_ty: ty::t = ty::mk_imm_box(ccx.tcx, body_ty);\n-\n-        // Grab onto the refcount and body parts of the box we allocated.\n-        let rc =\n-            GEP_tup_like(bcx, boxed_body_ty, box.val,\n-                         ~[0, abi::box_rc_field_refcnt]);\n-        bcx = rc.bcx;\n-        let body =\n-            GEP_tup_like(bcx, boxed_body_ty, box.val,\n-                         ~[0, abi::box_rc_field_body]);\n-        bcx = body.bcx;\n-        bcx.build.Store(C_int(1), rc.val);\n+        let body = box.body;\n \n         // Put together a tydesc for the body, so that the object can later be\n         // freed by calling through its tydesc.\n@@ -7146,7 +7116,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         // later.\n \n         let body_tydesc =\n-            GEP_tup_like(bcx, body_ty, body.val,\n+            GEP_tup_like(bcx, body_ty, body,\n                          ~[0, abi::obj_body_elt_tydesc]);\n         bcx = body_tydesc.bcx;\n         let ti = none[@tydesc_info];\n@@ -7165,7 +7135,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n \n         // Copy typarams into captured typarams.\n         let body_typarams =\n-            GEP_tup_like(bcx, body_ty, body.val,\n+            GEP_tup_like(bcx, body_ty, body,\n                          ~[0, abi::obj_body_elt_typarams]);\n         bcx = body_typarams.bcx;\n         let i: int = 0;\n@@ -7180,7 +7150,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n \n         // Copy args into body fields.\n         let body_fields =\n-            GEP_tup_like(bcx, body_ty, body.val,\n+            GEP_tup_like(bcx, body_ty, body,\n                          ~[0, abi::obj_body_elt_fields]);\n         bcx = body_fields.bcx;\n         i = 0;\n@@ -7202,7 +7172,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n         }\n \n         // Store box ptr in outer pair.\n-        let p = bcx.build.PointerCast(box.val, llbox_ty);\n+        let p = bcx.build.PointerCast(box.box, llbox_ty);\n         bcx.build.Store(p, pair_box);\n     }\n     bcx.build.RetVoid();"}]}