{"sha": "a6a7dac5cf929b04deac235e511073b2e9640433", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2YTdkYWM1Y2Y5MjliMDRkZWFjMjM1ZTUxMTA3M2IyZTk2NDA0MzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-23T07:30:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-23T07:30:03Z"}, "message": "Auto merge of #44633 - petrochenkov:priv2, r=nikomatsakis\n\nRecord semantic types for all syntactic types in bodies\n\n... and use recorded types in type privacy checking (types are recorded after inference, so there are no `_`s left).\nAlso use `hir_ty_to_ty` for types in signatures in type privacy checking.\n\nThis could also be potentially useful for save-analysis and diagnostics.\n\nFixes https://github.com/rust-lang/rust/pull/42125#issuecomment-305987755\nr? @eddyb", "tree": {"sha": "9bec4b77e2be7cf7fd3b5f1c4e42f47a6705c259", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bec4b77e2be7cf7fd3b5f1c4e42f47a6705c259"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6a7dac5cf929b04deac235e511073b2e9640433", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6a7dac5cf929b04deac235e511073b2e9640433", "html_url": "https://github.com/rust-lang/rust/commit/a6a7dac5cf929b04deac235e511073b2e9640433", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6a7dac5cf929b04deac235e511073b2e9640433/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85a5d3ffa42068e9ccffde004a466871fd6f2e44", "url": "https://api.github.com/repos/rust-lang/rust/commits/85a5d3ffa42068e9ccffde004a466871fd6f2e44", "html_url": "https://github.com/rust-lang/rust/commit/85a5d3ffa42068e9ccffde004a466871fd6f2e44"}, {"sha": "419069d984e3f4cf33768003fa5eaccae51fec10", "url": "https://api.github.com/repos/rust-lang/rust/commits/419069d984e3f4cf33768003fa5eaccae51fec10", "html_url": "https://github.com/rust-lang/rust/commit/419069d984e3f4cf33768003fa5eaccae51fec10"}], "stats": {"total": 263, "additions": 119, "deletions": 144}, "files": [{"sha": "807375e00afdbe58a9fac223154c477aaab35317", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6a7dac5cf929b04deac235e511073b2e9640433/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a6a7dac5cf929b04deac235e511073b2e9640433/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=a6a7dac5cf929b04deac235e511073b2e9640433", "patch": "@@ -1715,6 +1715,7 @@ name = \"rustc_privacy\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc 0.0.0\",\n+ \"rustc_typeck 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "8208eb896d669494a4314661430deaea5f2c2532", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a6a7dac5cf929b04deac235e511073b2e9640433", "patch": "@@ -683,7 +683,7 @@ impl<'a> LoweringContext<'a> {\n                 return self.lower_ty(ty);\n             }\n             TyKind::Path(ref qself, ref path) => {\n-                let id = self.lower_node_id(t.id).node_id;\n+                let id = self.lower_node_id(t.id);\n                 let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit);\n                 return self.ty_path(id, t.span, qpath);\n             }\n@@ -732,10 +732,12 @@ impl<'a> LoweringContext<'a> {\n             TyKind::Mac(_) => panic!(\"TyMac should have been expanded by now.\"),\n         };\n \n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(t.id);\n         P(hir::Ty {\n-            id: self.lower_node_id(t.id).node_id,\n+            id: node_id,\n             node: kind,\n             span: t.span,\n+            hir_id,\n         })\n     }\n \n@@ -861,7 +863,7 @@ impl<'a> LoweringContext<'a> {\n             // Otherwise, the base path is an implicit `Self` type path,\n             // e.g. `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n             // `<I as Iterator>::Item::default`.\n-            let new_id = self.next_id().node_id;\n+            let new_id = self.next_id();\n             self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path))\n         };\n \n@@ -886,7 +888,7 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             // Wrap the associated extension in another type node.\n-            let new_id = self.next_id().node_id;\n+            let new_id = self.next_id();\n             ty = self.ty_path(new_id, p.span, qpath);\n         }\n \n@@ -994,7 +996,8 @@ impl<'a> LoweringContext<'a> {\n         let &ParenthesizedParameterData { ref inputs, ref output, span } = data;\n         let inputs = inputs.iter().map(|ty| self.lower_ty(ty)).collect();\n         let mk_tup = |this: &mut Self, tys, span| {\n-            P(hir::Ty { node: hir::TyTup(tys), id: this.next_id().node_id, span })\n+            let LoweredNodeId { node_id, hir_id } = this.next_id();\n+            P(hir::Ty { node: hir::TyTup(tys), id: node_id, hir_id, span })\n         };\n \n         hir::PathParameters {\n@@ -2974,7 +2977,7 @@ impl<'a> LoweringContext<'a> {\n         self.expr_block(block, attrs)\n     }\n \n-    fn ty_path(&mut self, id: NodeId, span: Span, qpath: hir::QPath) -> P<hir::Ty> {\n+    fn ty_path(&mut self, id: LoweredNodeId, span: Span, qpath: hir::QPath) -> P<hir::Ty> {\n         let mut id = id;\n         let node = match qpath {\n             hir::QPath::Resolved(None, path) => {\n@@ -2984,14 +2987,14 @@ impl<'a> LoweringContext<'a> {\n                         bound_lifetimes: hir_vec![],\n                         trait_ref: hir::TraitRef {\n                             path: path.and_then(|path| path),\n-                            ref_id: id,\n+                            ref_id: id.node_id,\n                         },\n                         span,\n                     };\n \n                     // The original ID is taken by the `PolyTraitRef`,\n                     // so the `Ty` itself needs a different one.\n-                    id = self.next_id().node_id;\n+                    id = self.next_id();\n \n                     hir::TyTraitObject(hir_vec![principal], self.elided_lifetime(span))\n                 } else {\n@@ -3000,7 +3003,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             _ => hir::TyPath(qpath)\n         };\n-        P(hir::Ty { id, node, span })\n+        P(hir::Ty { id: id.node_id, hir_id: id.hir_id, node, span })\n     }\n \n     fn elided_lifetime(&mut self, span: Span) -> hir::Lifetime {"}, {"sha": "e96edaa86d2a2a5709b7ab3cf82c6837218fa997", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a6a7dac5cf929b04deac235e511073b2e9640433", "patch": "@@ -1354,6 +1354,7 @@ pub struct Ty {\n     pub id: NodeId,\n     pub node: Ty_,\n     pub span: Span,\n+    pub hir_id: HirId,\n }\n \n impl fmt::Debug for Ty {"}, {"sha": "bc0c52575ae1506fd65f5021f3cadb6185b9fc61", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=a6a7dac5cf929b04deac235e511073b2e9640433", "patch": "@@ -245,6 +245,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Ty {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty {\n                 id: _,\n+                hir_id: _,\n                 ref node,\n                 ref span,\n             } = *self;"}, {"sha": "c65312e9a8337e8fd48f3d290d91926bb97956d6", "filename": "src/librustc_privacy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc_privacy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc_privacy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2FCargo.toml?ref=a6a7dac5cf929b04deac235e511073b2e9640433", "patch": "@@ -10,5 +10,6 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n rustc = { path = \"../librustc\" }\n+rustc_typeck = { path = \"../librustc_typeck\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "e7a1dd6b043b173b51022a94877f785c0a301d35", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 37, "deletions": 118, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a6a7dac5cf929b04deac235e511073b2e9640433", "patch": "@@ -17,6 +17,7 @@\n \n #[macro_use] extern crate rustc;\n #[macro_use] extern crate syntax;\n+extern crate rustc_typeck;\n extern crate syntax_pos;\n \n use rustc::hir::{self, PatKind};\n@@ -658,65 +659,6 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n         }\n         false\n     }\n-\n-    fn check_item(&mut self, item_id: ast::NodeId) -> &mut Self {\n-        self.current_item = self.tcx.hir.local_def_id(item_id);\n-        self.span = self.tcx.hir.span(item_id);\n-        self\n-    }\n-\n-    // Convenience methods for checking item interfaces\n-    fn ty(&mut self) -> &mut Self {\n-        self.tcx.type_of(self.current_item).visit_with(self);\n-        self\n-    }\n-\n-    fn generics(&mut self) -> &mut Self {\n-        for def in &self.tcx.generics_of(self.current_item).types {\n-            if def.has_default {\n-                self.tcx.type_of(def.def_id).visit_with(self);\n-            }\n-        }\n-        self\n-    }\n-\n-    fn predicates(&mut self) -> &mut Self {\n-        let predicates = self.tcx.predicates_of(self.current_item);\n-        for predicate in &predicates.predicates {\n-            predicate.visit_with(self);\n-            match predicate {\n-                &ty::Predicate::Trait(poly_predicate) => {\n-                    self.check_trait_ref(poly_predicate.skip_binder().trait_ref);\n-                },\n-                &ty::Predicate::Projection(poly_predicate) => {\n-                    let tcx = self.tcx;\n-                    self.check_trait_ref(\n-                        poly_predicate.skip_binder().projection_ty.trait_ref(tcx)\n-                    );\n-                },\n-                _ => (),\n-            };\n-        }\n-        self\n-    }\n-\n-    fn impl_trait_ref(&mut self) -> &mut Self {\n-        if let Some(impl_trait_ref) = self.tcx.impl_trait_ref(self.current_item) {\n-            self.check_trait_ref(impl_trait_ref);\n-        }\n-        self.tcx.predicates_of(self.current_item).visit_with(self);\n-        self\n-    }\n-\n-    fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n-        if !self.item_is_accessible(trait_ref.def_id) {\n-            let msg = format!(\"trait `{}` is private\", trait_ref);\n-            self.tcx.sess.span_err(self.span, &msg);\n-            return true;\n-        }\n-\n-        trait_ref.super_visit_with(self)\n-    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n@@ -733,6 +675,35 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         self.tables = orig_tables;\n     }\n \n+    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty) {\n+        self.span = hir_ty.span;\n+        if let Some(ty) = self.tables.node_id_to_type_opt(hir_ty.hir_id) {\n+            // Types in bodies.\n+            if ty.visit_with(self) {\n+                return;\n+            }\n+        } else {\n+            // Types in signatures.\n+            // FIXME: This is very ineffective. Ideally each HIR type should be converted\n+            // into a semantic type only once and the result should be cached somehow.\n+            if rustc_typeck::hir_ty_to_ty(self.tcx, hir_ty).visit_with(self) {\n+                return;\n+            }\n+        }\n+\n+        intravisit::walk_ty(self, hir_ty);\n+    }\n+\n+    fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef) {\n+        if !self.item_is_accessible(trait_ref.path.def.def_id()) {\n+            let msg = format!(\"trait `{:?}` is private\", trait_ref.path);\n+            self.tcx.sess.span_err(self.span, &msg);\n+            return;\n+        }\n+\n+        intravisit::walk_trait_ref(self, trait_ref);\n+    }\n+\n     // Check types of expressions\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if self.check_expr_pat_type(expr.hir_id, expr.span) {\n@@ -807,63 +778,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                                         item.id,\n                                         &mut self.tables,\n                                         self.empty_tables);\n-\n-        match item.node {\n-            hir::ItemExternCrate(..) | hir::ItemMod(..) |\n-            hir::ItemUse(..) | hir::ItemGlobalAsm(..) => {}\n-            hir::ItemConst(..) | hir::ItemStatic(..) |\n-            hir::ItemTy(..) | hir::ItemFn(..) => {\n-                self.check_item(item.id).generics().predicates().ty();\n-            }\n-            hir::ItemTrait(.., ref trait_item_refs) => {\n-                self.check_item(item.id).generics().predicates();\n-                for trait_item_ref in trait_item_refs {\n-                    let check = self.check_item(trait_item_ref.id.node_id);\n-                    check.generics().predicates();\n-                    if trait_item_ref.kind != hir::AssociatedItemKind::Type ||\n-                       trait_item_ref.defaultness.has_value() {\n-                        check.ty();\n-                    }\n-                }\n-            }\n-            hir::ItemEnum(ref def, _) => {\n-                self.check_item(item.id).generics().predicates();\n-                for variant in &def.variants {\n-                    for field in variant.node.data.fields() {\n-                        self.check_item(field.id).ty();\n-                    }\n-                }\n-            }\n-            hir::ItemForeignMod(ref foreign_mod) => {\n-                for foreign_item in &foreign_mod.items {\n-                    self.check_item(foreign_item.id).generics().predicates().ty();\n-                }\n-            }\n-            hir::ItemStruct(ref struct_def, _) |\n-            hir::ItemUnion(ref struct_def, _) => {\n-                self.check_item(item.id).generics().predicates();\n-                for field in struct_def.fields() {\n-                    self.check_item(field.id).ty();\n-                }\n-            }\n-            hir::ItemDefaultImpl(..) => {\n-                self.check_item(item.id).impl_trait_ref();\n-            }\n-            hir::ItemImpl(.., ref trait_ref, _, ref impl_item_refs) => {\n-                {\n-                    let check = self.check_item(item.id);\n-                    check.ty().generics().predicates();\n-                    if trait_ref.is_some() {\n-                        check.impl_trait_ref();\n-                    }\n-                }\n-                for impl_item_ref in impl_item_refs {\n-                    let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n-                    self.check_item(impl_item.id).generics().predicates().ty();\n-                }\n-            }\n-        }\n-\n         self.current_item = self.tcx.hir.local_def_id(item.id);\n         intravisit::walk_item(self, item);\n         self.tables = orig_tables;\n@@ -924,8 +838,13 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ty::TyProjection(ref proj) => {\n-                let tcx = self.tcx;\n-                if self.check_trait_ref(proj.trait_ref(tcx)) {\n+                let trait_ref = proj.trait_ref(self.tcx);\n+                if !self.item_is_accessible(trait_ref.def_id) {\n+                    let msg = format!(\"trait `{}` is private\", trait_ref);\n+                    self.tcx.sess.span_err(self.span, &msg);\n+                    return true;\n+                }\n+                if trait_ref.super_visit_with(self) {\n                     return true;\n                 }\n             }"}, {"sha": "3171bd41f92dc1c8c4cb29bce11eb32c828809c8", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a6a7dac5cf929b04deac235e511073b2e9640433", "patch": "@@ -76,6 +76,8 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// used to help suppress derived errors typeck might otherwise\n     /// report.\n     fn set_tainted_by_errors(&self);\n+\n+    fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, span: Span);\n }\n \n struct ConvertedBinding<'tcx> {\n@@ -975,6 +977,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 }\n             }\n             Def::Err => {\n+                for segment in &path.segments {\n+                    for ty in &segment.parameters.types {\n+                        self.ast_ty_to_ty(ty);\n+                    }\n+                    for binding in &segment.parameters.bindings {\n+                        self.ast_ty_to_ty(&binding.ty);\n+                    }\n+                }\n                 self.set_tainted_by_errors();\n                 return self.tcx().types.err;\n             }\n@@ -1115,6 +1125,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         };\n \n+        self.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);\n         result_ty\n     }\n \n@@ -1124,8 +1135,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                      -> Ty<'tcx>\n     {\n         match ty.node {\n-            hir::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n-            hir::TyInfer => self.ty_infer(ty.span),\n+            hir::TyInfer if expected_ty.is_some() => {\n+                self.record_ty(ty.hir_id, expected_ty.unwrap(), ty.span);\n+                expected_ty.unwrap()\n+            }\n             _ => self.ast_ty_to_ty(ty),\n         }\n     }\n@@ -1214,19 +1227,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let expected_ret_ty = expected_sig.as_ref().map(|e| e.output());\n \n-        let is_infer = match decl.output {\n-            hir::Return(ref output) if output.node == hir::TyInfer => true,\n-            hir::DefaultReturn(..) => true,\n-            _ => false\n-        };\n-\n         let output_ty = match decl.output {\n-            _ if is_infer && expected_ret_ty.is_some() =>\n-                expected_ret_ty.unwrap(),\n-            _ if is_infer => self.ty_infer(decl.output.span()),\n-            hir::Return(ref output) =>\n-                self.ast_ty_to_ty(&output),\n-            hir::DefaultReturn(..) => bug!(),\n+            hir::Return(ref output) => {\n+                if let (&hir::TyInfer, Some(expected_ret_ty)) = (&output.node, expected_ret_ty) {\n+                    self.record_ty(output.hir_id, expected_ret_ty, output.span);\n+                    expected_ret_ty\n+                } else {\n+                    self.ast_ty_to_ty(&output)\n+                }\n+            }\n+            hir::DefaultReturn(span) => {\n+                if let Some(expected_ret_ty) = expected_ret_ty {\n+                    expected_ret_ty\n+                } else {\n+                    self.ty_infer(span)\n+                }\n+            }\n         };\n \n         debug!(\"ty_of_closure: output_ty={:?}\", output_ty);"}, {"sha": "edbdfc1a7d4bce1128e0e00ac39c3f978170d874", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a6a7dac5cf929b04deac235e511073b2e9640433", "patch": "@@ -1665,6 +1665,10 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn set_tainted_by_errors(&self) {\n         self.infcx.set_tainted_by_errors()\n     }\n+\n+    fn record_ty(&self, hir_id: hir::HirId, ty: Ty<'tcx>, _span: Span) {\n+        self.write_ty(hir_id, ty)\n+    }\n }\n \n /// Controls whether the arguments are tupled. This is used for the call"}, {"sha": "3c650718a4bfd72e4709afd1053a90ff14c5c171", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=a6a7dac5cf929b04deac235e511073b2e9640433", "patch": "@@ -207,6 +207,13 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         let var_ty = self.resolve(&var_ty, &l.span);\n         self.write_ty_to_tables(l.hir_id, var_ty);\n     }\n+\n+    fn visit_ty(&mut self, hir_ty: &'gcx hir::Ty) {\n+        intravisit::walk_ty(self, hir_ty);\n+        let ty = self.fcx.node_ty(hir_ty.hir_id);\n+        let ty = self.resolve(&ty, &hir_ty.span);\n+        self.write_ty_to_tables(hir_ty.hir_id, ty);\n+    }\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {"}, {"sha": "a36594cb6e557dec4f3ceef5d80dceb6f15027a1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a6a7dac5cf929b04deac235e511073b2e9640433", "patch": "@@ -221,6 +221,10 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     fn set_tainted_by_errors(&self) {\n         // no obvious place to track this, just let it go\n     }\n+\n+    fn record_ty(&self, _hir_id: hir::HirId, _ty: Ty<'tcx>, _span: Span) {\n+        // no place to record types from signatures?\n+    }\n }\n \n fn type_param_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "de455afbd6629d73b4cc9fa265dc43528b800d07", "filename": "src/test/compile-fail/lint-stability-deprecated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs?ref=a6a7dac5cf929b04deac235e511073b2e9640433", "patch": "@@ -107,6 +107,7 @@ mod cross_crate {\n         struct S1<T: TraitWithAssociatedTypes>(T::TypeUnstable);\n         struct S2<T: TraitWithAssociatedTypes>(T::TypeDeprecated);\n         //~^ WARN use of deprecated item\n+        //~| WARN use of deprecated item\n \n         let _ = DeprecatedStruct { //~ WARN use of deprecated item\n             i: 0 //~ WARN use of deprecated item"}, {"sha": "973d467b1122670184cbee8cf5e345b6ac899b22", "filename": "src/test/compile-fail/private-inferred-type.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs?ref=a6a7dac5cf929b04deac235e511073b2e9640433", "patch": "@@ -103,10 +103,11 @@ mod adjust {\n \n fn main() {\n     let _: m::Alias; //~ ERROR type `m::Priv` is private\n-    let _: <m::Alias as m::TraitWithAssocTy>::AssocTy; // FIXME\n+                     //~^ ERROR type `m::Priv` is private\n+    let _: <m::Alias as m::TraitWithAssocTy>::AssocTy; //~ ERROR type `m::Priv` is private\n     m::Alias {}; //~ ERROR type `m::Priv` is private\n     m::Pub { 0: m::Alias {} }; //~ ERROR type `m::Priv` is private\n-    m::Pub { 0: loop {} }; // FIXME\n+    m::Pub { 0: loop {} }; // OK, `m::Pub` is in value context, so it means Pub<_>, not Pub<Priv>\n     m::Pub::static_method; //~ ERROR type `m::Priv` is private\n     m::Pub::INHERENT_ASSOC_CONST; //~ ERROR type `m::Priv` is private\n     m::Pub(0u8).method_with_substs::<m::Alias>(); //~ ERROR type `m::Priv` is private"}, {"sha": "eb8c40a7dd5e821b0436334be6a073b900dfd1b6", "filename": "src/test/compile-fail/private-type-in-interface.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs?ref=a6a7dac5cf929b04deac235e511073b2e9640433", "patch": "@@ -31,7 +31,6 @@ fn f_ext(_: ext::Alias) {} //~ ERROR type `ext::Priv` is private\n trait Tr1 {}\n impl m::Alias {} //~ ERROR type `m::Priv` is private\n impl Tr1 for ext::Alias {} //~ ERROR type `ext::Priv` is private\n-                           //~^ ERROR type `ext::Priv` is private\n type A = <m::Alias as m::Trait>::X; //~ ERROR type `m::Priv` is private\n \n trait Tr2<T> {}"}, {"sha": "8f26777b441d4e5849befc3c6fa855f053501db0", "filename": "src/test/compile-fail/type-path-err-node-types.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Ftest%2Fcompile-fail%2Ftype-path-err-node-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a7dac5cf929b04deac235e511073b2e9640433/src%2Ftest%2Fcompile-fail%2Ftype-path-err-node-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-path-err-node-types.rs?ref=a6a7dac5cf929b04deac235e511073b2e9640433", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Type arguments of unresolved types should have their types recorded\n+\n+fn main() {\n+    let _: Nonexistent<u8, Assoc = u16>; //~ ERROR cannot find type `Nonexistent` in this scope\n+\n+    let _ = |a, b: _| -> _ { 0 };\n+}"}]}