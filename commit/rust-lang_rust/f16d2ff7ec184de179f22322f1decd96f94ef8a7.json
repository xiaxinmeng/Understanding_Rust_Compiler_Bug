{"sha": "f16d2ff7ec184de179f22322f1decd96f94ef8a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNmQyZmY3ZWMxODRkZTE3OWYyMjMyMmYxZGVjZDk2Zjk0ZWY4YTc=", "commit": {"author": {"name": "Austin Bonander", "email": "austin.bonander@gmail.com", "date": "2018-04-18T06:19:21Z"}, "committer": {"name": "Austin Bonander", "email": "austin.bonander@gmail.com", "date": "2018-04-29T23:01:41Z"}, "message": "Warn on pointless `#[derive]` in more places\n\nThis fixes the regression in #49934 and ensures that unused `#[derive]`s on statements, expressions and generic type parameters survive to trip the `unused_attributes` lint. For `#[derive]` on macro invocations it has a hardcoded warning since linting occurs after expansion. This also adds regression testing for some nodes that were already warning properly.\n\ncloses #49934", "tree": {"sha": "d0787ffb3072a91cf8bc0c567bbf099a84ef71ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0787ffb3072a91cf8bc0c567bbf099a84ef71ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f16d2ff7ec184de179f22322f1decd96f94ef8a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f16d2ff7ec184de179f22322f1decd96f94ef8a7", "html_url": "https://github.com/rust-lang/rust/commit/f16d2ff7ec184de179f22322f1decd96f94ef8a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f16d2ff7ec184de179f22322f1decd96f94ef8a7/comments", "author": {"login": "abonander", "id": 3198595, "node_id": "MDQ6VXNlcjMxOTg1OTU=", "avatar_url": "https://avatars.githubusercontent.com/u/3198595?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abonander", "html_url": "https://github.com/abonander", "followers_url": "https://api.github.com/users/abonander/followers", "following_url": "https://api.github.com/users/abonander/following{/other_user}", "gists_url": "https://api.github.com/users/abonander/gists{/gist_id}", "starred_url": "https://api.github.com/users/abonander/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abonander/subscriptions", "organizations_url": "https://api.github.com/users/abonander/orgs", "repos_url": "https://api.github.com/users/abonander/repos", "events_url": "https://api.github.com/users/abonander/events{/privacy}", "received_events_url": "https://api.github.com/users/abonander/received_events", "type": "User", "site_admin": false}, "committer": {"login": "abonander", "id": 3198595, "node_id": "MDQ6VXNlcjMxOTg1OTU=", "avatar_url": "https://avatars.githubusercontent.com/u/3198595?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abonander", "html_url": "https://github.com/abonander", "followers_url": "https://api.github.com/users/abonander/followers", "following_url": "https://api.github.com/users/abonander/following{/other_user}", "gists_url": "https://api.github.com/users/abonander/gists{/gist_id}", "starred_url": "https://api.github.com/users/abonander/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abonander/subscriptions", "organizations_url": "https://api.github.com/users/abonander/orgs", "repos_url": "https://api.github.com/users/abonander/repos", "events_url": "https://api.github.com/users/abonander/events{/privacy}", "received_events_url": "https://api.github.com/users/abonander/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b91e6a2672a6f69e404d87fa62a5900a390622cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b91e6a2672a6f69e404d87fa62a5900a390622cf", "html_url": "https://github.com/rust-lang/rust/commit/b91e6a2672a6f69e404d87fa62a5900a390622cf"}], "stats": {"total": 200, "additions": 184, "deletions": 16}, "files": [{"sha": "3823376df73e43676171fe76f277c909883688df", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f16d2ff7ec184de179f22322f1decd96f94ef8a7/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16d2ff7ec184de179f22322f1decd96f94ef8a7/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=f16d2ff7ec184de179f22322f1decd96f94ef8a7", "patch": "@@ -404,7 +404,7 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     // Intentionally visiting the expr first - the initialization expr\n     // dominates the local's definition.\n     walk_list!(visitor, visit_expr, &local.init);\n-\n+    walk_list!(visitor, visit_attribute, local.attrs.iter());\n     visitor.visit_id(local.id);\n     visitor.visit_pat(&local.pat);\n     walk_list!(visitor, visit_ty, &local.ty);\n@@ -731,6 +731,7 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n             visitor.visit_name(ty_param.span, ty_param.name);\n             walk_list!(visitor, visit_ty_param_bound, &ty_param.bounds);\n             walk_list!(visitor, visit_ty, &ty_param.default);\n+            walk_list!(visitor, visit_attribute, ty_param.attrs.iter());\n         }\n     }\n }"}, {"sha": "753ce48e478ba4d32c20e776e4648811efe5f580", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f16d2ff7ec184de179f22322f1decd96f94ef8a7/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16d2ff7ec184de179f22322f1decd96f94ef8a7/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=f16d2ff7ec184de179f22322f1decd96f94ef8a7", "patch": "@@ -206,7 +206,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n-    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>)\n+    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>, allow_derive: bool)\n                               -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n             let name = unwrap_or!(attrs[i].name(), continue);\n@@ -227,6 +227,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n         }\n \n+        if !allow_derive { return None }\n+\n         // Check for legacy derives\n         for i in 0..attrs.len() {\n             let name = unwrap_or!(attrs[i].name(), continue);"}, {"sha": "46e3e20f58eb71179315832416b8eeed2a3d3bd2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f16d2ff7ec184de179f22322f1decd96f94ef8a7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16d2ff7ec184de179f22322f1decd96f94ef8a7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f16d2ff7ec184de179f22322f1decd96f94ef8a7", "patch": "@@ -821,7 +821,7 @@ impl Stmt {\n \n     pub fn is_item(&self) -> bool {\n         match self.node {\n-            StmtKind::Local(_) => true,\n+            StmtKind::Item(_) => true,\n             _ => false,\n         }\n     }"}, {"sha": "3b76084f2fbe5cd7d8d2e22bafdab9fbcdf8f1eb", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f16d2ff7ec184de179f22322f1decd96f94ef8a7/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16d2ff7ec184de179f22322f1decd96f94ef8a7/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f16d2ff7ec184de179f22322f1decd96f94ef8a7", "patch": "@@ -118,6 +118,20 @@ impl Annotatable {\n         }\n     }\n \n+    pub fn expect_stmt(self) -> ast::Stmt {\n+        match self {\n+            Annotatable::Stmt(stmt) => stmt.into_inner(),\n+            _ => panic!(\"expected statement\"),\n+        }\n+    }\n+\n+    pub fn expect_expr(self) -> P<ast::Expr> {\n+        match self {\n+            Annotatable::Expr(expr) => expr,\n+            _ => panic!(\"expected expression\"),\n+        }\n+    }\n+\n     pub fn derive_allowed(&self) -> bool {\n         match *self {\n             Annotatable::Item(ref item) => match item.node {\n@@ -661,7 +675,9 @@ pub trait Resolver {\n \n     fn resolve_imports(&mut self);\n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n-    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n+    fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>, allow_derive: bool)\n+                              -> Option<Attribute>;\n+\n     fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n                      -> Result<Option<Lrc<SyntaxExtension>>, Determinacy>;\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n@@ -687,7 +703,8 @@ impl Resolver for DummyResolver {\n     fn add_builtin(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n \n     fn resolve_imports(&mut self) {}\n-    fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n+    fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>, _allow_derive: bool)\n+                              -> Option<Attribute> { None }\n     fn resolve_invoc(&mut self, _invoc: &mut Invocation, _scope: Mark, _force: bool)\n                      -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n         Err(Determinacy::Determined)"}, {"sha": "ddfffe06cfdc5f68e27685703e44d31b27d989c8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f16d2ff7ec184de179f22322f1decd96f94ef8a7/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16d2ff7ec184de179f22322f1decd96f94ef8a7/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f16d2ff7ec184de179f22322f1decd96f94ef8a7", "patch": "@@ -143,7 +143,7 @@ impl ExpansionKind {\n     }\n \n     fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(self, items: I) -> Expansion {\n-        let items = items.into_iter();\n+        let mut items = items.into_iter();\n         match self {\n             ExpansionKind::Items =>\n                 Expansion::Items(items.map(Annotatable::expect_item).collect()),\n@@ -153,7 +153,14 @@ impl ExpansionKind {\n                 Expansion::TraitItems(items.map(Annotatable::expect_trait_item).collect()),\n             ExpansionKind::ForeignItems =>\n                 Expansion::ForeignItems(items.map(Annotatable::expect_foreign_item).collect()),\n-            _ => unreachable!(),\n+            ExpansionKind::Stmts => Expansion::Stmts(items.map(Annotatable::expect_stmt).collect()),\n+            ExpansionKind::Expr => Expansion::Expr(\n+                items.next().expect(\"expected exactly one expression\").expect_expr()\n+            ),\n+            ExpansionKind::OptExpr =>\n+                Expansion::OptExpr(items.next().map(Annotatable::expect_expr)),\n+            ExpansionKind::Pat | ExpansionKind::Ty =>\n+                panic!(\"patterns and types aren't annotatable\"),\n         }\n     }\n }\n@@ -886,14 +893,15 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         self.collect(kind, InvocationKind::Attr { attr, traits, item })\n     }\n \n-    // If `item` is an attr invocation, remove and return the macro attribute.\n+    /// If `item` is an attr invocation, remove and return the macro attribute and derive traits.\n     fn classify_item<T>(&mut self, mut item: T) -> (Option<ast::Attribute>, Vec<Path>, T)\n         where T: HasAttrs,\n     {\n         let (mut attr, mut traits) = (None, Vec::new());\n \n         item = item.map_attrs(|mut attrs| {\n-            if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs) {\n+            if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs,\n+                                                                                     true) {\n                 attr = Some(legacy_attr_invoc);\n                 return attrs;\n             }\n@@ -908,6 +916,28 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         (attr, traits, item)\n     }\n \n+    /// Alternative of `classify_item()` that ignores `#[derive]` so invocations fallthrough\n+    /// to the unused-attributes lint (making it an error on statements and expressions\n+    /// is a breaking change)\n+    fn classify_nonitem<T: HasAttrs>(&mut self, mut item: T) -> (Option<ast::Attribute>, T) {\n+        let mut attr = None;\n+\n+        item = item.map_attrs(|mut attrs| {\n+            if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs,\n+                                                                                     false) {\n+                attr = Some(legacy_attr_invoc);\n+                return attrs;\n+            }\n+\n+            if self.cx.ecfg.proc_macro_enabled() {\n+                attr = find_attr_invoc(&mut attrs);\n+            }\n+            attrs\n+        });\n+\n+        (attr, item)\n+    }\n+\n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n@@ -918,6 +948,13 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         let features = self.cx.ecfg.features.unwrap();\n         for attr in attrs.iter() {\n             feature_gate::check_attribute(attr, self.cx.parse_sess, features);\n+\n+            // macros are expanded before any lint passes so this warning has to be hardcoded\n+            if attr.path == \"derive\" {\n+                self.cx.struct_span_warn(attr.span, \"`#[derive]` does nothing on macro invocations\")\n+                    .note(\"this may become a hard error in a future release\")\n+                    .emit();\n+            }\n         }\n     }\n \n@@ -938,15 +975,16 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         let mut expr = self.cfg.configure_expr(expr).into_inner();\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n-        let (attr, derives, expr) = self.classify_item(expr);\n+        // ignore derives so they remain unused\n+        let (attr, expr) = self.classify_nonitem(expr);\n \n-        if attr.is_some() || !derives.is_empty() {\n+        if attr.is_some() {\n             // collect the invoc regardless of whether or not attributes are permitted here\n             // expansion will eat the attribute so it won't error later\n             attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n             // ExpansionKind::Expr requires the macro to emit an expression\n-            return self.collect_attr(attr, derives, Annotatable::Expr(P(expr)), ExpansionKind::Expr)\n+            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)), ExpansionKind::Expr)\n                 .make_expr();\n         }\n \n@@ -962,12 +1000,13 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         let mut expr = configure!(self, expr).into_inner();\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n-        let (attr, derives, expr) = self.classify_item(expr);\n+        // ignore derives so they remain unused\n+        let (attr, expr) = self.classify_nonitem(expr);\n \n-        if attr.is_some() || !derives.is_empty() {\n+        if attr.is_some() {\n             attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n-            return self.collect_attr(attr, derives, Annotatable::Expr(P(expr)),\n+            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n                                      ExpansionKind::OptExpr)\n                 .make_opt_expr();\n         }\n@@ -1001,7 +1040,14 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n         // we'll expand attributes on expressions separately\n         if !stmt.is_expr() {\n-            let (attr, derives, stmt_) = self.classify_item(stmt);\n+            let (attr, derives, stmt_) = if stmt.is_item() {\n+                self.classify_item(stmt)\n+            } else {\n+                // ignore derives on non-item statements so it falls through\n+                // to the unused-attributes lint\n+                let (attr, stmt) = self.classify_nonitem(stmt);\n+                (attr, vec![], stmt)\n+            };\n \n             if attr.is_some() || !derives.is_empty() {\n                 return self.collect_attr(attr, derives,"}, {"sha": "3e30e7a6450fc86dfa1d381779f8cb974cb757f2", "filename": "src/test/ui/issue-49934.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f16d2ff7ec184de179f22322f1decd96f94ef8a7/src%2Ftest%2Fui%2Fissue-49934.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f16d2ff7ec184de179f22322f1decd96f94ef8a7/src%2Ftest%2Fui%2Fissue-49934.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49934.rs?ref=f16d2ff7ec184de179f22322f1decd96f94ef8a7", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![feature(stmt_expr_attributes)]\n+#![warn(unused_attributes)] //~ NOTE lint level defined here\n+\n+fn foo<#[derive(Debug)] T>() { //~ WARN unused attribute\n+    match 0 {\n+        #[derive(Debug)] //~ WARN unused attribute\n+        _ => (),\n+    }\n+}\n+\n+fn main() {\n+    // fold_stmt (Item)\n+    #[allow(dead_code)]\n+    #[derive(Debug)] // should not warn\n+    struct Foo;\n+\n+    // fold_stmt (Mac)\n+    #[derive(Debug)]\n+    //~^ WARN `#[derive]` does nothing on macro invocations\n+    //~| NOTE this may become a hard error in a future release\n+    println!(\"Hello, world!\");\n+\n+    // fold_stmt (Semi)\n+    #[derive(Debug)] //~ WARN unused attribute\n+    \"Hello, world!\";\n+\n+    // fold_stmt (Local)\n+    #[derive(Debug)] //~ WARN unused attribute\n+    let _ = \"Hello, world!\";\n+\n+    // fold_expr\n+    let _ = #[derive(Debug)] \"Hello, world!\";\n+    //~^ WARN unused attribute\n+\n+    let _ = [\n+        // fold_opt_expr\n+        #[derive(Debug)] //~ WARN unused attribute\n+        \"Hello, world!\"\n+    ];\n+}"}, {"sha": "298230b8b29f74a29ff2a4a335dc64f1e74fc0fd", "filename": "src/test/ui/issue-49934.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f16d2ff7ec184de179f22322f1decd96f94ef8a7/src%2Ftest%2Fui%2Fissue-49934.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f16d2ff7ec184de179f22322f1decd96f94ef8a7/src%2Ftest%2Fui%2Fissue-49934.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49934.stderr?ref=f16d2ff7ec184de179f22322f1decd96f94ef8a7", "patch": "@@ -0,0 +1,50 @@\n+warning: `#[derive]` does nothing on macro invocations\n+  --> $DIR/issue-49934.rs:30:5\n+   |\n+LL |     #[derive(Debug)]\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+   = note: this may become a hard error in a future release\n+\n+warning: unused attribute\n+  --> $DIR/issue-49934.rs:16:8\n+   |\n+LL | fn foo<#[derive(Debug)] T>() { //~ WARN unused attribute\n+   |        ^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-49934.rs:14:9\n+   |\n+LL | #![warn(unused_attributes)] //~ NOTE lint level defined here\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+warning: unused attribute\n+  --> $DIR/issue-49934.rs:18:9\n+   |\n+LL |         #[derive(Debug)] //~ WARN unused attribute\n+   |         ^^^^^^^^^^^^^^^^\n+\n+warning: unused attribute\n+  --> $DIR/issue-49934.rs:36:5\n+   |\n+LL |     #[derive(Debug)] //~ WARN unused attribute\n+   |     ^^^^^^^^^^^^^^^^\n+\n+warning: unused attribute\n+  --> $DIR/issue-49934.rs:40:5\n+   |\n+LL |     #[derive(Debug)] //~ WARN unused attribute\n+   |     ^^^^^^^^^^^^^^^^\n+\n+warning: unused attribute\n+  --> $DIR/issue-49934.rs:44:13\n+   |\n+LL |     let _ = #[derive(Debug)] \"Hello, world!\";\n+   |             ^^^^^^^^^^^^^^^^\n+\n+warning: unused attribute\n+  --> $DIR/issue-49934.rs:49:9\n+   |\n+LL |         #[derive(Debug)] //~ WARN unused attribute\n+   |         ^^^^^^^^^^^^^^^^\n+"}]}