{"sha": "0599b6b931816ab46ab79072189075f543931cbd", "node_id": "C_kwDOAAsO6NoAKDA1OTliNmI5MzE4MTZhYjQ2YWI3OTA3MjE4OTA3NWY1NDM5MzFjYmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-01T20:11:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-01T20:11:49Z"}, "message": "Auto merge of #109483 - joboet:optimize_lazycell, r=Mark-Simulacrum\n\nOptimize `LazyCell` size\n\n`LazyCell` can only store either the initializing function or the data it produces, so it does not need to reserve the space for both. Similar to #107329, but uses an `enum` instead of a `union`.", "tree": {"sha": "ef6413c8146d078c66db16ea8fc40959aea978cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef6413c8146d078c66db16ea8fc40959aea978cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0599b6b931816ab46ab79072189075f543931cbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0599b6b931816ab46ab79072189075f543931cbd", "html_url": "https://github.com/rust-lang/rust/commit/0599b6b931816ab46ab79072189075f543931cbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0599b6b931816ab46ab79072189075f543931cbd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0196c2bd274dd5bb01c77b5a9b1da9623571b0f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0196c2bd274dd5bb01c77b5a9b1da9623571b0f8", "html_url": "https://github.com/rust-lang/rust/commit/0196c2bd274dd5bb01c77b5a9b1da9623571b0f8"}, {"sha": "af080bf04be2a82273c646d807d8411518089199", "url": "https://api.github.com/repos/rust-lang/rust/commits/af080bf04be2a82273c646d807d8411518089199", "html_url": "https://github.com/rust-lang/rust/commit/af080bf04be2a82273c646d807d8411518089199"}], "stats": {"total": 88, "additions": 77, "deletions": 11}, "files": [{"sha": "44adcfa1a9463d9c0d223c43753dc7c15052bf5b", "filename": "library/core/src/cell/lazy.rs", "status": "modified", "additions": 77, "deletions": 11, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0599b6b931816ab46ab79072189075f543931cbd/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0599b6b931816ab46ab79072189075f543931cbd/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs?ref=0599b6b931816ab46ab79072189075f543931cbd", "patch": "@@ -1,6 +1,13 @@\n-use crate::cell::{Cell, OnceCell};\n-use crate::fmt;\n use crate::ops::Deref;\n+use crate::{fmt, mem};\n+\n+use super::UnsafeCell;\n+\n+enum State<T, F> {\n+    Uninit(F),\n+    Init(T),\n+    Poisoned,\n+}\n \n /// A value which is initialized on the first access.\n ///\n@@ -31,8 +38,7 @@ use crate::ops::Deref;\n /// ```\n #[unstable(feature = \"lazy_cell\", issue = \"109736\")]\n pub struct LazyCell<T, F = fn() -> T> {\n-    cell: OnceCell<T>,\n-    init: Cell<Option<F>>,\n+    state: UnsafeCell<State<T, F>>,\n }\n \n impl<T, F: FnOnce() -> T> LazyCell<T, F> {\n@@ -53,8 +59,8 @@ impl<T, F: FnOnce() -> T> LazyCell<T, F> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"lazy_cell\", issue = \"109736\")]\n-    pub const fn new(init: F) -> LazyCell<T, F> {\n-        LazyCell { cell: OnceCell::new(), init: Cell::new(Some(init)) }\n+    pub const fn new(f: F) -> LazyCell<T, F> {\n+        LazyCell { state: UnsafeCell::new(State::Uninit(f)) }\n     }\n \n     /// Forces the evaluation of this lazy value and returns a reference to\n@@ -77,10 +83,65 @@ impl<T, F: FnOnce() -> T> LazyCell<T, F> {\n     #[inline]\n     #[unstable(feature = \"lazy_cell\", issue = \"109736\")]\n     pub fn force(this: &LazyCell<T, F>) -> &T {\n-        this.cell.get_or_init(|| match this.init.take() {\n-            Some(f) => f(),\n-            None => panic!(\"`Lazy` instance has previously been poisoned\"),\n-        })\n+        // SAFETY:\n+        // This invalidates any mutable references to the data. The resulting\n+        // reference lives either until the end of the borrow of `this` (in the\n+        // initialized case) or is invalidated in `really_init` (in the\n+        // uninitialized case; `really_init` will create and return a fresh reference).\n+        let state = unsafe { &*this.state.get() };\n+        match state {\n+            State::Init(data) => data,\n+            // SAFETY: The state is uninitialized.\n+            State::Uninit(_) => unsafe { LazyCell::really_init(this) },\n+            State::Poisoned => panic!(\"LazyCell has previously been poisoned\"),\n+        }\n+    }\n+\n+    /// # Safety\n+    /// May only be called when the state is `Uninit`.\n+    #[cold]\n+    unsafe fn really_init(this: &LazyCell<T, F>) -> &T {\n+        // SAFETY:\n+        // This function is only called when the state is uninitialized,\n+        // so no references to `state` can exist except for the reference\n+        // in `force`, which is invalidated here and not accessed again.\n+        let state = unsafe { &mut *this.state.get() };\n+        // Temporarily mark the state as poisoned. This prevents reentrant\n+        // accesses and correctly poisons the cell if the closure panicked.\n+        let State::Uninit(f) = mem::replace(state, State::Poisoned) else { unreachable!() };\n+\n+        let data = f();\n+\n+        // SAFETY:\n+        // If the closure accessed the cell through something like a reentrant\n+        // mutex, but caught the panic resulting from the state being poisoned,\n+        // the mutable borrow for `state` will be invalidated, so we need to\n+        // go through the `UnsafeCell` pointer here. The state can only be\n+        // poisoned at this point, so using `write` to skip the destructor\n+        // of `State` should help the optimizer.\n+        unsafe { this.state.get().write(State::Init(data)) };\n+\n+        // SAFETY:\n+        // The previous references were invalidated by the `write` call above,\n+        // so do a new shared borrow of the state instead.\n+        let state = unsafe { &*this.state.get() };\n+        let State::Init(data) = state else { unreachable!() };\n+        data\n+    }\n+}\n+\n+impl<T, F> LazyCell<T, F> {\n+    #[inline]\n+    fn get(&self) -> Option<&T> {\n+        // SAFETY:\n+        // This is sound for the same reason as in `force`: once the state is\n+        // initialized, it will not be mutably accessed again, so this reference\n+        // will stay valid for the duration of the borrow to `self`.\n+        let state = unsafe { &*self.state.get() };\n+        match state {\n+            State::Init(data) => Some(data),\n+            _ => None,\n+        }\n     }\n }\n \n@@ -105,6 +166,11 @@ impl<T: Default> Default for LazyCell<T> {\n #[unstable(feature = \"lazy_cell\", issue = \"109736\")]\n impl<T: fmt::Debug, F> fmt::Debug for LazyCell<T, F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n+        let mut d = f.debug_tuple(\"LazyCell\");\n+        match self.get() {\n+            Some(data) => d.field(data),\n+            None => d.field(&format_args!(\"<uninit>\")),\n+        };\n+        d.finish()\n     }\n }"}]}