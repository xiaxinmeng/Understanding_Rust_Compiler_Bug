{"sha": "62c83bb17be9a47799d702a9470aa7a84012c782", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYzgzYmIxN2JlOWE0Nzc5OWQ3MDJhOTQ3MGFhN2E4NDAxMmM3ODI=", "commit": {"author": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-07-05T12:33:52Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-07-07T10:51:09Z"}, "message": "De-manage Lifetime", "tree": {"sha": "e3abca4816806c45787d44c209b144fa068b58b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3abca4816806c45787d44c209b144fa068b58b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62c83bb17be9a47799d702a9470aa7a84012c782", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62c83bb17be9a47799d702a9470aa7a84012c782", "html_url": "https://github.com/rust-lang/rust/commit/62c83bb17be9a47799d702a9470aa7a84012c782", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62c83bb17be9a47799d702a9470aa7a84012c782/comments", "author": null, "committer": null, "parents": [{"sha": "cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45", "html_url": "https://github.com/rust-lang/rust/commit/cd1b6c897911c91167c5a3c5e3c2fa0d9334ad45"}], "stats": {"total": 123, "additions": 61, "deletions": 62}, "files": [{"sha": "a5b64ea426841db1680062403e9445caf0040d4e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=62c83bb17be9a47799d702a9470aa7a84012c782", "patch": "@@ -651,18 +651,18 @@ impl DetermineRpCtxt {\n     // with &self type, &self is also bound.  We detect those last two\n     // cases via flags (anon_implies_rp and self_implies_rp) that are\n     // true when the anon or self region implies RP.\n-    pub fn region_is_relevant(&self, r: Option<@ast::Lifetime>) -> bool {\n+    pub fn region_is_relevant(&self, r: &Option<ast::Lifetime>) -> bool {\n         match r {\n-            None => {\n+            &None => {\n                 self.anon_implies_rp\n             }\n-            Some(ref l) if l.ident == special_idents::statik => {\n+            &Some(ref l) if l.ident == special_idents::statik => {\n                 false\n             }\n-            Some(ref l) if l.ident == special_idents::self_ => {\n+            &Some(ref l) if l.ident == special_idents::self_ => {\n                 true\n             }\n-            Some(_) => {\n+            &Some(_) => {\n                 false\n             }\n         }\n@@ -747,7 +747,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n     // locations)\n     let sess = cx.sess;\n     match ty.node {\n-        ast::ty_rptr(r, _) => {\n+        ast::ty_rptr(ref r, _) => {\n             debug!(\"referenced rptr type %s\",\n                    pprust::ty_to_str(ty, sess.intr()));\n \n@@ -762,7 +762,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n                    pprust::ty_to_str(ty, sess.intr()));\n             match f.region {\n                 Some(_) => {\n-                    if cx.region_is_relevant(f.region) {\n+                    if cx.region_is_relevant(&f.region) {\n                         let rv = cx.add_variance(rv_contravariant);\n                         cx.add_rp(cx.item_id, rv)\n                     }\n@@ -790,7 +790,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n           Some(&ast::def_trait(did)) |\n           Some(&ast::def_struct(did)) => {\n             if did.crate == ast::local_crate {\n-                if cx.region_is_relevant(path.rp) {\n+                if cx.region_is_relevant(&path.rp) {\n                     cx.add_dep(did.node);\n                 }\n             } else {\n@@ -800,7 +800,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n                   Some(variance) => {\n                     debug!(\"reference to external, rp'd type %s\",\n                            pprust::ty_to_str(ty, sess.intr()));\n-                    if cx.region_is_relevant(path.rp) {\n+                    if cx.region_is_relevant(&path.rp) {\n                         let rv = cx.add_variance(variance);\n                         cx.add_rp(cx.item_id, rv)\n                     }"}, {"sha": "b391180bbcdbdb562cd6b04472d641011116e605", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=62c83bb17be9a47799d702a9470aa7a84012c782", "patch": "@@ -85,15 +85,15 @@ pub trait AstConv {\n pub fn get_region_reporting_err(\n     tcx: ty::ctxt,\n     span: span,\n-    a_r: Option<@ast::Lifetime>,\n+    a_r: &Option<ast::Lifetime>,\n     res: Result<ty::Region, RegionError>) -> ty::Region\n {\n     match res {\n         result::Ok(r) => r,\n         result::Err(ref e) => {\n             let descr = match a_r {\n-                None => ~\"anonymous lifetime\",\n-                Some(a) => fmt!(\"lifetime %s\",\n+                &None => ~\"anonymous lifetime\",\n+                &Some(ref a) => fmt!(\"lifetime %s\",\n                                 lifetime_to_str(a, tcx.sess.intr()))\n             };\n             tcx.sess.span_err(\n@@ -109,19 +109,19 @@ pub fn ast_region_to_region<AC:AstConv,RS:region_scope + Copy + 'static>(\n     this: &AC,\n     rscope: &RS,\n     default_span: span,\n-    opt_lifetime: Option<@ast::Lifetime>) -> ty::Region\n+    opt_lifetime: &Option<ast::Lifetime>) -> ty::Region\n {\n     let (span, res) = match opt_lifetime {\n-        None => {\n+        &None => {\n             (default_span, rscope.anon_region(default_span))\n         }\n-        Some(ref lifetime) if lifetime.ident == special_idents::statik => {\n+        &Some(ref lifetime) if lifetime.ident == special_idents::statik => {\n             (lifetime.span, Ok(ty::re_static))\n         }\n-        Some(ref lifetime) if lifetime.ident == special_idents::self_ => {\n+        &Some(ref lifetime) if lifetime.ident == special_idents::self_ => {\n             (lifetime.span, rscope.self_region(lifetime.span))\n         }\n-        Some(ref lifetime) => {\n+        &Some(ref lifetime) => {\n             (lifetime.span, rscope.named_region(lifetime.span,\n                                                 lifetime.ident))\n         }\n@@ -164,11 +164,11 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + 'static>(\n       }\n       (&Some(_), &None) => {\n         let res = rscope.anon_region(path.span);\n-        let r = get_region_reporting_err(this.tcx(), path.span, None, res);\n+        let r = get_region_reporting_err(this.tcx(), path.span, &None, res);\n         Some(r)\n       }\n       (&Some(_), &Some(_)) => {\n-        Some(ast_region_to_region(this, rscope, path.span, path.rp))\n+        Some(ast_region_to_region(this, rscope, path.span, &path.rp))\n       }\n     };\n \n@@ -371,7 +371,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n       ast::ty_ptr(ref mt) => {\n         ty::mk_ptr(tcx, ast_mt_to_mt(this, rscope, mt))\n       }\n-      ast::ty_rptr(region, ref mt) => {\n+      ast::ty_rptr(ref region, ref mt) => {\n         let r = ast_region_to_region(this, rscope, ast_ty.span, region);\n         mk_pointer(this, rscope, mt, ty::vstore_slice(r),\n                    |tmt| ty::mk_rptr(tcx, r, tmt))\n@@ -398,7 +398,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                                       f.purity,\n                                       f.onceness,\n                                       bounds,\n-                                      f.region,\n+                                      &f.region,\n                                       &f.decl,\n                                       None,\n                                       &f.lifetimes,\n@@ -647,7 +647,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n             ast::sty_value => {\n                 Some(self_info.untransformed_self_ty)\n             }\n-            ast::sty_region(lifetime, mutability) => {\n+            ast::sty_region(ref lifetime, mutability) => {\n                 let region =\n                     ast_region_to_region(this, rscope,\n                                          self_info.explicit_self.span,\n@@ -677,7 +677,7 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n     purity: ast::purity,\n     onceness: ast::Onceness,\n     bounds: ty::BuiltinBounds,\n-    opt_lifetime: Option<@ast::Lifetime>,\n+    opt_lifetime: &Option<ast::Lifetime>,\n     decl: &ast::fn_decl,\n     expected_sig: Option<ty::FnSig>,\n     lifetimes: &OptVec<ast::Lifetime>,\n@@ -695,10 +695,10 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n     // resolve the function bound region in the original region\n     // scope `rscope`, not the scope of the function parameters\n     let bound_region = match opt_lifetime {\n-        Some(_) => {\n+        &Some(_) => {\n             ast_region_to_region(this, rscope, span, opt_lifetime)\n         }\n-        None => {\n+        &None => {\n             match sigil {\n                 ast::OwnedSigil | ast::ManagedSigil => {\n                     // @fn(), ~fn() default to static as the bound"}, {"sha": "cd66c765a2d6ca8670e397afe91834eeebacc863", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=62c83bb17be9a47799d702a9470aa7a84012c782", "patch": "@@ -1738,7 +1738,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                            purity,\n                                            expected_onceness,\n                                            expected_bounds,\n-                                           None,\n+                                           &None,\n                                            decl,\n                                            expected_sig,\n                                            &opt_vec::Empty,\n@@ -3310,7 +3310,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n             None\n           }\n           Some(_) => { // ...and the type is lifetime parameterized, ok.\n-            Some(ast_region_to_region(fcx, fcx, span, pth.rp))\n+            Some(ast_region_to_region(fcx, fcx, span, &pth.rp))\n           }\n         }\n       }"}, {"sha": "9c3111a6918363113ec07aeec0d5ff844bfa160d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=62c83bb17be9a47799d702a9470aa7a84012c782", "patch": "@@ -109,7 +109,7 @@ pub struct Path {\n     span: span,\n     global: bool,\n     idents: ~[ident],\n-    rp: Option<@Lifetime>,\n+    rp: Option<Lifetime>,\n     types: ~[@Ty],\n }\n \n@@ -296,7 +296,7 @@ pub enum vstore {\n     vstore_fixed(Option<uint>),     // [1,2,3,4]\n     vstore_uniq,                    // ~[1,2,3,4]\n     vstore_box,                     // @[1,2,3,4]\n-    vstore_slice(Option<@Lifetime>) // &'foo? [1,2,3,4]\n+    vstore_slice(Option<Lifetime>) // &'foo? [1,2,3,4]\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n@@ -701,7 +701,7 @@ impl ToStr for Onceness {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct TyClosure {\n     sigil: Sigil,\n-    region: Option<@Lifetime>,\n+    region: Option<Lifetime>,\n     lifetimes: OptVec<Lifetime>,\n     purity: purity,\n     onceness: Onceness,\n@@ -730,7 +730,7 @@ pub enum ty_ {\n     ty_vec(mt),\n     ty_fixed_length_vec(mt, @expr),\n     ty_ptr(mt),\n-    ty_rptr(Option<@Lifetime>, mt),\n+    ty_rptr(Option<Lifetime>, mt),\n     ty_closure(@TyClosure),\n     ty_bare_fn(@TyBareFn),\n     ty_tup(~[@Ty]),\n@@ -803,7 +803,7 @@ pub enum ret_style {\n pub enum explicit_self_ {\n     sty_static,                                // no self\n     sty_value,                                 // `self`\n-    sty_region(Option<@Lifetime>, mutability), // `&'lt self`\n+    sty_region(Option<Lifetime>, mutability), // `&'lt self`\n     sty_box(mutability),                       // `@self`\n     sty_uniq                                   // `~self`\n }"}, {"sha": "14ecc26a1c2b1f0e1486e9c004b02a375cb45684", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=62c83bb17be9a47799d702a9470aa7a84012c782", "patch": "@@ -38,7 +38,7 @@ pub trait AstBuilder {\n     fn path_all(&self, sp: span,\n                 global: bool,\n                 idents: ~[ast::ident],\n-                rp: Option<@ast::Lifetime>,\n+                rp: Option<ast::Lifetime>,\n                 types: ~[@ast::Ty])\n         -> ast::Path;\n \n@@ -51,7 +51,7 @@ pub trait AstBuilder {\n \n     fn ty_rptr(&self, span: span,\n                ty: @ast::Ty,\n-               lifetime: Option<@ast::Lifetime>,\n+               lifetime: Option<ast::Lifetime>,\n                mutbl: ast::mutability)\n         -> @ast::Ty;\n     fn ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty;\n@@ -238,7 +238,7 @@ impl AstBuilder for @ExtCtxt {\n     fn path_all(&self, sp: span,\n                 global: bool,\n                 idents: ~[ast::ident],\n-                rp: Option<@ast::Lifetime>,\n+                rp: Option<ast::Lifetime>,\n                 types: ~[@ast::Ty])\n         -> ast::Path {\n         ast::Path {\n@@ -281,7 +281,7 @@ impl AstBuilder for @ExtCtxt {\n     fn ty_rptr(&self,\n                span: span,\n                ty: @ast::Ty,\n-               lifetime: Option<@ast::Lifetime>,\n+               lifetime: Option<ast::Lifetime>,\n                mutbl: ast::mutability)\n         -> @ast::Ty {\n         self.ty(span,"}, {"sha": "8bd74b96afc1fa58a360ae9838bb0f987fc470bc", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=62c83bb17be9a47799d702a9470aa7a84012c782", "patch": "@@ -351,7 +351,7 @@ impl<'self> TraitDef<'self> {\n         let self_lifetime = if generics.lifetimes.is_empty() {\n             None\n         } else {\n-            Some(@*generics.lifetimes.get(0))\n+            Some(*generics.lifetimes.get(0))\n         };\n \n         // Create the type of `self`."}, {"sha": "2a60a20b872262b3ac6d5336e6dda8750c9eed69", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=62c83bb17be9a47799d702a9470aa7a84012c782", "patch": "@@ -110,9 +110,9 @@ pub fn nil_ty() -> Ty<'static> {\n     Tuple(~[])\n }\n \n-fn mk_lifetime(cx: @ExtCtxt, span: span, lt: &Option<&str>) -> Option<@ast::Lifetime> {\n+fn mk_lifetime(cx: @ExtCtxt, span: span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n     match *lt {\n-        Some(ref s) => Some(@cx.lifetime(span, cx.ident_of(*s))),\n+        Some(ref s) => Some(cx.lifetime(span, cx.ident_of(*s))),\n         None => None\n     }\n }\n@@ -171,7 +171,7 @@ impl<'self> Ty<'self> {\n                 let lifetime = if self_generics.lifetimes.is_empty() {\n                     None\n                 } else {\n-                    Some(@*self_generics.lifetimes.get(0))\n+                    Some(*self_generics.lifetimes.get(0))\n                 };\n \n                 cx.path_all(span, false, ~[self_ty], lifetime,\n@@ -251,8 +251,7 @@ pub fn get_explicit_self(cx: @ExtCtxt, span: span, self_ptr: &Option<PtrTy>)\n                     Send => ast::sty_uniq,\n                     Managed(mutbl) => ast::sty_box(mutbl),\n                     Borrowed(ref lt, mutbl) => {\n-                        let lt = lt.map(|s| @cx.lifetime(span,\n-                                                         cx.ident_of(*s)));\n+                        let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(*s)));\n                         ast::sty_region(lt, mutbl)\n                     }\n                 });"}, {"sha": "1959649a86544e5e581e8240ae6c3efa14dd3594", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=62c83bb17be9a47799d702a9470aa7a84012c782", "patch": "@@ -646,7 +646,7 @@ impl Parser {\n     // parse a ty_closure type\n     pub fn parse_ty_closure(&self,\n                             sigil: ast::Sigil,\n-                            region: Option<@ast::Lifetime>)\n+                            region: Option<ast::Lifetime>)\n                             -> ty_ {\n         /*\n \n@@ -985,7 +985,7 @@ impl Parser {\n         // @'foo fn() or @foo/fn() or @fn() are parsed directly as fn types:\n         match *self.token {\n             token::LIFETIME(*) => {\n-                let lifetime = @self.parse_lifetime();\n+                let lifetime = self.parse_lifetime();\n                 self.bump();\n                 return self.parse_ty_closure(sigil, Some(lifetime));\n             }\n@@ -994,7 +994,7 @@ impl Parser {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) &&\n                     self.token_is_closure_keyword(&self.look_ahead(2u))\n                 {\n-                    let lifetime = @self.parse_lifetime();\n+                    let lifetime = self.parse_lifetime();\n                     self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n                     return self.parse_ty_closure(sigil, Some(lifetime));\n                 } else if self.token_is_closure_keyword(&copy *self.token) {\n@@ -1263,7 +1263,7 @@ impl Parser {\n                     token::IDENT(sid, _) => {\n                         let span = copy self.span;\n                         self.bump();\n-                        Some(@ast::Lifetime {\n+                        Some(ast::Lifetime {\n                             id: self.get_id(),\n                             span: *span,\n                             ident: sid\n@@ -1288,7 +1288,7 @@ impl Parser {\n                 if v.len() == 0 {\n                     None\n                 } else if v.len() == 1 {\n-                    Some(@*v.get(0))\n+                    Some(*v.get(0))\n                 } else {\n                     self.fatal(fmt!(\"Expected at most one \\\n                                      lifetime name (for now)\"));\n@@ -1322,17 +1322,17 @@ impl Parser {\n     }\n \n     /// parses 0 or 1 lifetime\n-    pub fn parse_opt_lifetime(&self) -> Option<@ast::Lifetime> {\n+    pub fn parse_opt_lifetime(&self) -> Option<ast::Lifetime> {\n         match *self.token {\n             token::LIFETIME(*) => {\n-                Some(@self.parse_lifetime())\n+                Some(self.parse_lifetime())\n             }\n \n             // Also accept the (obsolete) syntax `foo/`\n             token::IDENT(*) => {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) {\n                     self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n-                    Some(@self.parse_lifetime())\n+                    Some(self.parse_lifetime())\n                 } else {\n                     None\n                 }\n@@ -3343,14 +3343,14 @@ impl Parser {\n             } else if (this.token_is_lifetime(&this.look_ahead(1)) &&\n                        token::is_keyword(keywords::Self, &this.look_ahead(2))) {\n                 this.bump();\n-                let lifetime = @this.parse_lifetime();\n+                let lifetime = this.parse_lifetime();\n                 this.expect_self_ident();\n                 sty_region(Some(lifetime), m_imm)\n             } else if (this.token_is_lifetime(&this.look_ahead(1)) &&\n                        this.token_is_mutability(&this.look_ahead(2)) &&\n                        token::is_keyword(keywords::Self, &this.look_ahead(3))) {\n                 this.bump();\n-                let lifetime = @this.parse_lifetime();\n+                let lifetime = this.parse_lifetime();\n                 let mutability = this.parse_mutability();\n                 this.expect_self_ident();\n                 sty_region(Some(lifetime), mutability)"}, {"sha": "d50eb8453d2f07efda57ba8d8bd7a1dc398198e8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c83bb17be9a47799d702a9470aa7a84012c782/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=62c83bb17be9a47799d702a9470aa7a84012c782", "patch": "@@ -366,9 +366,9 @@ pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n     for nmod.items.iter().advance |item| { print_foreign_item(s, *item); }\n }\n \n-pub fn print_opt_lifetime(s: @ps, lifetime: Option<@ast::Lifetime>) {\n+pub fn print_opt_lifetime(s: @ps, lifetime: &Option<ast::Lifetime>) {\n     for lifetime.iter().advance |l| {\n-        print_lifetime(s, *l);\n+        print_lifetime(s, l);\n         nbsp(s);\n     }\n }\n@@ -392,7 +392,7 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n         word(s.s, \"]\");\n       }\n       ast::ty_ptr(ref mt) => { word(s.s, \"*\"); print_mt(s, mt); }\n-      ast::ty_rptr(lifetime, ref mt) => {\n+      ast::ty_rptr(ref lifetime, ref mt) => {\n           word(s.s, \"&\");\n           print_opt_lifetime(s, lifetime);\n           print_mt(s, mt);\n@@ -408,14 +408,14 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n       ast::ty_bare_fn(f) => {\n           let generics = ast::Generics {lifetimes: copy f.lifetimes,\n                                         ty_params: opt_vec::Empty};\n-          print_ty_fn(s, Some(f.abis), None, None,\n+          print_ty_fn(s, Some(f.abis), None, &None,\n                       f.purity, ast::Many, &f.decl, None, &None,\n                       Some(&generics), None);\n       }\n       ast::ty_closure(f) => {\n           let generics = ast::Generics {lifetimes: copy f.lifetimes,\n                                         ty_params: opt_vec::Empty};\n-          print_ty_fn(s, None, Some(f.sigil), f.region,\n+          print_ty_fn(s, None, Some(f.sigil), &f.region,\n                       f.purity, f.onceness, &f.decl, None, &f.bounds,\n                       Some(&generics), None);\n       }\n@@ -804,7 +804,7 @@ pub fn print_ty_method(s: @ps, m: &ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n-    print_ty_fn(s, None, None, None, m.purity, ast::Many,\n+    print_ty_fn(s, None, None, &None, m.purity, ast::Many,\n                 &m.decl, Some(m.ident), &None, Some(&m.generics),\n                 Some(/*bad*/ copy m.explicit_self.node));\n     word(s.s, \";\");\n@@ -1021,7 +1021,7 @@ pub fn print_vstore(s: @ps, t: ast::vstore) {\n         ast::vstore_fixed(None) => word(s.s, \"_\"),\n         ast::vstore_uniq => word(s.s, \"~\"),\n         ast::vstore_box => word(s.s, \"@\"),\n-        ast::vstore_slice(r) => {\n+        ast::vstore_slice(ref r) => {\n             word(s.s, \"&\");\n             print_opt_lifetime(s, r);\n         }\n@@ -1505,7 +1505,7 @@ fn print_path_(s: @ps, path: &ast::Path, colons_before_params: bool,\n             word(s.s, \"<\");\n \n             for path.rp.iter().advance |r| {\n-                print_lifetime(s, *r);\n+                print_lifetime(s, r);\n                 if !path.types.is_empty() {\n                     word_space(s, \",\");\n                 }\n@@ -1653,7 +1653,7 @@ pub fn print_explicit_self(s: @ps, explicit_self: ast::explicit_self_) -> bool {\n         ast::sty_static => { return false; }\n         ast::sty_value => { word(s.s, \"self\"); }\n         ast::sty_uniq => { word(s.s, \"~self\"); }\n-        ast::sty_region(lt, m) => {\n+        ast::sty_region(ref lt, m) => {\n             word(s.s, \"&\");\n             print_opt_lifetime(s, lt);\n             print_mutability(s, m);\n@@ -1912,7 +1912,7 @@ pub fn print_arg(s: @ps, input: ast::arg) {\n pub fn print_ty_fn(s: @ps,\n                    opt_abis: Option<AbiSet>,\n                    opt_sigil: Option<ast::Sigil>,\n-                   opt_region: Option<@ast::Lifetime>,\n+                   opt_region: &Option<ast::Lifetime>,\n                    purity: ast::purity,\n                    onceness: ast::Onceness,\n                    decl: &ast::fn_decl,"}]}