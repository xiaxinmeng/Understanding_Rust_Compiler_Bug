{"sha": "6badf705b380bf8a66c5a1d8349365cab7a8ed4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYWRmNzA1YjM4MGJmOGE2NmM1YTFkODM0OTM2NWNhYjdhOGVkNGQ=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-12-04T20:55:36Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-12-07T21:41:08Z"}, "message": "Check lsp completions' edits for disjointness", "tree": {"sha": "440cbd68556dc2d84b817b38e3a5f6850b30b087", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/440cbd68556dc2d84b817b38e3a5f6850b30b087"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6badf705b380bf8a66c5a1d8349365cab7a8ed4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6badf705b380bf8a66c5a1d8349365cab7a8ed4d", "html_url": "https://github.com/rust-lang/rust/commit/6badf705b380bf8a66c5a1d8349365cab7a8ed4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6badf705b380bf8a66c5a1d8349365cab7a8ed4d/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "077c1c3c1f16b5387c9e20cfa087c517dac3f4c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/077c1c3c1f16b5387c9e20cfa087c517dac3f4c8", "html_url": "https://github.com/rust-lang/rust/commit/077c1c3c1f16b5387c9e20cfa087c517dac3f4c8"}], "stats": {"total": 177, "additions": 176, "deletions": 1}, "files": [{"sha": "d6865e1d61c1711e4a64bb7b770837c9ef92eace", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6badf705b380bf8a66c5a1d8349365cab7a8ed4d/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6badf705b380bf8a66c5a1d8349365cab7a8ed4d/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=6badf705b380bf8a66c5a1d8349365cab7a8ed4d", "patch": "@@ -36,6 +36,7 @@ use crate::{\n     from_json, from_proto,\n     global_state::{GlobalState, GlobalStateSnapshot},\n     lsp_ext::{self, InlayHint, InlayHintsParams},\n+    lsp_utils::all_edits_are_disjoint,\n     to_proto, LspError, Result,\n };\n \n@@ -601,6 +602,14 @@ pub(crate) fn handle_completion_resolve(\n ) -> Result<CompletionItem> {\n     let _p = profile::span(\"handle_resolve_completion\");\n \n+    if !all_edits_are_disjoint(&original_completion, &[]) {\n+        return Err(LspError::new(\n+            ErrorCode::InvalidParams as i32,\n+            \"Received a completion with disjoint edits\".into(),\n+        )\n+        .into());\n+    }\n+\n     // FIXME resolve the other capabilities also?\n     if !snap\n         .config\n@@ -640,6 +649,14 @@ pub(crate) fn handle_completion_resolve(\n         })\n         .collect_vec();\n \n+    if !all_edits_are_disjoint(&original_completion, &additional_edits) {\n+        return Err(LspError::new(\n+            ErrorCode::InternalError as i32,\n+            \"Import edit is not disjoint with the original completion edits\".into(),\n+        )\n+        .into());\n+    }\n+\n     if let Some(original_additional_edits) = original_completion.additional_text_edits.as_mut() {\n         original_additional_edits.extend(additional_edits.drain(..))\n     } else {"}, {"sha": "d5c1c1ad0fd38f8ebdc8975911eb236da4a2311c", "filename": "crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 159, "deletions": 1, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/6badf705b380bf8a66c5a1d8349365cab7a8ed4d/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6badf705b380bf8a66c5a1d8349365cab7a8ed4d/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=6badf705b380bf8a66c5a1d8349365cab7a8ed4d", "patch": "@@ -129,9 +129,36 @@ pub(crate) fn apply_document_changes(\n     }\n }\n \n+/// Checks that the edits inside the completion and the additional edits are disjoint.\n+pub(crate) fn all_edits_are_disjoint(\n+    completion: &lsp_types::CompletionItem,\n+    additional_edits: &[lsp_types::TextEdit],\n+) -> bool {\n+    let mut edit_ranges = Vec::new();\n+    match completion.text_edit.as_ref() {\n+        Some(lsp_types::CompletionTextEdit::Edit(edit)) => {\n+            edit_ranges.push(edit.range);\n+        }\n+        Some(lsp_types::CompletionTextEdit::InsertAndReplace(edit)) => {\n+            edit_ranges.push(edit.insert);\n+            edit_ranges.push(edit.replace);\n+        }\n+        None => {}\n+    }\n+    if let Some(additional_changes) = completion.additional_text_edits.as_ref() {\n+        edit_ranges.extend(additional_changes.iter().map(|edit| edit.range));\n+    };\n+    edit_ranges.extend(additional_edits.iter().map(|edit| edit.range));\n+    edit_ranges.sort_by_key(|range| (range.start, range.end));\n+    edit_ranges.iter().zip(edit_ranges.iter().skip(1)).all(|(l, r)| l.end <= r.start)\n+}\n+\n #[cfg(test)]\n mod tests {\n-    use lsp_types::{Position, Range, TextDocumentContentChangeEvent};\n+    use lsp_types::{\n+        CompletionItem, CompletionTextEdit, InsertReplaceEdit, Position, Range,\n+        TextDocumentContentChangeEvent,\n+    };\n \n     use super::*;\n \n@@ -197,4 +224,135 @@ mod tests {\n         apply_document_changes(&mut text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n         assert_eq!(text, \"a\u021bc\\ncb\");\n     }\n+\n+    #[test]\n+    fn empty_completion_disjoint_tests() {\n+        let empty_completion =\n+            CompletionItem::new_simple(\"label\".to_string(), \"detail\".to_string());\n+\n+        let disjoint_edit_1 = lsp_types::TextEdit::new(\n+            Range::new(Position::new(2, 2), Position::new(3, 3)),\n+            \"new_text\".to_string(),\n+        );\n+        let disjoint_edit_2 = lsp_types::TextEdit::new(\n+            Range::new(Position::new(3, 3), Position::new(4, 4)),\n+            \"new_text\".to_string(),\n+        );\n+\n+        let joint_edit = lsp_types::TextEdit::new(\n+            Range::new(Position::new(1, 1), Position::new(5, 5)),\n+            \"new_text\".to_string(),\n+        );\n+\n+        assert!(\n+            all_edits_are_disjoint(&empty_completion, &[]),\n+            \"Empty completion has all its edits disjoint\"\n+        );\n+        assert!(\n+            all_edits_are_disjoint(\n+                &empty_completion,\n+                &[disjoint_edit_1.clone(), disjoint_edit_2.clone()]\n+            ),\n+            \"Empty completion is disjoint to whatever disjoint extra edits added\"\n+        );\n+\n+        assert!(\n+            !all_edits_are_disjoint(\n+                &empty_completion,\n+                &[disjoint_edit_1, disjoint_edit_2, joint_edit]\n+            ),\n+            \"Empty completion does not prevent joint extra edits from failing the validation\"\n+        );\n+    }\n+\n+    #[test]\n+    fn completion_with_joint_edits_disjoint_tests() {\n+        let disjoint_edit = lsp_types::TextEdit::new(\n+            Range::new(Position::new(1, 1), Position::new(2, 2)),\n+            \"new_text\".to_string(),\n+        );\n+        let disjoint_edit_2 = lsp_types::TextEdit::new(\n+            Range::new(Position::new(2, 2), Position::new(3, 3)),\n+            \"new_text\".to_string(),\n+        );\n+        let joint_edit = lsp_types::TextEdit::new(\n+            Range::new(Position::new(1, 1), Position::new(5, 5)),\n+            \"new_text\".to_string(),\n+        );\n+\n+        let mut completion_with_joint_edits =\n+            CompletionItem::new_simple(\"label\".to_string(), \"detail\".to_string());\n+        completion_with_joint_edits.additional_text_edits =\n+            Some(vec![disjoint_edit.clone(), joint_edit.clone()]);\n+        assert!(\n+            !all_edits_are_disjoint(&completion_with_joint_edits, &[]),\n+            \"Completion with disjoint edits fails the validaton even with empty extra edits\"\n+        );\n+\n+        completion_with_joint_edits.text_edit =\n+            Some(CompletionTextEdit::Edit(disjoint_edit.clone()));\n+        completion_with_joint_edits.additional_text_edits = Some(vec![joint_edit.clone()]);\n+        assert!(\n+            !all_edits_are_disjoint(&completion_with_joint_edits, &[]),\n+            \"Completion with disjoint edits fails the validaton even with empty extra edits\"\n+        );\n+\n+        completion_with_joint_edits.text_edit =\n+            Some(CompletionTextEdit::InsertAndReplace(InsertReplaceEdit {\n+                new_text: \"new_text\".to_string(),\n+                insert: disjoint_edit.range,\n+                replace: joint_edit.range,\n+            }));\n+        completion_with_joint_edits.additional_text_edits = None;\n+        assert!(\n+            !all_edits_are_disjoint(&completion_with_joint_edits, &[]),\n+            \"Completion with disjoint edits fails the validaton even with empty extra edits\"\n+        );\n+\n+        completion_with_joint_edits.text_edit =\n+            Some(CompletionTextEdit::InsertAndReplace(InsertReplaceEdit {\n+                new_text: \"new_text\".to_string(),\n+                insert: disjoint_edit.range,\n+                replace: disjoint_edit_2.range,\n+            }));\n+        completion_with_joint_edits.additional_text_edits = Some(vec![joint_edit]);\n+        assert!(\n+            !all_edits_are_disjoint(&completion_with_joint_edits, &[]),\n+            \"Completion with disjoint edits fails the validaton even with empty extra edits\"\n+        );\n+    }\n+\n+    #[test]\n+    fn completion_with_disjoint_edits_disjoint_tests() {\n+        let disjoint_edit = lsp_types::TextEdit::new(\n+            Range::new(Position::new(1, 1), Position::new(2, 2)),\n+            \"new_text\".to_string(),\n+        );\n+        let disjoint_edit_2 = lsp_types::TextEdit::new(\n+            Range::new(Position::new(2, 2), Position::new(3, 3)),\n+            \"new_text\".to_string(),\n+        );\n+        let joint_edit = lsp_types::TextEdit::new(\n+            Range::new(Position::new(1, 1), Position::new(5, 5)),\n+            \"new_text\".to_string(),\n+        );\n+\n+        let mut completion_with_disjoint_edits =\n+            CompletionItem::new_simple(\"label\".to_string(), \"detail\".to_string());\n+        completion_with_disjoint_edits.text_edit = Some(CompletionTextEdit::Edit(disjoint_edit));\n+        let completion_with_disjoint_edits = completion_with_disjoint_edits;\n+\n+        assert!(\n+            all_edits_are_disjoint(&completion_with_disjoint_edits, &[]),\n+            \"Completion with disjoint edits is valid\"\n+        );\n+        assert!(\n+            !all_edits_are_disjoint(&completion_with_disjoint_edits, &[joint_edit.clone()]),\n+            \"Completion with disjoint edits and joint extra edit is invalid\"\n+        );\n+        assert!(\n+            all_edits_are_disjoint(&completion_with_disjoint_edits, &[disjoint_edit_2.clone()]),\n+            \"Completion with disjoint edits and joint extra edit is valid\"\n+        );\n+    }\n }"}]}