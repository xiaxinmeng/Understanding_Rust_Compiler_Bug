{"sha": "bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMGM1YmI0NDdhYzhlYmEwYTgwNTk5MzA1YzIzZGI2YzhhMWVkNmE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-22T20:38:08Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-24T01:35:35Z"}, "message": "core: Stop using oldcomm", "tree": {"sha": "44609d9acd77226ccb57e861bb1dd742e8cf0c66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44609d9acd77226ccb57e861bb1dd742e8cf0c66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a", "html_url": "https://github.com/rust-lang/rust/commit/bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc9ab2c0339aa00566ee6c5d12383278c7bd7eef", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc9ab2c0339aa00566ee6c5d12383278c7bd7eef", "html_url": "https://github.com/rust-lang/rust/commit/cc9ab2c0339aa00566ee6c5d12383278c7bd7eef"}], "stats": {"total": 143, "additions": 64, "deletions": 79}, "files": [{"sha": "23268b1b778d875682ecae3d96433edcda94fcfa", "filename": "src/libcore/private.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a", "patch": "@@ -18,7 +18,6 @@\n use cast;\n use iter;\n use libc;\n-use oldcomm;\n use option;\n use pipes;\n use prelude::*;"}, {"sha": "07071e948922bc4a3f52eba6c7938ef9babf4110", "filename": "src/libcore/run.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a", "patch": "@@ -17,7 +17,7 @@ use io;\n use io::ReaderUtil;\n use libc;\n use libc::{pid_t, c_void, c_int};\n-use oldcomm;\n+use pipes::{stream, SharedChan};\n use option::{Some, None};\n use os;\n use prelude::*;\n@@ -333,22 +333,23 @@ pub fn program_output(prog: &str, args: &[~str]) ->\n         // in parallel so we don't deadlock while blocking on one\n         // or the other. FIXME (#2625): Surely there's a much more\n         // clever way to do this.\n-        let p = oldcomm::Port();\n-        let ch = oldcomm::Chan(&p);\n+        let (p, ch) = stream();\n+        let ch = SharedChan(ch);\n+        let ch_clone = ch.clone();\n         do task::spawn_sched(task::SingleThreaded) {\n             let errput = readclose(pipe_err.in);\n-            oldcomm::send(ch, (2, move errput));\n+            ch.send((2, move errput));\n         };\n         do task::spawn_sched(task::SingleThreaded) {\n             let output = readclose(pipe_out.in);\n-            oldcomm::send(ch, (1, move output));\n+            ch_clone.send((1, move output));\n         };\n         let status = run::waitpid(pid);\n         let mut errs = ~\"\";\n         let mut outs = ~\"\";\n         let mut count = 2;\n         while count > 0 {\n-            let stream = oldcomm::recv(p);\n+            let stream = p.recv();\n             match stream {\n                 (1, copy s) => {\n                     outs = move s;"}, {"sha": "315a2843af6e143608920be0024b712316c7367f", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 53, "deletions": 66, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a", "patch": "@@ -43,10 +43,9 @@ use cmp;\n use cmp::Eq;\n use iter;\n use libc;\n-use oldcomm;\n use option;\n use result::Result;\n-use pipes::{stream, Chan, Port};\n+use pipes::{stream, Chan, Port, SharedChan};\n use pipes;\n use prelude::*;\n use ptr;\n@@ -427,18 +426,17 @@ impl TaskBuilder {\n      * Fails if a future_result was already set for this task.\n      */\n     fn try<T: Owned>(f: fn~() -> T) -> Result<T,()> {\n-        let po = oldcomm::Port();\n-        let ch = oldcomm::Chan(&po);\n+        let (po, ch) = stream::<T>();\n         let mut result = None;\n \n         let fr_task_builder = self.future_result(|+r| {\n             result = Some(move r);\n         });\n-        do fr_task_builder.spawn |move f| {\n-            oldcomm::send(ch, f());\n+        do fr_task_builder.spawn |move f, move ch| {\n+            ch.send(f());\n         }\n         match option::unwrap(move result).recv() {\n-            Success => result::Ok(oldcomm::recv(po)),\n+            Success => result::Ok(po.recv()),\n             Failure => result::Err(())\n         }\n     }\n@@ -665,17 +663,18 @@ fn test_cant_dup_task_builder() {\n \n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n+    let (po, ch) = stream();\n+    let ch = SharedChan(ch);\n     do spawn_unlinked {\n+        let ch = ch.clone();\n         do spawn_unlinked {\n             // Give middle task a chance to fail-but-not-kill-us.\n             for iter::repeat(16) { task::yield(); }\n-            oldcomm::send(ch, ()); // If killed first, grandparent hangs.\n+            ch.send(()); // If killed first, grandparent hangs.\n         }\n         fail; // Shouldn't kill either (grand)parent or (grand)child.\n     }\n-    oldcomm::recv(po);\n+    po.recv();\n }\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n@@ -695,8 +694,7 @@ fn test_spawn_unlinked_sup_fail_down() {\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n-    let po = oldcomm::Port::<()>();\n-    let _ch = oldcomm::Chan(&po);\n+    let (po, _ch) = stream::<()>();\n     // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n     // We have to cheat with opts - the interface doesn't support them because\n     // they don't make sense (redundant with task().supervised()).\n@@ -714,7 +712,7 @@ fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n         .. b0\n     };\n     do b1.spawn { fail; }\n-    oldcomm::recv(po); // We should get punted awake\n+    po.recv(); // We should get punted awake\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n@@ -738,11 +736,10 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n-    let po = oldcomm::Port::<()>();\n-    let _ch = oldcomm::Chan(&po);\n+    let (po, _ch) = stream::<()>();\n     // Default options are to spawn linked & unsupervised.\n     do spawn { fail; }\n-    oldcomm::recv(po); // We should get punted awake\n+    po.recv(); // We should get punted awake\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n@@ -810,27 +807,25 @@ fn test_spawn_linked_sup_propagate_sibling() {\n \n #[test]\n fn test_run_basic() {\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n+    let (po, ch) = stream::<()>();\n     do task().spawn {\n-        oldcomm::send(ch, ());\n+        ch.send(());\n     }\n-    oldcomm::recv(po);\n+    po.recv();\n }\n \n #[test]\n fn test_add_wrapper() {\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n+    let (po, ch) = stream::<()>();\n     let b0 = task();\n     let b1 = do b0.add_wrapper |body| {\n         fn~(move body) {\n             body();\n-            oldcomm::send(ch, ());\n+            ch.send(());\n         }\n     };\n     do b1.spawn { }\n-    oldcomm::recv(po);\n+    po.recv();\n }\n \n #[test]\n@@ -883,32 +878,31 @@ fn test_spawn_sched_no_threads() {\n \n #[test]\n fn test_spawn_sched() {\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n+    let (po, ch) = stream::<()>();\n+    let ch = SharedChan(ch);\n \n-    fn f(i: int, ch: oldcomm::Chan<()>) {\n+    fn f(i: int, ch: SharedChan<()>) {\n         let parent_sched_id = rt::rust_get_sched_id();\n \n         do spawn_sched(SingleThreaded) {\n             let child_sched_id = rt::rust_get_sched_id();\n             assert parent_sched_id != child_sched_id;\n \n             if (i == 0) {\n-                oldcomm::send(ch, ());\n+                ch.send(());\n             } else {\n-                f(i - 1, ch);\n+                f(i - 1, ch.clone());\n             }\n         };\n \n     }\n     f(10, ch);\n-    oldcomm::recv(po);\n+    po.recv();\n }\n \n #[test]\n fn test_spawn_sched_childs_on_default_sched() {\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n+    let (po, ch) = stream();\n \n     // Assuming tests run on the default scheduler\n     let default_id = rt::rust_get_sched_id();\n@@ -919,11 +913,11 @@ fn test_spawn_sched_childs_on_default_sched() {\n             let child_sched_id = rt::rust_get_sched_id();\n             assert parent_sched_id != child_sched_id;\n             assert child_sched_id == default_id;\n-            oldcomm::send(ch, ());\n+            ch.send(());\n         };\n     };\n \n-    oldcomm::recv(po);\n+    po.recv();\n }\n \n #[nolink]\n@@ -945,74 +939,69 @@ fn test_spawn_sched_blocking() {\n         // without affecting other schedulers\n         for iter::repeat(20u) {\n \n-            let start_po = oldcomm::Port();\n-            let start_ch = oldcomm::Chan(&start_po);\n-            let fin_po = oldcomm::Port();\n-            let fin_ch = oldcomm::Chan(&fin_po);\n+            let (start_po, start_ch) = stream();\n+            let (fin_po, fin_ch) = stream();\n \n             let lock = testrt::rust_dbg_lock_create();\n \n             do spawn_sched(SingleThreaded) {\n                 unsafe {\n                     testrt::rust_dbg_lock_lock(lock);\n \n-                    oldcomm::send(start_ch, ());\n+                    start_ch.send(());\n \n                     // Block the scheduler thread\n                     testrt::rust_dbg_lock_wait(lock);\n                     testrt::rust_dbg_lock_unlock(lock);\n \n-                    oldcomm::send(fin_ch, ());\n+                    fin_ch.send(());\n                 }\n             };\n \n             // Wait until the other task has its lock\n-            oldcomm::recv(start_po);\n+            start_po.recv();\n \n-            fn pingpong(po: oldcomm::Port<int>, ch: oldcomm::Chan<int>) {\n+            fn pingpong(po: &Port<int>, ch: &Chan<int>) {\n                 let mut val = 20;\n                 while val > 0 {\n-                    val = oldcomm::recv(po);\n-                    oldcomm::send(ch, val - 1);\n+                    val = po.recv();\n+                    ch.send(val - 1);\n                 }\n             }\n \n-            let setup_po = oldcomm::Port();\n-            let setup_ch = oldcomm::Chan(&setup_po);\n-            let parent_po = oldcomm::Port();\n-            let parent_ch = oldcomm::Chan(&parent_po);\n+            let (setup_po, setup_ch) = stream();\n+            let (parent_po, parent_ch) = stream();\n             do spawn {\n-                let child_po = oldcomm::Port();\n-                oldcomm::send(setup_ch, oldcomm::Chan(&child_po));\n-                pingpong(child_po, parent_ch);\n+                let (child_po, child_ch) = stream();\n+                setup_ch.send(child_ch);\n+                pingpong(&child_po, &parent_ch);\n             };\n \n-            let child_ch = oldcomm::recv(setup_po);\n-            oldcomm::send(child_ch, 20);\n-            pingpong(parent_po, child_ch);\n+            let child_ch = setup_po.recv();\n+            child_ch.send(20);\n+            pingpong(&parent_po, &child_ch);\n             testrt::rust_dbg_lock_lock(lock);\n             testrt::rust_dbg_lock_signal(lock);\n             testrt::rust_dbg_lock_unlock(lock);\n-            oldcomm::recv(fin_po);\n+            fin_po.recv();\n             testrt::rust_dbg_lock_destroy(lock);\n         }\n     }\n }\n \n #[cfg(test)]\n fn avoid_copying_the_body(spawnfn: fn(v: fn~())) {\n-    let p = oldcomm::Port::<uint>();\n-    let ch = oldcomm::Chan(&p);\n+    let (p, ch) = stream::<uint>();\n \n     let x = ~1;\n     let x_in_parent = ptr::addr_of(&(*x)) as uint;\n \n     do spawnfn |move x| {\n         let x_in_child = ptr::addr_of(&(*x)) as uint;\n-        oldcomm::send(ch, x_in_child);\n+        ch.send(x_in_child);\n     }\n \n-    let x_in_child = oldcomm::recv(p);\n+    let x_in_child = p.recv();\n     assert x_in_parent == x_in_child;\n }\n \n@@ -1050,20 +1039,18 @@ fn test_avoid_copying_the_body_unlinked() {\n \n #[test]\n fn test_platform_thread() {\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n+    let (po, ch) = stream();\n     do task().sched_mode(PlatformThread).spawn {\n-        oldcomm::send(ch, ());\n+        ch.send(());\n     }\n-    oldcomm::recv(po);\n+    po.recv();\n }\n \n #[test]\n #[ignore(cfg(windows))]\n #[should_fail]\n fn test_unkillable() {\n-    let po = oldcomm::Port();\n-    let ch = po.chan();\n+    let (po, ch) = stream();\n \n     // We want to do this after failing\n     do spawn_unlinked {"}, {"sha": "a844542c214ecfc51efa6b2e6e1b532cfba0de26", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=bc0c5bb447ac8eba0a80599305c23db6c8a1ed6a", "patch": "@@ -74,9 +74,8 @@\n #[warn(deprecated_mode)];\n \n use cast;\n-use oldcomm;\n use option;\n-use pipes::{Chan, Port};\n+use pipes::{stream, Chan, Port};\n use pipes;\n use prelude::*;\n use private;\n@@ -667,12 +666,11 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n \n #[test]\n fn test_spawn_raw_simple() {\n-    let po = oldcomm::Port();\n-    let ch = oldcomm::Chan(&po);\n+    let (po, ch) = stream();\n     do spawn_raw(default_task_opts()) {\n-        oldcomm::send(ch, ());\n+        ch.send(());\n     }\n-    oldcomm::recv(po);\n+    po.recv();\n }\n \n #[test]"}]}