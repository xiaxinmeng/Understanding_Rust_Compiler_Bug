{"sha": "5171b325bd2c5600649cc98e65db0ef2e72c3f89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNzFiMzI1YmQyYzU2MDA2NDljYzk4ZTY1ZGIwZWYyZTcyYzNmODk=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-12-21T06:36:50Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2015-01-05T20:00:57Z"}, "message": "creader: Convert free functions to Env methods", "tree": {"sha": "281029ceb227f3f66a624c2a12b8d71ceec48020", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/281029ceb227f3f66a624c2a12b8d71ceec48020"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5171b325bd2c5600649cc98e65db0ef2e72c3f89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5171b325bd2c5600649cc98e65db0ef2e72c3f89", "html_url": "https://github.com/rust-lang/rust/commit/5171b325bd2c5600649cc98e65db0ef2e72c3f89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5171b325bd2c5600649cc98e65db0ef2e72c3f89/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bf385be6a5ce267ac7cd9d1725178488e33131c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bf385be6a5ce267ac7cd9d1725178488e33131c", "html_url": "https://github.com/rust-lang/rust/commit/5bf385be6a5ce267ac7cd9d1725178488e33131c"}], "stats": {"total": 531, "additions": 267, "deletions": 264}, "files": [{"sha": "7d716135efe6091b978e754c99148d9ae49f60ce", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 267, "deletions": 264, "changes": 531, "blob_url": "https://github.com/rust-lang/rust/blob/5171b325bd2c5600649cc98e65db0ef2e72c3f89/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5171b325bd2c5600649cc98e65db0ef2e72c3f89/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=5171b325bd2c5600649cc98e65db0ef2e72c3f89", "patch": "@@ -35,6 +35,7 @@ use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::visit;\n use util::fs;\n+use log;\n \n struct Env<'a> {\n     sess: &'a Session,\n@@ -49,9 +50,11 @@ pub fn read_crates(sess: &Session,\n         sess: sess,\n         next_crate_num: sess.cstore.next_crate_num(),\n     };\n-    visit_crate(&e, krate);\n+    e.visit_crate(krate);\n     visit::walk_crate(&mut e, krate);\n-    dump_crates(&sess.cstore);\n+    if log_enabled!(log::DEBUG) {\n+        dump_crates(&sess.cstore);\n+    }\n     warn_if_multiple_versions(sess.diagnostic(), &sess.cstore);\n \n     for &(ref name, kind) in sess.opts.libs.iter() {\n@@ -61,11 +64,11 @@ pub fn read_crates(sess: &Session,\n \n impl<'a, 'v> visit::Visitor<'v> for Env<'a> {\n     fn visit_view_item(&mut self, a: &ast::ViewItem) {\n-        visit_view_item(self, a);\n+        self.process_view_item(a);\n         visit::walk_view_item(self, a);\n     }\n     fn visit_item(&mut self, a: &ast::Item) {\n-        visit_item(self, a);\n+        self.process_item(a);\n         visit::walk_item(self, a);\n     }\n }\n@@ -105,15 +108,6 @@ fn warn_if_multiple_versions(diag: &SpanHandler, cstore: &CStore) {\n     }\n }\n \n-fn visit_crate(e: &Env, c: &ast::Crate) {\n-    for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n-        match a.value_str() {\n-            Some(ref linkarg) => e.sess.cstore.add_used_link_args(linkarg.get()),\n-            None => { /* fallthrough */ }\n-        }\n-    }\n-}\n-\n fn should_link(i: &ast::ViewItem) -> bool {\n     i.attrs.iter().all(|attr| {\n         attr.name().get() != \"phase\" ||\n@@ -123,59 +117,13 @@ fn should_link(i: &ast::ViewItem) -> bool {\n     })\n }\n \n-fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n-    if !should_link(i) {\n-        return;\n-    }\n-\n-    match extract_crate_info(e, i) {\n-        Some(info) => {\n-            let (cnum, _, _) = resolve_crate(e,\n-                                             &None,\n-                                             info.ident[],\n-                                             info.name[],\n-                                             None,\n-                                             i.span,\n-                                             PathKind::Crate);\n-            e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n-        }\n-        None => ()\n-    }\n-}\n-\n struct CrateInfo {\n     ident: String,\n     name: String,\n     id: ast::NodeId,\n     should_link: bool,\n }\n \n-fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n-    match i.node {\n-        ast::ViewItemExternCrate(ident, ref path_opt, id) => {\n-            let ident = token::get_ident(ident);\n-            debug!(\"resolving extern crate stmt. ident: {} path_opt: {}\",\n-                   ident, path_opt);\n-            let name = match *path_opt {\n-                Some((ref path_str, _)) => {\n-                    let name = path_str.get().to_string();\n-                    validate_crate_name(Some(e.sess), name[],\n-                                        Some(i.span));\n-                    name\n-                }\n-                None => ident.get().to_string(),\n-            };\n-            Some(CrateInfo {\n-                ident: ident.get().to_string(),\n-                name: name,\n-                id: id,\n-                should_link: should_link(i),\n-            })\n-        }\n-        _ => None\n-    }\n-}\n-\n pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     let err = |&: s: &str| {\n         match (sp, sess) {\n@@ -198,85 +146,6 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     }\n }\n \n-fn visit_item(e: &Env, i: &ast::Item) {\n-    match i.node {\n-        ast::ItemForeignMod(ref fm) => {\n-            if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n-                return;\n-            }\n-\n-            // First, add all of the custom link_args attributes\n-            let link_args = i.attrs.iter()\n-                .filter_map(|at| if at.name() == \"link_args\" {\n-                    Some(at)\n-                } else {\n-                    None\n-                })\n-                .collect::<Vec<&ast::Attribute>>();\n-            for m in link_args.iter() {\n-                match m.value_str() {\n-                    Some(linkarg) => e.sess.cstore.add_used_link_args(linkarg.get()),\n-                    None => { /* fallthrough */ }\n-                }\n-            }\n-\n-            // Next, process all of the #[link(..)]-style arguments\n-            let link_args = i.attrs.iter()\n-                .filter_map(|at| if at.name() == \"link\" {\n-                    Some(at)\n-                } else {\n-                    None\n-                })\n-                .collect::<Vec<&ast::Attribute>>();\n-            for m in link_args.iter() {\n-                match m.meta_item_list() {\n-                    Some(items) => {\n-                        let kind = items.iter().find(|k| {\n-                            k.name() == \"kind\"\n-                        }).and_then(|a| a.value_str());\n-                        let kind = match kind {\n-                            Some(k) => {\n-                                if k == \"static\" {\n-                                    cstore::NativeStatic\n-                                } else if e.sess.target.target.options.is_like_osx\n-                                          && k == \"framework\" {\n-                                    cstore::NativeFramework\n-                                } else if k == \"framework\" {\n-                                    cstore::NativeFramework\n-                                } else if k == \"dylib\" {\n-                                    cstore::NativeUnknown\n-                                } else {\n-                                    e.sess.span_err(m.span,\n-                                        format!(\"unknown kind: `{}`\",\n-                                                k)[]);\n-                                    cstore::NativeUnknown\n-                                }\n-                            }\n-                            None => cstore::NativeUnknown\n-                        };\n-                        let n = items.iter().find(|n| {\n-                            n.name() == \"name\"\n-                        }).and_then(|a| a.value_str());\n-                        let n = match n {\n-                            Some(n) => n,\n-                            None => {\n-                                e.sess.span_err(m.span,\n-                                    \"#[link(...)] specified without \\\n-                                     `name = \\\"foo\\\"`\");\n-                                InternedString::new(\"foo\")\n-                            }\n-                        };\n-                        register_native_lib(e.sess, Some(m.span),\n-                                            n.get().to_string(), kind);\n-                    }\n-                    None => {}\n-                }\n-            }\n-        }\n-        _ => { }\n-    }\n-}\n-\n fn register_native_lib(sess: &Session,\n                        span: Option<Span>,\n                        name: String,\n@@ -304,143 +173,278 @@ fn register_native_lib(sess: &Session,\n     sess.cstore.add_used_library(name, kind);\n }\n \n-fn existing_match(e: &Env, name: &str,\n-                  hash: Option<&Svh>) -> Option<ast::CrateNum> {\n-    let mut ret = None;\n-    e.sess.cstore.iter_crate_data(|cnum, data| {\n-        if data.name != name { return }\n+impl<'a> Env<'a> {\n+    fn visit_crate(&self, c: &ast::Crate) {\n+        for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n+            match a.value_str() {\n+                Some(ref linkarg) => self.sess.cstore.add_used_link_args(linkarg.get()),\n+                None => { /* fallthrough */ }\n+            }\n+        }\n+    }\n+\n+    fn process_view_item(&mut self, i: &ast::ViewItem) {\n+        if !should_link(i) {\n+            return;\n+        }\n+\n+        match self.extract_crate_info(i) {\n+            Some(info) => {\n+                let (cnum, _, _) = self.resolve_crate(&None,\n+                                                      info.ident[],\n+                                                      info.name[],\n+                                                      None,\n+                                                      i.span,\n+                                                      PathKind::Crate);\n+                self.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n+            }\n+            None => ()\n+        }\n+    }\n \n-        match hash {\n-            Some(hash) if *hash == data.hash() => { ret = Some(cnum); return }\n-            Some(..) => return,\n-            None => {}\n+    fn extract_crate_info(&self, i: &ast::ViewItem) -> Option<CrateInfo> {\n+        match i.node {\n+            ast::ViewItemExternCrate(ident, ref path_opt, id) => {\n+                let ident = token::get_ident(ident);\n+                debug!(\"resolving extern crate stmt. ident: {} path_opt: {}\",\n+                       ident, path_opt);\n+                let name = match *path_opt {\n+                    Some((ref path_str, _)) => {\n+                        let name = path_str.get().to_string();\n+                        validate_crate_name(Some(self.sess), name[],\n+                                            Some(i.span));\n+                        name\n+                    }\n+                    None => ident.get().to_string(),\n+                };\n+                Some(CrateInfo {\n+                    ident: ident.get().to_string(),\n+                    name: name,\n+                    id: id,\n+                    should_link: should_link(i),\n+                })\n+            }\n+            _ => None\n         }\n+    }\n+\n+    fn process_item(&self, i: &ast::Item) {\n+        match i.node {\n+            ast::ItemForeignMod(ref fm) => {\n+                if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n+                    return;\n+                }\n+\n+                // First, add all of the custom link_args attributes\n+                let link_args = i.attrs.iter()\n+                    .filter_map(|at| if at.name() == \"link_args\" {\n+                        Some(at)\n+                    } else {\n+                        None\n+                    })\n+                    .collect::<Vec<&ast::Attribute>>();\n+                for m in link_args.iter() {\n+                    match m.value_str() {\n+                        Some(linkarg) => self.sess.cstore.add_used_link_args(linkarg.get()),\n+                        None => { /* fallthrough */ }\n+                    }\n+                }\n \n-        // When the hash is None we're dealing with a top-level dependency in\n-        // which case we may have a specification on the command line for this\n-        // library. Even though an upstream library may have loaded something of\n-        // the same name, we have to make sure it was loaded from the exact same\n-        // location as well.\n-        //\n-        // We're also sure to compare *paths*, not actual byte slices. The\n-        // `source` stores paths which are normalized which may be different\n-        // from the strings on the command line.\n-        let source = e.sess.cstore.get_used_crate_source(cnum).unwrap();\n-        match e.sess.opts.externs.get(name) {\n-            Some(locs) => {\n-                let found = locs.iter().any(|l| {\n-                    let l = fs::realpath(&Path::new(l[])).ok();\n-                    l == source.dylib || l == source.rlib\n-                });\n-                if found {\n-                    ret = Some(cnum);\n+                // Next, process all of the #[link(..)]-style arguments\n+                let link_args = i.attrs.iter()\n+                    .filter_map(|at| if at.name() == \"link\" {\n+                        Some(at)\n+                    } else {\n+                        None\n+                    })\n+                    .collect::<Vec<&ast::Attribute>>();\n+                for m in link_args.iter() {\n+                    match m.meta_item_list() {\n+                        Some(items) => {\n+                            let kind = items.iter().find(|k| {\n+                                k.name() == \"kind\"\n+                            }).and_then(|a| a.value_str());\n+                            let kind = match kind {\n+                                Some(k) => {\n+                                    if k == \"static\" {\n+                                        cstore::NativeStatic\n+                                    } else if self.sess.target.target.options.is_like_osx\n+                                              && k == \"framework\" {\n+                                        cstore::NativeFramework\n+                                    } else if k == \"framework\" {\n+                                        cstore::NativeFramework\n+                                    } else if k == \"dylib\" {\n+                                        cstore::NativeUnknown\n+                                    } else {\n+                                        self.sess.span_err(m.span,\n+                                            format!(\"unknown kind: `{}`\",\n+                                                    k)[]);\n+                                        cstore::NativeUnknown\n+                                    }\n+                                }\n+                                None => cstore::NativeUnknown\n+                            };\n+                            let n = items.iter().find(|n| {\n+                                n.name() == \"name\"\n+                            }).and_then(|a| a.value_str());\n+                            let n = match n {\n+                                Some(n) => n,\n+                                None => {\n+                                    self.sess.span_err(m.span,\n+                                        \"#[link(...)] specified without \\\n+                                         `name = \\\"foo\\\"`\");\n+                                    InternedString::new(\"foo\")\n+                                }\n+                            };\n+                            register_native_lib(self.sess, Some(m.span),\n+                                                n.get().to_string(), kind);\n+                        }\n+                        None => {}\n+                    }\n                 }\n             }\n-            None => ret = Some(cnum),\n+            _ => { }\n         }\n-    });\n-    return ret;\n-}\n+    }\n \n-fn register_crate<'a>(e: &mut Env,\n-                  root: &Option<CratePaths>,\n-                  ident: &str,\n-                  name: &str,\n-                  span: Span,\n-                  lib: loader::Library)\n-                        -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n-                            cstore::CrateSource) {\n-    // Claim this crate number and cache it\n-    let cnum = e.next_crate_num;\n-    e.next_crate_num += 1;\n-\n-    // Stash paths for top-most crate locally if necessary.\n-    let crate_paths = if root.is_none() {\n-        Some(CratePaths {\n-            ident: ident.to_string(),\n-            dylib: lib.dylib.clone(),\n-            rlib:  lib.rlib.clone(),\n-        })\n-    } else {\n-        None\n-    };\n-    // Maintain a reference to the top most crate.\n-    let root = if root.is_some() { root } else { &crate_paths };\n+    fn existing_match(&self, name: &str,\n+                      hash: Option<&Svh>) -> Option<ast::CrateNum> {\n+        let mut ret = None;\n+        self.sess.cstore.iter_crate_data(|cnum, data| {\n+            if data.name != name { return }\n+\n+            match hash {\n+                Some(hash) if *hash == data.hash() => { ret = Some(cnum); return }\n+                Some(..) => return,\n+                None => {}\n+            }\n+\n+            // When the hash is None we're dealing with a top-level dependency in\n+            // which case we may have a specification on the command line for this\n+            // library. Even though an upstream library may have loaded something of\n+            // the same name, we have to make sure it was loaded from the exact same\n+            // location as well.\n+            //\n+            // We're also sure to compare *paths*, not actual byte slices. The\n+            // `source` stores paths which are normalized which may be different\n+            // from the strings on the command line.\n+            let source = self.sess.cstore.get_used_crate_source(cnum).unwrap();\n+            match self.sess.opts.externs.get(name) {\n+                Some(locs) => {\n+                    let found = locs.iter().any(|l| {\n+                        let l = fs::realpath(&Path::new(l[])).ok();\n+                        l == source.dylib || l == source.rlib\n+                    });\n+                    if found {\n+                        ret = Some(cnum);\n+                    }\n+                }\n+                None => ret = Some(cnum),\n+            }\n+        });\n+        return ret;\n+    }\n \n-    let cnum_map = resolve_crate_deps(e, root, lib.metadata.as_slice(), span);\n+    fn register_crate(&mut self,\n+                      root: &Option<CratePaths>,\n+                      ident: &str,\n+                      name: &str,\n+                      span: Span,\n+                      lib: loader::Library)\n+                      -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n+                          cstore::CrateSource) {\n+        // Claim this crate number and cache it\n+        let cnum = self.next_crate_num;\n+        self.next_crate_num += 1;\n+\n+        // Stash paths for top-most crate locally if necessary.\n+        let crate_paths = if root.is_none() {\n+            Some(CratePaths {\n+                ident: ident.to_string(),\n+                dylib: lib.dylib.clone(),\n+                rlib:  lib.rlib.clone(),\n+            })\n+        } else {\n+            None\n+        };\n+        // Maintain a reference to the top most crate.\n+        let root = if root.is_some() { root } else { &crate_paths };\n \n-    let loader::Library{ dylib, rlib, metadata } = lib;\n+        let cnum_map = self.resolve_crate_deps(root, lib.metadata.as_slice(), span);\n \n-    let cmeta = Rc::new( cstore::crate_metadata {\n-        name: name.to_string(),\n-        data: metadata,\n-        cnum_map: cnum_map,\n-        cnum: cnum,\n-        span: span,\n-    });\n+        let loader::Library{ dylib, rlib, metadata } = lib;\n \n-    let source = cstore::CrateSource {\n-        dylib: dylib,\n-        rlib: rlib,\n-        cnum: cnum,\n-    };\n+        let cmeta = Rc::new( cstore::crate_metadata {\n+            name: name.to_string(),\n+            data: metadata,\n+            cnum_map: cnum_map,\n+            cnum: cnum,\n+            span: span,\n+        });\n \n-    e.sess.cstore.set_crate_data(cnum, cmeta.clone());\n-    e.sess.cstore.add_used_crate_source(source.clone());\n-    (cnum, cmeta, source)\n-}\n+        let source = cstore::CrateSource {\n+            dylib: dylib,\n+            rlib: rlib,\n+            cnum: cnum,\n+        };\n+\n+        self.sess.cstore.set_crate_data(cnum, cmeta.clone());\n+        self.sess.cstore.add_used_crate_source(source.clone());\n+        (cnum, cmeta, source)\n+    }\n \n-fn resolve_crate(e: &mut Env,\n-                 root: &Option<CratePaths>,\n-                 ident: &str,\n-                 name: &str,\n-                 hash: Option<&Svh>,\n-                 span: Span,\n-                 kind: PathKind)\n-                     -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n-                         cstore::CrateSource) {\n-    match existing_match(e, name, hash) {\n-        None => {\n-            let mut load_ctxt = loader::Context {\n-                sess: e.sess,\n-                span: span,\n-                ident: ident,\n-                crate_name: name,\n-                hash: hash.map(|a| &*a),\n-                filesearch: e.sess.target_filesearch(kind),\n-                triple: e.sess.opts.target_triple[],\n-                root: root,\n-                rejected_via_hash: vec!(),\n-                rejected_via_triple: vec!(),\n-                should_match_name: true,\n-            };\n-            let library = load_ctxt.load_library_crate();\n-            register_crate(e, root, ident, name, span, library)\n+    fn resolve_crate(&mut self,\n+                     root: &Option<CratePaths>,\n+                     ident: &str,\n+                     name: &str,\n+                     hash: Option<&Svh>,\n+                     span: Span,\n+                     kind: PathKind)\n+                         -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n+                             cstore::CrateSource) {\n+        match self.existing_match(name, hash) {\n+            None => {\n+                let mut load_ctxt = loader::Context {\n+                    sess: self.sess,\n+                    span: span,\n+                    ident: ident,\n+                    crate_name: name,\n+                    hash: hash.map(|a| &*a),\n+                    filesearch: self.sess.target_filesearch(kind),\n+                    triple: self.sess.opts.target_triple[],\n+                    root: root,\n+                    rejected_via_hash: vec!(),\n+                    rejected_via_triple: vec!(),\n+                    should_match_name: true,\n+                };\n+                let library = load_ctxt.load_library_crate();\n+                self.register_crate(root, ident, name, span, library)\n+            }\n+            Some(cnum) => (cnum,\n+                           self.sess.cstore.get_crate_data(cnum),\n+                           self.sess.cstore.get_used_crate_source(cnum).unwrap())\n         }\n-        Some(cnum) => (cnum,\n-                       e.sess.cstore.get_crate_data(cnum),\n-                       e.sess.cstore.get_used_crate_source(cnum).unwrap())\n     }\n-}\n \n-// Go through the crate metadata and load any crates that it references\n-fn resolve_crate_deps(e: &mut Env,\n-                      root: &Option<CratePaths>,\n-                      cdata: &[u8], span : Span)\n-                   -> cstore::cnum_map {\n-    debug!(\"resolving deps of external crate\");\n-    // The map from crate numbers in the crate we're resolving to local crate\n-    // numbers\n-    decoder::get_crate_deps(cdata).iter().map(|dep| {\n-        debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n-        let (local_cnum, _, _) = resolve_crate(e, root,\n-                                               dep.name[],\n-                                               dep.name[],\n-                                               Some(&dep.hash),\n-                                               span,\n-                                               PathKind::Dependency);\n-        (dep.cnum, local_cnum)\n-    }).collect()\n+    // Go through the crate metadata and load any crates that it references\n+    fn resolve_crate_deps(&mut self,\n+                          root: &Option<CratePaths>,\n+                          cdata: &[u8], span : Span)\n+                       -> cstore::cnum_map {\n+        debug!(\"resolving deps of external crate\");\n+        // The map from crate numbers in the crate we're resolving to local crate\n+        // numbers\n+        decoder::get_crate_deps(cdata).iter().map(|dep| {\n+            debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n+            let (local_cnum, _, _) = self.resolve_crate(root,\n+                                                   dep.name[],\n+                                                   dep.name[],\n+                                                   Some(&dep.hash),\n+                                                   span,\n+                                                   PathKind::Dependency);\n+            (dep.cnum, local_cnum)\n+        }).collect()\n+    }\n }\n \n pub struct PluginMetadataReader<'a> {\n@@ -459,7 +463,7 @@ impl<'a> PluginMetadataReader<'a> {\n \n     pub fn read_plugin_metadata(&mut self,\n                                 krate: &ast::ViewItem) -> PluginMetadata {\n-        let info = extract_crate_info(&self.env, krate).unwrap();\n+        let info = self.env.extract_crate_info(krate).unwrap();\n         let target_triple = self.env.sess.opts.target_triple[];\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n@@ -516,11 +520,10 @@ impl<'a> PluginMetadataReader<'a> {\n             macros: macros,\n             registrar_symbol: registrar,\n         };\n-        if should_link && existing_match(&self.env, info.name[],\n-                                         None).is_none() {\n+        if should_link && self.env.existing_match(info.name[], None).is_none() {\n             // register crate now to avoid double-reading metadata\n-            register_crate(&mut self.env, &None, info.ident[],\n-                           info.name[], krate.span, library);\n+            self.env.register_crate(&None, info.ident[],\n+                                    info.name[], krate.span, library);\n         }\n         pc\n     }"}]}