{"sha": "b575b0244982da29159d341412945b92dd57f5df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NzViMDI0NDk4MmRhMjkxNTlkMzQxNDEyOTQ1YjkyZGQ1N2Y1ZGY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-20T19:39:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-20T19:39:41Z"}, "message": "Merge #4961\n\n4961: Centralize handing of in-flight requests r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "33819de5d4de02d100a9c78110cb51b9b7df14c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33819de5d4de02d100a9c78110cb51b9b7df14c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b575b0244982da29159d341412945b92dd57f5df", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe7mX9CRBK7hj4Ov3rIwAAdHIIAHbRCpMpCUGusbB+XedlrD9N\nM05W30sjJTa4uU4vM6i7RJw82tWxvryCUknUOSw5r3puzRYaJ5aT1wnBNAWqMjjz\nzYQhiMytYXMY1bKLY7oy36rL8WN3HJIB+ICNWfXaolm631RAr8M3Wmpj+mWAVy7O\nDjoPJOAz/vyW4MNMpq31d0vNVXCwvbEifOXJuaT8cCr4fuSo36QI0b02DfAb4h/D\n0+wGdJRL4yyxlj/Ikp282AetoF/OAeqvE4KX3qev37k+TsYUWtlPd7BKwfQH/drb\nxaiwUAPijOlhLZtsFtf701kgESqzIBFmz5BycjafpspfCsPHqS0pIrbJjWUa+hw=\n=BoqR\n-----END PGP SIGNATURE-----\n", "payload": "tree 33819de5d4de02d100a9c78110cb51b9b7df14c6\nparent c8557b91a3ccfea5c83260bc35a59e6839784281\nparent 93605c49baccf7d28297028f0b49be8b94701f67\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1592681981 +0000\ncommitter GitHub <noreply@github.com> 1592681981 +0000\n\nMerge #4961\n\n4961: Centralize handing of in-flight requests r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b575b0244982da29159d341412945b92dd57f5df", "html_url": "https://github.com/rust-lang/rust/commit/b575b0244982da29159d341412945b92dd57f5df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b575b0244982da29159d341412945b92dd57f5df/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8557b91a3ccfea5c83260bc35a59e6839784281", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8557b91a3ccfea5c83260bc35a59e6839784281", "html_url": "https://github.com/rust-lang/rust/commit/c8557b91a3ccfea5c83260bc35a59e6839784281"}, {"sha": "93605c49baccf7d28297028f0b49be8b94701f67", "url": "https://api.github.com/repos/rust-lang/rust/commits/93605c49baccf7d28297028f0b49be8b94701f67", "html_url": "https://github.com/rust-lang/rust/commit/93605c49baccf7d28297028f0b49be8b94701f67"}], "stats": {"total": 358, "additions": 188, "deletions": 170}, "files": [{"sha": "d1897bf505c59fb10882b314e6ed997576b56fb9", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b575b0244982da29159d341412945b92dd57f5df/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b575b0244982da29159d341412945b92dd57f5df/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=b575b0244982da29159d341412945b92dd57f5df", "patch": "@@ -20,7 +20,7 @@ use stdx::format_to;\n use crate::{\n     config::{Config, FilesWatcher},\n     diagnostics::{CheckFixes, DiagnosticCollection},\n-    main_loop::pending_requests::{CompletedRequest, LatestRequests},\n+    main_loop::req_queue::{CompletedInRequest, LatestRequests},\n     to_proto::url_from_abs_path,\n     vfs_glob::{Glob, RustPackageFilterBuilder},\n     LspError, Result,\n@@ -236,7 +236,7 @@ impl GlobalState {\n         self.analysis_host.collect_garbage()\n     }\n \n-    pub fn complete_request(&mut self, request: CompletedRequest) {\n+    pub(crate) fn complete_request(&mut self, request: CompletedInRequest) {\n         self.latest_requests.write().record(request)\n     }\n }"}, {"sha": "fd40b2443f104c8f47f4e35cf393f16b80772deb", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 63, "deletions": 93, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/b575b0244982da29159d341412945b92dd57f5df/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b575b0244982da29159d341412945b92dd57f5df/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=b575b0244982da29159d341412945b92dd57f5df", "patch": "@@ -3,7 +3,7 @@\n \n mod handlers;\n mod subscriptions;\n-pub(crate) mod pending_requests;\n+pub(crate) mod req_queue;\n \n use std::{\n     borrow::Cow,\n@@ -28,7 +28,6 @@ use ra_ide::{Canceled, FileId, LineIndex};\n use ra_prof::profile;\n use ra_project_model::{PackageRoot, ProjectWorkspace};\n use ra_vfs::VfsTask;\n-use rustc_hash::FxHashSet;\n use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n@@ -38,12 +37,10 @@ use crate::{\n     from_proto,\n     global_state::{file_id_to_url, GlobalState, GlobalStateSnapshot},\n     lsp_ext,\n-    main_loop::{\n-        pending_requests::{PendingRequest, PendingRequests},\n-        subscriptions::Subscriptions,\n-    },\n+    main_loop::subscriptions::Subscriptions,\n     Result,\n };\n+use req_queue::ReqQueue;\n \n #[derive(Debug)]\n pub struct LspError {\n@@ -153,10 +150,10 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                 register_options: Some(serde_json::to_value(registration_options).unwrap()),\n             };\n             let params = lsp_types::RegistrationParams { registrations: vec![registration] };\n-            let request = request_new::<lsp_types::request::RegisterCapability>(\n-                loop_state.next_request_id(),\n-                params,\n-            );\n+            let request = loop_state\n+                .req_queue\n+                .outgoing\n+                .register::<lsp_types::request::RegisterCapability>(params, |_, _| ());\n             connection.sender.send(request.into()).unwrap();\n         }\n \n@@ -199,7 +196,7 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n     global_state.analysis_host.request_cancellation();\n     log::info!(\"waiting for tasks to finish...\");\n     task_receiver.into_iter().for_each(|task| {\n-        on_task(task, &connection.sender, &mut loop_state.pending_requests, &mut global_state)\n+        on_task(task, &connection.sender, &mut loop_state.req_queue.incoming, &mut global_state)\n     });\n     log::info!(\"...tasks have finished\");\n     log::info!(\"joining threadpool...\");\n@@ -264,27 +261,14 @@ impl fmt::Debug for Event {\n     }\n }\n \n-#[derive(Debug, Default)]\n+#[derive(Default)]\n struct LoopState {\n-    next_request_id: u64,\n-    pending_responses: FxHashSet<RequestId>,\n-    pending_requests: PendingRequests,\n+    req_queue: ReqQueue<fn(&mut GlobalState, lsp_server::Response)>,\n     subscriptions: Subscriptions,\n     workspace_loaded: bool,\n     roots_progress_reported: Option<usize>,\n     roots_scanned: usize,\n     roots_total: usize,\n-    configuration_request_id: Option<RequestId>,\n-}\n-\n-impl LoopState {\n-    fn next_request_id(&mut self) -> RequestId {\n-        self.next_request_id += 1;\n-        let res: RequestId = self.next_request_id.into();\n-        let inserted = self.pending_responses.insert(res.clone());\n-        assert!(inserted);\n-        res\n-    }\n }\n \n fn loop_turn(\n@@ -307,7 +291,7 @@ fn loop_turn(\n \n     match event {\n         Event::Task(task) => {\n-            on_task(task, &connection.sender, &mut loop_state.pending_requests, global_state);\n+            on_task(task, &connection.sender, &mut loop_state.req_queue.incoming, global_state);\n             global_state.maybe_collect_garbage();\n         }\n         Event::Vfs(task) => {\n@@ -317,7 +301,7 @@ fn loop_turn(\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => on_request(\n                 global_state,\n-                &mut loop_state.pending_requests,\n+                &mut loop_state.req_queue.incoming,\n                 pool,\n                 task_sender,\n                 &connection.sender,\n@@ -328,32 +312,8 @@ fn loop_turn(\n                 on_notification(&connection.sender, global_state, loop_state, not)?;\n             }\n             Message::Response(resp) => {\n-                let removed = loop_state.pending_responses.remove(&resp.id);\n-                if !removed {\n-                    log::error!(\"unexpected response: {:?}\", resp)\n-                }\n-\n-                if Some(&resp.id) == loop_state.configuration_request_id.as_ref() {\n-                    loop_state.configuration_request_id = None;\n-                    log::debug!(\"config update response: '{:?}\", resp);\n-                    let Response { error, result, .. } = resp;\n-\n-                    match (error, result) {\n-                        (Some(err), _) => {\n-                            log::error!(\"failed to fetch the server settings: {:?}\", err)\n-                        }\n-                        (None, Some(configs)) => {\n-                            if let Some(new_config) = configs.get(0) {\n-                                let mut config = global_state.config.clone();\n-                                config.update(&new_config);\n-                                global_state.update_configuration(config);\n-                            }\n-                        }\n-                        (None, None) => {\n-                            log::error!(\"received empty server settings response from the client\")\n-                        }\n-                    }\n-                }\n+                let handler = loop_state.req_queue.outgoing.complete(resp.id.clone());\n+                handler(global_state, resp)\n             }\n         },\n     };\n@@ -407,12 +367,12 @@ fn loop_turn(\n fn on_task(\n     task: Task,\n     msg_sender: &Sender<Message>,\n-    pending_requests: &mut PendingRequests,\n+    incoming_requests: &mut req_queue::Incoming,\n     state: &mut GlobalState,\n ) {\n     match task {\n         Task::Respond(response) => {\n-            if let Some(completed) = pending_requests.finish(&response.id) {\n+            if let Some(completed) = incoming_requests.complete(response.id.clone()) {\n                 log::info!(\"handled req#{} in {:?}\", completed.id, completed.duration);\n                 state.complete_request(completed);\n                 msg_sender.send(response.into()).unwrap();\n@@ -427,7 +387,7 @@ fn on_task(\n \n fn on_request(\n     global_state: &mut GlobalState,\n-    pending_requests: &mut PendingRequests,\n+    incoming_requests: &mut req_queue::Incoming,\n     pool: &ThreadPool,\n     task_sender: &Sender<Task>,\n     msg_sender: &Sender<Message>,\n@@ -440,7 +400,7 @@ fn on_request(\n         global_state,\n         task_sender,\n         msg_sender,\n-        pending_requests,\n+        incoming_requests,\n         request_received,\n     };\n     pool_dispatcher\n@@ -504,12 +464,7 @@ fn on_notification(\n                 NumberOrString::Number(id) => id.into(),\n                 NumberOrString::String(id) => id.into(),\n             };\n-            if loop_state.pending_requests.cancel(&id) {\n-                let response = Response::new_err(\n-                    id,\n-                    ErrorCode::RequestCanceled as i32,\n-                    \"canceled by client\".to_string(),\n-                );\n+            if let Some(response) = loop_state.req_queue.incoming.cancel(id) {\n                 msg_sender.send(response.into()).unwrap()\n             }\n             return Ok(());\n@@ -572,18 +527,38 @@ fn on_notification(\n         Ok(_) => {\n             // As stated in https://github.com/microsoft/language-server-protocol/issues/676,\n             // this notification's parameters should be ignored and the actual config queried separately.\n-            let request_id = loop_state.next_request_id();\n-            let request = request_new::<lsp_types::request::WorkspaceConfiguration>(\n-                request_id.clone(),\n-                lsp_types::ConfigurationParams {\n-                    items: vec![lsp_types::ConfigurationItem {\n-                        scope_uri: None,\n-                        section: Some(\"rust-analyzer\".to_string()),\n-                    }],\n-                },\n-            );\n+            let request = loop_state\n+                .req_queue\n+                .outgoing\n+                .register::<lsp_types::request::WorkspaceConfiguration>(\n+                    lsp_types::ConfigurationParams {\n+                        items: vec![lsp_types::ConfigurationItem {\n+                            scope_uri: None,\n+                            section: Some(\"rust-analyzer\".to_string()),\n+                        }],\n+                    },\n+                    |global_state, resp| {\n+                        log::debug!(\"config update response: '{:?}\", resp);\n+                        let Response { error, result, .. } = resp;\n+\n+                        match (error, result) {\n+                            (Some(err), _) => {\n+                                log::error!(\"failed to fetch the server settings: {:?}\", err)\n+                            }\n+                            (None, Some(configs)) => {\n+                                if let Some(new_config) = configs.get(0) {\n+                                    let mut config = global_state.config.clone();\n+                                    config.update(&new_config);\n+                                    global_state.update_configuration(config);\n+                                }\n+                            }\n+                            (None, None) => log::error!(\n+                                \"received empty server settings response from the client\"\n+                            ),\n+                        }\n+                    },\n+                );\n             msg_sender.send(request.into())?;\n-            loop_state.configuration_request_id = Some(request_id);\n \n             return Ok(());\n         }\n@@ -752,13 +727,16 @@ fn send_startup_progress(sender: &Sender<Message>, loop_state: &mut LoopState) {\n \n     match (prev, loop_state.workspace_loaded) {\n         (None, false) => {\n-            let work_done_progress_create = request_new::<lsp_types::request::WorkDoneProgressCreate>(\n-                loop_state.next_request_id(),\n-                WorkDoneProgressCreateParams {\n-                    token: lsp_types::ProgressToken::String(\"rustAnalyzer/startup\".into()),\n-                },\n-            );\n-            sender.send(work_done_progress_create.into()).unwrap();\n+            let request = loop_state\n+                .req_queue\n+                .outgoing\n+                .register::<lsp_types::request::WorkDoneProgressCreate>(\n+                    WorkDoneProgressCreateParams {\n+                        token: lsp_types::ProgressToken::String(\"rustAnalyzer/startup\".into()),\n+                    },\n+                    |_, _| (),\n+                );\n+            sender.send(request.into()).unwrap();\n             send_startup_progress_notif(\n                 sender,\n                 WorkDoneProgress::Begin(WorkDoneProgressBegin {\n@@ -800,7 +778,7 @@ struct PoolDispatcher<'a> {\n     req: Option<Request>,\n     pool: &'a ThreadPool,\n     global_state: &'a mut GlobalState,\n-    pending_requests: &'a mut PendingRequests,\n+    incoming_requests: &'a mut req_queue::Incoming,\n     msg_sender: &'a Sender<Message>,\n     task_sender: &'a Sender<Task>,\n     request_received: Instant,\n@@ -829,7 +807,7 @@ impl<'a> PoolDispatcher<'a> {\n             result_to_task::<R>(id, result)\n         })\n         .map_err(|_| format!(\"sync task {:?} panicked\", R::METHOD))?;\n-        on_task(task, self.msg_sender, self.pending_requests, self.global_state);\n+        on_task(task, self.msg_sender, self.incoming_requests, self.global_state);\n         Ok(self)\n     }\n \n@@ -876,7 +854,7 @@ impl<'a> PoolDispatcher<'a> {\n                 return None;\n             }\n         };\n-        self.pending_requests.start(PendingRequest {\n+        self.incoming_requests.register(req_queue::PendingInRequest {\n             id: id.clone(),\n             method: R::METHOD.to_string(),\n             received: self.request_received,\n@@ -993,14 +971,6 @@ where\n     Notification::new(N::METHOD.to_string(), params)\n }\n \n-fn request_new<R>(id: RequestId, params: R::Params) -> Request\n-where\n-    R: lsp_types::request::Request,\n-    R::Params: Serialize,\n-{\n-    Request::new(id, R::METHOD.to_string(), params)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use std::borrow::Cow;"}, {"sha": "73b33e41942c65505f44d2c2e934665e2aacb7f9", "filename": "crates/rust-analyzer/src/main_loop/pending_requests.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c8557b91a3ccfea5c83260bc35a59e6839784281/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fpending_requests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8557b91a3ccfea5c83260bc35a59e6839784281/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fpending_requests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Fpending_requests.rs?ref=c8557b91a3ccfea5c83260bc35a59e6839784281", "patch": "@@ -1,75 +0,0 @@\n-//! Data structures that keep track of inflight requests.\n-\n-use std::time::{Duration, Instant};\n-\n-use lsp_server::RequestId;\n-use rustc_hash::FxHashMap;\n-\n-#[derive(Debug)]\n-pub struct CompletedRequest {\n-    pub id: RequestId,\n-    pub method: String,\n-    pub duration: Duration,\n-}\n-\n-#[derive(Debug)]\n-pub(crate) struct PendingRequest {\n-    pub(crate) id: RequestId,\n-    pub(crate) method: String,\n-    pub(crate) received: Instant,\n-}\n-\n-impl From<PendingRequest> for CompletedRequest {\n-    fn from(pending: PendingRequest) -> CompletedRequest {\n-        CompletedRequest {\n-            id: pending.id,\n-            method: pending.method,\n-            duration: pending.received.elapsed(),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Default)]\n-pub(crate) struct PendingRequests {\n-    map: FxHashMap<RequestId, PendingRequest>,\n-}\n-\n-impl PendingRequests {\n-    pub(crate) fn start(&mut self, request: PendingRequest) {\n-        let id = request.id.clone();\n-        let prev = self.map.insert(id.clone(), request);\n-        assert!(prev.is_none(), \"duplicate request with id {}\", id);\n-    }\n-    pub(crate) fn cancel(&mut self, id: &RequestId) -> bool {\n-        self.map.remove(id).is_some()\n-    }\n-    pub(crate) fn finish(&mut self, id: &RequestId) -> Option<CompletedRequest> {\n-        self.map.remove(id).map(CompletedRequest::from)\n-    }\n-}\n-\n-const N_COMPLETED_REQUESTS: usize = 10;\n-\n-#[derive(Debug, Default)]\n-pub struct LatestRequests {\n-    // hand-rolling VecDeque here to print things in a nicer way\n-    buf: [Option<CompletedRequest>; N_COMPLETED_REQUESTS],\n-    idx: usize,\n-}\n-\n-impl LatestRequests {\n-    pub(crate) fn record(&mut self, request: CompletedRequest) {\n-        // special case: don't track status request itself\n-        if request.method == \"rust-analyzer/analyzerStatus\" {\n-            return;\n-        }\n-        let idx = self.idx;\n-        self.buf[idx] = Some(request);\n-        self.idx = (idx + 1) % N_COMPLETED_REQUESTS;\n-    }\n-\n-    pub(crate) fn iter(&self) -> impl Iterator<Item = (bool, &CompletedRequest)> {\n-        let idx = self.idx;\n-        self.buf.iter().enumerate().filter_map(move |(i, req)| Some((i == idx, req.as_ref()?)))\n-    }\n-}"}, {"sha": "5cf6d916b7738d8e2fc7ad801c837618a47f482e", "filename": "crates/rust-analyzer/src/main_loop/req_queue.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/b575b0244982da29159d341412945b92dd57f5df/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Freq_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b575b0244982da29159d341412945b92dd57f5df/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Freq_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop%2Freq_queue.rs?ref=b575b0244982da29159d341412945b92dd57f5df", "patch": "@@ -0,0 +1,123 @@\n+//! Manages the set of in-flight requests in both directions.\n+use std::time::{Duration, Instant};\n+\n+use lsp_server::RequestId;\n+use rustc_hash::FxHashMap;\n+use serde::Serialize;\n+\n+#[derive(Debug)]\n+pub(crate) struct ReqQueue<H> {\n+    pub(crate) incoming: Incoming,\n+    pub(crate) outgoing: Outgoing<H>,\n+}\n+\n+impl<H> Default for ReqQueue<H> {\n+    fn default() -> Self {\n+        ReqQueue { incoming: Incoming::default(), outgoing: Outgoing::default() }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct Outgoing<H> {\n+    next: u64,\n+    pending: FxHashMap<RequestId, H>,\n+}\n+\n+impl<H> Default for Outgoing<H> {\n+    fn default() -> Self {\n+        Outgoing { next: 0, pending: FxHashMap::default() }\n+    }\n+}\n+\n+impl<H> Outgoing<H> {\n+    pub(crate) fn register<R>(&mut self, params: R::Params, handler: H) -> lsp_server::Request\n+    where\n+        R: lsp_types::request::Request,\n+        R::Params: Serialize,\n+    {\n+        let id = RequestId::from(self.next);\n+        self.next += 1;\n+        self.pending.insert(id.clone(), handler);\n+        lsp_server::Request::new(id, R::METHOD.to_string(), params)\n+    }\n+    pub(crate) fn complete(&mut self, id: RequestId) -> H {\n+        self.pending.remove(&id).unwrap()\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct CompletedInRequest {\n+    pub(crate) id: RequestId,\n+    pub(crate) method: String,\n+    pub(crate) duration: Duration,\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct PendingInRequest {\n+    pub(crate) id: RequestId,\n+    pub(crate) method: String,\n+    pub(crate) received: Instant,\n+}\n+\n+impl From<PendingInRequest> for CompletedInRequest {\n+    fn from(pending: PendingInRequest) -> CompletedInRequest {\n+        CompletedInRequest {\n+            id: pending.id,\n+            method: pending.method,\n+            duration: pending.received.elapsed(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Default)]\n+pub(crate) struct Incoming {\n+    pending: FxHashMap<RequestId, PendingInRequest>,\n+}\n+\n+impl Incoming {\n+    pub(crate) fn register(&mut self, request: PendingInRequest) {\n+        let id = request.id.clone();\n+        let prev = self.pending.insert(id.clone(), request);\n+        assert!(prev.is_none(), \"duplicate request with id {}\", id);\n+    }\n+    pub(crate) fn cancel(&mut self, id: RequestId) -> Option<lsp_server::Response> {\n+        if self.pending.remove(&id).is_some() {\n+            Some(lsp_server::Response::new_err(\n+                id,\n+                lsp_server::ErrorCode::RequestCanceled as i32,\n+                \"canceled by client\".to_string(),\n+            ))\n+        } else {\n+            None\n+        }\n+    }\n+    pub(crate) fn complete(&mut self, id: RequestId) -> Option<CompletedInRequest> {\n+        self.pending.remove(&id).map(CompletedInRequest::from)\n+    }\n+}\n+\n+const N_COMPLETED_REQUESTS: usize = 10;\n+\n+#[derive(Debug, Default)]\n+pub struct LatestRequests {\n+    // hand-rolling VecDeque here to print things in a nicer way\n+    buf: [Option<CompletedInRequest>; N_COMPLETED_REQUESTS],\n+    idx: usize,\n+}\n+\n+impl LatestRequests {\n+    pub(crate) fn record(&mut self, request: CompletedInRequest) {\n+        // special case: don't track status request itself\n+        if request.method == \"rust-analyzer/analyzerStatus\" {\n+            return;\n+        }\n+        let idx = self.idx;\n+        self.buf[idx] = Some(request);\n+        self.idx = (idx + 1) % N_COMPLETED_REQUESTS;\n+    }\n+\n+    pub(crate) fn iter(&self) -> impl Iterator<Item = (bool, &CompletedInRequest)> {\n+        let idx = self.idx;\n+        self.buf.iter().enumerate().filter_map(move |(i, req)| Some((i == idx, req.as_ref()?)))\n+    }\n+}"}]}