{"sha": "69092ffdf23f5be5b2a9cbdd3145daed5004b2b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MDkyZmZkZjIzZjViZTViMmE5Y2JkZDMxNDVkYWVkNTAwNGIyYjI=", "commit": {"author": {"name": "Simon Mazur", "email": "semmaz.box@gmail.com", "date": "2015-09-10T12:03:22Z"}, "committer": {"name": "Simon Mazur", "email": "semmaz.box@gmail.com", "date": "2015-09-11T16:44:05Z"}, "message": "Changed libfmt_macros Parse iterator to Peekable", "tree": {"sha": "b47cfaabef3911d778b0c6e33cc3c50f6c016494", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b47cfaabef3911d778b0c6e33cc3c50f6c016494"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69092ffdf23f5be5b2a9cbdd3145daed5004b2b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69092ffdf23f5be5b2a9cbdd3145daed5004b2b2", "html_url": "https://github.com/rust-lang/rust/commit/69092ffdf23f5be5b2a9cbdd3145daed5004b2b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69092ffdf23f5be5b2a9cbdd3145daed5004b2b2/comments", "author": {"login": "semmaz", "id": 3989426, "node_id": "MDQ6VXNlcjM5ODk0MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3989426?v=4", "gravatar_id": "", "url": "https://api.github.com/users/semmaz", "html_url": "https://github.com/semmaz", "followers_url": "https://api.github.com/users/semmaz/followers", "following_url": "https://api.github.com/users/semmaz/following{/other_user}", "gists_url": "https://api.github.com/users/semmaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/semmaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/semmaz/subscriptions", "organizations_url": "https://api.github.com/users/semmaz/orgs", "repos_url": "https://api.github.com/users/semmaz/repos", "events_url": "https://api.github.com/users/semmaz/events{/privacy}", "received_events_url": "https://api.github.com/users/semmaz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "semmaz", "id": 3989426, "node_id": "MDQ6VXNlcjM5ODk0MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3989426?v=4", "gravatar_id": "", "url": "https://api.github.com/users/semmaz", "html_url": "https://github.com/semmaz", "followers_url": "https://api.github.com/users/semmaz/followers", "following_url": "https://api.github.com/users/semmaz/following{/other_user}", "gists_url": "https://api.github.com/users/semmaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/semmaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/semmaz/subscriptions", "organizations_url": "https://api.github.com/users/semmaz/orgs", "repos_url": "https://api.github.com/users/semmaz/repos", "events_url": "https://api.github.com/users/semmaz/events{/privacy}", "received_events_url": "https://api.github.com/users/semmaz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a1e6b85f6f0976aad5bf3bd6aec7403163c62cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a1e6b85f6f0976aad5bf3bd6aec7403163c62cc", "html_url": "https://github.com/rust-lang/rust/commit/1a1e6b85f6f0976aad5bf3bd6aec7403163c62cc"}], "stats": {"total": 51, "additions": 26, "deletions": 25}, "files": [{"sha": "e9227f7ce1619f401355e7a22d66f537b21fb5c8", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/69092ffdf23f5be5b2a9cbdd3145daed5004b2b2/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69092ffdf23f5be5b2a9cbdd3145daed5004b2b2/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=69092ffdf23f5be5b2a9cbdd3145daed5004b2b2", "patch": "@@ -37,6 +37,7 @@ pub use self::Count::*;\n \n use std::str;\n use std::string;\n+use std::iter;\n \n /// A piece is a portion of the format string which represents the next part\n /// to emit. These are emitted as a stream by the `Parser` class.\n@@ -141,7 +142,7 @@ pub enum Count<'a> {\n /// necessary there's probably lots of room for improvement performance-wise.\n pub struct Parser<'a> {\n     input: &'a str,\n-    cur: str::CharIndices<'a>,\n+    cur: iter::Peekable<str::CharIndices<'a>>,\n     /// Error messages accumulated during parsing\n     pub errors: Vec<string::String>,\n }\n@@ -150,8 +151,8 @@ impl<'a> Iterator for Parser<'a> {\n     type Item = Piece<'a>;\n \n     fn next(&mut self) -> Option<Piece<'a>> {\n-        match self.cur.clone().next() {\n-            Some((pos, '{')) => {\n+        match self.cur.peek() {\n+            Some(&(pos, '{')) => {\n                 self.cur.next();\n                 if self.consume('{') {\n                     Some(String(self.string(pos + 1)))\n@@ -161,7 +162,7 @@ impl<'a> Iterator for Parser<'a> {\n                     ret\n                 }\n             }\n-            Some((pos, '}')) => {\n+            Some(&(pos, '}')) => {\n                 self.cur.next();\n                 if self.consume('}') {\n                     Some(String(self.string(pos + 1)))\n@@ -170,7 +171,7 @@ impl<'a> Iterator for Parser<'a> {\n                     None\n                 }\n             }\n-            Some((pos, _)) => { Some(String(self.string(pos))) }\n+            Some(&(pos, _)) => { Some(String(self.string(pos))) }\n             None => None\n         }\n     }\n@@ -181,7 +182,7 @@ impl<'a> Parser<'a> {\n     pub fn new(s: &'a str) -> Parser<'a> {\n         Parser {\n             input: s,\n-            cur: s.char_indices(),\n+            cur: s.char_indices().peekable(),\n             errors: vec!(),\n         }\n     }\n@@ -197,8 +198,8 @@ impl<'a> Parser<'a> {\n     /// the current position, then the current iterator isn't moved and false is\n     /// returned, otherwise the character is consumed and true is returned.\n     fn consume(&mut self, c: char) -> bool {\n-        match self.cur.clone().next() {\n-            Some((_, maybe)) if c == maybe => {\n+        match self.cur.peek() {\n+            Some(&(_, maybe)) if c == maybe => {\n                 self.cur.next();\n                 true\n             }\n@@ -210,11 +211,11 @@ impl<'a> Parser<'a> {\n     /// found, an error is emitted.\n     fn must_consume(&mut self, c: char) {\n         self.ws();\n-        match self.cur.clone().next() {\n-            Some((_, maybe)) if c == maybe => {\n+        match self.cur.peek() {\n+            Some(&(_, maybe)) if c == maybe => {\n                 self.cur.next();\n             }\n-            Some((_, other)) => {\n+            Some(&(_, other)) => {\n                 self.err(&format!(\"expected `{:?}`, found `{:?}`\", c,\n                                   other));\n             }\n@@ -229,8 +230,8 @@ impl<'a> Parser<'a> {\n     /// character\n     fn ws(&mut self) {\n         loop {\n-            match self.cur.clone().next() {\n-                Some((_, c)) if c.is_whitespace() => { self.cur.next(); }\n+            match self.cur.peek() {\n+                Some(&(_, c)) if c.is_whitespace() => { self.cur.next(); }\n                 Some(..) | None => { return }\n             }\n         }\n@@ -241,8 +242,8 @@ impl<'a> Parser<'a> {\n     fn string(&mut self, start: usize) -> &'a str {\n         loop {\n             // we may not consume the character, so clone the iterator\n-            match self.cur.clone().next() {\n-                Some((pos, '}')) | Some((pos, '{')) => {\n+            match self.cur.peek() {\n+                Some(&(pos, '}')) | Some(&(pos, '{')) => {\n                     return &self.input[start..pos];\n                 }\n                 Some(..) => { self.cur.next(); }\n@@ -269,8 +270,8 @@ impl<'a> Parser<'a> {\n         match self.integer() {\n             Some(i) => { ArgumentIs(i) }\n             None => {\n-                match self.cur.clone().next() {\n-                    Some((_, c)) if c.is_alphabetic() => {\n+                match self.cur.peek() {\n+                    Some(&(_, c)) if c.is_alphabetic() => {\n                         ArgumentNamed(self.word())\n                     }\n                     _ => ArgumentNext\n@@ -293,8 +294,8 @@ impl<'a> Parser<'a> {\n         if !self.consume(':') { return spec }\n \n         // fill character\n-        match self.cur.clone().next() {\n-            Some((_, c)) => {\n+        match self.cur.peek() {\n+            Some(&(_, c)) => {\n                 match self.cur.clone().skip(1).next() {\n                     Some((_, '>')) | Some((_, '<')) | Some((_, '^')) => {\n                         spec.fill = Some(c);\n@@ -392,20 +393,20 @@ impl<'a> Parser<'a> {\n     /// be an alphabetic character followed by any number of alphanumeric\n     /// characters.\n     fn word(&mut self) -> &'a str {\n-        let start = match self.cur.clone().next() {\n-            Some((pos, c)) if c.is_xid_start() => {\n+        let start = match self.cur.peek() {\n+            Some(&(pos, c)) if c.is_xid_start() => {\n                 self.cur.next();\n                 pos\n             }\n             Some(..) | None => { return &self.input[..0]; }\n         };\n         let end;\n         loop {\n-            match self.cur.clone().next() {\n-                Some((_, c)) if c.is_xid_continue() => {\n+            match self.cur.peek() {\n+                Some(&(_, c)) if c.is_xid_continue() => {\n                     self.cur.next();\n                 }\n-                Some((pos, _)) => { end = pos; break }\n+                Some(&(pos, _)) => { end = pos; break }\n                 None => { end = self.input.len(); break }\n             }\n         }\n@@ -417,7 +418,7 @@ impl<'a> Parser<'a> {\n     fn integer(&mut self) -> Option<usize> {\n         let mut cur = 0;\n         let mut found = false;\n-        while let Some((_, c)) = self.cur.clone().next() {\n+        while let Some(&(_, c)) = self.cur.peek() {\n             if let Some(i) = c.to_digit(10) {\n                 cur = cur * 10 + i as usize;\n                 found = true;"}]}