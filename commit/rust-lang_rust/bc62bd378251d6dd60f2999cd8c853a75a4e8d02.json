{"sha": "bc62bd378251d6dd60f2999cd8c853a75a4e8d02", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNjJiZDM3ODI1MWQ2ZGQ2MGYyOTk5Y2Q4Yzg1M2E3NWE0ZThkMDI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-17T18:59:09Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-19T18:02:51Z"}, "message": "libsyntax: make enum variants take refs", "tree": {"sha": "7f27b1abaab38625605525514b542f38d5968a11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f27b1abaab38625605525514b542f38d5968a11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc62bd378251d6dd60f2999cd8c853a75a4e8d02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc62bd378251d6dd60f2999cd8c853a75a4e8d02", "html_url": "https://github.com/rust-lang/rust/commit/bc62bd378251d6dd60f2999cd8c853a75a4e8d02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59ba4fc1042bb83dc6899462649d70a0141ff8ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/59ba4fc1042bb83dc6899462649d70a0141ff8ca", "html_url": "https://github.com/rust-lang/rust/commit/59ba4fc1042bb83dc6899462649d70a0141ff8ca"}], "stats": {"total": 254, "additions": 150, "deletions": 104}, "files": [{"sha": "74f67808a5e972550afc9773f6beaa599a83ed4c", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=bc62bd378251d6dd60f2999cd8c853a75a4e8d02", "patch": "@@ -193,7 +193,7 @@ pub fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n         cx.local_id += 1u;\n     }\n     match fk {\n-        visit::fk_dtor(tps, ref attrs, self_id, parent_id) => {\n+        visit::fk_dtor(ref tps, ref attrs, self_id, parent_id) => {\n             let dt = @spanned {\n                 node: ast::struct_dtor_ {\n                     id: id,\n@@ -203,7 +203,7 @@ pub fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n                 },\n                 span: sp,\n             };\n-            cx.map.insert(id, node_dtor(/* FIXME (#2543) */ copy tps, dt,\n+            cx.map.insert(id, node_dtor(/* FIXME (#2543) */ copy *tps, dt,\n                                         parent_id,\n                                         @/* FIXME (#2543) */ copy cx.path));\n       }\n@@ -286,7 +286,7 @@ pub fn map_item(i: @item, &&cx: @mut Ctx, v: vt) {\n         map_struct_def(struct_def, node_item(i, item_path), i.ident, cx,\n                        v);\n       }\n-      item_trait(_, traits, ref methods) => {\n+      item_trait(_, ref traits, ref methods) => {\n         for traits.each |p| {\n             cx.map.insert(p.ref_id, node_item(i, item_path));\n         }"}, {"sha": "a82ad762e229f8ba4f2cf29321e677e83faa2476", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=bc62bd378251d6dd60f2999cd8c853a75a4e8d02", "patch": "@@ -327,8 +327,8 @@ pub impl inlined_item_utils for inlined_item {\n             ii_item(i) => (v.visit_item)(i, e, v),\n             ii_foreign(i) => (v.visit_foreign_item)(i, e, v),\n             ii_method(_, m) => visit::visit_method_helper(m, e, v),\n-            ii_dtor(ref dtor, _, tps, parent_id) => {\n-              visit::visit_struct_dtor_helper((*dtor), tps, parent_id, e, v);\n+            ii_dtor(/*bad*/ copy dtor, _, /*bad*/ copy tps, parent_id) => {\n+                visit::visit_struct_dtor_helper(dtor, tps, parent_id, e, v);\n             }\n         }\n     }"}, {"sha": "2809d1dcc563259d2a79e53b441d1d23a8c555f9", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=bc62bd378251d6dd60f2999cd8c853a75a4e8d02", "patch": "@@ -127,24 +127,24 @@ pub fn expand_auto_encode(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_encode) {\n             match item.node {\n-                ast::item_struct(@ast::struct_def { fields, _}, tps) => {\n+                ast::item_struct(ref struct_def, ref tps) => {\n                     let ser_impl = mk_struct_ser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        fields,\n-                        tps\n+                        struct_def.fields,\n+                        *tps\n                     );\n \n                     ~[filter_attrs(*item), ser_impl]\n                 },\n-                ast::item_enum(ref enum_def, tps) => {\n+                ast::item_enum(ref enum_def, ref tps) => {\n                     let ser_impl = mk_enum_ser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        (*enum_def),\n-                        tps\n+                        *enum_def,\n+                        *tps\n                     );\n \n                     ~[filter_attrs(*item), ser_impl]\n@@ -182,24 +182,24 @@ pub fn expand_auto_decode(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_decode) {\n             match item.node {\n-                ast::item_struct(@ast::struct_def { fields, _}, tps) => {\n+                ast::item_struct(ref struct_def, ref tps) => {\n                     let deser_impl = mk_struct_deser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        fields,\n-                        tps\n+                        struct_def.fields,\n+                        *tps\n                     );\n \n                     ~[filter_attrs(*item), deser_impl]\n                 },\n-                ast::item_enum(ref enum_def, tps) => {\n+                ast::item_enum(ref enum_def, ref tps) => {\n                     let deser_impl = mk_enum_deser_impl(\n                         cx,\n                         item.span,\n                         item.ident,\n-                        (*enum_def),\n-                        tps\n+                        *enum_def,\n+                        *tps\n                     );\n \n                     ~[filter_attrs(*item), deser_impl]\n@@ -410,7 +410,7 @@ fn mk_impl(\n     ident: ast::ident,\n     ty_param: ast::ty_param,\n     path: @ast::path,\n-    tps: ~[ast::ty_param],\n+    tps: &[ast::ty_param],\n     f: fn(@ast::Ty) -> @ast::method\n ) -> @ast::item {\n     // All the type parameters need to bound to the trait.\n@@ -458,7 +458,7 @@ fn mk_ser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    tps: ~[ast::ty_param],\n+    tps: &[ast::ty_param],\n     body: @ast::expr\n ) -> @ast::item {\n     // Make a path to the std::serialize::Encodable typaram.\n@@ -666,8 +666,8 @@ fn mk_struct_ser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    fields: ~[@ast::struct_field],\n-    tps: ~[ast::ty_param]\n+    fields: &[@ast::struct_field],\n+    tps: &[ast::ty_param]\n ) -> @ast::item {\n     let fields = do mk_struct_fields(fields).mapi |idx, field| {\n         // ast for `|| self.$(name).encode(__s)`\n@@ -808,7 +808,7 @@ struct field {\n     mutbl: ast::mutability,\n }\n \n-fn mk_struct_fields(fields: ~[@ast::struct_field]) -> ~[field] {\n+fn mk_struct_fields(fields: &[@ast::struct_field]) -> ~[field] {\n     do fields.map |field| {\n         let (ident, mutbl) = match field.node.kind {\n             ast::named_field(ident, mutbl, _) => (ident, mutbl),"}, {"sha": "cc42a0992cbedd3be70c6d661ab610e6060f49d4", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=bc62bd378251d6dd60f2999cd8c853a75a4e8d02", "patch": "@@ -54,27 +54,27 @@ pub impl proto::visitor<(), (), ()> for ext_ctxt {\n     fn visit_message(&self, name: ~str, _span: span, _tys: &[@ast::Ty],\n                      this: state, next: Option<next_state>) {\n         match next {\n-          Some(next_state { state: ref next, tys: next_tys }) => {\n+          Some(ref next_state) => {\n             let proto = this.proto;\n-            if !proto.has_state((*next)) {\n+            if !proto.has_state(next_state.state) {\n                 // This should be a span fatal, but then we need to\n                 // track span information.\n                 self.span_err(\n-                    proto.get_state((*next)).span,\n+                    proto.get_state(next_state.state).span,\n                     fmt!(\"message %s steps to undefined state, %s\",\n-                         name, (*next)));\n+                         name, next_state.state));\n             }\n             else {\n-                let next = proto.get_state((*next));\n+                let next = proto.get_state(next_state.state);\n \n-                if next.ty_params.len() != next_tys.len() {\n+                if next.ty_params.len() != next_state.tys.len() {\n                     self.span_err(\n                         next.span, // use a real span\n                         fmt!(\"message %s target (%s) \\\n                               needs %u type parameters, but got %u\",\n                              name, next.name,\n                              next.ty_params.len(),\n-                             next_tys.len()));\n+                             next_state.tys.len()));\n                 }\n             }\n           }"}, {"sha": "48bd8b03297424ee8e8ff787f26de8ad1d05d8b4", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=bc62bd378251d6dd60f2999cd8c853a75a4e8d02", "patch": "@@ -50,16 +50,13 @@ pub impl gen_send for message {\n     fn gen_send(&self, cx: ext_ctxt, try: bool) -> @ast::item {\n         debug!(\"pipec: gen_send\");\n         match *self {\n-          message(ref _id, span, tys, this,\n-                  Some(next_state {state: ref next, tys: next_tys})) => {\n+          message(ref _id, span, ref tys, this, Some(ref next_state)) => {\n             debug!(\"pipec: next state exists\");\n-            let next = this.proto.get_state((*next));\n-            assert next_tys.len() == next.ty_params.len();\n+            let next = this.proto.get_state(next_state.state);\n+            assert next_state.tys.len() == next.ty_params.len();\n             let arg_names = tys.mapi(|i, _ty| cx.ident_of(~\"x_\"+i.to_str()));\n \n-            let args_ast = (arg_names, tys).map(\n-                |n, t| cx.arg(*n, *t)\n-            );\n+            let args_ast = (arg_names, *tys).map(|n, t| cx.arg(*n, *t));\n \n             let pipe_ty = cx.ty_path_ast_builder(\n                 path(~[this.data_name()], span)\n@@ -119,7 +116,7 @@ pub impl gen_send for message {\n \n             let mut rty = cx.ty_path_ast_builder(path(~[next.data_name()],\n                                                       span)\n-                                                 .add_tys(next_tys));\n+                                                 .add_tys(next_state.tys));\n             if try {\n                 rty = cx.ty_option(rty);\n             }\n@@ -134,13 +131,13 @@ pub impl gen_send for message {\n                             cx.expr_block(body))\n           }\n \n-            message(ref _id, span, tys, this, None) => {\n+            message(ref _id, span, ref tys, this, None) => {\n                 debug!(\"pipec: no next state\");\n                 let arg_names = tys.mapi(|i, _ty| (~\"x_\" + i.to_str()));\n \n-                let args_ast = (arg_names, tys).map(\n-                    |n, t| cx.arg(cx.ident_of(*n), *t)\n-                );\n+                let args_ast = do (arg_names, *tys).map |n, t| {\n+                    cx.arg(cx.ident_of(*n), *t)\n+                };\n \n                 let args_ast = vec::append(\n                     ~[cx.arg(cx.ident_of(~\"pipe\"),\n@@ -219,8 +216,8 @@ pub impl to_type_decls for state {\n             let message(name, span, tys, this, next) = *m;\n \n             let tys = match next {\n-              Some(next_state { state: ref next, tys: next_tys }) => {\n-                let next = this.proto.get_state((*next));\n+              Some(ref next_state) => {\n+                let next = this.proto.get_state((next_state.state));\n                 let next_name = cx.str_of(next.data_name());\n \n                 let dir = match this.dir {\n@@ -232,7 +229,7 @@ pub impl to_type_decls for state {\n                                 cx.ty_path_ast_builder(\n                                     path(~[cx.ident_of(dir),\n                                            cx.ident_of(next_name)], span)\n-                                    .add_tys(next_tys)))\n+                                    .add_tys(next_state.tys)))\n               }\n               None => tys\n             };"}, {"sha": "dd0dfd8e44377323261e9666c957fc5822554192", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=bc62bd378251d6dd60f2999cd8c853a75a4e8d02", "patch": "@@ -59,12 +59,13 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                                      arg_reader as reader, argument_gram);\n \n     // Extract the arguments:\n-    let lhses:~[@named_match] = match argument_map.get(&lhs_nm) {\n-      @matched_seq(s, _) => s,\n-      _ => cx.span_bug(sp, ~\"wrong-structured lhs\")\n+    let lhses = match argument_map.get(&lhs_nm) {\n+        @matched_seq(ref s, _) => /* FIXME (#2543) */ copy *s,\n+        _ => cx.span_bug(sp, ~\"wrong-structured lhs\")\n     };\n-    let rhses:~[@named_match] = match argument_map.get(&rhs_nm) {\n-      @matched_seq(s, _) => s,\n+\n+    let rhses = match argument_map.get(&rhs_nm) {\n+      @matched_seq(ref s, _) => /* FIXME (#2543) */ copy *s,\n       _ => cx.span_bug(sp, ~\"wrong-structured rhs\")\n     };\n "}, {"sha": "dacb6f60e37643226e0249ad29ec42c2f32d14ae", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=bc62bd378251d6dd60f2999cd8c853a75a4e8d02", "patch": "@@ -82,10 +82,10 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n         node:\n             match mi.node {\n                 meta_word(ref id) => meta_word((*id)),\n-                meta_list(ref id, mis) => {\n-                    let fold_meta_item = |x|fold_meta_item_(x, fld);\n-                    meta_list(/* FIXME: (#2543) */ copy (*id),\n-                        vec::map(mis, |e| fold_meta_item(*e)))\n+                meta_list(ref id, ref mis) => {\n+                    let fold_meta_item = |x| fold_meta_item_(x, fld);\n+                    meta_list(/* FIXME: (#2543) */ copy *id,\n+                              mis.map(|e| fold_meta_item(*e)))\n                 }\n                 meta_name_value(ref id, s) => {\n                     meta_name_value((*id), /* FIXME (#2543) */ copy s)\n@@ -215,42 +215,44 @@ fn noop_fold_struct_field(&&sf: @struct_field, fld: ast_fold)\n pub fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n     match i {\n         item_const(t, e) => item_const(fld.fold_ty(t), fld.fold_expr(e)),\n-        item_fn(decl, purity, typms, ref body) => {\n-            item_fn(fold_fn_decl(decl, fld),\n+        item_fn(ref decl, purity, ref typms, ref body) => {\n+            item_fn(fold_fn_decl(/* FIXME (#2543) */ copy *decl, fld),\n                     purity,\n-                    fold_ty_params(typms, fld),\n-                    fld.fold_block((*body)))\n+                    fold_ty_params(/* FIXME (#2543) */ copy *typms, fld),\n+                    fld.fold_block(*body))\n         }\n         item_mod(m) => item_mod(fld.fold_mod(m)),\n         item_foreign_mod(nm) => item_foreign_mod(fld.fold_foreign_mod(nm)),\n         item_ty(t, typms) => item_ty(fld.fold_ty(t),\n                                      fold_ty_params(typms, fld)),\n-        item_enum(ref enum_definition, typms) => {\n+        item_enum(ref enum_definition, ref typms) => {\n             item_enum(ast::enum_def(ast::enum_def_ {\n                 variants: enum_definition.variants.map(\n                     |x| fld.fold_variant(*x)),\n                 common: enum_definition.common.map(\n                     |x| fold_struct_def(*x, fld)),\n-            }), fold_ty_params(typms, fld))\n+            }), fold_ty_params(/* FIXME (#2543) */ copy *typms, fld))\n         }\n-        item_struct(struct_def, typms) => {\n-            let struct_def = fold_struct_def(struct_def, fld);\n-              item_struct(struct_def, /* FIXME (#2543) */ copy typms)\n+        item_struct(ref struct_def, ref typms) => {\n+            let struct_def = fold_struct_def(\n+                /* FIXME (#2543) */ copy *struct_def,\n+                fld);\n+            item_struct(struct_def, /* FIXME (#2543) */ copy *typms)\n         }\n-        item_impl(tps, ifce, ty, ref methods) => {\n-            item_impl(fold_ty_params(tps, fld),\n+        item_impl(ref tps, ifce, ty, ref methods) => {\n+            item_impl(fold_ty_params(/* FIXME (#2543) */ copy *tps, fld),\n                       ifce.map(|p| fold_trait_ref(*p, fld)),\n                       fld.fold_ty(ty),\n                       methods.map(|x| fld.fold_method(*x)))\n         }\n-        item_trait(tps, traits, ref methods) => {\n+        item_trait(ref tps, ref traits, ref methods) => {\n             let methods = do methods.map |method| {\n                 match *method {\n                     required(*) => copy *method,\n                     provided(method) => provided(fld.fold_method(method))\n                 }\n             };\n-            item_trait(fold_ty_params(tps, fld),\n+            item_trait(fold_ty_params(/* FIXME (#2543) */ copy *tps, fld),\n                        traits.map(|p| fold_trait_ref(*p, fld)),\n                        methods)\n         }\n@@ -466,14 +468,14 @@ pub fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n             expr_match(fld.fold_expr(expr),\n                      vec::map((*arms), |x| fld.fold_arm(*x)))\n           }\n-          expr_fn(proto, decl, ref body, _) => {\n+          expr_fn(proto, ref decl, ref body, _) => {\n             expr_fn(proto,\n-                    fold_fn_decl(decl, fld),\n+                    fold_fn_decl(/* FIXME (#2543) */ copy *decl, fld),\n                     fld.fold_block(*body),\n                     @())\n           }\n-          expr_fn_block(decl, ref body) => {\n-            expr_fn_block(fold_fn_decl(decl, fld),\n+          expr_fn_block(ref decl, ref body) => {\n+            expr_fn_block(fold_fn_decl(/* FIXME (#2543) */ copy *decl, fld),\n                           fld.fold_block(*body))\n           }\n           expr_block(ref blk) => expr_block(fld.fold_block((*blk))),"}, {"sha": "40ba27c495c71e16b46266933f097b4b29877ede", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=bc62bd378251d6dd60f2999cd8c853a75a4e8d02", "patch": "@@ -495,9 +495,16 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n         end(s); // end the outer cbox\n \n       }\n-      ast::item_fn(decl, purity, typarams, ref body) => {\n-        print_fn(s, decl, Some(purity), item.ident, typarams, None,\n-                 item.vis);\n+      ast::item_fn(ref decl, purity, ref typarams, ref body) => {\n+        print_fn(\n+            s,\n+            /* FIXME (#2543) */ copy *decl,\n+            Some(purity),\n+            item.ident,\n+            /* FIXME (#2543) */ copy *typarams,\n+            None,\n+            item.vis\n+        );\n         word(s.s, ~\" \");\n         print_block_with_attrs(s, (*body), item.attrs);\n       }\n@@ -539,9 +546,15 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n         word(s.s, ~\";\");\n         end(s); // end the outer ibox\n       }\n-      ast::item_enum(ref enum_definition, params) => {\n-        print_enum_def(s, (*enum_definition), params, item.ident,\n-                       item.span, item.vis);\n+      ast::item_enum(ref enum_definition, ref params) => {\n+        print_enum_def(\n+            s,\n+            *enum_definition,\n+            /* FIXME (#2543) */ copy *params,\n+            item.ident,\n+            item.span,\n+            item.vis\n+        );\n       }\n       ast::item_struct(struct_def, tps) => {\n           head(s, visibility_qualified(item.vis, ~\"struct\"));\n@@ -577,13 +590,13 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n             bclose(s, item.span);\n         }\n       }\n-      ast::item_trait(tps, traits, ref methods) => {\n+      ast::item_trait(ref tps, ref traits, ref methods) => {\n         head(s, visibility_qualified(item.vis, ~\"trait\"));\n         print_ident(s, item.ident);\n-        print_type_params(s, tps);\n-        if vec::len(traits) != 0u {\n+        print_type_params(s, /* FIXME (#2543) */ copy *tps);\n+        if traits.len() != 0u {\n             word(s.s, ~\":\");\n-            for vec::each(traits) |trait_| {\n+            for traits.each |trait_| {\n                 nbsp(s);\n                 print_path(s, trait_.path, false);\n             }\n@@ -619,7 +632,7 @@ pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n         ident == enum_definition.variants[0].node.name;\n     if newtype {\n         match enum_definition.variants[0].node.kind {\n-            ast::tuple_variant_kind(args) if args.len() == 1 => {}\n+            ast::tuple_variant_kind(ref args) if args.len() == 1 => {}\n             _ => newtype = false\n         }\n     }\n@@ -1325,24 +1338,24 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         }\n         bclose_(s, expr.span, match_indent_unit);\n       }\n-      ast::expr_fn(sigil, decl, ref body, _) => {\n+      ast::expr_fn(sigil, ref decl, ref body, _) => {\n         // containing cbox, will be closed by print-block at }\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block at start\n         ibox(s, 0u);\n         print_fn_header_info(s, None, None, ast::Many,\n                              Some(sigil), ast::inherited);\n-        print_fn_args_and_ret(s, decl, None);\n+        print_fn_args_and_ret(s, /* FIXME (#2543) */ copy *decl, None);\n         space(s.s);\n         print_block(s, (*body));\n       }\n-      ast::expr_fn_block(decl, ref body) => {\n+      ast::expr_fn_block(ref decl, ref body) => {\n         // in do/for blocks we don't want to show an empty\n         // argument list, but at this point we don't know which\n         // we are inside.\n         //\n         // if !decl.inputs.is_empty() {\n-        print_fn_block_args(s, decl);\n+        print_fn_block_args(s, /* FIXME (#2543) */ copy *decl);\n         space(s.s);\n         // }\n         assert (*body).node.stmts.is_empty();\n@@ -1809,10 +1822,15 @@ pub fn print_meta_item(s: @ps, &&item: @ast::meta_item) {\n         word_space(s, ~\"=\");\n         print_literal(s, @value);\n       }\n-      ast::meta_list(ref name, items) => {\n+      ast::meta_list(ref name, ref items) => {\n         word(s.s, (*name));\n         popen(s);\n-        commasep(s, consistent, items, print_meta_item);\n+        commasep(\n+            s,\n+            consistent,\n+            /* FIXME (#2543) */ copy *items,\n+            print_meta_item\n+        );\n         pclose(s);\n       }\n     }"}, {"sha": "3701607ffc13faa0f329d6ace987f6ceed27bb3a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc62bd378251d6dd60f2999cd8c853a75a4e8d02/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=bc62bd378251d6dd60f2999cd8c853a75a4e8d02", "patch": "@@ -137,11 +137,20 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         (v.visit_ty)(t, e, v);\n         (v.visit_expr)(ex, e, v);\n       }\n-      item_fn(decl, purity, tp, ref body) => {\n-        (v.visit_fn)(fk_item_fn(/* FIXME (#2543) */ copy i.ident,\n-                              /* FIXME (#2543) */ copy tp,\n-                              purity), decl, (*body),\n-                   i.span, i.id, e, v);\n+      item_fn(ref decl, purity, ref tp, ref body) => {\n+        (v.visit_fn)(\n+            fk_item_fn(\n+                /* FIXME (#2543) */ copy i.ident,\n+                /* FIXME (#2543) */ copy *tp,\n+                purity\n+            ),\n+            /* FIXME (#2543) */ copy *decl,\n+            (*body),\n+            i.span,\n+            i.id,\n+            e,\n+            v\n+        );\n       }\n       item_mod(m) => (v.visit_mod)(m, i.span, i.id, e, v),\n       item_foreign_mod(nm) => {\n@@ -152,9 +161,14 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         (v.visit_ty)(t, e, v);\n         (v.visit_ty_params)(tps, e, v);\n       }\n-      item_enum(ref enum_definition, tps) => {\n-        (v.visit_ty_params)(tps, e, v);\n-        visit_enum_def((*enum_definition), tps, e, v);\n+      item_enum(ref enum_definition, ref tps) => {\n+        (v.visit_ty_params)(/* FIXME (#2543) */ copy *tps, e, v);\n+        visit_enum_def(\n+            *enum_definition,\n+            /* FIXME (#2543) */ copy *tps,\n+            e,\n+            v\n+        );\n       }\n       item_impl(tps, traits, ty, methods) => {\n         (v.visit_ty_params)(tps, e, v);\n@@ -170,8 +184,8 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         (v.visit_ty_params)(tps, e, v);\n         (v.visit_struct_def)(struct_def, i.ident, tps, i.id, e, v);\n       }\n-      item_trait(tps, traits, ref methods) => {\n-        (v.visit_ty_params)(tps, e, v);\n+      item_trait(ref tps, ref traits, ref methods) => {\n+        (v.visit_ty_params)(/* FIXME (#2543) */ copy *tps, e, v);\n         for traits.each |p| { visit_path(p.path, e, v); }\n         for (*methods).each |m| {\n             (v.visit_trait_method)(*m, e, v);\n@@ -460,13 +474,27 @@ pub fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         (v.visit_expr)(x, e, v);\n         for (*arms).each |a| { (v.visit_arm)(*a, e, v); }\n       }\n-      expr_fn(proto, decl, ref body, _) => {\n-        (v.visit_fn)(fk_anon(proto), decl, (*body),\n-                     ex.span, ex.id, e, v);\n-      }\n-      expr_fn_block(decl, ref body) => {\n-        (v.visit_fn)(fk_fn_block, decl, (*body),\n-                     ex.span, ex.id, e, v);\n+      expr_fn(proto, ref decl, ref body, _) => {\n+        (v.visit_fn)(\n+            fk_anon(proto),\n+            /* FIXME (#2543) */ copy *decl,\n+            *body,\n+            ex.span,\n+            ex.id,\n+            e,\n+            v\n+        );\n+      }\n+      expr_fn_block(ref decl, ref body) => {\n+        (v.visit_fn)(\n+            fk_fn_block,\n+            /* FIXME (#2543) */ copy *decl,\n+            *body,\n+            ex.span,\n+            ex.id,\n+            e,\n+            v\n+        );\n       }\n       expr_block(ref b) => (v.visit_block)((*b), e, v),\n       expr_assign(a, b) => {"}]}