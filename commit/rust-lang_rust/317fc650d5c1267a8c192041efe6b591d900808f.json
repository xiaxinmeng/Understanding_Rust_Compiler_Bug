{"sha": "317fc650d5c1267a8c192041efe6b591d900808f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxN2ZjNjUwZDVjMTI2N2E4YzE5MjA0MWVmZTZiNTkxZDkwMDgwOGY=", "commit": {"author": {"name": "Timo Freiberg", "email": "timo.freiberg@gmail.com", "date": "2020-04-16T21:53:25Z"}, "committer": {"name": "Timo Freiberg", "email": "timo.freiberg@gmail.com", "date": "2020-04-21T21:04:44Z"}, "message": "Make add_function generate functions in other modules via qualified path", "tree": {"sha": "90f572d14abd743603bc17e8e3a791b922aa3719", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90f572d14abd743603bc17e8e3a791b922aa3719"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/317fc650d5c1267a8c192041efe6b591d900808f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/317fc650d5c1267a8c192041efe6b591d900808f", "html_url": "https://github.com/rust-lang/rust/commit/317fc650d5c1267a8c192041efe6b591d900808f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/317fc650d5c1267a8c192041efe6b591d900808f/comments", "author": {"login": "TimoFreiberg", "id": 5281645, "node_id": "MDQ6VXNlcjUyODE2NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5281645?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimoFreiberg", "html_url": "https://github.com/TimoFreiberg", "followers_url": "https://api.github.com/users/TimoFreiberg/followers", "following_url": "https://api.github.com/users/TimoFreiberg/following{/other_user}", "gists_url": "https://api.github.com/users/TimoFreiberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimoFreiberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimoFreiberg/subscriptions", "organizations_url": "https://api.github.com/users/TimoFreiberg/orgs", "repos_url": "https://api.github.com/users/TimoFreiberg/repos", "events_url": "https://api.github.com/users/TimoFreiberg/events{/privacy}", "received_events_url": "https://api.github.com/users/TimoFreiberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimoFreiberg", "id": 5281645, "node_id": "MDQ6VXNlcjUyODE2NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5281645?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimoFreiberg", "html_url": "https://github.com/TimoFreiberg", "followers_url": "https://api.github.com/users/TimoFreiberg/followers", "following_url": "https://api.github.com/users/TimoFreiberg/following{/other_user}", "gists_url": "https://api.github.com/users/TimoFreiberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimoFreiberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimoFreiberg/subscriptions", "organizations_url": "https://api.github.com/users/TimoFreiberg/orgs", "repos_url": "https://api.github.com/users/TimoFreiberg/repos", "events_url": "https://api.github.com/users/TimoFreiberg/events{/privacy}", "received_events_url": "https://api.github.com/users/TimoFreiberg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "546f9ee7a7eb1d208fe279ec469b5981d47934fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/546f9ee7a7eb1d208fe279ec469b5981d47934fc", "html_url": "https://github.com/rust-lang/rust/commit/546f9ee7a7eb1d208fe279ec469b5981d47934fc"}], "stats": {"total": 234, "additions": 205, "deletions": 29}, "files": [{"sha": "e4fa9ee366e44e3b34a74fb8ab4b9af0f30d0e1b", "filename": "crates/ra_assists/src/doc_tests/generated.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/317fc650d5c1267a8c192041efe6b591d900808f/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/317fc650d5c1267a8c192041efe6b591d900808f/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fdoc_tests%2Fgenerated.rs?ref=317fc650d5c1267a8c192041efe6b591d900808f", "patch": "@@ -66,15 +66,15 @@ fn doctest_add_function() {\n struct Baz;\n fn baz() -> Baz { Baz }\n fn foo() {\n-     bar<|>(\"\", baz());\n+    bar<|>(\"\", baz());\n }\n \n \"#####,\n         r#####\"\n struct Baz;\n fn baz() -> Baz { Baz }\n fn foo() {\n-     bar(\"\", baz());\n+    bar(\"\", baz());\n }\n \n fn bar(arg: &str, baz: Baz) {"}, {"sha": "a1261fe15736ab66d1a91b99eddffc176a3f1ff3", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 195, "deletions": 24, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/317fc650d5c1267a8c192041efe6b591d900808f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/317fc650d5c1267a8c192041efe6b591d900808f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=317fc650d5c1267a8c192041efe6b591d900808f", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{\n };\n \n use crate::{Assist, AssistCtx, AssistId};\n-use ast::{edit::IndentLevel, ArgListOwner, CallExpr, Expr};\n+use ast::{edit::IndentLevel, ArgListOwner, ModuleItemOwner};\n use hir::HirDisplay;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n@@ -16,7 +16,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n // struct Baz;\n // fn baz() -> Baz { Baz }\n // fn foo() {\n-//      bar<|>(\"\", baz());\n+//     bar<|>(\"\", baz());\n // }\n //\n // ```\n@@ -25,7 +25,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n // struct Baz;\n // fn baz() -> Baz { Baz }\n // fn foo() {\n-//      bar(\"\", baz());\n+//     bar(\"\", baz());\n // }\n //\n // fn bar(arg: &str, baz: Baz) {\n@@ -38,16 +38,24 @@ pub(crate) fn add_function(ctx: AssistCtx) -> Option<Assist> {\n     let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n     let path = path_expr.path()?;\n \n-    if path.qualifier().is_some() {\n-        return None;\n-    }\n-\n     if ctx.sema.resolve_path(&path).is_some() {\n         // The function call already resolves, no need to add a function\n         return None;\n     }\n \n-    let function_builder = FunctionBuilder::from_call(&ctx, &call)?;\n+    let target_module = if let Some(qualifier) = path.qualifier() {\n+        if let Some(hir::PathResolution::Def(hir::ModuleDef::Module(resolved))) =\n+            ctx.sema.resolve_path(&qualifier)\n+        {\n+            Some(resolved.definition_source(ctx.sema.db).value)\n+        } else {\n+            return None;\n+        }\n+    } else {\n+        None\n+    };\n+\n+    let function_builder = FunctionBuilder::from_call(&ctx, &call, &path, target_module)?;\n \n     ctx.add_assist(AssistId(\"add_function\"), \"Add function\", |edit| {\n         edit.target(call.syntax().text_range());\n@@ -66,26 +74,54 @@ struct FunctionTemplate {\n }\n \n struct FunctionBuilder {\n-    append_fn_at: SyntaxNode,\n+    target: GeneratedFunctionTarget,\n     fn_name: ast::Name,\n     type_params: Option<ast::TypeParamList>,\n     params: ast::ParamList,\n }\n \n impl FunctionBuilder {\n-    fn from_call(ctx: &AssistCtx, call: &ast::CallExpr) -> Option<Self> {\n-        let append_fn_at = next_space_for_fn(&call)?;\n-        let fn_name = fn_name(&call)?;\n+    /// Prepares a generated function that matches `call` in `generate_in`\n+    /// (or as close to `call` as possible, if `generate_in` is `None`)\n+    fn from_call(\n+        ctx: &AssistCtx,\n+        call: &ast::CallExpr,\n+        path: &ast::Path,\n+        generate_in: Option<hir::ModuleSource>,\n+    ) -> Option<Self> {\n+        let target = if let Some(generate_in_module) = generate_in {\n+            next_space_for_fn_in_module(generate_in_module)?\n+        } else {\n+            next_space_for_fn_after_call_site(&call)?\n+        };\n+        let fn_name = fn_name(&path)?;\n         let (type_params, params) = fn_args(ctx, &call)?;\n-        Some(Self { append_fn_at, fn_name, type_params, params })\n+        Some(Self { target, fn_name, type_params, params })\n     }\n     fn render(self) -> Option<FunctionTemplate> {\n         let placeholder_expr = ast::make::expr_todo();\n         let fn_body = ast::make::block_expr(vec![], Some(placeholder_expr));\n         let fn_def = ast::make::fn_def(self.fn_name, self.type_params, self.params, fn_body);\n-        let fn_def = ast::make::add_newlines(2, fn_def);\n-        let fn_def = IndentLevel::from_node(&self.append_fn_at).increase_indent(fn_def);\n-        let insert_offset = self.append_fn_at.text_range().end();\n+\n+        let (fn_def, insert_offset) = match self.target {\n+            GeneratedFunctionTarget::BehindItem(it) => {\n+                let with_leading_blank_line = ast::make::add_leading_newlines(2, fn_def);\n+                let indented = IndentLevel::from_node(&it).increase_indent(with_leading_blank_line);\n+                (indented, it.text_range().end())\n+            }\n+            GeneratedFunctionTarget::InEmptyItemList(it) => {\n+                let with_leading_newline = ast::make::add_leading_newlines(1, fn_def);\n+                let indent = IndentLevel::from_node(it.syntax()).indented();\n+                let mut indented = indent.increase_indent(with_leading_newline);\n+                if !item_list_has_whitespace(&it) {\n+                    // In this case we want to make sure there's a newline between the closing\n+                    // function brace and the closing module brace (so it doesn't end in `}}`).\n+                    indented = ast::make::add_trailing_newlines(1, indented);\n+                }\n+                (indented, it.syntax().text_range().start() + TextUnit::from_usize(1))\n+            }\n+        };\n+\n         let cursor_offset_from_fn_start = fn_def\n             .syntax()\n             .descendants()\n@@ -98,15 +134,25 @@ impl FunctionBuilder {\n     }\n }\n \n-fn fn_name(call: &CallExpr) -> Option<ast::Name> {\n-    let name = call.expr()?.syntax().to_string();\n+/// Returns true if the given ItemList contains whitespace.\n+fn item_list_has_whitespace(it: &ast::ItemList) -> bool {\n+    it.syntax().descendants_with_tokens().find(|it| it.kind() == SyntaxKind::WHITESPACE).is_some()\n+}\n+\n+enum GeneratedFunctionTarget {\n+    BehindItem(SyntaxNode),\n+    InEmptyItemList(ast::ItemList),\n+}\n+\n+fn fn_name(call: &ast::Path) -> Option<ast::Name> {\n+    let name = call.segment()?.syntax().to_string();\n     Some(ast::make::name(&name))\n }\n \n /// Computes the type variables and arguments required for the generated function\n fn fn_args(\n     ctx: &AssistCtx,\n-    call: &CallExpr,\n+    call: &ast::CallExpr,\n ) -> Option<(Option<ast::TypeParamList>, ast::ParamList)> {\n     let mut arg_names = Vec::new();\n     let mut arg_types = Vec::new();\n@@ -158,9 +204,9 @@ fn deduplicate_arg_names(arg_names: &mut Vec<String>) {\n     }\n }\n \n-fn fn_arg_name(fn_arg: &Expr) -> Option<String> {\n+fn fn_arg_name(fn_arg: &ast::Expr) -> Option<String> {\n     match fn_arg {\n-        Expr::CastExpr(cast_expr) => fn_arg_name(&cast_expr.expr()?),\n+        ast::Expr::CastExpr(cast_expr) => fn_arg_name(&cast_expr.expr()?),\n         _ => Some(\n             fn_arg\n                 .syntax()\n@@ -172,7 +218,7 @@ fn fn_arg_name(fn_arg: &Expr) -> Option<String> {\n     }\n }\n \n-fn fn_arg_type(ctx: &AssistCtx, fn_arg: &Expr) -> Option<String> {\n+fn fn_arg_type(ctx: &AssistCtx, fn_arg: &ast::Expr) -> Option<String> {\n     let ty = ctx.sema.type_of_expr(fn_arg)?;\n     if ty.is_unknown() {\n         return None;\n@@ -184,7 +230,7 @@ fn fn_arg_type(ctx: &AssistCtx, fn_arg: &Expr) -> Option<String> {\n /// directly after the current block\n /// We want to write the generated function directly after\n /// fns, impls or macro calls, but inside mods\n-fn next_space_for_fn(expr: &CallExpr) -> Option<SyntaxNode> {\n+fn next_space_for_fn_after_call_site(expr: &ast::CallExpr) -> Option<GeneratedFunctionTarget> {\n     let mut ancestors = expr.syntax().ancestors().peekable();\n     let mut last_ancestor: Option<SyntaxNode> = None;\n     while let Some(next_ancestor) = ancestors.next() {\n@@ -201,7 +247,26 @@ fn next_space_for_fn(expr: &CallExpr) -> Option<SyntaxNode> {\n         }\n         last_ancestor = Some(next_ancestor);\n     }\n-    last_ancestor\n+    last_ancestor.map(GeneratedFunctionTarget::BehindItem)\n+}\n+\n+fn next_space_for_fn_in_module(module: hir::ModuleSource) -> Option<GeneratedFunctionTarget> {\n+    match module {\n+        hir::ModuleSource::SourceFile(it) => {\n+            if let Some(last_item) = it.items().last() {\n+                Some(GeneratedFunctionTarget::BehindItem(last_item.syntax().clone()))\n+            } else {\n+                Some(GeneratedFunctionTarget::BehindItem(it.syntax().clone()))\n+            }\n+        }\n+        hir::ModuleSource::Module(it) => {\n+            if let Some(last_item) = it.item_list().and_then(|it| it.items().last()) {\n+                Some(GeneratedFunctionTarget::BehindItem(last_item.syntax().clone()))\n+            } else {\n+                it.item_list().map(GeneratedFunctionTarget::InEmptyItemList)\n+            }\n+        }\n+    }\n }\n \n #[cfg(test)]\n@@ -713,6 +778,112 @@ fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) {\n         )\n     }\n \n+    #[test]\n+    fn add_function_in_module() {\n+        check_assist(\n+            add_function,\n+            r\"\n+mod bar {}\n+\n+fn foo() {\n+    bar::my_fn<|>()\n+}\n+\",\n+            r\"\n+mod bar {\n+    fn my_fn() {\n+        <|>todo!()\n+    }\n+}\n+\n+fn foo() {\n+    bar::my_fn()\n+}\n+\",\n+        );\n+        check_assist(\n+            add_function,\n+            r\"\n+mod bar {\n+}\n+\n+fn foo() {\n+    bar::my_fn<|>()\n+}\n+\",\n+            r\"\n+mod bar {\n+    fn my_fn() {\n+        <|>todo!()\n+    }\n+}\n+\n+fn foo() {\n+    bar::my_fn()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_in_module_containing_other_items() {\n+        check_assist(\n+            add_function,\n+            r\"\n+mod bar {\n+    fn something_else() {}\n+}\n+\n+fn foo() {\n+    bar::my_fn<|>()\n+}\n+\",\n+            r\"\n+mod bar {\n+    fn something_else() {}\n+\n+    fn my_fn() {\n+        <|>todo!()\n+    }\n+}\n+\n+fn foo() {\n+    bar::my_fn()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn add_function_in_nested_module() {\n+        check_assist(\n+            add_function,\n+            r\"\n+mod bar {\n+    mod baz {\n+    }\n+}\n+\n+fn foo() {\n+    bar::baz::my_fn<|>()\n+}\n+\",\n+            r\"\n+mod bar {\n+    mod baz {\n+        fn my_fn() {\n+            <|>todo!()\n+        }\n+    }\n+}\n+\n+fn foo() {\n+    bar::baz::my_fn()\n+}\n+\",\n+        )\n+    }\n+\n     #[test]\n     fn add_function_not_applicable_if_function_already_exists() {\n         check_assist_not_applicable("}, {"sha": "b0f4803f318fb3ee26a9762f3f8678663e66f0dc", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/317fc650d5c1267a8c192041efe6b591d900808f/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/317fc650d5c1267a8c192041efe6b591d900808f/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=317fc650d5c1267a8c192041efe6b591d900808f", "patch": "@@ -293,11 +293,16 @@ pub fn fn_def(\n     ast_from_text(&format!(\"fn {}{}{} {}\", fn_name, type_params, params, body))\n }\n \n-pub fn add_newlines(amount_of_newlines: usize, t: impl AstNode) -> ast::SourceFile {\n+pub fn add_leading_newlines(amount_of_newlines: usize, t: impl AstNode) -> ast::SourceFile {\n     let newlines = \"\\n\".repeat(amount_of_newlines);\n     ast_from_text(&format!(\"{}{}\", newlines, t.syntax()))\n }\n \n+pub fn add_trailing_newlines(amount_of_newlines: usize, t: impl AstNode) -> ast::SourceFile {\n+    let newlines = \"\\n\".repeat(amount_of_newlines);\n+    ast_from_text(&format!(\"{}{}\", t.syntax(), newlines))\n+}\n+\n fn ast_from_text<N: AstNode>(text: &str) -> N {\n     let parse = SourceFile::parse(text);\n     let node = parse.tree().syntax().descendants().find_map(N::cast).unwrap();"}, {"sha": "6c6943622301109350b75639e08281dc8341c893", "filename": "docs/user/assists.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/317fc650d5c1267a8c192041efe6b591d900808f/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/317fc650d5c1267a8c192041efe6b591d900808f/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=317fc650d5c1267a8c192041efe6b591d900808f", "patch": "@@ -65,15 +65,15 @@ Adds a stub function with a signature matching the function under the cursor.\n struct Baz;\n fn baz() -> Baz { Baz }\n fn foo() {\n-     bar\u2503(\"\", baz());\n+    bar\u2503(\"\", baz());\n }\n \n \n // AFTER\n struct Baz;\n fn baz() -> Baz { Baz }\n fn foo() {\n-     bar(\"\", baz());\n+    bar(\"\", baz());\n }\n \n fn bar(arg: &str, baz: Baz) {"}]}