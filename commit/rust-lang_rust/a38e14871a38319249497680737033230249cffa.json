{"sha": "a38e14871a38319249497680737033230249cffa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzOGUxNDg3MWEzODMxOTI0OTQ5NzY4MDczNzAzMzIzMDI0OWNmZmE=", "commit": {"author": {"name": "Douglas Young", "email": "rcxdude@gmail.com", "date": "2014-03-02T18:41:17Z"}, "committer": {"name": "Douglas Young", "email": "rcxdude@gmail.com", "date": "2014-03-10T22:36:56Z"}, "message": "Implement hexadecimal floating point literals via a syntax extension\n\ncloses #1433", "tree": {"sha": "df22c20ad555df915187b96122b35b33e7393a09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df22c20ad555df915187b96122b35b33e7393a09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a38e14871a38319249497680737033230249cffa", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a38e14871a38319249497680737033230249cffa", "html_url": "https://github.com/rust-lang/rust/commit/a38e14871a38319249497680737033230249cffa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a38e14871a38319249497680737033230249cffa/comments", "author": {"login": "rcxdude", "id": 316786, "node_id": "MDQ6VXNlcjMxNjc4Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/316786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rcxdude", "html_url": "https://github.com/rcxdude", "followers_url": "https://api.github.com/users/rcxdude/followers", "following_url": "https://api.github.com/users/rcxdude/following{/other_user}", "gists_url": "https://api.github.com/users/rcxdude/gists{/gist_id}", "starred_url": "https://api.github.com/users/rcxdude/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rcxdude/subscriptions", "organizations_url": "https://api.github.com/users/rcxdude/orgs", "repos_url": "https://api.github.com/users/rcxdude/repos", "events_url": "https://api.github.com/users/rcxdude/events{/privacy}", "received_events_url": "https://api.github.com/users/rcxdude/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rcxdude", "id": 316786, "node_id": "MDQ6VXNlcjMxNjc4Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/316786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rcxdude", "html_url": "https://github.com/rcxdude", "followers_url": "https://api.github.com/users/rcxdude/followers", "following_url": "https://api.github.com/users/rcxdude/following{/other_user}", "gists_url": "https://api.github.com/users/rcxdude/gists{/gist_id}", "starred_url": "https://api.github.com/users/rcxdude/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rcxdude/subscriptions", "organizations_url": "https://api.github.com/users/rcxdude/orgs", "repos_url": "https://api.github.com/users/rcxdude/repos", "events_url": "https://api.github.com/users/rcxdude/events{/privacy}", "received_events_url": "https://api.github.com/users/rcxdude/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62f1d68439dcfd509eaca29887afa97f22938373", "url": "https://api.github.com/repos/rust-lang/rust/commits/62f1d68439dcfd509eaca29887afa97f22938373", "html_url": "https://github.com/rust-lang/rust/commit/62f1d68439dcfd509eaca29887afa97f22938373"}], "stats": {"total": 274, "additions": 273, "deletions": 1}, "files": [{"sha": "67bd967a974a51f6f2f1e651776ba25000c39452", "filename": "mk/crates.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a38e14871a38319249497680737033230249cffa/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/a38e14871a38319249497680737033230249cffa/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=a38e14871a38319249497680737033230249cffa", "patch": "@@ -51,7 +51,7 @@\n \n TARGET_CRATES := std extra green rustuv native flate arena glob term semver \\\n                  uuid serialize sync getopts collections num test time\n-HOST_CRATES := syntax rustc rustdoc fourcc\n+HOST_CRATES := syntax rustc rustdoc fourcc hexfloat\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n@@ -76,6 +76,7 @@ DEPS_sync := std\n DEPS_getopts := std\n DEPS_collections := std\n DEPS_fourcc := syntax std\n+DEPS_hexfloat := syntax std\n DEPS_num := std\n DEPS_test := std extra collections getopts serialize term\n DEPS_time := std serialize"}, {"sha": "f331391d35a031b3e105221bc70bc6033579a9e2", "filename": "src/libhexfloat/lib.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/a38e14871a38319249497680737033230249cffa/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a38e14871a38319249497680737033230249cffa/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=a38e14871a38319249497680737033230249cffa", "patch": "@@ -0,0 +1,178 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+Syntax extension to create floating point literals from hexadecimal strings\n+\n+Once loaded, hexfloat!() is called with a string containing the hexadecimal\n+floating-point literal, and an optional type (f32 or f64).\n+If the type is omitted, the literal is treated the same as a normal unsuffixed\n+literal.\n+\n+# Examples\n+\n+To load the extension and use it:\n+\n+```rust,ignore\n+#[phase(syntax)]\n+extern crate hexfloat;\n+\n+fn main() {\n+    let val = hexfloat!(\"0x1.ffffb4\", f32);\n+}\n+ ```\n+\n+# References\n+\n+* [ExploringBinary: hexadecimal floating point constants]\n+  (http://www.exploringbinary.com/hexadecimal-floating-point-constants/)\n+\n+*/\n+\n+#[crate_id = \"hexfloat#0.10-pre\"];\n+#[crate_type = \"rlib\"];\n+#[crate_type = \"dylib\"];\n+#[license = \"MIT/ASL2\"];\n+\n+#[feature(macro_registrar, managed_boxes)];\n+\n+extern crate syntax;\n+\n+use syntax::ast;\n+use syntax::ast::Name;\n+use syntax::codemap::{Span, mk_sp};\n+use syntax::ext::base;\n+use syntax::ext::base::{SyntaxExtension, BasicMacroExpander, NormalTT, ExtCtxt, MRExpr};\n+use syntax::ext::build::AstBuilder;\n+use syntax::parse;\n+use syntax::parse::token;\n+\n+#[macro_registrar]\n+pub fn macro_registrar(register: |Name, SyntaxExtension|) {\n+    register(token::intern(\"hexfloat\"),\n+        NormalTT(~BasicMacroExpander {\n+            expander: expand_syntax_ext,\n+            span: None,\n+        },\n+        None));\n+}\n+\n+//Check if the literal is valid (as LLVM expects),\n+//and return a descriptive error if not.\n+fn hex_float_lit_err(s: &str) -> Option<(uint, ~str)> {\n+    let mut chars = s.chars().peekable();\n+    let mut i = 0;\n+    if chars.peek() == Some(&'-') { chars.next(); i+= 1 }\n+    if chars.next() != Some('0') { return Some((i, ~\"Expected '0'\")); } i+=1;\n+    if chars.next() != Some('x') { return Some((i, ~\"Expected 'x'\")); } i+=1;\n+    let mut d_len = 0;\n+    for _ in chars.take_while(|c| c.is_digit_radix(16)) { chars.next(); i+=1; d_len += 1;}\n+    if chars.next() != Some('.') { return Some((i, ~\"Expected '.'\")); } i+=1;\n+    let mut f_len = 0;\n+    for _ in chars.take_while(|c| c.is_digit_radix(16)) { chars.next(); i+=1; f_len += 1;}\n+    if d_len == 0 && f_len == 0 {\n+        return Some((i, ~\"Expected digits before or after decimal point\"));\n+    }\n+    if chars.next() != Some('p') { return Some((i, ~\"Expected 'p'\")); } i+=1;\n+    if chars.peek() == Some(&'-') { chars.next(); i+= 1 }\n+    let mut e_len = 0;\n+    for _ in chars.take_while(|c| c.is_digit()) { chars.next(); i+=1; e_len += 1}\n+    if e_len == 0 {\n+        return Some((i, ~\"Expected exponent digits\"));\n+    }\n+    match chars.next() {\n+        None => None,\n+        Some(_) => Some((i, ~\"Expected end of string\"))\n+    }\n+}\n+\n+pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::MacResult {\n+    let (expr, ty_lit) = parse_tts(cx, tts);\n+\n+    let ty = match ty_lit {\n+        None => None,\n+        Some(Ident{ident, span}) => match token::get_ident(ident).get() {\n+            \"f32\" => Some(ast::TyF32),\n+            \"f64\" => Some(ast::TyF64),\n+            _ => {\n+                cx.span_err(span, \"invalid floating point type in hexfloat!\");\n+                None\n+            }\n+        }\n+    };\n+\n+    let s = match expr.node {\n+        // expression is a literal\n+        ast::ExprLit(lit) => match lit.node {\n+            // string literal\n+            ast::LitStr(ref s, _) => {\n+                s.clone()\n+            }\n+            _ => {\n+                cx.span_err(expr.span, \"unsupported literal in hexfloat!\");\n+                return base::MacResult::dummy_expr(sp);\n+            }\n+        },\n+        _ => {\n+            cx.span_err(expr.span, \"non-literal in hexfloat!\");\n+            return base::MacResult::dummy_expr(sp);\n+        }\n+    };\n+\n+    {\n+        let err = hex_float_lit_err(s.get());\n+        match err {\n+            Some((err_pos, err_str)) => {\n+                let pos = expr.span.lo + syntax::codemap::Pos::from_uint(err_pos + 1);\n+                let span = syntax::codemap::mk_sp(pos,pos);\n+                cx.span_err(span, format!(\"invalid hex float literal in hexfloat!: {}\", err_str));\n+                return base::MacResult::dummy_expr(sp);\n+            }\n+            _ => ()\n+        }\n+    }\n+\n+    let lit = match ty {\n+        None => ast::LitFloatUnsuffixed(s),\n+        Some (ty) => ast::LitFloat(s, ty)\n+    };\n+    MRExpr(cx.expr_lit(sp, lit))\n+}\n+\n+struct Ident {\n+    ident: ast::Ident,\n+    span: Span\n+}\n+\n+fn parse_tts(cx: &ExtCtxt, tts: &[ast::TokenTree]) -> (@ast::Expr, Option<Ident>) {\n+    let p = &mut parse::new_parser_from_tts(cx.parse_sess(),\n+                                            cx.cfg(),\n+                                            tts.iter()\n+                                               .map(|x| (*x).clone())\n+                                               .collect());\n+    let ex = p.parse_expr();\n+    let id = if p.token == token::EOF {\n+        None\n+    } else {\n+        p.expect(&token::COMMA);\n+        let lo = p.span.lo;\n+        let ident = p.parse_ident();\n+        let hi = p.last_span.hi;\n+        Some(Ident{ident: ident, span: mk_sp(lo, hi)})\n+    };\n+    if p.token != token::EOF {\n+        p.unexpected();\n+    }\n+    (ex, id)\n+}\n+\n+// FIXME (10872): This is required to prevent an LLVM assert on Windows\n+#[test]\n+fn dummy_test() { }"}, {"sha": "9a7129dd2cf8431a9022c8593f56d8c124af2069", "filename": "src/test/compile-fail/syntax-extension-hexfloat-bad-lits.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a38e14871a38319249497680737033230249cffa/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-hexfloat-bad-lits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a38e14871a38319249497680737033230249cffa/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-hexfloat-bad-lits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-hexfloat-bad-lits.rs?ref=a38e14871a38319249497680737033230249cffa", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage1\n+// ignore-pretty\n+// ignore-cross-compile #12102\n+\n+#[feature(phase)];\n+\n+#[phase(syntax)]\n+extern crate hexfloat;\n+\n+fn main() {\n+    hexfloat!(\"foo\");\n+    //~^ ERROR invalid hex float literal in hexfloat!: Expected '0'\n+    hexfloat!(\"0\");\n+    //~^ERROR invalid hex float literal in hexfloat!: Expected 'x'\n+    hexfloat!(\"0x\");\n+    //~^ERROR invalid hex float literal in hexfloat!: Expected '.'\n+    hexfloat!(\"0x.\");\n+    //~^ERROR invalid hex float literal in hexfloat!: Expected digits before or after decimal point\n+    hexfloat!(\"0x0.0\");\n+    //~^ERROR invalid hex float literal in hexfloat!: Expected 'p'\n+    hexfloat!(\"0x0.0p\");\n+    //~^ERROR invalid hex float literal in hexfloat!: Expected exponent digits\n+    hexfloat!(\"0x0.0p0f\");\n+    //~^ERROR invalid hex float literal in hexfloat!: Expected end of string\n+}"}, {"sha": "cf7a2fb6acbc63043af14cf3f21888dbff7347b6", "filename": "src/test/compile-fail/syntax-extension-hexfloat-bad-types.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a38e14871a38319249497680737033230249cffa/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-hexfloat-bad-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a38e14871a38319249497680737033230249cffa/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-hexfloat-bad-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-hexfloat-bad-types.rs?ref=a38e14871a38319249497680737033230249cffa", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage1\n+// ignore-pretty\n+// ignore-cross-compile #12102\n+\n+#[feature(phase)];\n+\n+#[phase(syntax)]\n+extern crate hexfloat;\n+\n+fn main() {\n+    hexfloat!(foo);\n+    //~^ ERROR non-literal in hexfloat!\n+    hexfloat!(0);\n+    //~^ ERROR unsupported literal in hexfloat!\n+    hexfloat!(\"0x0.p0\", invalid);\n+    //~^ ERROR invalid floating point type in hexfloat!\n+}"}, {"sha": "6eeefabcf7cb9c4792cf42a22e35be192d392644", "filename": "src/test/run-pass/syntax-extension-hexfloat.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a38e14871a38319249497680737033230249cffa/src%2Ftest%2Frun-pass%2Fsyntax-extension-hexfloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a38e14871a38319249497680737033230249cffa/src%2Ftest%2Frun-pass%2Fsyntax-extension-hexfloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-hexfloat.rs?ref=a38e14871a38319249497680737033230249cffa", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage1\n+// ignore-pretty\n+// ignore-cross-compile #12102\n+// ignore-fast\n+\n+#[feature(phase)];\n+#[phase(syntax)]\n+extern crate hexfloat;\n+\n+pub fn main() {\n+    let a = hexfloat!(\"0x1.999999999999ap-4\");\n+    assert_eq!(a, 0.1);\n+    let b = hexfloat!(\"-0x1.fffp-4\", f32);\n+    assert_eq!(b, -0.12498474_f32);\n+    let c = hexfloat!(\"0x.12345p5\", f64);\n+    let d = hexfloat!(\"0x0.12345p5\", f64);\n+    assert_eq!(c,d);\n+    let f = hexfloat!(\"0x10.p4\", f32);\n+    let g = hexfloat!(\"0x10.0p4\", f32);\n+    assert_eq!(f,g);\n+}"}]}