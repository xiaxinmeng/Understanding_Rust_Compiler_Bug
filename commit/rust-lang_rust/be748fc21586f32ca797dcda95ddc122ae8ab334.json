{"sha": "be748fc21586f32ca797dcda95ddc122ae8ab334", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNzQ4ZmMyMTU4NmYzMmNhNzk3ZGNkYTk1ZGRjMTIyYWU4YWIzMzQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-28T14:14:01Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-28T14:14:15Z"}, "message": "Properly guard resource values against double-drop\n\nThs involved adding an extra field to their representation, so that there is\nsomething to check for zero.", "tree": {"sha": "59998b3649b85ec15bf34251eda462820105a5e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59998b3649b85ec15bf34251eda462820105a5e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be748fc21586f32ca797dcda95ddc122ae8ab334", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be748fc21586f32ca797dcda95ddc122ae8ab334", "html_url": "https://github.com/rust-lang/rust/commit/be748fc21586f32ca797dcda95ddc122ae8ab334", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be748fc21586f32ca797dcda95ddc122ae8ab334/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecc080ed0b4aa8a93e6e9f190c7e2638ff13bbca", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecc080ed0b4aa8a93e6e9f190c7e2638ff13bbca", "html_url": "https://github.com/rust-lang/rust/commit/ecc080ed0b4aa8a93e6e9f190c7e2638ff13bbca"}], "stats": {"total": 69, "additions": 51, "deletions": 18}, "files": [{"sha": "78b766dbf8c668993b628b8a13ceadb5a422ef15", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 51, "deletions": 18, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/be748fc21586f32ca797dcda95ddc122ae8ab334/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be748fc21586f32ca797dcda95ddc122ae8ab334/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=be748fc21586f32ca797dcda95ddc122ae8ab334", "patch": "@@ -884,7 +884,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             llty = abs_pair;\n         }\n         case (ty::ty_res(_, ?sub)) {\n-            ret type_of_inner(cx, sp, sub);\n+            ret T_struct([T_i32(), type_of_inner(cx, sp, sub)]);\n         }\n         case (ty::ty_var(_)) {\n             cx.tcx.sess.span_fatal(sp, \"trans::type_of called on ty_var\");\n@@ -1227,7 +1227,10 @@ fn simplify_type(&@crate_ctxt ccx, &ty::t typ) -> ty::t {\n                                     ty::mk_imm_box(ccx.tcx,\n                                                    ty::mk_nil(ccx.tcx))]);\n             }\n-            case (ty::ty_res(_, ?sub)) { ret simplify_type(ccx, sub);}\n+            case (ty::ty_res(_, ?sub)) {\n+                ret ty::mk_imm_tup(ccx.tcx, [ty::mk_int(ccx.tcx),\n+                                             simplify_type(ccx, sub)]);\n+            }\n             case (_) { ret typ; }\n         }\n     }\n@@ -2068,7 +2071,6 @@ fn maybe_free_ivec_heap_part(&@block_ctxt cx, ValueRef v0, ty::t unit_ty) ->\n \n fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n-\n     auto ccx = cx.fcx.lcx.ccx;\n     auto rs = alt (ty::struct(ccx.tcx, t)) {\n         case (ty::ty_str) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n@@ -2094,16 +2096,15 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n             decr_refcnt_maybe_free(cx, box_cell, v0, t)\n         }\n         case (ty::ty_res(?did, ?inner)) {\n-            auto dtor = alt (ccx.ast_map.get(did._1)) {\n+            (alt (ccx.ast_map.get(did._1)) {\n                 case (ast_map::node_item(?i)) {\n                     alt (i.node) {\n-                        case (ast::item_res(?dtor, _, _, _)) { dtor }\n+                        case (ast::item_res(?dtor, _, _, _)) {\n+                            drop_res(cx, v0, inner, dtor)\n+                        }\n                     }\n                 }\n-            };\n-            cx.fcx.llargs.insert(dtor.decl.inputs.(0).id, v0);\n-            auto rs = trans_block(cx, dtor.body, return);\n-            drop_ty(rs.bcx, v0, inner)\n+            })\n         }\n         case (ty::ty_fn(_, _, _, _, _)) {\n             auto box_cell =\n@@ -2120,6 +2121,30 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n     rs.bcx.build.RetVoid();\n }\n \n+fn drop_res(@block_ctxt cx, ValueRef rs, ty::t inner_t, &ast::_fn dtor)\n+    -> result {\n+    auto ccx = cx.fcx.lcx.ccx;\n+    auto tup_ty = ty::mk_imm_tup(ccx.tcx, [ty::mk_int(ccx.tcx), inner_t]);\n+    auto drop_cx = new_sub_block_ctxt(cx, \"drop res\");\n+    auto next_cx = new_sub_block_ctxt(cx, \"next\");\n+\n+    auto drop_flag = GEP_tup_like(cx,  tup_ty, rs, [0, 0]);\n+    cx = drop_flag.bcx;\n+    auto null_test = cx.build.IsNull(cx.build.Load(drop_flag.val));\n+    cx.build.CondBr(null_test, next_cx.llbb, drop_cx.llbb);\n+\n+    cx = drop_cx;\n+    auto val = GEP_tup_like(cx,  tup_ty, rs, [0, 1]);\n+    cx = val.bcx;\n+    cx.fcx.llargs.insert(dtor.decl.inputs.(0).id, val.val);\n+    cx = trans_block(cx, dtor.body, return).bcx;\n+    cx = drop_ty(cx, val.val, inner_t).bcx;\n+    cx.build.Store(C_int(0), drop_flag.val);\n+    cx.build.Br(next_cx.llbb);\n+\n+    ret rslt(next_cx, C_nil());\n+}\n+\n fn decr_refcnt_maybe_free(&@block_ctxt cx, ValueRef box_ptr_alias,\n                           ValueRef full_alias, &ty::t t) -> result {\n     auto load_rc_cx = new_sub_block_ctxt(cx, \"load rc\");\n@@ -2573,8 +2598,12 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n             }\n         }\n         case (ty::ty_res(_, ?inner)) {\n-            f(r.bcx, load_if_immediate(r.bcx, av, inner),\n-              load_if_immediate(r.bcx, bv, inner), inner);\n+            r = GEP_tup_like(r.bcx, t, av, [0, 1]);\n+            auto llfld_a = r.val;\n+            r = GEP_tup_like(r.bcx, t, bv, [0, 1]);\n+            auto llfld_b = r.val;\n+            f(r.bcx, load_if_immediate(r.bcx, llfld_a, inner),\n+              load_if_immediate(r.bcx, llfld_b, inner), inner);\n         }\n         case (ty::ty_tag(?tid, ?tps)) {\n             auto variants = ty::tag_variants(cx.fcx.lcx.ccx.tcx, tid);\n@@ -7691,17 +7720,21 @@ fn trans_res(@local_ctxt cx, &span sp, &ast::_fn f, ast::node_id ctor_id,\n              &vec[ast::ty_param] ty_params) {\n     auto llctor_decl = cx.ccx.item_ids.get(ctor_id);\n     auto fcx = new_fn_ctxt(cx, sp, llctor_decl);\n-    auto ret_ty = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n+    auto ret_t = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n     create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n-                              ret_ty, f.decl.inputs, ty_params);\n+                              ret_t, f.decl.inputs, ty_params);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n-    auto self_ty = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n-    auto llself_ty = type_of(cx.ccx, sp, self_ty);\n-    auto arg_ty = arg_tys_of_fn(cx.ccx, ctor_id).(0).ty;\n+    auto arg_t = arg_tys_of_fn(cx.ccx, ctor_id).(0).ty;\n+    auto tup_t = ty::mk_imm_tup(cx.ccx.tcx, [ty::mk_int(cx.ccx.tcx), arg_t]);\n     auto arg = load_if_immediate\n-        (bcx, fcx.llargs.get(f.decl.inputs.(0).id), arg_ty);\n-    bcx = copy_val(bcx, INIT, fcx.llretptr, arg, arg_ty).bcx;\n+        (bcx, fcx.llargs.get(f.decl.inputs.(0).id), arg_t);\n+    auto dst = GEP_tup_like(bcx, tup_t, fcx.llretptr, [0, 1]);\n+    bcx = dst.bcx;\n+    bcx = copy_val(bcx, INIT, dst.val, arg, arg_t).bcx;\n+    auto flag = GEP_tup_like(bcx, tup_t, fcx.llretptr, [0, 0]);\n+    bcx = flag.bcx;\n+    bcx.build.Store(C_int(1), flag.val);\n     bcx.build.RetVoid();\n     finish_fn(fcx, lltop);\n }"}]}