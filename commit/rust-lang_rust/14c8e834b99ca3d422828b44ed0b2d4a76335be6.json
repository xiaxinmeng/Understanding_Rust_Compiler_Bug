{"sha": "14c8e834b99ca3d422828b44ed0b2d4a76335be6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0YzhlODM0Yjk5Y2EzZDQyMjgyOGI0NGVkMGIyZDRhNzYzMzViZTY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-27T16:14:04Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-27T16:14:04Z"}, "message": "use Cell for memory's aligned flag to avoid infecting interfaces with 'fake' mutability", "tree": {"sha": "d3f3f31a6fd0a25727e2db69bb52c2c685df5298", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3f3f31a6fd0a25727e2db69bb52c2c685df5298"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14c8e834b99ca3d422828b44ed0b2d4a76335be6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14c8e834b99ca3d422828b44ed0b2d4a76335be6", "html_url": "https://github.com/rust-lang/rust/commit/14c8e834b99ca3d422828b44ed0b2d4a76335be6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14c8e834b99ca3d422828b44ed0b2d4a76335be6/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4672cb7bde348a3096bf1e6125d3cff98bf52b4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4672cb7bde348a3096bf1e6125d3cff98bf52b4d", "html_url": "https://github.com/rust-lang/rust/commit/4672cb7bde348a3096bf1e6125d3cff98bf52b4d"}], "stats": {"total": 168, "additions": 91, "deletions": 77}, "files": [{"sha": "c1ddfb9ffeafa7bdddf248b341e0ef388b52c1fa", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=14c8e834b99ca3d422828b44ed0b2d4a76335be6", "patch": "@@ -1161,7 +1161,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Lvalue::Ptr { ptr, extra, aligned } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                self.write_maybe_aligned(aligned,\n+                self.write_maybe_aligned_mut(aligned,\n                     |ectx| ectx.write_value_to_ptr(src_val, ptr, dest_ty))\n             }\n \n@@ -1193,7 +1193,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             //\n             // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n             // knew for certain that there were no outstanding pointers to this allocation.\n-            self.write_maybe_aligned(aligned,\n+            self.write_maybe_aligned_mut(aligned,\n                 |ectx| ectx.write_value_to_ptr(src_val, dest_ptr, dest_ty))?;\n \n         } else if let Value::ByRef(src_ptr, aligned) = src_val {\n@@ -1208,7 +1208,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // It is a valid optimization to attempt reading a primitive value out of the\n             // source and write that into the destination without making an allocation, so\n             // we do so here.\n-            self.read_maybe_aligned(aligned, |ectx| {\n+            self.read_maybe_aligned_mut(aligned, |ectx| {\n                 if let Ok(Some(src_val)) = ectx.try_read_value(src_ptr, dest_ty) {\n                     write_dest(ectx, src_val)?;\n                 } else {\n@@ -1235,7 +1235,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx> {\n         match value {\n             Value::ByRef(ptr, aligned) => {\n-                self.read_maybe_aligned(aligned, |ectx| ectx.copy(ptr, dest, dest_ty))\n+                self.read_maybe_aligned_mut(aligned, |ectx| ectx.copy(ptr, dest, dest_ty))\n             },\n             Value::ByVal(primval) => {\n                 let size = self.type_size(dest_ty)?.expect(\"dest type must be sized\");\n@@ -1270,9 +1270,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let field_1_size = self.type_size(field_1_ty.0)?.expect(\"pair element type must be sized\");\n         let field_0_ptr = ptr.offset(field_0.bytes(), &self)?.into();\n         let field_1_ptr = ptr.offset(field_1.bytes(), &self)?.into();\n-        self.write_maybe_aligned(!packed,\n+        self.write_maybe_aligned_mut(!packed,\n             |ectx| ectx.memory.write_primval(field_0_ptr, a, field_0_size))?;\n-        self.write_maybe_aligned(!packed,\n+        self.write_maybe_aligned_mut(!packed,\n             |ectx| ectx.memory.write_primval(field_1_ptr, b, field_1_size))?;\n         Ok(())\n     }\n@@ -1376,7 +1376,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(super) fn read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(super) fn read_value(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         if let Some(val) = self.try_read_value(ptr, ty)? {\n             Ok(val)\n         } else {\n@@ -1400,7 +1400,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn try_read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n+    fn try_read_value(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         use syntax::ast::FloatTy;\n \n         let val = match ty.sty {\n@@ -1512,7 +1512,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n-                let ptr = src.into_ptr(&mut self.memory)?;\n+                let ptr = src.into_ptr(&self.memory)?;\n                 // u64 cast is from usize to u64, which is always good\n                 self.write_value(ptr.to_value_with_len(length as u64), dest, dest_ty)\n             }\n@@ -1526,7 +1526,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let trait_ref = data.principal().unwrap().with_self_ty(self.tcx, src_pointee_ty);\n                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n                 let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n-                let ptr = src.into_ptr(&mut self.memory)?;\n+                let ptr = src.into_ptr(&self.memory)?;\n                 self.write_value(ptr.to_value_with_vtable(vtable), dest, dest_ty)\n             },\n "}, {"sha": "4d4db267ecf88a53e39645de6625e00b0fe4213e", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=14c8e834b99ca3d422828b44ed0b2d4a76335be6", "patch": "@@ -351,17 +351,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(Lvalue::Ptr { ptr, extra, aligned: aligned && !packed })\n     }\n \n-    pub(super) fn val_to_lvalue(&mut self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n+    pub(super) fn val_to_lvalue(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         Ok(match self.tcx.struct_tail(ty).sty {\n             ty::TyDynamic(..) => {\n-                let (ptr, vtable) = val.into_ptr_vtable_pair(&mut self.memory)?;\n+                let (ptr, vtable) = val.into_ptr_vtable_pair(&self.memory)?;\n                 Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable), aligned: true }\n             },\n             ty::TyStr | ty::TySlice(_) => {\n-                let (ptr, len) = val.into_slice(&mut self.memory)?;\n+                let (ptr, len) = val.into_slice(&self.memory)?;\n                 Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len), aligned: true }\n             },\n-            _ => Lvalue::Ptr { ptr: val.into_ptr(&mut self.memory)?, extra: LvalueExtra::None, aligned: true },\n+            _ => Lvalue::Ptr { ptr: val.into_ptr(&self.memory)?, extra: LvalueExtra::None, aligned: true },\n         })\n     }\n "}, {"sha": "2226744c6ab4b1c78251dfc3505562800b1351ca", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=14c8e834b99ca3d422828b44ed0b2d4a76335be6", "patch": "@@ -1,6 +1,7 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{fmt, iter, ptr, mem, io, ops};\n+use std::cell::Cell;\n \n use rustc::ty;\n use rustc::ty::layout::{self, TargetDataLayout, HasDataLayout};\n@@ -266,8 +267,8 @@ pub struct Memory<'a, 'tcx> {\n \n     /// To avoid having to pass flags to every single memory access, we have some global state saying whether\n     /// alignment checking is currently enforced for read and/or write accesses.\n-    reads_are_aligned: bool,\n-    writes_are_aligned: bool,\n+    reads_are_aligned: Cell<bool>,\n+    writes_are_aligned: Cell<bool>,\n \n     /// The current stack frame.  Used to check accesses against locks.\n     cur_frame: usize,\n@@ -287,8 +288,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             literal_alloc_cache: HashMap::new(),\n             thread_local: BTreeMap::new(),\n             next_thread_local: 0,\n-            reads_are_aligned: true,\n-            writes_are_aligned: true,\n+            reads_are_aligned: Cell::new(true),\n+            writes_are_aligned: Cell::new(true),\n             cur_frame: usize::max_value(),\n         }\n     }\n@@ -796,7 +797,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     fn get_bytes_unchecked(&self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n-        if self.reads_are_aligned {\n+        if self.reads_are_aligned.get() {\n             self.check_align(ptr.into(), align)?;\n         }\n         if size == 0 {\n@@ -813,7 +814,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     fn get_bytes_unchecked_mut(&mut self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n-        if self.writes_are_aligned {\n+        if self.writes_are_aligned.get() {\n             self.check_align(ptr.into(), align)?;\n         }\n         if size == 0 {\n@@ -909,10 +910,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn copy(&mut self, src: Pointer, dest: Pointer, size: u64, align: u64, nonoverlapping: bool) -> EvalResult<'tcx> {\n         if size == 0 {\n             // Empty accesses don't need to be valid pointers, but they should still be aligned\n-            if self.reads_are_aligned {\n+            if self.reads_are_aligned.get() {\n                 self.check_align(src, align)?;\n             }\n-            if self.writes_are_aligned {\n+            if self.writes_are_aligned.get() {\n                 self.check_align(dest, align)?;\n             }\n             return Ok(());\n@@ -968,7 +969,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn read_bytes(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &[u8]> {\n         if size == 0 {\n             // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-            if self.reads_are_aligned {\n+            if self.reads_are_aligned.get() {\n                 self.check_align(ptr, 1)?;\n             }\n             return Ok(&[]);\n@@ -979,7 +980,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx> {\n         if src.is_empty() {\n             // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-            if self.writes_are_aligned {\n+            if self.writes_are_aligned.get() {\n                 self.check_align(ptr, 1)?;\n             }\n             return Ok(());\n@@ -992,7 +993,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx> {\n         if count == 0 {\n             // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-            if self.writes_are_aligned {\n+            if self.writes_are_aligned.get() {\n                 self.check_align(ptr, 1)?;\n             }\n             return Ok(());\n@@ -1399,23 +1400,36 @@ pub(crate) trait HasMemory<'a, 'tcx> {\n     fn memory(&self) -> &Memory<'a, 'tcx>;\n \n     // These are not supposed to be overriden.\n-    fn read_maybe_aligned<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n+    fn read_maybe_aligned<F, T>(&self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n+        where F: FnOnce(&Self) -> EvalResult<'tcx, T>\n+    {\n+        let old = self.memory().reads_are_aligned.get();\n+        // Do alignment checking if *all* nested calls say it has to be aligned.\n+        self.memory().reads_are_aligned.set(old && aligned);\n+        let t = f(self);\n+        self.memory().reads_are_aligned.set(old);\n+        t\n+    }\n+\n+    fn read_maybe_aligned_mut<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n         where F: FnOnce(&mut Self) -> EvalResult<'tcx, T>\n     {\n-        let old = self.memory_mut().reads_are_aligned;\n-        self.memory_mut().reads_are_aligned = old && aligned;\n+        let old = self.memory().reads_are_aligned.get();\n+        // Do alignment checking if *all* nested calls say it has to be aligned.\n+        self.memory().reads_are_aligned.set(old && aligned);\n         let t = f(self);\n-        self.memory_mut().reads_are_aligned = old;\n+        self.memory().reads_are_aligned.set(old);\n         t\n     }\n \n-    fn write_maybe_aligned<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n+    fn write_maybe_aligned_mut<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n         where F: FnOnce(&mut Self) -> EvalResult<'tcx, T>\n     {\n-        let old = self.memory_mut().writes_are_aligned;\n-        self.memory_mut().writes_are_aligned = old && aligned;\n+        let old = self.memory().writes_are_aligned.get();\n+        // Do alignment checking if *all* nested calls say it has to be aligned.\n+        self.memory().writes_are_aligned.set(old && aligned);\n         let t = f(self);\n-        self.memory_mut().writes_are_aligned = old;\n+        self.memory().writes_are_aligned.set(old);\n         t\n     }\n }"}, {"sha": "b78945155f1a1b8049a99e7937daf9e39bf70af0", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=14c8e834b99ca3d422828b44ed0b2d4a76335be6", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                             // only the pointer part of a fat pointer is used for this space optimization\n                             let discr_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n-                            self.write_maybe_aligned(!packed, |ectx| ectx.memory.write_uint(nonnull, 0, discr_size))?;\n+                            self.write_maybe_aligned_mut(!packed, |ectx| ectx.memory.write_uint(nonnull, 0, discr_size))?;\n                         }\n                     },\n "}, {"sha": "69dd41c82aacee56e0992cc8ed1375d3ceba2c5e", "filename": "src/librustc_mir/interpret/terminator/intrinsic.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fintrinsic.rs?ref=14c8e834b99ca3d422828b44ed0b2d4a76335be6", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"arith_offset\" => {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let result_ptr = self.wrapping_pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_ptr(dest, result_ptr, dest_ty)?;\n             }\n@@ -61,7 +61,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 self.write_value(Value::by_ref(ptr), dest, ty)?;\n             }\n \n@@ -70,7 +70,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_store_rel\" |\n             \"volatile_store\" => {\n                 let ty = substs.type_at(0);\n-                let dest = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let dest = arg_vals[0].into_ptr(&self.memory)?;\n                 self.write_value_to_ptr(arg_vals[1], dest, ty)?;\n             }\n \n@@ -80,7 +80,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n@@ -94,7 +94,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let expect_old = self.value_to_primval(arg_vals[1], ty)?;\n                 let change = self.value_to_primval(arg_vals[2], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"atomic_xadd\" | \"atomic_xadd_acq\" | \"atomic_xadd_rel\" | \"atomic_xadd_acqrel\" | \"atomic_xadd_relaxed\" |\n             \"atomic_xsub\" | \"atomic_xsub_acq\" | \"atomic_xsub_rel\" | \"atomic_xsub_acqrel\" | \"atomic_xsub_relaxed\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let change = self.value_to_primval(arg_vals[1], ty)?;\n                 let old = self.read_value(ptr, ty)?;\n                 let old = match old {\n@@ -148,8 +148,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     // TODO: We do not even validate alignment for the 0-bytes case.  libstd relies on this in vec::IntoIter::next.\n                     // Also see the write_bytes intrinsic.\n                     let elem_align = self.type_align(elem_ty)?;\n-                    let src = arg_vals[0].into_ptr(&mut self.memory)?;\n-                    let dest = arg_vals[1].into_ptr(&mut self.memory)?;\n+                    let src = arg_vals[0].into_ptr(&self.memory)?;\n+                    let dest = arg_vals[1].into_ptr(&self.memory)?;\n                     self.memory.copy(src, dest, count * elem_size, elem_align, intrinsic_name.ends_with(\"_nonoverlapping\"))?;\n                 }\n             }\n@@ -176,7 +176,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n-                let adt_ptr = arg_vals[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let adt_ptr = arg_vals[0].into_ptr(&self.memory)?.to_ptr()?;\n                 let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n                 self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n             }\n@@ -297,7 +297,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"move_val_init\" => {\n                 let ty = substs.type_at(0);\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 self.write_value_to_ptr(arg_vals[1], ptr, ty)?;\n             }\n \n@@ -310,7 +310,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"offset\" => {\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let result_ptr = self.pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_ptr(dest, result_ptr, dest_ty)?;\n             }\n@@ -399,7 +399,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"transmute\" => {\n                 let src_ty = substs.type_at(0);\n                 let ptr = self.force_allocation(dest)?.to_ptr()?;\n-                self.write_maybe_aligned(/*aligned*/false, |ectx| {\n+                self.write_maybe_aligned_mut(/*aligned*/false, |ectx| {\n                     ectx.write_value_to_ptr(arg_vals[0], ptr.into(), src_ty)\n                 })?;\n             }\n@@ -464,7 +464,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty_align = self.type_align(ty)?;\n                 let val_byte = self.value_to_primval(arg_vals[1], u8)?.to_u128()? as u8;\n                 let size = self.type_size(ty)?.expect(\"write_bytes() type must be sized\");\n-                let ptr = arg_vals[0].into_ptr(&mut self.memory)?;\n+                let ptr = arg_vals[0].into_ptr(&self.memory)?;\n                 let count = self.value_to_primval(arg_vals[2], usize)?.to_u64()?;\n                 if count > 0 {\n                     // HashMap relies on write_bytes on a NULL ptr with count == 0 to work\n@@ -550,15 +550,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Ok((size, align.abi()))\n                 }\n                 ty::TyDynamic(..) => {\n-                    let (_, vtable) = value.into_ptr_vtable_pair(&mut self.memory)?;\n+                    let (_, vtable) = value.into_ptr_vtable_pair(&self.memory)?;\n                     // the second entry in the vtable is the dynamic size of the object.\n                     self.read_size_and_align_from_vtable(vtable)\n                 }\n \n                 ty::TySlice(_) | ty::TyStr => {\n                     let elem_ty = ty.sequence_element_type(self.tcx);\n                     let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\") as u64;\n-                    let (_, len) = value.into_slice(&mut self.memory)?;\n+                    let (_, len) = value.into_slice(&self.memory)?;\n                     let align = self.type_align(elem_ty)?;\n                     Ok((len * elem_size, align as u64))\n                 }"}, {"sha": "b9b72ca34ac2592c862c4ae38f23423054a3fc70", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=14c8e834b99ca3d422828b44ed0b2d4a76335be6", "patch": "@@ -397,7 +397,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             },\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n-                let (_, vtable) = self.eval_operand(&arg_operands[0])?.into_ptr_vtable_pair(&mut self.memory)?;\n+                let (_, vtable) = self.eval_operand(&arg_operands[0])?.into_ptr_vtable_pair(&self.memory)?;\n                 let fn_ptr = self.memory.read_ptr(vtable.offset(ptr_size * (idx as u64 + 3), &self)?)?;\n                 let instance = self.memory.get_fn(fn_ptr.to_ptr()?)?;\n                 let mut arg_operands = arg_operands.to_vec();\n@@ -464,7 +464,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(false)\n     }\n \n-    pub fn read_discriminant_value(&mut self, adt_ptr: MemoryPointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n+    pub fn read_discriminant_value(&self, adt_ptr: MemoryPointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n         use rustc::ty::layout::Layout::*;\n         let adt_layout = self.type_layout(adt_ty)?;\n         //trace!(\"read_discriminant_value {:#?}\", adt_layout);\n@@ -577,7 +577,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::heap::::__rust_dealloc\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n                 let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 let align = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if old_size == 0 {\n@@ -589,7 +589,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.deallocate(ptr, Some((old_size, align)), Kind::Rust)?;\n             }\n             \"alloc::heap::::__rust_realloc\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n                 let old_size = self.value_to_primval(args[1], usize)?.to_u64()?;\n                 let old_align = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 let new_size = self.value_to_primval(args[3], usize)?.to_u64()?;\n@@ -665,7 +665,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"free\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n                 if !ptr.is_null()? {\n                     self.memory.deallocate(ptr.to_ptr()?, None, Kind::C)?;\n                 }\n@@ -679,8 +679,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"dlsym\" => {\n-                let _handle = args[0].into_ptr(&mut self.memory)?;\n-                let symbol = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let _handle = args[0].into_ptr(&self.memory)?;\n+                let symbol = args[1].into_ptr(&self.memory)?.to_ptr()?;\n                 let symbol_name = self.memory.read_c_str(symbol)?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n@@ -691,8 +691,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n                 // We abort on panic, so not much is going on here, but we still have to call the closure\n                 let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n-                let f = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n-                let data = args[1].into_ptr(&mut self.memory)?;\n+                let f = args[0].into_ptr(&self.memory)?.to_ptr()?;\n+                let data = args[1].into_ptr(&self.memory)?;\n                 let f_instance = self.memory.get_fn(f)?;\n                 self.write_null(dest, dest_ty)?;\n \n@@ -723,8 +723,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"memcmp\" => {\n-                let left = args[0].into_ptr(&mut self.memory)?;\n-                let right = args[1].into_ptr(&mut self.memory)?;\n+                let left = args[0].into_ptr(&self.memory)?;\n+                let right = args[1].into_ptr(&self.memory)?;\n                 let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n \n                 let result = {\n@@ -743,7 +743,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"memrchr\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().rev().position(|&c| c == val) {\n@@ -755,7 +755,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"memchr\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?;\n+                let ptr = args[0].into_ptr(&self.memory)?;\n                 let val = self.value_to_primval(args[1], usize)?.to_u64()? as u8;\n                 let num = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, num)?.iter().position(|&c| c == val) {\n@@ -768,7 +768,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"getenv\" => {\n                 let result = {\n-                    let name_ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                    let name_ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n                     let name = self.memory.read_c_str(name_ptr)?;\n                     match self.env_vars.get(name) {\n                         Some(&var) => PrimVal::Ptr(var),\n@@ -781,7 +781,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"unsetenv\" => {\n                 let mut success = None;\n                 {\n-                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n+                    let name_ptr = args[0].into_ptr(&self.memory)?;\n                     if !name_ptr.is_null()? {\n                         let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n@@ -802,8 +802,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"setenv\" => {\n                 let mut new = None;\n                 {\n-                    let name_ptr = args[0].into_ptr(&mut self.memory)?;\n-                    let value_ptr = args[1].into_ptr(&mut self.memory)?.to_ptr()?;\n+                    let name_ptr = args[0].into_ptr(&self.memory)?;\n+                    let value_ptr = args[1].into_ptr(&self.memory)?.to_ptr()?;\n                     let value = self.memory.read_c_str(value_ptr)?;\n                     if !name_ptr.is_null()? {\n                         let name = self.memory.read_c_str(name_ptr.to_ptr()?)?;\n@@ -829,7 +829,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"write\" => {\n                 let fd = self.value_to_primval(args[0], usize)?.to_u64()?;\n-                let buf = args[1].into_ptr(&mut self.memory)?;\n+                let buf = args[1].into_ptr(&self.memory)?;\n                 let n = self.value_to_primval(args[2], usize)?.to_u64()?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 { // stdout/stderr\n@@ -846,7 +846,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"strlen\" => {\n-                let ptr = args[0].into_ptr(&mut self.memory)?.to_ptr()?;\n+                let ptr = args[0].into_ptr(&self.memory)?.to_ptr()?;\n                 let n = self.memory.read_c_str(ptr)?.len();\n                 self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n             }\n@@ -889,10 +889,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n-                let key_ptr = args[0].into_ptr(&mut self.memory)?;\n+                let key_ptr = args[0].into_ptr(&self.memory)?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor = match args[1].into_ptr(&mut self.memory)?.into_inner_primval() {\n+                let dtor = match args[1].into_ptr(&self.memory)?.into_inner_primval() {\n                     PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n                     PrimVal::Bytes(0) => None,\n                     PrimVal::Bytes(_) => return Err(EvalError::ReadBytesAsPointer),\n@@ -934,7 +934,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"pthread_setspecific\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n                 let key = self.value_to_primval(args[0], usize)?.to_u64()? as TlsKey;\n-                let new_ptr = args[1].into_ptr(&mut self.memory)?;\n+                let new_ptr = args[1].into_ptr(&self.memory)?;\n                 self.memory.store_tls(key, new_ptr)?;\n                 \n                 // Return success (0)"}, {"sha": "8c3cc1852507888ae74adf43b24eb174de4b4ac8", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=14c8e834b99ca3d422828b44ed0b2d4a76335be6", "patch": "@@ -151,7 +151,7 @@ std::sync::atomic::AtomicBool::get_mut$|\\\n     fn validate_ptr(&mut self, val: Value, pointee_ty: Ty<'tcx>, re: Option<CodeExtent>, mutbl: Mutability, mode: ValidationMode) -> EvalResult<'tcx> {\n         // Check alignment and non-NULLness\n         let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n-        let ptr = val.into_ptr(&mut self.memory)?;\n+        let ptr = val.into_ptr(&self.memory)?;\n         self.memory.check_align(ptr, align)?;\n \n         // Recurse\n@@ -309,7 +309,7 @@ std::sync::atomic::AtomicBool::get_mut$|\\\n                 self.validate_ptr(val, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n             }\n             TyFnPtr(_sig) => {\n-                let ptr = self.read_lvalue(query.lval)?.into_ptr(&mut self.memory)?.to_ptr()?;\n+                let ptr = self.read_lvalue(query.lval)?.into_ptr(&self.memory)?.to_ptr()?;\n                 self.memory.get_fn(ptr)?;\n                 // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n                 Ok(())"}, {"sha": "302ea0abec3cef067f1cd5c7f76943a259005f04", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c8e834b99ca3d422828b44ed0b2d4a76335be6/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=14c8e834b99ca3d422828b44ed0b2d4a76335be6", "patch": "@@ -167,7 +167,7 @@ impl<'a, 'tcx: 'a> Value {\n \n     /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n     /// this may have to perform a load.\n-    pub(super) fn into_ptr(&self, mem: &mut Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n+    pub(super) fn into_ptr(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr, aligned) => {\n@@ -179,7 +179,7 @@ impl<'a, 'tcx: 'a> Value {\n \n     pub(super) fn into_ptr_vtable_pair(\n         &self,\n-        mem: &mut Memory<'a, 'tcx>\n+        mem: &Memory<'a, 'tcx>\n     ) -> EvalResult<'tcx, (Pointer, MemoryPointer)> {\n         use self::Value::*;\n         match *self {\n@@ -197,11 +197,11 @@ impl<'a, 'tcx: 'a> Value {\n         }\n     }\n \n-    pub(super) fn into_slice(&self, mem: &mut Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n+    pub(super) fn into_slice(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, (Pointer, u64)> {\n         use self::Value::*;\n         match *self {\n             ByRef(ref_ptr, aligned) => {\n-                mem.write_maybe_aligned(aligned, |mem| {\n+                mem.read_maybe_aligned(aligned, |mem| {\n                     let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n                     let len = mem.read_usize(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n                     Ok((ptr, len))"}]}