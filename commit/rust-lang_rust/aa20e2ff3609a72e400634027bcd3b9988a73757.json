{"sha": "aa20e2ff3609a72e400634027bcd3b9988a73757", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMjBlMmZmMzYwOWE3MmU0MDA2MzQwMjdiY2QzYjk5ODhhNzM3NTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-15T16:40:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-19T08:29:31Z"}, "message": "Document new algorithm at a high-level.", "tree": {"sha": "97726a920a4d5ff67491c7e2d4fc5dc75b94baa4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97726a920a4d5ff67491c7e2d4fc5dc75b94baa4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa20e2ff3609a72e400634027bcd3b9988a73757", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa20e2ff3609a72e400634027bcd3b9988a73757", "html_url": "https://github.com/rust-lang/rust/commit/aa20e2ff3609a72e400634027bcd3b9988a73757", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa20e2ff3609a72e400634027bcd3b9988a73757/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b88c5d392a3a21dc3ff4202c243f6af59acaa2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b88c5d392a3a21dc3ff4202c243f6af59acaa2c", "html_url": "https://github.com/rust-lang/rust/commit/0b88c5d392a3a21dc3ff4202c243f6af59acaa2c"}], "stats": {"total": 127, "additions": 121, "deletions": 6}, "files": [{"sha": "80697cb3a41db7ffe7e02debc682e996eb3441c9", "filename": "src/librustc/middle/traits/doc.rs", "status": "modified", "additions": 117, "deletions": 2, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/aa20e2ff3609a72e400634027bcd3b9988a73757/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa20e2ff3609a72e400634027bcd3b9988a73757/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=aa20e2ff3609a72e400634027bcd3b9988a73757", "patch": "@@ -272,6 +272,123 @@ nested obligation `int : Bar<U>` to find out that `U=uint`.\n It would be good to only do *just as much* nested resolution as\n necessary. Currently, though, we just do a full resolution.\n \n+# Higher-ranked trait bounds\n+\n+One of the more subtle concepts at work are *higher-ranked trait\n+bounds*. An example of such a bound is `for<'a> MyTrait<&'a int>`.\n+Let's walk through how selection on higher-ranked trait references\n+works.\n+\n+## Basic matching and skolemization leaks\n+\n+Let's walk through the test `compile-fail/hrtb-just-for-static.rs` to see\n+how it works. The test starts with the trait `Foo`:\n+\n+```rust\n+trait Foo<X> {\n+    fn foo(&self, x: X) { }\n+}\n+```\n+\n+Let's say we have a function `want_hrtb` that wants a type which\n+implements `Foo<&'a int>` for any `'a`:\n+\n+```rust\n+fn want_hrtb<T>() where T : for<'a> Foo<&'a int> { ... }\n+```\n+\n+Now we have a struct `AnyInt` that implements `Foo<&'a int>` for any\n+`'a`:\n+\n+```rust\n+struct AnyInt;\n+impl<'a> Foo<&'a int> for AnyInt { }\n+```\n+\n+And the question is, does `AnyInt : for<'a> Foo<&'a int>`? We want the\n+answer to be yes. The algorithm for figuring it out is closely related\n+to the subtyping for higher-ranked types (which is described in\n+`middle::infer::higher_ranked::doc`, but also in a [paper by SPJ] that\n+I recommend you read).\n+\n+1. Skolemize the obligation.\n+2. Match the impl against the skolemized obligation.\n+3. Check for skolemization leaks.\n+\n+[paper by SPJ]: http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n+\n+So let's work through our example. The first thing we would do is to\n+skolemize the obligation, yielding `AnyInt : Foo<&'0 int>` (here `'0`\n+represents skolemized region #0). Note that now have no quantifiers;\n+in terms of the compiler type, this changes from a `ty::PolyTraitRef`\n+to a `TraitRef`. We would then create the `TraitRef` from the impl,\n+using fresh variables for it's bound regions (and thus getting\n+`Foo<&'$a int>`, where `'$a` is the inference variable for `'a`). Next\n+we relate the two trait refs, yielding a graph with the constraint\n+that `'0 == '$a`. Finally, we check for skolemization \"leaks\" -- a\n+leak is basically any attempt to relate a skolemized region to another\n+skolemized region, or to any region that pre-existed the impl match.\n+The leak check is done by searching from the skolemized region to find\n+the set of regions that it is related to in any way. This is called\n+the \"taint\" set. To pass the check, that set must consist *solely* of\n+itself and region variables from the impl. If the taint set includes\n+any other region, then the match is a failure. In this case, the taint\n+set for `'0` is `{'0, '$a}`, and hence the check will succeed.\n+\n+Let's consider a failure case. Imagine we also have a struct\n+\n+```rust\n+struct StaticInt;\n+impl Foo<&'static int> for StaticInt;\n+```\n+\n+We want the obligation `StaticInt : for<'a> Foo<&'a int>` to be\n+considered unsatisfied. The check begins just as before. `'a` is\n+skolemized to `'0` and the impl trait reference is instantiated to\n+`Foo<&'static int>`. When we relate those two, we get a constraint\n+like `'static == '0`. This means that the taint set for `'0` is `{'0,\n+'static}`, which fails the leak check.\n+\n+## Higher-ranked trait obligations\n+\n+Once the basic matching is done, we get to another interesting topic:\n+how to deal with impl obligations. I'll work through a simple example\n+here. Imagine we have the traits `Foo` and `Bar` and an associated impl:\n+\n+```\n+trait Foo<X> {\n+    fn foo(&self, x: X) { }\n+}\n+\n+trait Bar<X> {\n+    fn bar(&self, x: X) { }\n+}\n+\n+impl<X,F> Foo<X> for F\n+    where F : Bar<X>\n+{\n+}\n+```\n+\n+Now let's say we have a obligation `for<'a> Foo<&'a int>` and we match\n+this impl. What obligation is generated as a result? We want to get\n+`for<'a> Bar<&'a int>`, but how does that happen?\n+\n+After the matching, we are in a position where we have a skolemized\n+substitution like `X => &'0 int`. If we apply this substitution to the\n+impl obligations, we get `F : Bar<&'0 int>`. Obviously this is not\n+directly usable because the skolemized region `'0` cannot leak out of\n+our computation.\n+\n+What we do is to create an inverse mapping from the taint set of `'0`\n+back to the original bound region (`'a`, here) that `'0` resulted\n+from. (This is done in `higher_ranked::plug_leaks`). We know that the\n+leak check passed, so this taint set consists solely of the skolemized\n+region itself plus various intermediate region variables. We then walk\n+the trait-reference and convert every region in that taint set back to\n+a late-bound region, so in this case we'd wind up with `for<'a> F :\n+Bar<&'a int>`.\n+\n # Caching and subtle considerations therewith\n \n In general we attempt to cache the results of trait selection.  This\n@@ -400,6 +517,4 @@ there is no other type the user could enter. However, it is not\n future; we wouldn't have to guess types, in particular, we could be\n led by the impls.\n \n-\n-\n */"}, {"sha": "5eb8fd69312582100f2e64b7d024f1e1f801ed05", "filename": "src/test/compile-fail/hrtb-conflate-regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa20e2ff3609a72e400634027bcd3b9988a73757/src%2Ftest%2Fcompile-fail%2Fhrtb-conflate-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa20e2ff3609a72e400634027bcd3b9988a73757/src%2Ftest%2Fcompile-fail%2Fhrtb-conflate-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-conflate-regions.rs?ref=aa20e2ff3609a72e400634027bcd3b9988a73757", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test what an impl with only one bound region `'a` cannot be used to\n-// satisfy a constraint whre there are two bound regions.\n+// Test that an impl with only one bound region `'a` cannot be used to\n+// satisfy a constraint where there are two bound regions.\n \n trait Foo<X> {\n     fn foo(&self, x: X) { }"}, {"sha": "36a45400eec1a3e14406ae109c14025288864f2e", "filename": "src/test/compile-fail/hrtb-just-for-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa20e2ff3609a72e400634027bcd3b9988a73757/src%2Ftest%2Fcompile-fail%2Fhrtb-just-for-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa20e2ff3609a72e400634027bcd3b9988a73757/src%2Ftest%2Fcompile-fail%2Fhrtb-just-for-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-just-for-static.rs?ref=aa20e2ff3609a72e400634027bcd3b9988a73757", "patch": "@@ -27,7 +27,7 @@ fn give_any() {\n     want_hrtb::<AnyInt>()\n }\n \n-// StaticInt only implements Foo<&'a int> for 'a, so it is an error.\n+// StaticInt only implements Foo<&'static int>, so it is an error.\n struct StaticInt;\n impl Foo<&'static int> for StaticInt { }\n fn give_static() {"}, {"sha": "9fe8f9ab46ddc429fe07edad9ebf3fca50a6d8cc", "filename": "src/test/compile-fail/hrtb-type-outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa20e2ff3609a72e400634027bcd3b9988a73757/src%2Ftest%2Fcompile-fail%2Fhrtb-type-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa20e2ff3609a72e400634027bcd3b9988a73757/src%2Ftest%2Fcompile-fail%2Fhrtb-type-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-type-outlives.rs?ref=aa20e2ff3609a72e400634027bcd3b9988a73757", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test what happens when a HR obligation is applie to an impl with\n+// Test what happens when a HR obligation is applied to an impl with\n // \"outlives\" bounds. Currently we're pretty conservative here; this\n // will probably improve in time.\n "}]}