{"sha": "3f21b812bec836dc3bc0f56d4e34b7c46ec68af1", "node_id": "C_kwDOAAsO6NoAKDNmMjFiODEyYmVjODM2ZGMzYmMwZjU2ZDRlMzRiN2M0NmVjNjhhZjE", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev+love@gmail.com", "date": "2023-01-12T20:47:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-12T20:47:21Z"}, "message": "Rollup merge of #106446 - bzEq:fix-unwind-lsda, r=Amanieu\n\n[LSDA] Take ttype_index into account when taking unwind action\n\nIf `cs_action != 0`, we should check the `ttype_index` field in action record. If `ttype_index == 0`, a clean up action is taken; otherwise catch action is taken.\n\nThis can fix unwind failure on AIX which uses LLVM's libunwind by default. IIUC, rust's LSDA is borrowed from c++ and I'm assuming itanium-cxx-abi https://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf should be followed, so the fix follows what libcxxabi does. See https://github.com/llvm/llvm-project/blob/ec48682ce9f61d056361c5095f21e930b8365661/libcxxabi/src/cxa_personality.cpp#L152 for use of `ttype_index`.", "tree": {"sha": "07315c53a463f7a78a79a40201491ce661af456d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07315c53a463f7a78a79a40201491ce661af456d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f21b812bec836dc3bc0f56d4e34b7c46ec68af1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjwHHZCRBK7hj4Ov3rIwAAcM0IAJ+GZpqSJvtZskUpo0aJ/i1m\nTj5BSVCiaNOx3mZFMj2eB1AWdmSvI5klUmiBjeouUWroJgk1MC+q7ZfkSn74bfDn\ncBFWLSoAr0HpdEBgpNB61AYvmDWtOag9UTkWKumUQQ/kn8TjCmUF+MEoh+2tquPp\nXoCts1WznO9gZE00tE0U3i/HmVHGUE6xDSeHOQShc38qkz0uxYP0T1gebFmeGVE3\nb2eqnhIk84crnX3lI4opkRhLlXr0U1IP6zze+Rwl+p22X/fsZWkokO/1q+a59CGF\n11JgFku+0Wd14QZAMSag5wDICSEXmd29/t3Kbw/jdgb906Ebvlnmokqzl+jpwls=\n=9Jhp\n-----END PGP SIGNATURE-----\n", "payload": "tree 07315c53a463f7a78a79a40201491ce661af456d\nparent fa8f77a1deb0952fa81fd4f2f0809ceec8d7f7e8\nparent 93ef4b3991d19cddf011da8f0b5a7bf9a8672541\nauthor Yuki Okushi <huyuumi.dev+love@gmail.com> 1673556441 +0900\ncommitter GitHub <noreply@github.com> 1673556441 +0900\n\nRollup merge of #106446 - bzEq:fix-unwind-lsda, r=Amanieu\n\n[LSDA] Take ttype_index into account when taking unwind action\n\nIf `cs_action != 0`, we should check the `ttype_index` field in action record. If `ttype_index == 0`, a clean up action is taken; otherwise catch action is taken.\n\nThis can fix unwind failure on AIX which uses LLVM's libunwind by default. IIUC, rust's LSDA is borrowed from c++ and I'm assuming itanium-cxx-abi https://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf should be followed, so the fix follows what libcxxabi does. See https://github.com/llvm/llvm-project/blob/ec48682ce9f61d056361c5095f21e930b8365661/libcxxabi/src/cxa_personality.cpp#L152 for use of `ttype_index`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f21b812bec836dc3bc0f56d4e34b7c46ec68af1", "html_url": "https://github.com/rust-lang/rust/commit/3f21b812bec836dc3bc0f56d4e34b7c46ec68af1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f21b812bec836dc3bc0f56d4e34b7c46ec68af1/comments", "author": null, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa8f77a1deb0952fa81fd4f2f0809ceec8d7f7e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa8f77a1deb0952fa81fd4f2f0809ceec8d7f7e8", "html_url": "https://github.com/rust-lang/rust/commit/fa8f77a1deb0952fa81fd4f2f0809ceec8d7f7e8"}, {"sha": "93ef4b3991d19cddf011da8f0b5a7bf9a8672541", "url": "https://api.github.com/repos/rust-lang/rust/commits/93ef4b3991d19cddf011da8f0b5a7bf9a8672541", "html_url": "https://github.com/rust-lang/rust/commit/93ef4b3991d19cddf011da8f0b5a7bf9a8672541"}], "stats": {"total": 31, "additions": 22, "deletions": 9}, "files": [{"sha": "87585a8fcd0d72868e78631742e963783d0d7750", "filename": "library/std/src/personality/dwarf/eh.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3f21b812bec836dc3bc0f56d4e34b7c46ec68af1/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f21b812bec836dc3bc0f56d4e34b7c46ec68af1/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs?ref=3f21b812bec836dc3bc0f56d4e34b7c46ec68af1", "patch": "@@ -84,7 +84,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>) -> Result\n             let cs_start = read_encoded_pointer(&mut reader, context, call_site_encoding)?;\n             let cs_len = read_encoded_pointer(&mut reader, context, call_site_encoding)?;\n             let cs_lpad = read_encoded_pointer(&mut reader, context, call_site_encoding)?;\n-            let cs_action = reader.read_uleb128();\n+            let cs_action_entry = reader.read_uleb128();\n             // Callsite table is sorted by cs_start, so if we've passed the ip, we\n             // may stop searching.\n             if ip < func_start + cs_start {\n@@ -95,7 +95,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>) -> Result\n                     return Ok(EHAction::None);\n                 } else {\n                     let lpad = lpad_base + cs_lpad;\n-                    return Ok(interpret_cs_action(cs_action, lpad));\n+                    return Ok(interpret_cs_action(action_table as *mut u8, cs_action_entry, lpad));\n                 }\n             }\n         }\n@@ -113,26 +113,39 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext<'_>) -> Result\n         let mut idx = ip;\n         loop {\n             let cs_lpad = reader.read_uleb128();\n-            let cs_action = reader.read_uleb128();\n+            let cs_action_entry = reader.read_uleb128();\n             idx -= 1;\n             if idx == 0 {\n                 // Can never have null landing pad for sjlj -- that would have\n                 // been indicated by a -1 call site index.\n                 let lpad = (cs_lpad + 1) as usize;\n-                return Ok(interpret_cs_action(cs_action, lpad));\n+                return Ok(interpret_cs_action(action_table as *mut u8, cs_action_entry, lpad));\n             }\n         }\n     }\n }\n \n-fn interpret_cs_action(cs_action: u64, lpad: usize) -> EHAction {\n-    if cs_action == 0 {\n-        // If cs_action is 0 then this is a cleanup (Drop::drop). We run these\n+unsafe fn interpret_cs_action(\n+    action_table: *mut u8,\n+    cs_action_entry: u64,\n+    lpad: usize,\n+) -> EHAction {\n+    if cs_action_entry == 0 {\n+        // If cs_action_entry is 0 then this is a cleanup (Drop::drop). We run these\n         // for both Rust panics and foreign exceptions.\n         EHAction::Cleanup(lpad)\n     } else {\n-        // Stop unwinding Rust panics at catch_unwind.\n-        EHAction::Catch(lpad)\n+        // If lpad != 0 and cs_action_entry != 0, we have to check ttype_index.\n+        // If ttype_index == 0 under the condition, we take cleanup action.\n+        let action_record = (action_table as *mut u8).offset(cs_action_entry as isize - 1);\n+        let mut action_reader = DwarfReader::new(action_record);\n+        let ttype_index = action_reader.read_sleb128();\n+        if ttype_index == 0 {\n+            EHAction::Cleanup(lpad)\n+        } else {\n+            // Stop unwinding Rust panics at catch_unwind.\n+            EHAction::Catch(lpad)\n+        }\n     }\n }\n "}]}