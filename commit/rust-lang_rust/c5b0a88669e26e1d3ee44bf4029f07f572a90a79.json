{"sha": "c5b0a88669e26e1d3ee44bf4029f07f572a90a79", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YjBhODg2NjllMjZlMWQzZWU0NGJmNDAyOWYwN2Y1NzJhOTBhNzk=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-10-20T03:10:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-20T03:10:52Z"}, "message": "Rollup merge of #77612 - ssomers:btree_cleanup_2, r=Mark-Simulacrum\n\nBTreeMap: test invariants more thoroughly and more readably\n\nr? @Mark-Simulacrum", "tree": {"sha": "0dc5181de8c0f765f4d2ad5a041714519e8cbd71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dc5181de8c0f765f4d2ad5a041714519e8cbd71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5b0a88669e26e1d3ee44bf4029f07f572a90a79", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfjlU9CRBK7hj4Ov3rIwAAdHIIAJ7NNaILezHES5bG+/1vTAhc\nV0uHDy5z6tP3ynqYqp43swg2xM1zW1nvXkg2RusFZYSkgyhldTs9V+uxJRZ85aof\nMmJp0xqRjmg9rkLBwz3kMCGmRAcrJYAMPoG70ImHFac+ghDqEjtUswRBuXwcMIPl\n9SBZ/R3MFoP/a/ZhpsgggDJ3Bln38fjDlHNpK6r7Mt01Zu9i1J5EYuwKveLKhKKk\nYlJdq+c82qMJjlt4DFAasSKURV+rtZ3qD3Rsmj6mfxFYYS1+xHLGFFrVeo1cOVdy\nJfYx476xRw9FIQAOhVb8jLNNUQn0btm0Z7HUhvkmRGa4SL1Df9VOecWLvVSfqb4=\n=rZ/t\n-----END PGP SIGNATURE-----\n", "payload": "tree 0dc5181de8c0f765f4d2ad5a041714519e8cbd71\nparent a85e94927622665a9e9022de0d33a890a2e32d43\nparent 488b999fc20896318192f8e22709095cccd0a6bf\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1603163452 +0900\ncommitter GitHub <noreply@github.com> 1603163452 +0900\n\nRollup merge of #77612 - ssomers:btree_cleanup_2, r=Mark-Simulacrum\n\nBTreeMap: test invariants more thoroughly and more readably\n\nr? @Mark-Simulacrum\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5b0a88669e26e1d3ee44bf4029f07f572a90a79", "html_url": "https://github.com/rust-lang/rust/commit/c5b0a88669e26e1d3ee44bf4029f07f572a90a79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5b0a88669e26e1d3ee44bf4029f07f572a90a79/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a85e94927622665a9e9022de0d33a890a2e32d43", "url": "https://api.github.com/repos/rust-lang/rust/commits/a85e94927622665a9e9022de0d33a890a2e32d43", "html_url": "https://github.com/rust-lang/rust/commit/a85e94927622665a9e9022de0d33a890a2e32d43"}, {"sha": "488b999fc20896318192f8e22709095cccd0a6bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/488b999fc20896318192f8e22709095cccd0a6bf", "html_url": "https://github.com/rust-lang/rust/commit/488b999fc20896318192f8e22709095cccd0a6bf"}], "stats": {"total": 194, "additions": 115, "deletions": 79}, "files": [{"sha": "b51b95a635c87ba9cb60acc80db0eba0424cf49c", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 10, "deletions": 79, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c5b0a88669e26e1d3ee44bf4029f07f572a90a79/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5b0a88669e26e1d3ee44bf4029f07f572a90a79/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=c5b0a88669e26e1d3ee44bf4029f07f572a90a79", "patch": "@@ -1,4 +1,4 @@\n-use super::super::{navigate::Position, node, DeterministicRng};\n+use super::super::{node, DeterministicRng};\n use super::Entry::{Occupied, Vacant};\n use super::*;\n use crate::boxed::Box;\n@@ -7,7 +7,7 @@ use crate::rc::Rc;\n use crate::string::{String, ToString};\n use crate::vec::Vec;\n use std::convert::TryFrom;\n-use std::iter::FromIterator;\n+use std::iter::{self, FromIterator};\n use std::mem;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n@@ -42,19 +42,6 @@ fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>\n     }\n }\n \n-struct SeriesChecker<T> {\n-    previous: Option<T>,\n-}\n-\n-impl<T: Copy + Debug + Ord> SeriesChecker<T> {\n-    fn is_ascending(&mut self, next: T) {\n-        if let Some(previous) = self.previous {\n-            assert!(previous < next, \"{:?} >= {:?}\", previous, next);\n-        }\n-        self.previous = Some(next);\n-    }\n-}\n-\n impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n     /// Panics if the map (or the code navigating it) is corrupted.\n     fn check(&self)\n@@ -63,44 +50,10 @@ impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n     {\n         if let Some(root) = &self.root {\n             let root_node = root.node_as_ref();\n-            let mut checker = SeriesChecker { previous: None };\n-            let mut internal_length = 0;\n-            let mut internal_kv_count = 0;\n-            let mut leaf_length = 0;\n-            root_node.visit_nodes_in_order(|pos| match pos {\n-                Position::Leaf(node) => {\n-                    let is_root = root_node.height() == 0;\n-                    let min_len = if is_root { 0 } else { node::MIN_LEN };\n-                    assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n-\n-                    for idx in 0..node.len() {\n-                        let key = *unsafe { node.key_at(idx) };\n-                        checker.is_ascending(key);\n-                    }\n-                    leaf_length += node.len();\n-                }\n-                Position::Internal(node) => {\n-                    let is_root = root_node.height() == node.height();\n-                    let min_len = if is_root { 1 } else { node::MIN_LEN };\n-                    assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n-\n-                    for idx in 0..=node.len() {\n-                        let edge = unsafe { node::Handle::new_edge(node, idx) };\n-                        assert!(edge.descend().ascend().ok().unwrap() == edge);\n-                    }\n-\n-                    internal_length += node.len();\n-                }\n-                Position::InternalKV(kv) => {\n-                    let key = *kv.into_kv().0;\n-                    checker.is_ascending(key);\n-\n-                    internal_kv_count += 1;\n-                }\n-            });\n-            assert_eq!(internal_length, internal_kv_count);\n-            assert_eq!(root_node.calc_length(), internal_length + leaf_length);\n-            assert_eq!(self.length, internal_length + leaf_length);\n+            assert!(root_node.ascend().is_err());\n+            root_node.assert_back_pointers();\n+            root_node.assert_ascending();\n+            assert_eq!(self.length, root_node.assert_and_add_lengths());\n         } else {\n             assert_eq!(self.length, 0);\n         }\n@@ -116,28 +69,7 @@ impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n         K: Debug,\n     {\n         if let Some(root) = self.root.as_ref() {\n-            let mut result = String::new();\n-            let root_node = root.node_as_ref();\n-            root_node.visit_nodes_in_order(|pos| match pos {\n-                Position::Leaf(leaf) => {\n-                    let depth = root_node.height();\n-                    let indent = \"  \".repeat(depth);\n-                    result += &format!(\"\\n{}\", indent);\n-                    for idx in 0..leaf.len() {\n-                        if idx > 0 {\n-                            result += \", \";\n-                        }\n-                        result += &format!(\"{:?}\", unsafe { leaf.key_at(idx) });\n-                    }\n-                }\n-                Position::Internal(_) => {}\n-                Position::InternalKV(kv) => {\n-                    let depth = root_node.height() - kv.into_node().height();\n-                    let indent = \"  \".repeat(depth);\n-                    result += &format!(\"\\n{}{:?}\", indent, kv.into_kv().0);\n-                }\n-            });\n-            result\n+            root.node_as_ref().dump_keys()\n         } else {\n             String::from(\"not yet allocated\")\n         }\n@@ -170,7 +102,6 @@ fn test_levels() {\n         let last_key = *map.last_key_value().unwrap().0;\n         map.insert(last_key + 1, ());\n     }\n-    println!(\"{}\", map.dump_keys());\n     map.check();\n     // Structure:\n     // - 1 element in internal root node with 2 children\n@@ -372,7 +303,7 @@ fn test_iter_rev() {\n fn do_test_iter_mut_mutation<T>(size: usize)\n where\n     T: Copy + Debug + Ord + TryFrom<usize>,\n-    <T as std::convert::TryFrom<usize>>::Error: std::fmt::Debug,\n+    <T as TryFrom<usize>>::Error: Debug,\n {\n     let zero = T::try_from(0).unwrap();\n     let mut map: BTreeMap<T, T> = (0..size).map(|i| (T::try_from(i).unwrap(), zero)).collect();\n@@ -857,7 +788,7 @@ mod test_drain_filter {\n     fn consuming_nothing() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: BTreeMap<_, _> = pairs.collect();\n-        assert!(map.drain_filter(|_, _| false).eq(std::iter::empty()));\n+        assert!(map.drain_filter(|_, _| false).eq(iter::empty()));\n         map.check();\n     }\n \n@@ -878,7 +809,7 @@ mod test_drain_filter {\n                 *v += 6;\n                 false\n             })\n-            .eq(std::iter::empty())\n+            .eq(iter::empty())\n         );\n         assert!(map.keys().copied().eq(0..3));\n         assert!(map.values().copied().eq(6..9));"}, {"sha": "e56fc2aa51e7c1dfc8bbef4dd57c1cca6327a60e", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/c5b0a88669e26e1d3ee44bf4029f07f572a90a79/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5b0a88669e26e1d3ee44bf4029f07f572a90a79/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=c5b0a88669e26e1d3ee44bf4029f07f572a90a79", "patch": "@@ -1,6 +1,111 @@\n+use super::super::navigate;\n use super::*;\n+use crate::fmt::Debug;\n+use crate::string::String;\n use core::cmp::Ordering::*;\n \n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n+    pub fn assert_back_pointers(self) {\n+        match self.force() {\n+            ForceResult::Leaf(_) => {}\n+            ForceResult::Internal(node) => {\n+                for idx in 0..=node.len() {\n+                    let edge = unsafe { Handle::new_edge(node, idx) };\n+                    let child = edge.descend();\n+                    assert!(child.ascend().ok() == Some(edge));\n+                    child.assert_back_pointers();\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn assert_ascending(self)\n+    where\n+        K: Copy + Debug + Ord,\n+    {\n+        struct SeriesChecker<T> {\n+            previous: Option<T>,\n+        }\n+        impl<T: Copy + Debug + Ord> SeriesChecker<T> {\n+            fn is_ascending(&mut self, next: T) {\n+                if let Some(previous) = self.previous {\n+                    assert!(previous < next, \"{:?} >= {:?}\", previous, next);\n+                }\n+                self.previous = Some(next);\n+            }\n+        }\n+\n+        let mut checker = SeriesChecker { previous: None };\n+        self.visit_nodes_in_order(|pos| match pos {\n+            navigate::Position::Leaf(node) => {\n+                for idx in 0..node.len() {\n+                    let key = *unsafe { node.key_at(idx) };\n+                    checker.is_ascending(key);\n+                }\n+            }\n+            navigate::Position::InternalKV(kv) => {\n+                let key = *kv.into_kv().0;\n+                checker.is_ascending(key);\n+            }\n+            navigate::Position::Internal(_) => {}\n+        });\n+    }\n+\n+    pub fn assert_and_add_lengths(self) -> usize {\n+        let mut internal_length = 0;\n+        let mut internal_kv_count = 0;\n+        let mut leaf_length = 0;\n+        self.visit_nodes_in_order(|pos| match pos {\n+            navigate::Position::Leaf(node) => {\n+                let is_root = self.height() == 0;\n+                let min_len = if is_root { 0 } else { MIN_LEN };\n+                assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n+                leaf_length += node.len();\n+            }\n+            navigate::Position::Internal(node) => {\n+                let is_root = self.height() == node.height();\n+                let min_len = if is_root { 1 } else { MIN_LEN };\n+                assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n+                internal_length += node.len();\n+            }\n+            navigate::Position::InternalKV(_) => {\n+                internal_kv_count += 1;\n+            }\n+        });\n+        assert_eq!(internal_length, internal_kv_count);\n+        let total = internal_length + leaf_length;\n+        assert_eq!(self.calc_length(), total);\n+        total\n+    }\n+\n+    pub fn dump_keys(self) -> String\n+    where\n+        K: Debug,\n+    {\n+        let mut result = String::new();\n+        self.visit_nodes_in_order(|pos| match pos {\n+            navigate::Position::Leaf(leaf) => {\n+                let depth = self.height();\n+                let indent = \"  \".repeat(depth);\n+                result += &format!(\"\\n{}\", indent);\n+                for idx in 0..leaf.len() {\n+                    if idx > 0 {\n+                        result += \", \";\n+                    }\n+                    result += &format!(\"{:?}\", unsafe { leaf.key_at(idx) });\n+                }\n+            }\n+            navigate::Position::Internal(_) => {}\n+            navigate::Position::InternalKV(kv) => {\n+                let depth = self.height() - kv.into_node().height();\n+                let indent = \"  \".repeat(depth);\n+                result += &format!(\"\\n{}{:?}\", indent, kv.into_kv().0);\n+            }\n+        });\n+        result\n+    }\n+}\n+\n #[test]\n fn test_splitpoint() {\n     for idx in 0..=CAPACITY {"}]}