{"sha": "e936071fbf22e8fb48e7e473d35b01df453278e2", "node_id": "C_kwDOAAsO6NoAKGU5MzYwNzFmYmYyMmU4ZmI0OGU3ZTQ3M2QzNWIwMWRmNDUzMjc4ZTI", "commit": {"author": {"name": "Daniel Henry-Mantilla", "email": "daniel.henry.mantilla@gmail.com", "date": "2021-12-09T18:27:27Z"}, "committer": {"name": "Daniel Henry-Mantilla", "email": "daniel.henry.mantilla@gmail.com", "date": "2021-12-09T20:05:29Z"}, "message": "Minor improvements to `future::join!`'s implementation\n\nThis is a follow-up from #91645, regarding [some remarks I made](https://rust-lang.zulipchat.com/#narrow/stream/187312-wg-async-foundations/topic/join!/near/264293660).\n\nMainly:\n  - it hides the recursive munching through a private `macro`, to avoid leaking such details (a corollary is getting rid of the need to use `@` to disambiguate);\n  - it uses a `match` binding, _outside_ the `async move` block, to better match the semantics from function-like syntax;\n  - it pre-pins the future before calling into `poll_fn`, since `poll_fn`, alone, cannot guarantee that its capture does not move;\n  - it uses `.ready()?` since it's such a neat pattern;\n  - it renames `Took` to `Taken` for consistency with `Done`.", "tree": {"sha": "bd515fb7360116fda9f0ba54d271219ab9c80812", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd515fb7360116fda9f0ba54d271219ab9c80812"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e936071fbf22e8fb48e7e473d35b01df453278e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e936071fbf22e8fb48e7e473d35b01df453278e2", "html_url": "https://github.com/rust-lang/rust/commit/e936071fbf22e8fb48e7e473d35b01df453278e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e936071fbf22e8fb48e7e473d35b01df453278e2/comments", "author": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "committer": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b42deaccc2cbe17a68067aa5fdb76104369e1fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b42deaccc2cbe17a68067aa5fdb76104369e1fd", "html_url": "https://github.com/rust-lang/rust/commit/0b42deaccc2cbe17a68067aa5fdb76104369e1fd"}], "stats": {"total": 150, "additions": 97, "deletions": 53}, "files": [{"sha": "afab1bab7421a1fdcfd673f612d0ce01ae4d46ca", "filename": "library/core/src/future/join.rs", "status": "modified", "additions": 97, "deletions": 53, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/e936071fbf22e8fb48e7e473d35b01df453278e2/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e936071fbf22e8fb48e7e473d35b01df453278e2/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs?ref=e936071fbf22e8fb48e7e473d35b01df453278e2", "patch": "@@ -45,59 +45,102 @@ use crate::task::{Context, Poll};\n /// # };\n /// ```\n #[unstable(feature = \"future_join\", issue = \"91642\")]\n-pub macro join {\n-    ( $($fut:expr),* $(,)?) => {\n-        join! { @count: (), @futures: {}, @rest: ($($fut,)*) }\n-    },\n-    // Recurse until we have the position of each future in the tuple\n+pub macro join( $($fut:expr),+ $(,)? ) {\n+    // Funnel through an internal macro not to leak implementation details.\n+    join_internal! {\n+        current_position[]\n+        futures_and_positions[]\n+        munching[ $($fut)+ ]\n+    }\n+}\n+\n+/// To be able to *name* the i-th future in the tuple (say we want the .4-th),\n+/// the following trick will be used: `let (_, _, _, _, it, ..) = tuple;`\n+/// In order to do that, we need to generate a `i`-long repetition of `_`,\n+/// for each i-th fut. Hence the recursive muncher approach.\n+macro join_internal {\n+    // Recursion step: map each future with its \"position\" (underscore count).\n     (\n-        // A token for each future that has been expanded: \"_ _ _\"\n-        @count: ($($count:tt)*),\n-        // Futures and their positions in the tuple: \"{ a => (_), b => (_ _)) }\"\n-        @futures: { $($fut:tt)* },\n-        // Take a future from @rest to expand\n-        @rest: ($current:expr, $($rest:tt)*)\n-    ) => {\n-        join! {\n-            @count: ($($count)* _),\n-            @futures: { $($fut)* $current => ($($count)*), },\n-            @rest: ($($rest)*)\n+        // Accumulate a token for each future that has been expanded: \"_ _ _\".\n+        current_position[\n+            $($underscores:tt)*\n+        ]\n+        // Accumulate Futures and their positions in the tuple: `_0th ()   _1st ( _ ) \u2026`.\n+        futures_and_positions[\n+            $($acc:tt)*\n+        ]\n+        // Munch one future.\n+        munching[\n+            $current:tt\n+            $($rest:tt)*\n+        ]\n+    ) => (\n+        join_internal! {\n+            current_position[\n+                $($underscores)*\n+                _\n+            ]\n+            futures_and_positions[\n+                $($acc)*\n+                $current ( $($underscores)* )\n+            ]\n+            munching[\n+                $($rest)*\n+            ]\n         }\n-    },\n-    // Now generate the output future\n-    (\n-        @count: ($($count:tt)*),\n-        @futures: {\n-            $( $(@$f:tt)? $fut:expr => ( $($pos:tt)* ), )*\n-        },\n-        @rest: ()\n-    ) => {\n-        async move {\n-            let mut futures = ( $( MaybeDone::Future($fut), )* );\n+    ),\n \n+    // End of recursion: generate the output future.\n+    (\n+        current_position $_:tt\n+        futures_and_positions[\n+            $(\n+                $fut_expr:tt ( $($pos:tt)* )\n+            )*\n+        ]\n+        // Nothing left to munch.\n+        munching[]\n+    ) => (\n+        match ( $( MaybeDone::Future($fut_expr), )* ) { futures => async {\n+            let mut futures = futures;\n+            // SAFETY: this is `pin_mut!`.\n+            let futures = unsafe { Pin::new_unchecked(&mut futures) };\n             poll_fn(move |cx| {\n                 let mut done = true;\n-\n+                // For each `fut`, pin-project to it, and poll it.\n                 $(\n-                    let ( $($pos,)* fut, .. ) = &mut futures;\n-\n-                    // SAFETY: The futures are never moved\n-                    done &= unsafe { Pin::new_unchecked(fut).poll(cx).is_ready() };\n+                    // SAFETY: pinning projection\n+                    let fut = unsafe {\n+                        futures.as_mut().map_unchecked_mut(|it| {\n+                            let ( $($pos,)* fut, .. ) = it;\n+                            fut\n+                        })\n+                    };\n+                    // Despite how tempting it may be to `let () = fut.poll(cx).ready()?;`\n+                    // doing so would defeat the point of `join!`: to start polling eagerly all\n+                    // of the futures, to allow parallelizing the waits.\n+                    done &= fut.poll(cx).is_ready();\n                 )*\n-\n-                if done {\n-                    // Extract all the outputs\n-                    Poll::Ready(($({\n-                        let ( $($pos,)* fut, .. ) = &mut futures;\n-\n-                        fut.take_output().unwrap()\n-                    }),*))\n-                } else {\n-                    Poll::Pending\n+                if !done {\n+                    return Poll::Pending;\n                 }\n+                // All ready; time to extract all the outputs.\n+\n+                // SAFETY: `.take_output()` does not break the `Pin` invariants for that `fut`.\n+                let futures = unsafe {\n+                    futures.as_mut().get_unchecked_mut()\n+                };\n+                Poll::Ready(\n+                    ($(\n+                        {\n+                            let ( $($pos,)* fut, .. ) = &mut *futures;\n+                            fut.take_output().unwrap()\n+                        }\n+                    ),*) // <- no trailing comma since we don't want 1-tuples.\n+                )\n             }).await\n-        }\n-    }\n+        }}\n+    ),\n }\n \n /// Future used by `join!` that stores it's output to\n@@ -109,14 +152,14 @@ pub macro join {\n pub enum MaybeDone<F: Future> {\n     Future(F),\n     Done(F::Output),\n-    Took,\n+    Taken,\n }\n \n #[unstable(feature = \"future_join\", issue = \"91642\")]\n impl<F: Future> MaybeDone<F> {\n     pub fn take_output(&mut self) -> Option<F::Output> {\n-        match &*self {\n-            MaybeDone::Done(_) => match mem::replace(self, Self::Took) {\n+        match *self {\n+            MaybeDone::Done(_) => match mem::replace(self, Self::Taken) {\n                 MaybeDone::Done(val) => Some(val),\n                 _ => unreachable!(),\n             },\n@@ -132,13 +175,14 @@ impl<F: Future> Future for MaybeDone<F> {\n     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n         // SAFETY: pinning in structural for `f`\n         unsafe {\n-            match self.as_mut().get_unchecked_mut() {\n-                MaybeDone::Future(f) => match Pin::new_unchecked(f).poll(cx) {\n-                    Poll::Ready(val) => self.set(Self::Done(val)),\n-                    Poll::Pending => return Poll::Pending,\n-                },\n+            // Do not mix match ergonomics with unsafe.\n+            match *self.as_mut().get_unchecked_mut() {\n+                MaybeDone::Future(ref mut f) => {\n+                    let val = Pin::new_unchecked(f).poll(cx).ready()?;\n+                    self.set(Self::Done(val));\n+                }\n                 MaybeDone::Done(_) => {}\n-                MaybeDone::Took => unreachable!(),\n+                MaybeDone::Taken => unreachable!(),\n             }\n         }\n "}]}