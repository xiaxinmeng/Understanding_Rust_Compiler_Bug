{"sha": "274c85f5c80f6a8ae800bf9054e49bb111824278", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NGM4NWY1YzgwZjZhOGFlODAwYmY5MDU0ZTQ5YmIxMTE4MjQyNzg=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-04-19T17:23:57Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-04-23T18:01:55Z"}, "message": "Don't cache result of `in_any_value_of_ty` for locals\n\nThis was needed by an early version of dataflow-based const\nqualification where `QualifCursor` needed to return a full `BitSet` with\nthe current state.", "tree": {"sha": "3e68bcd8065a8cb79813e6b520d2d180becfa1b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e68bcd8065a8cb79813e6b520d2d180becfa1b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/274c85f5c80f6a8ae800bf9054e49bb111824278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/274c85f5c80f6a8ae800bf9054e49bb111824278", "html_url": "https://github.com/rust-lang/rust/commit/274c85f5c80f6a8ae800bf9054e49bb111824278", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/274c85f5c80f6a8ae800bf9054e49bb111824278/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a75c79288879fe9b87284ac897428c046d174ade", "url": "https://api.github.com/repos/rust-lang/rust/commits/a75c79288879fe9b87284ac897428c046d174ade", "html_url": "https://github.com/rust-lang/rust/commit/a75c79288879fe9b87284ac897428c046d174ade"}], "stats": {"total": 104, "additions": 51, "deletions": 53}, "files": [{"sha": "5b37edd01b37cfa183c847d3e04d0a30c2794ef9", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 51, "deletions": 53, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/274c85f5c80f6a8ae800bf9054e49bb111824278/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274c85f5c80f6a8ae800bf9054e49bb111824278/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=274c85f5c80f6a8ae800bf9054e49bb111824278", "patch": "@@ -3,7 +3,6 @@\n use rustc_errors::struct_span_err;\n use rustc_hir::lang_items;\n use rustc_hir::{def_id::DefId, HirId};\n-use rustc_index::bit_set::BitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n@@ -31,67 +30,59 @@ use crate::dataflow::{self, Analysis};\n type IndirectlyMutableResults<'mir, 'tcx> =\n     dataflow::ResultsCursor<'mir, 'tcx, MaybeMutBorrowedLocals<'mir, 'tcx>>;\n \n-struct QualifCursor<'a, 'mir, 'tcx, Q: Qualif> {\n-    cursor: dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>>,\n-    in_any_value_of_ty: BitSet<Local>,\n-}\n-\n-impl<Q: Qualif> QualifCursor<'a, 'mir, 'tcx, Q> {\n-    pub fn new(q: Q, ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n-        let cursor = FlowSensitiveAnalysis::new(q, ccx)\n-            .into_engine(ccx.tcx, ccx.body, ccx.def_id)\n-            .iterate_to_fixpoint()\n-            .into_results_cursor(ccx.body);\n-\n-        let mut in_any_value_of_ty = BitSet::new_empty(ccx.body.local_decls.len());\n-        for (local, decl) in ccx.body.local_decls.iter_enumerated() {\n-            if Q::in_any_value_of_ty(ccx, decl.ty) {\n-                in_any_value_of_ty.insert(local);\n-            }\n-        }\n-\n-        QualifCursor { cursor, in_any_value_of_ty }\n-    }\n-}\n+type QualifResults<'mir, 'tcx, Q> =\n+    dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'mir, 'mir, 'tcx, Q>>;\n \n-pub struct Qualifs<'a, 'mir, 'tcx> {\n-    has_mut_interior: QualifCursor<'a, 'mir, 'tcx, HasMutInterior>,\n-    needs_drop: QualifCursor<'a, 'mir, 'tcx, NeedsDrop>,\n+pub struct Qualifs<'mir, 'tcx> {\n+    has_mut_interior: QualifResults<'mir, 'tcx, HasMutInterior>,\n+    needs_drop: QualifResults<'mir, 'tcx, NeedsDrop>,\n     indirectly_mutable: IndirectlyMutableResults<'mir, 'tcx>,\n }\n \n-impl Qualifs<'a, 'mir, 'tcx> {\n-    fn indirectly_mutable(&mut self, local: Local, location: Location) -> bool {\n+impl Qualifs<'mir, 'tcx> {\n+    fn indirectly_mutable(\n+        &mut self,\n+        _: &Item<'mir, 'tcx>,\n+        local: Local,\n+        location: Location,\n+    ) -> bool {\n         self.indirectly_mutable.seek_before(location);\n         self.indirectly_mutable.get().contains(local)\n     }\n \n     /// Returns `true` if `local` is `NeedsDrop` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary\n-    fn needs_drop(&mut self, local: Local, location: Location) -> bool {\n-        if !self.needs_drop.in_any_value_of_ty.contains(local) {\n+    fn needs_drop(&mut self, item: &Item<'mir, 'tcx>, local: Local, location: Location) -> bool {\n+        let ty = item.body.local_decls[local].ty;\n+        if !NeedsDrop::in_any_value_of_ty(item, ty) {\n             return false;\n         }\n \n-        self.needs_drop.cursor.seek_before(location);\n-        self.needs_drop.cursor.get().contains(local) || self.indirectly_mutable(local, location)\n+        self.needs_drop.seek_before(location);\n+        self.needs_drop.get().contains(local) || self.indirectly_mutable(item, local, location)\n     }\n \n     /// Returns `true` if `local` is `HasMutInterior` at the given `Location`.\n     ///\n     /// Only updates the cursor if absolutely necessary.\n-    fn has_mut_interior(&mut self, local: Local, location: Location) -> bool {\n-        if !self.has_mut_interior.in_any_value_of_ty.contains(local) {\n+    fn has_mut_interior(\n+        &mut self,\n+        item: &Item<'mir, 'tcx>,\n+        local: Local,\n+        location: Location,\n+    ) -> bool {\n+        let ty = ccx.body.local_decls[local].ty;\n+        if !HasMutInterior::in_any_value_of_ty(ccx, ty) {\n             return false;\n         }\n \n-        self.has_mut_interior.cursor.seek_before(location);\n-        self.has_mut_interior.cursor.get().contains(local)\n-            || self.indirectly_mutable(local, location)\n+        self.has_mut_interior.seek_before(location);\n+        self.has_mut_interior.get().contains(local)\n+            || self.indirectly_mutable(item, local, location)\n     }\n \n-    fn in_return_place(&mut self, ccx: &ConstCx<'_, 'tcx>) -> ConstQualifs {\n+    fn in_return_place(&mut self, item: &Item<'mir, 'tcx>) -> ConstQualifs {\n         // Find the `Return` terminator if one exists.\n         //\n         // If no `Return` terminator exists, this MIR is divergent. Just return the conservative\n@@ -114,34 +105,31 @@ impl Qualifs<'a, 'mir, 'tcx> {\n         let return_loc = ccx.body.terminator_loc(return_block);\n \n         ConstQualifs {\n-            needs_drop: self.needs_drop(RETURN_PLACE, return_loc),\n-            has_mut_interior: self.has_mut_interior(RETURN_PLACE, return_loc),\n+            needs_drop: self.needs_drop(ccx, RETURN_PLACE, return_loc),\n+            has_mut_interior: self.has_mut_interior(ccx, RETURN_PLACE, return_loc),\n         }\n     }\n }\n \n-pub struct Validator<'a, 'mir, 'tcx> {\n-    ccx: &'a ConstCx<'mir, 'tcx>,\n-    qualifs: Qualifs<'a, 'mir, 'tcx>,\n+pub struct Validator<'mir, 'tcx> {\n+    ccx: &'mir ConstCx<'mir, 'tcx>,\n+    qualifs: Qualifs<'mir, 'tcx>,\n \n     /// The span of the current statement.\n     span: Span,\n }\n \n-impl Deref for Validator<'_, 'mir, 'tcx> {\n+impl Deref for Validator<'mir, 'tcx> {\n     type Target = ConstCx<'mir, 'tcx>;\n \n     fn deref(&self) -> &Self::Target {\n         &self.ccx\n     }\n }\n \n-impl Validator<'a, 'mir, 'tcx> {\n-    pub fn new(ccx: &'a ConstCx<'mir, 'tcx>) -> Self {\n-        let ConstCx { tcx, body, def_id, param_env, .. } = *ccx;\n-\n-        let needs_drop = QualifCursor::new(NeedsDrop, ccx);\n-        let has_mut_interior = QualifCursor::new(HasMutInterior, ccx);\n+impl Validator<'mir, 'tcx> {\n+    pub fn new(item: &'mir Item<'mir, 'tcx>) -> Self {\n+        let Item { tcx, body, def_id, param_env, .. } = *item;\n \n         // We can use `unsound_ignore_borrow_on_drop` here because custom drop impls are not\n         // allowed in a const.\n@@ -154,6 +142,16 @@ impl Validator<'a, 'mir, 'tcx> {\n             .iterate_to_fixpoint()\n             .into_results_cursor(body);\n \n+        let needs_drop = FlowSensitiveAnalysis::new(NeedsDrop, item)\n+            .into_engine(item.tcx, &item.body, item.def_id)\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(*item.body);\n+\n+        let has_mut_interior = FlowSensitiveAnalysis::new(HasMutInterior, item)\n+            .into_engine(item.tcx, &item.body, item.def_id)\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(*item.body);\n+\n         let qualifs = Qualifs { needs_drop, has_mut_interior, indirectly_mutable };\n \n         Validator { span: ccx.body.span, ccx, qualifs }\n@@ -239,7 +237,7 @@ impl Validator<'a, 'mir, 'tcx> {\n     }\n }\n \n-impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n+impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n     fn visit_basic_block_data(&mut self, bb: BasicBlock, block: &BasicBlockData<'tcx>) {\n         trace!(\"visit_basic_block_data: bb={:?} is_cleanup={:?}\", bb, block.is_cleanup);\n \n@@ -345,7 +343,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             | Rvalue::AddressOf(Mutability::Not, ref place) => {\n                 let borrowed_place_has_mut_interior = qualifs::in_place::<HasMutInterior, _>(\n                     &self.ccx,\n-                    &mut |local| self.qualifs.has_mut_interior(local, location),\n+                    &mut |local| self.qualifs.has_mut_interior(self.ccx, local, location),\n                     place.as_ref(),\n                 );\n \n@@ -571,7 +569,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 let needs_drop = if let Some(local) = dropped_place.as_local() {\n                     // Use the span where the local was declared as the span of the drop error.\n                     err_span = self.body.local_decls[local].source_info.span;\n-                    self.qualifs.needs_drop(local, location)\n+                    self.qualifs.needs_drop(self.ccx, local, location)\n                 } else {\n                     true\n                 };"}]}