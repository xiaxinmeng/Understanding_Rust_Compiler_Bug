{"sha": "7c34cf7ee3e70bbd6b1f0d8d2bd6931d75989aed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMzRjZjdlZTNlNzBiYmQ2YjFmMGQ4ZDJiZDY5MzFkNzU5ODlhZWQ=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-09-22T07:56:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-09-22T07:56:40Z"}, "message": "Rollup merge of #54415 - petrochenkov:norollback, r=estebank\n\nparser: Tweak function parameter parsing to avoid rollback on succesfull path\n\nSince rollback is not perfect and may e.g. leave non-fatal errors after it, we need to make sure compilation fails if it happens.\nSo in particular case of `fn parse_arg_general` we need to parse the \"good\" `TYPE` first and only then rollback and recover erroneous `PAT: TYPE` if necessary.\nFound when working on https://github.com/rust-lang/rfcs/pull/2544#issuecomment-423293222.\n\nr? @ghost", "tree": {"sha": "64a9f99b64bee235afd611aba8a512740ce25269", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64a9f99b64bee235afd611aba8a512740ce25269"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c34cf7ee3e70bbd6b1f0d8d2bd6931d75989aed", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbpfW4CRBK7hj4Ov3rIwAAdHIIACE1FZ5toQ/51NxXW/7uBJ2U\nXMiEuon5eYNoBexyu3hhzn4LfLtDwRvvRPWDI9UKr0CuLZil1c7f7LUihXhceJcL\nrKMjkd0tZgf7Nmpc3+6laYpNi3uU+Vc8IXJsPaCGfwnNJNJMFluBmJkM46S7mS42\nj97ygr/j81SJqKn4r9CcahSJ06+882eyBQqo2j45Eu9mXK8oKsDoM2BoCMllWjw9\n09/NDT4I8Bg6yNPsEWMEqfArkz1bEtRPOyYTkoqY5feogeCgfwdMXAjjEadhKp62\nTBEGuFyhtJhsQw/baucvKdJzWXX2ZUyniEiKYNQnIU+HU8lOsDzmPIOJKAw+UpQ=\n=xaXy\n-----END PGP SIGNATURE-----\n", "payload": "tree 64a9f99b64bee235afd611aba8a512740ce25269\nparent 0bf52b3a5be7f0b6aa38779b0d78d5469b93494f\nparent 9784d3543f524f142aae52da9d2a6ce1eb9d702a\nauthor Pietro Albini <pietro@pietroalbini.org> 1537603000 +0200\ncommitter GitHub <noreply@github.com> 1537603000 +0200\n\nRollup merge of #54415 - petrochenkov:norollback, r=estebank\n\nparser: Tweak function parameter parsing to avoid rollback on succesfull path\n\nSince rollback is not perfect and may e.g. leave non-fatal errors after it, we need to make sure compilation fails if it happens.\nSo in particular case of `fn parse_arg_general` we need to parse the \"good\" `TYPE` first and only then rollback and recover erroneous `PAT: TYPE` if necessary.\nFound when working on https://github.com/rust-lang/rfcs/pull/2544#issuecomment-423293222.\n\nr? @ghost\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c34cf7ee3e70bbd6b1f0d8d2bd6931d75989aed", "html_url": "https://github.com/rust-lang/rust/commit/7c34cf7ee3e70bbd6b1f0d8d2bd6931d75989aed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c34cf7ee3e70bbd6b1f0d8d2bd6931d75989aed/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bf52b3a5be7f0b6aa38779b0d78d5469b93494f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bf52b3a5be7f0b6aa38779b0d78d5469b93494f", "html_url": "https://github.com/rust-lang/rust/commit/0bf52b3a5be7f0b6aa38779b0d78d5469b93494f"}, {"sha": "9784d3543f524f142aae52da9d2a6ce1eb9d702a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9784d3543f524f142aae52da9d2a6ce1eb9d702a", "html_url": "https://github.com/rust-lang/rust/commit/9784d3543f524f142aae52da9d2a6ce1eb9d702a"}], "stats": {"total": 62, "additions": 26, "deletions": 36}, "files": [{"sha": "7a13beb78526cf8b0119755bcb2195bdf66077b9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7c34cf7ee3e70bbd6b1f0d8d2bd6931d75989aed/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c34cf7ee3e70bbd6b1f0d8d2bd6931d75989aed/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7c34cf7ee3e70bbd6b1f0d8d2bd6931d75989aed", "patch": "@@ -1781,27 +1781,32 @@ impl<'a> Parser<'a> {\n             (pat, self.parse_ty()?)\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n+            let parser_snapshot_before_ty = self.clone();\n+            let mut ty = self.parse_ty();\n+            if ty.is_ok() && self.token == token::Colon {\n+                // This wasn't actually a type, but a pattern looking like a type,\n+                // so we are going to rollback and re-parse for recovery.\n+                ty = self.unexpected();\n+            }\n+            match ty {\n+                Ok(ty) => {\n+                    let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n+                    let pat = P(Pat {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: PatKind::Ident(\n+                            BindingMode::ByValue(Mutability::Immutable), ident, None),\n+                        span: ty.span,\n+                    });\n+                    (pat, ty)\n+                }\n+                Err(mut err) => {\n+                    // Recover from attempting to parse the argument as a type without pattern.\n+                    err.cancel();\n+                    mem::replace(self, parser_snapshot_before_ty);\n+                    let pat = self.parse_pat()?;\n+                    self.expect(&token::Colon)?;\n+                    let ty = self.parse_ty()?;\n \n-            let parser_snapshot_before_pat = self.clone();\n-\n-            // Once we can use edition 2018 in the compiler,\n-            // replace this with real try blocks.\n-            macro_rules! try_block {\n-                ($($inside:tt)*) => (\n-                    (||{ ::std::ops::Try::from_ok({ $($inside)* }) })()\n-                )\n-            }\n-\n-            // We're going to try parsing the argument as a pattern (even though it's not\n-            // allowed). This way we can provide better errors to the user.\n-            let pat_arg: PResult<'a, _> = try_block! {\n-                let pat = self.parse_pat()?;\n-                self.expect(&token::Colon)?;\n-                (pat, self.parse_ty()?)\n-            };\n-\n-            match pat_arg {\n-                Ok((pat, ty)) => {\n                     let mut err = self.diagnostic().struct_span_err_with_code(\n                         pat.span,\n                         \"patterns aren't allowed in methods without bodies\",\n@@ -1814,6 +1819,7 @@ impl<'a> Parser<'a> {\n                         Applicability::MachineApplicable,\n                     );\n                     err.emit();\n+\n                     // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n                     let pat = P(Pat {\n                         node: PatKind::Wild,\n@@ -1822,22 +1828,6 @@ impl<'a> Parser<'a> {\n                     });\n                     (pat, ty)\n                 }\n-                Err(mut err) => {\n-                    err.cancel();\n-                    // Recover from attempting to parse the argument as a pattern. This means\n-                    // the type is alone, with no name, e.g. `fn foo(u32)`.\n-                    mem::replace(self, parser_snapshot_before_pat);\n-                    debug!(\"parse_arg_general ident_to_pat\");\n-                    let ident = Ident::new(keywords::Invalid.name(), self.prev_span);\n-                    let ty = self.parse_ty()?;\n-                    let pat = P(Pat {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: PatKind::Ident(\n-                            BindingMode::ByValue(Mutability::Immutable), ident, None),\n-                        span: ty.span,\n-                    });\n-                    (pat, ty)\n-                }\n             }\n         };\n "}]}