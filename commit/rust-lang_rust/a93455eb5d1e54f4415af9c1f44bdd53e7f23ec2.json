{"sha": "a93455eb5d1e54f4415af9c1f44bdd53e7f23ec2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MzQ1NWViNWQxZTU0ZjQ0MTVhZjljMWY0NGJkZDUzZTdmMjNlYzI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-20T10:51:48Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-20T12:13:57Z"}, "message": "Remove unit tests", "tree": {"sha": "e2169f3a98d503347d26e07a91b96a82b5a59858", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2169f3a98d503347d26e07a91b96a82b5a59858"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a93455eb5d1e54f4415af9c1f44bdd53e7f23ec2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a93455eb5d1e54f4415af9c1f44bdd53e7f23ec2", "html_url": "https://github.com/rust-lang/rust/commit/a93455eb5d1e54f4415af9c1f44bdd53e7f23ec2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a93455eb5d1e54f4415af9c1f44bdd53e7f23ec2/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7fa72abe2cc6f6852a3faeaf4d1ac7c5c371d91", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7fa72abe2cc6f6852a3faeaf4d1ac7c5c371d91", "html_url": "https://github.com/rust-lang/rust/commit/d7fa72abe2cc6f6852a3faeaf4d1ac7c5c371d91"}], "stats": {"total": 448, "additions": 3, "deletions": 445}, "files": [{"sha": "73acbb2aa0aede831ac88b9025179e84e0b54b64", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 258, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/a93455eb5d1e54f4415af9c1f44bdd53e7f23ec2/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a93455eb5d1e54f4415af9c1f44bdd53e7f23ec2/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a93455eb5d1e54f4415af9c1f44bdd53e7f23ec2", "patch": "@@ -1265,7 +1265,7 @@ mod tests {\n     use ext::mtwt;\n     use fold::Folder;\n     use parse;\n-    use parse::token::{self, keywords};\n+    use parse::token;\n     use util::parser_testing::{string_to_parser};\n     use util::parser_testing::{string_to_pat, string_to_crate, strs_to_idents};\n     use visit;\n@@ -1395,267 +1395,10 @@ mod tests {\n             );\n     }\n \n-    // renaming tests expand a crate and then check that the bindings match\n-    // the right varrefs. The specification of the test case includes the\n-    // text of the crate, and also an array of arrays.  Each element in the\n-    // outer array corresponds to a binding in the traversal of the AST\n-    // induced by visit.  Each of these arrays contains a list of indexes,\n-    // interpreted as the varrefs in the varref traversal that this binding\n-    // should match.  So, for instance, in a program with two bindings and\n-    // three varrefs, the array [[1, 2], [0]] would indicate that the first\n-    // binding should match the second two varrefs, and the second binding\n-    // should match the first varref.\n-    //\n-    // Put differently; this is a sparse representation of a boolean matrix\n-    // indicating which bindings capture which identifiers.\n-    //\n-    // Note also that this matrix is dependent on the implicit ordering of\n-    // the bindings and the varrefs discovered by the name-finder and the path-finder.\n-    //\n-    // The comparisons are done post-mtwt-resolve, so we're comparing renamed\n-    // names; differences in marks don't matter any more.\n-    //\n-    // oog... I also want tests that check \"bound-identifier-=?\". That is,\n-    // not just \"do these have the same name\", but \"do they have the same\n-    // name *and* the same marks\"? Understanding this is really pretty painful.\n-    // in principle, you might want to control this boolean on a per-varref basis,\n-    // but that would make things even harder to understand, and might not be\n-    // necessary for thorough testing.\n-    type RenamingTest = (&'static str, Vec<Vec<usize>>, bool);\n-\n-    #[test]\n-    fn automatic_renaming () {\n-        let tests: Vec<RenamingTest> =\n-            vec!(// b & c should get new names throughout, in the expr too:\n-                (\"fn a() -> i32 { let b = 13; let c = b; b+c }\",\n-                 vec!(vec!(0,1),vec!(2)), false),\n-                // both x's should be renamed (how is this causing a bug?)\n-                (\"fn main () {let x: i32 = 13;x;}\",\n-                 vec!(vec!(0)), false),\n-                // the use of b after the + should be renamed, the other one not:\n-                (\"macro_rules! f (($x:ident) => (b + $x)); fn a() -> i32 { let b = 13; f!(b)}\",\n-                 vec!(vec!(1)), false),\n-                // the b before the plus should not be renamed (requires marks)\n-                (\"macro_rules! f (($x:ident) => ({let b=9; ($x + b)})); fn a() -> i32 { f!(b)}\",\n-                 vec!(vec!(1)), false),\n-                // the marks going in and out of letty should cancel, allowing that $x to\n-                // capture the one following the semicolon.\n-                // this was an awesome test case, and caught a *lot* of bugs.\n-                (\"macro_rules! letty(($x:ident) => (let $x = 15;));\n-                  macro_rules! user(($x:ident) => ({letty!($x); $x}));\n-                  fn main() -> i32 {user!(z)}\",\n-                 vec!(vec!(0)), false)\n-                );\n-        for (idx,s) in tests.iter().enumerate() {\n-            run_renaming_test(s,idx);\n-        }\n-    }\n-\n-    // no longer a fixme #8062: this test exposes a *potential* bug; our system does\n-    // not behave exactly like MTWT, but a conversation with Matthew Flatt\n-    // suggests that this can only occur in the presence of local-expand, which\n-    // we have no plans to support. ... unless it's needed for item hygiene....\n-    #[ignore]\n-    #[test]\n-    fn issue_8062(){\n-        run_renaming_test(\n-            &(\"fn main() {let hrcoo = 19; macro_rules! getx(()=>(hrcoo)); getx!();}\",\n-              vec!(vec!(0)), true), 0)\n-    }\n-\n-    // FIXME #6994:\n-    // the z flows into and out of two macros (g & f) along one path, and one\n-    // (just g) along the other, so the result of the whole thing should\n-    // be \"let z_123 = 3; z_123\"\n-    #[ignore]\n-    #[test]\n-    fn issue_6994(){\n-        run_renaming_test(\n-            &(\"macro_rules! g (($x:ident) =>\n-              ({macro_rules! f(($y:ident)=>({let $y=3;$x}));f!($x)}));\n-              fn a(){g!(z)}\",\n-              vec!(vec!(0)),false),\n-            0)\n-    }\n-\n-    // match variable hygiene. Should expand into\n-    // fn z() {match 8 {x_1 => {match 9 {x_2 | x_2 if x_2 == x_1 => x_2 + x_1}}}}\n-    #[test]\n-    fn issue_9384(){\n-        run_renaming_test(\n-            &(\"macro_rules! bad_macro (($ex:expr) => ({match 9 {x | x if x == $ex => x + $ex}}));\n-              fn z() {match 8 {x => bad_macro!(x)}}\",\n-              // NB: the third \"binding\" is the repeat of the second one.\n-              vec!(vec!(1,3),vec!(0,2),vec!(0,2)),\n-              true),\n-            0)\n-    }\n-\n-    // interpolated nodes weren't getting labeled.\n-    // should expand into\n-    // fn main(){let g1_1 = 13; g1_1}}\n-    #[test]\n-    fn pat_expand_issue_15221(){\n-        run_renaming_test(\n-            &(\"macro_rules! inner ( ($e:pat ) => ($e));\n-              macro_rules! outer ( ($e:pat ) => (inner!($e)));\n-              fn main() { let outer!(g) = 13; g;}\",\n-              vec!(vec!(0)),\n-              true),\n-            0)\n-    }\n-\n     // create a really evil test case where a $x appears inside a binding of $x\n     // but *shouldn't* bind because it was inserted by a different macro....\n     // can't write this test case until we have macro-generating macros.\n \n-    // method arg hygiene\n-    // method expands to fn get_x(&self_0, x_1: i32) {self_0 + self_2 + x_3 + x_1}\n-    #[test]\n-    fn method_arg_hygiene(){\n-        run_renaming_test(\n-            &(\"macro_rules! inject_x (()=>(x));\n-              macro_rules! inject_self (()=>(self));\n-              struct A;\n-              impl A{fn get_x(&self, x: i32) {self + inject_self!() + inject_x!() + x;} }\",\n-              vec!(vec!(0),vec!(3)),\n-              true),\n-            0)\n-    }\n-\n-    // ooh, got another bite?\n-    // expands to struct A; impl A {fn thingy(&self_1) {self_1;}}\n-    #[test]\n-    fn method_arg_hygiene_2(){\n-        run_renaming_test(\n-            &(\"struct A;\n-              macro_rules! add_method (($T:ty) =>\n-              (impl $T {  fn thingy(&self) {self;} }));\n-              add_method!(A);\",\n-              vec!(vec!(0)),\n-              true),\n-            0)\n-    }\n-\n-    // item fn hygiene\n-    // expands to fn q(x_1: i32){fn g(x_2: i32){x_2 + x_1};}\n-    #[test]\n-    fn issue_9383(){\n-        run_renaming_test(\n-            &(\"macro_rules! bad_macro (($ex:expr) => (fn g(x: i32){ x + $ex }));\n-              fn q(x: i32) { bad_macro!(x); }\",\n-              vec!(vec!(1),vec!(0)),true),\n-            0)\n-    }\n-\n-    // closure arg hygiene (ExprKind::Closure)\n-    // expands to fn f(){(|x_1 : i32| {(x_2 + x_1)})(3);}\n-    #[test]\n-    fn closure_arg_hygiene(){\n-        run_renaming_test(\n-            &(\"macro_rules! inject_x (()=>(x));\n-            fn f(){(|x : i32| {(inject_x!() + x)})(3);}\",\n-              vec!(vec!(1)),\n-              true),\n-            0)\n-    }\n-\n-    // macro_rules in method position. Sadly, unimplemented.\n-    #[test]\n-    fn macro_in_method_posn(){\n-        expand_crate_str(\n-            \"macro_rules! my_method (() => (fn thirteen(&self) -> i32 {13}));\n-            struct A;\n-            impl A{ my_method!(); }\n-            fn f(){A.thirteen;}\".to_string());\n-    }\n-\n-    // another nested macro\n-    // expands to impl Entries {fn size_hint(&self_1) {self_1;}\n-    #[test]\n-    fn item_macro_workaround(){\n-        run_renaming_test(\n-            &(\"macro_rules! item { ($i:item) => {$i}}\n-              struct Entries;\n-              macro_rules! iterator_impl {\n-              () => { item!( impl Entries { fn size_hint(&self) { self;}});}}\n-              iterator_impl! { }\",\n-              vec!(vec!(0)), true),\n-            0)\n-    }\n-\n-    // run one of the renaming tests\n-    fn run_renaming_test(t: &RenamingTest, test_idx: usize) {\n-        let invalid_name = keywords::Invalid.name();\n-        let (teststr, bound_connections, bound_ident_check) = match *t {\n-            (ref str,ref conns, bic) => (str.to_string(), conns.clone(), bic)\n-        };\n-        let cr = expand_crate_str(teststr.to_string());\n-        let bindings = crate_bindings(&cr);\n-        let varrefs = crate_varrefs(&cr);\n-\n-        // must be one check clause for each binding:\n-        assert_eq!(bindings.len(),bound_connections.len());\n-        for (binding_idx,shouldmatch) in bound_connections.iter().enumerate() {\n-            let binding_name = mtwt::resolve(bindings[binding_idx]);\n-            let binding_marks = mtwt::marksof(bindings[binding_idx].ctxt, invalid_name);\n-            // shouldmatch can't name varrefs that don't exist:\n-            assert!((shouldmatch.is_empty()) ||\n-                    (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n-            for (idx,varref) in varrefs.iter().enumerate() {\n-                let print_hygiene_debug_info = || {\n-                    // good lord, you can't make a path with 0 segments, can you?\n-                    let final_varref_ident = match varref.segments.last() {\n-                        Some(pathsegment) => pathsegment.identifier,\n-                        None => panic!(\"varref with 0 path segments?\")\n-                    };\n-                    let varref_name = mtwt::resolve(final_varref_ident);\n-                    let varref_idents : Vec<ast::Ident>\n-                        = varref.segments.iter().map(|s| s.identifier)\n-                        .collect();\n-                    println!(\"varref #{}: {:?}, resolves to {}\",idx, varref_idents, varref_name);\n-                    println!(\"varref's first segment's string: \\\"{}\\\"\", final_varref_ident);\n-                    println!(\"binding #{}: {}, resolves to {}\",\n-                             binding_idx, bindings[binding_idx], binding_name);\n-                    mtwt::with_sctable(|x| mtwt::display_sctable(x));\n-                };\n-                if shouldmatch.contains(&idx) {\n-                    // it should be a path of length 1, and it should\n-                    // be free-identifier=? or bound-identifier=? to the given binding\n-                    assert_eq!(varref.segments.len(),1);\n-                    let varref_name = mtwt::resolve(varref.segments[0].identifier);\n-                    let varref_marks = mtwt::marksof(varref.segments[0]\n-                                                           .identifier\n-                                                           .ctxt,\n-                                                     invalid_name);\n-                    if !(varref_name==binding_name) {\n-                        println!(\"uh oh, should match but doesn't:\");\n-                        print_hygiene_debug_info();\n-                    }\n-                    assert_eq!(varref_name,binding_name);\n-                    if bound_ident_check {\n-                        // we're checking bound-identifier=?, and the marks\n-                        // should be the same, too:\n-                        assert_eq!(varref_marks,binding_marks.clone());\n-                    }\n-                } else {\n-                    let varref_name = mtwt::resolve(varref.segments[0].identifier);\n-                    let fail = (varref.segments.len() == 1)\n-                        && (varref_name == binding_name);\n-                    // temp debugging:\n-                    if fail {\n-                        println!(\"failure on test {}\",test_idx);\n-                        println!(\"text of test case: \\\"{}\\\"\", teststr);\n-                        println!(\"\");\n-                        println!(\"uh oh, matches but shouldn't:\");\n-                        print_hygiene_debug_info();\n-                    }\n-                    assert!(!fail);\n-                }\n-            }\n-        }\n-    }\n-\n     #[test]\n     fn fmt_in_macro_used_inside_module_macro() {\n         let crate_str = \"macro_rules! fmt_wrap(($b:expr)=>($b.to_string()));"}, {"sha": "c9e8715dda6a8a288ae2cebb61284268dca6f507", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 2, "deletions": 187, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/a93455eb5d1e54f4415af9c1f44bdd53e7f23ec2/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a93455eb5d1e54f4415af9c1f44bdd53e7f23ec2/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=a93455eb5d1e54f4415af9c1f44bdd53e7f23ec2", "patch": "@@ -173,91 +173,14 @@ pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n \n #[cfg(test)]\n mod tests {\n-    use self::TestSC::*;\n     use ast::{EMPTY_CTXT, Ident, Mrk, Name, SyntaxContext};\n-    use super::{resolve, xor_push, apply_mark_internal, new_sctable_internal};\n-    use super::{apply_rename_internal, apply_renames, marksof_internal, resolve_internal};\n-    use super::{SCTable, EmptyCtxt, Mark, Rename, IllegalCtxt};\n-    use std::collections::HashMap;\n-\n-    #[test]\n-    fn xorpush_test () {\n-        let mut s = Vec::new();\n-        xor_push(&mut s, 14);\n-        assert_eq!(s.clone(), [14]);\n-        xor_push(&mut s, 14);\n-        assert_eq!(s.clone(), []);\n-        xor_push(&mut s, 14);\n-        assert_eq!(s.clone(), [14]);\n-        xor_push(&mut s, 15);\n-        assert_eq!(s.clone(), [14, 15]);\n-        xor_push(&mut s, 16);\n-        assert_eq!(s.clone(), [14, 15, 16]);\n-        xor_push(&mut s, 16);\n-        assert_eq!(s.clone(), [14, 15]);\n-        xor_push(&mut s, 15);\n-        assert_eq!(s.clone(), [14]);\n-    }\n+    use super::{resolve, apply_mark_internal, new_sctable_internal};\n+    use super::{SCTable, Mark};\n \n     fn id(n: u32, s: SyntaxContext) -> Ident {\n         Ident::new(Name(n), s)\n     }\n \n-    // because of the SCTable, I now need a tidy way of\n-    // creating syntax objects. Sigh.\n-    #[derive(Clone, PartialEq, Debug)]\n-    enum TestSC {\n-        M(Mrk),\n-        R(Ident,Name)\n-    }\n-\n-    // unfold a vector of TestSC values into a SCTable,\n-    // returning the resulting index\n-    fn unfold_test_sc(tscs : Vec<TestSC> , tail: SyntaxContext, table: &SCTable)\n-        -> SyntaxContext {\n-        tscs.iter().rev().fold(tail, |tail : SyntaxContext, tsc : &TestSC|\n-                  {match *tsc {\n-                      M(mrk) => apply_mark_internal(mrk,tail,table),\n-                      R(ident,name) => apply_rename_internal(ident,name,tail,table)}})\n-    }\n-\n-    // gather a SyntaxContext back into a vector of TestSCs\n-    fn refold_test_sc(mut sc: SyntaxContext, table : &SCTable) -> Vec<TestSC> {\n-        let mut result = Vec::new();\n-        loop {\n-            let table = table.table.borrow();\n-            match (*table)[sc.0 as usize] {\n-                EmptyCtxt => {return result;},\n-                Mark(mrk,tail) => {\n-                    result.push(M(mrk));\n-                    sc = tail;\n-                    continue;\n-                },\n-                Rename(id,name,tail) => {\n-                    result.push(R(id,name));\n-                    sc = tail;\n-                    continue;\n-                }\n-                IllegalCtxt => panic!(\"expected resolvable context, got IllegalCtxt\")\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unfold_refold(){\n-        let mut t = new_sctable_internal();\n-\n-        let test_sc = vec!(M(3),R(id(101,EMPTY_CTXT),Name(14)),M(9));\n-        assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),SyntaxContext(4));\n-        {\n-            let table = t.table.borrow();\n-            assert!((*table)[2] == Mark(9,EMPTY_CTXT));\n-            assert!((*table)[3] == Rename(id(101,EMPTY_CTXT),Name(14),SyntaxContext(2)));\n-            assert!((*table)[4] == Mark(3,SyntaxContext(3)));\n-        }\n-        assert_eq!(refold_test_sc(SyntaxContext(4),&t),test_sc);\n-    }\n-\n     // extend a syntax context with a sequence of marks given\n     // in a vector. v[0] will be the outermost mark.\n     fn unfold_marks(mrks: Vec<Mrk> , tail: SyntaxContext, table: &SCTable)\n@@ -277,98 +200,12 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_marksof () {\n-        let stopname = Name(242);\n-        let name1 = Name(243);\n-        let mut t = new_sctable_internal();\n-        assert_eq!(marksof_internal (EMPTY_CTXT,stopname,&t),Vec::new());\n-        // FIXME #5074: ANF'd to dodge nested calls\n-        { let ans = unfold_marks(vec!(4,98),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans,stopname,&t), [4, 98]);}\n-        // does xoring work?\n-        { let ans = unfold_marks(vec!(5,5,16),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans,stopname,&t), [16]);}\n-        // does nested xoring work?\n-        { let ans = unfold_marks(vec!(5,10,10,5,16),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans, stopname,&t), [16]);}\n-        // rename where stop doesn't match:\n-        { let chain = vec!(M(9),\n-                        R(id(name1.0,\n-                             apply_mark_internal (4, EMPTY_CTXT,&mut t)),\n-                          Name(100101102)),\n-                        M(14));\n-         let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans, stopname, &t), [9, 14]);}\n-        // rename where stop does match\n-        { let name1sc = apply_mark_internal(4, EMPTY_CTXT, &mut t);\n-         let chain = vec!(M(9),\n-                       R(id(name1.0, name1sc),\n-                         stopname),\n-                       M(14));\n-         let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans, stopname, &t), [9]); }\n-    }\n-\n-\n-    #[test]\n-    fn resolve_tests () {\n-        let a = 40;\n-        let mut t = new_sctable_internal();\n-        let mut rt = HashMap::new();\n-        // - ctxt is MT\n-        assert_eq!(resolve_internal(id(a,EMPTY_CTXT),&mut t, &mut rt),Name(a));\n-        // - simple ignored marks\n-        { let sc = unfold_marks(vec!(1,2,3),EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),Name(a));}\n-        // - orthogonal rename where names don't match\n-        { let sc = unfold_test_sc(vec!(R(id(50,EMPTY_CTXT),Name(51)),M(12)),EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),Name(a));}\n-        // - rename where names do match, but marks don't\n-        { let sc1 = apply_mark_internal(1,EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(vec!(R(id(a,sc1),Name(50)),\n-                                   M(1),\n-                                   M(2)),\n-                                 EMPTY_CTXT,&mut t);\n-        assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), Name(a));}\n-        // - rename where names and marks match\n-        { let sc1 = unfold_test_sc(vec!(M(1),M(2)),EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(vec!(R(id(a,sc1),Name(50)),M(1),M(2)),EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), Name(50)); }\n-        // - rename where names and marks match by literal sharing\n-        { let sc1 = unfold_test_sc(vec!(M(1),M(2)),EMPTY_CTXT,&mut t);\n-         let sc = unfold_test_sc(vec!(R(id(a,sc1),Name(50))),sc1,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), Name(50)); }\n-        // - two renames of the same var.. can only happen if you use\n-        // local-expand to prevent the inner binding from being renamed\n-        // during the rename-pass caused by the first:\n-        println!(\"about to run bad test\");\n-        { let sc = unfold_test_sc(vec!(R(id(a,EMPTY_CTXT),Name(50)),\n-                                    R(id(a,EMPTY_CTXT),Name(51))),\n-                                  EMPTY_CTXT,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), Name(51)); }\n-        // the simplest double-rename:\n-        { let a_to_a50 = apply_rename_internal(id(a,EMPTY_CTXT),Name(50),EMPTY_CTXT,&mut t);\n-         let a50_to_a51 = apply_rename_internal(id(a,a_to_a50),Name(51),a_to_a50,&mut t);\n-         assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t, &mut rt),Name(51));\n-         // mark on the outside doesn't stop rename:\n-         let sc = apply_mark_internal(9,a50_to_a51,&mut t);\n-         assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),Name(51));\n-         // but mark on the inside does:\n-         let a50_to_a51_b = unfold_test_sc(vec!(R(id(a,a_to_a50),Name(51)),\n-                                              M(9)),\n-                                           a_to_a50,\n-                                           &mut t);\n-         assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t, &mut rt),Name(50));}\n-    }\n-\n     #[test]\n     fn mtwt_resolve_test(){\n         let a = 40;\n         assert_eq!(resolve(id(a,EMPTY_CTXT)),Name(a));\n     }\n \n-\n     #[test]\n     fn hashing_tests () {\n         let mut t = new_sctable_internal();\n@@ -378,26 +215,4 @@ mod tests {\n         assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),SyntaxContext(2));\n         // I'm assuming that the rename table will behave the same....\n     }\n-\n-    #[test]\n-    fn resolve_table_hashing_tests() {\n-        let mut t = new_sctable_internal();\n-        let mut rt = HashMap::new();\n-        assert_eq!(rt.len(),0);\n-        resolve_internal(id(30,EMPTY_CTXT),&mut t, &mut rt);\n-        assert_eq!(rt.len(),1);\n-        resolve_internal(id(39,EMPTY_CTXT),&mut t, &mut rt);\n-        assert_eq!(rt.len(),2);\n-        resolve_internal(id(30,EMPTY_CTXT),&mut t, &mut rt);\n-        assert_eq!(rt.len(),2);\n-    }\n-\n-    #[test]\n-    fn new_resolves_test() {\n-        let renames = vec!((Ident::with_empty_ctxt(Name(23)),Name(24)),\n-                           (Ident::with_empty_ctxt(Name(29)),Name(29)));\n-        let new_ctxt1 = apply_renames(&renames,EMPTY_CTXT);\n-        assert_eq!(resolve(Ident::new(Name(23),new_ctxt1)),Name(24));\n-        assert_eq!(resolve(Ident::new(Name(29),new_ctxt1)),Name(29));\n-    }\n }"}]}