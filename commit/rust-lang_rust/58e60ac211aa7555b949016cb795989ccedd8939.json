{"sha": "58e60ac211aa7555b949016cb795989ccedd8939", "node_id": "C_kwDOAAsO6NoAKDU4ZTYwYWMyMTFhYTc1NTViOTQ5MDE2Y2I3OTU5ODljY2VkZDg5Mzk", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-12-08T09:42:45Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-12-08T09:42:45Z"}, "message": "Make `VecDeque::from_iter` O(1) from `vec(_deque)::IntoIter`", "tree": {"sha": "617eee19d24e01e14bbae99d08c9da71481148db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/617eee19d24e01e14bbae99d08c9da71481148db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58e60ac211aa7555b949016cb795989ccedd8939", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58e60ac211aa7555b949016cb795989ccedd8939", "html_url": "https://github.com/rust-lang/rust/commit/58e60ac211aa7555b949016cb795989ccedd8939", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58e60ac211aa7555b949016cb795989ccedd8939/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5418b09e84883c4de2e652a147ab9faff4eee29", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5418b09e84883c4de2e652a147ab9faff4eee29", "html_url": "https://github.com/rust-lang/rust/commit/f5418b09e84883c4de2e652a147ab9faff4eee29"}], "stats": {"total": 135, "additions": 124, "deletions": 11}, "files": [{"sha": "e54880e8652305b7f173d08f48aae0b18276212d", "filename": "library/alloc/src/collections/vec_deque/into_iter.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58e60ac211aa7555b949016cb795989ccedd8939/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e60ac211aa7555b949016cb795989ccedd8939/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs?ref=58e60ac211aa7555b949016cb795989ccedd8939", "patch": "@@ -25,6 +25,10 @@ impl<T, A: Allocator> IntoIter<T, A> {\n     pub(super) fn new(inner: VecDeque<T, A>) -> Self {\n         IntoIter { inner }\n     }\n+\n+    pub(super) fn into_vecdeque(self) -> VecDeque<T, A> {\n+        self.inner\n+    }\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]"}, {"sha": "8fee44d6f932b4ff09d85a7c8c7b81b20da5a74e", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/58e60ac211aa7555b949016cb795989ccedd8939/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e60ac211aa7555b949016cb795989ccedd8939/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=58e60ac211aa7555b949016cb795989ccedd8939", "patch": "@@ -55,6 +55,10 @@ use self::spec_extend::SpecExtend;\n \n mod spec_extend;\n \n+use self::spec_from_iter::SpecFromIter;\n+\n+mod spec_from_iter;\n+\n #[cfg(test)]\n mod tests;\n \n@@ -586,6 +590,35 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         VecDeque { head: 0, len: 0, buf: RawVec::with_capacity_in(capacity, alloc) }\n     }\n \n+    /// For use by `vec::IntoIter::into_vecdeque`\n+    ///\n+    /// # Safety\n+    ///\n+    /// All the usual requirements on the allocated memory like in\n+    /// `Vec::from_raw_parts_in`, but takes a *range* of elements that are\n+    /// initialized rather than only supporting `0..len`.  Requires that\n+    /// `initialized.start` \u2264 `initialized.end` \u2264 `capacity`.\n+    #[inline]\n+    pub(crate) unsafe fn from_contiguous_raw_parts_in(\n+        ptr: *mut T,\n+        initialized: Range<usize>,\n+        capacity: usize,\n+        alloc: A,\n+    ) -> Self {\n+        debug_assert!(initialized.start <= initialized.end);\n+        debug_assert!(initialized.end <= capacity);\n+\n+        // SAFETY: Our safety precondition guarantees the range length won't wrap,\n+        // and that the allocation is valid for use in `RawVec`.\n+        unsafe {\n+            VecDeque {\n+                head: initialized.start,\n+                len: initialized.end.unchecked_sub(initialized.start),\n+                buf: RawVec::from_raw_parts_in(ptr, capacity, alloc),\n+            }\n+        }\n+    }\n+\n     /// Provides a reference to the element at the given index.\n     ///\n     /// Element at index 0 is the front of the queue.\n@@ -2699,18 +2732,8 @@ impl<T, A: Allocator> IndexMut<usize> for VecDeque<T, A> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for VecDeque<T> {\n-    #[inline]\n     fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> VecDeque<T> {\n-        // Since converting is O(1) now, might as well re-use that logic\n-        // (including things like the `vec::IntoIter`\u2192`Vec` specialization)\n-        // especially as that could save us some monomorphiziation work\n-        // if one uses the same iterators (like slice ones) with both.\n-        return from_iter_via_vec(iter.into_iter());\n-\n-        #[inline]\n-        fn from_iter_via_vec<U>(iter: impl Iterator<Item = U>) -> VecDeque<U> {\n-            Vec::from_iter(iter).into()\n-        }\n+        SpecFromIter::spec_from_iter(iter.into_iter())\n     }\n }\n "}, {"sha": "7650492ebdad1500c4167bfcc69f6f53998bb35c", "filename": "library/alloc/src/collections/vec_deque/spec_from_iter.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/58e60ac211aa7555b949016cb795989ccedd8939/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_from_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e60ac211aa7555b949016cb795989ccedd8939/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_from_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_from_iter.rs?ref=58e60ac211aa7555b949016cb795989ccedd8939", "patch": "@@ -0,0 +1,33 @@\n+use super::{IntoIter, VecDeque};\n+\n+/// Specialization trait used for `VecDeque::from_iter`\n+pub(super) trait SpecFromIter<T, I> {\n+    fn spec_from_iter(iter: I) -> Self;\n+}\n+\n+impl<T, I> SpecFromIter<T, I> for VecDeque<T>\n+where\n+    I: Iterator<Item = T>,\n+{\n+    default fn spec_from_iter(iterator: I) -> Self {\n+        // Since converting is O(1) now, just re-use the `Vec` logic for\n+        // anything where we can't do something extra-special for `VecDeque`,\n+        // especially as that could save us some monomorphiziation work\n+        // if one uses the same iterators (like slice ones) with both.\n+        crate::vec::Vec::from_iter(iterator).into()\n+    }\n+}\n+\n+impl<T> SpecFromIter<T, crate::vec::IntoIter<T>> for VecDeque<T> {\n+    #[inline]\n+    fn spec_from_iter(iterator: crate::vec::IntoIter<T>) -> Self {\n+        iterator.into_vecdeque()\n+    }\n+}\n+\n+impl<T> SpecFromIter<T, IntoIter<T>> for VecDeque<T> {\n+    #[inline]\n+    fn spec_from_iter(iterator: IntoIter<T>) -> Self {\n+        iterator.into_vecdeque()\n+    }\n+}"}, {"sha": "41e2fb9b2f0d99c1774b420a9a7951974834687d", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/58e60ac211aa7555b949016cb795989ccedd8939/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e60ac211aa7555b949016cb795989ccedd8939/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=58e60ac211aa7555b949016cb795989ccedd8939", "patch": "@@ -1,6 +1,7 @@\n #[cfg(not(no_global_oom_handling))]\n use super::AsVecIntoIter;\n use crate::alloc::{Allocator, Global};\n+use crate::collections::VecDeque;\n use crate::raw_vec::RawVec;\n use core::array;\n use core::fmt;\n@@ -132,6 +133,32 @@ impl<T, A: Allocator> IntoIter<T, A> {\n     pub(crate) fn forget_remaining_elements(&mut self) {\n         self.ptr = self.end;\n     }\n+\n+    #[inline]\n+    pub(crate) fn into_vecdeque(self) -> VecDeque<T, A> {\n+        // Keep our `Drop` impl from dropping the elements and the allocator\n+        let mut this = ManuallyDrop::new(self);\n+\n+        // SAFETY: This allocation originally came from a `Vec`, so it passes\n+        // all those checks.  We have `this.buf` \u2264 `this.ptr` \u2264 `this.end`,\n+        // so the `sub_ptr`s below cannot wrap, and will produce a well-formed\n+        // range.  `end` \u2264 `buf + cap`, so the range will be in-bounds.\n+        // Taking `alloc` is ok because nothing else is going to look at it,\n+        // since our `Drop` impl isn't going to run so there's no more code.\n+        unsafe {\n+            let buf = this.buf.as_ptr();\n+            let initialized = if T::IS_ZST {\n+                // All the pointers are the same for ZSTs, so it's fine to\n+                // say that they're all at the beginning of the \"allocation\".\n+                0..this.len()\n+            } else {\n+                this.ptr.sub_ptr(buf)..this.end.sub_ptr(buf)\n+            };\n+            let cap = this.cap;\n+            let alloc = ManuallyDrop::take(&mut this.alloc);\n+            VecDeque::from_contiguous_raw_parts_in(buf, initialized, cap, alloc)\n+        }\n+    }\n }\n \n #[stable(feature = \"vec_intoiter_as_ref\", since = \"1.46.0\")]"}, {"sha": "823061d400f3005be7eeddccbdfb1b590551f60d", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/58e60ac211aa7555b949016cb795989ccedd8939/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58e60ac211aa7555b949016cb795989ccedd8939/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=58e60ac211aa7555b949016cb795989ccedd8939", "patch": "@@ -1736,3 +1736,29 @@ fn test_resize_keeps_reserved_space_from_item() {\n     d.resize(1, v);\n     assert_eq!(d[0].capacity(), 1234);\n }\n+\n+#[test]\n+fn test_collect_from_into_iter_keeps_allocation() {\n+    let mut v = Vec::with_capacity(13);\n+    v.extend(0..7);\n+    check(v.into_iter());\n+\n+    let mut v = VecDeque::with_capacity(13);\n+    v.extend(0..7);\n+    check(v.into_iter());\n+\n+    fn check(mut it: impl Iterator<Item = i32>) {\n+        assert_eq!(it.next(), Some(0));\n+        assert_eq!(it.next(), Some(1));\n+        let mut v: VecDeque<i32> = it.collect();\n+        assert_eq!(v.capacity(), 13);\n+        assert_eq!(v.as_slices(), ([2, 3, 4, 5, 6].as_slice(), [].as_slice()));\n+        v.push_front(7);\n+        assert_eq!(v.as_slices(), ([7, 2, 3, 4, 5, 6].as_slice(), [].as_slice()));\n+        v.push_front(8);\n+        assert_eq!(v.as_slices(), ([8, 7, 2, 3, 4, 5, 6].as_slice(), [].as_slice()));\n+        v.push_front(9);\n+        assert_eq!(v.as_slices(), ([9].as_slice(), [8, 7, 2, 3, 4, 5, 6].as_slice()));\n+        assert_eq!(v.capacity(), 13);\n+    }\n+}"}]}