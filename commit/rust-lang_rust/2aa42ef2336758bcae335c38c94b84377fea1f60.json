{"sha": "2aa42ef2336758bcae335c38c94b84377fea1f60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhYTQyZWYyMzM2NzU4YmNhZTMzNWMzOGM5NGI4NDM3N2ZlYTFmNjA=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-09-23T04:29:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-09-23T04:29:23Z"}, "message": "Rollup merge of #44778 - lucasem:master, r=estebank\n\nstd::sync::RwLock docs improvement\n\nAddresses the `RwLock` part of #29377.\nr? @steveklabnik\n\nAdded examples, links to types, and a small comparison between RwLock and Mutex.", "tree": {"sha": "4a97d4fbde854af58c8d1c40dfa0996a08f66265", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a97d4fbde854af58c8d1c40dfa0996a08f66265"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2aa42ef2336758bcae335c38c94b84377fea1f60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa42ef2336758bcae335c38c94b84377fea1f60", "html_url": "https://github.com/rust-lang/rust/commit/2aa42ef2336758bcae335c38c94b84377fea1f60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2aa42ef2336758bcae335c38c94b84377fea1f60/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbd8ac59fabdf2ad4bdf724783db3a89e3024740", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbd8ac59fabdf2ad4bdf724783db3a89e3024740", "html_url": "https://github.com/rust-lang/rust/commit/bbd8ac59fabdf2ad4bdf724783db3a89e3024740"}, {"sha": "f283875a780662f13d977e05de7ab5fe52604743", "url": "https://api.github.com/repos/rust-lang/rust/commits/f283875a780662f13d977e05de7ab5fe52604743", "html_url": "https://github.com/rust-lang/rust/commit/f283875a780662f13d977e05de7ab5fe52604743"}], "stats": {"total": 133, "additions": 120, "deletions": 13}, "files": [{"sha": "4757faabfb873aee9118656509e8f3734c296478", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 120, "deletions": 13, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/2aa42ef2336758bcae335c38c94b84377fea1f60/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa42ef2336758bcae335c38c94b84377fea1f60/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=2aa42ef2336758bcae335c38c94b84377fea1f60", "patch": "@@ -24,19 +24,24 @@ use sys_common::rwlock as sys;\n /// of the underlying data (exclusive access) and the read portion of this lock\n /// typically allows for read-only access (shared access).\n ///\n+/// In comparison, a [`Mutex`] does not distinguish between readers or writers\n+/// that aquire the lock, therefore blocking any threads waiting for the lock to\n+/// become available. An `RwLock` will allow any number of readers to aquire the\n+/// lock as long as a writer is not holding the lock.\n+///\n /// The priority policy of the lock is dependent on the underlying operating\n /// system's implementation, and this type does not guarantee that any\n /// particular policy will be used.\n ///\n /// The type parameter `T` represents the data that this lock protects. It is\n-/// required that `T` satisfies `Send` to be shared across threads and `Sync` to\n-/// allow concurrent access through readers. The RAII guards returned from the\n-/// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n-/// to allow access to the contained of the lock.\n+/// required that `T` satisfies [`Send`] to be shared across threads and\n+/// [`Sync`] to allow concurrent access through readers. The RAII guards\n+/// returned from the locking methods implement [`Deref`][] (and [`DerefMut`]\n+/// for the `write` methods) to allow access to the contained of the lock.\n ///\n /// # Poisoning\n ///\n-/// An `RwLock`, like `Mutex`, will become poisoned on a panic. Note, however,\n+/// An `RwLock`, like [`Mutex`], will become poisoned on a panic. Note, however,\n /// that an `RwLock` may only be poisoned if a panic occurs while it is locked\n /// exclusively (write mode). If a panic occurs in any reader, then the lock\n /// will not be poisoned.\n@@ -63,6 +68,12 @@ use sys_common::rwlock as sys;\n ///     assert_eq!(*w, 6);\n /// } // write lock is dropped here\n /// ```\n+///\n+/// [`Deref`]: ../../std/ops/trait.Deref.html\n+/// [`DerefMut`]: ../../std/ops/trait.DerefMut.html\n+/// [`Send`]: ../../std/marker/trait.Send.html\n+/// [`Sync`]: ../../std/marker/trait.Sync.html\n+/// [`Mutex`]: struct.Mutex.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLock<T: ?Sized> {\n     inner: Box<sys::RWLock>,\n@@ -154,6 +165,24 @@ impl<T: ?Sized> RwLock<T> {\n     /// # Panics\n     ///\n     /// This function might panic when called if the lock is already held by the current thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, RwLock};\n+    /// use std::thread;\n+    ///\n+    /// let lock = Arc::new(RwLock::new(1));\n+    /// let c_lock = lock.clone();\n+    ///\n+    /// let n = lock.read().unwrap();\n+    /// assert_eq!(*n, 1);\n+    ///\n+    /// thread::spawn(move || {\n+    ///     let r = c_lock.read();\n+    ///     assert!(r.is_ok());\n+    /// }).join().unwrap();\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&self) -> LockResult<RwLockReadGuard<T>> {\n@@ -180,6 +209,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(1);\n+    ///\n+    /// match lock.try_read() {\n+    ///     Ok(n) => assert_eq!(*n, 1),\n+    ///     Err(_) => unreachable!(),\n+    /// };\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<T>> {\n@@ -210,6 +252,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// # Panics\n     ///\n     /// This function might panic when called if the lock is already held by the current thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(1);\n+    ///\n+    /// let mut n = lock.write().unwrap();\n+    /// *n = 2;\n+    ///\n+    /// assert!(lock.try_read().is_err());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&self) -> LockResult<RwLockWriteGuard<T>> {\n@@ -236,6 +291,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(1);\n+    ///\n+    /// let n = lock.read().unwrap();\n+    /// assert_eq!(*n, 1);\n+    ///\n+    /// assert!(lock.try_write().is_err());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n@@ -253,6 +321,22 @@ impl<T: ?Sized> RwLock<T> {\n     /// If another thread is active, the lock can still become poisoned at any\n     /// time.  You should not trust a `false` value for program correctness\n     /// without additional synchronization.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, RwLock};\n+    /// use std::thread;\n+    ///\n+    /// let lock = Arc::new(RwLock::new(0));\n+    /// let c_lock = lock.clone();\n+    ///\n+    /// let _ = thread::spawn(move || {\n+    ///     let _lock = c_lock.write().unwrap();\n+    ///     panic!(); // the lock gets poisoned\n+    /// }).join();\n+    /// assert_eq!(lock.is_poisoned(), true);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn is_poisoned(&self) -> bool {\n@@ -267,6 +351,19 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let lock = RwLock::new(String::new());\n+    /// {\n+    ///     let mut s = lock.write().unwrap();\n+    ///     *s = \"modified\".to_owned();\n+    /// }\n+    /// assert_eq!(lock.into_inner().unwrap(), \"modified\");\n+    /// ```\n     #[stable(feature = \"rwlock_into_inner\", since = \"1.6.0\")]\n     pub fn into_inner(self) -> LockResult<T> where T: Sized {\n         // We know statically that there are no outstanding references to\n@@ -282,7 +379,7 @@ impl<T: ?Sized> RwLock<T> {\n                 (ptr::read(inner), ptr::read(poison), ptr::read(data))\n             };\n             mem::forget(self);\n-            inner.destroy();  // Keep in sync with the `Drop` impl.\n+            inner.destroy(); // Keep in sync with the `Drop` impl.\n             drop(inner);\n \n             poison::map_result(poison.borrow(), |_| data.into_inner())\n@@ -300,6 +397,16 @@ impl<T: ?Sized> RwLock<T> {\n     /// is poisoned whenever a writer panics while holding an exclusive lock. An\n     /// error will only be returned if the lock would have otherwise been\n     /// acquired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::RwLock;\n+    ///\n+    /// let mut lock = RwLock::new(0);\n+    /// *lock.get_mut().unwrap() = 10;\n+    /// assert_eq!(*lock.read().unwrap(), 10);\n+    /// ```\n     #[stable(feature = \"rwlock_get_mut\", since = \"1.6.0\")]\n     pub fn get_mut(&mut self) -> LockResult<&mut T> {\n         // We know statically that there are no other references to `self`, so\n@@ -486,7 +593,7 @@ mod tests {\n     fn test_rw_arc_poison_wr() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.write().unwrap();\n             panic!();\n         }).join();\n@@ -498,7 +605,7 @@ mod tests {\n         let arc = Arc::new(RwLock::new(1));\n         assert!(!arc.is_poisoned());\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.write().unwrap();\n             panic!();\n         }).join();\n@@ -510,7 +617,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.read().unwrap();\n             panic!();\n         }).join();\n@@ -521,7 +628,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rw() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<(), _> = thread::spawn(move|| {\n+        let _: Result<(), _> = thread::spawn(move || {\n             let _lock = arc2.read().unwrap();\n             panic!()\n         }).join();\n@@ -535,7 +642,7 @@ mod tests {\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n-        thread::spawn(move|| {\n+        thread::spawn(move || {\n             let mut lock = arc2.write().unwrap();\n             for _ in 0..10 {\n                 let tmp = *lock;\n@@ -550,7 +657,7 @@ mod tests {\n         let mut children = Vec::new();\n         for _ in 0..5 {\n             let arc3 = arc.clone();\n-            children.push(thread::spawn(move|| {\n+            children.push(thread::spawn(move || {\n                 let lock = arc3.read().unwrap();\n                 assert!(*lock >= 0);\n             }));\n@@ -571,7 +678,7 @@ mod tests {\n     fn test_rw_arc_access_in_unwind() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _ = thread::spawn(move|| -> () {\n+        let _ = thread::spawn(move || -> () {\n             struct Unwinder {\n                 i: Arc<RwLock<isize>>,\n             }"}]}