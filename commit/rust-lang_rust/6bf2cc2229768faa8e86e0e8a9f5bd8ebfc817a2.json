{"sha": "6bf2cc2229768faa8e86e0e8a9f5bd8ebfc817a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZjJjYzIyMjk3NjhmYWE4ZTg2ZTBlOGE5ZjViZDhlYmZjODE3YTI=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-02-04T22:44:03Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-02-06T05:42:53Z"}, "message": "Avoid instantiating many `Parser` structs in `generic_extension`.\n\nCurrently, every iteration of the main loop in `generic_extension`\ninstantiates a `Parser`, which is expensive because `Parser` is a large\ntype. Many of those instantiations are only used immutably, particularly\nfor simple-but-repetitive macros of the sort seen in `html5ever` and PR\n68836.\n\nThis commit initializes a single \"base\" parser outside the loop, and\nthen uses `Cow` to avoid cloning it except for the mutating iterations.\nThis speeds up `html5ever` runs by up to 15%.", "tree": {"sha": "f94f68a1b9ff98767712a93772e8919161670f1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f94f68a1b9ff98767712a93772e8919161670f1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bf2cc2229768faa8e86e0e8a9f5bd8ebfc817a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bf2cc2229768faa8e86e0e8a9f5bd8ebfc817a2", "html_url": "https://github.com/rust-lang/rust/commit/6bf2cc2229768faa8e86e0e8a9f5bd8ebfc817a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bf2cc2229768faa8e86e0e8a9f5bd8ebfc817a2/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "002287d25f6ef9718dbabd3e23c00b5ebcfb51c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/002287d25f6ef9718dbabd3e23c00b5ebcfb51c1", "html_url": "https://github.com/rust-lang/rust/commit/002287d25f6ef9718dbabd3e23c00b5ebcfb51c1"}], "stats": {"total": 101, "additions": 56, "deletions": 45}, "files": [{"sha": "f119c956ced04e078bef2d823b97041276eb4f71", "filename": "src/librustc_expand/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bf2cc2229768faa8e86e0e8a9f5bd8ebfc817a2/src%2Flibrustc_expand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf2cc2229768faa8e86e0e8a9f5bd8ebfc817a2/src%2Flibrustc_expand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Flib.rs?ref=6bf2cc2229768faa8e86e0e8a9f5bd8ebfc817a2", "patch": "@@ -1,3 +1,4 @@\n+#![feature(cow_is_borrowed)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(proc_macro_diagnostic)]"}, {"sha": "78f22f3e443b1206703c3f8e5b1f697a88f26538", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 9, "deletions": 29, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6bf2cc2229768faa8e86e0e8a9f5bd8ebfc817a2/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf2cc2229768faa8e86e0e8a9f5bd8ebfc817a2/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=6bf2cc2229768faa8e86e0e8a9f5bd8ebfc817a2", "patch": "@@ -78,20 +78,19 @@ use crate::mbe::{self, TokenTree};\n \n use rustc_ast_pretty::pprust;\n use rustc_parse::parser::{FollowedByType, Parser, PathStyle};\n-use rustc_parse::Directory;\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{kw, sym, Symbol};\n use syntax::ast::{Ident, Name};\n use syntax::ptr::P;\n use syntax::token::{self, DocComment, Nonterminal, Token};\n-use syntax::tokenstream::TokenStream;\n \n use rustc_errors::{FatalError, PResult};\n use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::mem;\n use std::ops::{Deref, DerefMut};\n@@ -613,28 +612,9 @@ fn inner_parse_loop<'root, 'tt>(\n     Success(())\n }\n \n-/// Use the given sequence of token trees (`ms`) as a matcher. Match the given token stream `tts`\n-/// against it and return the match.\n-///\n-/// # Parameters\n-///\n-/// - `sess`: The session into which errors are emitted\n-/// - `tts`: The tokenstream we are matching against the pattern `ms`\n-/// - `ms`: A sequence of token trees representing a pattern against which we are matching\n-/// - `directory`: Information about the file locations (needed for the black-box parser)\n-/// - `recurse_into_modules`: Whether or not to recurse into modules (needed for the black-box\n-///   parser)\n-pub(super) fn parse(\n-    sess: &ParseSess,\n-    tts: TokenStream,\n-    ms: &[TokenTree],\n-    directory: Option<Directory<'_>>,\n-    recurse_into_modules: bool,\n-) -> NamedParseResult {\n-    // Create a parser that can be used for the \"black box\" parts.\n-    let mut parser =\n-        Parser::new(sess, tts, directory, recurse_into_modules, true, rustc_parse::MACRO_ARGUMENTS);\n-\n+/// Use the given sequence of token trees (`ms`) as a matcher. Match the token\n+/// stream from the given `parser` against it and return the match.\n+pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> NamedParseResult {\n     // A queue of possible matcher positions. We initialize it with the matcher position in which\n     // the \"dot\" is before the first token of the first token tree in `ms`. `inner_parse_loop` then\n     // processes all of these possible matcher positions and produces possible next positions into\n@@ -659,7 +639,7 @@ pub(super) fn parse(\n         // parsing from the black-box parser done. The result is that `next_items` will contain a\n         // bunch of possible next matcher positions in `next_items`.\n         match inner_parse_loop(\n-            sess,\n+            parser.sess,\n             &mut cur_items,\n             &mut next_items,\n             &mut eof_items,\n@@ -684,7 +664,7 @@ pub(super) fn parse(\n             if eof_items.len() == 1 {\n                 let matches =\n                     eof_items[0].matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());\n-                return nameize(sess, ms, matches);\n+                return nameize(parser.sess, ms, matches);\n             } else if eof_items.len() > 1 {\n                 return Error(\n                     parser.token.span,\n@@ -736,13 +716,13 @@ pub(super) fn parse(\n         // If there are no possible next positions AND we aren't waiting for the black-box parser,\n         // then there is a syntax error.\n         else if bb_items.is_empty() && next_items.is_empty() {\n-            return Failure(parser.token.take(), \"no rules expected this token in macro call\");\n+            return Failure(parser.token.clone(), \"no rules expected this token in macro call\");\n         }\n         // Dump all possible `next_items` into `cur_items` for the next iteration.\n         else if !next_items.is_empty() {\n             // Now process the next token\n             cur_items.extend(next_items.drain(..));\n-            parser.bump();\n+            parser.to_mut().bump();\n         }\n         // Finally, we have the case where we need to call the black-box parser to get some\n         // nonterminal.\n@@ -754,7 +734,7 @@ pub(super) fn parse(\n                 let match_cur = item.match_cur;\n                 item.push_match(\n                     match_cur,\n-                    MatchedNonterminal(Lrc::new(parse_nt(&mut parser, span, ident.name))),\n+                    MatchedNonterminal(Lrc::new(parse_nt(parser.to_mut(), span, ident.name))),\n                 );\n                 item.idx += 1;\n                 item.match_cur += 1;"}, {"sha": "9432790e78cedc9c7cb4ca87bcff3b1abf6657d3", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6bf2cc2229768faa8e86e0e8a9f5bd8ebfc817a2/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf2cc2229768faa8e86e0e8a9f5bd8ebfc817a2/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=6bf2cc2229768faa8e86e0e8a9f5bd8ebfc817a2", "patch": "@@ -1,11 +1,11 @@\n-use crate::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n+use crate::base::{DummyResult, ExpansionData, ExtCtxt, MacResult, TTMacroExpander};\n use crate::base::{SyntaxExtension, SyntaxExtensionKind};\n use crate::expand::{ensure_complete_parse, parse_ast_fragment, AstFragment, AstFragmentKind};\n use crate::mbe;\n use crate::mbe::macro_check;\n-use crate::mbe::macro_parser::parse;\n+use crate::mbe::macro_parser::parse_tt;\n use crate::mbe::macro_parser::{Error, Failure, Success};\n-use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedParseResult};\n+use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq};\n use crate::mbe::transcribe::transcribe;\n \n use rustc_ast_pretty::pprust;\n@@ -166,9 +166,9 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n     }\n }\n \n-fn trace_macros_note(cx: &mut ExtCtxt<'_>, sp: Span, message: String) {\n+fn trace_macros_note(cx_expansions: &mut FxHashMap<Span, Vec<String>>, sp: Span, message: String) {\n     let sp = sp.macro_backtrace().last().map(|trace| trace.call_site).unwrap_or(sp);\n-    cx.expansions.entry(sp).or_default().push(message);\n+    cx_expansions.entry(sp).or_default().push(message);\n }\n \n /// Given `lhses` and `rhses`, this is the new macro we create\n@@ -184,12 +184,36 @@ fn generic_extension<'cx>(\n ) -> Box<dyn MacResult + 'cx> {\n     if cx.trace_macros() {\n         let msg = format!(\"expanding `{}! {{ {} }}`\", name, pprust::tts_to_string(arg.clone()));\n-        trace_macros_note(cx, sp, msg);\n+        trace_macros_note(&mut cx.expansions, sp, msg);\n     }\n \n     // Which arm's failure should we report? (the one furthest along)\n     let mut best_failure: Option<(Token, &str)> = None;\n+\n+    // We create a base parser that can be used for the \"black box\" parts.\n+    // Every iteration needs a fresh copy of that base parser. However, the\n+    // parser is not mutated on many of the iterations, particularly when\n+    // dealing with macros like this:\n+    //\n+    // macro_rules! foo {\n+    //     (\"a\") => (A);\n+    //     (\"b\") => (B);\n+    //     (\"c\") => (C);\n+    //     // ... etc. (maybe hundreds more)\n+    // }\n+    //\n+    // as seen in the `html5ever` benchmark. We use a `Cow` so that the base\n+    // parser is only cloned when necessary (upon mutation). Furthermore, we\n+    // reinitialize the `Cow` with the base parser at the start of every\n+    // iteration, so that any mutated parsers are not reused. This is all quite\n+    // hacky, but speeds up the `html5ever` benchmark significantly. (Issue\n+    // 68836 suggests a more comprehensive but more complex change to deal with\n+    // this situation.)\n+    let base_parser = base_parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n+\n     for (i, lhs) in lhses.iter().enumerate() {\n+        let mut parser = Cow::Borrowed(&base_parser);\n+\n         // try each arm's matchers\n         let lhs_tt = match *lhs {\n             mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n@@ -202,7 +226,7 @@ fn generic_extension<'cx>(\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n         let mut gated_spans_snaphot = mem::take(&mut *cx.parse_sess.gated_spans.spans.borrow_mut());\n \n-        match parse_tt(cx, lhs_tt, arg.clone()) {\n+        match parse_tt(&mut parser, lhs_tt) {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n@@ -232,7 +256,7 @@ fn generic_extension<'cx>(\n \n                 if cx.trace_macros() {\n                     let msg = format!(\"to `{}`\", pprust::tts_to_string(tts.clone()));\n-                    trace_macros_note(cx, sp, msg);\n+                    trace_macros_note(&mut cx.expansions, sp, msg);\n                 }\n \n                 let directory = Directory {\n@@ -269,6 +293,7 @@ fn generic_extension<'cx>(\n         // Restore to the state before snapshotting and maybe try again.\n         mem::swap(&mut gated_spans_snaphot, &mut cx.parse_sess.gated_spans.spans.borrow_mut());\n     }\n+    drop(base_parser);\n \n     let (token, label) = best_failure.expect(\"ran no matchers\");\n     let span = token.span.substitute_dummy(sp);\n@@ -286,7 +311,9 @@ fn generic_extension<'cx>(\n                 mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n                 _ => continue,\n             };\n-            match parse_tt(cx, lhs_tt, arg.clone()) {\n+            let base_parser =\n+                base_parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n+            match parse_tt(&mut Cow::Borrowed(&base_parser), lhs_tt) {\n                 Success(_) => {\n                     if comma_span.is_dummy() {\n                         err.note(\"you might be missing a comma\");\n@@ -368,7 +395,8 @@ pub fn compile_declarative_macro(\n         ),\n     ];\n \n-    let argument_map = match parse(sess, body, &argument_gram, None, true) {\n+    let base_parser = Parser::new(sess, body, None, true, true, rustc_parse::MACRO_ARGUMENTS);\n+    let argument_map = match parse_tt(&mut Cow::Borrowed(&base_parser), &argument_gram) {\n         Success(m) => m,\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);\n@@ -1184,14 +1212,16 @@ fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     }\n }\n \n-/// Use this token tree as a matcher to parse given tts.\n-fn parse_tt(cx: &ExtCtxt<'_>, mtch: &[mbe::TokenTree], tts: TokenStream) -> NamedParseResult {\n-    // `None` is because we're not interpolating\n+fn base_parser_from_cx<'cx>(\n+    current_expansion: &'cx ExpansionData,\n+    sess: &'cx ParseSess,\n+    tts: TokenStream,\n+) -> Parser<'cx> {\n     let directory = Directory {\n-        path: Cow::from(cx.current_expansion.module.directory.as_path()),\n-        ownership: cx.current_expansion.directory_ownership,\n+        path: Cow::from(current_expansion.module.directory.as_path()),\n+        ownership: current_expansion.directory_ownership,\n     };\n-    parse(cx.parse_sess(), tts, mtch, Some(directory), true)\n+    Parser::new(sess, tts, Some(directory), true, true, rustc_parse::MACRO_ARGUMENTS)\n }\n \n /// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For"}]}