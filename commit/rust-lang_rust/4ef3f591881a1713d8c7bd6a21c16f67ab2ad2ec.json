{"sha": "4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlZjNmNTkxODgxYTE3MTNkOGM3YmQ2YTIxYzE2ZjY3YWIyYWQyZWM=", "commit": {"author": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-09-26T03:41:27Z"}, "committer": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-10-07T04:19:19Z"}, "message": "Run rustfmt on librustc_typeck/check/ folder", "tree": {"sha": "caa84bc9718729f24603930d066d97120fc52445", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/caa84bc9718729f24603930d066d97120fc52445"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJX9yJHAAoJEAkcWPS/w2VxL4UP+wYeDgVGRdvVTZcZywKj8NpJ\nV0JDOw4BGrBjEQbc2wejS97hIw9xHVOrFbtlkN1LiE756z06custgOSk/4/Zm+Pk\nz1qnRAHoOGv/5hIxQzaHsmt7TUISUiCO957JD24IXzdIHf0zX4IM+lV8T7HaQZuh\n6Nv4LgwHKxCCIgdaaVSwajxStArVBoQxpvI9JL4OqNbvVfku6BwI3zPRLvbD8STD\nXgyY1YCzGyFt7IeCin326PR95IruZ18tDXldpc0K5CSCGWtvZm4p0UXAqjks5JMk\nCNHhXAZKylkSsTVdnNx9EwCCek3bw/kUfqJmCAzrl/6xpLtKa+TRuFIATsWmpdPv\n1IaztYby4tD/rQiUYRDKisbVVuyTHoA73x1uXl/O9Lk1OOzhjUsnPIyY7s3zfTC7\nLn5LjN4+EQGdli4C9v+dyomsjnYCs8REstihDCdT4KL1LRVii6mdyLV0JqwILIyP\nduir0AtopJmv6qT6r1u23S5BXmorVzor0or1cdBrQaGFTdPFsch27a7CxR5mkzVV\nXYbJ2ad26ExqupMdIk5STnswO+sXNBqVIdqfZrzwTkkW12sAH0hCRUsd4ehNG+ll\nE8FK8VAH2SXDWXOypEn7Tdgv85tkgK2tTptvMcc0kLrPEInJtCOxXnWVfTEhFy3G\ny65NutkQ/wnuE8fjzMM5\n=aL9S\n-----END PGP SIGNATURE-----", "payload": "tree caa84bc9718729f24603930d066d97120fc52445\nparent 75c155b834e3bd667ca50187741c1b7abbf9e3df\nauthor Srinivas Reddy Thatiparthy <thatiparthysreenivas@gmail.com> 1474861287 +0530\ncommitter Srinivas Reddy Thatiparthy <thatiparthysreenivas@gmail.com> 1475813959 +0530\n\nRun rustfmt on librustc_typeck/check/ folder\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec", "html_url": "https://github.com/rust-lang/rust/commit/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/comments", "author": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75c155b834e3bd667ca50187741c1b7abbf9e3df", "url": "https://api.github.com/repos/rust-lang/rust/commits/75c155b834e3bd667ca50187741c1b7abbf9e3df", "html_url": "https://github.com/rust-lang/rust/commit/75c155b834e3bd667ca50187741c1b7abbf9e3df"}], "stats": {"total": 1236, "additions": 633, "deletions": 603}, "files": [{"sha": "9610477d8fd919f26e49a37c1130a4e4375eaef5", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n use rustc::infer::InferCtxt;\n-use rustc::traits::{self, FulfillmentContext, Normalized, MiscObligation,\n-                     SelectionContext, ObligationCause};\n+use rustc::traits::{self, FulfillmentContext, Normalized, MiscObligation, SelectionContext,\n+                    ObligationCause};\n use rustc::ty::fold::TypeFoldable;\n use syntax::ast;\n use syntax_pos::Span;\n \n-//FIXME(@jroesch): Ideally we should be able to drop the fulfillment_cx argument.\n+// FIXME(@jroesch): Ideally we should be able to drop the fulfillment_cx argument.\n pub fn normalize_associated_types_in<'a, 'gcx, 'tcx, T>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     fulfillment_cx: &mut FulfillmentContext<'tcx>,"}, {"sha": "8127bcf8256438e7f1230ec4a6e2357bae9b66ae", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 61, "deletions": 48, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec", "patch": "@@ -26,7 +26,7 @@ use syntax::parse::token;\n #[derive(Copy, Clone, Debug)]\n enum AutoderefKind {\n     Builtin,\n-    Overloaded\n+    Overloaded,\n }\n \n pub struct Autoderef<'a, 'gcx: 'tcx, 'tcx: 'a> {\n@@ -35,7 +35,7 @@ pub struct Autoderef<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     cur_ty: Ty<'tcx>,\n     obligations: Vec<traits::PredicateObligation<'tcx>>,\n     at_start: bool,\n-    span: Span\n+    span: Span,\n }\n \n impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n@@ -45,7 +45,8 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n         let tcx = self.fcx.tcx;\n \n         debug!(\"autoderef: steps={:?}, cur_ty={:?}\",\n-               self.steps, self.cur_ty);\n+               self.steps,\n+               self.cur_ty);\n         if self.at_start {\n             self.at_start = false;\n             debug!(\"autoderef stage #0 is {:?}\", self.cur_ty);\n@@ -54,11 +55,13 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n \n         if self.steps.len() == tcx.sess.recursion_limit.get() {\n             // We've reached the recursion limit, error gracefully.\n-            struct_span_err!(tcx.sess, self.span, E0055,\n-                      \"reached the recursion limit while auto-dereferencing {:?}\",\n-                      self.cur_ty)\n-                      .span_label(self.span, &format!(\"deref recursion limit reached\"))\n-                      .emit();\n+            struct_span_err!(tcx.sess,\n+                             self.span,\n+                             E0055,\n+                             \"reached the recursion limit while auto-dereferencing {:?}\",\n+                             self.cur_ty)\n+                .span_label(self.span, &format!(\"deref recursion limit reached\"))\n+                .emit();\n             return None;\n         }\n \n@@ -72,7 +75,7 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n         } else {\n             match self.overloaded_deref_ty(self.cur_ty) {\n                 Some(ty) => (AutoderefKind::Overloaded, ty),\n-                _ => return None\n+                _ => return None,\n             }\n         };\n \n@@ -81,8 +84,10 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n         }\n \n         self.steps.push((self.cur_ty, kind));\n-        debug!(\"autoderef stage #{:?} is {:?} from {:?}\", self.steps.len(),\n-               new_ty, (self.cur_ty, kind));\n+        debug!(\"autoderef stage #{:?} is {:?} from {:?}\",\n+               self.steps.len(),\n+               new_ty,\n+               (self.cur_ty, kind));\n         self.cur_ty = new_ty;\n \n         Some((self.cur_ty, self.steps.len()))\n@@ -99,9 +104,9 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         let trait_ref = TraitRef {\n             def_id: match tcx.lang_items.deref_trait() {\n                 Some(f) => f,\n-                None => return None\n+                None => return None,\n             },\n-            substs: Substs::new_trait(tcx, self.cur_ty, &[])\n+            substs: Substs::new_trait(tcx, self.cur_ty, &[]),\n         };\n \n         let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n@@ -113,15 +118,13 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n             return None;\n         }\n \n-        let normalized = traits::normalize_projection_type(\n-            &mut selcx,\n-            ty::ProjectionTy {\n-                trait_ref: trait_ref,\n-                item_name: token::intern(\"Target\")\n-            },\n-            cause,\n-            0\n-        );\n+        let normalized = traits::normalize_projection_type(&mut selcx,\n+                                                           ty::ProjectionTy {\n+                                                               trait_ref: trait_ref,\n+                                                               item_name: token::intern(\"Target\"),\n+                                                           },\n+                                                           cause,\n+                                                           0);\n \n         debug!(\"overloaded_deref_ty({:?}) = {:?}\", ty, normalized);\n         self.obligations.extend(normalized.obligations);\n@@ -134,17 +137,23 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn finalize<'b, I>(self, pref: LvaluePreference, exprs: I)\n-        where I: IntoIterator<Item=&'b hir::Expr>\n+        where I: IntoIterator<Item = &'b hir::Expr>\n     {\n-        let methods : Vec<_> = self.steps.iter().map(|&(ty, kind)| {\n-            if let AutoderefKind::Overloaded = kind {\n-                self.fcx.try_overloaded_deref(self.span, None, ty, pref)\n-            } else {\n-                None\n-            }\n-        }).collect();\n+        let methods: Vec<_> = self.steps\n+            .iter()\n+            .map(|&(ty, kind)| {\n+                if let AutoderefKind::Overloaded = kind {\n+                    self.fcx.try_overloaded_deref(self.span, None, ty, pref)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect();\n \n-        debug!(\"finalize({:?}) - {:?},{:?}\", pref, methods, self.obligations);\n+        debug!(\"finalize({:?}) - {:?},{:?}\",\n+               pref,\n+               methods,\n+               self.obligations);\n \n         for expr in exprs {\n             debug!(\"finalize - finalizing #{} - {:?}\", expr.id, expr);\n@@ -163,18 +172,14 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn autoderef(&'a self,\n-                     span: Span,\n-                     base_ty: Ty<'tcx>)\n-                     -> Autoderef<'a, 'gcx, 'tcx>\n-    {\n+    pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'gcx, 'tcx> {\n         Autoderef {\n             fcx: self,\n             steps: vec![],\n             cur_ty: self.resolve_type_vars_if_possible(&base_ty),\n             obligations: vec![],\n             at_start: true,\n-            span: span\n+            span: span,\n         }\n     }\n \n@@ -183,28 +188,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 base_expr: Option<&hir::Expr>,\n                                 base_ty: Ty<'tcx>,\n                                 lvalue_pref: LvaluePreference)\n-                                -> Option<MethodCallee<'tcx>>\n-    {\n+                                -> Option<MethodCallee<'tcx>> {\n         debug!(\"try_overloaded_deref({:?},{:?},{:?},{:?})\",\n-               span, base_expr, base_ty, lvalue_pref);\n+               span,\n+               base_expr,\n+               base_ty,\n+               lvalue_pref);\n         // Try DerefMut first, if preferred.\n         let method = match (lvalue_pref, self.tcx.lang_items.deref_mut_trait()) {\n             (PreferMutLvalue, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span, base_expr,\n-                                            token::intern(\"deref_mut\"), trait_did,\n-                                            base_ty, None)\n+                self.lookup_method_in_trait(span,\n+                                            base_expr,\n+                                            token::intern(\"deref_mut\"),\n+                                            trait_did,\n+                                            base_ty,\n+                                            None)\n             }\n-            _ => None\n+            _ => None,\n         };\n \n         // Otherwise, fall back to Deref.\n         let method = match (method, self.tcx.lang_items.deref_trait()) {\n             (None, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span, base_expr,\n-                                            token::intern(\"deref\"), trait_did,\n-                                            base_ty, None)\n+                self.lookup_method_in_trait(span,\n+                                            base_expr,\n+                                            token::intern(\"deref\"),\n+                                            trait_did,\n+                                            base_ty,\n+                                            None)\n             }\n-            (method, _) => method\n+            (method, _) => method,\n         };\n \n         method"}, {"sha": "c5a21d7dd91ce116bb9a4b5585cbd15e041747ef", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 84, "deletions": 85, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{DeferredCallResolution, Expectation, FnCtxt,\n-            TupleArgumentsFlag};\n+use super::{DeferredCallResolution, Expectation, FnCtxt, TupleArgumentsFlag};\n \n use CrateCtxt;\n use hir::def::Def;\n@@ -27,7 +26,10 @@ use rustc::hir;\n /// method that is called)\n pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id: DefId) {\n     if ccx.tcx.lang_items.drop_trait() == Some(trait_id) {\n-        struct_span_err!(ccx.tcx.sess, span, E0040, \"explicit use of destructor method\")\n+        struct_span_err!(ccx.tcx.sess,\n+                         span,\n+                         E0040,\n+                         \"explicit use of destructor method\")\n             .span_label(span, &format!(\"explicit destructor calls not allowed\"))\n             .emit();\n     }\n@@ -36,23 +38,25 @@ pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id:\n enum CallStep<'tcx> {\n     Builtin,\n     DeferredClosure(ty::FnSig<'tcx>),\n-    Overloaded(ty::MethodCallee<'tcx>)\n+    Overloaded(ty::MethodCallee<'tcx>),\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_call(&self,\n                       call_expr: &'gcx hir::Expr,\n                       callee_expr: &'gcx hir::Expr,\n                       arg_exprs: &'gcx [P<hir::Expr>],\n-                      expected: Expectation<'tcx>) -> Ty<'tcx>\n-    {\n+                      expected: Expectation<'tcx>)\n+                      -> Ty<'tcx> {\n         let original_callee_ty = self.check_expr(callee_expr);\n         let expr_ty = self.structurally_resolved_type(call_expr.span, original_callee_ty);\n \n         let mut autoderef = self.autoderef(callee_expr.span, expr_ty);\n-        let result = autoderef.by_ref().flat_map(|(adj_ty, idx)| {\n-            self.try_overloaded_call_step(call_expr, callee_expr, adj_ty, idx)\n-        }).next();\n+        let result = autoderef.by_ref()\n+            .flat_map(|(adj_ty, idx)| {\n+                self.try_overloaded_call_step(call_expr, callee_expr, adj_ty, idx)\n+            })\n+            .next();\n         let callee_ty = autoderef.unambiguous_final_ty();\n         autoderef.finalize(LvaluePreference::NoPreference, Some(callee_expr));\n \n@@ -71,8 +75,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             Some(CallStep::Overloaded(method_callee)) => {\n-                self.confirm_overloaded_call(call_expr, callee_expr,\n-                                             arg_exprs, expected, method_callee)\n+                self.confirm_overloaded_call(call_expr,\n+                                             callee_expr,\n+                                             arg_exprs,\n+                                             expected,\n+                                             method_callee)\n             }\n         };\n \n@@ -87,8 +94,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 callee_expr: &'gcx hir::Expr,\n                                 adjusted_ty: Ty<'tcx>,\n                                 autoderefs: usize)\n-                                -> Option<CallStep<'tcx>>\n-    {\n+                                -> Option<CallStep<'tcx>> {\n         debug!(\"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?}, autoderefs={})\",\n                call_expr,\n                adjusted_ty,\n@@ -108,20 +114,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // haven't yet decided on whether the closure is fn vs\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n                 if self.closure_kind(def_id).is_none() {\n-                    let closure_ty =\n-                        self.closure_type(def_id, substs);\n-                    let fn_sig =\n-                        self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n-                                                                       infer::FnCall,\n-                                                                       &closure_ty.sig).0;\n-                    self.record_deferred_call_resolution(def_id, Box::new(CallResolution {\n-                        call_expr: call_expr,\n-                        callee_expr: callee_expr,\n-                        adjusted_ty: adjusted_ty,\n-                        autoderefs: autoderefs,\n-                        fn_sig: fn_sig.clone(),\n-                        closure_def_id: def_id\n-                    }));\n+                    let closure_ty = self.closure_type(def_id, substs);\n+                    let fn_sig = self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n+                                                                   infer::FnCall,\n+                                                                   &closure_ty.sig)\n+                        .0;\n+                    self.record_deferred_call_resolution(def_id,\n+                                                         Box::new(CallResolution {\n+                                                             call_expr: call_expr,\n+                                                             callee_expr: callee_expr,\n+                                                             adjusted_ty: adjusted_ty,\n+                                                             autoderefs: autoderefs,\n+                                                             fn_sig: fn_sig.clone(),\n+                                                             closure_def_id: def_id,\n+                                                         }));\n                     return Some(CallStep::DeferredClosure(fn_sig));\n                 }\n             }\n@@ -150,14 +156,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   callee_expr: &hir::Expr,\n                                   adjusted_ty: Ty<'tcx>,\n                                   autoderefs: usize)\n-                                  -> Option<ty::MethodCallee<'tcx>>\n-    {\n+                                  -> Option<ty::MethodCallee<'tcx>> {\n         // Try the options that are least restrictive on the caller first.\n-        for &(opt_trait_def_id, method_name) in &[\n-            (self.tcx.lang_items.fn_trait(), token::intern(\"call\")),\n-            (self.tcx.lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n-            (self.tcx.lang_items.fn_once_trait(), token::intern(\"call_once\")),\n-        ] {\n+        for &(opt_trait_def_id, method_name) in\n+            &[(self.tcx.lang_items.fn_trait(), token::intern(\"call\")),\n+              (self.tcx.lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n+              (self.tcx.lang_items.fn_once_trait(), token::intern(\"call_once\"))] {\n             let trait_def_id = match opt_trait_def_id {\n                 Some(def_id) => def_id,\n                 None => continue,\n@@ -185,19 +189,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             call_expr: &hir::Expr,\n                             callee_ty: Ty<'tcx>,\n                             arg_exprs: &'gcx [P<hir::Expr>],\n-                            expected: Expectation<'tcx>) -> Ty<'tcx>\n-    {\n+                            expected: Expectation<'tcx>)\n+                            -> Ty<'tcx> {\n         let error_fn_sig;\n \n         let fn_sig = match callee_ty.sty {\n-            ty::TyFnDef(.., &ty::BareFnTy {ref sig, ..}) |\n-            ty::TyFnPtr(&ty::BareFnTy {ref sig, ..}) => {\n-                sig\n-            }\n+            ty::TyFnDef(.., &ty::BareFnTy { ref sig, .. }) |\n+            ty::TyFnPtr(&ty::BareFnTy { ref sig, .. }) => sig,\n             _ => {\n-                let mut err = self.type_error_struct(call_expr.span, |actual| {\n-                    format!(\"expected function, found `{}`\", actual)\n-                }, callee_ty);\n+                let mut err = self.type_error_struct(call_expr.span,\n+                                                     |actual| {\n+                                                         format!(\"expected function, found `{}`\",\n+                                                                 actual)\n+                                                     },\n+                                                     callee_ty);\n \n                 if let hir::ExprCall(ref expr, _) = call_expr.node {\n                     let tcx = self.tcx;\n@@ -218,7 +223,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 error_fn_sig = ty::Binder(ty::FnSig {\n                     inputs: self.err_args(arg_exprs.len()),\n                     output: self.tcx.types.err,\n-                    variadic: false\n+                    variadic: false,\n                 });\n \n                 &error_fn_sig\n@@ -231,17 +236,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // previously appeared within a `Binder<>` and hence would not\n         // have been normalized before.\n         let fn_sig =\n-            self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n-                                                           infer::FnCall,\n-                                                           fn_sig).0;\n-        let fn_sig =\n-            self.normalize_associated_types_in(call_expr.span, &fn_sig);\n+            self.replace_late_bound_regions_with_fresh_var(call_expr.span, infer::FnCall, fn_sig)\n+                .0;\n+        let fn_sig = self.normalize_associated_types_in(call_expr.span, &fn_sig);\n \n         // Call the generic checker.\n-        let expected_arg_tys = self.expected_types_for_fn_args(call_expr.span,\n-                                                               expected,\n-                                                               fn_sig.output,\n-                                                               &fn_sig.inputs);\n+        let expected_arg_tys =\n+            self.expected_types_for_fn_args(call_expr.span,\n+                                            expected,\n+                                            fn_sig.output,\n+                                            &fn_sig.inputs);\n         self.check_argument_types(call_expr.span,\n                                   &fn_sig.inputs,\n                                   &expected_arg_tys[..],\n@@ -256,18 +260,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                      call_expr: &hir::Expr,\n                                      arg_exprs: &'gcx [P<hir::Expr>],\n                                      expected: Expectation<'tcx>,\n-                                     fn_sig: ty::FnSig<'tcx>) -> Ty<'tcx>\n-    {\n+                                     fn_sig: ty::FnSig<'tcx>)\n+                                     -> Ty<'tcx> {\n         // `fn_sig` is the *signature* of the cosure being called. We\n         // don't know the full details yet (`Fn` vs `FnMut` etc), but we\n         // do know the types expected for each argument and the return\n         // type.\n \n-        let expected_arg_tys =\n-            self.expected_types_for_fn_args(call_expr.span,\n-                                            expected,\n-                                            fn_sig.output.clone(),\n-                                            &fn_sig.inputs);\n+        let expected_arg_tys = self.expected_types_for_fn_args(call_expr.span,\n+                                                               expected,\n+                                                               fn_sig.output.clone(),\n+                                                               &fn_sig.inputs);\n \n         self.check_argument_types(call_expr.span,\n                                   &fn_sig.inputs,\n@@ -284,15 +287,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                callee_expr: &'gcx hir::Expr,\n                                arg_exprs: &'gcx [P<hir::Expr>],\n                                expected: Expectation<'tcx>,\n-                               method_callee: ty::MethodCallee<'tcx>) -> Ty<'tcx>\n-    {\n-        let output_type =\n-            self.check_method_argument_types(call_expr.span,\n-                                             method_callee.ty,\n-                                             callee_expr,\n-                                             arg_exprs,\n-                                             TupleArgumentsFlag::TupleArguments,\n-                                             expected);\n+                               method_callee: ty::MethodCallee<'tcx>)\n+                               -> Ty<'tcx> {\n+        let output_type = self.check_method_argument_types(call_expr.span,\n+                                                           method_callee.ty,\n+                                                           callee_expr,\n+                                                           arg_exprs,\n+                                                           TupleArgumentsFlag::TupleArguments,\n+                                                           expected);\n \n         self.write_overloaded_call_method_map(call_expr, method_callee);\n         output_type\n@@ -318,16 +320,17 @@ struct CallResolution<'gcx: 'tcx, 'tcx> {\n \n impl<'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> for CallResolution<'gcx, 'tcx> {\n     fn resolve<'a>(&mut self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n-        debug!(\"DeferredCallResolution::resolve() {:?}\",\n-               self);\n+        debug!(\"DeferredCallResolution::resolve() {:?}\", self);\n \n         // we should not be invoked until the closure kind has been\n         // determined by upvar inference\n         assert!(fcx.closure_kind(self.closure_def_id).is_some());\n \n         // We may now know enough to figure out fn vs fnmut etc.\n-        match fcx.try_overloaded_call_traits(self.call_expr, self.callee_expr,\n-                                             self.adjusted_ty, self.autoderefs) {\n+        match fcx.try_overloaded_call_traits(self.call_expr,\n+                                             self.callee_expr,\n+                                             self.adjusted_ty,\n+                                             self.autoderefs) {\n             Some(method_callee) => {\n                 // One problem is that when we get here, we are going\n                 // to have a newly instantiated function signature\n@@ -337,28 +340,24 @@ impl<'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> for CallResolution<'gcx, 'tc\n                 // can't because of the annoying need for a TypeTrace.\n                 // (This always bites me, should find a way to\n                 // refactor it.)\n-                let method_sig = fcx.tcx.no_late_bound_regions(method_callee.ty.fn_sig())\n-                                        .unwrap();\n+                let method_sig = fcx.tcx\n+                    .no_late_bound_regions(method_callee.ty.fn_sig())\n+                    .unwrap();\n \n-                debug!(\"attempt_resolution: method_callee={:?}\",\n-                       method_callee);\n+                debug!(\"attempt_resolution: method_callee={:?}\", method_callee);\n \n                 for (&method_arg_ty, &self_arg_ty) in\n-                    method_sig.inputs[1..].iter().zip(&self.fn_sig.inputs)\n-                {\n+                    method_sig.inputs[1..].iter().zip(&self.fn_sig.inputs) {\n                     fcx.demand_eqtype(self.call_expr.span, self_arg_ty, method_arg_ty);\n                 }\n \n-                fcx.demand_eqtype(self.call_expr.span,\n-                                  method_sig.output,\n-                                  self.fn_sig.output);\n+                fcx.demand_eqtype(self.call_expr.span, method_sig.output, self.fn_sig.output);\n \n                 fcx.write_overloaded_call_method_map(self.call_expr, method_callee);\n             }\n             None => {\n-                span_bug!(\n-                    self.call_expr.span,\n-                    \"failed to find an overloaded call trait for closure call\");\n+                span_bug!(self.call_expr.span,\n+                          \"failed to find an overloaded call trait for closure call\");\n             }\n         }\n     }"}, {"sha": "c456b9358b3e2e1f652dd48ab8d846557ac59b9b", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 111, "deletions": 103, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec", "patch": "@@ -69,7 +69,7 @@ enum UnsizeKind<'tcx> {\n     /// The unsize info of this projection\n     OfProjection(&'tcx ty::ProjectionTy<'tcx>),\n     /// The unsize info of this parameter\n-    OfParam(&'tcx ty::ParamTy)\n+    OfParam(&'tcx ty::ParamTy),\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -83,13 +83,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // FIXME(arielb1): do some kind of normalization\n                 match def.struct_variant().fields.last() {\n                     None => None,\n-                    Some(f) => self.unsize_kind(f.ty(self.tcx, substs))\n+                    Some(f) => self.unsize_kind(f.ty(self.tcx, substs)),\n                 }\n             }\n             // We should really try to normalize here.\n             ty::TyProjection(ref pi) => Some(UnsizeKind::OfProjection(pi)),\n             ty::TyParam(ref p) => Some(UnsizeKind::OfParam(p)),\n-            _ => None\n+            _ => None,\n         }\n     }\n }\n@@ -133,9 +133,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                 check.report_cast_to_unsized_type(fcx);\n                 Err(ErrorReported)\n             }\n-            _ => {\n-                Ok(check)\n-            }\n+            _ => Ok(check),\n         }\n     }\n \n@@ -145,18 +143,21 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             CastError::NeedViaThinPtr |\n             CastError::NeedViaInt |\n             CastError::NeedViaUsize => {\n-                fcx.type_error_struct(self.span, |actual| {\n-                    format!(\"casting `{}` as `{}` is invalid\",\n-                            actual,\n-                            fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty)\n-                    .help(&format!(\"cast through {} first\", match e {\n-                            CastError::NeedViaPtr => \"a raw pointer\",\n-                            CastError::NeedViaThinPtr => \"a thin pointer\",\n-                            CastError::NeedViaInt => \"an integer\",\n-                            CastError::NeedViaUsize => \"a usize\",\n-                            _ => bug!()\n-                        }))\n+                fcx.type_error_struct(self.span,\n+                                       |actual| {\n+                                           format!(\"casting `{}` as `{}` is invalid\",\n+                                                   actual,\n+                                                   fcx.ty_to_string(self.cast_ty))\n+                                       },\n+                                       self.expr_ty)\n+                    .help(&format!(\"cast through {} first\",\n+                                   match e {\n+                                       CastError::NeedViaPtr => \"a raw pointer\",\n+                                       CastError::NeedViaThinPtr => \"a thin pointer\",\n+                                       CastError::NeedViaInt => \"an integer\",\n+                                       CastError::NeedViaUsize => \"a usize\",\n+                                       _ => bug!(),\n+                                   }))\n                     .emit();\n             }\n             CastError::CastToBool => {\n@@ -166,76 +167,90 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                     .emit();\n             }\n             CastError::CastToChar => {\n-                fcx.type_error_message(self.span, |actual| {\n-                    format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n-                }, self.expr_ty);\n+                fcx.type_error_message(self.span,\n+                                       |actual| {\n+                                           format!(\"only `u8` can be cast as `char`, not `{}`\",\n+                                                   actual)\n+                                       },\n+                                       self.expr_ty);\n             }\n             CastError::NonScalar => {\n-                fcx.type_error_message(self.span, |actual| {\n-                    format!(\"non-scalar cast: `{}` as `{}`\",\n-                            actual,\n-                            fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty);\n+                fcx.type_error_message(self.span,\n+                                       |actual| {\n+                                           format!(\"non-scalar cast: `{}` as `{}`\",\n+                                                   actual,\n+                                                   fcx.ty_to_string(self.cast_ty))\n+                                       },\n+                                       self.expr_ty);\n             }\n             CastError::IllegalCast => {\n-                fcx.type_error_message(self.span, |actual| {\n-                    format!(\"casting `{}` as `{}` is invalid\",\n-                            actual,\n-                            fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty);\n+                fcx.type_error_message(self.span,\n+                                       |actual| {\n+                                           format!(\"casting `{}` as `{}` is invalid\",\n+                                                   actual,\n+                                                   fcx.ty_to_string(self.cast_ty))\n+                                       },\n+                                       self.expr_ty);\n             }\n             CastError::SizedUnsizedCast => {\n-                fcx.type_error_message(self.span, |actual| {\n-                    format!(\"cannot cast thin pointer `{}` to fat pointer `{}`\",\n-                            actual,\n-                            fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty)\n+                fcx.type_error_message(self.span,\n+                                       |actual| {\n+                                           format!(\"cannot cast thin pointer `{}` to fat pointer \\\n+                                                    `{}`\",\n+                                                   actual,\n+                                                   fcx.ty_to_string(self.cast_ty))\n+                                       },\n+                                       self.expr_ty)\n             }\n             CastError::DifferingKinds => {\n-                fcx.type_error_struct(self.span, |actual| {\n-                    format!(\"casting `{}` as `{}` is invalid\",\n-                            actual,\n-                            fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty)\n+                fcx.type_error_struct(self.span,\n+                                       |actual| {\n+                                           format!(\"casting `{}` as `{}` is invalid\",\n+                                                   actual,\n+                                                   fcx.ty_to_string(self.cast_ty))\n+                                       },\n+                                       self.expr_ty)\n                     .note(\"vtable kinds may not match\")\n                     .emit();\n             }\n         }\n     }\n \n     fn report_cast_to_unsized_type(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) {\n-        if\n-            self.cast_ty.references_error() ||\n-            self.expr_ty.references_error()\n-        {\n+        if self.cast_ty.references_error() || self.expr_ty.references_error() {\n             return;\n         }\n \n         let tstr = fcx.ty_to_string(self.cast_ty);\n-        let mut err = fcx.type_error_struct(self.span, |actual| {\n-            format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n-        }, self.expr_ty);\n+        let mut err =\n+            fcx.type_error_struct(self.span,\n+                                  |actual| {\n+                                      format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n+                                  },\n+                                  self.expr_ty);\n         match self.expr_ty.sty {\n             ty::TyRef(_, ty::TypeAndMut { mutbl: mt, .. }) => {\n                 let mtstr = match mt {\n                     hir::MutMutable => \"mut \",\n-                    hir::MutImmutable => \"\"\n+                    hir::MutImmutable => \"\",\n                 };\n                 if self.cast_ty.is_trait() {\n                     match fcx.tcx.sess.codemap().span_to_snippet(self.cast_span) {\n                         Ok(s) => {\n                             err.span_suggestion(self.cast_span,\n                                                 \"try casting to a reference instead:\",\n                                                 format!(\"&{}{}\", mtstr, s));\n-                        },\n-                        Err(_) =>\n-                            span_help!(err, self.cast_span,\n-                                       \"did you mean `&{}{}`?\", mtstr, tstr),\n+                        }\n+                        Err(_) => {\n+                            span_help!(err, self.cast_span, \"did you mean `&{}{}`?\", mtstr, tstr)\n+                        }\n                     }\n                 } else {\n-                    span_help!(err, self.span,\n+                    span_help!(err,\n+                               self.span,\n                                \"consider using an implicit coercion to `&{}{}` instead\",\n-                               mtstr, tstr);\n+                               mtstr,\n+                               tstr);\n                 }\n             }\n             ty::TyBox(..) => {\n@@ -244,13 +259,13 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                         err.span_suggestion(self.cast_span,\n                                             \"try casting to a `Box` instead:\",\n                                             format!(\"Box<{}>\", s));\n-                    },\n-                    Err(_) =>\n-                        span_help!(err, self.cast_span, \"did you mean `Box<{}>`?\", tstr),\n+                    }\n+                    Err(_) => span_help!(err, self.cast_span, \"did you mean `Box<{}>`?\", tstr),\n                 }\n             }\n             _ => {\n-                span_help!(err, self.expr.span,\n+                span_help!(err,\n+                           self.expr.span,\n                            \"consider using a box or reference as appropriate\");\n             }\n         }\n@@ -286,7 +301,9 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         self.expr_ty = fcx.structurally_resolved_type(self.span, self.expr_ty);\n         self.cast_ty = fcx.structurally_resolved_type(self.span, self.cast_ty);\n \n-        debug!(\"check_cast({}, {:?} as {:?})\", self.expr.id, self.expr_ty,\n+        debug!(\"check_cast({}, {:?} as {:?})\",\n+               self.expr.id,\n+               self.expr_ty,\n                self.cast_ty);\n \n         if !fcx.type_is_known_to_be_sized(self.cast_ty, self.span) {\n@@ -296,15 +313,16 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         } else if self.try_coercion_cast(fcx) {\n             self.trivial_cast_lint(fcx);\n             debug!(\" -> CoercionCast\");\n-            fcx.tcx.cast_kinds.borrow_mut().insert(self.expr.id,\n-                                                   CastKind::CoercionCast);\n-        } else { match self.do_check(fcx) {\n-            Ok(k) => {\n-                debug!(\" -> {:?}\", k);\n-                fcx.tcx.cast_kinds.borrow_mut().insert(self.expr.id, k);\n-            }\n-            Err(e) => self.report_cast_error(fcx, e)\n-        };}\n+            fcx.tcx.cast_kinds.borrow_mut().insert(self.expr.id, CastKind::CoercionCast);\n+        } else {\n+            match self.do_check(fcx) {\n+                Ok(k) => {\n+                    debug!(\" -> {:?}\", k);\n+                    fcx.tcx.cast_kinds.borrow_mut().insert(self.expr.id, k);\n+                }\n+                Err(e) => self.report_cast_error(fcx, e),\n+            };\n+        }\n     }\n \n     /// Check a cast, and report an error if one exists. In some cases, this\n@@ -330,9 +348,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                     return Err(CastError::NonScalar);\n                 }\n             }\n-            _ => {\n-                return Err(CastError::NonScalar)\n-            }\n+            _ => return Err(CastError::NonScalar),\n         };\n \n         match (t_from, t_cast) {\n@@ -347,17 +363,20 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             (_, Int(Char)) => Err(CastError::CastToChar),\n \n             // prim -> float,ptr\n-            (Int(Bool), Float) | (Int(CEnum), Float) | (Int(Char), Float)\n-                => Err(CastError::NeedViaInt),\n-            (Int(Bool), Ptr(_)) | (Int(CEnum), Ptr(_)) | (Int(Char), Ptr(_))\n-                => Err(CastError::NeedViaUsize),\n+            (Int(Bool), Float) |\n+            (Int(CEnum), Float) |\n+            (Int(Char), Float) => Err(CastError::NeedViaInt),\n+            (Int(Bool), Ptr(_)) |\n+            (Int(CEnum), Ptr(_)) |\n+            (Int(Char), Ptr(_)) => Err(CastError::NeedViaUsize),\n \n             // ptr -> *\n             (Ptr(m_e), Ptr(m_c)) => self.check_ptr_ptr_cast(fcx, m_e, m_c), // ptr-ptr-cast\n             (Ptr(m_expr), Int(_)) => self.check_ptr_addr_cast(fcx, m_expr), // ptr-addr-cast\n             (Ptr(_), Float) | (FnPtr, Float) => Err(CastError::NeedViaUsize),\n             (FnPtr, Int(_)) => Ok(CastKind::FnPtrAddrCast),\n-            (RPtr(_), Int(_)) | (RPtr(_), Float) => Err(CastError::NeedViaPtr),\n+            (RPtr(_), Int(_)) |\n+            (RPtr(_), Float) => Err(CastError::NeedViaPtr),\n             // * -> ptr\n             (Int(_), Ptr(mt)) => self.check_addr_ptr_cast(fcx, mt), // addr-ptr-cast\n             (FnPtr, Ptr(mt)) => self.check_fptr_ptr_cast(fcx, mt),\n@@ -366,12 +385,12 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n \n             // prim -> prim\n             (Int(CEnum), Int(_)) => Ok(CastKind::EnumCast),\n-            (Int(Char), Int(_)) | (Int(Bool), Int(_)) => Ok(CastKind::PrimIntCast),\n+            (Int(Char), Int(_)) |\n+            (Int(Bool), Int(_)) => Ok(CastKind::PrimIntCast),\n \n-            (Int(_), Int(_)) |\n-            (Int(_), Float) |\n-            (Float, Int(_)) |\n-            (Float, Float) => Ok(CastKind::NumericCast),\n+            (Int(_), Int(_)) | (Int(_), Float) | (Float, Int(_)) | (Float, Float) => {\n+                Ok(CastKind::NumericCast)\n+            }\n \n         }\n     }\n@@ -380,10 +399,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                           fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                           m_expr: &'tcx ty::TypeAndMut<'tcx>,\n                           m_cast: &'tcx ty::TypeAndMut<'tcx>)\n-                          -> Result<CastKind, CastError>\n-    {\n-        debug!(\"check_ptr_ptr_cast m_expr={:?} m_cast={:?}\",\n-               m_expr, m_cast);\n+                          -> Result<CastKind, CastError> {\n+        debug!(\"check_ptr_ptr_cast m_expr={:?} m_cast={:?}\", m_expr, m_cast);\n         // ptr-ptr cast. vtables must match.\n \n         // Cast to sized is OK\n@@ -399,15 +416,14 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         // vtable kinds must match\n         match (fcx.unsize_kind(m_cast.ty), fcx.unsize_kind(m_expr.ty)) {\n             (Some(a), Some(b)) if a == b => Ok(CastKind::PtrPtrCast),\n-            _ => Err(CastError::DifferingKinds)\n+            _ => Err(CastError::DifferingKinds),\n         }\n     }\n \n     fn check_fptr_ptr_cast(&self,\n                            fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                            m_cast: &'tcx ty::TypeAndMut<'tcx>)\n-                           -> Result<CastKind, CastError>\n-    {\n+                           -> Result<CastKind, CastError> {\n         // fptr-ptr cast. must be to sized ptr\n \n         if fcx.type_is_known_to_be_sized(m_cast.ty, self.span) {\n@@ -420,8 +436,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     fn check_ptr_addr_cast(&self,\n                            fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                            m_expr: &'tcx ty::TypeAndMut<'tcx>)\n-                           -> Result<CastKind, CastError>\n-    {\n+                           -> Result<CastKind, CastError> {\n         // ptr-addr cast. must be from sized ptr\n \n         if fcx.type_is_known_to_be_sized(m_expr.ty, self.span) {\n@@ -435,8 +450,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                       fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                       m_expr: &'tcx ty::TypeAndMut<'tcx>,\n                       m_cast: &'tcx ty::TypeAndMut<'tcx>)\n-                      -> Result<CastKind, CastError>\n-    {\n+                      -> Result<CastKind, CastError> {\n         // array-ptr-cast.\n \n         if m_expr.mutbl == hir::MutImmutable && m_cast.mutbl == hir::MutImmutable {\n@@ -460,28 +474,22 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     fn check_addr_ptr_cast(&self,\n                            fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                            m_cast: &'tcx ty::TypeAndMut<'tcx>)\n-                           -> Result<CastKind, CastError>\n-    {\n+                           -> Result<CastKind, CastError> {\n         // ptr-addr cast. pointer must be thin.\n         if fcx.type_is_known_to_be_sized(m_cast.ty, self.span) {\n-           Ok(CastKind::AddrPtrCast)\n+            Ok(CastKind::AddrPtrCast)\n         } else {\n-           Err(CastError::IllegalCast)\n+            Err(CastError::IllegalCast)\n         }\n     }\n \n     fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> bool {\n         fcx.try_coerce(self.expr, self.expr_ty, self.cast_ty).is_ok()\n     }\n-\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    fn type_is_known_to_be_sized(&self,\n-                                 ty: Ty<'tcx>,\n-                                 span: Span)\n-                                 -> bool\n-    {\n+    fn type_is_known_to_be_sized(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundSized, span)\n     }\n }"}, {"sha": "1dbd0728bf217ab1b6fcf0f889a94fbe5406ae2e", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 64, "deletions": 57, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec", "patch": "@@ -24,17 +24,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               _capture: hir::CaptureClause,\n                               decl: &'gcx hir::FnDecl,\n                               body: &'gcx hir::Block,\n-                              expected: Expectation<'tcx>) -> Ty<'tcx> {\n+                              expected: Expectation<'tcx>)\n+                              -> Ty<'tcx> {\n         debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n                expr,\n                expected);\n \n         // It's always helpful for inference if we know the kind of\n         // closure sooner rather than later, so first examine the expected\n         // type, and see if can glean a closure kind from there.\n-        let (expected_sig,expected_kind) = match expected.to_option(self) {\n+        let (expected_sig, expected_kind) = match expected.to_option(self) {\n             Some(ty) => self.deduce_expectations_from_expected_type(ty),\n-            None => (None, None)\n+            None => (None, None),\n         };\n         self.check_closure(expr, expected_kind, decl, body, expected_sig)\n     }\n@@ -44,7 +45,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                      opt_kind: Option<ty::ClosureKind>,\n                      decl: &'gcx hir::FnDecl,\n                      body: &'gcx hir::Block,\n-                     expected_sig: Option<ty::FnSig<'tcx>>) -> Ty<'tcx> {\n+                     expected_sig: Option<ty::FnSig<'tcx>>)\n+                     -> Ty<'tcx> {\n         let expr_def_id = self.tcx.map.local_def_id(expr.id);\n \n         debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n@@ -64,18 +66,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let upvar_tys = self.next_ty_vars(num_upvars);\n \n         debug!(\"check_closure: expr.id={:?} upvar_tys={:?}\",\n-               expr.id, upvar_tys);\n+               expr.id,\n+               upvar_tys);\n \n         let closure_type = self.tcx.mk_closure(expr_def_id,\n-            self.parameter_environment.free_substs,\n-            upvar_tys);\n-\n-        let fn_sig = self.tcx.liberate_late_bound_regions(\n-            self.tcx.region_maps.call_site_extent(expr.id, body.id), &fn_ty.sig);\n-        let fn_sig =\n-            (**self).normalize_associated_types_in(body.span, body.id, &fn_sig);\n-\n-        check_fn(self, hir::Unsafety::Normal, expr.id, &fn_sig, decl, expr.id, &body);\n+                                               self.parameter_environment.free_substs,\n+                                               upvar_tys);\n+\n+        let fn_sig = self.tcx\n+            .liberate_late_bound_regions(self.tcx.region_maps.call_site_extent(expr.id, body.id),\n+                                         &fn_ty.sig);\n+        let fn_sig = (**self).normalize_associated_types_in(body.span, body.id, &fn_sig);\n+\n+        check_fn(self,\n+                 hir::Unsafety::Normal,\n+                 expr.id,\n+                 &fn_sig,\n+                 decl,\n+                 expr.id,\n+                 &body);\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `closures` table.\n@@ -88,46 +97,47 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         self.tables.borrow_mut().closure_tys.insert(expr_def_id, fn_ty);\n         match opt_kind {\n-            Some(kind) => { self.tables.borrow_mut().closure_kinds.insert(expr_def_id, kind); }\n-            None => { }\n+            Some(kind) => {\n+                self.tables.borrow_mut().closure_kinds.insert(expr_def_id, kind);\n+            }\n+            None => {}\n         }\n \n         closure_type\n     }\n \n-    fn deduce_expectations_from_expected_type(&self, expected_ty: Ty<'tcx>)\n-        -> (Option<ty::FnSig<'tcx>>,Option<ty::ClosureKind>)\n-    {\n+    fn deduce_expectations_from_expected_type\n+        (&self,\n+         expected_ty: Ty<'tcx>)\n+         -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n         debug!(\"deduce_expectations_from_expected_type(expected_ty={:?})\",\n                expected_ty);\n \n         match expected_ty.sty {\n             ty::TyTrait(ref object_type) => {\n-                let sig = object_type.projection_bounds.iter().filter_map(|pb| {\n-                    let pb = pb.with_self_ty(self.tcx, self.tcx.types.err);\n-                    self.deduce_sig_from_projection(&pb)\n-                }).next();\n+                let sig = object_type.projection_bounds\n+                    .iter()\n+                    .filter_map(|pb| {\n+                        let pb = pb.with_self_ty(self.tcx, self.tcx.types.err);\n+                        self.deduce_sig_from_projection(&pb)\n+                    })\n+                    .next();\n                 let kind = self.tcx.lang_items.fn_trait_kind(object_type.principal.def_id());\n                 (sig, kind)\n             }\n-            ty::TyInfer(ty::TyVar(vid)) => {\n-                self.deduce_expectations_from_obligations(vid)\n-            }\n-            _ => {\n-                (None, None)\n-            }\n+            ty::TyInfer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n+            _ => (None, None),\n         }\n     }\n \n-    fn deduce_expectations_from_obligations(&self, expected_vid: ty::TyVid)\n-        -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>)\n-    {\n+    fn deduce_expectations_from_obligations\n+        (&self,\n+         expected_vid: ty::TyVid)\n+         -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n         let fulfillment_cx = self.fulfillment_cx.borrow();\n         // Here `expected_ty` is known to be a type inference variable.\n \n-        let expected_sig =\n-            fulfillment_cx\n-            .pending_obligations()\n+        let expected_sig = fulfillment_cx.pending_obligations()\n             .iter()\n             .map(|obligation| &obligation.obligation)\n             .filter_map(|obligation| {\n@@ -142,9 +152,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.self_type_matches_expected_vid(trait_ref, expected_vid)\n                             .and_then(|_| self.deduce_sig_from_projection(proj_predicate))\n                     }\n-                    _ => {\n-                        None\n-                    }\n+                    _ => None,\n                 }\n             })\n             .next();\n@@ -153,9 +161,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // infer the kind. This can occur if there is a trait-reference\n         // like `F : Fn<A>`. Note that due to subtyping we could encounter\n         // many viable options, so pick the most restrictive.\n-        let expected_kind =\n-            fulfillment_cx\n-            .pending_obligations()\n+        let expected_kind = fulfillment_cx.pending_obligations()\n             .iter()\n             .map(|obligation| &obligation.obligation)\n             .filter_map(|obligation| {\n@@ -178,25 +184,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // inference variable.\n                     ty::Predicate::ClosureKind(..) => None,\n                 };\n-                opt_trait_ref\n-                    .and_then(|tr| self.self_type_matches_expected_vid(tr, expected_vid))\n+                opt_trait_ref.and_then(|tr| self.self_type_matches_expected_vid(tr, expected_vid))\n                     .and_then(|tr| self.tcx.lang_items.fn_trait_kind(tr.def_id()))\n             })\n-            .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n+            .fold(None,\n+                  |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n \n         (expected_sig, expected_kind)\n     }\n \n     /// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n     /// everything we need to know about a closure.\n     fn deduce_sig_from_projection(&self,\n-        projection: &ty::PolyProjectionPredicate<'tcx>)\n-        -> Option<ty::FnSig<'tcx>>\n-    {\n+                                  projection: &ty::PolyProjectionPredicate<'tcx>)\n+                                  -> Option<ty::FnSig<'tcx>> {\n         let tcx = self.tcx;\n \n-        debug!(\"deduce_sig_from_projection({:?})\",\n-               projection);\n+        debug!(\"deduce_sig_from_projection({:?})\", projection);\n \n         let trait_ref = projection.to_poly_trait_ref();\n \n@@ -206,33 +210,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let arg_param_ty = trait_ref.substs().type_at(1);\n         let arg_param_ty = self.resolve_type_vars_if_possible(&arg_param_ty);\n-        debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\", arg_param_ty);\n+        debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\",\n+               arg_param_ty);\n \n         let input_tys = match arg_param_ty.sty {\n             ty::TyTuple(tys) => tys.to_vec(),\n-            _ => { return None; }\n+            _ => {\n+                return None;\n+            }\n         };\n         debug!(\"deduce_sig_from_projection: input_tys {:?}\", input_tys);\n \n         let ret_param_ty = projection.0.ty;\n         let ret_param_ty = self.resolve_type_vars_if_possible(&ret_param_ty);\n-        debug!(\"deduce_sig_from_projection: ret_param_ty {:?}\", ret_param_ty);\n+        debug!(\"deduce_sig_from_projection: ret_param_ty {:?}\",\n+               ret_param_ty);\n \n         let fn_sig = ty::FnSig {\n             inputs: input_tys,\n             output: ret_param_ty,\n-            variadic: false\n+            variadic: false,\n         };\n         debug!(\"deduce_sig_from_projection: fn_sig {:?}\", fn_sig);\n \n         Some(fn_sig)\n     }\n \n     fn self_type_matches_expected_vid(&self,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n-        expected_vid: ty::TyVid)\n-        -> Option<ty::PolyTraitRef<'tcx>>\n-    {\n+                                      trait_ref: ty::PolyTraitRef<'tcx>,\n+                                      expected_vid: ty::TyVid)\n+                                      -> Option<ty::PolyTraitRef<'tcx>> {\n         let self_ty = self.shallow_resolve(trait_ref.self_ty());\n         debug!(\"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n                trait_ref,"}, {"sha": "5be77cb12e9efa25fc21a7285ec20cde45658379", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 99, "deletions": 110, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec", "patch": "@@ -60,7 +60,7 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use check::{FnCtxt};\n+use check::FnCtxt;\n \n use rustc::hir;\n use rustc::infer::{Coercion, InferOk, TypeOrigin, TypeTrace};\n@@ -79,7 +79,7 @@ use std::cell::RefCell;\n use std::collections::VecDeque;\n use std::ops::Deref;\n \n-struct Coerce<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct Coerce<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     origin: TypeOrigin,\n     use_lub: bool,\n@@ -102,7 +102,7 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n         (hir::MutMutable, hir::MutMutable) |\n         (hir::MutImmutable, hir::MutImmutable) |\n         (hir::MutMutable, hir::MutImmutable) => Ok(()),\n-        (hir::MutImmutable, hir::MutMutable) => Err(TypeError::Mutability)\n+        (hir::MutImmutable, hir::MutMutable) => Err(TypeError::Mutability),\n     }\n }\n \n@@ -112,7 +112,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             fcx: fcx,\n             origin: origin,\n             use_lub: false,\n-            unsizing_obligations: RefCell::new(vec![])\n+            unsizing_obligations: RefCell::new(vec![]),\n         }\n     }\n \n@@ -144,21 +144,18 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n     /// Synthesize an identity adjustment.\n     fn identity(&self, ty: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        Ok((ty, AdjustDerefRef(AutoDerefRef {\n-            autoderefs: 0,\n-            autoref: None,\n-            unsize: None\n-        })))\n+        Ok((ty,\n+            AdjustDerefRef(AutoDerefRef {\n+                autoderefs: 0,\n+                autoref: None,\n+                unsize: None,\n+            })))\n     }\n \n-    fn coerce<'a, E, I>(&self,\n-                        exprs: &E,\n-                        a: Ty<'tcx>,\n-                        b: Ty<'tcx>)\n-                        -> CoerceResult<'tcx>\n-        // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n+    fn coerce<'a, E, I>(&self, exprs: &E, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx>\n         where E: Fn() -> I,\n-              I: IntoIterator<Item=&'a hir::Expr> {\n+              I: IntoIterator<Item = &'a hir::Expr>\n+    {\n \n         let a = self.shallow_resolve(a);\n         debug!(\"Coerce.tys({:?} => {:?})\", a, b);\n@@ -223,9 +220,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                          r_b: &'tcx ty::Region,\n                                          mt_b: TypeAndMut<'tcx>)\n                                          -> CoerceResult<'tcx>\n-        // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n         where E: Fn() -> I,\n-              I: IntoIterator<Item=&'a hir::Expr>\n+              I: IntoIterator<Item = &'a hir::Expr>\n     {\n \n         debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\", a, b);\n@@ -241,7 +237,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n                 (r_a, mt_a)\n             }\n-            _ => return self.unify_and_identity(a, b)\n+            _ => return self.unify_and_identity(a, b),\n         };\n \n         let span = self.origin.span();\n@@ -255,7 +251,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             if autoderefs == 0 {\n                 // Don't let this pass, otherwise it would cause\n                 // &T to autoref to &&T.\n-                continue\n+                continue;\n             }\n \n             // At this point, we have deref'd `a` to `referent_ty`.  So\n@@ -333,19 +329,24 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             } else if autoderefs == 1 {\n                 r_a // [3] above\n             } else {\n-                if r_borrow_var.is_none() { // create var lazilly, at most once\n+                if r_borrow_var.is_none() {\n+                    // create var lazilly, at most once\n                     let coercion = Coercion(span);\n                     let r = self.next_region_var(coercion);\n                     r_borrow_var = Some(r); // [4] above\n                 }\n                 r_borrow_var.unwrap()\n             };\n-            let derefd_ty_a = self.tcx.mk_ref(r, TypeAndMut {\n-                ty: referent_ty,\n-                mutbl: mt_b.mutbl // [1] above\n-            });\n+            let derefd_ty_a = self.tcx.mk_ref(r,\n+                                              TypeAndMut {\n+                                                  ty: referent_ty,\n+                                                  mutbl: mt_b.mutbl, // [1] above\n+                                              });\n             match self.unify(derefd_ty_a, b) {\n-                Ok(ty) => { success = Some((ty, autoderefs)); break },\n+                Ok(ty) => {\n+                    success = Some((ty, autoderefs));\n+                    break;\n+                }\n                 Err(err) => {\n                     if first_error.is_none() {\n                         first_error = Some(err);\n@@ -391,29 +392,27 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         }\n         let r_borrow = match ty.sty {\n             ty::TyRef(r_borrow, _) => r_borrow,\n-            _ => span_bug!(span, \"expected a ref type, got {:?}\", ty)\n+            _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n         let autoref = Some(AutoPtr(r_borrow, mt_b.mutbl));\n         debug!(\"coerce_borrowed_pointer: succeeded ty={:?} autoderefs={:?} autoref={:?}\",\n-               ty, autoderefs, autoref);\n-        Ok((ty, AdjustDerefRef(AutoDerefRef {\n-            autoderefs: autoderefs,\n-            autoref: autoref,\n-            unsize: None\n-        })))\n+               ty,\n+               autoderefs,\n+               autoref);\n+        Ok((ty,\n+            AdjustDerefRef(AutoDerefRef {\n+                autoderefs: autoderefs,\n+                autoref: autoref,\n+                unsize: None,\n+            })))\n     }\n \n \n     // &[T; n] or &mut [T; n] -> &[T]\n     // or &mut [T; n] -> &mut [T]\n     // or &Concrete -> &Trait, etc.\n-    fn coerce_unsized(&self,\n-                      source: Ty<'tcx>,\n-                      target: Ty<'tcx>)\n-                      -> CoerceResult<'tcx> {\n-        debug!(\"coerce_unsized(source={:?}, target={:?})\",\n-               source,\n-               target);\n+    fn coerce_unsized(&self, source: Ty<'tcx>, target: Ty<'tcx>) -> CoerceResult<'tcx> {\n+        debug!(\"coerce_unsized(source={:?}, target={:?})\", source, target);\n \n         let traits = (self.tcx.lang_items.unsize_trait(),\n                       self.tcx.lang_items.coerce_unsized_trait());\n@@ -442,7 +441,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n                 (mt_a.ty, Some(AutoUnsafe(mt_b.mutbl)))\n             }\n-            _ => (source, None)\n+            _ => (source, None),\n         };\n         let source = source.adjust_for_autoref(self.tcx, reborrow);\n \n@@ -454,30 +453,26 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         // Create an obligation for `Source: CoerceUnsized<Target>`.\n         let cause = ObligationCause::misc(self.origin.span(), self.body_id);\n-        queue.push_back(self.tcx.predicate_for_trait_def(cause,\n-                                                         coerce_unsized_did,\n-                                                         0,\n-                                                         source,\n-                                                         &[target]));\n+        queue.push_back(self.tcx\n+            .predicate_for_trait_def(cause, coerce_unsized_did, 0, source, &[target]));\n \n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n         // inference might unify those two inner type variables later.\n         let traits = [coerce_unsized_did, unsize_did];\n         while let Some(obligation) = queue.pop_front() {\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n-            let trait_ref =  match obligation.predicate {\n-                ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n-                    tr.clone()\n-                }\n+            let trait_ref = match obligation.predicate {\n+                ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => tr.clone(),\n                 _ => {\n                     leftover_predicates.push(obligation);\n                     continue;\n                 }\n             };\n             match selcx.select(&obligation.with(trait_ref)) {\n                 // Uncertain or unimplemented.\n-                Ok(None) | Err(traits::Unimplemented) => {\n+                Ok(None) |\n+                Err(traits::Unimplemented) => {\n                     debug!(\"coerce_unsized: early return - can't prove obligation\");\n                     return Err(TypeError::Mismatch);\n                 }\n@@ -503,22 +498,20 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         let adjustment = AutoDerefRef {\n             autoderefs: if reborrow.is_some() { 1 } else { 0 },\n             autoref: reborrow,\n-            unsize: Some(target)\n+            unsize: Some(target),\n         };\n         debug!(\"Success, coerced with {:?}\", adjustment);\n         Ok((target, AdjustDerefRef(adjustment)))\n     }\n \n     fn coerce_from_fn_pointer(&self,\n-                           a: Ty<'tcx>,\n-                           fn_ty_a: &'tcx ty::BareFnTy<'tcx>,\n-                           b: Ty<'tcx>)\n-                           -> CoerceResult<'tcx>\n-    {\n-        /*!\n-         * Attempts to coerce from the type of a Rust function item\n-         * into a closure or a `proc`.\n-         */\n+                              a: Ty<'tcx>,\n+                              fn_ty_a: &'tcx ty::BareFnTy<'tcx>,\n+                              b: Ty<'tcx>)\n+                              -> CoerceResult<'tcx> {\n+        //! Attempts to coerce from the type of a Rust function item\n+        //! into a closure or a `proc`.\n+        //!\n \n         let b = self.shallow_resolve(b);\n         debug!(\"coerce_from_fn_pointer(a={:?}, b={:?})\", a, b);\n@@ -527,9 +520,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                     let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n-                    return self.unify_and_identity(unsafe_a, b).map(|(ty, _)| {\n-                        (ty, AdjustUnsafeFnPointer)\n-                    });\n+                    return self.unify_and_identity(unsafe_a, b)\n+                        .map(|(ty, _)| (ty, AdjustUnsafeFnPointer));\n                 }\n                 _ => {}\n             }\n@@ -542,22 +534,19 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                            fn_ty_a: &'tcx ty::BareFnTy<'tcx>,\n                            b: Ty<'tcx>)\n                            -> CoerceResult<'tcx> {\n-        /*!\n-         * Attempts to coerce from the type of a Rust function item\n-         * into a closure or a `proc`.\n-         */\n+        //! Attempts to coerce from the type of a Rust function item\n+        //! into a closure or a `proc`.\n+        //!\n \n         let b = self.shallow_resolve(b);\n         debug!(\"coerce_from_fn_item(a={:?}, b={:?})\", a, b);\n \n         match b.sty {\n             ty::TyFnPtr(_) => {\n                 let a_fn_pointer = self.tcx.mk_fn_ptr(fn_ty_a);\n-                self.unify_and_identity(a_fn_pointer, b).map(|(ty, _)| {\n-                    (ty, AdjustReifyFnPointer)\n-                })\n+                self.unify_and_identity(a_fn_pointer, b).map(|(ty, _)| (ty, AdjustReifyFnPointer))\n             }\n-            _ => self.unify_and_identity(a, b)\n+            _ => self.unify_and_identity(a, b),\n         }\n     }\n \n@@ -566,9 +555,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                          b: Ty<'tcx>,\n                          mutbl_b: hir::Mutability)\n                          -> CoerceResult<'tcx> {\n-        debug!(\"coerce_unsafe_ptr(a={:?}, b={:?})\",\n-               a,\n-               b);\n+        debug!(\"coerce_unsafe_ptr(a={:?}, b={:?})\", a, b);\n \n         let (is_ref, mt_a) = match a.sty {\n             ty::TyRef(_, mt) => (true, mt),\n@@ -579,24 +566,28 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         };\n \n         // Check that the types which they point at are compatible.\n-        let a_unsafe = self.tcx.mk_ptr(ty::TypeAndMut{ mutbl: mutbl_b, ty: mt_a.ty });\n+        let a_unsafe = self.tcx.mk_ptr(ty::TypeAndMut {\n+            mutbl: mutbl_b,\n+            ty: mt_a.ty,\n+        });\n         let (ty, noop) = self.unify_and_identity(a_unsafe, b)?;\n         coerce_mutbls(mt_a.mutbl, mutbl_b)?;\n \n         // Although references and unsafe ptrs have the same\n         // representation, we still register an AutoDerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n-        Ok((ty, if is_ref {\n-            AdjustDerefRef(AutoDerefRef {\n-                autoderefs: 1,\n-                autoref: Some(AutoUnsafe(mutbl_b)),\n-                unsize: None\n-            })\n-        } else if mt_a.mutbl != mutbl_b {\n-            AdjustMutToConstPointer\n-        } else {\n-            noop\n-        }))\n+        Ok((ty,\n+            if is_ref {\n+                AdjustDerefRef(AutoDerefRef {\n+                    autoderefs: 1,\n+                    autoref: Some(AutoUnsafe(mutbl_b)),\n+                    unsize: None,\n+                })\n+            } else if mt_a.mutbl != mutbl_b {\n+                AdjustMutToConstPointer\n+            } else {\n+                noop\n+            }))\n     }\n }\n \n@@ -606,7 +597,8 @@ fn apply<'a, 'b, 'gcx, 'tcx, E, I>(coerce: &mut Coerce<'a, 'gcx, 'tcx>,\n                                    b: Ty<'tcx>)\n                                    -> CoerceResult<'tcx>\n     where E: Fn() -> I,\n-          I: IntoIterator<Item=&'b hir::Expr> {\n+          I: IntoIterator<Item = &'b hir::Expr>\n+{\n \n     let (ty, adjustment) = indent(|| coerce.coerce(exprs, a, b))?;\n \n@@ -638,12 +630,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mut coerce = Coerce::new(self, TypeOrigin::ExprAssignable(expr.span));\n         self.commit_if_ok(|_| {\n-            let (ty, adjustment) =\n-                apply(&mut coerce, &|| Some(expr), source, target)?;\n+            let (ty, adjustment) = apply(&mut coerce, &|| Some(expr), source, target)?;\n             if !adjustment.is_identity() {\n                 debug!(\"Success, coerced with {:?}\", adjustment);\n                 match self.tables.borrow().adjustments.get(&expr.id) {\n-                    None | Some(&AdjustNeverToAny(..)) => (),\n+                    None |\n+                    Some(&AdjustNeverToAny(..)) => (),\n                     _ => bug!(\"expr already has an adjustment on it!\"),\n                 };\n                 self.write_adjustment(expr.id, adjustment);\n@@ -662,9 +654,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                            new: &'b hir::Expr,\n                                            new_ty: Ty<'tcx>)\n                                            -> RelateResult<'tcx, Ty<'tcx>>\n-        // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n         where E: Fn() -> I,\n-              I: IntoIterator<Item=&'b hir::Expr> {\n+              I: IntoIterator<Item = &'b hir::Expr>\n+    {\n \n         let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n         let new_ty = self.resolve_type_vars_with_obligations(new_ty);\n@@ -675,8 +667,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Special-case that coercion alone cannot handle:\n         // Two function item types of differing IDs or Substs.\n         match (&prev_ty.sty, &new_ty.sty) {\n-            (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n-             &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n+            (&ty::TyFnDef(a_def_id, a_substs, a_fty), &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n                 // The signature must always match.\n                 let fty = self.lub(true, trace.clone(), &a_fty, &b_fty)\n                     .map(|InferOk { value, obligations }| {\n@@ -720,17 +711,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // but only if the new expression has no coercion already applied to it.\n         let mut first_error = None;\n         if !self.tables.borrow().adjustments.contains_key(&new.id) {\n-            let result = self.commit_if_ok(|_| {\n-                apply(&mut coerce, &|| Some(new), new_ty, prev_ty)\n-            });\n+            let result = self.commit_if_ok(|_| apply(&mut coerce, &|| Some(new), new_ty, prev_ty));\n             match result {\n                 Ok((ty, adjustment)) => {\n                     if !adjustment.is_identity() {\n                         self.write_adjustment(new.id, adjustment);\n                     }\n                     return Ok(ty);\n                 }\n-                Err(e) => first_error = Some(e)\n+                Err(e) => first_error = Some(e),\n             }\n         }\n \n@@ -739,20 +728,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // previous expressions, other than noop reborrows (ignoring lifetimes).\n         for expr in exprs() {\n             let noop = match self.tables.borrow().adjustments.get(&expr.id) {\n-                Some(&AdjustDerefRef(AutoDerefRef {\n-                    autoderefs: 1,\n-                    autoref: Some(AutoPtr(_, mutbl_adj)),\n-                    unsize: None\n-                })) => match self.node_ty(expr.id).sty {\n-                    ty::TyRef(_, mt_orig) => {\n-                        // Reborrow that we can safely ignore.\n-                        mutbl_adj == mt_orig.mutbl\n+                Some(&AdjustDerefRef(AutoDerefRef { autoderefs: 1,\n+                                                    autoref: Some(AutoPtr(_, mutbl_adj)),\n+                                                    unsize: None })) => {\n+                    match self.node_ty(expr.id).sty {\n+                        ty::TyRef(_, mt_orig) => {\n+                            // Reborrow that we can safely ignore.\n+                            mutbl_adj == mt_orig.mutbl\n+                        }\n+                        _ => false,\n                     }\n-                    _ => false\n-                },\n+                }\n                 Some(&AdjustNeverToAny(_)) => true,\n                 Some(_) => false,\n-                None => true\n+                None => true,\n             };\n \n             if !noop {"}, {"sha": "25e9f1f522c96499bf8906092b3a2a6f81b0833e", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 211, "deletions": 197, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=4ef3f591881a1713d8c7bd6a21c16f67ab2ad2ec", "patch": "@@ -40,8 +40,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      trait_m: &ty::Method<'tcx>,\n                                      impl_trait_ref: &ty::TraitRef<'tcx>,\n                                      trait_item_span: Option<Span>) {\n-    debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n-           impl_trait_ref);\n+    debug!(\"compare_impl_method(impl_trait_ref={:?})\", impl_trait_ref);\n \n     debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n            impl_trait_ref);\n@@ -58,34 +57,36 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     // inscrutable, particularly for cases where one method has no\n     // self.\n     match (&trait_m.explicit_self, &impl_m.explicit_self) {\n-        (&ty::ExplicitSelfCategory::Static,\n-         &ty::ExplicitSelfCategory::Static) => {}\n+        (&ty::ExplicitSelfCategory::Static, &ty::ExplicitSelfCategory::Static) => {}\n         (&ty::ExplicitSelfCategory::Static, _) => {\n-            let mut err = struct_span_err!(tcx.sess, impl_m_span, E0185,\n-                \"method `{}` has a `{}` declaration in the impl, \\\n-                        but not in the trait\",\n-                        trait_m.name,\n-                        impl_m.explicit_self);\n-            err.span_label(impl_m_span, &format!(\"`{}` used in impl\",\n-                                                 impl_m.explicit_self));\n+            let mut err = struct_span_err!(tcx.sess,\n+                                           impl_m_span,\n+                                           E0185,\n+                                           \"method `{}` has a `{}` declaration in the impl, but \\\n+                                            not in the trait\",\n+                                           trait_m.name,\n+                                           impl_m.explicit_self);\n+            err.span_label(impl_m_span,\n+                           &format!(\"`{}` used in impl\", impl_m.explicit_self));\n             if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n-                err.span_label(span, &format!(\"trait declared without `{}`\",\n-                                              impl_m.explicit_self));\n+                err.span_label(span,\n+                               &format!(\"trait declared without `{}`\", impl_m.explicit_self));\n             }\n             err.emit();\n             return;\n         }\n         (_, &ty::ExplicitSelfCategory::Static) => {\n-            let mut err = struct_span_err!(tcx.sess, impl_m_span, E0186,\n-                \"method `{}` has a `{}` declaration in the trait, \\\n-                        but not in the impl\",\n-                        trait_m.name,\n-                        trait_m.explicit_self);\n-            err.span_label(impl_m_span, &format!(\"expected `{}` in impl\",\n-                                                  trait_m.explicit_self));\n+            let mut err = struct_span_err!(tcx.sess,\n+                                           impl_m_span,\n+                                           E0186,\n+                                           \"method `{}` has a `{}` declaration in the trait, but \\\n+                                            not in the impl\",\n+                                           trait_m.name,\n+                                           trait_m.explicit_self);\n+            err.span_label(impl_m_span,\n+                           &format!(\"expected `{}` in impl\", trait_m.explicit_self));\n             if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n-                err.span_label(span, & format!(\"`{}` used in trait\",\n-                                               trait_m.explicit_self));\n+                err.span_label(span, &format!(\"`{}` used in trait\", trait_m.explicit_self));\n             }\n             err.emit();\n             return;\n@@ -107,17 +108,23 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     impl_m_span\n                 }\n             }\n-            _ => bug!(\"{:?} is not a method\", impl_m)\n+            _ => bug!(\"{:?} is not a method\", impl_m),\n         };\n \n-        let mut err = struct_span_err!(tcx.sess, span, E0049,\n-            \"method `{}` has {} type parameter{} \\\n-             but its trait declaration has {} type parameter{}\",\n-            trait_m.name,\n-            num_impl_m_type_params,\n-            if num_impl_m_type_params == 1 {\"\"} else {\"s\"},\n-            num_trait_m_type_params,\n-            if num_trait_m_type_params == 1 {\"\"} else {\"s\"});\n+        let mut err = struct_span_err!(tcx.sess,\n+                                       span,\n+                                       E0049,\n+                                       \"method `{}` has {} type parameter{} but its trait \\\n+                                        declaration has {} type parameter{}\",\n+                                       trait_m.name,\n+                                       num_impl_m_type_params,\n+                                       if num_impl_m_type_params == 1 { \"\" } else { \"s\" },\n+                                       num_trait_m_type_params,\n+                                       if num_trait_m_type_params == 1 {\n+                                           \"\"\n+                                       } else {\n+                                           \"s\"\n+                                       });\n \n         let mut suffix = None;\n \n@@ -154,46 +161,46 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let trait_span = if let Some(trait_id) = trait_m_node_id {\n             match tcx.map.expect_trait_item(trait_id).node {\n                 TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n-                    if let Some(arg) = trait_m_sig.decl.inputs.get(\n-                        if trait_number_args > 0 {\n-                            trait_number_args - 1\n-                        } else {\n-                            0\n-                        }) {\n+                    if let Some(arg) = trait_m_sig.decl.inputs.get(if trait_number_args > 0 {\n+                        trait_number_args - 1\n+                    } else {\n+                        0\n+                    }) {\n                         Some(arg.pat.span)\n                     } else {\n                         trait_item_span\n                     }\n                 }\n-                _ => bug!(\"{:?} is not a method\", impl_m)\n+                _ => bug!(\"{:?} is not a method\", impl_m),\n             }\n         } else {\n             trait_item_span\n         };\n         let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n         let impl_span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n             ImplItemKind::Method(ref impl_m_sig, _) => {\n-                if let Some(arg) = impl_m_sig.decl.inputs.get(\n-                    if impl_number_args > 0 {\n-                        impl_number_args - 1\n-                    } else {\n-                        0\n-                    }) {\n+                if let Some(arg) = impl_m_sig.decl.inputs.get(if impl_number_args > 0 {\n+                    impl_number_args - 1\n+                } else {\n+                    0\n+                }) {\n                     arg.pat.span\n                 } else {\n                     impl_m_span\n                 }\n             }\n-            _ => bug!(\"{:?} is not a method\", impl_m)\n+            _ => bug!(\"{:?} is not a method\", impl_m),\n         };\n-        let mut err = struct_span_err!(tcx.sess, impl_span, E0050,\n-            \"method `{}` has {} parameter{} \\\n-             but the declaration in trait `{}` has {}\",\n-            trait_m.name,\n-            impl_number_args,\n-            if impl_number_args == 1 {\"\"} else {\"s\"},\n-            tcx.item_path_str(trait_m.def_id),\n-            trait_number_args);\n+        let mut err = struct_span_err!(tcx.sess,\n+                                       impl_span,\n+                                       E0050,\n+                                       \"method `{}` has {} parameter{} but the declaration in \\\n+                                        trait `{}` has {}\",\n+                                       trait_m.name,\n+                                       impl_number_args,\n+                                       if impl_number_args == 1 { \"\" } else { \"s\" },\n+                                       tcx.item_path_str(trait_m.def_id),\n+                                       trait_number_args);\n         if let Some(trait_span) = trait_span {\n             err.span_label(trait_span,\n                            &format!(\"trait requires {}\",\n@@ -210,7 +217,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 } else {\n                                     format!(\"{} parameter\", trait_number_args)\n                                 },\n-                       impl_number_args));\n+                                impl_number_args));\n         err.emit();\n         return;\n     }\n@@ -287,9 +294,10 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let impl_to_skol_substs = &impl_param_env.free_substs;\n \n     // Create mapping from trait to skolemized.\n-    let trait_to_skol_substs =\n-        impl_to_skol_substs.rebase_onto(tcx, impl_m.container_id(),\n-                                        trait_to_impl_substs.subst(tcx, impl_to_skol_substs));\n+    let trait_to_skol_substs = impl_to_skol_substs.rebase_onto(tcx,\n+                                                               impl_m.container_id(),\n+                                                               trait_to_impl_substs.subst(tcx,\n+                                                                          impl_to_skol_substs));\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n \n@@ -325,39 +333,36 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         //\n         // We then register the obligations from the impl_m and check to see\n         // if all constraints hold.\n-        hybrid_preds.predicates.extend(\n-            trait_m.predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n+        hybrid_preds.predicates\n+            .extend(trait_m.predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n \n         // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n         // The key step here is to update the caller_bounds's predicates to be\n         // the new hybrid bounds we computed.\n         let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n         let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.predicates);\n-        let trait_param_env = traits::normalize_param_env_or_error(tcx,\n-                                                                   trait_param_env,\n-                                                                   normalize_cause.clone());\n+        let trait_param_env =\n+            traits::normalize_param_env_or_error(tcx, trait_param_env, normalize_cause.clone());\n         // FIXME(@jroesch) this seems ugly, but is a temporary change\n         infcx.parameter_environment = trait_param_env;\n \n         debug!(\"compare_impl_method: caller_bounds={:?}\",\n-            infcx.parameter_environment.caller_bounds);\n+               infcx.parameter_environment.caller_bounds);\n \n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n         let impl_m_own_bounds = impl_m.predicates.instantiate_own(tcx, impl_to_skol_substs);\n-        let (impl_m_own_bounds, _) =\n-            infcx.replace_late_bound_regions_with_fresh_var(\n-                impl_m_span,\n-                infer::HigherRankedType,\n-                &ty::Binder(impl_m_own_bounds.predicates));\n+        let (impl_m_own_bounds, _) = infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n+                                                       infer::HigherRankedType,\n+                                                       &ty::Binder(impl_m_own_bounds.predicates));\n         for predicate in impl_m_own_bounds {\n             let traits::Normalized { value: predicate, .. } =\n                 traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);\n \n             let cause = traits::ObligationCause {\n                 span: impl_m_span,\n                 body_id: impl_m_body_id,\n-                code: traits::ObligationCauseCode::CompareImplMethodObligation\n+                code: traits::ObligationCauseCode::CompareImplMethodObligation,\n             };\n \n             fulfillment_cx.register_predicate_obligation(\n@@ -382,40 +387,34 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let tcx = infcx.tcx;\n         let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n \n-        let (impl_sig, _) =\n-            infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n-                                                            infer::HigherRankedType,\n-                                                            &impl_m.fty.sig);\n-        let impl_sig =\n-            impl_sig.subst(tcx, impl_to_skol_substs);\n-        let impl_sig =\n-            assoc::normalize_associated_types_in(&infcx,\n-                                                 &mut fulfillment_cx,\n-                                                 impl_m_span,\n-                                                 impl_m_body_id,\n-                                                 &impl_sig);\n+        let (impl_sig, _) = infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n+                                                       infer::HigherRankedType,\n+                                                       &impl_m.fty.sig);\n+        let impl_sig = impl_sig.subst(tcx, impl_to_skol_substs);\n+        let impl_sig = assoc::normalize_associated_types_in(&infcx,\n+                                                            &mut fulfillment_cx,\n+                                                            impl_m_span,\n+                                                            impl_m_body_id,\n+                                                            &impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: impl_m.fty.unsafety,\n             abi: impl_m.fty.abi,\n-            sig: ty::Binder(impl_sig.clone())\n+            sig: ty::Binder(impl_sig.clone()),\n         }));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n-        let trait_sig = tcx.liberate_late_bound_regions(\n-            infcx.parameter_environment.free_id_outlive,\n-            &trait_m.fty.sig);\n-        let trait_sig =\n-            trait_sig.subst(tcx, trait_to_skol_substs);\n-        let trait_sig =\n-            assoc::normalize_associated_types_in(&infcx,\n-                                                 &mut fulfillment_cx,\n-                                                 impl_m_span,\n-                                                 impl_m_body_id,\n-                                                 &trait_sig);\n+        let trait_sig = tcx.liberate_late_bound_regions(infcx.parameter_environment.free_id_outlive,\n+                                         &trait_m.fty.sig);\n+        let trait_sig = trait_sig.subst(tcx, trait_to_skol_substs);\n+        let trait_sig = assoc::normalize_associated_types_in(&infcx,\n+                                                             &mut fulfillment_cx,\n+                                                             impl_m_span,\n+                                                             impl_m_body_id,\n+                                                             &trait_sig);\n         let trait_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: trait_m.fty.unsafety,\n             abi: trait_m.fty.abi,\n-            sig: ty::Binder(trait_sig.clone())\n+            sig: ty::Binder(trait_sig.clone()),\n         }));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n@@ -425,36 +424,39 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                    impl_fty,\n                    trait_fty);\n \n-            let (impl_err_span, trait_err_span) =\n-                extract_spans_for_error_reporting(&infcx, &terr, origin, impl_m,\n-                    impl_sig, trait_m, trait_sig);\n+            let (impl_err_span, trait_err_span) = extract_spans_for_error_reporting(&infcx,\n+                                                                                    &terr,\n+                                                                                    origin,\n+                                                                                    impl_m,\n+                                                                                    impl_sig,\n+                                                                                    trait_m,\n+                                                                                    trait_sig);\n \n             let origin = TypeOrigin::MethodCompatCheck(impl_err_span);\n \n-            let mut diag = struct_span_err!(\n-                tcx.sess, origin.span(), E0053,\n-                \"method `{}` has an incompatible type for trait\", trait_m.name\n-            );\n-\n-            infcx.note_type_err(\n-                &mut diag,\n-                origin,\n-                trait_err_span.map(|sp| (sp, format!(\"type in trait\"))),\n-                Some(infer::ValuePairs::Types(ExpectedFound {\n-                     expected: trait_fty,\n-                     found: impl_fty\n-                })),\n-                &terr\n-            );\n+            let mut diag = struct_span_err!(tcx.sess,\n+                                            origin.span(),\n+                                            E0053,\n+                                            \"method `{}` has an incompatible type for trait\",\n+                                            trait_m.name);\n+\n+            infcx.note_type_err(&mut diag,\n+                                origin,\n+                                trait_err_span.map(|sp| (sp, format!(\"type in trait\"))),\n+                                Some(infer::ValuePairs::Types(ExpectedFound {\n+                                    expected: trait_fty,\n+                                    found: impl_fty,\n+                                })),\n+                                &terr);\n             diag.emit();\n-            return\n+            return;\n         }\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n         if let Err(ref errors) = fulfillment_cx.select_all_or_error(&infcx) {\n             infcx.report_fulfillment_errors(errors);\n-            return\n+            return;\n         }\n \n         // Finally, resolve all regions. This catches wily misuses of\n@@ -480,8 +482,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                     impl_generics: &ty::Generics<'tcx>,\n                                                     trait_to_skol_substs: &Substs<'tcx>,\n                                                     impl_to_skol_substs: &Substs<'tcx>)\n-                                                    -> bool\n-    {\n+                                                    -> bool {\n \n         let trait_params = &trait_generics.regions[..];\n         let impl_params = &impl_generics.regions[..];\n@@ -506,9 +507,12 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // are zero. Since I don't quite know how to phrase things at\n         // the moment, give a kind of vague error message.\n         if trait_params.len() != impl_params.len() {\n-            struct_span_err!(ccx.tcx.sess, span, E0195,\n-                \"lifetime parameters or bounds on method `{}` do \\\n-                 not match the trait declaration\",impl_m.name)\n+            struct_span_err!(ccx.tcx.sess,\n+                             span,\n+                             E0195,\n+                             \"lifetime parameters or bounds on method `{}` do not match the \\\n+                              trait declaration\",\n+                             impl_m.name)\n                 .span_label(span, &format!(\"lifetimes do not match trait\"))\n                 .emit();\n             return false;\n@@ -524,66 +528,80 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                          impl_sig: ty::FnSig<'tcx>,\n                                                          trait_m: &ty::Method,\n                                                          trait_sig: ty::FnSig<'tcx>)\n-                                                        -> (Span, Option<Span>) {\n+                                                         -> (Span, Option<Span>) {\n         let tcx = infcx.tcx;\n         let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n         let (impl_m_output, impl_m_iter) = match tcx.map.expect_impl_item(impl_m_node_id).node {\n-            ImplItemKind::Method(ref impl_m_sig, _) =>\n-                (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter()),\n-            _ => bug!(\"{:?} is not a method\", impl_m)\n+            ImplItemKind::Method(ref impl_m_sig, _) => {\n+                (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n+            }\n+            _ => bug!(\"{:?} is not a method\", impl_m),\n         };\n \n         match *terr {\n             TypeError::Mutability => {\n                 if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n                     let trait_m_iter = match tcx.map.expect_trait_item(trait_m_node_id).node {\n-                        TraitItem_::MethodTraitItem(ref trait_m_sig, _) =>\n-                            trait_m_sig.decl.inputs.iter(),\n-                        _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m)\n+                        TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n+                            trait_m_sig.decl.inputs.iter()\n+                        }\n+                        _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m),\n                     };\n \n-                    impl_m_iter.zip(trait_m_iter).find(|&(ref impl_arg, ref trait_arg)| {\n-                        match (&impl_arg.ty.node, &trait_arg.ty.node) {\n-                            (&Ty_::TyRptr(_, ref impl_mt), &Ty_::TyRptr(_, ref trait_mt)) |\n-                            (&Ty_::TyPtr(ref impl_mt), &Ty_::TyPtr(ref trait_mt)) =>\n-                                impl_mt.mutbl != trait_mt.mutbl,\n-                            _ => false\n-                        }\n-                    }).map(|(ref impl_arg, ref trait_arg)| {\n-                        match (impl_arg.to_self(), trait_arg.to_self()) {\n-                            (Some(impl_self), Some(trait_self)) =>\n-                                (impl_self.span, Some(trait_self.span)),\n-                            (None, None) => (impl_arg.ty.span, Some(trait_arg.ty.span)),\n-                            _ => bug!(\"impl and trait fns have different first args, \\\n-                                       impl: {:?}, trait: {:?}\", impl_arg, trait_arg)\n-                        }\n-                    }).unwrap_or((origin.span(), tcx.map.span_if_local(trait_m.def_id)))\n+                    impl_m_iter.zip(trait_m_iter)\n+                        .find(|&(ref impl_arg, ref trait_arg)| {\n+                            match (&impl_arg.ty.node, &trait_arg.ty.node) {\n+                                (&Ty_::TyRptr(_, ref impl_mt), &Ty_::TyRptr(_, ref trait_mt)) |\n+                                (&Ty_::TyPtr(ref impl_mt), &Ty_::TyPtr(ref trait_mt)) => {\n+                                    impl_mt.mutbl != trait_mt.mutbl\n+                                }\n+                                _ => false,\n+                            }\n+                        })\n+                        .map(|(ref impl_arg, ref trait_arg)| {\n+                            match (impl_arg.to_self(), trait_arg.to_self()) {\n+                                (Some(impl_self), Some(trait_self)) => {\n+                                    (impl_self.span, Some(trait_self.span))\n+                                }\n+                                (None, None) => (impl_arg.ty.span, Some(trait_arg.ty.span)),\n+                                _ => {\n+                                    bug!(\"impl and trait fns have different first args, impl: \\\n+                                          {:?}, trait: {:?}\",\n+                                         impl_arg,\n+                                         trait_arg)\n+                                }\n+                            }\n+                        })\n+                        .unwrap_or((origin.span(), tcx.map.span_if_local(trait_m.def_id)))\n                 } else {\n                     (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n                 }\n             }\n             TypeError::Sorts(ExpectedFound { .. }) => {\n                 if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n                     let (trait_m_output, trait_m_iter) =\n-                    match tcx.map.expect_trait_item(trait_m_node_id).node {\n-                        TraitItem_::MethodTraitItem(ref trait_m_sig, _) =>\n-                            (&trait_m_sig.decl.output, trait_m_sig.decl.inputs.iter()),\n-                        _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m)\n-                    };\n+                        match tcx.map.expect_trait_item(trait_m_node_id).node {\n+                            TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n+                                (&trait_m_sig.decl.output, trait_m_sig.decl.inputs.iter())\n+                            }\n+                            _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m),\n+                        };\n \n                     let impl_iter = impl_sig.inputs.iter();\n                     let trait_iter = trait_sig.inputs.iter();\n-                    impl_iter.zip(trait_iter).zip(impl_m_iter).zip(trait_m_iter)\n+                    impl_iter.zip(trait_iter)\n+                        .zip(impl_m_iter)\n+                        .zip(trait_m_iter)\n                         .filter_map(|(((impl_arg_ty, trait_arg_ty), impl_arg), trait_arg)| {\n                             match infcx.sub_types(true, origin, trait_arg_ty, impl_arg_ty) {\n                                 Ok(_) => None,\n-                                Err(_) => Some((impl_arg.ty.span, Some(trait_arg.ty.span)))\n+                                Err(_) => Some((impl_arg.ty.span, Some(trait_arg.ty.span))),\n                             }\n                         })\n                         .next()\n                         .unwrap_or_else(|| {\n-                            if infcx.sub_types(false, origin, impl_sig.output,\n-                                               trait_sig.output).is_err() {\n+                            if infcx.sub_types(false, origin, impl_sig.output, trait_sig.output)\n+                                .is_err() {\n                                 (impl_m_output.span(), Some(trait_m_output.span()))\n                             } else {\n                                 (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n@@ -593,7 +611,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n                 }\n             }\n-            _ => (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+            _ => (origin.span(), tcx.map.span_if_local(trait_m.def_id)),\n         }\n     }\n }\n@@ -603,8 +621,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     impl_c_span: Span,\n                                     trait_c: &ty::AssociatedConst<'tcx>,\n                                     impl_trait_ref: &ty::TraitRef<'tcx>) {\n-    debug!(\"compare_const_impl(impl_trait_ref={:?})\",\n-           impl_trait_ref);\n+    debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     let tcx = ccx.tcx;\n     tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n@@ -626,11 +643,12 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let impl_to_skol_substs = &impl_param_env.free_substs;\n \n         // Create mapping from trait to skolemized.\n-        let trait_to_skol_substs =\n-            impl_to_skol_substs.rebase_onto(tcx, impl_c.container.id(),\n-                                            trait_to_impl_substs.subst(tcx, impl_to_skol_substs));\n+        let trait_to_skol_substs = impl_to_skol_substs.rebase_onto(tcx,\n+                                                                   impl_c.container.id(),\n+                                                                   trait_to_impl_substs.subst(tcx,\n+                                                                              impl_to_skol_substs));\n         debug!(\"compare_const_impl: trait_to_skol_substs={:?}\",\n-            trait_to_skol_substs);\n+               trait_to_skol_substs);\n \n         // Compute skolemized form of impl and trait const tys.\n         let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n@@ -639,31 +657,27 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         let err = infcx.commit_if_ok(|_| {\n             // There is no \"body\" here, so just pass dummy id.\n-            let impl_ty =\n-                assoc::normalize_associated_types_in(&infcx,\n-                                                     &mut fulfillment_cx,\n-                                                     impl_c_span,\n-                                                     ast::CRATE_NODE_ID,\n-                                                     &impl_ty);\n-\n-            debug!(\"compare_const_impl: impl_ty={:?}\",\n-                impl_ty);\n-\n-            let trait_ty =\n-                assoc::normalize_associated_types_in(&infcx,\n-                                                     &mut fulfillment_cx,\n-                                                     impl_c_span,\n-                                                     ast::CRATE_NODE_ID,\n-                                                     &trait_ty);\n-\n-            debug!(\"compare_const_impl: trait_ty={:?}\",\n-                trait_ty);\n+            let impl_ty = assoc::normalize_associated_types_in(&infcx,\n+                                                               &mut fulfillment_cx,\n+                                                               impl_c_span,\n+                                                               ast::CRATE_NODE_ID,\n+                                                               &impl_ty);\n+\n+            debug!(\"compare_const_impl: impl_ty={:?}\", impl_ty);\n+\n+            let trait_ty = assoc::normalize_associated_types_in(&infcx,\n+                                                                &mut fulfillment_cx,\n+                                                                impl_c_span,\n+                                                                ast::CRATE_NODE_ID,\n+                                                                &trait_ty);\n+\n+            debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n             infcx.sub_types(false, origin, impl_ty, trait_ty)\n-                 .map(|InferOk { obligations, .. }| {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty())\n-            })\n+                .map(|InferOk { obligations, .. }| {\n+                    // FIXME(#32730) propagate obligations\n+                    assert!(obligations.is_empty())\n+                })\n         });\n \n         if let Err(terr) = err {\n@@ -674,31 +688,31 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             // Locate the Span containing just the type of the offending impl\n             match tcx.map.expect_impl_item(impl_c_node_id).node {\n                 ImplItemKind::Const(ref ty, _) => origin = TypeOrigin::Misc(ty.span),\n-                _ => bug!(\"{:?} is not a impl const\", impl_c)\n+                _ => bug!(\"{:?} is not a impl const\", impl_c),\n             }\n \n-            let mut diag = struct_span_err!(\n-                tcx.sess, origin.span(), E0326,\n-                \"implemented const `{}` has an incompatible type for trait\",\n-                trait_c.name\n-            );\n+            let mut diag = struct_span_err!(tcx.sess,\n+                                            origin.span(),\n+                                            E0326,\n+                                            \"implemented const `{}` has an incompatible type for \\\n+                                             trait\",\n+                                            trait_c.name);\n \n             // Add a label to the Span containing just the type of the item\n             let trait_c_node_id = tcx.map.as_local_node_id(trait_c.def_id).unwrap();\n             let trait_c_span = match tcx.map.expect_trait_item(trait_c_node_id).node {\n                 TraitItem_::ConstTraitItem(ref ty, _) => ty.span,\n-                _ => bug!(\"{:?} is not a trait const\", trait_c)\n+                _ => bug!(\"{:?} is not a trait const\", trait_c),\n             };\n \n-            infcx.note_type_err(\n-                &mut diag,\n-                origin,\n-                Some((trait_c_span, format!(\"type in trait\"))),\n-                Some(infer::ValuePairs::Types(ExpectedFound {\n-                    expected: trait_ty,\n-                    found: impl_ty\n-                })), &terr\n-            );\n+            infcx.note_type_err(&mut diag,\n+                                origin,\n+                                Some((trait_c_span, format!(\"type in trait\"))),\n+                                Some(infer::ValuePairs::Types(ExpectedFound {\n+                                    expected: trait_ty,\n+                                    found: impl_ty,\n+                                })),\n+                                &terr);\n             diag.emit();\n         }\n     });"}]}