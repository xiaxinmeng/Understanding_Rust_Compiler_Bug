{"sha": "ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71", "node_id": "C_kwDOAAsO6NoAKGVhNTQxYmMyZWUwMGM5NTVlM2Y3ZWIzZGRkNWMzYWI4MDE0NmFiNzE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-27T11:46:08Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-02-06T10:46:37Z"}, "message": "make &mut !Unpin not dereferenceable\n\nSee https://github.com/rust-lang/unsafe-code-guidelines/issues/381 for discussion.", "tree": {"sha": "90de52aa5460cb560bdc7ff4400f1c19b36db07f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90de52aa5460cb560bdc7ff4400f1c19b36db07f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71", "html_url": "https://github.com/rust-lang/rust/commit/ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "201ae7387245caa4591d4c8db4c35c170c64faf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/201ae7387245caa4591d4c8db4c35c170c64faf0", "html_url": "https://github.com/rust-lang/rust/commit/201ae7387245caa4591d4c8db4c35c170c64faf0"}], "stats": {"total": 115, "additions": 48, "deletions": 67}, "files": [{"sha": "4ee3202292afd91e0b6903195d3a9955a0887548", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71", "patch": "@@ -256,13 +256,16 @@ fn adjust_for_rust_scalar<'tcx>(\n \n             // `Box` are not necessarily dereferenceable for the entire duration of the function as\n             // they can be deallocated at any time. Same for non-frozen shared references (see\n-            // <https://github.com/rust-lang/rust/pull/98017>). If LLVM had a way to say\n-            // \"dereferenceable on entry\" we could use it here.\n+            // <https://github.com/rust-lang/rust/pull/98017>), and for mutable references to\n+            // potentially self-referential types (see\n+            // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>). If LLVM had a way\n+            // to say \"dereferenceable on entry\" we could use it here.\n             attrs.pointee_size = match kind {\n-                PointerKind::Box | PointerKind::SharedRef { frozen: false } => Size::ZERO,\n-                PointerKind::SharedRef { frozen: true } | PointerKind::MutableRef { .. } => {\n-                    pointee.size\n-                }\n+                PointerKind::Box\n+                | PointerKind::SharedRef { frozen: false }\n+                | PointerKind::MutableRef { unpin: false } => Size::ZERO,\n+                PointerKind::SharedRef { frozen: true }\n+                | PointerKind::MutableRef { unpin: true } => pointee.size,\n             };\n \n             // The aliasing rules for `Box<T>` are still not decided, but currently we emit"}, {"sha": "3b3a41c2f03736a917c6877290d0d657f6d8623b", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71", "patch": "@@ -81,21 +81,18 @@ impl NewPermission {\n                         protector: None,\n                     }\n                 } else if pointee.is_unpin(*cx.tcx, cx.param_env()) {\n-                    // A regular full mutable reference.\n+                    // A regular full mutable reference. On `FnEntry` this is `noalias` and `dereferenceable`.\n                     NewPermission::Uniform {\n                         perm: Permission::Unique,\n                         access: Some(AccessKind::Write),\n                         protector,\n                     }\n                 } else {\n+                    // `!Unpin` dereferences do not get `noalias` nor `dereferenceable`.\n                     NewPermission::Uniform {\n                         perm: Permission::SharedReadWrite,\n-                        // FIXME: We emit `dereferenceable` for `!Unpin` mutable references, so we\n-                        // should do fake accesses here. But then we run into\n-                        // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>, so for now\n-                        // we don't do that.\n                         access: None,\n-                        protector,\n+                        protector: None,\n                     }\n                 }\n             }\n@@ -109,6 +106,7 @@ impl NewPermission {\n                 }\n             }\n             ty::Ref(_, _pointee, Mutability::Not) => {\n+                // Shared references. If frozen, these get `noalias` and `dereferenceable`; otherwise neither.\n                 NewPermission::FreezeSensitive {\n                     freeze_perm: Permission::SharedReadOnly,\n                     freeze_access: Some(AccessKind::Read),"}, {"sha": "fd67dccd14df6d826b0767b726fd31f827d37f3d", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/201ae7387245caa4591d4c8db4c35c170c64faf0/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201ae7387245caa4591d4c8db4c35c170c64faf0/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.rs?ref=201ae7387245caa4591d4c8db4c35c170c64faf0", "patch": "@@ -1,16 +0,0 @@\n-//@error-pattern: /deallocating while item \\[SharedReadWrite for .*\\] is strongly protected/\n-use std::marker::PhantomPinned;\n-\n-pub struct NotUnpin(i32, PhantomPinned);\n-\n-fn inner(x: &mut NotUnpin, f: fn(&mut NotUnpin)) {\n-    // `f` may mutate, but it may not deallocate!\n-    f(x)\n-}\n-\n-fn main() {\n-    inner(Box::leak(Box::new(NotUnpin(0, PhantomPinned))), |x| {\n-        let raw = x as *mut _;\n-        drop(unsafe { Box::from_raw(raw) });\n-    });\n-}"}, {"sha": "47cfa0de7258c1fe0263442c8387a6d7b3d7a7d9", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector2.stderr", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/201ae7387245caa4591d4c8db4c35c170c64faf0/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/201ae7387245caa4591d4c8db4c35c170c64faf0/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector2.stderr?ref=201ae7387245caa4591d4c8db4c35c170c64faf0", "patch": "@@ -1,38 +0,0 @@\n-error: Undefined Behavior: deallocating while item [SharedReadWrite for <TAG>] is strongly protected by call ID\n-  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   |\n-LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item [SharedReadWrite for <TAG>] is strongly protected by call ID\n-   |\n-   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n-   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-   = note: BACKTRACE:\n-   = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `<std::alloc::Global as std::alloc::Allocator>::deallocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `alloc::alloc::box_free::<NotUnpin, std::alloc::Global>` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `std::ptr::drop_in_place::<std::boxed::Box<NotUnpin>> - shim(Some(std::boxed::Box<NotUnpin>))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n-   = note: inside `std::mem::drop::<std::boxed::Box<NotUnpin>>` at RUSTLIB/core/src/mem/mod.rs:LL:CC\n-note: inside closure\n-  --> $DIR/deallocate_against_protector2.rs:LL:CC\n-   |\n-LL |         drop(unsafe { Box::from_raw(raw) });\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: inside `<[closure@$DIR/deallocate_against_protector2.rs:LL:CC] as std::ops::FnOnce<(&mut NotUnpin,)>>::call_once - shim` at RUSTLIB/core/src/ops/function.rs:LL:CC\n-note: inside `inner`\n-  --> $DIR/deallocate_against_protector2.rs:LL:CC\n-   |\n-LL |     f(x)\n-   |     ^^^^\n-note: inside `main`\n-  --> $DIR/deallocate_against_protector2.rs:LL:CC\n-   |\n-LL | /     inner(Box::leak(Box::new(NotUnpin(0, PhantomPinned))), |x| {\n-LL | |         let raw = x as *mut _;\n-LL | |         drop(unsafe { Box::from_raw(raw) });\n-LL | |     });\n-   | |______^\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "8e78efa73c751578c9c3b7849553bb62fcd32e31", "filename": "src/tools/miri/tests/pass/stacked-borrows/stacked-borrows.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs?ref=ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71", "patch": "@@ -19,6 +19,7 @@ fn main() {\n     array_casts();\n     mut_below_shr();\n     wide_raw_ptr_in_tuple();\n+    not_unpin_not_protected();\n }\n \n // Make sure that reading from an `&mut` does, like reborrowing to `&`,\n@@ -219,3 +220,22 @@ fn wide_raw_ptr_in_tuple() {\n     // Make sure the fn ptr part of the vtable is still fine.\n     r.type_id();\n }\n+\n+fn not_unpin_not_protected() {\n+    // `&mut !Unpin`, at least for now, does not get `noalias` nor `dereferenceable`, so we also\n+    // don't add protectors. (We could, but until we have a better idea for where we want to go with\n+    // the self-referntial-generator situation, it does not seem worth the potential trouble.)\n+    use std::marker::PhantomPinned;\n+\n+    pub struct NotUnpin(i32, PhantomPinned);\n+\n+    fn inner(x: &mut NotUnpin, f: fn(&mut NotUnpin)) {\n+        // `f` may mutate, but it may not deallocate!\n+        f(x)\n+    }\n+\n+    inner(Box::leak(Box::new(NotUnpin(0, PhantomPinned))), |x| {\n+        let raw = x as *mut _;\n+        drop(unsafe { Box::from_raw(raw) });\n+    });\n+}"}, {"sha": "0f4639086b885f9e8a15b59aaaf71193ee33ab64", "filename": "tests/codegen/function-arguments.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71/tests%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71/tests%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ffunction-arguments.rs?ref=ea541bc2ee00c955e3f7eb3ddd5c3ab80146ab71", "patch": "@@ -85,6 +85,12 @@ pub fn option_nonzero_int(x: Option<NonZeroU64>) -> Option<NonZeroU64> {\n pub fn readonly_borrow(_: &i32) {\n }\n \n+// CHECK: noundef align 4 dereferenceable(4) {{i32\\*|ptr}} @readonly_borrow_ret()\n+#[no_mangle]\n+pub fn readonly_borrow_ret() -> &'static i32 {\n+  loop {}\n+}\n+\n // CHECK: @static_borrow({{i32\\*|ptr}} noalias noundef readonly align 4 dereferenceable(4) %_1)\n // static borrow may be captured\n #[no_mangle]\n@@ -115,9 +121,17 @@ pub fn mutable_unsafe_borrow(_: &mut UnsafeInner) {\n pub fn mutable_borrow(_: &mut i32) {\n }\n \n+// CHECK: noundef align 4 dereferenceable(4) {{i32\\*|ptr}} @mutable_borrow_ret()\n+#[no_mangle]\n+pub fn mutable_borrow_ret() -> &'static mut i32 {\n+  loop {}\n+}\n+\n #[no_mangle]\n-// CHECK: @mutable_notunpin_borrow({{i32\\*|ptr}} noundef align 4 dereferenceable(4) %_1)\n+// CHECK: @mutable_notunpin_borrow({{i32\\*|ptr}} noundef nonnull align 4 %_1)\n // This one is *not* `noalias` because it might be self-referential.\n+// It is also not `dereferenceable` due to\n+// <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>.\n pub fn mutable_notunpin_borrow(_: &mut NotUnpin) {\n }\n "}]}