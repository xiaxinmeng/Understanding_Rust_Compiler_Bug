{"sha": "c15ad84519193c3b7fd5c364cd46598303df92e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNWFkODQ1MTkxOTNjM2I3ZmQ1YzM2NGNkNDY1OTgzMDNkZjkyZTU=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2019-12-29T20:16:20Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-01-11T10:18:44Z"}, "message": "Fix a memory leak in SEH unwinding if a Rust panic is caught by C++ and discarded", "tree": {"sha": "9e2a831d43c20d0d47c485faeebe6d90277bf0fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e2a831d43c20d0d47c485faeebe6d90277bf0fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c15ad84519193c3b7fd5c364cd46598303df92e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c15ad84519193c3b7fd5c364cd46598303df92e5", "html_url": "https://github.com/rust-lang/rust/commit/c15ad84519193c3b7fd5c364cd46598303df92e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c15ad84519193c3b7fd5c364cd46598303df92e5/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46f52260d89517bcb1c49b189dfb54645776e8c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/46f52260d89517bcb1c49b189dfb54645776e8c3", "html_url": "https://github.com/rust-lang/rust/commit/46f52260d89517bcb1c49b189dfb54645776e8c3"}], "stats": {"total": 85, "additions": 73, "deletions": 12}, "files": [{"sha": "9451eefb9a5cc1d16ec76b0fc724ea370cc9248e", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c15ad84519193c3b7fd5c364cd46598303df92e5/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c15ad84519193c3b7fd5c364cd46598303df92e5/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=c15ad84519193c3b7fd5c364cd46598303df92e5", "patch": "@@ -26,6 +26,7 @@\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(unwind_attributes)]\n+#![feature(abi_thiscall)]\n #![panic_runtime]\n #![feature(panic_runtime)]\n "}, {"sha": "417de8e23cc9b466adb1d4fe4b749e91240b31fc", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c15ad84519193c3b7fd5c364cd46598303df92e5/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c15ad84519193c3b7fd5c364cd46598303df92e5/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=c15ad84519193c3b7fd5c364cd46598303df92e5", "patch": "@@ -77,8 +77,11 @@ use libc::{c_int, c_uint, c_void};\n //      #include <stdint.h>\n //\n //      struct rust_panic {\n+//          rust_panic(const rust_panic&);\n+//          ~rust_panic();\n+//\n //          uint64_t x[2];\n-//      }\n+//      };\n //\n //      void foo() {\n //          rust_panic a = {0, 1};\n@@ -128,7 +131,7 @@ mod imp {\n #[repr(C)]\n pub struct _ThrowInfo {\n     pub attributes: c_uint,\n-    pub pnfnUnwind: imp::ptr_t,\n+    pub pmfnUnwind: imp::ptr_t,\n     pub pForwardCompat: imp::ptr_t,\n     pub pCatchableTypeArray: imp::ptr_t,\n }\n@@ -145,7 +148,7 @@ pub struct _CatchableType {\n     pub pType: imp::ptr_t,\n     pub thisDisplacement: _PMD,\n     pub sizeOrOffset: c_int,\n-    pub copy_function: imp::ptr_t,\n+    pub copyFunction: imp::ptr_t,\n }\n \n #[repr(C)]\n@@ -168,7 +171,7 @@ const TYPE_NAME: [u8; 11] = *b\"rust_panic\\0\";\n \n static mut THROW_INFO: _ThrowInfo = _ThrowInfo {\n     attributes: 0,\n-    pnfnUnwind: ptr!(0),\n+    pmfnUnwind: ptr!(0),\n     pForwardCompat: ptr!(0),\n     pCatchableTypeArray: ptr!(0),\n };\n@@ -181,7 +184,7 @@ static mut CATCHABLE_TYPE: _CatchableType = _CatchableType {\n     pType: ptr!(0),\n     thisDisplacement: _PMD { mdisp: 0, pdisp: -1, vdisp: 0 },\n     sizeOrOffset: mem::size_of::<[u64; 2]>() as c_int,\n-    copy_function: ptr!(0),\n+    copyFunction: ptr!(0),\n };\n \n extern \"C\" {\n@@ -208,6 +211,39 @@ static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n     name: TYPE_NAME,\n };\n \n+// Destructor used if the C++ code decides to capture the exception and drop it\n+// without propagating it. The catch part of the try intrinsic will set the\n+// first word of the exception object to 0 so that it is skipped by the\n+// destructor.\n+//\n+// Note that x86 Windows uses the \"thiscall\" calling convention for C++ member\n+// functions instead of the default \"C\" calling convention.\n+cfg_if::cfg_if! {\n+    if #[cfg(target_arch = \"x86\")] {\n+        unsafe extern \"thiscall\" fn exception_cleanup(e: *mut [u64; 2]) {\n+            if (*e)[0] != 0 {\n+                cleanup(*e);\n+            }\n+        }\n+        unsafe extern \"thiscall\" fn exception_copy(_dest: *mut [u64; 2],\n+                                                   _src: *mut [u64; 2])\n+                                                   -> *mut [u64; 2] {\n+            panic!(\"Rust panics cannot be copied\");\n+        }\n+    } else {\n+        unsafe extern \"C\" fn exception_cleanup(e: *mut [u64; 2]) {\n+            if (*e)[0] != 0 {\n+                cleanup(*e);\n+            }\n+        }\n+        unsafe extern \"C\" fn exception_copy(_dest: *mut [u64; 2],\n+                                            _src: *mut [u64; 2])\n+                                            -> *mut [u64; 2] {\n+            panic!(\"Rust panics cannot be copied\");\n+        }\n+    }\n+}\n+\n pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     use core::intrinsics::atomic_store;\n \n@@ -220,8 +256,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     // exception (constructed above).\n     let ptrs = mem::transmute::<_, raw::TraitObject>(data);\n     let mut ptrs = [ptrs.data as u64, ptrs.vtable as u64];\n-    let ptrs_ptr = ptrs.as_mut_ptr();\n-    let throw_ptr = ptrs_ptr as *mut _;\n+    let throw_ptr = ptrs.as_mut_ptr() as *mut _;\n \n     // This... may seems surprising, and justifiably so. On 32-bit MSVC the\n     // pointers between these structure are just that, pointers. On 64-bit MSVC,\n@@ -243,6 +278,12 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     //\n     // In any case, we basically need to do something like this until we can\n     // express more operations in statics (and we may never be able to).\n+    if !cfg!(bootstrap) {\n+        atomic_store(\n+            &mut THROW_INFO.pmfnUnwind as *mut _ as *mut u32,\n+            ptr!(exception_cleanup) as u32,\n+        );\n+    }\n     atomic_store(\n         &mut THROW_INFO.pCatchableTypeArray as *mut _ as *mut u32,\n         ptr!(&CATCHABLE_TYPE_ARRAY as *const _) as u32,\n@@ -255,6 +296,12 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n         &mut CATCHABLE_TYPE.pType as *mut _ as *mut u32,\n         ptr!(&TYPE_DESCRIPTOR as *const _) as u32,\n     );\n+    if !cfg!(bootstrap) {\n+        atomic_store(\n+            &mut CATCHABLE_TYPE.copyFunction as *mut _ as *mut u32,\n+            ptr!(exception_copy) as u32,\n+        );\n+    }\n \n     extern \"system\" {\n         #[unwind(allowed)]"}, {"sha": "5adff0d1f9233a081ee4f1bb36eca4d4e2bbb614", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c15ad84519193c3b7fd5c364cd46598303df92e5/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c15ad84519193c3b7fd5c364cd46598303df92e5/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=c15ad84519193c3b7fd5c364cd46598303df92e5", "patch": "@@ -922,24 +922,29 @@ fn codegen_msvc_try(\n         //      #include <stdint.h>\n         //\n         //      struct rust_panic {\n+        //          rust_panic(const rust_panic&);\n+        //          ~rust_panic();\n+        //\n         //          uint64_t x[2];\n         //      }\n         //\n         //      int bar(void (*foo)(void), uint64_t *ret) {\n         //          try {\n         //              foo();\n         //              return 0;\n-        //          } catch(rust_panic a) {\n+        //          } catch(rust_panic& a) {\n         //              ret[0] = a.x[0];\n         //              ret[1] = a.x[1];\n+        //              a.x[0] = 0;\n         //              return 1;\n         //          }\n         //      }\n         //\n         // More information can be found in libstd's seh.rs implementation.\n         let i64_2 = bx.type_array(bx.type_i64(), 2);\n-        let i64_align = bx.tcx().data_layout.i64_align.abi;\n-        let slot = bx.alloca(i64_2, i64_align);\n+        let i64_2_ptr = bx.type_ptr_to(i64_2);\n+        let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n+        let slot = bx.alloca(i64_2_ptr, ptr_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n         normal.ret(bx.const_i32(0));\n@@ -951,11 +956,19 @@ fn codegen_msvc_try(\n             Some(did) => bx.get_static(did),\n             None => bug!(\"eh_catch_typeinfo not defined, but needed for SEH unwinding\"),\n         };\n-        let funclet = catchpad.catch_pad(cs, &[tydesc, bx.const_i32(0), slot]);\n+        let flags = bx.const_i32(8); // Catch by reference\n+        let funclet = catchpad.catch_pad(cs, &[tydesc, flags, slot]);\n \n-        let payload = catchpad.load(slot, i64_align);\n+        let i64_align = bx.tcx().data_layout.i64_align.abi;\n+        let payload_ptr = catchpad.load(slot, ptr_align);\n+        let payload = catchpad.load(payload_ptr, i64_align);\n         let local_ptr = catchpad.bitcast(local_ptr, bx.type_ptr_to(i64_2));\n         catchpad.store(payload, local_ptr, i64_align);\n+\n+        // Clear the first word of the exception so avoid double-dropping it.\n+        let payload_0_ptr = catchpad.inbounds_gep(payload_ptr, &[bx.const_i32(0), bx.const_i32(0)]);\n+        catchpad.store(bx.const_u64(0), payload_0_ptr, i64_align);\n+\n         catchpad.catch_ret(&funclet, caught.llbb());\n \n         caught.ret(bx.const_i32(1));"}]}