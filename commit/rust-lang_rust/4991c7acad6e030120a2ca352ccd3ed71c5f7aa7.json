{"sha": "4991c7acad6e030120a2ca352ccd3ed71c5f7aa7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5OTFjN2FjYWQ2ZTAzMDEyMGEyY2EzNTJjY2QzZWQ3MWM1ZjdhYTc=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-13T19:55:15Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-14T12:46:47Z"}, "message": "Remaining API additions for int overflow:\n\n  `wrapping_div`, `wrapping_rem`, `wrapping_neg`,\n  `wrapping_shl`, `wrapping_shr`.\n\nAll marked unstable under `core` feature for now (with expectation of\nbeing marked as stable by 1.0 release).", "tree": {"sha": "407cc8059e242dc1694622ab636e92e5afe0c6ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/407cc8059e242dc1694622ab636e92e5afe0c6ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4991c7acad6e030120a2ca352ccd3ed71c5f7aa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4991c7acad6e030120a2ca352ccd3ed71c5f7aa7", "html_url": "https://github.com/rust-lang/rust/commit/4991c7acad6e030120a2ca352ccd3ed71c5f7aa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4991c7acad6e030120a2ca352ccd3ed71c5f7aa7/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9d8065633be69847e1a5b16f952467f43951b65", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9d8065633be69847e1a5b16f952467f43951b65", "html_url": "https://github.com/rust-lang/rust/commit/a9d8065633be69847e1a5b16f952467f43951b65"}], "stats": {"total": 155, "additions": 155, "deletions": 0}, "files": [{"sha": "92b40f8a98fa5e4ac8dc97abe1ec9e37ee7d8f6b", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4991c7acad6e030120a2ca352ccd3ed71c5f7aa7/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4991c7acad6e030120a2ca352ccd3ed71c5f7aa7/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=4991c7acad6e030120a2ca352ccd3ed71c5f7aa7", "patch": "@@ -1219,6 +1219,66 @@ macro_rules! int_impl {\n             }\n         }\n \n+        /// Wrapping (modular) division. Computes `floor(self / other)`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// The only case where such wrapping can occur is when one\n+        /// divides `MIN / -1` on a signed type (where `MIN` is the\n+        /// negative minimal value for the type); this is equivalent\n+        /// to `-MIN`, a positive value that is too large to represent\n+        /// in the type. In such a case, this function returns `MIN`\n+        /// itself..\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_div(self, rhs: $T) -> $T {\n+            self.overflowing_div(rhs).0\n+        }\n+\n+        /// Wrapping (modular) remainder. Computes `self % other`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// Such wrap-around never actually occurs mathematically;\n+        /// implementation artifacts make `x % y` illegal for `MIN /\n+        /// -1` on a signed type illegal (where `MIN` is the negative\n+        /// minimal value). In such a case, this function returns `0`.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_rem(self, rhs: $T) -> $T {\n+            self.overflowing_rem(rhs).0\n+        }\n+\n+        /// Wrapping (modular) negation. Computes `-self`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// The only case where such wrapping can occur is when one\n+        /// negates `MIN` on a signed type (where `MIN` is the\n+        /// negative minimal value for the type); this is a positive\n+        /// value that is too large to represent in the type. In such\n+        /// a case, this function returns `MIN` itself.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_neg(self) -> $T {\n+            self.overflowing_neg().0\n+        }\n+\n+        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n+        /// where `mask` removes any high-order bits of `rhs` that\n+        /// would cause the shift to exceed the bitwidth of the type.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_shl(self, rhs: u32) -> $T {\n+            self.overflowing_shl(rhs).0\n+        }\n+\n+        /// Panic-free bitwise shift-left; yields `self >> mask(rhs)`,\n+        /// where `mask` removes any high-order bits of `rhs` that\n+        /// would cause the shift to exceed the bitwidth of the type.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_shr(self, rhs: u32) -> $T {\n+            self.overflowing_shr(rhs).0\n+        }\n+\n         /// Raises self to the power of `exp`, using exponentiation by squaring.\n         ///\n         /// # Examples\n@@ -1739,6 +1799,66 @@ macro_rules! uint_impl {\n             }\n         }\n \n+        /// Wrapping (modular) division. Computes `floor(self / other)`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// The only case where such wrapping can occur is when one\n+        /// divides `MIN / -1` on a signed type (where `MIN` is the\n+        /// negative minimal value for the type); this is equivalent\n+        /// to `-MIN`, a positive value that is too large to represent\n+        /// in the type. In such a case, this function returns `MIN`\n+        /// itself..\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_div(self, rhs: $T) -> $T {\n+            self.overflowing_div(rhs).0\n+        }\n+\n+        /// Wrapping (modular) remainder. Computes `self % other`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// Such wrap-around never actually occurs mathematically;\n+        /// implementation artifacts make `x % y` illegal for `MIN /\n+        /// -1` on a signed type illegal (where `MIN` is the negative\n+        /// minimal value). In such a case, this function returns `0`.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_rem(self, rhs: $T) -> $T {\n+            self.overflowing_rem(rhs).0\n+        }\n+\n+        /// Wrapping (modular) negation. Computes `-self`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// The only case where such wrapping can occur is when one\n+        /// negates `MIN` on a signed type (where `MIN` is the\n+        /// negative minimal value for the type); this is a positive\n+        /// value that is too large to represent in the type. In such\n+        /// a case, this function returns `MIN` itself.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_neg(self) -> $T {\n+            self.overflowing_neg().0\n+        }\n+\n+        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n+        /// where `mask` removes any high-order bits of `rhs` that\n+        /// would cause the shift to exceed the bitwidth of the type.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_shl(self, rhs: u32) -> $T {\n+            self.overflowing_shl(rhs).0\n+        }\n+\n+        /// Panic-free bitwise shift-left; yields `self >> mask(rhs)`,\n+        /// where `mask` removes any high-order bits of `rhs` that\n+        /// would cause the shift to exceed the bitwidth of the type.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_shr(self, rhs: u32) -> $T {\n+            self.overflowing_shr(rhs).0\n+        }\n+\n         /// Raises self to the power of `exp`, using exponentiation by squaring.\n         ///\n         /// # Examples"}, {"sha": "3ce2851f8e2f4d9878237a391b4a07b82a8d9650", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4991c7acad6e030120a2ca352ccd3ed71c5f7aa7/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4991c7acad6e030120a2ca352ccd3ed71c5f7aa7/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=4991c7acad6e030120a2ca352ccd3ed71c5f7aa7", "patch": "@@ -48,6 +48,7 @@ pub trait OverflowingOps {\n \n     fn overflowing_div(self, rhs: Self) -> (Self, bool);\n     fn overflowing_rem(self, rhs: Self) -> (Self, bool);\n+    fn overflowing_neg(self) -> (Self, bool);\n \n     fn overflowing_shl(self, rhs: u32) -> (Self, bool);\n     fn overflowing_shr(self, rhs: u32) -> (Self, bool);\n@@ -255,6 +256,15 @@ macro_rules! signed_overflowing_impl {\n                 (self >> (rhs & self::shift_max::$t),\n                  (rhs > self::shift_max::$t))\n             }\n+\n+            #[inline(always)]\n+            fn overflowing_neg(self) -> ($t, bool) {\n+                if self == $t::MIN {\n+                    ($t::MIN, true)\n+                } else {\n+                    (-self, false)\n+                }\n+            }\n         }\n     )*)\n }\n@@ -300,6 +310,11 @@ macro_rules! unsigned_overflowing_impl {\n                 (self >> (rhs & self::shift_max::$t),\n                  (rhs > self::shift_max::$t))\n             }\n+\n+            #[inline(always)]\n+            fn overflowing_neg(self) -> ($t, bool) {\n+                ((!self).wrapping_add(1), true)\n+            }\n         }\n     )*)\n }\n@@ -341,6 +356,11 @@ impl OverflowingOps for usize {\n         (r as usize, f)\n     }\n     #[inline(always)]\n+    fn overflowing_neg(self) -> (usize, bool) {\n+        let (r, f) = (self as u64).overflowing_neg();\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n     fn overflowing_shl(self, rhs: u32) -> (usize, bool) {\n         let (r, f) = (self as u64).overflowing_shl(rhs);\n         (r as usize, f)\n@@ -386,6 +406,11 @@ impl OverflowingOps for usize {\n         (r as usize, f)\n     }\n     #[inline(always)]\n+    fn overflowing_neg(self) -> (usize, bool) {\n+        let (r, f) = (self as u32).overflowing_neg();\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n     fn overflowing_shl(self, rhs: u32) -> (usize, bool) {\n         let (r, f) = (self as u32).overflowing_shl(rhs);\n         (r as usize, f)\n@@ -431,6 +456,11 @@ impl OverflowingOps for isize {\n         (r as isize, f)\n     }\n     #[inline(always)]\n+    fn overflowing_neg(self) -> (isize, bool) {\n+        let (r, f) = (self as i64).overflowing_neg();\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n     fn overflowing_shl(self, rhs: u32) -> (isize, bool) {\n         let (r, f) = (self as i64).overflowing_shl(rhs);\n         (r as isize, f)\n@@ -476,6 +506,11 @@ impl OverflowingOps for isize {\n         (r as isize, f)\n     }\n     #[inline(always)]\n+    fn overflowing_neg(self) -> (isize, bool) {\n+        let (r, f) = (self as i32).overflowing_neg();\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n     fn overflowing_shl(self, rhs: u32) -> (isize, bool) {\n         let (r, f) = (self as i32).overflowing_shl(rhs);\n         (r as isize, f)"}]}