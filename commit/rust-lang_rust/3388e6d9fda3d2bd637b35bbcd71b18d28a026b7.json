{"sha": "3388e6d9fda3d2bd637b35bbcd71b18d28a026b7", "node_id": "C_kwDOAAsO6NoAKDMzODhlNmQ5ZmRhM2QyYmQ2MzdiMzViYmNkNzFiMThkMjhhMDI2Yjc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-02T18:34:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-02T18:34:07Z"}, "message": "Rollup merge of #93590 - est31:let_else, r=lcnr\n\nMore let_else adoptions\n\nContinuation of #89933, #91018, #91481, #93046.", "tree": {"sha": "abb103be7dd3844bc27b6ac1a5c118447341c54d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abb103be7dd3844bc27b6ac1a5c118447341c54d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh+s6fCRBK7hj4Ov3rIwAA+SMIACP44D+kiHNCHL+GRbk74+NT\nUCnDbpP23d/BFqoRuUBGHIPHFE6eZJ6gmIdpKi15CTK6wNiBYtdirF+EmfBQCdAO\nHsYcrJt8bjPIQjxwvEh28Bvoj18ktaYcCbsPK7/hm34C4divFISog40OzZ9HGdrW\nytwXhf1rMq6h4KnLNLHuLPZJORJkoqW4Q24N+vMZkbMG5TJxg8nLjViSV+T+4ycR\nPut01UUPy4MYHLGWOmXpbs4fTrxECz6BZQrV+v9gxoEzOhrveZYWSHP1zPwhrAIX\noY4ls/64SnN5kQE5guT7XIu9M4jPG8f64oMHpBcx9kuE+P01MHuPh2bj7I1qc40=\n=0quJ\n-----END PGP SIGNATURE-----\n", "payload": "tree abb103be7dd3844bc27b6ac1a5c118447341c54d\nparent 799bded9b44fd59b4647d4e2087b8d336f573bae\nparent 670f5c6ef385f251df5cd7bcba9e8039a80bdb4d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1643826847 +0100\ncommitter GitHub <noreply@github.com> 1643826847 +0100\n\nRollup merge of #93590 - est31:let_else, r=lcnr\n\nMore let_else adoptions\n\nContinuation of #89933, #91018, #91481, #93046.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7", "html_url": "https://github.com/rust-lang/rust/commit/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "799bded9b44fd59b4647d4e2087b8d336f573bae", "url": "https://api.github.com/repos/rust-lang/rust/commits/799bded9b44fd59b4647d4e2087b8d336f573bae", "html_url": "https://github.com/rust-lang/rust/commit/799bded9b44fd59b4647d4e2087b8d336f573bae"}, {"sha": "670f5c6ef385f251df5cd7bcba9e8039a80bdb4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/670f5c6ef385f251df5cd7bcba9e8039a80bdb4d", "html_url": "https://github.com/rust-lang/rust/commit/670f5c6ef385f251df5cd7bcba9e8039a80bdb4d"}], "stats": {"total": 434, "additions": 208, "deletions": 226}, "files": [{"sha": "cacc36b616a1e05590762693c4db09376445738a", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=3388e6d9fda3d2bd637b35bbcd71b18d28a026b7", "patch": "@@ -471,9 +471,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // two imports.\n                 for new_node_id in [id1, id2] {\n                     let new_id = self.resolver.local_def_id(new_node_id);\n-                    let res = if let Some(res) = resolutions.next() {\n-                        res\n-                    } else {\n+                    let Some(res) = resolutions.next() else {\n                         // Associate an HirId to both ids even if there is no resolution.\n                         let _old = self\n                             .node_id_to_hir_id"}, {"sha": "b1e601516ab97e947c73ba5f346bd574e0f65378", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=3388e6d9fda3d2bd637b35bbcd71b18d28a026b7", "patch": "@@ -32,6 +32,7 @@\n \n #![feature(crate_visibility_modifier)]\n #![feature(box_patterns)]\n+#![feature(let_else)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n #![cfg_attr(not(bootstrap), allow(rustc::potential_query_instability))]"}, {"sha": "8c5beb1025803ec05b2450e6dd72793675866afe", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 67, "deletions": 71, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=3388e6d9fda3d2bd637b35bbcd71b18d28a026b7", "patch": "@@ -217,85 +217,81 @@ where\n                     let mut issue_num = None;\n                     let mut is_soft = false;\n                     for meta in metas {\n-                        if let Some(mi) = meta.meta_item() {\n-                            match mi.name_or_empty() {\n-                                sym::feature => {\n-                                    if !get(mi, &mut feature) {\n-                                        continue 'outer;\n-                                    }\n+                        let Some(mi) = meta.meta_item() else {\n+                            handle_errors(\n+                                &sess.parse_sess,\n+                                meta.span(),\n+                                AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n+                            );\n+                            continue 'outer;\n+                        };\n+                        match mi.name_or_empty() {\n+                            sym::feature => {\n+                                if !get(mi, &mut feature) {\n+                                    continue 'outer;\n                                 }\n-                                sym::reason => {\n-                                    if !get(mi, &mut reason) {\n-                                        continue 'outer;\n-                                    }\n+                            }\n+                            sym::reason => {\n+                                if !get(mi, &mut reason) {\n+                                    continue 'outer;\n+                                }\n+                            }\n+                            sym::issue => {\n+                                if !get(mi, &mut issue) {\n+                                    continue 'outer;\n                                 }\n-                                sym::issue => {\n-                                    if !get(mi, &mut issue) {\n-                                        continue 'outer;\n-                                    }\n \n-                                    // These unwraps are safe because `get` ensures the meta item\n-                                    // is a name/value pair string literal.\n-                                    issue_num = match issue.unwrap().as_str() {\n-                                        \"none\" => None,\n-                                        issue => {\n-                                            let emit_diag = |msg: &str| {\n-                                                struct_span_err!(\n-                                                    diagnostic,\n-                                                    mi.span,\n-                                                    E0545,\n-                                                    \"`issue` must be a non-zero numeric string \\\n-                                                    or \\\"none\\\"\",\n-                                                )\n-                                                .span_label(\n-                                                    mi.name_value_literal_span().unwrap(),\n-                                                    msg,\n-                                                )\n-                                                .emit();\n-                                            };\n-                                            match issue.parse() {\n-                                                Ok(0) => {\n-                                                    emit_diag(\n-                                                        \"`issue` must not be \\\"0\\\", \\\n-                                                        use \\\"none\\\" instead\",\n-                                                    );\n-                                                    continue 'outer;\n-                                                }\n-                                                Ok(num) => NonZeroU32::new(num),\n-                                                Err(err) => {\n-                                                    emit_diag(&err.to_string());\n-                                                    continue 'outer;\n-                                                }\n+                                // These unwraps are safe because `get` ensures the meta item\n+                                // is a name/value pair string literal.\n+                                issue_num = match issue.unwrap().as_str() {\n+                                    \"none\" => None,\n+                                    issue => {\n+                                        let emit_diag = |msg: &str| {\n+                                            struct_span_err!(\n+                                                diagnostic,\n+                                                mi.span,\n+                                                E0545,\n+                                                \"`issue` must be a non-zero numeric string \\\n+                                                or \\\"none\\\"\",\n+                                            )\n+                                            .span_label(mi.name_value_literal_span().unwrap(), msg)\n+                                            .emit();\n+                                        };\n+                                        match issue.parse() {\n+                                            Ok(0) => {\n+                                                emit_diag(\n+                                                    \"`issue` must not be \\\"0\\\", \\\n+                                                    use \\\"none\\\" instead\",\n+                                                );\n+                                                continue 'outer;\n+                                            }\n+                                            Ok(num) => NonZeroU32::new(num),\n+                                            Err(err) => {\n+                                                emit_diag(&err.to_string());\n+                                                continue 'outer;\n                                             }\n                                         }\n-                                    };\n-                                }\n-                                sym::soft => {\n-                                    if !mi.is_word() {\n-                                        let msg = \"`soft` should not have any arguments\";\n-                                        sess.parse_sess.span_diagnostic.span_err(mi.span, msg);\n                                     }\n-                                    is_soft = true;\n-                                }\n-                                _ => {\n-                                    handle_errors(\n-                                        &sess.parse_sess,\n-                                        meta.span(),\n-                                        AttrError::UnknownMetaItem(\n-                                            pprust::path_to_string(&mi.path),\n-                                            &[\"feature\", \"reason\", \"issue\", \"soft\"],\n-                                        ),\n-                                    );\n-                                    continue 'outer;\n+                                };\n+                            }\n+                            sym::soft => {\n+                                if !mi.is_word() {\n+                                    let msg = \"`soft` should not have any arguments\";\n+                                    sess.parse_sess.span_diagnostic.span_err(mi.span, msg);\n                                 }\n+                                is_soft = true;\n+                            }\n+                            _ => {\n+                                handle_errors(\n+                                    &sess.parse_sess,\n+                                    meta.span(),\n+                                    AttrError::UnknownMetaItem(\n+                                        pprust::path_to_string(&mi.path),\n+                                        &[\"feature\", \"reason\", \"issue\", \"soft\"],\n+                                    ),\n+                                );\n+                                continue 'outer;\n                             }\n-                        } else {\n-                            handle_errors(\n-                                &sess.parse_sess,\n-                                meta.span(),\n-                                AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n-                            );\n-                            continue 'outer;\n                         }\n                     }\n "}, {"sha": "c95c1c40a34c20fc211cfbbf31b5241cb7cddbca", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=3388e6d9fda3d2bd637b35bbcd71b18d28a026b7", "patch": "@@ -4,6 +4,8 @@\n //! The goal is to move the definition of `MetaItem` and things that don't need to be in `syntax`\n //! to this crate.\n \n+#![feature(let_else)]\n+\n #[macro_use]\n extern crate rustc_macros;\n "}, {"sha": "3409f14c98b733b3054b4b92465e31908c7382b4", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 65, "deletions": 72, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=3388e6d9fda3d2bd637b35bbcd71b18d28a026b7", "patch": "@@ -311,43 +311,39 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 ty::BoundRegionKind::BrEnv => {\n                     let def_ty = self.regioncx.universal_regions().defining_ty;\n \n-                    if let DefiningTy::Closure(_, substs) = def_ty {\n-                        let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n-                            tcx.hir().expect_expr(self.mir_hir_id()).kind\n-                        {\n-                            span\n-                        } else {\n-                            bug!(\"Closure is not defined by a closure expr\");\n-                        };\n-                        let region_name = self.synthesize_region_name();\n-\n-                        let closure_kind_ty = substs.as_closure().kind_ty();\n-                        let note = match closure_kind_ty.to_opt_closure_kind() {\n-                            Some(ty::ClosureKind::Fn) => {\n-                                \"closure implements `Fn`, so references to captured variables \\\n-                                 can't escape the closure\"\n-                            }\n-                            Some(ty::ClosureKind::FnMut) => {\n-                                \"closure implements `FnMut`, so references to captured variables \\\n-                                 can't escape the closure\"\n-                            }\n-                            Some(ty::ClosureKind::FnOnce) => {\n-                                bug!(\"BrEnv in a `FnOnce` closure\");\n-                            }\n-                            None => bug!(\"Closure kind not inferred in borrow check\"),\n-                        };\n-\n-                        Some(RegionName {\n-                            name: region_name,\n-                            source: RegionNameSource::SynthesizedFreeEnvRegion(\n-                                args_span,\n-                                note.to_string(),\n-                            ),\n-                        })\n-                    } else {\n+                    let DefiningTy::Closure(_, substs) = def_ty else {\n                         // Can't have BrEnv in functions, constants or generators.\n                         bug!(\"BrEnv outside of closure.\");\n-                    }\n+                    };\n+                    let hir::ExprKind::Closure(_, _, _, args_span, _) =\n+                        tcx.hir().expect_expr(self.mir_hir_id()).kind else {\n+                        bug!(\"Closure is not defined by a closure expr\");\n+                    };\n+                    let region_name = self.synthesize_region_name();\n+\n+                    let closure_kind_ty = substs.as_closure().kind_ty();\n+                    let note = match closure_kind_ty.to_opt_closure_kind() {\n+                        Some(ty::ClosureKind::Fn) => {\n+                            \"closure implements `Fn`, so references to captured variables \\\n+                                can't escape the closure\"\n+                        }\n+                        Some(ty::ClosureKind::FnMut) => {\n+                            \"closure implements `FnMut`, so references to captured variables \\\n+                                can't escape the closure\"\n+                        }\n+                        Some(ty::ClosureKind::FnOnce) => {\n+                            bug!(\"BrEnv in a `FnOnce` closure\");\n+                        }\n+                        None => bug!(\"Closure kind not inferred in borrow check\"),\n+                    };\n+\n+                    Some(RegionName {\n+                        name: region_name,\n+                        source: RegionNameSource::SynthesizedFreeEnvRegion(\n+                            args_span,\n+                            note.to_string(),\n+                        ),\n+                    })\n                 }\n \n                 ty::BoundRegionKind::BrAnon(_) => None,\n@@ -765,48 +761,45 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     fn get_future_inner_return_ty(&self, hir_ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n         let hir = self.infcx.tcx.hir();\n \n-        if let hir::TyKind::OpaqueDef(id, _) = hir_ty.kind {\n-            let opaque_ty = hir.item(id);\n-            if let hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                bounds:\n-                    [\n-                        hir::GenericBound::LangItemTrait(\n-                            hir::LangItem::Future,\n-                            _,\n-                            _,\n-                            hir::GenericArgs {\n-                                bindings:\n-                                    [\n-                                        hir::TypeBinding {\n-                                            ident: Ident { name: sym::Output, .. },\n-                                            kind:\n-                                                hir::TypeBindingKind::Equality {\n-                                                    term: hir::Term::Ty(ty),\n-                                                },\n-                                            ..\n-                                        },\n-                                    ],\n-                                ..\n-                            },\n-                        ),\n-                    ],\n-                ..\n-            }) = opaque_ty.kind\n-            {\n-                ty\n-            } else {\n-                span_bug!(\n-                    hir_ty.span,\n-                    \"bounds from lowered return type of async fn did not match expected format: {:?}\",\n-                    opaque_ty\n-                );\n-            }\n-        } else {\n+        let hir::TyKind::OpaqueDef(id, _) = hir_ty.kind else {\n             span_bug!(\n                 hir_ty.span,\n                 \"lowered return type of async fn is not OpaqueDef: {:?}\",\n                 hir_ty\n             );\n+        };\n+        let opaque_ty = hir.item(id);\n+        if let hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+            bounds:\n+                [\n+                    hir::GenericBound::LangItemTrait(\n+                        hir::LangItem::Future,\n+                        _,\n+                        _,\n+                        hir::GenericArgs {\n+                            bindings:\n+                                [\n+                                    hir::TypeBinding {\n+                                        ident: Ident { name: sym::Output, .. },\n+                                        kind:\n+                                            hir::TypeBindingKind::Equality { term: hir::Term::Ty(ty) },\n+                                        ..\n+                                    },\n+                                ],\n+                            ..\n+                        },\n+                    ),\n+                ],\n+            ..\n+        }) = opaque_ty.kind\n+        {\n+            ty\n+        } else {\n+            span_bug!(\n+                hir_ty.span,\n+                \"bounds from lowered return type of async fn did not match expected format: {:?}\",\n+                opaque_ty\n+            );\n         }\n     }\n "}, {"sha": "5597a8b091554769adc7dd0f07be095b02ea8739", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=3388e6d9fda3d2bd637b35bbcd71b18d28a026b7", "patch": "@@ -1427,9 +1427,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             bug!(\"temporary should be initialized exactly once\")\n                         };\n \n-                        let loc = match init.location {\n-                            InitLocation::Statement(stmt) => stmt,\n-                            _ => bug!(\"temporary initialized in arguments\"),\n+                        let InitLocation::Statement(loc) = init.location else {\n+                            bug!(\"temporary initialized in arguments\")\n                         };\n \n                         let body = self.body;"}, {"sha": "6329bcee4fa3f1c6eb4e12c4c53d73439f5f71dd", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=3388e6d9fda3d2bd637b35bbcd71b18d28a026b7", "patch": "@@ -602,33 +602,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 for binding in &candidate_ref.bindings {\n                     let local = self.var_local_id(binding.var_id, OutsideGuard);\n \n-                    if let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                    let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n                         VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n-                    )))) = self.local_decls[local].local_info\n-                    {\n-                        // `try_upvars_resolved` may fail if it is unable to resolve the given\n-                        // `PlaceBuilder` inside a closure. In this case, we don't want to include\n-                        // a scrutinee place. `scrutinee_place_builder` will fail for destructured\n-                        // assignments. This is because a closure only captures the precise places\n-                        // that it will read and as a result a closure may not capture the entire\n-                        // tuple/struct and rather have individual places that will be read in the\n-                        // final MIR.\n-                        // Example:\n-                        // ```\n-                        // let foo = (0, 1);\n-                        // let c = || {\n-                        //    let (v1, v2) = foo;\n-                        // };\n-                        // ```\n-                        if let Ok(match_pair_resolved) =\n-                            initializer.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n-                        {\n-                            let place =\n-                                match_pair_resolved.into_place(self.tcx, self.typeck_results);\n-                            *match_place = Some(place);\n-                        }\n-                    } else {\n+                    )))) = self.local_decls[local].local_info else {\n                         bug!(\"Let binding to non-user variable.\")\n+                    };\n+                    // `try_upvars_resolved` may fail if it is unable to resolve the given\n+                    // `PlaceBuilder` inside a closure. In this case, we don't want to include\n+                    // a scrutinee place. `scrutinee_place_builder` will fail for destructured\n+                    // assignments. This is because a closure only captures the precise places\n+                    // that it will read and as a result a closure may not capture the entire\n+                    // tuple/struct and rather have individual places that will be read in the\n+                    // final MIR.\n+                    // Example:\n+                    // ```\n+                    // let foo = (0, 1);\n+                    // let c = || {\n+                    //    let (v1, v2) = foo;\n+                    // };\n+                    // ```\n+                    if let Ok(match_pair_resolved) =\n+                        initializer.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+                    {\n+                        let place = match_pair_resolved.into_place(self.tcx, self.typeck_results);\n+                        *match_place = Some(place);\n                     }\n                 }\n                 // All of the subcandidates should bind the same locals, so we"}, {"sha": "49cd21c2137b78c32dd3adb88918c2f73d847a8d", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 45, "deletions": 49, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=3388e6d9fda3d2bd637b35bbcd71b18d28a026b7", "patch": "@@ -227,16 +227,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let target_blocks = make_target_blocks(self);\n                 let terminator = if *switch_ty.kind() == ty::Bool {\n                     assert!(!options.is_empty() && options.len() <= 2);\n-                    if let [first_bb, second_bb] = *target_blocks {\n-                        let (true_bb, false_bb) = match options[0] {\n-                            1 => (first_bb, second_bb),\n-                            0 => (second_bb, first_bb),\n-                            v => span_bug!(test.span, \"expected boolean value but got {:?}\", v),\n-                        };\n-                        TerminatorKind::if_(self.tcx, Operand::Copy(place), true_bb, false_bb)\n-                    } else {\n+                    let [first_bb, second_bb] = *target_blocks else {\n                         bug!(\"`TestKind::SwitchInt` on `bool` should have two targets\")\n-                    }\n+                    };\n+                    let (true_bb, false_bb) = match options[0] {\n+                        1 => (first_bb, second_bb),\n+                        0 => (second_bb, first_bb),\n+                        v => span_bug!(test.span, \"expected boolean value but got {:?}\", v),\n+                    };\n+                    TerminatorKind::if_(self.tcx, Operand::Copy(place), true_bb, false_bb)\n                 } else {\n                     // The switch may be inexhaustive so we have a catch all block\n                     debug_assert_eq!(options.len() + 1, target_blocks.len());\n@@ -285,24 +284,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let hi = self.literal_operand(test.span, hi);\n                 let val = Operand::Copy(place);\n \n-                if let [success, fail] = *target_blocks {\n-                    self.compare(\n-                        block,\n-                        lower_bound_success,\n-                        fail,\n-                        source_info,\n-                        BinOp::Le,\n-                        lo,\n-                        val.clone(),\n-                    );\n-                    let op = match *end {\n-                        RangeEnd::Included => BinOp::Le,\n-                        RangeEnd::Excluded => BinOp::Lt,\n-                    };\n-                    self.compare(lower_bound_success, success, fail, source_info, op, val, hi);\n-                } else {\n+                let [success, fail] = *target_blocks else {\n                     bug!(\"`TestKind::Range` should have two target blocks\");\n-                }\n+                };\n+                self.compare(\n+                    block,\n+                    lower_bound_success,\n+                    fail,\n+                    source_info,\n+                    BinOp::Le,\n+                    lo,\n+                    val.clone(),\n+                );\n+                let op = match *end {\n+                    RangeEnd::Included => BinOp::Le,\n+                    RangeEnd::Excluded => BinOp::Lt,\n+                };\n+                self.compare(lower_bound_success, success, fail, source_info, op, val, hi);\n             }\n \n             TestKind::Len { len, op } => {\n@@ -317,21 +315,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // expected = <N>\n                 let expected = self.push_usize(block, source_info, len);\n \n-                if let [true_bb, false_bb] = *target_blocks {\n-                    // result = actual == expected OR result = actual < expected\n-                    // branch based on result\n-                    self.compare(\n-                        block,\n-                        true_bb,\n-                        false_bb,\n-                        source_info,\n-                        op,\n-                        Operand::Move(actual),\n-                        Operand::Move(expected),\n-                    );\n-                } else {\n+                let [true_bb, false_bb] = *target_blocks else {\n                     bug!(\"`TestKind::Len` should have two target blocks\");\n-                }\n+                };\n+                // result = actual == expected OR result = actual < expected\n+                // branch based on result\n+                self.compare(\n+                    block,\n+                    true_bb,\n+                    false_bb,\n+                    source_info,\n+                    op,\n+                    Operand::Move(actual),\n+                    Operand::Move(expected),\n+                );\n             }\n         }\n     }\n@@ -459,16 +456,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n         self.diverge_from(block);\n \n-        if let [success_block, fail_block] = *make_target_blocks(self) {\n-            // check the result\n-            self.cfg.terminate(\n-                eq_block,\n-                source_info,\n-                TerminatorKind::if_(self.tcx, Operand::Move(eq_result), success_block, fail_block),\n-            );\n-        } else {\n+        let [success_block, fail_block] = *make_target_blocks(self) else {\n             bug!(\"`TestKind::Eq` should have two target blocks\")\n-        }\n+        };\n+        // check the result\n+        self.cfg.terminate(\n+            eq_block,\n+            source_info,\n+            TerminatorKind::if_(self.tcx, Operand::Move(eq_result), success_block, fail_block),\n+        );\n     }\n \n     /// Given that we are performing `test` against `test_place`, this job"}, {"sha": "a3f7e84b1d524b5ccca0d5feb7481813c5c691da", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=3388e6d9fda3d2bd637b35bbcd71b18d28a026b7", "patch": "@@ -47,11 +47,10 @@ use rls_data::{\n \n use tracing::{debug, error};\n \n+#[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5213\n macro_rules! down_cast_data {\n     ($id:ident, $kind:ident, $sp:expr) => {\n-        let $id = if let super::Data::$kind(data) = $id {\n-            data\n-        } else {\n+        let super::Data::$kind($id) = $id else {\n             span_bug!($sp, \"unexpected data kind: {:?}\", $id);\n         };\n     };"}, {"sha": "2eebddb47df5c24d2f7f4ea74ad05c36996d8b18", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3388e6d9fda3d2bd637b35bbcd71b18d28a026b7/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=3388e6d9fda3d2bd637b35bbcd71b18d28a026b7", "patch": "@@ -1,6 +1,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(if_let_guard)]\n #![feature(nll)]\n+#![feature(let_else)]\n #![recursion_limit = \"256\"]\n #![cfg_attr(not(bootstrap), allow(rustc::potential_query_instability))]\n "}]}