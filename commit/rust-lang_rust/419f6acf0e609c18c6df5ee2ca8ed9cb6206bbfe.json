{"sha": "419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxOWY2YWNmMGU2MDljMThjNmRmNWVlMmNhOGVkOWNiNjIwNmJiZmU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-04-10T02:41:20Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-04-10T23:08:22Z"}, "message": "std: rename {read,emit}_field to {read,emit}_struct_field", "tree": {"sha": "fa6554641f1a01209753dfe41e57e6251763479e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa6554641f1a01209753dfe41e57e6251763479e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe", "html_url": "https://github.com/rust-lang/rust/commit/419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97cc571358c3ac1bc3d562ac60c39c67cda3678d", "url": "https://api.github.com/repos/rust-lang/rust/commits/97cc571358c3ac1bc3d562ac60c39c67cda3678d", "html_url": "https://github.com/rust-lang/rust/commit/97cc571358c3ac1bc3d562ac60c39c67cda3678d"}], "stats": {"total": 193, "additions": 183, "deletions": 10}, "files": [{"sha": "f5a31879855ef2816915db2f13454c848eb31797", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe", "patch": "@@ -556,6 +556,7 @@ trait read_method_map_entry_helper {\n                             -> method_map_entry;\n }\n \n+#[cfg(stage0)]\n fn encode_method_map_entry(ecx: @e::EncodeContext,\n                               ebml_w: writer::Encoder,\n                               mme: method_map_entry) {\n@@ -572,7 +573,27 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+fn encode_method_map_entry(ecx: @e::EncodeContext,\n+                              ebml_w: writer::Encoder,\n+                              mme: method_map_entry) {\n+    do ebml_w.emit_struct(\"method_map_entry\", 3) {\n+        do ebml_w.emit_struct_field(\"self_arg\", 0u) {\n+            ebml_w.emit_arg(ecx, mme.self_arg);\n+        }\n+        do ebml_w.emit_struct_field(\"explicit_self\", 2u) {\n+            mme.explicit_self.encode(&ebml_w);\n+        }\n+        do ebml_w.emit_struct_field(\"origin\", 1u) {\n+            mme.origin.encode(&ebml_w);\n+        }\n+    }\n+}\n+\n impl read_method_map_entry_helper for reader::Decoder {\n+    #[cfg(stage0)]\n     fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n         -> method_map_entry {\n         do self.read_struct(\"method_map_entry\", 3) {\n@@ -592,6 +613,29 @@ impl read_method_map_entry_helper for reader::Decoder {\n             }\n         }\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n+        -> method_map_entry {\n+        do self.read_struct(\"method_map_entry\", 3) {\n+            method_map_entry {\n+                self_arg: self.read_struct_field(\"self_arg\", 0u, || {\n+                    self.read_arg(xcx)\n+                }),\n+                explicit_self: self.read_struct_field(\"explicit_self\", 2u, || {\n+                    let self_type: ast::self_ty_ = Decodable::decode(self);\n+                    self_type\n+                }),\n+                origin: self.read_struct_field(\"origin\", 1u, || {\n+                    let method_origin: method_origin =\n+                        Decodable::decode(self);\n+                    method_origin.tr(xcx)\n+                }),\n+            }\n+        }\n+    }\n }\n \n impl tr for method_origin {\n@@ -782,6 +826,7 @@ impl ebml_writer_helpers for writer::Encoder {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn emit_tpbt(&self, ecx: @e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n         do self.emit_struct(\"ty_param_bounds_and_ty\", 2) {\n@@ -804,6 +849,32 @@ impl ebml_writer_helpers for writer::Encoder {\n             }\n         }\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn emit_tpbt(&self, ecx: @e::EncodeContext,\n+                 tpbt: ty::ty_param_bounds_and_ty) {\n+        do self.emit_struct(\"ty_param_bounds_and_ty\", 2) {\n+            do self.emit_struct_field(\"generics\", 0) {\n+                do self.emit_struct(\"Generics\", 2) {\n+                    do self.emit_struct_field(\"type_param_defs\", 0) {\n+                        do self.emit_from_vec(*tpbt.generics.type_param_defs)\n+                            |type_param_def|\n+                        {\n+                            self.emit_type_param_def(ecx, type_param_def);\n+                        }\n+                    }\n+                    do self.emit_struct_field(\"region_param\", 1) {\n+                        tpbt.generics.region_param.encode(self);\n+                    }\n+                }\n+            }\n+            do self.emit_struct_field(\"ty\", 1) {\n+                self.emit_ty(ecx, tpbt.ty);\n+            }\n+        }\n+    }\n }\n \n trait write_tag_and_id {\n@@ -1053,6 +1124,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n         -> ty::ty_param_bounds_and_ty\n     {\n@@ -1075,6 +1147,31 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n+        -> ty::ty_param_bounds_and_ty\n+    {\n+        do self.read_struct(\"ty_param_bounds_and_ty\", 2) {\n+            ty::ty_param_bounds_and_ty {\n+                generics: do self.read_struct(\"Generics\", 2) {\n+                    ty::Generics {\n+                        type_param_defs: self.read_struct_field(\"type_param_defs\", 0, || {\n+                            @self.read_to_vec(|| self.read_type_param_def(xcx))\n+                        }),\n+                        region_param: self.read_struct_field(~\"region_param\", 1, || {\n+                            Decodable::decode(self)\n+                        })\n+                    }\n+                },\n+                ty: self.read_struct_field(\"ty\", 1, || {\n+                    self.read_ty(xcx)\n+                })\n+            }\n+        }\n+    }\n+\n     fn convert_def_id(&self, xcx: @ExtendedDecodeContext,\n                       source: tydecode::DefIdSource,\n                       did: ast::def_id) -> ast::def_id {"}, {"sha": "28933d553e6ef168074d9c61afa21ba4f9c1b18d", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe", "patch": "@@ -340,8 +340,18 @@ pub mod reader {\n             f()\n         }\n \n+        #[cfg(stage0)]\n         fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n-            debug!(\"read_field(name=%s, idx=%u)\", name, idx);\n+            debug!(\"read_field(name=%?, idx=%u)\", name, idx);\n+            self._check_label(name);\n+            f()\n+        }\n+\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        #[cfg(stage3)]\n+        fn read_struct_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+            debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n             self._check_label(name);\n             f()\n         }\n@@ -614,10 +624,18 @@ pub mod writer {\n         fn emit_enum_variant_arg(&self, _idx: uint, f: &fn()) { f() }\n \n         fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) { f() }\n+        #[cfg(stage0)]\n         fn emit_field(&self, name: &str, _idx: uint, f: &fn()) {\n             self._emit_label(name);\n             f()\n         }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        #[cfg(stage3)]\n+        fn emit_struct_field(&self, name: &str, _idx: uint, f: &fn()) {\n+            self._emit_label(name);\n+            f()\n+        }\n \n         fn emit_option(&self, f: &fn()) {\n             self.emit_enum(\"Option\", f);"}, {"sha": "4b5e1f142299036438814d418a051e745abd6734", "filename": "src/libstd/json.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe", "patch": "@@ -135,12 +135,22 @@ impl serialize::Encoder for Encoder {\n         f();\n         self.wr.write_char('}');\n     }\n+    #[cfg(stage0)]\n     fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx != 0 { self.wr.write_char(','); }\n         self.wr.write_str(escape_str(name));\n         self.wr.write_char(':');\n         f();\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn emit_struct_field(&self, name: &str, idx: uint, f: &fn()) {\n+        if idx != 0 { self.wr.write_char(','); }\n+        self.wr.write_str(escape_str(name));\n+        self.wr.write_char(':');\n+        f();\n+    }\n \n     fn emit_option(&self, f: &fn()) { f(); }\n     fn emit_option_none(&self) { self.emit_nil(); }\n@@ -254,6 +264,7 @@ impl serialize::Encoder for PrettyEncoder {\n             self.wr.write_char('}');\n         }\n     }\n+    #[cfg(stage0)]\n     fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n@@ -265,6 +276,20 @@ impl serialize::Encoder for PrettyEncoder {\n         self.wr.write_str(\": \");\n         f();\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn emit_struct_field(&self, name: &str, idx: uint, f: &fn()) {\n+        if idx == 0 {\n+            self.wr.write_char('\\n');\n+        } else {\n+            self.wr.write_str(\",\\n\");\n+        }\n+        self.wr.write_str(spaces(self.indent));\n+        self.wr.write_str(escape_str(name));\n+        self.wr.write_str(\": \");\n+        f();\n+    }\n \n     fn emit_option(&self, f: &fn()) { f(); }\n     fn emit_option_none(&self) { self.emit_nil(); }\n@@ -834,8 +859,31 @@ impl serialize::Decoder for Decoder {\n         value\n     }\n \n+    #[cfg(stage0)]\n     fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_field(%s, idx=%u)\", name, idx);\n+        debug!(\"read_field(name=%?, idx=%u)\", name, idx);\n+        match self.stack.pop() {\n+            Object(obj) => {\n+                let mut obj = obj;\n+                let value = match obj.pop(&name.to_owned()) {\n+                    None => fail!(fmt!(\"no such field: %s\", name)),\n+                    Some(json) => {\n+                        self.stack.push(json);\n+                        f()\n+                    }\n+                };\n+                self.stack.push(Object(obj));\n+                value\n+            }\n+            value => fail!(fmt!(\"not an object: %?\", value))\n+        }\n+    }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn read_struct_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n         match self.stack.pop() {\n             Object(obj) => {\n                 let mut obj = obj;"}, {"sha": "cc3a1ec028983d7d2b93a94447e6a9dd37f3fa32", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe", "patch": "@@ -48,8 +48,13 @@ pub trait Encoder {\n     fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: &fn());\n     fn emit_enum_variant_arg(&self, idx: uint, f: &fn());\n \n-    fn emit_struct(&self, name: &str, _len: uint, f: &fn());\n+    fn emit_struct(&self, name: &str, len: uint, f: &fn());\n+    #[cfg(stage0)]\n     fn emit_field(&self, f_name: &str, f_idx: uint, f: &fn());\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn emit_struct_field(&self, f_name: &str, f_idx: uint, f: &fn());\n \n     // Specialized types:\n     fn emit_option(&self, f: &fn());\n@@ -89,8 +94,13 @@ pub trait Decoder {\n     fn read_enum_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T;\n     fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T;\n \n-    fn read_struct<T>(&self, name: &str, _len: uint, f: &fn() -> T) -> T;\n-    fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T;\n+    fn read_struct<T>(&self, s_name: &str, len: uint, f: &fn() -> T) -> T;\n+    #[cfg(stage0)]\n+    fn read_field<T>(&self, f_name: &str, f_idx: uint, f: &fn() -> T) -> T;\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn read_struct_field<T>(&self, f_name: &str, f_idx: uint, f: &fn() -> T) -> T;\n \n     // Specialized types:\n     fn read_option<T>(&self, f: &fn(bool) -> T) -> T;"}, {"sha": "38bac6b1f438d0482beda794db31f122ed463f3a", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=419f6acf0e609c18c6df5ee2ca8ed9cb6206bbfe", "patch": "@@ -732,12 +732,12 @@ fn mk_struct_ser_impl(\n             )\n         );\n \n-        // ast for `__s.emit_field($(name), $(idx), $(expr_lambda))`\n+        // ast for `__s.emit_struct_field($(name), $(idx), $(expr_lambda))`\n         cx.stmt(\n             cx.expr_method_call(\n                 span,\n                 cx.expr_var(span, ~\"__s\"),\n-                cx.ident_of(~\"emit_field\"),\n+                cx.ident_of(~\"emit_struct_field\"),\n                 ~[\n                     cx.lit_str(span, @cx.str_of(field.ident)),\n                     cx.lit_uint(span, idx),\n@@ -786,11 +786,11 @@ fn mk_struct_deser_impl(\n             )\n         );\n \n-        // ast for `__d.read_field($(name), $(idx), $(expr_lambda))`\n+        // ast for `__d.read_struct_field($(name), $(idx), $(expr_lambda))`\n         let expr: @ast::expr = cx.expr_method_call(\n             span,\n             cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_field\"),\n+            cx.ident_of(~\"read_struct_field\"),\n             ~[\n                 cx.lit_str(span, @cx.str_of(field.ident)),\n                 cx.lit_uint(span, idx),\n@@ -1256,7 +1256,7 @@ mod test {\n         fn emit_struct(&self, name: &str, +len: uint, f: &fn()) {\n             self.add_to_log(CallToEmitStruct (name.to_str(),len)); f();\n         }\n-        fn emit_field(&self, name: &str, +idx: uint, f: &fn()) {\n+        fn emit_struct_field(&self, name: &str, +idx: uint, f: &fn()) {\n             self.add_to_log(CallToEmitField (name.to_str(),idx)); f();\n         }\n "}]}