{"sha": "b0d2c6a71485dcba9952cc240b7cb73e85f10f10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZDJjNmE3MTQ4NWRjYmE5OTUyY2MyNDBiN2NiNzNlODVmMTBmMTA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-16T05:57:41Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-17T00:53:35Z"}, "message": "Rollup merge of #22294 - nikomatsakis:integer-audit, r=huonw\n\ncc https://github.com/rust-lang/rust/issues/22240", "tree": {"sha": "6868703c1e7b3257915a81c82810371c96194a01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6868703c1e7b3257915a81c82810371c96194a01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0d2c6a71485dcba9952cc240b7cb73e85f10f10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0d2c6a71485dcba9952cc240b7cb73e85f10f10", "html_url": "https://github.com/rust-lang/rust/commit/b0d2c6a71485dcba9952cc240b7cb73e85f10f10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0d2c6a71485dcba9952cc240b7cb73e85f10f10/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d660739f9adf0cec515f4a80096d6345dab34080", "url": "https://api.github.com/repos/rust-lang/rust/commits/d660739f9adf0cec515f4a80096d6345dab34080", "html_url": "https://github.com/rust-lang/rust/commit/d660739f9adf0cec515f4a80096d6345dab34080"}, {"sha": "6171c35d6e084e1fe2cb21326008bb001c1b4002", "url": "https://api.github.com/repos/rust-lang/rust/commits/6171c35d6e084e1fe2cb21326008bb001c1b4002", "html_url": "https://github.com/rust-lang/rust/commit/6171c35d6e084e1fe2cb21326008bb001c1b4002"}], "stats": {"total": 220, "additions": 110, "deletions": 110}, "files": [{"sha": "562a597cccf1d1947e48363a3031cb26e0a8d52b", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0d2c6a71485dcba9952cc240b7cb73e85f10f10/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d2c6a71485dcba9952cc240b7cb73e85f10f10/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=b0d2c6a71485dcba9952cc240b7cb73e85f10f10", "patch": "@@ -72,7 +72,7 @@ impl<T, F> Finally<T> for F where F: FnMut() -> T {\n /// ```\n /// use std::finally::try_finally;\n ///\n-/// struct State<'a> { buffer: &'a mut [u8], len: uint }\n+/// struct State<'a> { buffer: &'a mut [u8], len: usize }\n /// # let mut buf = [];\n /// let mut state = State { buffer: &mut buf, len: 0 };\n /// try_finally("}, {"sha": "fbd7f840da6e15748e2972899771deaa7b5307d5", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b0d2c6a71485dcba9952cc240b7cb73e85f10f10/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d2c6a71485dcba9952cc240b7cb73e85f10f10/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=b0d2c6a71485dcba9952cc240b7cb73e85f10f10", "patch": "@@ -37,8 +37,8 @@\n //!\n //! #[derive(Debug)]\n //! struct Point {\n-//!     x: int,\n-//!     y: int\n+//!     x: i32,\n+//!     y: i32\n //! }\n //!\n //! impl Add for Point {\n@@ -206,7 +206,7 @@ macro_rules! add_impl {\n     )*)\n }\n \n-add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n+add_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n \n /// The `Sub` trait is used to specify the functionality of `-`.\n ///\n@@ -259,7 +259,7 @@ macro_rules! sub_impl {\n     )*)\n }\n \n-sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n+sub_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n \n /// The `Mul` trait is used to specify the functionality of `*`.\n ///\n@@ -312,7 +312,7 @@ macro_rules! mul_impl {\n     )*)\n }\n \n-mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n+mul_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n \n /// The `Div` trait is used to specify the functionality of `/`.\n ///\n@@ -365,7 +365,7 @@ macro_rules! div_impl {\n     )*)\n }\n \n-div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n+div_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n \n /// The `Rem` trait is used to specify the functionality of `%`.\n ///\n@@ -435,7 +435,7 @@ macro_rules! rem_float_impl {\n     }\n }\n \n-rem_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+rem_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n rem_float_impl! { f32, fmodf }\n rem_float_impl! { f64, fmod }\n \n@@ -506,9 +506,9 @@ macro_rules! neg_uint_impl {\n     }\n }\n \n-neg_impl! { int i8 i16 i32 i64 f32 f64 }\n+neg_impl! { isize i8 i16 i32 i64 f32 f64 }\n \n-neg_uint_impl! { uint, int }\n+neg_uint_impl! { usize, isize }\n neg_uint_impl! { u8, i8 }\n neg_uint_impl! { u16, i16 }\n neg_uint_impl! { u32, i32 }\n@@ -566,7 +566,7 @@ macro_rules! not_impl {\n     )*)\n }\n \n-not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+not_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n /// The `BitAnd` trait is used to specify the functionality of `&`.\n ///\n@@ -619,7 +619,7 @@ macro_rules! bitand_impl {\n     )*)\n }\n \n-bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+bitand_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n /// The `BitOr` trait is used to specify the functionality of `|`.\n ///\n@@ -672,7 +672,7 @@ macro_rules! bitor_impl {\n     )*)\n }\n \n-bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+bitor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n /// The `BitXor` trait is used to specify the functionality of `^`.\n ///\n@@ -725,7 +725,7 @@ macro_rules! bitxor_impl {\n     )*)\n }\n \n-bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+bitxor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n /// The `Shl` trait is used to specify the functionality of `<<`.\n ///"}, {"sha": "3dc94ba555f3589bff0aec08c7cfde3f2232bead", "filename": "src/libcore/option.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b0d2c6a71485dcba9952cc240b7cb73e85f10f10/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d2c6a71485dcba9952cc240b7cb73e85f10f10/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b0d2c6a71485dcba9952cc240b7cb73e85f10f10", "patch": "@@ -60,19 +60,19 @@\n //! the optional owned box, `Option<Box<T>>`.\n //!\n //! The following example uses `Option` to create an optional box of\n-//! `int`. Notice that in order to use the inner `int` value first the\n+//! `i32`. Notice that in order to use the inner `i32` value first the\n //! `check_optional` function needs to use pattern matching to\n //! determine whether the box has a value (i.e. it is `Some(...)`) or\n //! not (`None`).\n //!\n //! ```\n-//! let optional: Option<Box<int>> = None;\n+//! let optional: Option<Box<i32>> = None;\n //! check_optional(&optional);\n //!\n-//! let optional: Option<Box<int>> = Some(Box::new(9000));\n+//! let optional: Option<Box<i32>> = Some(Box::new(9000));\n //! check_optional(&optional);\n //!\n-//! fn check_optional(optional: &Option<Box<int>>) {\n+//! fn check_optional(optional: &Option<Box<i32>>) {\n //!     match *optional {\n //!         Some(ref p) => println!(\"have value {}\", p),\n //!         None => println!(\"have no value\")\n@@ -108,7 +108,7 @@\n //! Initialize a result to `None` before a loop:\n //!\n //! ```\n-//! enum Kingdom { Plant(uint, &'static str), Animal(uint, &'static str) }\n+//! enum Kingdom { Plant(u32, &'static str), Animal(u32, &'static str) }\n //!\n //! // A list of data to search through.\n //! let all_the_big_things = [\n@@ -188,10 +188,10 @@ impl<T> Option<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Option<uint> = Some(2);\n+    /// let x: Option<u32> = Some(2);\n     /// assert_eq!(x.is_some(), true);\n     ///\n-    /// let x: Option<uint> = None;\n+    /// let x: Option<u32> = None;\n     /// assert_eq!(x.is_some(), false);\n     /// ```\n     #[inline]\n@@ -208,10 +208,10 @@ impl<T> Option<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Option<uint> = Some(2);\n+    /// let x: Option<u32> = Some(2);\n     /// assert_eq!(x.is_none(), false);\n     ///\n-    /// let x: Option<uint> = None;\n+    /// let x: Option<u32> = None;\n     /// assert_eq!(x.is_none(), true);\n     /// ```\n     #[inline]\n@@ -228,7 +228,7 @@ impl<T> Option<T> {\n     ///\n     /// # Example\n     ///\n-    /// Convert an `Option<String>` into an `Option<int>`, preserving the original.\n+    /// Convert an `Option<String>` into an `Option<usize>`, preserving the original.\n     /// The `map` method takes the `self` argument by value, consuming the original,\n     /// so this technique uses `as_ref` to first take an `Option` to a reference\n     /// to the value inside the original.\n@@ -237,7 +237,7 @@ impl<T> Option<T> {\n     /// let num_as_str: Option<String> = Some(\"10\".to_string());\n     /// // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n     /// // then consume *that* with `map`, leaving `num_as_str` on the stack.\n-    /// let num_as_int: Option<uint> = num_as_str.as_ref().map(|n| n.len());\n+    /// let num_as_int: Option<usize> = num_as_str.as_ref().map(|n| n.len());\n     /// println!(\"still can print num_as_str: {:?}\", num_as_str);\n     /// ```\n     #[inline]\n@@ -406,12 +406,12 @@ impl<T> Option<T> {\n     ///\n     /// # Example\n     ///\n-    /// Convert an `Option<String>` into an `Option<uint>`, consuming the original:\n+    /// Convert an `Option<String>` into an `Option<usize>`, consuming the original:\n     ///\n     /// ```\n     /// let num_as_str: Option<String> = Some(\"10\".to_string());\n     /// // `Option::map` takes self *by value*, consuming `num_as_str`\n-    /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n+    /// let num_as_int: Option<usize> = num_as_str.map(|n| n.len());\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -518,7 +518,7 @@ impl<T> Option<T> {\n     /// let x = Some(4);\n     /// assert_eq!(x.iter().next(), Some(&4));\n     ///\n-    /// let x: Option<uint> = None;\n+    /// let x: Option<u32> = None;\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n@@ -539,7 +539,7 @@ impl<T> Option<T> {\n     /// }\n     /// assert_eq!(x, Some(42));\n     ///\n-    /// let mut x: Option<uint> = None;\n+    /// let mut x: Option<u32> = None;\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n     #[inline]\n@@ -581,15 +581,15 @@ impl<T> Option<T> {\n     /// let y: Option<&str> = None;\n     /// assert_eq!(x.and(y), None);\n     ///\n-    /// let x: Option<uint> = None;\n+    /// let x: Option<u32> = None;\n     /// let y = Some(\"foo\");\n     /// assert_eq!(x.and(y), None);\n     ///\n     /// let x = Some(2);\n     /// let y = Some(\"foo\");\n     /// assert_eq!(x.and(y), Some(\"foo\"));\n     ///\n-    /// let x: Option<uint> = None;\n+    /// let x: Option<u32> = None;\n     /// let y: Option<&str> = None;\n     /// assert_eq!(x.and(y), None);\n     /// ```\n@@ -608,8 +608,8 @@ impl<T> Option<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// fn sq(x: uint) -> Option<uint> { Some(x * x) }\n-    /// fn nope(_: uint) -> Option<uint> { None }\n+    /// fn sq(x: u32) -> Option<u32> { Some(x * x) }\n+    /// fn nope(_: u32) -> Option<u32> { None }\n     ///\n     /// assert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\n     /// assert_eq!(Some(2).and_then(sq).and_then(nope), None);\n@@ -642,7 +642,7 @@ impl<T> Option<T> {\n     /// let y = Some(100);\n     /// assert_eq!(x.or(y), Some(2));\n     ///\n-    /// let x: Option<uint> = None;\n+    /// let x: Option<u32> = None;\n     /// let y = None;\n     /// assert_eq!(x.or(y), None);\n     /// ```\n@@ -690,7 +690,7 @@ impl<T> Option<T> {\n     /// x.take();\n     /// assert_eq!(x, None);\n     ///\n-    /// let mut x: Option<uint> = None;\n+    /// let mut x: Option<u32> = None;\n     /// x.take();\n     /// assert_eq!(x, None);\n     /// ```\n@@ -789,7 +789,7 @@ impl<A> Iterator for Item<A> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         match self.opt {\n             Some(_) => (1, Some(1)),\n             None => (0, Some(0)),\n@@ -817,7 +817,7 @@ impl<'a, A> Iterator for Iter<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a A> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -847,7 +847,7 @@ impl<'a, A> Iterator for IterMut<'a, A> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut A> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -870,7 +870,7 @@ impl<A> Iterator for IntoIter<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -896,11 +896,11 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// checking for overflow:\n     ///\n     /// ```rust\n-    /// use std::uint;\n+    /// use std::u16;\n     ///\n     /// let v = vec!(1, 2);\n-    /// let res: Option<Vec<uint>> = v.iter().map(|&x: &uint|\n-    ///     if x == uint::MAX { None }\n+    /// let res: Option<Vec<u16>> = v.iter().map(|&x: &u16|\n+    ///     if x == u16::MAX { None }\n     ///     else { Some(x + 1) }\n     /// ).collect();\n     /// assert!(res == Some(vec!(2, 3)));"}, {"sha": "072c60c7036cffceb2c5c88beb2e14841ebb7a17", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b0d2c6a71485dcba9952cc240b7cb73e85f10f10/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d2c6a71485dcba9952cc240b7cb73e85f10f10/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b0d2c6a71485dcba9952cc240b7cb73e85f10f10", "patch": "@@ -27,10 +27,10 @@\n //! ## 1. Coerce a reference (`&T`) or mutable reference (`&mut T`).\n //!\n //! ```\n-//! let my_num: int = 10;\n-//! let my_num_ptr: *const int = &my_num;\n-//! let mut my_speed: int = 88;\n-//! let my_speed_ptr: *mut int = &mut my_speed;\n+//! let my_num: i32 = 10;\n+//! let my_num_ptr: *const i32 = &my_num;\n+//! let mut my_speed: i32 = 88;\n+//! let my_speed_ptr: *mut i32 = &mut my_speed;\n //! ```\n //!\n //! This does not take ownership of the original allocation\n@@ -49,15 +49,15 @@\n //! use std::mem;\n //!\n //! unsafe {\n-//!     let my_num: Box<int> = Box::new(10);\n-//!     let my_num: *const int = mem::transmute(my_num);\n-//!     let my_speed: Box<int> = Box::new(88);\n-//!     let my_speed: *mut int = mem::transmute(my_speed);\n+//!     let my_num: Box<i32> = Box::new(10);\n+//!     let my_num: *const i32 = mem::transmute(my_num);\n+//!     let my_speed: Box<i32> = Box::new(88);\n+//!     let my_speed: *mut i32 = mem::transmute(my_speed);\n //!\n //!     // By taking ownership of the original `Box<T>` though\n //!     // we are obligated to transmute it back later to be destroyed.\n-//!     drop(mem::transmute::<_, Box<int>>(my_speed));\n-//!     drop(mem::transmute::<_, Box<int>>(my_num));\n+//!     drop(mem::transmute::<_, Box<i32>>(my_speed));\n+//!     drop(mem::transmute::<_, Box<i32>>(my_num));\n //! }\n //! ```\n //!\n@@ -73,7 +73,7 @@\n //!\n //! fn main() {\n //!     unsafe {\n-//!         let my_num: *mut int = libc::malloc(mem::size_of::<int>() as libc::size_t) as *mut int;\n+//!         let my_num: *mut i32 = libc::malloc(mem::size_of::<i32>() as libc::size_t) as *mut i32;\n //!         if my_num.is_null() {\n //!             panic!(\"failed to allocate memory\");\n //!         }\n@@ -117,7 +117,7 @@ pub use intrinsics::set_memory;\n /// ```\n /// use std::ptr;\n ///\n-/// let p: *const int = ptr::null();\n+/// let p: *const i32 = ptr::null();\n /// assert!(p.is_null());\n /// ```\n #[inline]\n@@ -131,7 +131,7 @@ pub fn null<T>() -> *const T { 0 as *const T }\n /// ```\n /// use std::ptr;\n ///\n-/// let p: *mut int = ptr::null_mut();\n+/// let p: *mut i32 = ptr::null_mut();\n /// assert!(p.is_null());\n /// ```\n #[inline]\n@@ -148,7 +148,7 @@ pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n #[inline]\n #[unstable(feature = \"core\",\n            reason = \"may play a larger role in std::ptr future extensions\")]\n-pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n+pub unsafe fn zero_memory<T>(dst: *mut T, count: usize) {\n     set_memory(dst, 0, count);\n }\n \n@@ -276,7 +276,7 @@ pub trait PtrExt: Sized {\n     /// Otherwise `offset` invokes Undefined Behaviour, regardless of whether\n     /// the pointer is used.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: int) -> Self;\n+    unsafe fn offset(self, count: isize) -> Self;\n }\n \n /// Methods on mutable raw pointers\n@@ -303,11 +303,11 @@ impl<T> PtrExt for *const T {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_null(self) -> bool { self as uint == 0 }\n+    fn is_null(self) -> bool { self as usize == 0 }\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: int) -> *const T {\n+    unsafe fn offset(self, count: isize) -> *const T {\n         intrinsics::offset(self, count)\n     }\n \n@@ -330,11 +330,11 @@ impl<T> PtrExt for *mut T {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn is_null(self) -> bool { self as uint == 0 }\n+    fn is_null(self) -> bool { self as usize == 0 }\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: int) -> *mut T {\n+    unsafe fn offset(self, count: isize) -> *mut T {\n         intrinsics::offset(self, count) as *mut T\n     }\n \n@@ -553,7 +553,7 @@ impl<T> Unique<T> {\n     /// Return an (unsafe) pointer into the memory owned by `self`.\n     #[unstable(feature = \"core\",\n                reason = \"recently added to this module\")]\n-    pub unsafe fn offset(self, offset: int) -> *mut T {\n+    pub unsafe fn offset(self, offset: isize) -> *mut T {\n         self.ptr.offset(offset)\n     }\n }"}, {"sha": "1a874ee178ba0fd8c477c69e2232b01a1d50edd5", "filename": "src/libcore/result.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b0d2c6a71485dcba9952cc240b7cb73e85f10f10/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0d2c6a71485dcba9952cc240b7cb73e85f10f10/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=b0d2c6a71485dcba9952cc240b7cb73e85f10f10", "patch": "@@ -311,10 +311,10 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.ok(), Some(2));\n     ///\n-    /// let x: Result<uint, &str> = Err(\"Nothing here\");\n+    /// let x: Result<u32, &str> = Err(\"Nothing here\");\n     /// assert_eq!(x.ok(), None);\n     /// ```\n     #[inline]\n@@ -334,10 +334,10 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.err(), None);\n     ///\n-    /// let x: Result<uint, &str> = Err(\"Nothing here\");\n+    /// let x: Result<u32, &str> = Err(\"Nothing here\");\n     /// assert_eq!(x.err(), Some(\"Nothing here\"));\n     /// ```\n     #[inline]\n@@ -359,10 +359,10 @@ impl<T, E> Result<T, E> {\n     /// into the original, leaving the original in place.\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.as_ref(), Ok(&2));\n     ///\n-    /// let x: Result<uint, &str> = Err(\"Error\");\n+    /// let x: Result<u32, &str> = Err(\"Error\");\n     /// assert_eq!(x.as_ref(), Err(&\"Error\"));\n     /// ```\n     #[inline]\n@@ -404,7 +404,7 @@ impl<T, E> Result<T, E> {\n     /// Convert from `Result<T, E>` to `&mut [T]` (without copying)\n     ///\n     /// ```\n-    /// let mut x: Result<&str, uint> = Ok(\"Gold\");\n+    /// let mut x: Result<&str, u32> = Ok(\"Gold\");\n     /// {\n     ///     let v = x.as_mut_slice();\n     ///     assert!(v == [\"Gold\"]);\n@@ -413,7 +413,7 @@ impl<T, E> Result<T, E> {\n     /// }\n     /// assert_eq!(x, Ok(\"Silver\"));\n     ///\n-    /// let mut x: Result<&str, uint> = Err(45);\n+    /// let mut x: Result<&str, u32> = Err(45);\n     /// assert!(x.as_mut_slice().is_empty());\n     /// ```\n     #[inline]\n@@ -481,12 +481,12 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// fn stringify(x: uint) -> String { format!(\"error code: {}\", x) }\n+    /// fn stringify(x: u32) -> String { format!(\"error code: {}\", x) }\n     ///\n-    /// let x: Result<uint, uint> = Ok(2);\n+    /// let x: Result<u32, u32> = Ok(2);\n     /// assert_eq!(x.map_err(stringify), Ok(2));\n     ///\n-    /// let x: Result<uint, uint> = Err(13);\n+    /// let x: Result<u32, u32> = Err(13);\n     /// assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n     /// ```\n     #[inline]\n@@ -507,10 +507,10 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(7);\n+    /// let x: Result<u32, &str> = Ok(7);\n     /// assert_eq!(x.iter().next(), Some(&7));\n     ///\n-    /// let x: Result<uint, &str> = Err(\"nothing!\");\n+    /// let x: Result<u32, &str> = Err(\"nothing!\");\n     /// assert_eq!(x.iter().next(), None);\n     /// ```\n     #[inline]\n@@ -524,14 +524,14 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let mut x: Result<uint, &str> = Ok(7);\n+    /// let mut x: Result<u32, &str> = Ok(7);\n     /// match x.iter_mut().next() {\n     ///     Some(&mut ref mut x) => *x = 40,\n     ///     None => {},\n     /// }\n     /// assert_eq!(x, Ok(40));\n     ///\n-    /// let mut x: Result<uint, &str> = Err(\"nothing!\");\n+    /// let mut x: Result<u32, &str> = Err(\"nothing!\");\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n     #[inline]\n@@ -545,12 +545,12 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(5);\n-    /// let v: Vec<uint> = x.into_iter().collect();\n+    /// let x: Result<u32, &str> = Ok(5);\n+    /// let v: Vec<u32> = x.into_iter().collect();\n     /// assert_eq!(v, vec![5]);\n     ///\n-    /// let x: Result<uint, &str> = Err(\"nothing!\");\n-    /// let v: Vec<uint> = x.into_iter().collect();\n+    /// let x: Result<u32, &str> = Err(\"nothing!\");\n+    /// let v: Vec<u32> = x.into_iter().collect();\n     /// assert_eq!(v, vec![]);\n     /// ```\n     #[inline]\n@@ -568,19 +568,19 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Ok(2);\n     /// let y: Result<&str, &str> = Err(\"late error\");\n     /// assert_eq!(x.and(y), Err(\"late error\"));\n     ///\n-    /// let x: Result<uint, &str> = Err(\"early error\");\n+    /// let x: Result<u32, &str> = Err(\"early error\");\n     /// let y: Result<&str, &str> = Ok(\"foo\");\n     /// assert_eq!(x.and(y), Err(\"early error\"));\n     ///\n-    /// let x: Result<uint, &str> = Err(\"not a 2\");\n+    /// let x: Result<u32, &str> = Err(\"not a 2\");\n     /// let y: Result<&str, &str> = Err(\"late error\");\n     /// assert_eq!(x.and(y), Err(\"not a 2\"));\n     ///\n-    /// let x: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Ok(2);\n     /// let y: Result<&str, &str> = Ok(\"different result type\");\n     /// assert_eq!(x.and(y), Ok(\"different result type\"));\n     /// ```\n@@ -600,8 +600,8 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// fn sq(x: uint) -> Result<uint, uint> { Ok(x * x) }\n-    /// fn err(x: uint) -> Result<uint, uint> { Err(x) }\n+    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n+    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n     ///\n     /// assert_eq!(Ok(2).and_then(sq).and_then(sq), Ok(16));\n     /// assert_eq!(Ok(2).and_then(sq).and_then(err), Err(4));\n@@ -622,20 +622,20 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(2);\n-    /// let y: Result<uint, &str> = Err(\"late error\");\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// let y: Result<u32, &str> = Err(\"late error\");\n     /// assert_eq!(x.or(y), Ok(2));\n     ///\n-    /// let x: Result<uint, &str> = Err(\"early error\");\n-    /// let y: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Err(\"early error\");\n+    /// let y: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.or(y), Ok(2));\n     ///\n-    /// let x: Result<uint, &str> = Err(\"not a 2\");\n-    /// let y: Result<uint, &str> = Err(\"late error\");\n+    /// let x: Result<u32, &str> = Err(\"not a 2\");\n+    /// let y: Result<u32, &str> = Err(\"late error\");\n     /// assert_eq!(x.or(y), Err(\"late error\"));\n     ///\n-    /// let x: Result<uint, &str> = Ok(2);\n-    /// let y: Result<uint, &str> = Ok(100);\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// let y: Result<u32, &str> = Ok(100);\n     /// assert_eq!(x.or(y), Ok(2));\n     /// ```\n     #[inline]\n@@ -654,8 +654,8 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// fn sq(x: uint) -> Result<uint, uint> { Ok(x * x) }\n-    /// fn err(x: uint) -> Result<uint, uint> { Err(x) }\n+    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n+    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n     ///\n     /// assert_eq!(Ok(2).or_else(sq).or_else(sq), Ok(2));\n     /// assert_eq!(Ok(2).or_else(err).or_else(sq), Ok(2));\n@@ -678,10 +678,10 @@ impl<T, E> Result<T, E> {\n     ///\n     /// ```\n     /// let optb = 2;\n-    /// let x: Result<uint, &str> = Ok(9);\n+    /// let x: Result<u32, &str> = Ok(9);\n     /// assert_eq!(x.unwrap_or(optb), 9);\n     ///\n-    /// let x: Result<uint, &str> = Err(\"error\");\n+    /// let x: Result<u32, &str> = Err(\"error\");\n     /// assert_eq!(x.unwrap_or(optb), optb);\n     /// ```\n     #[inline]\n@@ -699,7 +699,7 @@ impl<T, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// fn count(x: &str) -> uint { x.len() }\n+    /// fn count(x: &str) -> usize { x.len() }\n     ///\n     /// assert_eq!(Ok(2).unwrap_or_else(count), 2);\n     /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n@@ -726,12 +726,12 @@ impl<T, E: fmt::Debug> Result<T, E> {\n     /// # Example\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Ok(2);\n     /// assert_eq!(x.unwrap(), 2);\n     /// ```\n     ///\n     /// ```{.should_fail}\n-    /// let x: Result<uint, &str> = Err(\"emergency failure\");\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n     /// x.unwrap(); // panics with `emergency failure`\n     /// ```\n     #[inline]\n@@ -757,12 +757,12 @@ impl<T: fmt::Debug, E> Result<T, E> {\n     /// # Example\n     ///\n     /// ```{.should_fail}\n-    /// let x: Result<uint, &str> = Ok(2);\n+    /// let x: Result<u32, &str> = Ok(2);\n     /// x.unwrap_err(); // panics with `2`\n     /// ```\n     ///\n     /// ```\n-    /// let x: Result<uint, &str> = Err(\"emergency failure\");\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n     /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n     /// ```\n     #[inline]\n@@ -811,7 +811,7 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> { self.inner.take() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let n = if self.inner.is_some() {1} else {0};\n         (n, Some(n))\n     }\n@@ -841,7 +841,7 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> { self.inner.take() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let n = if self.inner.is_some() {1} else {0};\n         (n, Some(n))\n     }\n@@ -867,7 +867,7 @@ impl<T> Iterator for IntoIter<T> {\n     #[inline]\n     fn next(&mut self) -> Option<T> { self.inner.take() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let n = if self.inner.is_some() {1} else {0};\n         (n, Some(n))\n     }\n@@ -896,11 +896,11 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// checking for overflow:\n     ///\n     /// ```rust\n-    /// use std::uint;\n+    /// use std::u32;\n     ///\n     /// let v = vec!(1, 2);\n-    /// let res: Result<Vec<uint>, &'static str> = v.iter().map(|&x: &uint|\n-    ///     if x == uint::MAX { Err(\"Overflow!\") }\n+    /// let res: Result<Vec<u32>, &'static str> = v.iter().map(|&x: &u32|\n+    ///     if x == u32::MAX { Err(\"Overflow!\") }\n     ///     else { Ok(x + 1) }\n     /// ).collect();\n     /// assert!(res == Ok(vec!(2, 3)));"}]}