{"sha": "94fccccd2cdba42aed93ad7715e969ab6aad6301", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ZmNjY2NkMmNkYmE0MmFlZDkzYWQ3NzE1ZTk2OWFiNmFhZDYzMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-24T11:02:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-24T11:02:23Z"}, "message": "Auto merge of #72529 - RalfJung:rollup-ydthv90, r=RalfJung\n\nRollup of 3 pull requests\n\nSuccessful merges:\n\n - #72284 (Remove `macro_defs` map)\n - #72393 (Rewrite `Parser::collect_tokens`)\n - #72528 (Fix typo in doc comment.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "aa8d4c31f33695f92860092b05f995d6b2544472", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa8d4c31f33695f92860092b05f995d6b2544472"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94fccccd2cdba42aed93ad7715e969ab6aad6301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94fccccd2cdba42aed93ad7715e969ab6aad6301", "html_url": "https://github.com/rust-lang/rust/commit/94fccccd2cdba42aed93ad7715e969ab6aad6301", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94fccccd2cdba42aed93ad7715e969ab6aad6301/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7726070fa755f660b5da3f82f46e07d9c6866f69", "url": "https://api.github.com/repos/rust-lang/rust/commits/7726070fa755f660b5da3f82f46e07d9c6866f69", "html_url": "https://github.com/rust-lang/rust/commit/7726070fa755f660b5da3f82f46e07d9c6866f69"}, {"sha": "e2e3aacc238abe789170a64467b96fe2d7e41174", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2e3aacc238abe789170a64467b96fe2d7e41174", "html_url": "https://github.com/rust-lang/rust/commit/e2e3aacc238abe789170a64467b96fe2d7e41174"}], "stats": {"total": 255, "additions": 160, "deletions": 95}, "files": [{"sha": "5d98fdeeaf9a5f9693ee3cd343d026e36bf54dc4", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=94fccccd2cdba42aed93ad7715e969ab6aad6301", "patch": "@@ -688,7 +688,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> Span {\n         span.fresh_expansion(ExpnData {\n             allow_internal_unstable,\n-            ..ExpnData::default(ExpnKind::Desugaring(reason), span, self.sess.edition())\n+            ..ExpnData::default(ExpnKind::Desugaring(reason), span, self.sess.edition(), None)\n         })\n     }\n "}, {"sha": "0137080938fdd13637313c96a26c112ac319d576", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=94fccccd2cdba42aed93ad7715e969ab6aad6301", "patch": "@@ -13,6 +13,7 @@ use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{DiagnosticBuilder, ErrorReported};\n use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n use rustc_session::parse::ParseSess;\n+use rustc_span::def_id::DefId;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{AstPass, ExpnData, ExpnId, ExpnKind};\n use rustc_span::source_map::SourceMap;\n@@ -857,7 +858,13 @@ impl SyntaxExtension {\n         SyntaxExtension::default(SyntaxExtensionKind::NonMacroAttr { mark_used }, edition)\n     }\n \n-    pub fn expn_data(&self, parent: ExpnId, call_site: Span, descr: Symbol) -> ExpnData {\n+    pub fn expn_data(\n+        &self,\n+        parent: ExpnId,\n+        call_site: Span,\n+        descr: Symbol,\n+        macro_def_id: Option<DefId>,\n+    ) -> ExpnData {\n         ExpnData {\n             kind: ExpnKind::Macro(self.macro_kind(), descr),\n             parent,\n@@ -867,6 +874,7 @@ impl SyntaxExtension {\n             allow_internal_unsafe: self.allow_internal_unsafe,\n             local_inner_macros: self.local_inner_macros,\n             edition: self.edition,\n+            macro_def_id,\n         }\n     }\n }"}, {"sha": "b505302f62501add8da868130e4401f384afa16b", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=94fccccd2cdba42aed93ad7715e969ab6aad6301", "patch": "@@ -988,6 +988,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                     ExpnKind::Macro(MacroKind::Attr, sym::derive),\n                     item.span(),\n                     self.cx.parse_sess.edition,\n+                    None,\n                 )\n             }),\n             _ => None,"}, {"sha": "b21524cb9bdd2f2258df3ecf5c4d24ac96be4b16", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 113, "deletions": 73, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=94fccccd2cdba42aed93ad7715e969ab6aad6301", "patch": "@@ -118,6 +118,8 @@ impl<'a> Drop for Parser<'a> {\n struct TokenCursor {\n     frame: TokenCursorFrame,\n     stack: Vec<TokenCursorFrame>,\n+    cur_token: Option<TreeAndJoint>,\n+    collecting: Option<Collecting>,\n }\n \n #[derive(Clone)]\n@@ -127,30 +129,24 @@ struct TokenCursorFrame {\n     open_delim: bool,\n     tree_cursor: tokenstream::Cursor,\n     close_delim: bool,\n-    last_token: LastToken,\n }\n \n-/// This is used in `TokenCursorFrame` above to track tokens that are consumed\n-/// by the parser, and then that's transitively used to record the tokens that\n-/// each parse AST item is created with.\n-///\n-/// Right now this has two states, either collecting tokens or not collecting\n-/// tokens. If we're collecting tokens we just save everything off into a local\n-/// `Vec`. This should eventually though likely save tokens from the original\n-/// token stream and just use slicing of token streams to avoid creation of a\n-/// whole new vector.\n-///\n-/// The second state is where we're passively not recording tokens, but the last\n-/// token is still tracked for when we want to start recording tokens. This\n-/// \"last token\" means that when we start recording tokens we'll want to ensure\n-/// that this, the first token, is included in the output.\n-///\n-/// You can find some more example usage of this in the `collect_tokens` method\n-/// on the parser.\n-#[derive(Clone)]\n-enum LastToken {\n-    Collecting(Vec<TreeAndJoint>),\n-    Was(Option<TreeAndJoint>),\n+/// Used to track additional state needed by `collect_tokens`\n+#[derive(Clone, Debug)]\n+struct Collecting {\n+    /// Holds the current tokens captured during the most\n+    /// recent call to `collect_tokens`\n+    buf: Vec<TreeAndJoint>,\n+    /// The depth of the `TokenCursor` stack at the time\n+    /// collection was started. When we encounter a `TokenTree::Delimited`,\n+    /// we want to record the `TokenTree::Delimited` itself,\n+    /// but *not* any of the inner tokens while we are inside\n+    /// the new frame (this would cause us to record duplicate tokens).\n+    ///\n+    /// This `depth` fields tracks stack depth we are recording tokens.\n+    /// Only tokens encountered at this depth will be recorded. See\n+    /// `TokenCursor::next` for more details.\n+    depth: usize,\n }\n \n impl TokenCursorFrame {\n@@ -161,7 +157,6 @@ impl TokenCursorFrame {\n             open_delim: delim == token::NoDelim,\n             tree_cursor: tts.clone().into_trees(),\n             close_delim: delim == token::NoDelim,\n-            last_token: LastToken::Was(None),\n         }\n     }\n }\n@@ -171,25 +166,38 @@ impl TokenCursor {\n         loop {\n             let tree = if !self.frame.open_delim {\n                 self.frame.open_delim = true;\n-                TokenTree::open_tt(self.frame.span, self.frame.delim)\n-            } else if let Some(tree) = self.frame.tree_cursor.next() {\n+                TokenTree::open_tt(self.frame.span, self.frame.delim).into()\n+            } else if let Some(tree) = self.frame.tree_cursor.next_with_joint() {\n                 tree\n             } else if !self.frame.close_delim {\n                 self.frame.close_delim = true;\n-                TokenTree::close_tt(self.frame.span, self.frame.delim)\n+                TokenTree::close_tt(self.frame.span, self.frame.delim).into()\n             } else if let Some(frame) = self.stack.pop() {\n                 self.frame = frame;\n                 continue;\n             } else {\n                 return Token::new(token::Eof, DUMMY_SP);\n             };\n \n-            match self.frame.last_token {\n-                LastToken::Collecting(ref mut v) => v.push(tree.clone().into()),\n-                LastToken::Was(ref mut t) => *t = Some(tree.clone().into()),\n+            // Don't set an open delimiter as our current token - we want\n+            // to leave it as the full `TokenTree::Delimited` from the previous\n+            // iteration of this loop\n+            if !matches!(tree.0, TokenTree::Token(Token { kind: TokenKind::OpenDelim(_), .. })) {\n+                self.cur_token = Some(tree.clone());\n+            }\n+\n+            if let Some(collecting) = &mut self.collecting {\n+                if collecting.depth == self.stack.len() {\n+                    debug!(\n+                        \"TokenCursor::next():  collected {:?} at depth {:?}\",\n+                        tree,\n+                        self.stack.len()\n+                    );\n+                    collecting.buf.push(tree.clone().into())\n+                }\n             }\n \n-            match tree {\n+            match tree.0 {\n                 TokenTree::Token(token) => return token,\n                 TokenTree::Delimited(sp, delim, tts) => {\n                     let frame = TokenCursorFrame::new(sp, delim, &tts);\n@@ -350,6 +358,8 @@ impl<'a> Parser<'a> {\n             token_cursor: TokenCursor {\n                 frame: TokenCursorFrame::new(DelimSpan::dummy(), token::NoDelim, &tokens),\n                 stack: Vec::new(),\n+                cur_token: None,\n+                collecting: None,\n             },\n             desugar_doc_comments,\n             unmatched_angle_bracket_count: 0,\n@@ -1105,65 +1115,95 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Records all tokens consumed by the provided callback,\n+    /// including the current token. These tokens are collected\n+    /// into a `TokenStream`, and returned along with the result\n+    /// of the callback.\n+    ///\n+    /// Note: If your callback consumes an opening delimiter\n+    /// (including the case where you call `collect_tokens`\n+    /// when the current token is an opening delimeter),\n+    /// you must also consume the corresponding closing delimiter.\n+    ///\n+    /// That is, you can consume\n+    /// `something ([{ }])` or `([{}])`, but not `([{}]`\n+    ///\n+    /// This restriction shouldn't be an issue in practice,\n+    /// since this function is used to record the tokens for\n+    /// a parsed AST item, which always has matching delimiters.\n     fn collect_tokens<R>(\n         &mut self,\n         f: impl FnOnce(&mut Self) -> PResult<'a, R>,\n     ) -> PResult<'a, (R, TokenStream)> {\n         // Record all tokens we parse when parsing this item.\n-        let mut tokens = Vec::new();\n-        let prev_collecting = match self.token_cursor.frame.last_token {\n-            LastToken::Collecting(ref mut list) => Some(mem::take(list)),\n-            LastToken::Was(ref mut last) => {\n-                tokens.extend(last.take());\n-                None\n-            }\n-        };\n-        self.token_cursor.frame.last_token = LastToken::Collecting(tokens);\n-        let prev = self.token_cursor.stack.len();\n+        let tokens: Vec<TreeAndJoint> = self.token_cursor.cur_token.clone().into_iter().collect();\n+        debug!(\"collect_tokens: starting with {:?}\", tokens);\n+\n+        // We need special handling for the case where `collect_tokens` is called\n+        // on an opening delimeter (e.g. '('). At this point, we have already pushed\n+        // a new frame - however, we want to record the original `TokenTree::Delimited`,\n+        // for consistency with the case where we start recording one token earlier.\n+        // See `TokenCursor::next` to see how `cur_token` is set up.\n+        let prev_depth =\n+            if matches!(self.token_cursor.cur_token, Some((TokenTree::Delimited(..), _))) {\n+                if self.token_cursor.stack.is_empty() {\n+                    // There is nothing below us in the stack that\n+                    // the function could consume, so the only thing it can legally\n+                    // capture is the entire contents of the current frame.\n+                    return Ok((f(self)?, TokenStream::new(tokens)));\n+                }\n+                // We have already recorded the full `TokenTree::Delimited` when we created\n+                // our `tokens` vector at the start of this function. We are now inside\n+                // a new frame corresponding to the `TokenTree::Delimited` we already recoreded.\n+                // We don't want to record any of the tokens inside this frame, since they\n+                // will be duplicates of the tokens nested inside the `TokenTree::Delimited`.\n+                // Therefore, we set our recording depth to the *previous* frame. This allows\n+                // us to record a sequence like: `(foo).bar()`: the `(foo)` will be recored\n+                // as our initial `cur_token`, while the `.bar()` will be recored after we\n+                // pop the `(foo)` frame.\n+                self.token_cursor.stack.len() - 1\n+            } else {\n+                self.token_cursor.stack.len()\n+            };\n+        let prev_collecting =\n+            self.token_cursor.collecting.replace(Collecting { buf: tokens, depth: prev_depth });\n+\n         let ret = f(self);\n-        let last_token = if self.token_cursor.stack.len() == prev {\n-            &mut self.token_cursor.frame.last_token\n-        } else if self.token_cursor.stack.get(prev).is_none() {\n-            // This can happen due to a bad interaction of two unrelated recovery mechanisms with\n-            // mismatched delimiters *and* recovery lookahead on the likely typo `pub ident(`\n-            // (#62881).\n-            return Ok((ret?, TokenStream::default()));\n+\n+        let mut collected_tokens = if let Some(collecting) = self.token_cursor.collecting.take() {\n+            collecting.buf\n         } else {\n-            &mut self.token_cursor.stack[prev].last_token\n+            let msg = format!(\"our vector went away?\");\n+            debug!(\"collect_tokens: {}\", msg);\n+            self.sess.span_diagnostic.delay_span_bug(self.token.span, &msg);\n+            // This can happen due to a bad interaction of two unrelated recovery mechanisms\n+            // with mismatched delimiters *and* recovery lookahead on the likely typo\n+            // `pub ident(` (#62895, different but similar to the case above).\n+            return Ok((ret?, TokenStream::default()));\n         };\n \n-        // Pull out the tokens that we've collected from the call to `f` above.\n-        let mut collected_tokens = match *last_token {\n-            LastToken::Collecting(ref mut v) => mem::take(v),\n-            LastToken::Was(ref was) => {\n-                let msg = format!(\"our vector went away? - found Was({:?})\", was);\n-                debug!(\"collect_tokens: {}\", msg);\n-                self.sess.span_diagnostic.delay_span_bug(self.token.span, &msg);\n-                // This can happen due to a bad interaction of two unrelated recovery mechanisms\n-                // with mismatched delimiters *and* recovery lookahead on the likely typo\n-                // `pub ident(` (#62895, different but similar to the case above).\n-                return Ok((ret?, TokenStream::default()));\n-            }\n-        };\n+        debug!(\"collect_tokens: got raw tokens {:?}\", collected_tokens);\n \n         // If we're not at EOF our current token wasn't actually consumed by\n         // `f`, but it'll still be in our list that we pulled out. In that case\n         // put it back.\n         let extra_token = if self.token != token::Eof { collected_tokens.pop() } else { None };\n \n-        // If we were previously collecting tokens, then this was a recursive\n-        // call. In that case we need to record all the tokens we collected in\n-        // our parent list as well. To do that we push a clone of our stream\n-        // onto the previous list.\n-        match prev_collecting {\n-            Some(mut list) => {\n-                list.extend(collected_tokens.iter().cloned());\n-                list.extend(extra_token);\n-                *last_token = LastToken::Collecting(list);\n-            }\n-            None => {\n-                *last_token = LastToken::Was(extra_token);\n+        if let Some(mut collecting) = prev_collecting {\n+            // If we were previously collecting at the same depth,\n+            // then the previous call to `collect_tokens` needs to see\n+            // the tokens we just recorded.\n+            //\n+            // If we were previously recording at an lower `depth`,\n+            // then the previous `collect_tokens` call already recorded\n+            // this entire frame in the form of a `TokenTree::Delimited`,\n+            // so there is nothing else for us to do.\n+            if collecting.depth == prev_depth {\n+                collecting.buf.extend(collected_tokens.iter().cloned());\n+                collecting.buf.extend(extra_token);\n+                debug!(\"collect_tokens: updating previous buf to {:?}\", collecting);\n             }\n+            self.token_cursor.collecting = Some(collecting)\n         }\n \n         Ok((ret?, TokenStream::new(collected_tokens)))"}, {"sha": "c32b823fe73b20a1f808653622c98ad2f7f92491", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=94fccccd2cdba42aed93ad7715e969ab6aad6301", "patch": "@@ -126,8 +126,8 @@ impl<'a> Resolver<'a> {\n     }\n \n     crate fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n-        let def_id = match self.macro_defs.get(&expn_id) {\n-            Some(def_id) => *def_id,\n+        let def_id = match expn_id.expn_data().macro_def_id {\n+            Some(def_id) => def_id,\n             None => return self.ast_transform_scopes.get(&expn_id).unwrap_or(&self.graph_root),\n         };\n         if let Some(id) = self.definitions.as_local_node_id(def_id) {"}, {"sha": "34368a07071fe14275a0c0101b8bf969069d28bf", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=94fccccd2cdba42aed93ad7715e969ab6aad6301", "patch": "@@ -922,7 +922,6 @@ pub struct Resolver<'a> {\n     dummy_ext_bang: Lrc<SyntaxExtension>,\n     dummy_ext_derive: Lrc<SyntaxExtension>,\n     non_macro_attrs: [Lrc<SyntaxExtension>; 2],\n-    macro_defs: FxHashMap<ExpnId, DefId>,\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n     ast_transform_scopes: FxHashMap<ExpnId, Module<'a>>,\n     unused_macros: NodeMap<Span>,\n@@ -1152,9 +1151,6 @@ impl<'a> Resolver<'a> {\n         let mut invocation_parent_scopes = FxHashMap::default();\n         invocation_parent_scopes.insert(ExpnId::root(), ParentScope::module(graph_root));\n \n-        let mut macro_defs = FxHashMap::default();\n-        macro_defs.insert(ExpnId::root(), root_def_id);\n-\n         let features = session.features_untracked();\n         let non_macro_attr =\n             |mark_used| Lrc::new(SyntaxExtension::non_macro_attr(mark_used, session.edition()));\n@@ -1229,7 +1225,6 @@ impl<'a> Resolver<'a> {\n             invocation_parent_scopes,\n             output_macro_rules_scopes: Default::default(),\n             helper_attrs: Default::default(),\n-            macro_defs,\n             local_macro_def_scopes: FxHashMap::default(),\n             name_already_seen: FxHashMap::default(),\n             potentially_unused_imports: Vec::new(),\n@@ -1335,8 +1330,8 @@ impl<'a> Resolver<'a> {\n \n     fn macro_def(&self, mut ctxt: SyntaxContext) -> DefId {\n         loop {\n-            match self.macro_defs.get(&ctxt.outer_expn()) {\n-                Some(&def_id) => return def_id,\n+            match ctxt.outer_expn().expn_data().macro_def_id {\n+                Some(def_id) => return def_id,\n                 None => ctxt.remove_mark(),\n             };\n         }\n@@ -1820,7 +1815,7 @@ impl<'a> Resolver<'a> {\n                 && module.expansion.is_descendant_of(parent.expansion)\n             {\n                 // The macro is a proc macro derive\n-                if let Some(&def_id) = self.macro_defs.get(&module.expansion) {\n+                if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n                     if let Some(ext) = self.get_macro_by_def_id(def_id) {\n                         if !ext.is_builtin && ext.macro_kind() == MacroKind::Derive {\n                             if parent.expansion.outer_expn_is_descendant_of(span.ctxt()) {"}, {"sha": "7027c8262678774fca3d3c5f707e5de79f7a15dd", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=94fccccd2cdba42aed93ad7715e969ab6aad6301", "patch": "@@ -186,6 +186,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             call_site,\n             self.session.edition(),\n             features.into(),\n+            None,\n         )));\n \n         let parent_scope = if let Some(module_id) = parent_module_id {\n@@ -290,13 +291,17 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, force)?;\n \n         let span = invoc.span();\n-        invoc_id.set_expn_data(ext.expn_data(parent_scope.expansion, span, fast_print_path(path)));\n-\n-        if let Res::Def(_, def_id) = res {\n+        invoc_id.set_expn_data(ext.expn_data(\n+            parent_scope.expansion,\n+            span,\n+            fast_print_path(path),\n+            res.opt_def_id(),\n+        ));\n+\n+        if let Res::Def(_, _) = res {\n             if after_derive {\n                 self.session.span_err(span, \"macro attributes must be placed before `#[derive]`\");\n             }\n-            self.macro_defs.insert(invoc_id, def_id);\n             let normal_module_def_id = self.macro_def_scope(invoc_id).normal_ancestor_id;\n             self.definitions.add_parent_module_of_macro_def(invoc_id, normal_module_def_id);\n         }"}, {"sha": "c0fb84e741f4a9f56111f003678ad26512b7580a", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=94fccccd2cdba42aed93ad7715e969ab6aad6301", "patch": "@@ -25,6 +25,7 @@\n // because getting it wrong can lead to nested `HygieneData::with` calls that\n // trigger runtime aborts. (Fortunately these are obvious and easy to fix.)\n \n+use crate::def_id::{DefId, CRATE_DEF_INDEX};\n use crate::edition::Edition;\n use crate::symbol::{kw, sym, Symbol};\n use crate::GLOBALS;\n@@ -155,7 +156,12 @@ crate struct HygieneData {\n impl HygieneData {\n     crate fn new(edition: Edition) -> Self {\n         HygieneData {\n-            expn_data: vec![Some(ExpnData::default(ExpnKind::Root, DUMMY_SP, edition))],\n+            expn_data: vec![Some(ExpnData::default(\n+                ExpnKind::Root,\n+                DUMMY_SP,\n+                edition,\n+                Some(DefId::local(CRATE_DEF_INDEX)),\n+            ))],\n             syntax_context_data: vec![SyntaxContextData {\n                 outer_expn: ExpnId::root(),\n                 outer_transparency: Transparency::Opaque,\n@@ -673,11 +679,19 @@ pub struct ExpnData {\n     pub local_inner_macros: bool,\n     /// Edition of the crate in which the macro is defined.\n     pub edition: Edition,\n+    /// The `DefId` of the macro being invoked,\n+    /// if this `ExpnData` corresponds to a macro invocation\n+    pub macro_def_id: Option<DefId>,\n }\n \n impl ExpnData {\n     /// Constructs expansion data with default properties.\n-    pub fn default(kind: ExpnKind, call_site: Span, edition: Edition) -> ExpnData {\n+    pub fn default(\n+        kind: ExpnKind,\n+        call_site: Span,\n+        edition: Edition,\n+        macro_def_id: Option<DefId>,\n+    ) -> ExpnData {\n         ExpnData {\n             kind,\n             parent: ExpnId::root(),\n@@ -687,6 +701,7 @@ impl ExpnData {\n             allow_internal_unsafe: false,\n             local_inner_macros: false,\n             edition,\n+            macro_def_id,\n         }\n     }\n \n@@ -695,10 +710,11 @@ impl ExpnData {\n         call_site: Span,\n         edition: Edition,\n         allow_internal_unstable: Lrc<[Symbol]>,\n+        macro_def_id: Option<DefId>,\n     ) -> ExpnData {\n         ExpnData {\n             allow_internal_unstable: Some(allow_internal_unstable),\n-            ..ExpnData::default(kind, call_site, edition)\n+            ..ExpnData::default(kind, call_site, edition, macro_def_id)\n         }\n     }\n "}, {"sha": "7dc822db3d0271fe7266a275e3854cf6391f5186", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=94fccccd2cdba42aed93ad7715e969ab6aad6301", "patch": "@@ -272,7 +272,7 @@ impl Once {\n     /// result in an immediate panic. If `f` panics, the `Once` will remain\n     /// in a poison state. If `f` does _not_ panic, the `Once` will no\n     /// longer be in a poison state and all future calls to `call_once` or\n-    /// `call_one_force` will be no-ops.\n+    /// `call_once_force` will be no-ops.\n     ///\n     /// The closure `f` is yielded a [`OnceState`] structure which can be used\n     /// to query the poison status of the `Once`."}, {"sha": "f60b6a00be1298f3afb7fc3ab5fbf1d460084dd6", "filename": "src/test/ui/ast-json/ast-json-noexpand-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout?ref=94fccccd2cdba42aed93ad7715e969ab6aad6301", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"core\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Semi\",\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}\n+{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"core\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Semi\",\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}"}, {"sha": "42e7e789980634d3eb17b435e965b80785a858bf", "filename": "src/test/ui/ast-json/ast-json-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/94fccccd2cdba42aed93ad7715e969ab6aad6301/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout?ref=94fccccd2cdba42aed93ad7715e969ab6aad6301", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"core\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Semi\",\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}\n+{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":\"Empty\"}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"core\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Semi\",\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}}],\"inline\":true},\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}]},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}]}}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"span\":{\"lo\":0,\"hi\":0},\"proc_macros\":[]}"}]}