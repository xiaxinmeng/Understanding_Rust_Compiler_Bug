{"sha": "43c9c637d345ca75ffec7583806ebd8b0520e31b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzYzljNjM3ZDM0NWNhNzVmZmVjNzU4MzgwNmViZDhiMDUyMGUzMWI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-08T23:34:37Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-09T01:19:26Z"}, "message": "doc: Update to new trait syntax", "tree": {"sha": "0afa4724f2768937de474711b6c4cdb971da8890", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0afa4724f2768937de474711b6c4cdb971da8890"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43c9c637d345ca75ffec7583806ebd8b0520e31b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43c9c637d345ca75ffec7583806ebd8b0520e31b", "html_url": "https://github.com/rust-lang/rust/commit/43c9c637d345ca75ffec7583806ebd8b0520e31b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43c9c637d345ca75ffec7583806ebd8b0520e31b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a0720b439a4692f55d3b9951e74d452a7aef802", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a0720b439a4692f55d3b9951e74d452a7aef802", "html_url": "https://github.com/rust-lang/rust/commit/6a0720b439a4692f55d3b9951e74d452a7aef802"}], "stats": {"total": 54, "additions": 19, "deletions": 35}, "files": [{"sha": "9d7d9ee473cd5fa7f323fc62fe4c0dd69697f21b", "filename": "doc/rust.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43c9c637d345ca75ffec7583806ebd8b0520e31b/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/43c9c637d345ca75ffec7583806ebd8b0520e31b/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=43c9c637d345ca75ffec7583806ebd8b0520e31b", "patch": "@@ -1299,7 +1299,7 @@ type.\n \n ~~~~\n # trait shape { }\n-# impl of shape for int { }\n+# impl int: shape { }\n # let mycircle = 0;\n \n let myshape: shape = mycircle as shape;\n@@ -1325,7 +1325,7 @@ An _implementation item_ provides an implementation of a\n \n type circle = {radius: float, center: point};\n \n-impl circle_shape of shape for circle {\n+impl circle: shape {\n     fn draw(s: surface) { do_draw_circle(s, self); }\n     fn bounding_box() -> bounding_box {\n         let r = self.radius;\n@@ -1363,10 +1363,10 @@ specified, after the `impl` keyword.\n ~~~~\n # trait seq<T> { }\n \n-impl <T> of seq<T> for ~[T] {\n+impl<T> ~[T]: seq<T> {\n     /* ... */\n }\n-impl of seq<bool> for u32 {\n+impl u32: seq<bool> {\n    /* Treat the integer as a sequence of bits */\n }\n ~~~~\n@@ -2728,7 +2728,7 @@ trait printable {\n   fn to_str() -> ~str;\n }\n \n-impl of printable for ~str {\n+impl ~str: printable {\n   fn to_str() -> ~str { self }\n }\n \n@@ -2775,7 +2775,7 @@ trait printable {\n   fn to_str() -> ~str;\n }\n \n-impl of printable for ~str {\n+impl ~str: printable {\n   fn to_str() -> ~str { self }\n }\n ~~~~~~"}, {"sha": "420b48db68c5e46285f56d9a47e58f5574f4485c", "filename": "doc/tutorial.md", "status": "modified", "additions": 13, "deletions": 29, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/43c9c637d345ca75ffec7583806ebd8b0520e31b/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/43c9c637d345ca75ffec7583806ebd8b0520e31b/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=43c9c637d345ca75ffec7583806ebd8b0520e31b", "patch": "@@ -74,7 +74,7 @@ Here's a parallel game of rock, paper, scissors to whet your appetite.\n ~~~~\n use std;\n \n-import comm::{listen, methods};\n+import comm::listen;\n import task::spawn;\n import iter::repeat;\n import rand::{seeded_rng, seed};\n@@ -2440,10 +2440,10 @@ is used. This defines implementations of `to_str` for the `int` and\n \n ~~~~\n # trait to_str { fn to_str() -> ~str; }\n-impl of to_str for int {\n+impl int: to_str {\n     fn to_str() -> ~str { int::to_str(self, 10u) }\n }\n-impl of to_str for ~str {\n+impl ~str: to_str {\n     fn to_str() -> ~str { self }\n }\n ~~~~\n@@ -2454,22 +2454,6 @@ static overloading\u2014when the Rust compiler sees the `to_str` method\n call, it looks for an implementation that matches the type with a\n method that matches the name, and simply calls that.\n \n-## Scoping\n-\n-Implementations are not globally visible. Resolving a method to an\n-implementation requires that implementation to be in scope. You can\n-import and export implementations using the name of the trait they\n-implement (multiple implementations with the same name can be in scope\n-without problems). Or you can give them an explicit name if you\n-prefer, using this syntax:\n-\n-~~~~\n-# trait to_str { fn to_str() -> ~str; }\n-impl nil_to_str of to_str for () {\n-    fn to_str() -> ~str { ~\"()\" }\n-}\n-~~~~\n-\n ## Bounded type parameters\n \n The useful thing about value polymorphism is that it does not have to\n@@ -2510,7 +2494,7 @@ trait seq<T> {\n     fn len() -> uint;\n     fn iter(fn(T));\n }\n-impl <T> of seq<T> for ~[T] {\n+impl<T> ~[T]: seq<T> {\n     fn len() -> uint { vec::len(self) }\n     fn iter(b: fn(T)) {\n         for self.each |elt| { b(elt); }\n@@ -2541,7 +2525,7 @@ trait eq {\n   fn equals(&&other: self) -> bool;\n }\n \n-impl of eq for int {\n+impl int: eq {\n   fn equals(&&other: int) -> bool { other == self }\n }\n ~~~~\n@@ -2558,7 +2542,7 @@ However, consider this function:\n ~~~~\n # type circle = int; type rectangle = int;\n # trait drawable { fn draw(); }\n-# impl of drawable for int { fn draw() {} }\n+# impl int: drawable { fn draw() {} }\n # fn new_circle() -> int { 1 }\n fn draw_all<T: drawable>(shapes: ~[T]) {\n     for shapes.each |shape| { shape.draw(); }\n@@ -2595,7 +2579,7 @@ to a trait type:\n ~~~~\n # type circle = int; type rectangle = int;\n # trait drawable { fn draw(); }\n-# impl of drawable for int { fn draw() {} }\n+# impl int: drawable { fn draw() {} }\n # fn new_circle() -> int { 1 }\n # fn new_rectangle() -> int { 2 }\n # fn draw_all(shapes: ~[drawable]) {}\n@@ -2909,7 +2893,7 @@ in parallel.  We might write something like:\n \n ~~~~\n import task::spawn;\n-import comm::{port, chan, methods};\n+import comm::{port, chan};\n \n let port = port();\n let chan = port.chan();\n@@ -2939,7 +2923,7 @@ once it is complete.  The second line creates a channel for sending\n integers to the port `port`:\n \n ~~~~\n-# import comm::{port, chan, methods};\n+# import comm::{port, chan};\n # let port = port::<int>();\n let chan = port.chan();\n ~~~~\n@@ -2949,7 +2933,7 @@ The next statement actually spawns the child:\n \n ~~~~\n # import task::{spawn};\n-# import comm::{port, chan, methods};\n+# import comm::{port, chan};\n # fn some_expensive_computation() -> int { 42 }\n # let port = port();\n # let chan = port.chan();\n@@ -2969,7 +2953,7 @@ some other expensive computation and then waiting for the child's result\n to arrive on the port:\n \n ~~~~\n-# import comm::{port, chan, methods};\n+# import comm::{port, chan};\n # fn some_other_expensive_computation() {}\n # let port = port::<int>();\n # let chan = chan::<int>(port);\n@@ -2991,7 +2975,7 @@ the string in response.  The child terminates when `0` is received.\n Here is the function that implements the child task:\n \n ~~~~\n-# import comm::{port, chan, methods};\n+# import comm::{port, chan};\n fn stringifier(from_parent: port<uint>,\n                to_parent: chan<~str>) {\n     let mut value: uint;\n@@ -3015,7 +2999,7 @@ Here is the code for the parent task:\n \n ~~~~\n # import task::{spawn_conversation};\n-# import comm::{chan, port, methods};\n+# import comm::{chan, port};\n # fn stringifier(from_parent: comm::port<uint>,\n #                to_parent: comm::chan<~str>) {\n #     comm::send(to_parent, ~\"22\");"}]}