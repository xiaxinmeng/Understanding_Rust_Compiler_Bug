{"sha": "b577beeb3a006f68cf8df25e7c77bb13a7803f26", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NzdiZWViM2EwMDZmNjhjZjhkZjI1ZTdjNzdiYjEzYTc4MDNmMjY=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-10T16:19:26Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-10T16:26:58Z"}, "message": "copyedits: patterns\n\nThis also puts slice patterns in nightly docs, where they belong.", "tree": {"sha": "d99e5601d2ee44814bd8a0ab0e70501d9e3f83c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d99e5601d2ee44814bd8a0ab0e70501d9e3f83c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b577beeb3a006f68cf8df25e7c77bb13a7803f26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b577beeb3a006f68cf8df25e7c77bb13a7803f26", "html_url": "https://github.com/rust-lang/rust/commit/b577beeb3a006f68cf8df25e7c77bb13a7803f26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b577beeb3a006f68cf8df25e7c77bb13a7803f26/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9aa4b643c41b02b89ada2aa8ac3f38aab3e98de1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9aa4b643c41b02b89ada2aa8ac3f38aab3e98de1", "html_url": "https://github.com/rust-lang/rust/commit/9aa4b643c41b02b89ada2aa8ac3f38aab3e98de1"}], "stats": {"total": 117, "additions": 66, "deletions": 51}, "files": [{"sha": "fb042b2704b6bf3680ad20758f683a6182f7088c", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b577beeb3a006f68cf8df25e7c77bb13a7803f26/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/b577beeb3a006f68cf8df25e7c77bb13a7803f26/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=b577beeb3a006f68cf8df25e7c77bb13a7803f26", "patch": "@@ -67,4 +67,5 @@\n     * [Link args](link-args.md)\n     * [Benchmark Tests](benchmark-tests.md)\n     * [Box Syntax and Patterns](box-syntax-and-patterns.md)\n+    * [Slice Patterns](slice-patterns.md)\n * [Glossary](glossary.md)"}, {"sha": "c88e3a0f9edf5f71564270e369c7233455ec2849", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 47, "deletions": 51, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b577beeb3a006f68cf8df25e7c77bb13a7803f26/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/b577beeb3a006f68cf8df25e7c77bb13a7803f26/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=b577beeb3a006f68cf8df25e7c77bb13a7803f26", "patch": "@@ -1,13 +1,16 @@\n % Patterns\n \n-We've made use of patterns a few times in the guide: first with `let` bindings,\n-then with `match` statements. Let's go on a whirlwind tour of all of the things\n-patterns can do!\n+Patterns are quite common in Rust. We use them in [variable\n+bindings][bindings], [match statements][match], and other places, too. Let\u2019s go\n+on a whirlwind tour of all of the things patterns can do!\n+\n+[bindings]: variable-bindings.html\n+[match]: match.html\n \n A quick refresher: you can match against literals directly, and `_` acts as an\n-*any* case:\n+\u2018any\u2019 case:\n \n-```{rust}\n+```rust\n let x = 1;\n \n match x {\n@@ -18,9 +21,11 @@ match x {\n }\n ```\n \n+# Multiple patterns\n+\n You can match multiple patterns with `|`:\n \n-```{rust}\n+```rust\n let x = 1;\n \n match x {\n@@ -30,9 +35,11 @@ match x {\n }\n ```\n \n+# Ranges\n+\n You can match a range of values with `...`:\n \n-```{rust}\n+```rust\n let x = 1;\n \n match x {\n@@ -43,10 +50,12 @@ match x {\n \n Ranges are mostly used with integers and single characters.\n \n-If you're matching multiple things, via a `|` or a `...`, you can bind\n+# Bindings\n+\n+If you\u2019re matching multiple things, via a `|` or a `...`, you can bind\n the value to a name with `@`:\n \n-```{rust}\n+```rust\n let x = 1;\n \n match x {\n@@ -55,10 +64,12 @@ match x {\n }\n ```\n \n-If you're matching on an enum which has variants, you can use `..` to\n+# Ignoring variants\n+\n+If you\u2019re matching on an enum which has variants, you can use `..` to\n ignore the value and type in the variant:\n \n-```{rust}\n+```rust\n enum OptionalInt {\n     Value(i32),\n     Missing,\n@@ -72,9 +83,11 @@ match x {\n }\n ```\n \n-You can introduce *match guards* with `if`:\n+# Guards\n+\n+You can introduce \u2018match guards\u2019 with `if`:\n \n-```{rust}\n+```rust\n enum OptionalInt {\n     Value(i32),\n     Missing,\n@@ -89,47 +102,38 @@ match x {\n }\n ```\n \n-If you're matching on a pointer, you can use the same syntax as you declared it\n-with. First, `&`:\n-\n-```{rust}\n-let x = &5;\n-\n-match x {\n-    &val => println!(\"Got a value: {}\", val),\n-}\n-```\n-\n-Here, the `val` inside the `match` has type `i32`. In other words, the left-hand\n-side of the pattern destructures the value. If we have `&5`, then in `&val`, `val`\n-would be `5`.\n+# ref and ref mut\n \n-If you want to get a reference, use the `ref` keyword:\n+If you want to get a [reference][ref], use the `ref` keyword:\n \n-```{rust}\n+```rust\n let x = 5;\n \n match x {\n     ref r => println!(\"Got a reference to {}\", r),\n }\n ```\n \n+[ref]: references-and-borrowing.html\n+\n Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`\n keyword _creates_ a reference, for use in the pattern. If you need a mutable\n reference, `ref mut` will work in the same way:\n \n-```{rust}\n+```rust\n let mut x = 5;\n \n match x {\n     ref mut mr => println!(\"Got a mutable reference to {}\", mr),\n }\n ```\n \n-If you have a struct, you can destructure it inside of a pattern:\n+# Destructuring\n+\n+If you have a compound data type, like a `struct`, you can destructure it\n+inside of a pattern:\n \n-```{rust}\n-# #![allow(non_shorthand_field_patterns)]\n+```rust\n struct Point {\n     x: i32,\n     y: i32,\n@@ -142,10 +146,9 @@ match origin {\n }\n ```\n \n-If we only care about some of the values, we don't have to give them all names:\n+If we only care about some of the values, we don\u2019t have to give them all names:\n \n-```{rust}\n-# #![allow(non_shorthand_field_patterns)]\n+```rust\n struct Point {\n     x: i32,\n     y: i32,\n@@ -160,8 +163,7 @@ match origin {\n \n You can do this kind of match on any member, not just the first:\n \n-```{rust}\n-# #![allow(non_shorthand_field_patterns)]\n+```rust\n struct Point {\n     x: i32,\n     y: i32,\n@@ -174,22 +176,16 @@ match origin {\n }\n ```\n \n-If you want to match against a slice or array, you can use `&`:\n+This \u2018destructuring\u2019 behavior works on any compound data type, like\n+[tuples][tuples] or [enums][enums].\n \n-```{rust}\n-# #![feature(slice_patterns)]\n-fn main() {\n-    let v = vec![\"match_this\", \"1\"];\n+[tuples]: primitive-types.html#tuples\n+[enums]: enums.html\n \n-    match &v[..] {\n-        [\"match_this\", second] => println!(\"The second element is {}\", second),\n-        _ => {},\n-    }\n-}\n-```\n+# Mix and Match\n \n-Whew! That's a lot of different ways to match things, and they can all be\n-mixed and matched, depending on what you're doing:\n+Whew! That\u2019s a lot of different ways to match things, and they can all be\n+mixed and matched, depending on what you\u2019re doing:\n \n ```{rust,ignore}\n match x {"}, {"sha": "4599333a77a05e88d326126621762f6f27c4388e", "filename": "src/doc/trpl/slice-patterns.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b577beeb3a006f68cf8df25e7c77bb13a7803f26/src%2Fdoc%2Ftrpl%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/b577beeb3a006f68cf8df25e7c77bb13a7803f26/src%2Fdoc%2Ftrpl%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fslice-patterns.md?ref=b577beeb3a006f68cf8df25e7c77bb13a7803f26", "patch": "@@ -0,0 +1,18 @@\n+% Slice patterns\n+\n+If you want to match against a slice or array, you can use `&` with the\n+`slice_patterns` feature:\n+\n+```rust\n+#![feature(slice_patterns)]\n+\n+fn main() {\n+    let v = vec![\"match_this\", \"1\"];\n+\n+    match &v[..] {\n+        [\"match_this\", second] => println!(\"The second element is {}\", second),\n+        _ => {},\n+    }\n+}\n+```\n+"}]}