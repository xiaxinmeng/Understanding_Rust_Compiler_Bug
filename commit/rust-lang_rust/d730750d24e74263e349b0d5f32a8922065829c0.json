{"sha": "d730750d24e74263e349b0d5f32a8922065829c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MzA3NTBkMjRlNzQyNjNlMzQ5YjBkNWYzMmE4OTIyMDY1ODI5YzA=", "commit": {"author": {"name": "Nick Hamann", "email": "nick@wabbo.org", "date": "2015-05-10T08:48:15Z"}, "committer": {"name": "Nick Hamann", "email": "nick@wabbo.org", "date": "2015-05-10T22:49:12Z"}, "message": "Add long diagnostics for E0184, E0204, E0205, E0206, E0243, E0244.", "tree": {"sha": "4e2174f87eb7493e796fd8650a26c34eae12d394", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e2174f87eb7493e796fd8650a26c34eae12d394"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d730750d24e74263e349b0d5f32a8922065829c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d730750d24e74263e349b0d5f32a8922065829c0", "html_url": "https://github.com/rust-lang/rust/commit/d730750d24e74263e349b0d5f32a8922065829c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d730750d24e74263e349b0d5f32a8922065829c0/comments", "author": null, "committer": null, "parents": [{"sha": "a6dc983a604ec3a0e89a08419c57c256ba1a0e4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6dc983a604ec3a0e89a08419c57c256ba1a0e4a", "html_url": "https://github.com/rust-lang/rust/commit/a6dc983a604ec3a0e89a08419c57c256ba1a0e4a"}], "stats": {"total": 117, "additions": 108, "deletions": 9}, "files": [{"sha": "7428e5ada5f205184b6f17ff50361e40c80c3df7", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 108, "deletions": 9, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d730750d24e74263e349b0d5f32a8922065829c0/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d730750d24e74263e349b0d5f32a8922065829c0/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=d730750d24e74263e349b0d5f32a8922065829c0", "patch": "@@ -150,6 +150,114 @@ attribute. Such a function must have the following type signature:\n ```\n fn(isize, *const *const u8) -> isize\n ```\n+\"##,\n+\n+E0184: r##\"\n+Explicitly implementing both Drop and Copy for a type is currently disallowed.\n+This feature can make some sense in theory, but the current implementation is\n+incorrect and can lead to memory unsafety (see issue #20126), so it has been\n+disabled for now.\n+\"##,\n+\n+E0204: r##\"\n+An attempt to implement the `Copy` trait for a struct failed because one of the\n+fields does not implement `Copy`. To fix this, you must implement `Copy` for the\n+mentioned field. Note that this may not be possible, as in the example of\n+\n+```\n+struct Foo {\n+    foo : Vec<u32>,\n+}\n+\n+impl Copy for Foo { }\n+```\n+\n+This fails because `Vec<T>` does not implement `Copy` for any `T`.\n+\n+Here's another example that will fail:\n+\n+```\n+#[derive(Copy)]\n+struct Foo<'a> {\n+    ty: &'a mut bool,\n+}\n+```\n+\n+This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (as opposed\n+to `&T`, which is).\n+\"##,\n+\n+E0205: r##\"\n+An attempt to implement the `Copy` trait for an enum failed because one of the\n+variants does not implement `Copy`. To fix this, you must implement `Copy` for\n+the mentioned variant. Note that this may not be possible, as in the example of\n+\n+```\n+enum Foo {\n+    Bar(Vec<u32>),\n+    Baz,\n+}\n+\n+impl Copy for Foo { }\n+```\n+\n+This fails because `Vec<T>` does not implement `Copy` for any `T`.\n+\n+Here's another example that will fail:\n+\n+```\n+#[derive(Copy)]\n+enum Foo<'a> {\n+    Bar(&'a mut bool),\n+    Baz\n+}\n+```\n+\n+This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (as opposed\n+to `&T`, which is).\n+\"##,\n+\n+E0206: r##\"\n+You can only implement `Copy` for a struct or enum. For example, both of the\n+following examples will fail, because neither `i32` nor `&'static mut Bar` is\n+a struct or enum:\n+\n+```\n+type Foo = i32;\n+impl Copy for Foo { } // error\n+\n+#[derive(Copy, Clone)]\n+struct Bar;\n+impl Copy for &'static mut Bar { } // error\n+```\n+\"##,\n+\n+E0243: r##\"\n+This error indicates that not enough type parameters were found in a type or\n+trait.\n+\n+For example, the `Foo` struct below is defined to be generic in `T`, but the\n+type parameter is missing in the definition of `Bar`:\n+\n+```\n+struct Foo<T> { x: T }\n+\n+struct Bar { x: Foo }\n+```\n+\"##,\n+\n+E0244: r##\"\n+This error indicates that too many type parameters were found in a type or\n+trait.\n+\n+For example, the `Foo` struct below has no type parameters, but is supplied\n+with two in the definition of `Bar`:\n+\n+```\n+struct Foo { x: bool }\n+\n+struct Bar<S, T> { x: Foo<S, T> }\n+```\n \"##\n \n }\n@@ -232,7 +340,6 @@ register_diagnostics! {\n     E0178,\n     E0182,\n     E0183,\n-    E0184,\n     E0185,\n     E0186,\n     E0187, // can't infer the kind of the closure\n@@ -254,12 +361,6 @@ register_diagnostics! {\n     E0202, // associated items are not allowed in inherent impls\n     E0203, // type parameter has more than one relaxed default bound,\n            // and only one is supported\n-    E0204, // trait `Copy` may not be implemented for this type; field\n-           // does not implement `Copy`\n-    E0205, // trait `Copy` may not be implemented for this type; variant\n-           // does not implement `copy`\n-    E0206, // trait `Copy` may not be implemented for this type; type is\n-           // not a structure or enumeration\n     E0207, // type parameter is not constrained by the impl trait, self type, or predicate\n     E0208,\n     E0209, // builtin traits can only be implemented on structs or enums\n@@ -296,8 +397,6 @@ register_diagnostics! {\n     E0240,\n     E0241,\n     E0242, // internal error looking up a definition\n-    E0243, // wrong number of type arguments\n-    E0244, // wrong number of type arguments\n     E0245, // not a trait\n     E0246, // illegal recursive type\n     E0247, // found module name used as a type"}]}