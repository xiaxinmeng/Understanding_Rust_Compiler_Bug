{"sha": "ac919d527ced593e1b199b8c5b7b8cafa3840375", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjOTE5ZDUyN2NlZDU5M2UxYjE5OWI4YzViN2I4Y2FmYTM4NDAzNzU=", "commit": {"author": {"name": "scalexm", "email": "martin.alex32@hotmail.fr", "date": "2017-08-01T19:38:52Z"}, "committer": {"name": "scalexm", "email": "martin.alex32@hotmail.fr", "date": "2017-08-03T12:40:40Z"}, "message": "Add a more precise error message\nWhen trying to perform static dispatch on something which derefs\nto a trait object, and the target trait is not in scope, we had\nconfusing error messages if the target method had a\n`Self: Sized` bound. We add a more precise error message in this\ncase: \"consider using trait ...\".\n\nFixes #35976.", "tree": {"sha": "e9ea89d245362a79ade15d26e18ee28aec764ed4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9ea89d245362a79ade15d26e18ee28aec764ed4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac919d527ced593e1b199b8c5b7b8cafa3840375", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac919d527ced593e1b199b8c5b7b8cafa3840375", "html_url": "https://github.com/rust-lang/rust/commit/ac919d527ced593e1b199b8c5b7b8cafa3840375", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac919d527ced593e1b199b8c5b7b8cafa3840375/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12aad38ad40f489c5700747158426adee2b732c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/12aad38ad40f489c5700747158426adee2b732c0", "html_url": "https://github.com/rust-lang/rust/commit/12aad38ad40f489c5700747158426adee2b732c0"}], "stats": {"total": 180, "additions": 157, "deletions": 23}, "files": [{"sha": "eef0bcc375358050d86e52cd8ada0e7905695996", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac919d527ced593e1b199b8c5b7b8cafa3840375/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac919d527ced593e1b199b8c5b7b8cafa3840375/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ac919d527ced593e1b199b8c5b7b8cafa3840375", "patch": "@@ -160,7 +160,7 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct AssociatedItem {\n     pub def_id: DefId,\n     pub name: Name,"}, {"sha": "0ab75ad622ce0195660e73f7a5bfff560fe9850a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ac919d527ced593e1b199b8c5b7b8cafa3840375/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac919d527ced593e1b199b8c5b7b8cafa3840375/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=ac919d527ced593e1b199b8c5b7b8cafa3840375", "patch": "@@ -38,6 +38,11 @@ impl<'a, 'gcx, 'tcx> Deref for ConfirmContext<'a, 'gcx, 'tcx> {\n     }\n }\n \n+pub struct ConfirmResult<'tcx> {\n+    pub callee: MethodCallee<'tcx>,\n+    pub rerun: bool,\n+}\n+\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn confirm_method(&self,\n                           span: Span,\n@@ -46,7 +51,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           unadjusted_self_ty: Ty<'tcx>,\n                           pick: probe::Pick<'tcx>,\n                           segment: &hir::PathSegment)\n-                          -> MethodCallee<'tcx> {\n+                          -> ConfirmResult<'tcx> {\n         debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, generic_args={:?})\",\n                unadjusted_self_ty,\n                pick,\n@@ -75,7 +80,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                unadjusted_self_ty: Ty<'tcx>,\n                pick: probe::Pick<'tcx>,\n                segment: &hir::PathSegment)\n-               -> MethodCallee<'tcx> {\n+               -> ConfirmResult<'tcx> {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n         let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick);\n \n@@ -91,6 +96,16 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // Create the final signature for the method, replacing late-bound regions.\n         let (method_sig, method_predicates) = self.instantiate_method_sig(&pick, all_substs);\n \n+        // If there is a `Self: Sized` bound and `Self` is a trait object, it is possible that\n+        // something which derefs to `Self` actually implements the trait and the caller\n+        // wanted to make a static dispatch on it but forgot to import the trait.\n+        // See test `src/test/compile-fail/issue-35976.rs`.\n+        //\n+        // In that case, we'll error anyway, but we'll also re-run the search with all traits\n+        // in scope, and if we find another method which can be used, we'll output an\n+        // appropriate hint suggesting to import the trait.\n+        let rerun = self.predicates_require_illegal_sized_bound(&method_predicates);\n+\n         // Unify the (adjusted) self type with what the method expects.\n         self.unify_receivers(self_ty, method_sig.inputs()[0]);\n \n@@ -109,7 +124,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             self.convert_lvalue_derefs_to_mutable();\n         }\n \n-        callee\n+        ConfirmResult { callee, rerun }\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -533,6 +548,30 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n \n+    fn predicates_require_illegal_sized_bound(&self,\n+                                              predicates: &ty::InstantiatedPredicates<'tcx>)\n+                                              -> bool {\n+        let sized_def_id = match self.tcx.lang_items.sized_trait() {\n+            Some(def_id) => def_id,\n+            None => return false,\n+        };\n+\n+        traits::elaborate_predicates(self.tcx, predicates.predicates.clone())\n+            .filter_map(|predicate| {\n+                match predicate {\n+                    ty::Predicate::Trait(trait_pred) if trait_pred.def_id() == sized_def_id =>\n+                        Some(trait_pred),\n+                    _ => None,\n+                }\n+            })\n+            .any(|trait_pred| {\n+                match trait_pred.0.self_ty().sty {\n+                    ty::TyDynamic(..) => true,\n+                    _ => false,\n+                }\n+            })\n+    }\n+\n     fn enforce_illegal_method_limitations(&self, pick: &probe::Pick) {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n         match pick.item.container {"}, {"sha": "f875511a9f59e70631e0a3120d47e17467ad902d", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ac919d527ced593e1b199b8c5b7b8cafa3840375/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac919d527ced593e1b199b8c5b7b8cafa3840375/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=ac919d527ced593e1b199b8c5b7b8cafa3840375", "patch": "@@ -33,7 +33,7 @@ mod confirm;\n pub mod probe;\n mod suggest;\n \n-use self::probe::IsSuggestion;\n+use self::probe::{IsSuggestion, ProbeScope};\n \n #[derive(Clone, Copy, Debug)]\n pub struct MethodCallee<'tcx> {\n@@ -106,7 +106,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          -> bool {\n         let mode = probe::Mode::MethodCall;\n         match self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n-                                  self_ty, call_expr_id) {\n+                                  self_ty, call_expr_id, ProbeScope::TraitsInScope) {\n             Ok(..) => true,\n             Err(NoMatch(..)) => false,\n             Err(Ambiguity(..)) => true,\n@@ -142,10 +142,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                call_expr,\n                self_expr);\n \n-        let mode = probe::Mode::MethodCall;\n-        let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n-        let pick = self.probe_for_name(span, mode, segment.name, IsSuggestion(false),\n-                                       self_ty, call_expr.id)?;\n+        let pick = self.lookup_probe(\n+            span,\n+            segment.name,\n+            self_ty,\n+            call_expr,\n+            ProbeScope::TraitsInScope\n+        )?;\n \n         if let Some(import_id) = pick.import_id {\n             let import_def_id = self.tcx.hir.local_def_id(import_id);\n@@ -155,12 +158,53 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.check_stability(pick.item.def_id, call_expr.id, span);\n \n-        Ok(self.confirm_method(span,\n-                               self_expr,\n-                               call_expr,\n-                               self_ty,\n-                               pick,\n-                               segment))\n+        let result = self.confirm_method(span,\n+                                         self_expr,\n+                                         call_expr,\n+                                         self_ty,\n+                                         pick.clone(),\n+                                         segment);\n+\n+        if result.rerun {\n+            // We probe again, taking all traits into account (not only those in scope).\n+            if let Ok(new_pick) = self.lookup_probe(span,\n+                                                    segment.name,\n+                                                    self_ty,\n+                                                    call_expr,\n+                                                    ProbeScope::AllTraits) {\n+                // If we find a different result, the caller probably forgot to import the trait.\n+                // We span an error with an appropriate help message.\n+                if new_pick != pick {\n+                    let error = MethodError::NoMatch(\n+                        NoMatchData::new(Vec::new(),\n+                                         Vec::new(),\n+                                         vec![new_pick.item.container.id()],\n+                                         probe::Mode::MethodCall)\n+                    );\n+                    self.report_method_error(span,\n+                                             self_ty,\n+                                             segment.name,\n+                                             Some(self_expr),\n+                                             error,\n+                                             None);\n+                }\n+            }\n+        }\n+\n+        Ok(result.callee)\n+    }\n+\n+    fn lookup_probe(&self,\n+                    span: Span,\n+                    method_name: ast::Name,\n+                    self_ty: ty::Ty<'tcx>,\n+                    call_expr: &'gcx hir::Expr,\n+                    scope: ProbeScope)\n+                    -> probe::PickResult<'tcx> {\n+        let mode = probe::Mode::MethodCall;\n+        let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n+        self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n+                            self_ty, call_expr.id, scope)\n     }\n \n     /// `lookup_method_in_trait` is used for overloaded operators.\n@@ -299,7 +343,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         -> Result<Def, MethodError<'tcx>> {\n         let mode = probe::Mode::Path;\n         let pick = self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n-                                       self_ty, expr_id)?;\n+                                       self_ty, expr_id, ProbeScope::TraitsInScope)?;\n \n         if let Some(import_id) = pick.import_id {\n             let import_def_id = self.tcx.hir.local_def_id(import_id);"}, {"sha": "3195b10404d1ca8299e316217707d915f045bb33", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ac919d527ced593e1b199b8c5b7b8cafa3840375/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac919d527ced593e1b199b8c5b7b8cafa3840375/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ac919d527ced593e1b199b8c5b7b8cafa3840375", "patch": "@@ -106,7 +106,7 @@ enum CandidateKind<'tcx> {\n                          ty::PolyTraitRef<'tcx>),\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq, Clone)]\n pub struct Pick<'tcx> {\n     pub item: ty::AssociatedItem,\n     pub kind: PickKind<'tcx>,\n@@ -130,7 +130,7 @@ pub struct Pick<'tcx> {\n     pub unsize: Option<Ty<'tcx>>,\n }\n \n-#[derive(Clone,Debug)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub enum PickKind<'tcx> {\n     InherentImplPick,\n     ExtensionImplPick(// Impl\n@@ -155,6 +155,15 @@ pub enum Mode {\n     Path,\n }\n \n+#[derive(PartialEq, Eq, Copy, Clone, Debug)]\n+pub enum ProbeScope {\n+    // Assemble candidates coming only from traits in scope.\n+    TraitsInScope,\n+\n+    // Assemble candidates coming from all traits.\n+    AllTraits,\n+}\n+\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// This is used to offer suggestions to users. It returns methods\n     /// that could have been called which have the desired return\n@@ -175,14 +184,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                scope_expr_id);\n         let method_names =\n             self.probe_op(span, mode, LookingFor::ReturnType(return_type), IsSuggestion(true),\n-                          self_ty, scope_expr_id,\n+                          self_ty, scope_expr_id, ProbeScope::TraitsInScope,\n                           |probe_cx| Ok(probe_cx.candidate_method_names()))\n                 .unwrap_or(vec![]);\n         method_names\n             .iter()\n             .flat_map(|&method_name| {\n                 match self.probe_for_name(span, mode, method_name, IsSuggestion(true), self_ty,\n-                                          scope_expr_id) {\n+                                          scope_expr_id, ProbeScope::TraitsInScope) {\n                     Ok(pick) => Some(pick.item),\n                     Err(_) => None,\n                 }\n@@ -196,7 +205,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           item_name: ast::Name,\n                           is_suggestion: IsSuggestion,\n                           self_ty: Ty<'tcx>,\n-                          scope_expr_id: ast::NodeId)\n+                          scope_expr_id: ast::NodeId,\n+                          scope: ProbeScope)\n                           -> PickResult<'tcx> {\n         debug!(\"probe(self_ty={:?}, item_name={}, scope_expr_id={})\",\n                self_ty,\n@@ -208,6 +218,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       is_suggestion,\n                       self_ty,\n                       scope_expr_id,\n+                      scope,\n                       |probe_cx| probe_cx.pick())\n     }\n \n@@ -218,6 +229,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       is_suggestion: IsSuggestion,\n                       self_ty: Ty<'tcx>,\n                       scope_expr_id: ast::NodeId,\n+                      scope: ProbeScope,\n                       op: OP)\n                       -> Result<R, MethodError<'tcx>>\n         where OP: FnOnce(ProbeContext<'a, 'gcx, 'tcx>) -> Result<R, MethodError<'tcx>>\n@@ -275,8 +287,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let mut probe_cx =\n                 ProbeContext::new(self, span, mode, looking_for,\n                                   steps, opt_simplified_steps);\n+\n             probe_cx.assemble_inherent_candidates();\n-            probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)?;\n+            match scope {\n+                ProbeScope::TraitsInScope =>\n+                    probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)?,\n+                ProbeScope::AllTraits =>\n+                    probe_cx.assemble_extension_candidates_for_all_traits()?,\n+            };\n             op(probe_cx)\n         })\n     }"}, {"sha": "194616c94437425e071de62f468508ff45e34c6c", "filename": "src/test/compile-fail/issue-35976.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ac919d527ced593e1b199b8c5b7b8cafa3840375/src%2Ftest%2Fcompile-fail%2Fissue-35976.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac919d527ced593e1b199b8c5b7b8cafa3840375/src%2Ftest%2Fcompile-fail%2Fissue-35976.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-35976.rs?ref=ac919d527ced593e1b199b8c5b7b8cafa3840375", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod private {\n+    pub trait Future {\n+        fn wait(&self) where Self: Sized;\n+    }\n+\n+    impl Future for Box<Future> {\n+        fn wait(&self) { }\n+    }\n+}\n+\n+//use private::Future;\n+\n+fn bar(arg: Box<private::Future>) {\n+    arg.wait();\n+    //~^ ERROR no method named `wait` found for type `std::boxed::Box<private::Future + 'static>`\n+    //~| the following trait is implemented but not in scope\n+    //~| ERROR the trait bound `private::Future + 'static: std::marker::Sized` is not satisfied\n+    //~| `private::Future + 'static` does not have a constant size known at compile-time\n+}\n+\n+fn main() {\n+\n+}"}]}