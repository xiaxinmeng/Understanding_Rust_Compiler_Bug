{"sha": "d0e60b72ee3f5fb07b01143d82362cb42307f32d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwZTYwYjcyZWUzZjVmYjA3YjAxMTQzZDgyMzYyY2I0MjMwN2YzMmQ=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-03-26T16:24:16Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-04-06T22:39:56Z"}, "message": "De-~[] Reader and Writer\n\nThere's a little more allocation here and there now since\nfrom_utf8_owned can't be used with Vec.", "tree": {"sha": "ed0161843da862f7b40a01b76a81ced97c1e67da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed0161843da862f7b40a01b76a81ced97c1e67da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0e60b72ee3f5fb07b01143d82362cb42307f32d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0e60b72ee3f5fb07b01143d82362cb42307f32d", "html_url": "https://github.com/rust-lang/rust/commit/d0e60b72ee3f5fb07b01143d82362cb42307f32d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0e60b72ee3f5fb07b01143d82362cb42307f32d/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94a055c7295bd5822219b86243c2af6fff9d21d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/94a055c7295bd5822219b86243c2af6fff9d21d3", "html_url": "https://github.com/rust-lang/rust/commit/94a055c7295bd5822219b86243c2af6fff9d21d3"}], "stats": {"total": 225, "additions": 117, "deletions": 108}, "files": [{"sha": "aa0fb838284cc859cc7e27fbe8643152b40f578c", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -84,8 +84,8 @@ pub fn run(lib_path: &str,\n \n             Some(Result {\n                 status: status,\n-                out: str::from_utf8_owned(output).unwrap(),\n-                err: str::from_utf8_owned(error).unwrap()\n+                out: str::from_utf8(output.as_slice()).unwrap().to_owned(),\n+                err: str::from_utf8(error.as_slice()).unwrap().to_owned()\n             })\n         },\n         Err(..) => None"}, {"sha": "b290bd2838ab3de017676584de998aa9ee2433ed", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -153,7 +153,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n         match props.pp_exact { Some(_) => 1, None => 2 };\n \n     let src = File::open(testfile).read_to_end().unwrap();\n-    let src = str::from_utf8_owned(src).unwrap();\n+    let src = str::from_utf8(src.as_slice()).unwrap().to_owned();\n     let mut srcs = vec!(src);\n \n     let mut round = 0;\n@@ -177,7 +177,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n         Some(ref file) => {\n             let filepath = testfile.dir_path().join(file);\n             let s = File::open(&filepath).read_to_end().unwrap();\n-            str::from_utf8_owned(s).unwrap()\n+            str::from_utf8(s.as_slice()).unwrap().to_owned()\n           }\n           None => { (*srcs.get(srcs.len() - 2u)).clone() }\n         };\n@@ -1163,7 +1163,7 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n \n fn count_extracted_lines(p: &Path) -> uint {\n     let x = File::open(&p.with_extension(\"ll\")).read_to_end().unwrap();\n-    let x = str::from_utf8_owned(x).unwrap();\n+    let x = str::from_utf8(x.as_slice()).unwrap();\n     x.lines().len()\n }\n "}, {"sha": "eeba816f439f972ff6b3192e796939140f7f35fb", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -59,8 +59,10 @@ fn run_ar(sess: &Session, args: &str, cwd: Option<&Path>,\n             if !o.status.success() {\n                 sess.err(format!(\"{} {} failed with: {}\", ar, args.connect(\" \"),\n                                  o.status));\n-                sess.note(format!(\"stdout ---\\n{}\", str::from_utf8(o.output).unwrap()));\n-                sess.note(format!(\"stderr ---\\n{}\", str::from_utf8(o.error).unwrap()));\n+                sess.note(format!(\"stdout ---\\n{}\",\n+                                  str::from_utf8(o.output.as_slice()).unwrap()));\n+                sess.note(format!(\"stderr ---\\n{}\",\n+                                  str::from_utf8(o.error.as_slice()).unwrap()));\n                 sess.abort_if_errors();\n             }\n             o\n@@ -129,7 +131,7 @@ impl<'a> Archive<'a> {\n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<~str> {\n         let output = run_ar(self.sess, \"t\", None, [&self.dst]);\n-        let output = str::from_utf8(output.output).unwrap();\n+        let output = str::from_utf8(output.output.as_slice()).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n         output.lines_any().map(|s| s.to_owned()).collect()"}, {"sha": "a9fad13fb60fbf57f2d5ce97bf72fd28366ebe8d", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -337,7 +337,9 @@ pub mod write {\n                 if !prog.status.success() {\n                     sess.err(format!(\"linking with `{}` failed: {}\", cc, prog.status));\n                     sess.note(format!(\"{} arguments: '{}'\", cc, args.connect(\"' '\")));\n-                    sess.note(str::from_utf8_owned(prog.error + prog.output).unwrap());\n+                    let mut note = prog.error.clone();\n+                    note.push_all(prog.output.as_slice());\n+                    sess.note(str::from_utf8(note.as_slice()).unwrap().to_owned());\n                     sess.abort_if_errors();\n                 }\n             },\n@@ -929,7 +931,8 @@ fn link_rlib<'a>(sess: &'a Session,\n             let bc = obj_filename.with_extension(\"bc\");\n             let bc_deflated = obj_filename.with_extension(\"bc.deflate\");\n             match fs::File::open(&bc).read_to_end().and_then(|data| {\n-                fs::File::create(&bc_deflated).write(flate::deflate_bytes(data).as_slice())\n+                fs::File::create(&bc_deflated)\n+                    .write(flate::deflate_bytes(data.as_slice()).as_slice())\n             }) {\n                 Ok(()) => {}\n                 Err(e) => {\n@@ -1025,7 +1028,9 @@ fn link_natively(sess: &Session, dylib: bool, obj_filename: &Path,\n             if !prog.status.success() {\n                 sess.err(format!(\"linking with `{}` failed: {}\", cc_prog, prog.status));\n                 sess.note(format!(\"{} arguments: '{}'\", cc_prog, cc_args.connect(\"' '\")));\n-                sess.note(str::from_utf8_owned(prog.error + prog.output).unwrap());\n+                let mut output = prog.error.clone();\n+                output.push_all(prog.output.as_slice());\n+                sess.note(str::from_utf8(output.as_slice()).unwrap().to_owned());\n                 sess.abort_if_errors();\n             }\n         },"}, {"sha": "b9c3ef2f266121eb6a421e14ad11bcce92ba9f98", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -272,7 +272,7 @@ pub fn run_compiler(args: &[~str]) {\n         let ifile = matches.free.get(0).as_slice();\n         if ifile == \"-\" {\n             let contents = io::stdin().read_to_end().unwrap();\n-            let src = str::from_utf8_owned(contents).unwrap();\n+            let src = str::from_utf8(contents.as_slice()).unwrap().to_owned();\n             (d::StrInput(src), None)\n         } else {\n             (d::FileInput(Path::new(ifile)), Some(Path::new(ifile)))"}, {"sha": "a2e2a032a0c60bd5769b474bfe795f6d341684fe", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -487,7 +487,7 @@ impl<'a> SourceCollector<'a> {\n                        filename.ends_with(\"macros>\") => return Ok(()),\n             Err(e) => return Err(e)\n         };\n-        let contents = str::from_utf8_owned(contents).unwrap();\n+        let contents = str::from_utf8(contents.as_slice()).unwrap();\n \n         // Remove the utf-8 BOM if any\n         let contents = if contents.starts_with(\"\\ufeff\") {"}, {"sha": "be91279844209e54ab892f934eef2c2656185774", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -22,7 +22,7 @@ use test::Collector;\n fn load_string(input: &Path) -> io::IoResult<Option<~str>> {\n     let mut f = try!(io::File::open(input));\n     let d = try!(f.read_to_end());\n-    Ok(str::from_utf8_owned(d))\n+    Ok(str::from_utf8(d.as_slice()).map(|s| s.to_owned()))\n }\n macro_rules! load_or_return {\n     ($input: expr, $cant_read: expr, $not_utf8: expr) => {"}, {"sha": "06b57780abe22305644e8021dc96998c30fa4dbe", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -159,7 +159,8 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n             if should_fail && out.status.success() {\n                 fail!(\"test executable succeeded when it should have failed\");\n             } else if !should_fail && !out.status.success() {\n-                fail!(\"test executable failed:\\n{}\", str::from_utf8(out.error));\n+                fail!(\"test executable failed:\\n{}\",\n+                      str::from_utf8(out.error.as_slice()));\n             }\n         }\n     }"}, {"sha": "34e2cbeb15efbdc4bce4a11dce79ff1343583cc9", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -1282,8 +1282,8 @@ pub fn from_reader(rdr: &mut io::Reader) -> DecodeResult<Json> {\n         Ok(c) => c,\n         Err(e) => return Err(IoError(e))\n     };\n-    let s = match str::from_utf8_owned(contents) {\n-        Some(s) => s,\n+    let s = match str::from_utf8(contents.as_slice()) {\n+        Some(s) => s.to_owned(),\n         None => return Err(ParseError(~\"contents not utf-8\", 0, 0))\n     };\n     let mut parser = Parser::new(s.chars());"}, {"sha": "fa977113d6c9b3be9a4c778977d1f622b6a69fe1", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -504,10 +504,10 @@ mod test {\n     fn test_read_until() {\n         let inner = MemReader::new(~[0, 1, 2, 1, 0]);\n         let mut reader = BufferedReader::with_capacity(2, inner);\n-        assert_eq!(reader.read_until(0), Ok(~[0]));\n-        assert_eq!(reader.read_until(2), Ok(~[1, 2]));\n-        assert_eq!(reader.read_until(1), Ok(~[1]));\n-        assert_eq!(reader.read_until(8), Ok(~[0]));\n+        assert_eq!(reader.read_until(0), Ok(vec!(0)));\n+        assert_eq!(reader.read_until(2), Ok(vec!(1, 2)));\n+        assert_eq!(reader.read_until(1), Ok(vec!(1)));\n+        assert_eq!(reader.read_until(8), Ok(vec!(0)));\n         assert!(reader.read_until(9).is_err());\n     }\n "}, {"sha": "10ea3628b866a4106c9ee3b19538f0a9fe9e9d75", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -323,7 +323,7 @@ mod test {\n     fn read_bytes() {\n         let mut reader = MemReader::new(~[10, 11, 12, 13]);\n         let bytes = reader.read_exact(4).unwrap();\n-        assert!(bytes == ~[10, 11, 12, 13]);\n+        assert!(bytes == vec!(10, 11, 12, 13));\n     }\n \n     #[test]\n@@ -332,7 +332,7 @@ mod test {\n             count: 0,\n         };\n         let bytes = reader.read_exact(4).unwrap();\n-        assert!(bytes == ~[10, 11, 12, 13]);\n+        assert!(bytes == vec!(10, 11, 12, 13));\n     }\n \n     #[test]\n@@ -344,37 +344,37 @@ mod test {\n     #[test]\n     fn push_exact() {\n         let mut reader = MemReader::new(~[10, 11, 12, 13]);\n-        let mut buf = ~[8, 9];\n+        let mut buf = vec!(8, 9);\n         reader.push_exact(&mut buf, 4).unwrap();\n-        assert!(buf == ~[8, 9, 10, 11, 12, 13]);\n+        assert!(buf == vec!(8, 9, 10, 11, 12, 13));\n     }\n \n     #[test]\n     fn push_exact_partial() {\n         let mut reader = PartialReader {\n             count: 0,\n         };\n-        let mut buf = ~[8, 9];\n+        let mut buf = vec!(8, 9);\n         reader.push_exact(&mut buf, 4).unwrap();\n-        assert!(buf == ~[8, 9, 10, 11, 12, 13]);\n+        assert!(buf == vec!(8, 9, 10, 11, 12, 13));\n     }\n \n     #[test]\n     fn push_exact_eof() {\n         let mut reader = MemReader::new(~[10, 11]);\n-        let mut buf = ~[8, 9];\n+        let mut buf = vec!(8, 9);\n         assert!(reader.push_exact(&mut buf, 4).is_err());\n-        assert!(buf == ~[8, 9, 10, 11]);\n+        assert!(buf == vec!(8, 9, 10, 11));\n     }\n \n     #[test]\n     fn push_exact_error() {\n         let mut reader = ErroringLaterReader {\n             count: 0,\n         };\n-        let mut buf = ~[8, 9];\n+        let mut buf = vec!(8, 9);\n         assert!(reader.push_exact(&mut buf, 4).is_err());\n-        assert!(buf == ~[8, 9, 10]);\n+        assert!(buf == vec!(8, 9, 10));\n     }\n \n     #[test]\n@@ -383,7 +383,7 @@ mod test {\n             count: 0,\n         };\n         let buf = reader.read_to_end().unwrap();\n-        assert!(buf == ~[10, 11, 12, 13]);\n+        assert!(buf == vec!(10, 11, 12, 13));\n     }\n \n     #[test]\n@@ -393,7 +393,7 @@ mod test {\n             count: 0,\n         };\n         let buf = reader.read_to_end().unwrap();\n-        assert!(buf == ~[10, 11]);\n+        assert!(buf == vec!(10, 11));\n     }\n \n     #[test]"}, {"sha": "2fea002d4197f85a59fc4617b65331b389dea61b", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -1074,7 +1074,7 @@ mod test {\n         check!(copy(&input, &output));\n \n         assert_eq!(check!(File::open(&output).read_to_end()),\n-                   (bytes!(\"foo\")).to_owned());\n+                   (Vec::from_slice(bytes!(\"foo\"))));\n     })\n \n     iotest!(fn copy_file_src_dir() {\n@@ -1114,7 +1114,7 @@ mod test {\n         }\n         assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n         assert_eq!(check!(File::open(&out).read_to_end()),\n-                   (bytes!(\"foobar\")).to_owned());\n+                   (Vec::from_slice(bytes!(\"foobar\"))));\n     })\n \n     #[cfg(not(windows))] // apparently windows doesn't like symlinks\n@@ -1146,7 +1146,7 @@ mod test {\n         }\n         assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n         assert_eq!(check!(File::open(&out).read_to_end()),\n-                   (bytes!(\"foobar\")).to_owned());\n+                   (Vec::from_slice(bytes!(\"foobar\"))));\n \n         // can't link to yourself\n         match link(&input, &input) {\n@@ -1206,7 +1206,7 @@ mod test {\n         check!(file.fsync());\n         assert_eq!(check!(stat(&path)).size, 10);\n         assert_eq!(check!(File::open(&path).read_to_end()),\n-                   (bytes!(\"foobar\", 0, 0, 0, 0)).to_owned());\n+                   (Vec::from_slice(bytes!(\"foobar\", 0, 0, 0, 0))));\n \n         // Truncate to a smaller length, don't seek, and then write something.\n         // Ensure that the intermediate zeroes are all filled in (we're seeked\n@@ -1217,7 +1217,7 @@ mod test {\n         check!(file.fsync());\n         assert_eq!(check!(stat(&path)).size, 9);\n         assert_eq!(check!(File::open(&path).read_to_end()),\n-                   (bytes!(\"fo\", 0, 0, 0, 0, \"wut\")).to_owned());\n+                   (Vec::from_slice(bytes!(\"fo\", 0, 0, 0, 0, \"wut\"))));\n         drop(file);\n     })\n "}, {"sha": "ee9432ca73beba57efe925f6a87b93eed0da6611", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -129,7 +129,7 @@ impl Seek for MemWriter {\n ///\n /// let mut r = MemReader::new(~[0, 1, 2]);\n ///\n-/// assert_eq!(r.read_to_end().unwrap(), ~[0, 1, 2]);\n+/// assert_eq!(r.read_to_end().unwrap(), vec!(0, 1, 2));\n /// ```\n pub struct MemReader {\n     buf: ~[u8],\n@@ -272,7 +272,7 @@ impl<'a> Seek for BufWriter<'a> {\n /// let mut buf = [0, 1, 2, 3];\n /// let mut r = BufReader::new(buf);\n ///\n-/// assert_eq!(r.read_to_end().unwrap(), ~[0, 1, 2, 3]);\n+/// assert_eq!(r.read_to_end().unwrap(), vec!(0, 1, 2, 3));\n /// ```\n pub struct BufReader<'a> {\n     buf: &'a [u8],\n@@ -441,8 +441,8 @@ mod test {\n         assert_eq!(buf.slice(0, 3), &[5, 6, 7]);\n         assert!(reader.read(buf).is_err());\n         let mut reader = MemReader::new(~[0, 1, 2, 3, 4, 5, 6, 7]);\n-        assert_eq!(reader.read_until(3).unwrap(), ~[0, 1, 2, 3]);\n-        assert_eq!(reader.read_until(3).unwrap(), ~[4, 5, 6, 7]);\n+        assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n+        assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n         assert!(reader.read(buf).is_err());\n     }\n \n@@ -465,8 +465,8 @@ mod test {\n         assert_eq!(buf.slice(0, 3), &[5, 6, 7]);\n         assert!(reader.read(buf).is_err());\n         let mut reader = BufReader::new(in_buf);\n-        assert_eq!(reader.read_until(3).unwrap(), ~[0, 1, 2, 3]);\n-        assert_eq!(reader.read_until(3).unwrap(), ~[4, 5, 6, 7]);\n+        assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n+        assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n         assert!(reader.read(buf).is_err());\n     }\n "}, {"sha": "97519adbc3f828e436e3b8e5238fba218733eb3a", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -225,8 +225,8 @@ use str::{StrSlice, OwnedStr};\n use str;\n use uint;\n use unstable::finally::try_finally;\n-use slice::{OwnedVector, MutableVector, ImmutableVector, OwnedCloneableVector};\n-use slice;\n+use slice::{Vector, OwnedVector, MutableVector, ImmutableVector, OwnedCloneableVector};\n+use vec::Vec;\n \n // Reexports\n pub use self::stdio::stdin;\n@@ -486,9 +486,9 @@ pub trait Reader {\n     /// or EOF. If `Ok(())` is returned, then all of the requested bytes were\n     /// pushed on to the vector, otherwise the amount `len` bytes couldn't be\n     /// read (an error was encountered), and the error is returned.\n-    fn push_exact(&mut self, buf: &mut ~[u8], len: uint) -> IoResult<()> {\n+    fn push_exact(&mut self, buf: &mut Vec<u8>, len: uint) -> IoResult<()> {\n         struct State<'a> {\n-            buf: &'a mut ~[u8],\n+            buf: &'a mut Vec<u8>,\n             total_read: uint\n         }\n \n@@ -526,8 +526,8 @@ pub trait Reader {\n     /// have already been consumed from the underlying reader, and they are lost\n     /// (not returned as part of the error). If this is unacceptable, then it is\n     /// recommended to use the `push_exact` or `read` methods.\n-    fn read_exact(&mut self, len: uint) -> IoResult<~[u8]> {\n-        let mut buf = slice::with_capacity(len);\n+    fn read_exact(&mut self, len: uint) -> IoResult<Vec<u8>> {\n+        let mut buf = Vec::with_capacity(len);\n         match self.push_exact(&mut buf, len) {\n             Ok(()) => Ok(buf),\n             Err(e) => Err(e),\n@@ -542,8 +542,8 @@ pub trait Reader {\n     /// discarded when an error is returned.\n     ///\n     /// When EOF is encountered, all bytes read up to that point are returned.\n-    fn read_to_end(&mut self) -> IoResult<~[u8]> {\n-        let mut buf = slice::with_capacity(DEFAULT_BUF_SIZE);\n+    fn read_to_end(&mut self) -> IoResult<Vec<u8>> {\n+        let mut buf = Vec::with_capacity(DEFAULT_BUF_SIZE);\n         loop {\n             match self.push_exact(&mut buf, DEFAULT_BUF_SIZE) {\n                 Ok(()) => {}\n@@ -564,8 +564,8 @@ pub trait Reader {\n     /// UTF-8 bytes.\n     fn read_to_str(&mut self) -> IoResult<~str> {\n         self.read_to_end().and_then(|s| {\n-            match str::from_utf8_owned(s) {\n-                Some(s) => Ok(s),\n+            match str::from_utf8(s.as_slice()) {\n+                Some(s) => Ok(s.to_owned()),\n                 None => Err(standard_error(InvalidInput)),\n             }\n         })\n@@ -1198,8 +1198,8 @@ pub trait Buffer: Reader {\n     /// valid UTF-8 sequence of bytes.\n     fn read_line(&mut self) -> IoResult<~str> {\n         self.read_until('\\n' as u8).and_then(|line|\n-            match str::from_utf8_owned(line) {\n-                Some(s) => Ok(s),\n+            match str::from_utf8(line.as_slice()) {\n+                Some(s) => Ok(s.to_owned()),\n                 None => Err(standard_error(InvalidInput)),\n             }\n         )\n@@ -1230,8 +1230,8 @@ pub trait Buffer: Reader {\n     /// have been read, otherwise the pending byte buffer is returned. This\n     /// is the reason that the byte buffer returned may not always contain the\n     /// delimiter.\n-    fn read_until(&mut self, byte: u8) -> IoResult<~[u8]> {\n-        let mut res = ~[];\n+    fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> {\n+        let mut res = Vec::new();\n \n         let mut used;\n         loop {"}, {"sha": "02c061c54dd9941067df412e00dfb652d158ce6d", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -718,14 +718,14 @@ mod test {\n         spawn(proc() {\n             let mut a = a;\n             let mut c = a.accept().unwrap();\n-            assert_eq!(c.read_to_end(), Ok(~[]));\n+            assert_eq!(c.read_to_end(), Ok(vec!()));\n             c.write([1]).unwrap();\n         });\n \n         let mut s = TcpStream::connect(addr).unwrap();\n         assert!(s.obj.close_write().is_ok());\n         assert!(s.write([1]).is_err());\n-        assert_eq!(s.read_to_end(), Ok(~[1]));\n+        assert_eq!(s.read_to_end(), Ok(vec!(1)));\n     })\n }\n "}, {"sha": "f0b96e2e76c0b9a862f6dd7bc5fcfbf90329e793", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -142,9 +142,9 @@ pub struct ProcessOutput {\n     /// The status (exit code) of the process.\n     pub status: ProcessExit,\n     /// The data that the process wrote to stdout.\n-    pub output: ~[u8],\n+    pub output: Vec<u8>,\n     /// The data that the process wrote to stderr.\n-    pub error: ~[u8],\n+    pub error: Vec<u8>,\n }\n \n /// Describes what to do with a standard io stream for a child process.\n@@ -277,8 +277,8 @@ impl Process {\n     /// };\n     ///\n     /// println!(\"status: {}\", output.status);\n-    /// println!(\"stdout: {}\", str::from_utf8_lossy(output.output));\n-    /// println!(\"stderr: {}\", str::from_utf8_lossy(output.error));\n+    /// println!(\"stdout: {}\", str::from_utf8_lossy(output.output.as_slice()));\n+    /// println!(\"stderr: {}\", str::from_utf8_lossy(output.error.as_slice()));\n     /// ```\n     pub fn output(prog: &str, args: &[~str]) -> IoResult<ProcessOutput> {\n         Process::new(prog, args).map(|mut p| p.wait_with_output())\n@@ -387,14 +387,14 @@ impl Process {\n     /// The stdin handle to the child is closed before waiting.\n     pub fn wait_with_output(&mut self) -> ProcessOutput {\n         drop(self.stdin.take());\n-        fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<~[u8]>> {\n+        fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> {\n             let (tx, rx) = channel();\n             match stream {\n                 Some(stream) => spawn(proc() {\n                     let mut stream = stream;\n                     tx.send(stream.read_to_end())\n                 }),\n-                None => tx.send(Ok(~[]))\n+                None => tx.send(Ok(Vec::new()))\n             }\n             rx\n         }\n@@ -404,8 +404,8 @@ impl Process {\n         let status = self.wait();\n \n         ProcessOutput { status: status,\n-                        output: stdout.recv().ok().unwrap_or(~[]),\n-                        error:  stderr.recv().ok().unwrap_or(~[]) }\n+                        output: stdout.recv().ok().unwrap_or(Vec::new()),\n+                        error:  stderr.recv().ok().unwrap_or(Vec::new()) }\n     }\n }\n \n@@ -614,13 +614,13 @@ mod tests {\n \n         let ProcessOutput {status, output, error}\n              = Process::output(\"echo\", [~\"hello\"]).unwrap();\n-        let output_str = str::from_utf8_owned(output).unwrap();\n+        let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n         // FIXME #7224\n         if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n+            assert_eq!(error, Vec::new());\n         }\n     })\n \n@@ -630,7 +630,7 @@ mod tests {\n              = Process::output(\"mkdir\", [~\".\"]).unwrap();\n \n         assert!(status.matches_exit_status(1));\n-        assert_eq!(output, ~[]);\n+        assert_eq!(output, Vec::new());\n         assert!(!error.is_empty());\n     })\n \n@@ -652,13 +652,13 @@ mod tests {\n \n         let mut prog = Process::new(\"echo\", [~\"hello\"]).unwrap();\n         let ProcessOutput {status, output, error} = prog.wait_with_output();\n-        let output_str = str::from_utf8_owned(output).unwrap();\n+        let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n         // FIXME #7224\n         if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n+            assert_eq!(error, Vec::new());\n         }\n     })\n \n@@ -667,22 +667,22 @@ mod tests {\n         let mut prog = Process::new(\"echo\", [~\"hello\"]).unwrap();\n         let ProcessOutput {status, output, error} = prog.wait_with_output();\n \n-        let output_str = str::from_utf8_owned(output).unwrap();\n+        let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n         // FIXME #7224\n         if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n+            assert_eq!(error, Vec::new());\n         }\n \n         let ProcessOutput {status, output, error} = prog.wait_with_output();\n \n         assert!(status.success());\n-        assert_eq!(output, ~[]);\n+        assert_eq!(output, Vec::new());\n         // FIXME #7224\n         if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n+            assert_eq!(error, Vec::new());\n         }\n     })\n \n@@ -718,7 +718,7 @@ mod tests {\n         use os;\n         let mut prog = run_pwd(None);\n \n-        let output = str::from_utf8_owned(prog.wait_with_output().output).unwrap();\n+        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n         let parent_dir = os::getcwd();\n         let child_dir = Path::new(output.trim());\n \n@@ -736,7 +736,7 @@ mod tests {\n         let parent_dir = os::getcwd().dir_path();\n         let mut prog = run_pwd(Some(&parent_dir));\n \n-        let output = str::from_utf8_owned(prog.wait_with_output().output).unwrap();\n+        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n         let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n@@ -780,7 +780,7 @@ mod tests {\n         if running_on_valgrind() { return; }\n \n         let mut prog = run_env(None);\n-        let output = str::from_utf8_owned(prog.wait_with_output().output).unwrap();\n+        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -794,7 +794,7 @@ mod tests {\n         if running_on_valgrind() { return; }\n \n         let mut prog = run_env(None);\n-        let output = str::from_utf8_owned(prog.wait_with_output().output).unwrap();\n+        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -811,7 +811,7 @@ mod tests {\n \n         let mut prog = run_env(Some(new_env));\n         let result = prog.wait_with_output();\n-        let output = str::from_utf8_lossy(result.output).into_owned();\n+        let output = str::from_utf8_lossy(result.output.as_slice()).into_owned();\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);"}, {"sha": "b2661cb74e4a50ce5d274c1c36c39aada4e01db8", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -207,7 +207,7 @@ mod test {\n         let mut r = MemReader::new(~[0, 1, 2]);\n         {\n             let mut r = LimitReader::new(r.by_ref(), 4);\n-            assert_eq!(~[0, 1, 2], r.read_to_end().unwrap());\n+            assert_eq!(vec!(0, 1, 2), r.read_to_end().unwrap());\n         }\n     }\n \n@@ -216,9 +216,9 @@ mod test {\n         let mut r = MemReader::new(~[0, 1, 2]);\n         {\n             let mut r = LimitReader::new(r.by_ref(), 2);\n-            assert_eq!(~[0, 1], r.read_to_end().unwrap());\n+            assert_eq!(vec!(0, 1), r.read_to_end().unwrap());\n         }\n-        assert_eq!(~[2], r.read_to_end().unwrap());\n+        assert_eq!(vec!(2), r.read_to_end().unwrap());\n     }\n \n     #[test]\n@@ -228,7 +228,7 @@ mod test {\n         assert_eq!(3, r.limit());\n         assert_eq!(0, r.read_byte().unwrap());\n         assert_eq!(2, r.limit());\n-        assert_eq!(~[1, 2], r.read_to_end().unwrap());\n+        assert_eq!(vec!(1, 2), r.read_to_end().unwrap());\n         assert_eq!(0, r.limit());\n     }\n \n@@ -288,14 +288,14 @@ mod test {\n         let rs = ~[MemReader::new(~[0, 1]), MemReader::new(~[]),\n                    MemReader::new(~[2, 3])];\n         let mut r = ChainedReader::new(rs.move_iter());\n-        assert_eq!(~[0, 1, 2, 3], r.read_to_end().unwrap());\n+        assert_eq!(vec!(0, 1, 2, 3), r.read_to_end().unwrap());\n     }\n \n     #[test]\n     fn test_tee_reader() {\n         let mut r = TeeReader::new(MemReader::new(~[0, 1, 2]),\n                                    MemWriter::new());\n-        assert_eq!(~[0, 1, 2], r.read_to_end().unwrap());\n+        assert_eq!(vec!(0, 1, 2), r.read_to_end().unwrap());\n         let (_, w) = r.unwrap();\n         assert_eq!(~[0, 1, 2], w.unwrap());\n     }"}, {"sha": "008532bcafe67cb3a237fbb4155dfda54f0e8e97", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -113,13 +113,13 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n         Ok(bytes) => bytes,\n     };\n-    match str::from_utf8_owned(bytes) {\n+    match str::from_utf8(bytes.as_slice()) {\n         Some(src) => {\n             // Add this input file to the code map to make it available as\n             // dependency information\n             let filename = file.display().to_str();\n             let interned = token::intern_and_get_ident(src);\n-            cx.codemap().new_filemap(filename, src);\n+            cx.codemap().new_filemap(filename, src.to_owned());\n \n             base::MRExpr(cx.expr_str(sp, interned))\n         }"}, {"sha": "bb812f7f6b4136c16009afeeed3d78dbe957994e", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -350,7 +350,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n                                     srdr: &mut io::Reader)\n                                  -> (Vec<Comment>, Vec<Literal>) {\n     let src = srdr.read_to_end().unwrap();\n-    let src = str::from_utf8_owned(src).unwrap();\n+    let src = str::from_utf8(src.as_slice()).unwrap().to_owned();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let mut rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);"}, {"sha": "35f9898ebbbf76345d6b62341f295e733063f2b5", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -228,9 +228,10 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n             unreachable!()\n         }\n     };\n-    match str::from_utf8_owned(bytes) {\n+    match str::from_utf8(bytes.as_slice()) {\n         Some(s) => {\n-            return string_to_filemap(sess, s, path.as_str().unwrap().to_str())\n+            return string_to_filemap(sess, s.to_owned(),\n+                                     path.as_str().unwrap().to_str())\n         }\n         None => err(format!(\"{} is not UTF-8 encoded\", path.display())),\n     }\n@@ -292,7 +293,7 @@ mod test {\n         let mut writer = MemWriter::new();\n         let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n         let _ = val.encode(&mut encoder);\n-        str::from_utf8_owned(writer.unwrap()).unwrap()\n+        str::from_utf8(writer.unwrap().as_slice()).unwrap().to_owned()\n     }\n \n     // produce a codemap::span"}, {"sha": "37ef3c133a57f639d08c6e9a583e1b84492896da", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -208,8 +208,8 @@ pub fn parse(file: &mut io::Reader,\n \n     // don't read NUL\n     let bytes = try!(file.read_exact(names_bytes as uint - 1));\n-    let names_str = match str::from_utf8_owned(bytes) {\n-        Some(s) => s, None => return Err(~\"input not utf-8\"),\n+    let names_str = match str::from_utf8(bytes.as_slice()) {\n+        Some(s) => s.to_owned(), None => return Err(~\"input not utf-8\"),\n     };\n \n     let term_names: Vec<~str> = names_str.split('|').map(|s| s.to_owned()).collect();"}, {"sha": "8883abffb93a1a7c5ae696ebccd14cbebcdb432f", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -479,7 +479,7 @@ impl<'a, T:Send +\n fn test() {\n     use std::os;\n     use std::io::{fs, Process};\n-    use std::str::from_utf8_owned;\n+    use std::str::from_utf8;\n \n     // Create a path to a new file 'filename' in the directory in which\n     // this test is running.\n@@ -505,7 +505,7 @@ fn test() {\n         let pth = pth.clone();\n \n         let contents = File::open(&pth).read_to_end().unwrap();\n-        let file_content = from_utf8_owned(contents).unwrap();\n+        let file_content = from_utf8(contents.as_slice()).unwrap().to_owned();\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);"}, {"sha": "4ee4f94d4354bc8e8e3685f9f267c9b3a6f52433", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -44,7 +44,7 @@ fn main() {\n     };\n     let mut data = data.unwrap();\n \n-    for seq in data.mut_split(|c| *c == '>' as u8) {\n+    for seq in data.as_mut_slice().mut_split(|c| *c == '>' as u8) {\n         // skip header and last \\n\n         let begin = match seq.iter().position(|c| *c == '\\n' as u8) {\n             None => continue,\n@@ -80,5 +80,5 @@ fn main() {\n         }\n     }\n \n-    stdout().write(data).unwrap();\n+    stdout().write(data.as_slice()).unwrap();\n }"}, {"sha": "66ddbac05134200be493300d55306063c551c17a", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -58,7 +58,7 @@ fn main() {\n         // rustc is passed to us with --out-dir and -L etc., so we\n         // can't exec it directly\n         let result = Process::output(\"sh\", [~\"-c\", rustc + \" \" + main_file_str]).unwrap();\n-        let err = str::from_utf8_lossy(result.error);\n+        let err = str::from_utf8_lossy(result.error.as_slice());\n \n         // positive test so that this test will be updated when the\n         // compiler changes."}, {"sha": "faa22962290e7ae01f98b896270250dfb4258e83", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -55,7 +55,7 @@ fn main() {\n         // can't exec it directly\n         let result = Process::output(\"sh\", [~\"-c\", rustc + \" \" + main_file_str]).unwrap();\n \n-        let err = str::from_utf8_lossy(result.error);\n+        let err = str::from_utf8_lossy(result.error.as_slice());\n \n         // the span should end the line (e.g no extra ~'s)\n         let expected_span = \"^\" + \"~\".repeat(n - 1) + \"\\n\";"}, {"sha": "a34403daaab3ac277e1e9bec5759975f6333b928", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -53,7 +53,7 @@ fn runtest(me: &str) {\n     }).unwrap();\n     let out = p.wait_with_output();\n     assert!(!out.status.success());\n-    let s = str::from_utf8(out.error).unwrap();\n+    let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(s.contains(\"stack backtrace\") && s.contains(\"foo::h\"),\n             \"bad output: {}\", s);\n \n@@ -65,7 +65,7 @@ fn runtest(me: &str) {\n     }).unwrap();\n     let out = p.wait_with_output();\n     assert!(!out.status.success());\n-    let s = str::from_utf8(out.error).unwrap();\n+    let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(!s.contains(\"stack backtrace\") && !s.contains(\"foo::h\"),\n             \"bad output2: {}\", s);\n \n@@ -77,7 +77,7 @@ fn runtest(me: &str) {\n     }).unwrap();\n     let out = p.wait_with_output();\n     assert!(!out.status.success());\n-    let s = str::from_utf8(out.error).unwrap();\n+    let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(s.contains(\"stack backtrace\") && s.contains(\"double::h\"),\n             \"bad output3: {}\", s);\n \n@@ -90,7 +90,7 @@ fn runtest(me: &str) {\n     }).unwrap();\n     let out = p.wait_with_output();\n     assert!(!out.status.success());\n-    let s = str::from_utf8(out.error).unwrap();\n+    let s = str::from_utf8(out.error.as_slice()).unwrap();\n     let mut i = 0;\n     for _ in range(0, 2) {\n         i += s.slice_from(i + 10).find_str(\"stack backtrace\").unwrap() + 10;"}, {"sha": "2e710cbf5c86c82f8af8dda0b9654f266de3170c", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0e60b72ee3f5fb07b01143d82362cb42307f32d/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=d0e60b72ee3f5fb07b01143d82362cb42307f32d", "patch": "@@ -43,12 +43,12 @@ fn main() {\n     } else {\n         let silent = Process::output(args[0], [~\"silent\"]).unwrap();\n         assert!(!silent.status.success());\n-        let error = str::from_utf8_lossy(silent.error);\n+        let error = str::from_utf8_lossy(silent.error.as_slice());\n         assert!(error.as_slice().contains(\"has overflowed its stack\"));\n \n         let loud = Process::output(args[0], [~\"loud\"]).unwrap();\n         assert!(!loud.status.success());\n-        let error = str::from_utf8_lossy(silent.error);\n+        let error = str::from_utf8_lossy(silent.error.as_slice());\n         assert!(error.as_slice().contains(\"has overflowed its stack\"));\n     }\n }"}]}