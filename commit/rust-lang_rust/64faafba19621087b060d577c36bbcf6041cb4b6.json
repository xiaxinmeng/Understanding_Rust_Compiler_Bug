{"sha": "64faafba19621087b060d577c36bbcf6041cb4b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZmFhZmJhMTk2MjEwODdiMDYwZDU3N2MzNmJiY2Y2MDQxY2I0YjY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-17T04:58:21Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-20T07:34:32Z"}, "message": "rustc: Optimize reading metadata by 4x\n\nWe were previously reading metadata via `ar p`, but as learned from rustdoc\nawhile back, spawning a process to do something is pretty slow. Turns out LLVM\nhas an Archive class to read archives, but it cannot write archives.\n\nThis commits adds bindings to the read-only version of the LLVM archive class\n(with a new type that only has a read() method), and then it uses this class\nwhen reading the metadata out of rlibs. When you put this in tandem of not\ncompressing the metadata, reading the metadata is 4x faster than it used to be\nThe timings I got for reading metadata from the respective libraries was:\n\n    libstd-04ff901e-0.9-pre.dylib    => 100ms\n    libstd-04ff901e-0.9-pre.rlib     => 23ms\n    librustuv-7945354c-0.9-pre.dylib => 4ms\n    librustuv-7945354c-0.9-pre.rlib  => 1ms\n    librustc-5b94a16f-0.9-pre.dylib  => 87ms\n    librustc-5b94a16f-0.9-pre.rlib   => 35ms\n    libextra-a6ebb16f-0.9-pre.dylib  => 63ms\n    libextra-a6ebb16f-0.9-pre.rlib   => 15ms\n    libsyntax-2e4c0458-0.9-pre.dylib => 86ms\n    libsyntax-2e4c0458-0.9-pre.rlib  => 22ms\n\nIn order to always take advantage of these faster metadata read-times, I sort\nthe files in filesearch based on whether they have an rlib extension or not\n(prefer all rlib files first).\n\nOverall, this halved the compile time for a `fn main() {}` crate from 0.185s to\n0.095s on my system (when preferring dynamic linking). Reading metadata is still\nthe slowest pass of the compiler at 0.035s, but it's getting pretty close to\nlinking at 0.021s! The next best optimization is to just not copy the metadata\nfrom LLVM because that's the most expensive part of reading metadata right now.", "tree": {"sha": "7cd40bc723b19751bb213c0d8f345c1c07f7241f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cd40bc723b19751bb213c0d8f345c1c07f7241f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64faafba19621087b060d577c36bbcf6041cb4b6", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64faafba19621087b060d577c36bbcf6041cb4b6", "html_url": "https://github.com/rust-lang/rust/commit/64faafba19621087b060d577c36bbcf6041cb4b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64faafba19621087b060d577c36bbcf6041cb4b6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "html_url": "https://github.com/rust-lang/rust/commit/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d"}], "stats": {"total": 203, "additions": 186, "deletions": 17}, "files": [{"sha": "453f0c42d8d8e159f5288c574b6f9ff5d15519e5", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=64faafba19621087b060d577c36bbcf6041cb4b6", "patch": "@@ -12,21 +12,29 @@\n \n use driver::session::Session;\n use metadata::filesearch;\n+use lib::llvm::{ArchiveRef, llvm};\n \n+use std::cast;\n use std::io::fs;\n+use std::libc;\n use std::os;\n use std::run::{ProcessOptions, Process, ProcessOutput};\n use std::str;\n+use std::unstable::raw;\n use extra::tempfile::TempDir;\n use syntax::abi;\n \n-pub static METADATA_FILENAME: &'static str = \"metadata\";\n+pub static METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n \n pub struct Archive {\n     priv sess: Session,\n     priv dst: Path,\n }\n \n+pub struct ArchiveRO {\n+    priv ptr: ArchiveRef,\n+}\n+\n fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n         paths: &[&Path]) -> ProcessOutput {\n     let ar = sess.opts.ar.clone().unwrap_or_else(|| ~\"ar\");\n@@ -193,3 +201,50 @@ impl Archive {\n                                  perhaps an -L flag is missing?\", name));\n     }\n }\n+\n+impl ArchiveRO {\n+    /// Opens a static archive for read-only purposes. This is more optimized\n+    /// than the `open` method because it uses LLVM's internal `Archive` class\n+    /// rather than shelling out to `ar` for everything.\n+    ///\n+    /// If this archive is used with a mutable method, then an error will be\n+    /// raised.\n+    pub fn open(dst: &Path) -> Option<ArchiveRO> {\n+        unsafe {\n+            let ar = dst.with_c_str(|dst| {\n+                llvm::LLVMRustOpenArchive(dst)\n+            });\n+            if ar.is_null() {\n+                None\n+            } else {\n+                Some(ArchiveRO { ptr: ar })\n+            }\n+        }\n+    }\n+\n+    /// Read a file in the archive\n+    pub fn read<'a>(&'a self, file: &str) -> Option<&'a [u8]> {\n+        unsafe {\n+            let mut size = 0 as libc::size_t;\n+            let ptr = file.with_c_str(|file| {\n+                llvm::LLVMRustArchiveReadSection(self.ptr, file, &mut size)\n+            });\n+            if ptr.is_null() {\n+                None\n+            } else {\n+                Some(cast::transmute(raw::Slice {\n+                    data: ptr,\n+                    len: size as uint,\n+                }))\n+            }\n+        }\n+    }\n+}\n+\n+impl Drop for ArchiveRO {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMRustDestroyArchive(self.ptr);\n+        }\n+    }\n+}"}, {"sha": "95801ad55fbace95d6702bf3cdbe97dc41055d70", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=64faafba19621087b060d577c36bbcf6041cb4b6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::archive::Archive;\n+use back::archive::ArchiveRO;\n use back::link;\n use driver::session;\n use lib::llvm::{ModuleRef, TargetMachineRef, llvm, True, False};\n@@ -43,10 +43,11 @@ pub fn run(sess: session::Session, llmod: ModuleRef,\n             }\n         };\n \n-        let archive = Archive::open(sess, path);\n+        let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         debug!(\"reading {}\", name);\n         let bc = time(sess.time_passes(), format!(\"read {}.bc\", name), (), |_|\n                       archive.read(format!(\"{}.bc\", name)));\n+        let bc = bc.expect(\"missing bytecode in archive!\");\n         let ptr = bc.as_ptr();\n         debug!(\"linking {}\", name);\n         time(sess.time_passes(), format!(\"ll link {}\", name), (), |()| unsafe {"}, {"sha": "f02a497ee46b42c800d1e6d0fdbf277c7e35f90d", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=64faafba19621087b060d577c36bbcf6041cb4b6", "patch": "@@ -1100,7 +1100,6 @@ pub fn early_error(emitter: @diagnostic::Emitter, msg: &str) -> ! {\n \n pub fn list_metadata(sess: Session, path: &Path, out: @mut io::Writer) {\n     metadata::loader::list_file_metadata(\n-        sess,\n         token::get_ident_interner(),\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);\n }"}, {"sha": "7db4a06e6c02bf7d333282b46069bfd8736d21be", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=64faafba19621087b060d577c36bbcf6041cb4b6", "patch": "@@ -257,6 +257,8 @@ pub enum Pass_opaque {}\n pub type PassRef = *Pass_opaque;\n pub enum TargetMachine_opaque {}\n pub type TargetMachineRef = *TargetMachine_opaque;\n+pub enum Archive_opaque {}\n+pub type ArchiveRef = *Archive_opaque;\n \n pub mod debuginfo {\n     use super::{ValueRef};\n@@ -300,7 +302,7 @@ pub mod llvm {\n     use super::{Bool, BuilderRef, ContextRef, MemoryBufferRef, ModuleRef};\n     use super::{ObjectFileRef, Opcode, PassManagerRef, PassManagerBuilderRef};\n     use super::{SectionIteratorRef, TargetDataRef, TypeKind, TypeRef, UseRef};\n-    use super::{ValueRef, TargetMachineRef, FileType};\n+    use super::{ValueRef, TargetMachineRef, FileType, ArchiveRef};\n     use super::{CodeGenModel, RelocMode, CodeGenOptLevel};\n     use super::debuginfo::*;\n     use std::libc::{c_char, c_int, c_longlong, c_ushort, c_uint, c_ulonglong,\n@@ -1748,6 +1750,11 @@ pub mod llvm {\n                                           syms: **c_char,\n                                           len: size_t);\n         pub fn LLVMRustMarkAllFunctionsNounwind(M: ModuleRef);\n+\n+        pub fn LLVMRustOpenArchive(path: *c_char) -> ArchiveRef;\n+        pub fn LLVMRustArchiveReadSection(AR: ArchiveRef, name: *c_char,\n+                                          out_len: *mut size_t) -> *c_char;\n+        pub fn LLVMRustDestroyArchive(AR: ArchiveRef);\n     }\n }\n "}, {"sha": "2080db43a33d4918bcae95d5a58ae5c93e77a260", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=64faafba19621087b060d577c36bbcf6041cb4b6", "patch": "@@ -15,6 +15,7 @@\n \n use metadata::cstore;\n use metadata::decoder;\n+use metadata::loader;\n \n use std::hashmap::HashMap;\n use extra;\n@@ -29,6 +30,7 @@ pub type cnum_map = @mut HashMap<ast::CrateNum, ast::CrateNum>;\n \n pub enum MetadataBlob {\n     MetadataVec(~[u8]),\n+    MetadataArchive(loader::ArchiveMetadata),\n }\n \n pub struct crate_metadata {\n@@ -216,6 +218,7 @@ impl MetadataBlob {\n     pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n         match *self {\n             MetadataVec(ref vec) => vec.as_slice(),\n+            MetadataArchive(ref ar) => ar.as_slice(),\n         }\n     }\n }"}, {"sha": "66d42cf44298f20425628a8636b083ead8842357", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=64faafba19621087b060d577c36bbcf6041cb4b6", "patch": "@@ -123,7 +123,16 @@ pub fn search(filesearch: @FileSearch, pick: pick) {\n         match io::result(|| fs::readdir(lib_search_path)) {\n             Ok(files) => {\n                 let mut rslt = FileDoesntMatch;\n-                for path in files.iter() {\n+                let is_rlib = |p: & &Path| {\n+                    p.extension_str() == Some(\"rlib\")\n+                };\n+                // Reading metadata out of rlibs is faster, and if we find both\n+                // an rlib and a dylib we only read one of the files of\n+                // metadata, so in the name of speed, bring all rlib files to\n+                // the front of the search list.\n+                let files1 = files.iter().filter(|p| is_rlib(p));\n+                let files2 = files.iter().filter(|p| !is_rlib(p));\n+                for path in files1.chain(files2) {\n                     debug!(\"testing {}\", path.display());\n                     let maybe_picked = pick(path);\n                     match maybe_picked {"}, {"sha": "d670fc532b5f9081ff5c2bac83d5fe2d48a82b8f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 66, "deletions": 11, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=64faafba19621087b060d577c36bbcf6041cb4b6", "patch": "@@ -10,10 +10,10 @@\n \n //! Finds crate binaries and loads their metadata\n \n-use back::archive::{Archive, METADATA_FILENAME};\n+use back::archive::{ArchiveRO, METADATA_FILENAME};\n use driver::session::Session;\n use lib::llvm::{False, llvm, ObjectFile, mk_section_iter};\n-use metadata::cstore::{MetadataBlob, MetadataVec};\n+use metadata::cstore::{MetadataBlob, MetadataVec, MetadataArchive};\n use metadata::decoder;\n use metadata::encoder;\n use metadata::filesearch::{FileMatches, FileDoesntMatch};\n@@ -61,6 +61,12 @@ pub struct Library {\n     metadata: MetadataBlob,\n }\n \n+pub struct ArchiveMetadata {\n+    priv archive: ArchiveRO,\n+    // See comments in ArchiveMetadata::new for why this is static\n+    priv data: &'static [u8],\n+}\n+\n impl Context {\n     pub fn load_library_crate(&self) -> Library {\n         match self.find_library_crate() {\n@@ -102,7 +108,7 @@ impl Context {\n                     if candidate && existing {\n                         FileMatches\n                     } else if candidate {\n-                        match get_metadata_section(self.sess, self.os, path) {\n+                        match get_metadata_section(self.os, path) {\n                             Some(cvec) =>\n                                 if crate_matches(cvec.as_slice(), self.name,\n                                                  self.version, self.hash) {\n@@ -248,11 +254,60 @@ fn crate_matches(crate_data: &[u8],\n     }\n }\n \n-fn get_metadata_section(sess: Session, os: Os,\n-                        filename: &Path) -> Option<MetadataBlob> {\n+impl ArchiveMetadata {\n+    fn new(ar: ArchiveRO) -> Option<ArchiveMetadata> {\n+        let data: &'static [u8] = {\n+            let data = match ar.read(METADATA_FILENAME) {\n+                Some(data) => data,\n+                None => {\n+                    debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n+                    return None;\n+                }\n+            };\n+            // This data is actually a pointer inside of the archive itself, but\n+            // we essentially want to cache it because the lookup inside the\n+            // archive is a fairly expensive operation (and it's queried for\n+            // *very* frequently). For this reason, we transmute it to the\n+            // static lifetime to put into the struct. Note that the buffer is\n+            // never actually handed out with a static lifetime, but rather the\n+            // buffer is loaned with the lifetime of this containing object.\n+            // Hence, we're guaranteed that the buffer will never be used after\n+            // this object is dead, so this is a safe operation to transmute and\n+            // store the data as a static buffer.\n+            unsafe { cast::transmute(data) }\n+        };\n+        Some(ArchiveMetadata {\n+            archive: ar,\n+            data: data,\n+        })\n+    }\n+\n+    pub fn as_slice<'a>(&'a self) -> &'a [u8] { self.data }\n+}\n+\n+// Just a small wrapper to time how long reading metadata takes.\n+fn get_metadata_section(os: Os, filename: &Path) -> Option<MetadataBlob> {\n+    use extra::time;\n+    let start = time::precise_time_ns();\n+    let ret = get_metadata_section_imp(os, filename);\n+    info!(\"reading {} => {}ms\", filename.filename_display(),\n+           (time::precise_time_ns() - start) / 1000000);\n+    return ret;\n+}\n+\n+fn get_metadata_section_imp(os: Os, filename: &Path) -> Option<MetadataBlob> {\n     if filename.filename_str().unwrap().ends_with(\".rlib\") {\n-        let archive = Archive::open(sess, filename.clone());\n-        return Some(MetadataVec(archive.read(METADATA_FILENAME)));\n+        // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n+        // internally to read the file. We also avoid even using a memcpy by\n+        // just keeping the archive along while the metadata is in use.\n+        let archive = match ArchiveRO::open(filename) {\n+            Some(ar) => ar,\n+            None => {\n+                debug!(\"llvm didn't like `{}`\", filename.display());\n+                return None;\n+            }\n+        };\n+        return ArchiveMetadata::new(archive).map(|ar| MetadataArchive(ar));\n     }\n     unsafe {\n         let mb = filename.with_c_str(|buf| {\n@@ -322,13 +377,13 @@ pub fn read_meta_section_name(os: Os) -> &'static str {\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-pub fn list_file_metadata(sess: Session,\n-                          intr: @ident_interner,\n+pub fn list_file_metadata(intr: @ident_interner,\n                           os: Os,\n                           path: &Path,\n                           out: @mut io::Writer) {\n-    match get_metadata_section(sess, os, path) {\n-      option::Some(bytes) => decoder::list_crate_metadata(intr, bytes.as_slice(),\n+    match get_metadata_section(os, path) {\n+      option::Some(bytes) => decoder::list_crate_metadata(intr,\n+                                                          bytes.as_slice(),\n                                                           out),\n       option::None => {\n         write!(out, \"could not find metadata in {}.\\n\", path.display())"}, {"sha": "d66f90a5352c17012511162af857bc92dbfb477a", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/64faafba19621087b060d577c36bbcf6041cb4b6/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=64faafba19621087b060d577c36bbcf6041cb4b6", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #include \"rustllvm.h\"\n+#include \"llvm/Object/Archive.h\"\n \n //===----------------------------------------------------------------------===\n //\n@@ -19,6 +20,7 @@\n \n using namespace llvm;\n using namespace llvm::sys;\n+using namespace llvm::object;\n \n const char *LLVMRustError;\n \n@@ -558,3 +560,41 @@ LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n     }\n     return true;\n }\n+\n+extern \"C\" void*\n+LLVMRustOpenArchive(char *path) {\n+    OwningPtr<MemoryBuffer> buf;\n+    error_code err = MemoryBuffer::getFile(path, buf);\n+    if (err) {\n+        LLVMRustError = err.message().c_str();\n+        return NULL;\n+    }\n+    Archive *ret = new Archive(buf.take(), err);\n+    if (err) {\n+        LLVMRustError = err.message().c_str();\n+        return NULL;\n+    }\n+    return ret;\n+}\n+\n+extern \"C\" const char*\n+LLVMRustArchiveReadSection(Archive *ar, char *name, size_t *size) {\n+    for (Archive::child_iterator child = ar->begin_children(),\n+                                   end = ar->end_children();\n+         child != end; ++child) {\n+        StringRef sect_name;\n+        error_code err = child->getName(sect_name);\n+        if (err) continue;\n+        if (sect_name.trim(\" \") == name) {\n+            StringRef buf = child->getBuffer();\n+            *size = buf.size();\n+            return buf.data();\n+        }\n+    }\n+    return NULL;\n+}\n+\n+extern \"C\" void\n+LLVMRustDestroyArchive(Archive *ar) {\n+    delete ar;\n+}"}]}