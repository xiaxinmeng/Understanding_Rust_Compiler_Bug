{"sha": "9b471a3f5fe57e5c6e08acf665f2094422415a3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNDcxYTNmNWZlNTdlNWM2ZTA4YWNmNjY1ZjIwOTQ0MjI0MTVhM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-19T16:39:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-19T16:39:03Z"}, "message": "Auto merge of #82020 - jyn514:mut-passes, r=camelid,GuillaumeGomez\n\nMake `Clean` take &mut DocContext\n\n- Take `FnMut` in `rustc_trait_selection::find_auto_trait_generics`\n- Take `&mut DocContext` in most of `clean`\n- Collect the iterator in auto_trait_impls instead of iterating lazily; the lifetimes were really bad.\n\nThis combined with https://github.com/rust-lang/rust/pull/82018 should hopefully help with https://github.com/rust-lang/rust/pull/82014 by allowing `cx.cache.exported_traits` to be modified in `register_res`. Previously it had to use interior mutability, which required either adding a RefCell to `cache.exported_traits` on *top* of the existing `RefCell<Cache>` or mixing reads and writes between `cx.exported_traits` and `cx.cache.exported_traits`. I don't currently have that working but I expect it to be reasonably easy to add after this.", "tree": {"sha": "a7cfdbfe655ddca8f88b5e00192c8ce95feb8a9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7cfdbfe655ddca8f88b5e00192c8ce95feb8a9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b471a3f5fe57e5c6e08acf665f2094422415a3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b471a3f5fe57e5c6e08acf665f2094422415a3d", "html_url": "https://github.com/rust-lang/rust/commit/9b471a3f5fe57e5c6e08acf665f2094422415a3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b471a3f5fe57e5c6e08acf665f2094422415a3d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8599bff5a3556059817503030e248507706e96b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8599bff5a3556059817503030e248507706e96b4", "html_url": "https://github.com/rust-lang/rust/commit/8599bff5a3556059817503030e248507706e96b4"}, {"sha": "2bc5a0a600d99b0597b63c7c878836b005790763", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bc5a0a600d99b0597b63c7c878836b005790763", "html_url": "https://github.com/rust-lang/rust/commit/2bc5a0a600d99b0597b63c7c878836b005790763"}], "stats": {"total": 612, "additions": 285, "deletions": 327}, "files": [{"sha": "97cc258d425111776644dde1ddb7e5d8916530b8", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -77,7 +77,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n         ty: Ty<'tcx>,\n         orig_env: ty::ParamEnv<'tcx>,\n         trait_did: DefId,\n-        auto_trait_callback: impl Fn(&InferCtxt<'_, 'tcx>, AutoTraitInfo<'tcx>) -> A,\n+        mut auto_trait_callback: impl FnMut(&InferCtxt<'_, 'tcx>, AutoTraitInfo<'tcx>) -> A,\n     ) -> AutoTraitResult<A> {\n         let tcx = self.tcx;\n "}, {"sha": "d43378081ce580de920d4bfd02cefaddf55bb799", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 36, "deletions": 49, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -21,42 +21,38 @@ struct RegionDeps<'tcx> {\n }\n \n crate struct AutoTraitFinder<'a, 'tcx> {\n-    crate cx: &'a core::DocContext<'tcx>,\n-    crate f: auto_trait::AutoTraitFinder<'tcx>,\n+    crate cx: &'a mut core::DocContext<'tcx>,\n }\n \n impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n-    crate fn new(cx: &'a core::DocContext<'tcx>) -> Self {\n-        let f = auto_trait::AutoTraitFinder::new(cx.tcx);\n-\n-        AutoTraitFinder { cx, f }\n+    crate fn new(cx: &'a mut core::DocContext<'tcx>) -> Self {\n+        AutoTraitFinder { cx }\n     }\n \n     // FIXME(eddyb) figure out a better way to pass information about\n     // parametrization of `ty` than `param_env_def_id`.\n-    crate fn get_auto_trait_impls(&self, ty: Ty<'tcx>, param_env_def_id: DefId) -> Vec<Item> {\n-        let param_env = self.cx.tcx.param_env(param_env_def_id);\n+    crate fn get_auto_trait_impls(&mut self, ty: Ty<'tcx>, param_env_def_id: DefId) -> Vec<Item> {\n+        let tcx = self.cx.tcx;\n+        let param_env = tcx.param_env(param_env_def_id);\n+        let f = auto_trait::AutoTraitFinder::new(self.cx.tcx);\n \n         debug!(\"get_auto_trait_impls({:?})\", ty);\n-        let auto_traits = self.cx.auto_traits.iter().cloned();\n+        let auto_traits: Vec<_> = self.cx.auto_traits.iter().cloned().collect();\n         auto_traits\n+            .into_iter()\n             .filter_map(|trait_def_id| {\n-                let trait_ref = ty::TraitRef {\n-                    def_id: trait_def_id,\n-                    substs: self.cx.tcx.mk_substs_trait(ty, &[]),\n-                };\n+                let trait_ref =\n+                    ty::TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(ty, &[]) };\n                 if !self.cx.generated_synthetics.borrow_mut().insert((ty, trait_def_id)) {\n                     debug!(\"get_auto_trait_impl_for({:?}): already generated, aborting\", trait_ref);\n                     return None;\n                 }\n \n                 let result =\n-                    self.f.find_auto_trait_generics(ty, param_env, trait_def_id, |infcx, info| {\n+                    f.find_auto_trait_generics(ty, param_env, trait_def_id, |infcx, info| {\n                         let region_data = info.region_data;\n \n-                        let names_map = self\n-                            .cx\n-                            .tcx\n+                        let names_map = tcx\n                             .generics_of(param_env_def_id)\n                             .params\n                             .iter()\n@@ -66,7 +62,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                             })\n                             .map(|name| (name, Lifetime(name)))\n                             .collect();\n-                        let lifetime_predicates = self.handle_lifetimes(&region_data, &names_map);\n+                        let lifetime_predicates = Self::handle_lifetimes(&region_data, &names_map);\n                         let new_generics = self.param_env_to_generics(\n                             infcx.tcx,\n                             param_env_def_id,\n@@ -105,12 +101,10 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                         // Instead, we generate `impl !Send for Foo<T>`, which better\n                         // expresses the fact that `Foo<T>` never implements `Send`,\n                         // regardless of the choice of `T`.\n-                        let params = (\n-                            self.cx.tcx.generics_of(param_env_def_id),\n-                            ty::GenericPredicates::default(),\n-                        )\n-                            .clean(self.cx)\n-                            .params;\n+                        let params =\n+                            (tcx.generics_of(param_env_def_id), ty::GenericPredicates::default())\n+                                .clean(self.cx)\n+                                .params;\n \n                         Generics { params, where_predicates: Vec::new() }\n                     }\n@@ -139,12 +133,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .collect()\n     }\n \n-    fn get_lifetime(\n-        &self,\n-        region: Region<'_>,\n-        names_map: &FxHashMap<Symbol, Lifetime>,\n-    ) -> Lifetime {\n-        self.region_name(region)\n+    fn get_lifetime(region: Region<'_>, names_map: &FxHashMap<Symbol, Lifetime>) -> Lifetime {\n+        region_name(region)\n             .map(|name| {\n                 names_map.get(&name).unwrap_or_else(|| {\n                     panic!(\"Missing lifetime with name {:?} for {:?}\", name.as_str(), region)\n@@ -154,13 +144,6 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .clone()\n     }\n \n-    fn region_name(&self, region: Region<'_>) -> Option<Symbol> {\n-        match region {\n-            &ty::ReEarlyBound(r) => Some(r.name),\n-            _ => None,\n-        }\n-    }\n-\n     // This method calculates two things: Lifetime constraints of the form 'a: 'b,\n     // and region constraints of the form ReVar: 'a\n     //\n@@ -172,7 +155,6 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     // to perform the calculations we need on our own, rather than trying to make\n     // existing inference/solver code do what we want.\n     fn handle_lifetimes<'cx>(\n-        &self,\n         regions: &RegionConstraintData<'cx>,\n         names_map: &FxHashMap<Symbol, Lifetime>,\n     ) -> Vec<WherePredicate> {\n@@ -210,9 +192,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 &Constraint::RegSubReg(r1, r2) => {\n                     // The constraint is already in the form that we want, so we're done with it\n                     // Desired order is 'larger, smaller', so flip then\n-                    if self.region_name(r1) != self.region_name(r2) {\n+                    if region_name(r1) != region_name(r2) {\n                         finished\n-                            .entry(self.region_name(r2).expect(\"no region_name found\"))\n+                            .entry(region_name(r2).expect(\"no region_name found\"))\n                             .or_default()\n                             .push(r1);\n                     }\n@@ -245,9 +227,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 for larger in deps.larger.iter() {\n                     match (smaller, larger) {\n                         (&RegionTarget::Region(r1), &RegionTarget::Region(r2)) => {\n-                            if self.region_name(r1) != self.region_name(r2) {\n+                            if region_name(r1) != region_name(r2) {\n                                 finished\n-                                    .entry(self.region_name(r2).expect(\"no region name found\"))\n+                                    .entry(region_name(r2).expect(\"no region name found\"))\n                                     .or_default()\n                                     .push(r1) // Larger, smaller\n                             }\n@@ -292,7 +274,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     .get(name)\n                     .unwrap_or(&empty)\n                     .iter()\n-                    .map(|region| GenericBound::Outlives(self.get_lifetime(region, names_map)))\n+                    .map(|region| GenericBound::Outlives(Self::get_lifetime(region, names_map)))\n                     .collect();\n \n                 if bounds.is_empty() {\n@@ -437,7 +419,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     // K', we use the dedicated syntax 'T: Fn() -> K'\n     // * We explicitly add a '?Sized' bound if we didn't find any 'Sized' predicates for a type\n     fn param_env_to_generics(\n-        &self,\n+        &mut self,\n         tcx: TyCtxt<'tcx>,\n         param_env_def_id: DefId,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -468,10 +450,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                         _ => false,\n                     }\n             })\n-            .map(|p| {\n-                let replaced = p.fold_with(&mut replacer);\n-                (replaced, replaced.clean(self.cx))\n-            });\n+            .map(|p| p.fold_with(&mut replacer));\n \n         let mut generic_params =\n             (tcx.generics_of(param_env_def_id), tcx.explicit_predicates_of(param_env_def_id))\n@@ -490,7 +469,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n         let mut ty_to_fn: FxHashMap<Type, (Option<PolyTrait>, Option<Type>)> = Default::default();\n \n-        for (orig_p, p) in clean_where_predicates {\n+        for p in clean_where_predicates {\n+            let (orig_p, p) = (p, p.clean(self.cx));\n             if p.is_none() {\n                 continue;\n             }\n@@ -749,6 +729,13 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     }\n }\n \n+fn region_name(region: Region<'_>) -> Option<Symbol> {\n+    match region {\n+        &ty::ReEarlyBound(r) => Some(r.name),\n+        _ => None,\n+    }\n+}\n+\n // Replaces all ReVars in a type with ty::Region's, using the provided map\n struct RegionReplacer<'a, 'tcx> {\n     vid_to_region: &'a FxHashMap<ty::RegionVid, ty::Region<'tcx>>,"}, {"sha": "a9d19a725c44f594f991011152f92321909e6091", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -10,17 +10,13 @@ use rustc_span::DUMMY_SP;\n use super::*;\n \n crate struct BlanketImplFinder<'a, 'tcx> {\n-    crate cx: &'a core::DocContext<'tcx>,\n+    crate cx: &'a mut core::DocContext<'tcx>,\n }\n \n impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n-    crate fn new(cx: &'a core::DocContext<'tcx>) -> Self {\n-        BlanketImplFinder { cx }\n-    }\n-\n     // FIXME(eddyb) figure out a better way to pass information about\n     // parametrization of `ty` than `param_env_def_id`.\n-    crate fn get_blanket_impls(&self, ty: Ty<'tcx>, param_env_def_id: DefId) -> Vec<Item> {\n+    crate fn get_blanket_impls(&mut self, ty: Ty<'tcx>, param_env_def_id: DefId) -> Vec<Item> {\n         let param_env = self.cx.tcx.param_env(param_env_def_id);\n \n         debug!(\"get_blanket_impls({:?})\", ty);"}, {"sha": "fded0499ba6a8f0f60a584e5fb15e36af698138d", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -37,7 +37,7 @@ type Attrs<'hir> = rustc_middle::ty::Attributes<'hir>;\n ///\n /// `parent_module` refers to the parent of the *re-export*, not the original item.\n crate fn try_inline(\n-    cx: &DocContext<'_>,\n+    cx: &mut DocContext<'_>,\n     parent_module: DefId,\n     res: Res,\n     name: Symbol,\n@@ -129,7 +129,7 @@ crate fn try_inline(\n }\n \n crate fn try_inline_glob(\n-    cx: &DocContext<'_>,\n+    cx: &mut DocContext<'_>,\n     res: Res,\n     visited: &mut FxHashSet<DefId>,\n ) -> Option<Vec<clean::Item>> {\n@@ -187,7 +187,7 @@ crate fn record_extern_fqn(cx: &DocContext<'_>, did: DefId, kind: clean::TypeKin\n     }\n }\n \n-crate fn build_external_trait(cx: &DocContext<'_>, did: DefId) -> clean::Trait {\n+crate fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean::Trait {\n     let trait_items =\n         cx.tcx.associated_items(did).in_definition_order().map(|item| item.clean(cx)).collect();\n \n@@ -207,14 +207,14 @@ crate fn build_external_trait(cx: &DocContext<'_>, did: DefId) -> clean::Trait {\n     }\n }\n \n-fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n+fn build_external_function(cx: &mut DocContext<'_>, did: DefId) -> clean::Function {\n     let sig = cx.tcx.fn_sig(did);\n \n     let constness =\n         if is_min_const_fn(cx.tcx, did) { hir::Constness::Const } else { hir::Constness::NotConst };\n     let asyncness = cx.tcx.asyncness(did);\n     let predicates = cx.tcx.predicates_of(did);\n-    let (generics, decl) = clean::enter_impl_trait(cx, || {\n+    let (generics, decl) = clean::enter_impl_trait(cx, |cx| {\n         ((cx.tcx.generics_of(did), predicates).clean(cx), (did, sig).clean(cx))\n     });\n     clean::Function {\n@@ -224,7 +224,7 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n     }\n }\n \n-fn build_enum(cx: &DocContext<'_>, did: DefId) -> clean::Enum {\n+fn build_enum(cx: &mut DocContext<'_>, did: DefId) -> clean::Enum {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n \n     clean::Enum {\n@@ -234,7 +234,7 @@ fn build_enum(cx: &DocContext<'_>, did: DefId) -> clean::Enum {\n     }\n }\n \n-fn build_struct(cx: &DocContext<'_>, did: DefId) -> clean::Struct {\n+fn build_struct(cx: &mut DocContext<'_>, did: DefId) -> clean::Struct {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n@@ -246,7 +246,7 @@ fn build_struct(cx: &DocContext<'_>, did: DefId) -> clean::Struct {\n     }\n }\n \n-fn build_union(cx: &DocContext<'_>, did: DefId) -> clean::Union {\n+fn build_union(cx: &mut DocContext<'_>, did: DefId) -> clean::Union {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n@@ -257,7 +257,7 @@ fn build_union(cx: &DocContext<'_>, did: DefId) -> clean::Union {\n     }\n }\n \n-fn build_type_alias(cx: &DocContext<'_>, did: DefId) -> clean::Typedef {\n+fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> clean::Typedef {\n     let predicates = cx.tcx.explicit_predicates_of(did);\n     let type_ = cx.tcx.type_of(did).clean(cx);\n \n@@ -270,7 +270,7 @@ fn build_type_alias(cx: &DocContext<'_>, did: DefId) -> clean::Typedef {\n \n /// Builds all inherent implementations of an ADT (struct/union/enum) or Trait item/path/reexport.\n crate fn build_impls(\n-    cx: &DocContext<'_>,\n+    cx: &mut DocContext<'_>,\n     parent_module: Option<DefId>,\n     did: DefId,\n     attrs: Option<Attrs<'_>>,\n@@ -286,7 +286,7 @@ crate fn build_impls(\n \n /// `parent_module` refers to the parent of the re-export, not the original item\n fn merge_attrs(\n-    cx: &DocContext<'_>,\n+    cx: &mut DocContext<'_>,\n     parent_module: Option<DefId>,\n     old_attrs: Attrs<'_>,\n     new_attrs: Option<Attrs<'_>>,\n@@ -311,7 +311,7 @@ fn merge_attrs(\n \n /// Builds a specific implementation of a type. The `did` could be a type method or trait method.\n crate fn build_impl(\n-    cx: &DocContext<'_>,\n+    cx: &mut DocContext<'_>,\n     parent_module: impl Into<Option<DefId>>,\n     did: DefId,\n     attrs: Option<Attrs<'_>>,\n@@ -394,7 +394,7 @@ crate fn build_impl(\n                     }\n                 })\n                 .collect::<Vec<_>>(),\n-            clean::enter_impl_trait(cx, || (tcx.generics_of(did), predicates).clean(cx)),\n+            clean::enter_impl_trait(cx, |cx| (tcx.generics_of(did), predicates).clean(cx)),\n         ),\n     };\n     let polarity = tcx.impl_polarity(did);\n@@ -437,7 +437,11 @@ crate fn build_impl(\n     ret.push(item);\n }\n \n-fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>) -> clean::Module {\n+fn build_module(\n+    cx: &mut DocContext<'_>,\n+    did: DefId,\n+    visited: &mut FxHashSet<DefId>,\n+) -> clean::Module {\n     let mut items = Vec::new();\n \n     // If we're re-exporting a re-export it may actually re-export something in\n@@ -495,7 +499,7 @@ crate fn print_inlined_const(cx: &DocContext<'_>, did: DefId) -> String {\n     }\n }\n \n-fn build_const(cx: &DocContext<'_>, did: DefId) -> clean::Constant {\n+fn build_const(cx: &mut DocContext<'_>, did: DefId) -> clean::Constant {\n     clean::Constant {\n         type_: cx.tcx.type_of(did).clean(cx),\n         expr: print_inlined_const(cx, did),\n@@ -506,15 +510,15 @@ fn build_const(cx: &DocContext<'_>, did: DefId) -> clean::Constant {\n     }\n }\n \n-fn build_static(cx: &DocContext<'_>, did: DefId, mutable: bool) -> clean::Static {\n+fn build_static(cx: &mut DocContext<'_>, did: DefId, mutable: bool) -> clean::Static {\n     clean::Static {\n         type_: cx.tcx.type_of(did).clean(cx),\n         mutability: if mutable { Mutability::Mut } else { Mutability::Not },\n         expr: None,\n     }\n }\n \n-fn build_macro(cx: &DocContext<'_>, did: DefId, name: Symbol) -> clean::ItemKind {\n+fn build_macro(cx: &mut DocContext<'_>, did: DefId, name: Symbol) -> clean::ItemKind {\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n     match cx.enter_resolver(|r| r.cstore().load_macro_untracked(did, cx.sess())) {\n         LoadedMacro::MacroDef(def, _) => {\n@@ -603,7 +607,7 @@ fn separate_supertrait_bounds(\n     (g, ty_bounds)\n }\n \n-crate fn record_extern_trait(cx: &DocContext<'_>, did: DefId) {\n+crate fn record_extern_trait(cx: &mut DocContext<'_>, did: DefId) {\n     if did.is_local() {\n         return;\n     }"}, {"sha": "1cfa6090ef48d6dc095c0e138cbf01e96424fce1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 125, "deletions": 126, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -49,43 +49,44 @@ crate use self::types::Visibility::{Inherited, Public};\n crate use self::types::*;\n \n crate trait Clean<T> {\n-    fn clean(&self, cx: &DocContext<'_>) -> T;\n+    fn clean(&self, cx: &mut DocContext<'_>) -> T;\n }\n \n impl<T: Clean<U>, U> Clean<Vec<U>> for [T] {\n-    fn clean(&self, cx: &DocContext<'_>) -> Vec<U> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n impl<T: Clean<U>, U, V: Idx> Clean<IndexVec<V, U>> for IndexVec<V, T> {\n-    fn clean(&self, cx: &DocContext<'_>) -> IndexVec<V, U> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> IndexVec<V, U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n impl<T: Clean<U>, U> Clean<U> for &T {\n-    fn clean(&self, cx: &DocContext<'_>) -> U {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> U {\n         (**self).clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<U> for Rc<T> {\n-    fn clean(&self, cx: &DocContext<'_>) -> U {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> U {\n         (**self).clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Option<U> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Option<U> {\n         self.as_ref().map(|v| v.clean(cx))\n     }\n }\n \n impl Clean<ExternalCrate> for CrateNum {\n-    fn clean(&self, cx: &DocContext<'_>) -> ExternalCrate {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> ExternalCrate {\n+        let tcx = cx.tcx;\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n-        let krate_span = cx.tcx.def_span(root);\n+        let krate_span = tcx.def_span(root);\n         let krate_src = cx.sess().source_map().span_to_filename(krate_span);\n \n         // Collect all inner modules which are tagged as implementations of\n@@ -105,7 +106,7 @@ impl Clean<ExternalCrate> for CrateNum {\n         // Also note that this does not attempt to deal with modules tagged\n         // duplicately for the same primitive. This is handled later on when\n         // rendering by delegating everything to a hash map.\n-        let as_primitive = |res: Res| {\n+        let mut as_primitive = |res: Res| {\n             if let Res::Def(DefKind::Mod, def_id) = res {\n                 let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n                 let mut prim = None;\n@@ -125,15 +126,14 @@ impl Clean<ExternalCrate> for CrateNum {\n             None\n         };\n         let primitives = if root.is_local() {\n-            cx.tcx\n-                .hir()\n+            tcx.hir()\n                 .krate()\n                 .item\n                 .module\n                 .item_ids\n                 .iter()\n                 .filter_map(|&id| {\n-                    let item = cx.tcx.hir().item(id);\n+                    let item = tcx.hir().item(id);\n                     match item.kind {\n                         hir::ItemKind::Mod(_) => {\n                             as_primitive(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n@@ -151,17 +151,12 @@ impl Clean<ExternalCrate> for CrateNum {\n                 })\n                 .collect()\n         } else {\n-            cx.tcx\n-                .item_children(root)\n-                .iter()\n-                .map(|item| item.res)\n-                .filter_map(as_primitive)\n-                .collect()\n+            tcx.item_children(root).iter().map(|item| item.res).filter_map(as_primitive).collect()\n         };\n \n-        let as_keyword = |res: Res| {\n+        let mut as_keyword = |res: Res| {\n             if let Res::Def(DefKind::Mod, def_id) = res {\n-                let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n+                let attrs = tcx.get_attrs(def_id).clean(cx);\n                 let mut keyword = None;\n                 for attr in attrs.lists(sym::doc) {\n                     if attr.has_name(sym::keyword) {\n@@ -176,15 +171,14 @@ impl Clean<ExternalCrate> for CrateNum {\n             None\n         };\n         let keywords = if root.is_local() {\n-            cx.tcx\n-                .hir()\n+            tcx.hir()\n                 .krate()\n                 .item\n                 .module\n                 .item_ids\n                 .iter()\n                 .filter_map(|&id| {\n-                    let item = cx.tcx.hir().item(id);\n+                    let item = tcx.hir().item(id);\n                     match item.kind {\n                         hir::ItemKind::Mod(_) => {\n                             as_keyword(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n@@ -199,21 +193,21 @@ impl Clean<ExternalCrate> for CrateNum {\n                 })\n                 .collect()\n         } else {\n-            cx.tcx.item_children(root).iter().map(|item| item.res).filter_map(as_keyword).collect()\n+            tcx.item_children(root).iter().map(|item| item.res).filter_map(as_keyword).collect()\n         };\n \n         ExternalCrate {\n-            name: cx.tcx.crate_name(*self),\n+            name: tcx.crate_name(*self),\n             src: krate_src,\n-            attrs: cx.tcx.get_attrs(root).clean(cx),\n+            attrs: tcx.get_attrs(root).clean(cx),\n             primitives,\n             keywords,\n         }\n     }\n }\n \n impl Clean<Item> for doctree::Module<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let mut items: Vec<Item> = vec![];\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n@@ -246,13 +240,13 @@ impl Clean<Item> for doctree::Module<'_> {\n }\n \n impl Clean<Attributes> for [ast::Attribute] {\n-    fn clean(&self, cx: &DocContext<'_>) -> Attributes {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Attributes {\n         Attributes::from_ast(cx.sess().diagnostic(), self, None)\n     }\n }\n \n impl Clean<GenericBound> for hir::GenericBound<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n         match *self {\n             hir::GenericBound::Outlives(lt) => GenericBound::Outlives(lt.clean(cx)),\n             hir::GenericBound::LangItemTrait(lang_item, span, _, generic_args) => {\n@@ -279,7 +273,7 @@ impl Clean<GenericBound> for hir::GenericBound<'_> {\n }\n \n impl Clean<Type> for (ty::TraitRef<'_>, &[TypeBinding]) {\n-    fn clean(&self, cx: &DocContext<'_>) -> Type {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         let (trait_ref, bounds) = *self;\n         inline::record_extern_fqn(cx, trait_ref.def_id, TypeKind::Trait);\n         let path = external_path(\n@@ -298,7 +292,7 @@ impl Clean<Type> for (ty::TraitRef<'_>, &[TypeBinding]) {\n }\n \n impl<'tcx> Clean<GenericBound> for ty::TraitRef<'tcx> {\n-    fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n         GenericBound::TraitBound(\n             PolyTrait { trait_: (*self, &[][..]).clean(cx), generic_params: vec![] },\n             hir::TraitBoundModifier::None,\n@@ -307,7 +301,7 @@ impl<'tcx> Clean<GenericBound> for ty::TraitRef<'tcx> {\n }\n \n impl Clean<GenericBound> for (ty::PolyTraitRef<'_>, &[TypeBinding]) {\n-    fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n         let (poly_trait_ref, bounds) = *self;\n         let poly_trait_ref = poly_trait_ref.lift_to_tcx(cx.tcx).unwrap();\n \n@@ -335,13 +329,13 @@ impl Clean<GenericBound> for (ty::PolyTraitRef<'_>, &[TypeBinding]) {\n }\n \n impl<'tcx> Clean<GenericBound> for ty::PolyTraitRef<'tcx> {\n-    fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n         (*self, &[][..]).clean(cx)\n     }\n }\n \n impl<'tcx> Clean<Option<Vec<GenericBound>>> for InternalSubsts<'tcx> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Option<Vec<GenericBound>> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Option<Vec<GenericBound>> {\n         let mut v = Vec::new();\n         v.extend(self.regions().filter_map(|r| r.clean(cx)).map(GenericBound::Outlives));\n         v.extend(self.types().map(|t| {\n@@ -355,7 +349,7 @@ impl<'tcx> Clean<Option<Vec<GenericBound>>> for InternalSubsts<'tcx> {\n }\n \n impl Clean<Lifetime> for hir::Lifetime {\n-    fn clean(&self, cx: &DocContext<'_>) -> Lifetime {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Lifetime {\n         let def = cx.tcx.named_region(self.hir_id);\n         match def {\n             Some(\n@@ -374,7 +368,7 @@ impl Clean<Lifetime> for hir::Lifetime {\n }\n \n impl Clean<Lifetime> for hir::GenericParam<'_> {\n-    fn clean(&self, _: &DocContext<'_>) -> Lifetime {\n+    fn clean(&self, _: &mut DocContext<'_>) -> Lifetime {\n         match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n                 if !self.bounds.is_empty() {\n@@ -398,7 +392,7 @@ impl Clean<Lifetime> for hir::GenericParam<'_> {\n }\n \n impl Clean<Constant> for hir::ConstArg {\n-    fn clean(&self, cx: &DocContext<'_>) -> Constant {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Constant {\n         Constant {\n             type_: cx\n                 .tcx\n@@ -412,13 +406,13 @@ impl Clean<Constant> for hir::ConstArg {\n }\n \n impl Clean<Lifetime> for ty::GenericParamDef {\n-    fn clean(&self, _cx: &DocContext<'_>) -> Lifetime {\n+    fn clean(&self, _cx: &mut DocContext<'_>) -> Lifetime {\n         Lifetime(self.name)\n     }\n }\n \n impl Clean<Option<Lifetime>> for ty::RegionKind {\n-    fn clean(&self, _cx: &DocContext<'_>) -> Option<Lifetime> {\n+    fn clean(&self, _cx: &mut DocContext<'_>) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n             ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name) }) => {\n@@ -440,7 +434,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n }\n \n impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n         match *self {\n             hir::WherePredicate::BoundPredicate(ref wbp) => WherePredicate::BoundPredicate {\n                 ty: wbp.bounded_ty.clean(cx),\n@@ -460,7 +454,7 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n }\n \n impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n         let bound_predicate = self.kind();\n         match bound_predicate.skip_binder() {\n             ty::PredicateKind::Trait(pred, _) => Some(bound_predicate.rebind(pred).clean(cx)),\n@@ -480,7 +474,7 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n }\n \n impl<'a> Clean<WherePredicate> for ty::PolyTraitPredicate<'a> {\n-    fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n         let poly_trait_ref = self.map_bound(|pred| pred.trait_ref);\n         WherePredicate::BoundPredicate {\n             ty: poly_trait_ref.skip_binder().self_ty().clean(cx),\n@@ -492,7 +486,7 @@ impl<'a> Clean<WherePredicate> for ty::PolyTraitPredicate<'a> {\n impl<'tcx> Clean<Option<WherePredicate>>\n     for ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n {\n-    fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(a, b) = self;\n \n         if let (ty::ReEmpty(_), ty::ReEmpty(_)) = (a, b) {\n@@ -507,7 +501,7 @@ impl<'tcx> Clean<Option<WherePredicate>>\n }\n \n impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(ty, lt) = self;\n \n         if let ty::ReEmpty(_) = lt {\n@@ -522,14 +516,14 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n }\n \n impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n-    fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n         let ty::ProjectionPredicate { projection_ty, ty } = self;\n         WherePredicate::EqPredicate { lhs: projection_ty.clean(cx), rhs: ty.clean(cx) }\n     }\n }\n \n impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Type {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         let lifted = self.lift_to_tcx(cx.tcx).unwrap();\n         let trait_ = match lifted.trait_ref(cx.tcx).clean(cx) {\n             GenericBound::TraitBound(t, _) => t.trait_,\n@@ -544,7 +538,7 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n }\n \n impl Clean<GenericParamDef> for ty::GenericParamDef {\n-    fn clean(&self, cx: &DocContext<'_>) -> GenericParamDef {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             ty::GenericParamDefKind::Lifetime => (self.name, GenericParamDefKind::Lifetime),\n             ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n@@ -574,7 +568,7 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n }\n \n impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> GenericParamDef {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n                 let name = if !self.bounds.is_empty() {\n@@ -617,7 +611,7 @@ impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n }\n \n impl Clean<Generics> for hir::Generics<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Generics {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Generics {\n         // Synthetic type-parameters are inserted after normal ones.\n         // In order for normal parameters to be able to refer to synthetic ones,\n         // scans them first.\n@@ -697,7 +691,7 @@ impl Clean<Generics> for hir::Generics<'_> {\n }\n \n impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx>) {\n-    fn clean(&self, cx: &DocContext<'_>) -> Generics {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Generics {\n         use self::WherePredicate as WP;\n         use std::collections::BTreeMap;\n \n@@ -801,7 +795,8 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n             if let crate::core::ImplTraitParam::ParamIndex(idx) = param {\n                 if let Some(proj) = impl_trait_proj.remove(&idx) {\n                     for (trait_did, name, rhs) in proj {\n-                        simplify::merge_bounds(cx, &mut bounds, trait_did, name, &rhs.clean(cx));\n+                        let rhs = rhs.clean(cx);\n+                        simplify::merge_bounds(cx, &mut bounds, trait_did, name, &rhs);\n                     }\n                 }\n             } else {\n@@ -866,7 +861,7 @@ fn clean_fn_or_proc_macro(\n     generics: &'a hir::Generics<'a>,\n     body_id: hir::BodyId,\n     name: &mut Symbol,\n-    cx: &DocContext<'_>,\n+    cx: &mut DocContext<'_>,\n ) -> ItemKind {\n     let macro_kind = item.attrs.iter().find_map(|a| {\n         if a.has_name(sym::proc_macro) {\n@@ -921,15 +916,15 @@ fn clean_fn_or_proc_macro(\n }\n \n impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::BodyId) {\n-    fn clean(&self, cx: &DocContext<'_>) -> Function {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Function {\n         let (generics, decl) =\n-            enter_impl_trait(cx, || (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx)));\n+            enter_impl_trait(cx, |cx| (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx)));\n         Function { decl, generics, header: self.0.header }\n     }\n }\n \n impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [Ident]) {\n-    fn clean(&self, cx: &DocContext<'_>) -> Arguments {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Arguments {\n         Arguments {\n             values: self\n                 .0\n@@ -948,7 +943,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [Ident]) {\n }\n \n impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], hir::BodyId) {\n-    fn clean(&self, cx: &DocContext<'_>) -> Arguments {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Arguments {\n         let body = cx.tcx.hir().body(self.1);\n \n         Arguments {\n@@ -969,7 +964,7 @@ impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl<'a>, A)\n where\n     (&'a [hir::Ty<'a>], A): Clean<Arguments>,\n {\n-    fn clean(&self, cx: &DocContext<'_>) -> FnDecl {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> FnDecl {\n         FnDecl {\n             inputs: (self.0.inputs, self.1).clean(cx),\n             output: self.0.output.clean(cx),\n@@ -980,7 +975,7 @@ where\n }\n \n impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n-    fn clean(&self, cx: &DocContext<'_>) -> FnDecl {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> FnDecl {\n         let (did, sig) = *self;\n         let mut names = if did.is_local() { &[] } else { cx.tcx.fn_arg_names(did) }.iter();\n \n@@ -1004,7 +999,7 @@ impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n }\n \n impl Clean<FnRetTy> for hir::FnRetTy<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> FnRetTy {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> FnRetTy {\n         match *self {\n             Self::Return(ref typ) => Return(typ.clean(cx)),\n             Self::DefaultReturn(..) => DefaultReturn,\n@@ -1013,7 +1008,7 @@ impl Clean<FnRetTy> for hir::FnRetTy<'_> {\n }\n \n impl Clean<bool> for hir::IsAuto {\n-    fn clean(&self, _: &DocContext<'_>) -> bool {\n+    fn clean(&self, _: &mut DocContext<'_>) -> bool {\n         match *self {\n             hir::IsAuto::Yes => true,\n             hir::IsAuto::No => false,\n@@ -1022,13 +1017,14 @@ impl Clean<bool> for hir::IsAuto {\n }\n \n impl Clean<Type> for hir::TraitRef<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Type {\n-        resolve_type(cx, self.path.clean(cx), self.hir_ref_id)\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+        let path = self.path.clean(cx);\n+        resolve_type(cx, path, self.hir_ref_id)\n     }\n }\n \n impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> PolyTrait {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n             generic_params: self.bound_generic_params.clean(cx),\n@@ -1037,15 +1033,15 @@ impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n }\n \n impl Clean<TypeKind> for hir::def::DefKind {\n-    fn clean(&self, _: &DocContext<'_>) -> TypeKind {\n+    fn clean(&self, _: &mut DocContext<'_>) -> TypeKind {\n         (*self).into()\n     }\n }\n \n impl Clean<Item> for hir::TraitItem<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let local_did = self.def_id.to_def_id();\n-        cx.with_param_env(local_did, || {\n+        cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n                 hir::TraitItemKind::Const(ref ty, default) => {\n                     AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx.tcx, e)))\n@@ -1060,7 +1056,7 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     MethodItem(m, None)\n                 }\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(ref names)) => {\n-                    let (generics, decl) = enter_impl_trait(cx, || {\n+                    let (generics, decl) = enter_impl_trait(cx, |cx| {\n                         (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n                     });\n                     let mut t = Function { header: sig.header, decl, generics };\n@@ -1084,9 +1080,9 @@ impl Clean<Item> for hir::TraitItem<'_> {\n }\n \n impl Clean<Item> for hir::ImplItem<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let local_did = self.def_id.to_def_id();\n-        cx.with_param_env(local_did, || {\n+        cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n                 hir::ImplItemKind::Const(ref ty, expr) => {\n                     AssocConstItem(ty.clean(cx), Some(print_const_expr(cx.tcx, expr)))\n@@ -1133,10 +1129,11 @@ impl Clean<Item> for hir::ImplItem<'_> {\n }\n \n impl Clean<Item> for ty::AssocItem {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+        let tcx = cx.tcx;\n         let kind = match self.kind {\n             ty::AssocKind::Const => {\n-                let ty = cx.tcx.type_of(self.def_id);\n+                let ty = tcx.type_of(self.def_id);\n                 let default = if self.defaultness.has_value() {\n                     Some(inline::print_inlined_const(cx, self.def_id))\n                 } else {\n@@ -1146,15 +1143,15 @@ impl Clean<Item> for ty::AssocItem {\n             }\n             ty::AssocKind::Fn => {\n                 let generics =\n-                    (cx.tcx.generics_of(self.def_id), cx.tcx.explicit_predicates_of(self.def_id))\n+                    (tcx.generics_of(self.def_id), tcx.explicit_predicates_of(self.def_id))\n                         .clean(cx);\n-                let sig = cx.tcx.fn_sig(self.def_id);\n+                let sig = tcx.fn_sig(self.def_id);\n                 let mut decl = (self.def_id, sig).clean(cx);\n \n                 if self.fn_has_self_parameter {\n                     let self_ty = match self.container {\n-                        ty::ImplContainer(def_id) => cx.tcx.type_of(def_id),\n-                        ty::TraitContainer(_) => cx.tcx.types.self_param,\n+                        ty::ImplContainer(def_id) => tcx.type_of(def_id),\n+                        ty::TraitContainer(_) => tcx.types.self_param,\n                     };\n                     let self_arg_ty = sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n@@ -1176,12 +1173,12 @@ impl Clean<Item> for ty::AssocItem {\n                     ty::TraitContainer(_) => self.defaultness.has_value(),\n                 };\n                 if provided {\n-                    let constness = if is_min_const_fn(cx.tcx, self.def_id) {\n+                    let constness = if is_min_const_fn(tcx, self.def_id) {\n                         hir::Constness::Const\n                     } else {\n                         hir::Constness::NotConst\n                     };\n-                    let asyncness = cx.tcx.asyncness(self.def_id);\n+                    let asyncness = tcx.asyncness(self.def_id);\n                     let defaultness = match self.container {\n                         ty::ImplContainer(_) => Some(self.defaultness),\n                         ty::TraitContainer(_) => None,\n@@ -1216,9 +1213,9 @@ impl Clean<Item> for ty::AssocItem {\n                 let my_name = self.ident.name;\n \n                 if let ty::TraitContainer(_) = self.container {\n-                    let bounds = cx.tcx.explicit_item_bounds(self.def_id);\n+                    let bounds = tcx.explicit_item_bounds(self.def_id);\n                     let predicates = ty::GenericPredicates { parent: None, predicates: bounds };\n-                    let generics = (cx.tcx.generics_of(self.def_id), predicates).clean(cx);\n+                    let generics = (tcx.generics_of(self.def_id), predicates).clean(cx);\n                     let mut bounds = generics\n                         .where_predicates\n                         .iter()\n@@ -1258,15 +1255,15 @@ impl Clean<Item> for ty::AssocItem {\n                     }\n \n                     let ty = if self.defaultness.has_value() {\n-                        Some(cx.tcx.type_of(self.def_id))\n+                        Some(tcx.type_of(self.def_id))\n                     } else {\n                         None\n                     };\n \n                     AssocTypeItem(bounds, ty.clean(cx))\n                 } else {\n                     // FIXME: when could this happen? Associated items in inherent impls?\n-                    let type_ = cx.tcx.type_of(self.def_id).clean(cx);\n+                    let type_ = tcx.type_of(self.def_id).clean(cx);\n                     TypedefItem(\n                         Typedef {\n                             type_,\n@@ -1283,7 +1280,7 @@ impl Clean<Item> for ty::AssocItem {\n     }\n }\n \n-fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &DocContext<'_>) -> Type {\n+fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n     use rustc_hir::GenericParamCount;\n     let hir::Ty { hir_id, span, ref kind } = *hir_ty;\n     let qpath = match kind {\n@@ -1389,9 +1386,10 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &DocContext<'_>) -> Type {\n                         }\n                     }\n                 }\n-                return cx.enter_alias(ty_substs, lt_substs, ct_substs, || ty.clean(cx));\n+                return cx.enter_alias(ty_substs, lt_substs, ct_substs, |cx| ty.clean(cx));\n             }\n-            resolve_type(cx, path.clean(cx), hir_id)\n+            let path = path.clean(cx);\n+            resolve_type(cx, path, hir_id)\n         }\n         hir::QPath::Resolved(Some(ref qself), ref p) => {\n             // Try to normalize `<X as Y>::T` to a type\n@@ -1423,19 +1421,19 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &DocContext<'_>) -> Type {\n             } else {\n                 Res::Err\n             };\n-            let trait_path = hir::Path { span, res, segments: &[] };\n+            let trait_path = hir::Path { span, res, segments: &[] }.clean(cx);\n             Type::QPath {\n                 name: segment.ident.name,\n                 self_type: box qself.clean(cx),\n-                trait_: box resolve_type(cx, trait_path.clean(cx), hir_id),\n+                trait_: box resolve_type(cx, trait_path, hir_id),\n             }\n         }\n         hir::QPath::LangItem(..) => bug!(\"clean: requiring documentation of lang item\"),\n     }\n }\n \n impl Clean<Type> for hir::Ty<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Type {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         use rustc_hir::*;\n \n         match self.kind {\n@@ -1507,7 +1505,7 @@ impl Clean<Type> for hir::Ty<'_> {\n }\n \n /// Returns `None` if the type could not be normalized\n-fn normalize(cx: &DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n+fn normalize(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n     // HACK: low-churn fix for #79459 while we wait for a trait normalization fix\n     if !cx.tcx.sess.opts.debugging_opts.normalize_docs {\n         return None;\n@@ -1538,7 +1536,7 @@ fn normalize(cx: &DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n }\n \n impl<'tcx> Clean<Type> for Ty<'tcx> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Type {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         debug!(\"cleaning type: {:?}\", self);\n         let ty = normalize(cx, self).unwrap_or(self);\n         match *ty.kind() {\n@@ -1746,7 +1744,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n }\n \n impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Constant {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Constant {\n         Constant {\n             type_: self.ty.clean(cx),\n             expr: format!(\"{}\", self),\n@@ -1757,7 +1755,7 @@ impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n }\n \n impl Clean<Item> for hir::StructField<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let what_rustc_thinks = Item::from_hir_id_and_parts(\n             self.hir_id,\n             Some(self.ident.name),\n@@ -1770,7 +1768,7 @@ impl Clean<Item> for hir::StructField<'_> {\n }\n \n impl Clean<Item> for ty::FieldDef {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let what_rustc_thinks = Item::from_def_id_and_parts(\n             self.did,\n             Some(self.ident.name),\n@@ -1783,7 +1781,7 @@ impl Clean<Item> for ty::FieldDef {\n }\n \n impl Clean<Visibility> for hir::Visibility<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Visibility {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Visibility {\n         match self.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Inherited => Visibility::Inherited,\n@@ -1801,7 +1799,7 @@ impl Clean<Visibility> for hir::Visibility<'_> {\n }\n \n impl Clean<Visibility> for ty::Visibility {\n-    fn clean(&self, _cx: &DocContext<'_>) -> Visibility {\n+    fn clean(&self, _cx: &mut DocContext<'_>) -> Visibility {\n         match *self {\n             ty::Visibility::Public => Visibility::Public,\n             // NOTE: this is not quite right: `ty` uses `Invisible` to mean 'private',\n@@ -1816,7 +1814,7 @@ impl Clean<Visibility> for ty::Visibility {\n }\n \n impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> VariantStruct {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> VariantStruct {\n         VariantStruct {\n             struct_type: CtorKind::from_hir(self),\n             fields: self.fields().iter().map(|x| x.clean(cx)).collect(),\n@@ -1826,7 +1824,7 @@ impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n }\n \n impl Clean<Item> for ty::VariantDef {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let kind = match self.ctor_kind {\n             CtorKind::Const => Variant::CLike,\n             CtorKind::Fn => Variant::Tuple(\n@@ -1857,7 +1855,7 @@ impl Clean<Item> for ty::VariantDef {\n }\n \n impl Clean<Variant> for hir::VariantData<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Variant {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Variant {\n         match self {\n             hir::VariantData::Struct(..) => Variant::Struct(self.clean(cx)),\n             hir::VariantData::Tuple(..) => {\n@@ -1869,13 +1867,13 @@ impl Clean<Variant> for hir::VariantData<'_> {\n }\n \n impl Clean<Span> for rustc_span::Span {\n-    fn clean(&self, _cx: &DocContext<'_>) -> Span {\n+    fn clean(&self, _cx: &mut DocContext<'_>) -> Span {\n         Span::from_rustc_span(*self)\n     }\n }\n \n impl Clean<Path> for hir::Path<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Path {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n         Path {\n             global: self.is_global(),\n             res: self.res,\n@@ -1885,7 +1883,7 @@ impl Clean<Path> for hir::Path<'_> {\n }\n \n impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> GenericArgs {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> GenericArgs {\n         if self.parenthesized {\n             let output = self.bindings[0].ty().clean(cx);\n             GenericArgs::Parenthesized {\n@@ -1913,42 +1911,42 @@ impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n }\n \n impl Clean<PathSegment> for hir::PathSegment<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> PathSegment {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> PathSegment {\n         PathSegment { name: self.ident.name, args: self.args().clean(cx) }\n     }\n }\n \n impl Clean<String> for Ident {\n     #[inline]\n-    fn clean(&self, cx: &DocContext<'_>) -> String {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> String {\n         self.name.clean(cx)\n     }\n }\n \n impl Clean<String> for Symbol {\n     #[inline]\n-    fn clean(&self, _: &DocContext<'_>) -> String {\n+    fn clean(&self, _: &mut DocContext<'_>) -> String {\n         self.to_string()\n     }\n }\n \n impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> BareFunctionDecl {\n-        let (generic_params, decl) = enter_impl_trait(cx, || {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> BareFunctionDecl {\n+        let (generic_params, decl) = enter_impl_trait(cx, |cx| {\n             (self.generic_params.clean(cx), (&*self.decl, self.param_names).clean(cx))\n         });\n         BareFunctionDecl { unsafety: self.unsafety, abi: self.abi, decl, generic_params }\n     }\n }\n \n impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n-    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Vec<Item> {\n         use hir::ItemKind;\n \n         let (item, renamed) = self;\n         let def_id = item.def_id.to_def_id();\n         let mut name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n-        cx.with_param_env(def_id, || {\n+        cx.with_param_env(def_id, |cx| {\n             let kind = match item.kind {\n                 ItemKind::Static(ty, mutability, body_id) => {\n                     StaticItem(Static { type_: ty.clean(cx), mutability, expr: Some(body_id) })\n@@ -2031,7 +2029,7 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n }\n \n impl Clean<Item> for hir::Variant<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let kind = VariantItem(self.data.clean(cx));\n         let what_rustc_thinks =\n             Item::from_hir_id_and_parts(self.id, Some(self.ident.name), kind, cx);\n@@ -2042,7 +2040,7 @@ impl Clean<Item> for hir::Variant<'_> {\n \n impl Clean<bool> for ty::ImplPolarity {\n     /// Returns whether the impl has negative polarity.\n-    fn clean(&self, _: &DocContext<'_>) -> bool {\n+    fn clean(&self, _: &mut DocContext<'_>) -> bool {\n         match self {\n             &ty::ImplPolarity::Positive |\n             // FIXME: do we want to do something else here?\n@@ -2052,38 +2050,39 @@ impl Clean<bool> for ty::ImplPolarity {\n     }\n }\n \n-fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &DocContext<'_>) -> Vec<Item> {\n+fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &mut DocContext<'_>) -> Vec<Item> {\n+    let tcx = cx.tcx;\n     let mut ret = Vec::new();\n     let trait_ = impl_.of_trait.clean(cx);\n     let items =\n-        impl_.items.iter().map(|ii| cx.tcx.hir().impl_item(ii.id).clean(cx)).collect::<Vec<_>>();\n-    let def_id = cx.tcx.hir().local_def_id(hir_id);\n+        impl_.items.iter().map(|ii| tcx.hir().impl_item(ii.id).clean(cx)).collect::<Vec<_>>();\n+    let def_id = tcx.hir().local_def_id(hir_id);\n \n     // If this impl block is an implementation of the Deref trait, then we\n     // need to try inlining the target's inherent impl blocks as well.\n-    if trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n+    if trait_.def_id() == tcx.lang_items().deref_trait() {\n         build_deref_target_impls(cx, &items, &mut ret);\n     }\n \n     let provided: FxHashSet<Symbol> = trait_\n         .def_id()\n-        .map(|did| cx.tcx.provided_trait_methods(did).map(|meth| meth.ident.name).collect())\n+        .map(|did| tcx.provided_trait_methods(did).map(|meth| meth.ident.name).collect())\n         .unwrap_or_default();\n \n     let for_ = impl_.self_ty.clean(cx);\n-    let type_alias = for_.def_id().and_then(|did| match cx.tcx.def_kind(did) {\n-        DefKind::TyAlias => Some(cx.tcx.type_of(did).clean(cx)),\n+    let type_alias = for_.def_id().and_then(|did| match tcx.def_kind(did) {\n+        DefKind::TyAlias => Some(tcx.type_of(did).clean(cx)),\n         _ => None,\n     });\n-    let make_item = |trait_: Option<Type>, for_: Type, items: Vec<Item>| {\n+    let mut make_item = |trait_: Option<Type>, for_: Type, items: Vec<Item>| {\n         let kind = ImplItem(Impl {\n             unsafety: impl_.unsafety,\n             generics: impl_.generics.clean(cx),\n             provided_trait_methods: provided.clone(),\n             trait_,\n             for_,\n             items,\n-            negative_polarity: cx.tcx.impl_polarity(def_id).clean(cx),\n+            negative_polarity: tcx.impl_polarity(def_id).clean(cx),\n             synthetic: false,\n             blanket_impl: None,\n         });\n@@ -2100,7 +2099,7 @@ fn clean_extern_crate(\n     krate: &hir::Item<'_>,\n     name: Symbol,\n     orig_name: Option<Symbol>,\n-    cx: &DocContext<'_>,\n+    cx: &mut DocContext<'_>,\n ) -> Vec<Item> {\n     // this is the ID of the `extern crate` statement\n     let cnum = cx.tcx.extern_mod_stmt_cnum(krate.def_id).unwrap_or(LOCAL_CRATE);\n@@ -2147,7 +2146,7 @@ fn clean_use_statement(\n     name: Symbol,\n     path: &hir::Path<'_>,\n     kind: hir::UseKind,\n-    cx: &DocContext<'_>,\n+    cx: &mut DocContext<'_>,\n ) -> Vec<Item> {\n     // We need this comparison because some imports (for std types for example)\n     // are \"inserted\" as well but directly by the compiler and they should not be\n@@ -2237,13 +2236,13 @@ fn clean_use_statement(\n }\n \n impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let (item, renamed) = self;\n-        cx.with_param_env(item.def_id.to_def_id(), || {\n+        cx.with_param_env(item.def_id.to_def_id(), |cx| {\n             let kind = match item.kind {\n                 hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n                     let abi = cx.tcx.hir().get_foreign_abi(item.hir_id());\n-                    let (generics, decl) = enter_impl_trait(cx, || {\n+                    let (generics, decl) = enter_impl_trait(cx, |cx| {\n                         (generics.clean(cx), (&**decl, &names[..]).clean(cx))\n                     });\n                     ForeignFunctionItem(Function {\n@@ -2274,7 +2273,7 @@ impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n }\n \n impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n         let (item, renamed) = self;\n         let name = renamed.unwrap_or(item.ident.name);\n         let tts = item.ast.body.inner_tokens().trees().collect::<Vec<_>>();\n@@ -2323,13 +2322,13 @@ impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n }\n \n impl Clean<TypeBinding> for hir::TypeBinding<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> TypeBinding {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> TypeBinding {\n         TypeBinding { name: self.ident.name, kind: self.kind.clean(cx) }\n     }\n }\n \n impl Clean<TypeBindingKind> for hir::TypeBindingKind<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> TypeBindingKind {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> TypeBindingKind {\n         match *self {\n             hir::TypeBindingKind::Equality { ref ty } => {\n                 TypeBindingKind::Equality { ty: ty.clean(cx) }"}, {"sha": "3e7196fa7fa03d0f0950d570520ac8ec8c311bee", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -130,7 +130,7 @@ impl Item {\n         hir_id: hir::HirId,\n         name: Option<Symbol>,\n         kind: ItemKind,\n-        cx: &DocContext<'_>,\n+        cx: &mut DocContext<'_>,\n     ) -> Item {\n         Item::from_def_id_and_parts(cx.tcx.hir().local_def_id(hir_id).to_def_id(), name, kind, cx)\n     }\n@@ -139,7 +139,7 @@ impl Item {\n         def_id: DefId,\n         name: Option<Symbol>,\n         kind: ItemKind,\n-        cx: &DocContext<'_>,\n+        cx: &mut DocContext<'_>,\n     ) -> Item {\n         debug!(\"name={:?}, def_id={:?}\", name, def_id);\n \n@@ -936,7 +936,7 @@ crate enum GenericBound {\n }\n \n impl GenericBound {\n-    crate fn maybe_sized(cx: &DocContext<'_>) -> GenericBound {\n+    crate fn maybe_sized(cx: &mut DocContext<'_>) -> GenericBound {\n         let did = cx.tcx.require_lang_item(LangItem::Sized, None);\n         let empty = cx.tcx.intern_substs(&[]);\n         let path = external_path(cx, cx.tcx.item_name(did), Some(did), false, vec![], empty);"}, {"sha": "c7bfd363a129b5a40b89c0a2432763ef9f806c30", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -90,7 +90,7 @@ crate fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n }\n \n fn external_generic_args(\n-    cx: &DocContext<'_>,\n+    cx: &mut DocContext<'_>,\n     trait_did: Option<DefId>,\n     has_self: bool,\n     bindings: Vec<TypeBinding>,\n@@ -142,7 +142,7 @@ fn external_generic_args(\n // trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n // from Fn<(A, B,), C> to Fn(A, B) -> C\n pub(super) fn external_path(\n-    cx: &DocContext<'_>,\n+    cx: &mut DocContext<'_>,\n     name: Symbol,\n     trait_did: Option<DefId>,\n     has_self: bool,\n@@ -214,7 +214,7 @@ crate fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n     s\n }\n \n-crate fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut Vec<Item>) {\n+crate fn build_deref_target_impls(cx: &mut DocContext<'_>, items: &[Item], ret: &mut Vec<Item>) {\n     let tcx = cx.tcx;\n \n     for item in items {\n@@ -241,7 +241,7 @@ crate trait ToSource {\n \n impl ToSource for rustc_span::Span {\n     fn to_src(&self, cx: &DocContext<'_>) -> String {\n-        debug!(\"converting span {:?} to snippet\", self.clean(cx));\n+        debug!(\"converting span {:?} to snippet\", self);\n         let sn = match cx.sess().source_map().span_to_snippet(*self) {\n             Ok(x) => x,\n             Err(_) => String::new(),\n@@ -407,7 +407,7 @@ crate fn print_const_expr(tcx: TyCtxt<'_>, body: hir::BodyId) -> String {\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt\n-crate fn resolve_type(cx: &DocContext<'_>, path: Path, id: hir::HirId) -> Type {\n+crate fn resolve_type(cx: &mut DocContext<'_>, path: Path, id: hir::HirId) -> Type {\n     debug!(\"resolve_type({:?},{:?})\", path, id);\n \n     let is_generic = match path.res {\n@@ -421,12 +421,12 @@ crate fn resolve_type(cx: &DocContext<'_>, path: Path, id: hir::HirId) -> Type {\n         Res::SelfTy(..) | Res::Def(DefKind::TyParam | DefKind::AssocTy, _) => true,\n         _ => false,\n     };\n-    let did = register_res(&*cx, path.res);\n+    let did = register_res(cx, path.res);\n     ResolvedPath { path, param_names: None, did, is_generic }\n }\n \n crate fn get_auto_trait_and_blanket_impls(\n-    cx: &DocContext<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n     ty: Ty<'tcx>,\n     param_env_def_id: DefId,\n ) -> impl Iterator<Item = Item> {\n@@ -439,11 +439,11 @@ crate fn get_auto_trait_and_blanket_impls(\n         .sess()\n         .prof\n         .generic_activity(\"get_blanket_impls\")\n-        .run(|| BlanketImplFinder::new(cx).get_blanket_impls(ty, param_env_def_id));\n+        .run(|| BlanketImplFinder { cx }.get_blanket_impls(ty, param_env_def_id));\n     auto_impls.into_iter().chain(blanket_impls)\n }\n \n-crate fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n+crate fn register_res(cx: &mut DocContext<'_>, res: Res) -> DefId {\n     debug!(\"register_res({:?})\", res);\n \n     let (did, kind) = match res {\n@@ -483,21 +483,21 @@ crate fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n     did\n }\n \n-crate fn resolve_use_source(cx: &DocContext<'_>, path: Path) -> ImportSource {\n+crate fn resolve_use_source(cx: &mut DocContext<'_>, path: Path) -> ImportSource {\n     ImportSource {\n         did: if path.res.opt_def_id().is_none() { None } else { Some(register_res(cx, path.res)) },\n         path,\n     }\n }\n \n-crate fn enter_impl_trait<F, R>(cx: &DocContext<'_>, f: F) -> R\n+crate fn enter_impl_trait<F, R>(cx: &mut DocContext<'_>, f: F) -> R\n where\n-    F: FnOnce() -> R,\n+    F: FnOnce(&mut DocContext<'_>) -> R,\n {\n-    let old_bounds = mem::take(&mut *cx.impl_trait_bounds.borrow_mut());\n-    let r = f();\n+    let old_bounds = mem::take(&mut *cx.impl_trait_bounds.get_mut());\n+    let r = f(cx);\n     assert!(cx.impl_trait_bounds.borrow().is_empty());\n-    *cx.impl_trait_bounds.borrow_mut() = old_bounds;\n+    *cx.impl_trait_bounds.get_mut() = old_bounds;\n     r\n }\n "}, {"sha": "4517eda9b333f19d9706ef235fedd57319823ccf", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -83,13 +83,13 @@ crate struct DocContext<'tcx> {\n }\n \n impl<'tcx> DocContext<'tcx> {\n-    crate fn sess(&self) -> &Session {\n+    crate fn sess(&self) -> &'tcx Session {\n         &self.tcx.sess\n     }\n \n-    crate fn with_param_env<T, F: FnOnce() -> T>(&self, def_id: DefId, f: F) -> T {\n+    crate fn with_param_env<T, F: FnOnce(&mut Self) -> T>(&mut self, def_id: DefId, f: F) -> T {\n         let old_param_env = self.param_env.replace(self.tcx.param_env(def_id));\n-        let ret = f();\n+        let ret = f(self);\n         self.param_env.set(old_param_env);\n         ret\n     }\n@@ -104,24 +104,24 @@ impl<'tcx> DocContext<'tcx> {\n     /// Call the closure with the given parameters set as\n     /// the substitutions for a type alias' RHS.\n     crate fn enter_alias<F, R>(\n-        &self,\n+        &mut self,\n         ty_substs: FxHashMap<DefId, clean::Type>,\n         lt_substs: FxHashMap<DefId, clean::Lifetime>,\n         ct_substs: FxHashMap<DefId, clean::Constant>,\n         f: F,\n     ) -> R\n     where\n-        F: FnOnce() -> R,\n+        F: FnOnce(&mut Self) -> R,\n     {\n         let (old_tys, old_lts, old_cts) = (\n-            mem::replace(&mut *self.ty_substs.borrow_mut(), ty_substs),\n-            mem::replace(&mut *self.lt_substs.borrow_mut(), lt_substs),\n-            mem::replace(&mut *self.ct_substs.borrow_mut(), ct_substs),\n+            mem::replace(&mut *self.ty_substs.get_mut(), ty_substs),\n+            mem::replace(&mut *self.lt_substs.get_mut(), lt_substs),\n+            mem::replace(&mut *self.ct_substs.get_mut(), ct_substs),\n         );\n-        let r = f();\n-        *self.ty_substs.borrow_mut() = old_tys;\n-        *self.lt_substs.borrow_mut() = old_lts;\n-        *self.ct_substs.borrow_mut() = old_cts;\n+        let r = f(self);\n+        *self.ty_substs.get_mut() = old_tys;\n+        *self.lt_substs.get_mut() = old_lts;\n+        *self.ct_substs.get_mut() = old_cts;\n         r\n     }\n \n@@ -627,7 +627,7 @@ crate fn run_global_ctxt(\n         };\n         if run {\n             debug!(\"running pass {}\", p.pass.name);\n-            krate = ctxt.tcx.sess.time(p.pass.name, || (p.pass.run)(krate, &ctxt));\n+            krate = ctxt.tcx.sess.time(p.pass.name, || (p.pass.run)(krate, &mut ctxt));\n         }\n     }\n "}, {"sha": "f5eb92c1bb5aa0522b736321736d31c22551ec06", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -181,7 +181,7 @@ impl<'tcx> Context<'tcx> {\n         self.shared.tcx\n     }\n \n-    fn sess(&self) -> &Session {\n+    fn sess(&self) -> &'tcx Session {\n         &self.shared.tcx.sess\n     }\n }"}, {"sha": "689cda76cc0947a175f2f01efeb62674e4e872b1", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -70,8 +70,8 @@ impl DocFolder for SourceCollector<'_, '_> {\n     }\n }\n \n-impl SourceCollector<'_, '_> {\n-    fn sess(&self) -> &Session {\n+impl SourceCollector<'_, 'tcx> {\n+    fn sess(&self) -> &'tcx Session {\n         &self.scx.tcx.sess\n     }\n "}, {"sha": "ce88e09b174e5ba8a7c812945ffb6d6ea0b88c66", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -37,8 +37,8 @@ crate struct JsonRenderer<'tcx> {\n     cache: Rc<Cache>,\n }\n \n-impl JsonRenderer<'_> {\n-    fn sess(&self) -> &Session {\n+impl JsonRenderer<'tcx> {\n+    fn sess(&self) -> &'tcx Session {\n         self.tcx.sess\n     }\n "}, {"sha": "542cf6d2c275ad5838fe367c7c1bcad4f66cb9f4", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -20,8 +20,8 @@ crate const CALCULATE_DOC_COVERAGE: Pass = Pass {\n     description: \"counts the number of items with and without documentation\",\n };\n \n-fn calculate_doc_coverage(krate: clean::Crate, ctx: &DocContext<'_>) -> clean::Crate {\n-    let mut calc = CoverageCalculator::new(ctx);\n+fn calculate_doc_coverage(krate: clean::Crate, ctx: &mut DocContext<'_>) -> clean::Crate {\n+    let mut calc = CoverageCalculator { items: Default::default(), ctx };\n     let krate = calc.fold_crate(krate);\n \n     calc.print_results();\n@@ -101,7 +101,7 @@ impl ops::AddAssign for ItemCount {\n \n struct CoverageCalculator<'a, 'b> {\n     items: BTreeMap<FileName, ItemCount>,\n-    ctx: &'a DocContext<'b>,\n+    ctx: &'a mut DocContext<'b>,\n }\n \n fn limit_filename_len(filename: String) -> String {\n@@ -115,10 +115,6 @@ fn limit_filename_len(filename: String) -> String {\n }\n \n impl<'a, 'b> CoverageCalculator<'a, 'b> {\n-    fn new(ctx: &'a DocContext<'b>) -> CoverageCalculator<'a, 'b> {\n-        CoverageCalculator { items: Default::default(), ctx }\n-    }\n-\n     fn to_json(&self) -> String {\n         serde_json::to_string(\n             &self"}, {"sha": "c85490864ec70e68a1037d780ac961bc001896c1", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -17,7 +17,7 @@ crate const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n     description: \"validates syntax inside Rust code blocks\",\n };\n \n-crate fn check_code_block_syntax(krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n+crate fn check_code_block_syntax(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n     SyntaxChecker { cx }.fold_crate(krate)\n }\n "}, {"sha": "2c2ae9d03bf82ea272225c673f1a2581e7553c32", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -47,8 +47,14 @@ crate const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n     description: \"resolves intra-doc links\",\n };\n \n-crate fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n-    LinkCollector::new(cx).fold_crate(krate)\n+crate fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+    LinkCollector {\n+        cx,\n+        mod_ids: Vec::new(),\n+        kind_side_channel: Cell::new(None),\n+        visited_links: FxHashMap::default(),\n+    }\n+    .fold_crate(krate)\n }\n \n /// Top-level errors emitted by this pass.\n@@ -257,7 +263,7 @@ struct CachedLink {\n }\n \n struct LinkCollector<'a, 'tcx> {\n-    cx: &'a DocContext<'tcx>,\n+    cx: &'a mut DocContext<'tcx>,\n     /// A stack of modules used to decide what scope to resolve in.\n     ///\n     /// The last module will be used if the parent scope of the current item is\n@@ -273,15 +279,6 @@ struct LinkCollector<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n-    fn new(cx: &'a DocContext<'tcx>) -> Self {\n-        LinkCollector {\n-            cx,\n-            mod_ids: Vec::new(),\n-            kind_side_channel: Cell::new(None),\n-            visited_links: FxHashMap::default(),\n-        }\n-    }\n-\n     /// Given a full link, parse it as an [enum struct variant].\n     ///\n     /// In particular, this will return an error whenever there aren't three\n@@ -293,7 +290,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'path str,\n         module_id: DefId,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n-        let cx = self.cx;\n+        let tcx = self.cx.tcx;\n         let no_res = || ResolutionFailure::NotResolved {\n             module_id,\n             partial_res: None,\n@@ -317,7 +314,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             // If there's no third component, we saw `[a::b]` before and it failed to resolve.\n             // So there's no partial res.\n             .ok_or_else(no_res)?;\n-        let ty_res = cx\n+        let ty_res = self\n+            .cx\n             .enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n             })\n@@ -326,18 +324,17 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n         match ty_res {\n             Res::Def(DefKind::Enum, did) => {\n-                if cx\n-                    .tcx\n+                if tcx\n                     .inherent_impls(did)\n                     .iter()\n-                    .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n+                    .flat_map(|imp| tcx.associated_items(*imp).in_definition_order())\n                     .any(|item| item.ident.name == variant_name)\n                 {\n                     // This is just to let `fold_item` know that this shouldn't be considered;\n                     // it's a bug for the error to make it to the user\n                     return Err(ResolutionFailure::Dummy.into());\n                 }\n-                match cx.tcx.type_of(did).kind() {\n+                match tcx.type_of(did).kind() {\n                     ty::Adt(def, _) if def.is_enum() => {\n                         if def.all_fields().any(|item| item.ident.name == variant_field_name) {\n                             Ok((\n@@ -380,20 +377,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         item_name: Symbol,\n         item_str: &'path str,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n-        let cx = self.cx;\n+        let tcx = self.cx.tcx;\n \n         prim_ty\n-            .impls(cx.tcx)\n+            .impls(tcx)\n             .into_iter()\n             .find_map(|&impl_| {\n-                cx.tcx\n-                    .associated_items(impl_)\n-                    .find_by_name_and_namespace(\n-                        cx.tcx,\n-                        Ident::with_dummy_span(item_name),\n-                        ns,\n-                        impl_,\n-                    )\n+                tcx.associated_items(impl_)\n+                    .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n                     .map(|item| {\n                         let kind = item.kind;\n                         self.kind_side_channel.set(Some((kind.as_def_kind(), item.def_id)));\n@@ -434,9 +425,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'a str,\n         module_id: DefId,\n     ) -> Result<Res, ResolutionFailure<'a>> {\n-        let cx = self.cx;\n         let path = ast::Path::from_ident(Ident::from_str(path_str));\n-        cx.enter_resolver(|resolver| {\n+        self.cx.enter_resolver(|resolver| {\n             // FIXME(jynelson): does this really need 3 separate lookups?\n             if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n                 &path,\n@@ -498,7 +488,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n-        let cx = self.cx;\n+        let cx = &self.cx;\n \n         if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n@@ -948,12 +938,18 @@ impl LinkCollector<'_, '_> {\n             return None;\n         }\n \n-        let cx = self.cx;\n         let link = ori_link.link.replace(\"`\", \"\");\n         let parts = link.split('#').collect::<Vec<_>>();\n         let (link, extra_fragment) = if parts.len() > 2 {\n             // A valid link can't have multiple #'s\n-            anchor_failure(cx, &item, &link, dox, ori_link.range, AnchorFailure::MultipleAnchors);\n+            anchor_failure(\n+                self.cx,\n+                &item,\n+                &link,\n+                dox,\n+                ori_link.range,\n+                AnchorFailure::MultipleAnchors,\n+            );\n             return None;\n         } else if parts.len() == 2 {\n             if parts[0].trim().is_empty() {\n@@ -1105,7 +1101,7 @@ impl LinkCollector<'_, '_> {\n                 if matches!(disambiguator, Some(Disambiguator::Primitive)) {\n                     if fragment.is_some() {\n                         anchor_failure(\n-                            cx,\n+                            self.cx,\n                             &item,\n                             path_str,\n                             dox,\n@@ -1119,7 +1115,7 @@ impl LinkCollector<'_, '_> {\n                 } else {\n                     // `[char]` when a `char` module is in scope\n                     let candidates = vec![res, prim];\n-                    ambiguity_error(cx, &item, path_str, dox, ori_link.range, candidates);\n+                    ambiguity_error(self.cx, &item, path_str, dox, ori_link.range, candidates);\n                     return None;\n                 }\n             }\n@@ -1140,7 +1136,7 @@ impl LinkCollector<'_, '_> {\n                 suggest_disambiguator(resolved, diag, path_str, dox, sp, &ori_link.range);\n             };\n             report_diagnostic(\n-                cx,\n+                self.cx,\n                 BROKEN_INTRA_DOC_LINKS,\n                 &msg,\n                 &item,\n@@ -1187,7 +1183,7 @@ impl LinkCollector<'_, '_> {\n                 if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n                     && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n                 {\n-                    privacy_error(cx, &item, &path_str, dox, &ori_link);\n+                    privacy_error(self.cx, &item, &path_str, dox, &ori_link);\n                 }\n             }\n \n@@ -1211,7 +1207,7 @@ impl LinkCollector<'_, '_> {\n                         && !self.cx.tcx.features().intra_doc_pointers\n                     {\n                         let span = super::source_span_for_markdown_range(\n-                            cx,\n+                            self.cx,\n                             dox,\n                             &ori_link.range,\n                             &item.attrs,\n@@ -1243,7 +1239,7 @@ impl LinkCollector<'_, '_> {\n             }\n             Res::Def(kind, id) => {\n                 verify(kind, id)?;\n-                let id = clean::register_res(cx, rustc_hir::def::Res::Def(kind, id));\n+                let id = clean::register_res(self.cx, rustc_hir::def::Res::Def(kind, id));\n                 Some(ItemLink { link: ori_link.link, link_text, did: Some(id), fragment })\n             }\n         }"}, {"sha": "0b6d81d1b447effc3aa557e1831f7f6e35ccfb0c", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -14,9 +14,11 @@ crate const COLLECT_TRAIT_IMPLS: Pass = Pass {\n     description: \"retrieves trait impls for items in the crate\",\n };\n \n-crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n-    let mut synth = SyntheticImplCollector::new(cx);\n-    let mut krate = cx.sess().time(\"collect_synthetic_impls\", || synth.fold_crate(krate));\n+crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+    let (mut krate, synth_impls) = cx.sess().time(\"collect_synthetic_impls\", || {\n+        let mut synth = SyntheticImplCollector { cx, impls: Vec::new() };\n+        (synth.fold_crate(krate), synth.impls)\n+    });\n \n     let prims: FxHashSet<PrimitiveType> = krate.primitives.iter().map(|p| p.1).collect();\n \n@@ -142,7 +144,7 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n         panic!(\"collect-trait-impls can't run\");\n     };\n \n-    items.extend(synth.impls);\n+    items.extend(synth_impls);\n     for it in new_items.drain(..) {\n         if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n             if !(cleaner.keep_impl(for_)\n@@ -160,16 +162,10 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n }\n \n struct SyntheticImplCollector<'a, 'tcx> {\n-    cx: &'a DocContext<'tcx>,\n+    cx: &'a mut DocContext<'tcx>,\n     impls: Vec<Item>,\n }\n \n-impl<'a, 'tcx> SyntheticImplCollector<'a, 'tcx> {\n-    fn new(cx: &'a DocContext<'tcx>) -> Self {\n-        SyntheticImplCollector { cx, impls: Vec::new() }\n-    }\n-}\n-\n impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.is_struct() || i.is_enum() || i.is_union() {"}, {"sha": "042a895d2fa2f4e8daf314db6a3660e2b89451a4", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -19,27 +19,20 @@ crate const CHECK_PRIVATE_ITEMS_DOC_TESTS: Pass = Pass {\n };\n \n struct PrivateItemDocTestLinter<'a, 'tcx> {\n-    cx: &'a DocContext<'tcx>,\n+    cx: &'a mut DocContext<'tcx>,\n }\n \n-impl<'a, 'tcx> PrivateItemDocTestLinter<'a, 'tcx> {\n-    fn new(cx: &'a DocContext<'tcx>) -> Self {\n-        PrivateItemDocTestLinter { cx }\n-    }\n-}\n-\n-crate fn check_private_items_doc_tests(krate: Crate, cx: &DocContext<'_>) -> Crate {\n-    let mut coll = PrivateItemDocTestLinter::new(cx);\n+crate fn check_private_items_doc_tests(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+    let mut coll = PrivateItemDocTestLinter { cx };\n \n     coll.fold_crate(krate)\n }\n \n impl<'a, 'tcx> DocFolder for PrivateItemDocTestLinter<'a, 'tcx> {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n-        let cx = self.cx;\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);\n \n-        look_for_tests(&cx, &dox, &item);\n+        look_for_tests(self.cx, &dox, &item);\n \n         Some(self.fold_item_recur(item))\n     }"}, {"sha": "a6fe7e228d7e8105ed7c95c0eee666ed6747e4c7", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -16,20 +16,14 @@ crate const CHECK_INVALID_HTML_TAGS: Pass = Pass {\n };\n \n struct InvalidHtmlTagsLinter<'a, 'tcx> {\n-    cx: &'a DocContext<'tcx>,\n+    cx: &'a mut DocContext<'tcx>,\n }\n \n-impl<'a, 'tcx> InvalidHtmlTagsLinter<'a, 'tcx> {\n-    fn new(cx: &'a DocContext<'tcx>) -> Self {\n-        InvalidHtmlTagsLinter { cx }\n-    }\n-}\n-\n-crate fn check_invalid_html_tags(krate: Crate, cx: &DocContext<'_>) -> Crate {\n+crate fn check_invalid_html_tags(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     if !cx.tcx.sess.is_nightly_build() {\n         krate\n     } else {\n-        let mut coll = InvalidHtmlTagsLinter::new(cx);\n+        let mut coll = InvalidHtmlTagsLinter { cx };\n \n         coll.fold_crate(krate)\n     }"}, {"sha": "5813732facb6e92f6ad38e4195ca391d74a5b24d", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -53,7 +53,7 @@ crate use self::html_tags::CHECK_INVALID_HTML_TAGS;\n #[derive(Copy, Clone)]\n crate struct Pass {\n     crate name: &'static str,\n-    crate run: fn(clean::Crate, &DocContext<'_>) -> clean::Crate,\n+    crate run: fn(clean::Crate, &mut DocContext<'_>) -> clean::Crate,\n     crate description: &'static str,\n }\n "}, {"sha": "9d4539a9769ca05891848a0ea954deab15ceeda2", "filename": "src/librustdoc/passes/non_autolinks.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -23,15 +23,11 @@ const URL_REGEX: &str = concat!(\n );\n \n struct NonAutolinksLinter<'a, 'tcx> {\n-    cx: &'a DocContext<'tcx>,\n+    cx: &'a mut DocContext<'tcx>,\n     regex: Regex,\n }\n \n impl<'a, 'tcx> NonAutolinksLinter<'a, 'tcx> {\n-    fn new(cx: &'a DocContext<'tcx>) -> Self {\n-        Self { cx, regex: Regex::new(URL_REGEX).expect(\"failed to build regex\") }\n-    }\n-\n     fn find_raw_urls(\n         &self,\n         text: &str,\n@@ -52,11 +48,12 @@ impl<'a, 'tcx> NonAutolinksLinter<'a, 'tcx> {\n     }\n }\n \n-crate fn check_non_autolinks(krate: Crate, cx: &DocContext<'_>) -> Crate {\n+crate fn check_non_autolinks(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     if !cx.tcx.sess.is_nightly_build() {\n         krate\n     } else {\n-        let mut coll = NonAutolinksLinter::new(cx);\n+        let mut coll =\n+            NonAutolinksLinter { cx, regex: Regex::new(URL_REGEX).expect(\"failed to build regex\") };\n \n         coll.fold_crate(krate)\n     }"}, {"sha": "2369ff78b1ce05eee76299ab1e9383da4b919fbc", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -12,7 +12,7 @@ crate const PROPAGATE_DOC_CFG: Pass = Pass {\n     description: \"propagates `#[doc(cfg(...))]` to child items\",\n };\n \n-crate fn propagate_doc_cfg(cr: Crate, _: &DocContext<'_>) -> Crate {\n+crate fn propagate_doc_cfg(cr: Crate, _: &mut DocContext<'_>) -> Crate {\n     CfgPropagator { parent_cfg: None }.fold_crate(cr)\n }\n "}, {"sha": "c742d32cb62eab09756d992a712d76ebeedcbf53", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -15,7 +15,7 @@ crate const STRIP_HIDDEN: Pass = Pass {\n };\n \n /// Strip items marked `#[doc(hidden)]`\n-crate fn strip_hidden(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n+crate fn strip_hidden(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n     let mut retained = DefIdSet::default();\n \n     // strip all #[doc(hidden)] items"}, {"sha": "63869324cb8d234c94314a14a09f33b74b92ad9c", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -9,6 +9,6 @@ crate const STRIP_PRIV_IMPORTS: Pass = Pass {\n     description: \"strips all private import statements (`use`, `extern crate`) from a crate\",\n };\n \n-crate fn strip_priv_imports(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n+crate fn strip_priv_imports(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n     ImportStripper.fold_crate(krate)\n }"}, {"sha": "c0bb05af3edb51dda040b94ef9a758beb5374cdb", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -14,7 +14,7 @@ crate const STRIP_PRIVATE: Pass = Pass {\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-crate fn strip_private(mut krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n+crate fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n     let mut retained = DefIdSet::default();\n     let access_levels = cx.renderinfo.borrow().access_levels.clone();"}, {"sha": "da2eda73641228e737f6f70cab177bbc48511940", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b471a3f5fe57e5c6e08acf665f2094422415a3d/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=9b471a3f5fe57e5c6e08acf665f2094422415a3d", "patch": "@@ -14,7 +14,7 @@ crate const UNINDENT_COMMENTS: Pass = Pass {\n     description: \"removes excess indentation on comments in order for markdown to like it\",\n };\n \n-crate fn unindent_comments(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n+crate fn unindent_comments(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n     CommentCleaner.fold_crate(krate)\n }\n "}]}