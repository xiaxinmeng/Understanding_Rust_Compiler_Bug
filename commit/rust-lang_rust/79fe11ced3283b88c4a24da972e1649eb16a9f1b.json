{"sha": "79fe11ced3283b88c4a24da972e1649eb16a9f1b", "node_id": "C_kwDOAAsO6NoAKDc5ZmUxMWNlZDMyODNiODhjNGEyNGRhOTcyZTE2NDllYjE2YTlmMWI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-05-26T13:09:19Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-05-26T13:09:19Z"}, "message": "Shuffle some things around", "tree": {"sha": "50741f68af05ea945e42759a5beb0eba1030a396", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50741f68af05ea945e42759a5beb0eba1030a396"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79fe11ced3283b88c4a24da972e1649eb16a9f1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79fe11ced3283b88c4a24da972e1649eb16a9f1b", "html_url": "https://github.com/rust-lang/rust/commit/79fe11ced3283b88c4a24da972e1649eb16a9f1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79fe11ced3283b88c4a24da972e1649eb16a9f1b/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9638466567e66f6024ffa922bf48b8aba6a33b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9638466567e66f6024ffa922bf48b8aba6a33b4", "html_url": "https://github.com/rust-lang/rust/commit/e9638466567e66f6024ffa922bf48b8aba6a33b4"}], "stats": {"total": 165, "additions": 91, "deletions": 74}, "files": [{"sha": "defb3e1461fa5a01553fcd8de90f199fcb90a418", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/79fe11ced3283b88c4a24da972e1649eb16a9f1b/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fe11ced3283b88c4a24da972e1649eb16a9f1b/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=79fe11ced3283b88c4a24da972e1649eb16a9f1b", "patch": "@@ -52,24 +52,31 @@ pub(crate) type ReqQueue = lsp_server::ReqQueue<(String, Instant), ReqHandler>;\n pub(crate) struct GlobalState {\n     sender: Sender<lsp_server::Message>,\n     req_queue: ReqQueue,\n+\n     pub(crate) task_pool: Handle<TaskPool<Task>, Receiver<Task>>,\n-    pub(crate) loader: Handle<Box<dyn vfs::loader::Handle>, Receiver<vfs::loader::Message>>,\n+\n     pub(crate) config: Arc<Config>,\n     pub(crate) analysis_host: AnalysisHost,\n     pub(crate) diagnostics: DiagnosticCollection,\n     pub(crate) mem_docs: MemDocs,\n+    pub(crate) source_root_config: SourceRootConfig,\n     pub(crate) semantic_tokens_cache: Arc<Mutex<FxHashMap<Url, SemanticTokens>>>,\n+\n+    // status\n     pub(crate) shutdown_requested: bool,\n     pub(crate) last_reported_status: Option<lsp_ext::ServerStatusParams>,\n-    pub(crate) source_root_config: SourceRootConfig,\n \n+    // proc macros\n     pub(crate) proc_macro_changed: bool,\n     pub(crate) proc_macro_clients: Arc<[anyhow::Result<ProcMacroServer>]>,\n \n+    // Flycheck\n     pub(crate) flycheck: Arc<[FlycheckHandle]>,\n     pub(crate) flycheck_sender: Sender<flycheck::Message>,\n     pub(crate) flycheck_receiver: Receiver<flycheck::Message>,\n \n+    // VFS\n+    pub(crate) loader: Handle<Box<dyn vfs::loader::Handle>, Receiver<vfs::loader::Message>>,\n     pub(crate) vfs: Arc<RwLock<(vfs::Vfs, IntMap<FileId, LineEndings>)>>,\n     pub(crate) vfs_config_version: u32,\n     pub(crate) vfs_progress_config_version: u32,\n@@ -102,11 +109,12 @@ pub(crate) struct GlobalState {\n     /// the user just adds comments or whitespace to Cargo.toml, we do not want\n     /// to invalidate any salsa caches.\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n+\n+    // op queues\n     pub(crate) fetch_workspaces_queue: OpQueue<(), Option<Vec<anyhow::Result<ProjectWorkspace>>>>,\n     pub(crate) fetch_build_data_queue:\n         OpQueue<(), (Arc<Vec<ProjectWorkspace>>, Vec<anyhow::Result<WorkspaceBuildScripts>>)>,\n     pub(crate) fetch_proc_macros_queue: OpQueue<Vec<ProcMacroPaths>, bool>,\n-\n     pub(crate) prime_caches_queue: OpQueue,\n }\n "}, {"sha": "b3522394cd60dc898e42966ba1dcb5f74cebf57e", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 80, "deletions": 71, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/79fe11ced3283b88c4a24da972e1649eb16a9f1b/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79fe11ced3283b88c4a24da972e1649eb16a9f1b/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=79fe11ced3283b88c4a24da972e1649eb16a9f1b", "patch": "@@ -77,7 +77,7 @@ pub(crate) enum PrimeCachesProgress {\n \n impl fmt::Debug for Event {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let debug_verbose_not = |not: &Notification, f: &mut fmt::Formatter<'_>| {\n+        let debug_non_verbose = |not: &Notification, f: &mut fmt::Formatter<'_>| {\n             f.debug_struct(\"Notification\").field(\"method\", &not.method).finish()\n         };\n \n@@ -86,7 +86,7 @@ impl fmt::Debug for Event {\n                 if notification_is::<lsp_types::notification::DidOpenTextDocument>(not)\n                     || notification_is::<lsp_types::notification::DidChangeTextDocument>(not)\n                 {\n-                    return debug_verbose_not(not, f);\n+                    return debug_non_verbose(not, f);\n                 }\n             }\n             Event::Task(Task::Response(resp)) => {\n@@ -112,38 +112,7 @@ impl GlobalState {\n         self.update_status_or_notify();\n \n         if self.config.did_save_text_document_dynamic_registration() {\n-            let save_registration_options = lsp_types::TextDocumentSaveRegistrationOptions {\n-                include_text: Some(false),\n-                text_document_registration_options: lsp_types::TextDocumentRegistrationOptions {\n-                    document_selector: Some(vec![\n-                        lsp_types::DocumentFilter {\n-                            language: None,\n-                            scheme: None,\n-                            pattern: Some(\"**/*.rs\".into()),\n-                        },\n-                        lsp_types::DocumentFilter {\n-                            language: None,\n-                            scheme: None,\n-                            pattern: Some(\"**/Cargo.toml\".into()),\n-                        },\n-                        lsp_types::DocumentFilter {\n-                            language: None,\n-                            scheme: None,\n-                            pattern: Some(\"**/Cargo.lock\".into()),\n-                        },\n-                    ]),\n-                },\n-            };\n-\n-            let registration = lsp_types::Registration {\n-                id: \"textDocument/didSave\".to_string(),\n-                method: \"textDocument/didSave\".to_string(),\n-                register_options: Some(serde_json::to_value(save_registration_options).unwrap()),\n-            };\n-            self.send_request::<lsp_types::request::RegisterCapability>(\n-                lsp_types::RegistrationParams { registrations: vec![registration] },\n-                |_, _| (),\n-            );\n+            self.register_did_save_capability();\n         }\n \n         self.fetch_workspaces_queue.request_op(\"startup\".to_string(), ());\n@@ -152,17 +121,54 @@ impl GlobalState {\n         }\n \n         while let Some(event) = self.next_event(&inbox) {\n-            if let Event::Lsp(lsp_server::Message::Notification(not)) = &event {\n-                if not.method == lsp_types::notification::Exit::METHOD {\n-                    return Ok(());\n-                }\n+            if matches!(\n+                &event,\n+                Event::Lsp(lsp_server::Message::Notification(Notification { method, .. }))\n+                if method == lsp_types::notification::Exit::METHOD\n+            ) {\n+                return Ok(());\n             }\n-            self.handle_event(event)?\n+            self.handle_event(event)?;\n         }\n \n         Err(\"client exited without proper shutdown sequence\".into())\n     }\n \n+    fn register_did_save_capability(&mut self) {\n+        let save_registration_options = lsp_types::TextDocumentSaveRegistrationOptions {\n+            include_text: Some(false),\n+            text_document_registration_options: lsp_types::TextDocumentRegistrationOptions {\n+                document_selector: Some(vec![\n+                    lsp_types::DocumentFilter {\n+                        language: None,\n+                        scheme: None,\n+                        pattern: Some(\"**/*.rs\".into()),\n+                    },\n+                    lsp_types::DocumentFilter {\n+                        language: None,\n+                        scheme: None,\n+                        pattern: Some(\"**/Cargo.toml\".into()),\n+                    },\n+                    lsp_types::DocumentFilter {\n+                        language: None,\n+                        scheme: None,\n+                        pattern: Some(\"**/Cargo.lock\".into()),\n+                    },\n+                ]),\n+            },\n+        };\n+\n+        let registration = lsp_types::Registration {\n+            id: \"textDocument/didSave\".to_string(),\n+            method: \"textDocument/didSave\".to_string(),\n+            register_options: Some(serde_json::to_value(save_registration_options).unwrap()),\n+        };\n+        self.send_request::<lsp_types::request::RegisterCapability>(\n+            lsp_types::RegistrationParams { registrations: vec![registration] },\n+            |_, _| (),\n+        );\n+    }\n+\n     fn next_event(&self, inbox: &Receiver<lsp_server::Message>) -> Option<Event> {\n         select! {\n             recv(inbox) -> msg =>\n@@ -184,20 +190,20 @@ impl GlobalState {\n         // NOTE: don't count blocking select! call as a loop-turn time\n         let _p = profile::span(\"GlobalState::handle_event\");\n \n-        let event_dbg = format!(\"{event:?}\");\n-        tracing::debug!(\"{:?} handle_event({:?})\", loop_start, event);\n-        let task_queue_len = self.task_pool.handle.len();\n-        if task_queue_len > 0 {\n-            tracing::info!(\"task queue len: {}\", task_queue_len);\n+        let event_dbg_msg = format!(\"{event:?}\");\n+        tracing::debug!(\"{:?} handle_event({})\", loop_start, event_dbg_msg);\n+        if tracing::enabled!(tracing::Level::INFO) {\n+            let task_queue_len = self.task_pool.handle.len();\n+            if task_queue_len > 0 {\n+                tracing::info!(\"task queue len: {}\", task_queue_len);\n+            }\n         }\n \n         let was_quiescent = self.is_quiescent();\n         match event {\n             Event::Lsp(msg) => match msg {\n                 lsp_server::Message::Request(req) => self.on_new_request(loop_start, req),\n-                lsp_server::Message::Notification(not) => {\n-                    self.on_notification(not)?;\n-                }\n+                lsp_server::Message::Notification(not) => self.on_notification(not)?,\n                 lsp_server::Message::Response(resp) => self.complete_request(resp),\n             },\n             Event::Task(task) => {\n@@ -291,7 +297,8 @@ impl GlobalState {\n                 }\n             }\n \n-            if !was_quiescent || state_changed {\n+            let client_refresh = !was_quiescent || state_changed;\n+            if client_refresh {\n                 // Refresh semantic tokens if the client supports it.\n                 if self.config.semantic_tokens_refresh() {\n                     self.semantic_tokens_cache.lock().clear();\n@@ -309,9 +316,9 @@ impl GlobalState {\n                 }\n             }\n \n-            if (!was_quiescent || state_changed || memdocs_added_or_removed)\n-                && self.config.publish_diagnostics()\n-            {\n+            let update_diagnostics = (!was_quiescent || state_changed || memdocs_added_or_removed)\n+                && self.config.publish_diagnostics();\n+            if update_diagnostics {\n                 self.update_diagnostics()\n             }\n         }\n@@ -371,38 +378,40 @@ impl GlobalState {\n         }\n \n         if let Some((cause, ())) = self.prime_caches_queue.should_start_op() {\n-            tracing::debug!(%cause, \"will prime caches\");\n-            let num_worker_threads = self.config.prime_caches_num_threads();\n-\n-            self.task_pool.handle.spawn_with_sender({\n-                let analysis = self.snapshot().analysis;\n-                move |sender| {\n-                    sender.send(Task::PrimeCaches(PrimeCachesProgress::Begin)).unwrap();\n-                    let res = analysis.parallel_prime_caches(num_worker_threads, |progress| {\n-                        let report = PrimeCachesProgress::Report(progress);\n-                        sender.send(Task::PrimeCaches(report)).unwrap();\n-                    });\n-                    sender\n-                        .send(Task::PrimeCaches(PrimeCachesProgress::End {\n-                            cancelled: res.is_err(),\n-                        }))\n-                        .unwrap();\n-                }\n-            });\n+            self.prime_caches(cause);\n         }\n \n         self.update_status_or_notify();\n \n         let loop_duration = loop_start.elapsed();\n         if loop_duration > Duration::from_millis(100) && was_quiescent {\n-            tracing::warn!(\"overly long loop turn took {loop_duration:?}: {event_dbg}\");\n+            tracing::warn!(\"overly long loop turn took {loop_duration:?}: {event_dbg_msg}\");\n             self.poke_rust_analyzer_developer(format!(\n-                \"overly long loop turn took {loop_duration:?}: {event_dbg}\"\n+                \"overly long loop turn took {loop_duration:?}: {event_dbg_msg}\"\n             ));\n         }\n         Ok(())\n     }\n \n+    fn prime_caches(&mut self, cause: String) {\n+        tracing::debug!(%cause, \"will prime caches\");\n+        let num_worker_threads = self.config.prime_caches_num_threads();\n+\n+        self.task_pool.handle.spawn_with_sender({\n+            let analysis = self.snapshot().analysis;\n+            move |sender| {\n+                sender.send(Task::PrimeCaches(PrimeCachesProgress::Begin)).unwrap();\n+                let res = analysis.parallel_prime_caches(num_worker_threads, |progress| {\n+                    let report = PrimeCachesProgress::Report(progress);\n+                    sender.send(Task::PrimeCaches(report)).unwrap();\n+                });\n+                sender\n+                    .send(Task::PrimeCaches(PrimeCachesProgress::End { cancelled: res.is_err() }))\n+                    .unwrap();\n+            }\n+        });\n+    }\n+\n     fn update_status_or_notify(&mut self) {\n         let status = self.current_status();\n         if self.last_reported_status.as_ref() != Some(&status) {"}]}