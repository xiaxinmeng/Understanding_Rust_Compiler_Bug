{"sha": "eb3ff3ccb0bc065a0bf3010f83defd53f642bd4c", "node_id": "C_kwDOAAsO6NoAKGViM2ZmM2NjYjBiYzA2NWEwYmYzMDEwZjgzZGVmZDUzZjY0MmJkNGM", "commit": {"author": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-03-16T13:43:51Z"}, "committer": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-03-16T13:52:46Z"}, "message": "TB: tree traversal", "tree": {"sha": "b35e34cedb547322c3547f70f2fa793da6749a59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b35e34cedb547322c3547f70f2fa793da6749a59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb3ff3ccb0bc065a0bf3010f83defd53f642bd4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb3ff3ccb0bc065a0bf3010f83defd53f642bd4c", "html_url": "https://github.com/rust-lang/rust/commit/eb3ff3ccb0bc065a0bf3010f83defd53f642bd4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb3ff3ccb0bc065a0bf3010f83defd53f642bd4c/comments", "author": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd954dbf1436951ae94b7b8cf052edcb0e3e2dfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd954dbf1436951ae94b7b8cf052edcb0e3e2dfc", "html_url": "https://github.com/rust-lang/rust/commit/cd954dbf1436951ae94b7b8cf052edcb0e3e2dfc"}], "stats": {"total": 339, "additions": 339, "deletions": 0}, "files": [{"sha": "86416a0eb1bca2ee4bd9859f9c7e7456980eb171", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/tree.rs", "status": "modified", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/eb3ff3ccb0bc065a0bf3010f83defd53f642bd4c/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb3ff3ccb0bc065a0bf3010f83defd53f642bd4c/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs?ref=eb3ff3ccb0bc065a0bf3010f83defd53f642bd4c", "patch": "@@ -115,6 +115,151 @@ pub(super) struct Node {\n     pub debug_info: NodeDebugInfo,\n }\n \n+/// Data given to the transition function\n+struct NodeAppArgs<'node> {\n+    /// Node on which the transition is currently being applied\n+    node: &'node Node,\n+    /// Mutable access to its permissions\n+    perm: UniEntry<'node, LocationState>,\n+    /// Relative position of the access\n+    rel_pos: AccessRelatedness,\n+}\n+/// Data given to the error handler\n+struct ErrHandlerArgs<'node, InErr> {\n+    /// Kind of error that occurred\n+    error_kind: InErr,\n+    /// Tag that triggered the error (not the tag that was accessed,\n+    /// rather the parent tag that had insufficient permissions or the\n+    /// non-parent tag that had a protector).\n+    faulty_tag: &'node NodeDebugInfo,\n+}\n+/// Internal contents of `Tree` with the minimum of mutable access for\n+/// the purposes of the tree traversal functions: the permissions (`perms`) can be\n+/// updated but not the tree structure (`tag_mapping` and `nodes`)\n+struct TreeVisitor<'tree> {\n+    tag_mapping: &'tree UniKeyMap<BorTag>,\n+    nodes: &'tree UniValMap<Node>,\n+    perms: &'tree mut UniValMap<LocationState>,\n+}\n+\n+/// Whether to continue exploring the children recursively or not.\n+enum ContinueTraversal {\n+    Recurse,\n+    SkipChildren,\n+}\n+\n+impl<'tree> TreeVisitor<'tree> {\n+    // Applies `f_propagate` to every vertex of the tree top-down in the following order: first\n+    // all ancestors of `start`, then `start` itself, then children of `start`, then the rest.\n+    // This ensures that errors are triggered in the following order\n+    // - first invalid accesses with insufficient permissions, closest to the root first,\n+    // - then protector violations, closest to `start` first.\n+    //\n+    // `f_propagate` should follow the following format: for a given `Node` it updates its\n+    // `Permission` depending on the position relative to `start` (given by an\n+    // `AccessRelatedness`).\n+    // It outputs whether the tree traversal for this subree should continue or not.\n+    fn traverse_parents_this_children_others<InnErr, OutErr>(\n+        mut self,\n+        start: BorTag,\n+        f_propagate: impl Fn(NodeAppArgs<'_>) -> Result<ContinueTraversal, InnErr>,\n+        err_builder: impl Fn(ErrHandlerArgs<'_, InnErr>) -> OutErr,\n+    ) -> Result<(), OutErr>\n+where {\n+        struct TreeVisitAux<NodeApp, ErrHandler> {\n+            f_propagate: NodeApp,\n+            err_builder: ErrHandler,\n+            stack: Vec<(UniIndex, AccessRelatedness)>,\n+        }\n+        impl<NodeApp, InnErr, OutErr, ErrHandler> TreeVisitAux<NodeApp, ErrHandler>\n+        where\n+            NodeApp: Fn(NodeAppArgs<'_>) -> Result<ContinueTraversal, InnErr>,\n+            ErrHandler: Fn(ErrHandlerArgs<'_, InnErr>) -> OutErr,\n+        {\n+            fn pop(&mut self) -> Option<(UniIndex, AccessRelatedness)> {\n+                self.stack.pop()\n+            }\n+\n+            /// Apply the function to the current `tag`, and push its children\n+            /// to the stack of future tags to visit.\n+            fn exec_and_visit(\n+                &mut self,\n+                this: &mut TreeVisitor<'_>,\n+                tag: UniIndex,\n+                exclude: Option<UniIndex>,\n+                rel_pos: AccessRelatedness,\n+            ) -> Result<(), OutErr> {\n+                // 1. apply the propagation function\n+                let node = this.nodes.get(tag).unwrap();\n+                let recurse =\n+                    (self.f_propagate)(NodeAppArgs { node, perm: this.perms.entry(tag), rel_pos })\n+                        .map_err(|error_kind| {\n+                            (self.err_builder)(ErrHandlerArgs {\n+                                error_kind,\n+                                faulty_tag: &node.debug_info,\n+                            })\n+                        })?;\n+                // 2. add the children to the stack for future traversal\n+                if matches!(recurse, ContinueTraversal::Recurse) {\n+                    let child_rel = rel_pos.for_child();\n+                    for &child in node.children.iter() {\n+                        // some child might be excluded from here and handled separately\n+                        if Some(child) != exclude {\n+                            self.stack.push((child, child_rel));\n+                        }\n+                    }\n+                }\n+                Ok(())\n+            }\n+        }\n+\n+        let start_idx = self.tag_mapping.get(&start).unwrap();\n+        let mut stack = TreeVisitAux { f_propagate, err_builder, stack: Vec::new() };\n+        {\n+            let mut path_ascend = Vec::new();\n+            // First climb to the root while recording the path\n+            let mut curr = start_idx;\n+            while let Some(ancestor) = self.nodes.get(curr).unwrap().parent {\n+                path_ascend.push((ancestor, curr));\n+                curr = ancestor;\n+            }\n+            // Then descend:\n+            // - execute f_propagate on each node\n+            // - record children in visit\n+            while let Some((ancestor, next_in_path)) = path_ascend.pop() {\n+                // Explore ancestors in descending order.\n+                // `next_in_path` is excluded from the recursion because it\n+                // will be the `ancestor` of the next iteration.\n+                // It also needs a different `AccessRelatedness` than the other\n+                // children of `ancestor`.\n+                stack.exec_and_visit(\n+                    &mut self,\n+                    ancestor,\n+                    Some(next_in_path),\n+                    AccessRelatedness::StrictChildAccess,\n+                )?;\n+            }\n+        };\n+        // All (potentially zero) ancestors have been explored, call f_propagate on start\n+        stack.exec_and_visit(&mut self, start_idx, None, AccessRelatedness::This)?;\n+        // up to this point we have never popped from `stack`, hence if the\n+        // path to the root is `root = p(n) <- p(n-1)... <- p(1) <- p(0) = start`\n+        // then now `stack` contains\n+        // `[<children(p(n)) except p(n-1)> ... <children(p(1)) except p(0)> <children(p(0))>]`,\n+        // all of which are for now unexplored.\n+        // This is the starting point of a standard DFS which will thus\n+        // explore all non-ancestors of `start` in the following order:\n+        // - all descendants of `start`;\n+        // - then the unexplored descendants of `parent(start)`;\n+        // ...\n+        // - until finally the unexplored descendants of `root`.\n+        while let Some((tag, rel_pos)) = stack.pop() {\n+            stack.exec_and_visit(&mut self, tag, None, rel_pos)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl Tree {\n     /// Create a new tree, with only a root pointer.\n     pub fn new(root_tag: BorTag, size: Size) -> Self {\n@@ -177,6 +322,200 @@ impl<'tcx> Tree {\n         Ok(())\n     }\n \n+    /// Deallocation requires\n+    /// - a pointer that permits write accesses\n+    /// - the absence of Strong Protectors anywhere in the allocation\n+    pub fn dealloc(\n+        &mut self,\n+        tag: BorTag,\n+        range: AllocRange,\n+        global: &GlobalState,\n+    ) -> InterpResult<'tcx> {\n+        self.perform_access(AccessKind::Write, tag, range, global)?;\n+        let access_info = &self.nodes.get(self.tag_mapping.get(&tag).unwrap()).unwrap().debug_info;\n+        for (_range, perms) in self.rperms.iter_mut(range.start, range.size) {\n+            TreeVisitor { nodes: &self.nodes, tag_mapping: &self.tag_mapping, perms }\n+                .traverse_parents_this_children_others(\n+                    tag,\n+                    |args: NodeAppArgs<'_>| -> Result<ContinueTraversal, TransitionError> {\n+                        let NodeAppArgs { node, .. } = args;\n+                        if global.borrow().protected_tags.get(&node.tag)\n+                            == Some(&ProtectorKind::StrongProtector)\n+                        {\n+                            Err(TransitionError::ProtectedDealloc)\n+                        } else {\n+                            Ok(ContinueTraversal::Recurse)\n+                        }\n+                    },\n+                    |args: ErrHandlerArgs<'_, TransitionError>| -> InterpErrorInfo<'tcx> {\n+                        let ErrHandlerArgs { error_kind, faulty_tag } = args;\n+                        TbError {\n+                            faulty_tag,\n+                            access_kind: AccessKind::Write,\n+                            error_kind,\n+                            tag_of_access: access_info,\n+                        }\n+                        .build()\n+                    },\n+                )?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Maps the following propagation procedure to each range:\n+    /// - initialize if needed;\n+    /// - compute new state after transition;\n+    /// - check that there is no protector that would forbid this;\n+    /// - record this specific location as accessed.\n+    pub fn perform_access(\n+        &mut self,\n+        access_kind: AccessKind,\n+        tag: BorTag,\n+        range: AllocRange,\n+        global: &GlobalState,\n+    ) -> InterpResult<'tcx> {\n+        let access_info = &self.nodes.get(self.tag_mapping.get(&tag).unwrap()).unwrap().debug_info;\n+        for (_range, perms) in self.rperms.iter_mut(range.start, range.size) {\n+            TreeVisitor { nodes: &self.nodes, tag_mapping: &self.tag_mapping, perms }\n+                .traverse_parents_this_children_others(\n+                    tag,\n+                    |args: NodeAppArgs<'_>| -> Result<ContinueTraversal, TransitionError> {\n+                        let NodeAppArgs { node, mut perm, rel_pos } = args;\n+\n+                        let old_state =\n+                            perm.or_insert_with(|| LocationState::new(node.default_initial_perm));\n+\n+                        // Optimize the tree traversal.\n+                        // The optimization here consists of observing thanks to the tests\n+                        // `foreign_read_is_noop_after_write` and `all_transitions_idempotent`\n+                        // that if we apply twice in a row the effects of a foreign access\n+                        // we can skip some branches.\n+                        // \"two foreign accesses in a row\" occurs when `perm.latest_foreign_access` is `Some(_)`\n+                        // AND the `rel_pos` of the current access corresponds to a foreign access.\n+                        if rel_pos.is_foreign() {\n+                            let new_access_noop =\n+                                match (old_state.latest_foreign_access, access_kind) {\n+                                    // Previously applied transition makes the new one a guaranteed\n+                                    // noop in the two following cases:\n+                                    // (1) justified by `foreign_read_is_noop_after_write`\n+                                    (Some(AccessKind::Write), AccessKind::Read) => true,\n+                                    // (2) justified by `all_transitions_idempotent`\n+                                    (Some(old), new) if old == new => true,\n+                                    // In all other cases there has been a recent enough\n+                                    // child access that the effects of the new foreign access\n+                                    // need to be applied to this subtree.\n+                                    _ => false,\n+                                };\n+                            if new_access_noop {\n+                                // Abort traversal if the new transition is indeed guaranteed\n+                                // to be noop.\n+                                return Ok(ContinueTraversal::SkipChildren);\n+                            } else {\n+                                // Otherwise propagate this time, and also record the\n+                                // access that just occurred so that we can skip the propagation\n+                                // next time.\n+                                old_state.latest_foreign_access = Some(access_kind);\n+                            }\n+                        } else {\n+                            // A child access occurred, this breaks the streak of \"two foreign\n+                            // accesses in a row\" and we reset this field.\n+                            old_state.latest_foreign_access = None;\n+                        }\n+\n+                        let old_perm = old_state.permission;\n+                        let protected = global.borrow().protected_tags.contains_key(&node.tag);\n+                        let new_perm =\n+                            Permission::perform_access(access_kind, rel_pos, old_perm, protected)\n+                                .ok_or(TransitionError::ChildAccessForbidden(old_perm))?;\n+                        if protected\n+                            // Can't trigger Protector on uninitialized locations\n+                            && old_state.initialized\n+                            && !old_perm.protector_allows_transition(new_perm)\n+                        {\n+                            return Err(TransitionError::ProtectedTransition(old_perm, new_perm));\n+                        }\n+                        old_state.permission = new_perm;\n+                        old_state.initialized |= !rel_pos.is_foreign();\n+                        Ok(ContinueTraversal::Recurse)\n+                    },\n+                    |args: ErrHandlerArgs<'_, TransitionError>| -> InterpErrorInfo<'tcx> {\n+                        let ErrHandlerArgs { error_kind, faulty_tag } = args;\n+                        TbError { faulty_tag, access_kind, error_kind, tag_of_access: access_info }\n+                            .build()\n+                    },\n+                )?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+/// Integration with the BorTag garbage collector\n+impl Tree {\n+    pub fn remove_unreachable_tags(&mut self, live_tags: &FxHashSet<BorTag>) {\n+        assert!(self.keep_only_needed(self.root, live_tags)); // root can't be removed\n+    }\n+\n+    /// Traverses the entire tree looking for useless tags.\n+    /// Returns true iff the tag it was called on is still live or has live children,\n+    /// and removes from the tree all tags that have no live children.\n+    ///\n+    /// NOTE: This leaves in the middle of the tree tags that are unreachable but have\n+    /// reachable children. There is a potential for compacting the tree by reassigning\n+    /// children of dead tags to the nearest live parent, but it must be done with care\n+    /// not to remove UB.\n+    ///\n+    /// Example: Consider the tree `root - parent - child`, with `parent: Frozen` and\n+    /// `child: Reserved`. This tree can exist. If we blindly delete `parent` and reassign\n+    /// `child` to be a direct child of `root` then Writes to `child` are now permitted\n+    /// whereas they were not when `parent` was still there.\n+    fn keep_only_needed(&mut self, idx: UniIndex, live: &FxHashSet<BorTag>) -> bool {\n+        let node = self.nodes.get(idx).unwrap();\n+        // FIXME: this function does a lot of cloning, a 2-pass approach is possibly\n+        // more efficient. It could consist of\n+        // 1. traverse the Tree, collect all useless tags in a Vec\n+        // 2. traverse the Vec, remove all tags previously selected\n+        // Bench it.\n+        let children: SmallVec<_> = node\n+            .children\n+            .clone()\n+            .into_iter()\n+            .filter(|child| self.keep_only_needed(*child, live))\n+            .collect();\n+        let no_children = children.is_empty();\n+        let node = self.nodes.get_mut(idx).unwrap();\n+        node.children = children;\n+        if !live.contains(&node.tag) && no_children {\n+            // All of the children and this node are unreachable, delete this tag\n+            // from the tree (the children have already been deleted by recursive\n+            // calls).\n+            // Due to the API of UniMap we must absolutely call\n+            // `UniValMap::remove` for the key of this tag on *all* maps that used it\n+            // (which are `self.nodes` and every range of `self.rperms`)\n+            // before we can safely apply `UniValMap::forget` to truly remove\n+            // the tag from the mapping.\n+            let tag = node.tag;\n+            self.nodes.remove(idx);\n+            for perms in self.rperms.iter_mut_all() {\n+                perms.remove(idx);\n+            }\n+            self.tag_mapping.remove(&tag);\n+            // The tag has been deleted, inform the caller\n+            false\n+        } else {\n+            // The tag is still live or has live children, it must be kept\n+            true\n+        }\n+    }\n+}\n+\n+impl VisitTags for Tree {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n+        // To ensure that the root never gets removed, we visit it\n+        // (the `root` node of `Tree` is not an `Option<_>`)\n+        visit(self.nodes.get(self.root).unwrap().tag)\n+    }\n+}\n+\n /// Relative position of the access\n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum AccessRelatedness {"}]}