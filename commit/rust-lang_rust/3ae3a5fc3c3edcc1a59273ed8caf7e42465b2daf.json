{"sha": "3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhZTNhNWZjM2MzZWRjYzFhNTkyNzNlZDhjYWY3ZTQyNDY1YjJkYWY=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-09-11T00:16:57Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-09-19T02:20:15Z"}, "message": "Overloaded augmented assignments", "tree": {"sha": "9b94a6376047026d92a7baebe6e90c2818e11e0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b94a6376047026d92a7baebe6e90c2818e11e0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "html_url": "https://github.com/rust-lang/rust/commit/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/comments", "author": null, "committer": null, "parents": [{"sha": "fb5de8ce57a36e504af2dd6626365d94b5f4262d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb5de8ce57a36e504af2dd6626365d94b5f4262d", "html_url": "https://github.com/rust-lang/rust/commit/fb5de8ce57a36e504af2dd6626365d94b5f4262d"}], "stats": {"total": 1064, "additions": 979, "deletions": 85}, "files": [{"sha": "350ade22707caac1cafe384ea649ad6737bc624e", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 528, "deletions": 0, "changes": 528, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -927,6 +927,534 @@ macro_rules! shr_impl_all {\n \n shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n \n+/// The `AddAssign` trait is used to specify the functionality of `+=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `AddAssign`. When `Foo += Foo` happens, it ends up\n+/// calling `add_assign`, and therefore, `main` prints `Adding!`.\n+///\n+/// ```\n+/// #![feature(augmented_assignments)]\n+/// #![feature(op_assign_traits)]\n+///\n+/// use std::ops::AddAssign;\n+///\n+/// #[derive(Copy, Clone)]\n+/// struct Foo;\n+///\n+/// impl AddAssign for Foo {\n+///     fn add_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Adding!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo += Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]\n+#[lang = \"add_assign\"]\n+#[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+pub trait AddAssign<Rhs=Self> {\n+    /// The method for the `+=` operator\n+    fn add_assign(&mut self, Rhs);\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! add_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl AddAssign for $t {\n+            #[inline]\n+            fn add_assign(&mut self, other: $t) { *self += other }\n+        }\n+    )+)\n+}\n+\n+#[cfg(not(stage0))]\n+add_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+\n+/// The `SubAssign` trait is used to specify the functionality of `-=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `SubAssign`. When `Foo -= Foo` happens, it ends up\n+/// calling `sub_assign`, and therefore, `main` prints `Subtracting!`.\n+///\n+/// ```\n+/// #![feature(augmented_assignments)]\n+/// #![feature(op_assign_traits)]\n+///\n+/// use std::ops::SubAssign;\n+///\n+/// #[derive(Copy, Clone)]\n+/// struct Foo;\n+///\n+/// impl SubAssign for Foo {\n+///     fn sub_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Subtracting!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo -= Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]\n+#[lang = \"sub_assign\"]\n+#[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+pub trait SubAssign<Rhs=Self> {\n+    /// The method for the `-=` operator\n+    fn sub_assign(&mut self, Rhs);\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! sub_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl SubAssign for $t {\n+            #[inline]\n+            fn sub_assign(&mut self, other: $t) { *self -= other }\n+        }\n+    )+)\n+}\n+\n+#[cfg(not(stage0))]\n+sub_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+\n+/// The `MulAssign` trait is used to specify the functionality of `*=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `MulAssign`. When `Foo *= Foo` happens, it ends up\n+/// calling `mul_assign`, and therefore, `main` prints `Multiplying!`.\n+///\n+/// ```\n+/// #![feature(augmented_assignments)]\n+/// #![feature(op_assign_traits)]\n+///\n+/// use std::ops::MulAssign;\n+///\n+/// #[derive(Copy, Clone)]\n+/// struct Foo;\n+///\n+/// impl MulAssign for Foo {\n+///     fn mul_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Multiplying!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo *= Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]\n+#[lang = \"mul_assign\"]\n+#[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+pub trait MulAssign<Rhs=Self> {\n+    /// The method for the `*=` operator\n+    fn mul_assign(&mut self, Rhs);\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! mul_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl MulAssign for $t {\n+            #[inline]\n+            fn mul_assign(&mut self, other: $t) { *self *= other }\n+        }\n+    )+)\n+}\n+\n+#[cfg(not(stage0))]\n+mul_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+\n+/// The `DivAssign` trait is used to specify the functionality of `/=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `DivAssign`. When `Foo /= Foo` happens, it ends up\n+/// calling `div_assign`, and therefore, `main` prints `Dividing!`.\n+///\n+/// ```\n+/// #![feature(augmented_assignments)]\n+/// #![feature(op_assign_traits)]\n+///\n+/// use std::ops::DivAssign;\n+///\n+/// #[derive(Copy, Clone)]\n+/// struct Foo;\n+///\n+/// impl DivAssign for Foo {\n+///     fn div_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Dividing!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo /= Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]\n+#[lang = \"div_assign\"]\n+#[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+pub trait DivAssign<Rhs=Self> {\n+    /// The method for the `/=` operator\n+    fn div_assign(&mut self, Rhs);\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! div_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl DivAssign for $t {\n+            #[inline]\n+            fn div_assign(&mut self, other: $t) { *self /= other }\n+        }\n+    )+)\n+}\n+\n+#[cfg(not(stage0))]\n+div_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+\n+/// The `RemAssign` trait is used to specify the functionality of `%=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `RemAssign`. When `Foo %= Foo` happens, it ends up\n+/// calling `rem_assign`, and therefore, `main` prints `Remainder-ing!`.\n+///\n+/// ```\n+/// #![feature(augmented_assignments)]\n+/// #![feature(op_assign_traits)]\n+///\n+/// use std::ops::RemAssign;\n+///\n+/// #[derive(Copy, Clone)]\n+/// struct Foo;\n+///\n+/// impl RemAssign for Foo {\n+///     fn rem_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Remainder-ing!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo %= Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]\n+#[lang = \"rem_assign\"]\n+#[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+pub trait RemAssign<Rhs=Self> {\n+    /// The method for the `%=` operator\n+    fn rem_assign(&mut self, Rhs);\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! rem_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl RemAssign for $t {\n+            #[inline]\n+            fn rem_assign(&mut self, other: $t) { *self %= other }\n+        }\n+    )+)\n+}\n+\n+#[cfg(not(stage0))]\n+rem_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+\n+/// The `BitAndAssign` trait is used to specify the functionality of `&=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `BitAndAssign`. When `Foo &= Foo` happens, it ends up\n+/// calling `bitand_assign`, and therefore, `main` prints `Bitwise And-ing!`.\n+///\n+/// ```\n+/// #![feature(augmented_assignments)]\n+/// #![feature(op_assign_traits)]\n+///\n+/// use std::ops::BitAndAssign;\n+///\n+/// #[derive(Copy, Clone)]\n+/// struct Foo;\n+///\n+/// impl BitAndAssign for Foo {\n+///     fn bitand_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Bitwise And-ing!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo &= Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]\n+#[lang = \"bitand_assign\"]\n+#[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+pub trait BitAndAssign<Rhs=Self> {\n+    /// The method for the `&` operator\n+    fn bitand_assign(&mut self, Rhs);\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! bitand_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl BitAndAssign for $t {\n+            #[inline]\n+            fn bitand_assign(&mut self, other: $t) { *self &= other }\n+        }\n+    )+)\n+}\n+\n+#[cfg(not(stage0))]\n+bitand_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+\n+/// The `BitOrAssign` trait is used to specify the functionality of `|=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `BitOrAssign`. When `Foo |= Foo` happens, it ends up\n+/// calling `bitor_assign`, and therefore, `main` prints `Bitwise Or-ing!`.\n+///\n+/// ```\n+/// #![feature(augmented_assignments)]\n+/// #![feature(op_assign_traits)]\n+///\n+/// use std::ops::BitOrAssign;\n+///\n+/// #[derive(Copy, Clone)]\n+/// struct Foo;\n+///\n+/// impl BitOrAssign for Foo {\n+///     fn bitor_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Bitwise Or-ing!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo |= Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]\n+#[lang = \"bitor_assign\"]\n+#[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+pub trait BitOrAssign<Rhs=Self> {\n+    /// The method for the `|=` operator\n+    fn bitor_assign(&mut self, Rhs);\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! bitor_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl BitOrAssign for $t {\n+            #[inline]\n+            fn bitor_assign(&mut self, other: $t) { *self |= other }\n+        }\n+    )+)\n+}\n+\n+#[cfg(not(stage0))]\n+bitor_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+\n+/// The `BitXorAssign` trait is used to specify the functionality of `^=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `BitXorAssign`. When `Foo ^= Foo` happens, it ends up\n+/// calling `bitxor_assign`, and therefore, `main` prints `Bitwise Xor-ing!`.\n+///\n+/// ```\n+/// #![feature(augmented_assignments)]\n+/// #![feature(op_assign_traits)]\n+///\n+/// use std::ops::BitXorAssign;\n+///\n+/// #[derive(Copy, Clone)]\n+/// struct Foo;\n+///\n+/// impl BitXorAssign for Foo {\n+///     fn bitxor_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Bitwise Xor-ing!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo ^= Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]\n+#[lang = \"bitxor_assign\"]\n+#[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+pub trait BitXorAssign<Rhs=Self> {\n+    /// The method for the `^=` operator\n+    fn bitxor_assign(&mut self, Rhs);\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! bitxor_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl BitXorAssign for $t {\n+            #[inline]\n+            fn bitxor_assign(&mut self, other: $t) { *self ^= other }\n+        }\n+    )+)\n+}\n+\n+#[cfg(not(stage0))]\n+bitxor_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+\n+/// The `ShlAssign` trait is used to specify the functionality of `<<=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `ShlAssign`. When `Foo <<= Foo` happens, it ends up\n+/// calling `shl_assign`, and therefore, `main` prints `Shifting left!`.\n+///\n+/// ```\n+/// #![feature(augmented_assignments)]\n+/// #![feature(op_assign_traits)]\n+///\n+/// use std::ops::ShlAssign;\n+///\n+/// #[derive(Copy, Clone)]\n+/// struct Foo;\n+///\n+/// impl ShlAssign<Foo> for Foo {\n+///     fn shl_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Shifting left!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo <<= Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]\n+#[lang = \"shl_assign\"]\n+#[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+pub trait ShlAssign<Rhs> {\n+    /// The method for the `<<=` operator\n+    fn shl_assign(&mut self, Rhs);\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! shl_assign_impl {\n+    ($t:ty, $f:ty) => (\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl ShlAssign<$f> for $t {\n+            #[inline]\n+            fn shl_assign(&mut self, other: $f) {\n+                *self <<= other\n+            }\n+        }\n+    )\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! shl_assign_impl_all {\n+    ($($t:ty)*) => ($(\n+        shl_assign_impl! { $t, u8 }\n+        shl_assign_impl! { $t, u16 }\n+        shl_assign_impl! { $t, u32 }\n+        shl_assign_impl! { $t, u64 }\n+        shl_assign_impl! { $t, usize }\n+\n+        shl_assign_impl! { $t, i8 }\n+        shl_assign_impl! { $t, i16 }\n+        shl_assign_impl! { $t, i32 }\n+        shl_assign_impl! { $t, i64 }\n+        shl_assign_impl! { $t, isize }\n+    )*)\n+}\n+\n+#[cfg(not(stage0))]\n+shl_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+\n+/// The `ShrAssign` trait is used to specify the functionality of `>>=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `ShrAssign`. When `Foo >>= Foo` happens, it ends up\n+/// calling `shr_assign`, and therefore, `main` prints `Shifting right!`.\n+///\n+/// ```\n+/// #![feature(augmented_assignments)]\n+/// #![feature(op_assign_traits)]\n+///\n+/// use std::ops::ShrAssign;\n+///\n+/// #[derive(Copy, Clone)]\n+/// struct Foo;\n+///\n+/// impl ShrAssign<Foo> for Foo {\n+///     fn shr_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Shifting right!\");\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo >>= Foo;\n+/// }\n+/// ```\n+#[cfg(not(stage0))]\n+#[lang = \"shr_assign\"]\n+#[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+pub trait ShrAssign<Rhs=Self> {\n+    /// The method for the `>>=` operator\n+    fn shr_assign(&mut self, Rhs);\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! shr_assign_impl {\n+    ($t:ty, $f:ty) => (\n+        #[unstable(feature = \"op_assign_traits\", reason = \"recently added\", issue = \"28235\")]\n+        impl ShrAssign<$f> for $t {\n+            #[inline]\n+            fn shr_assign(&mut self, other: $f) {\n+                *self >>= other\n+            }\n+        }\n+    )\n+}\n+\n+#[cfg(not(stage0))]\n+macro_rules! shr_assign_impl_all {\n+    ($($t:ty)*) => ($(\n+        shr_assign_impl! { $t, u8 }\n+        shr_assign_impl! { $t, u16 }\n+        shr_assign_impl! { $t, u32 }\n+        shr_assign_impl! { $t, u64 }\n+        shr_assign_impl! { $t, usize }\n+\n+        shr_assign_impl! { $t, i8 }\n+        shr_assign_impl! { $t, i16 }\n+        shr_assign_impl! { $t, i32 }\n+        shr_assign_impl! { $t, i64 }\n+        shr_assign_impl! { $t, isize }\n+    )*)\n+}\n+\n+#[cfg(not(stage0))]\n+shr_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+\n /// The `Index` trait is used to specify the functionality of indexing operations\n /// like `arr[idx]` when used in an immutable context.\n ///"}, {"sha": "113dc6f577a107613e7cd0cdd7b9941ff7d7af7a", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -525,11 +525,17 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 self.consume_expr(&**base);\n             }\n \n-            hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n-                // This will have to change if/when we support\n-                // overloaded operators for `+=` and so forth.\n-                self.mutate_expr(expr, &**lhs, WriteAndRead);\n-                self.consume_expr(&**rhs);\n+            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+                let pass_args = if ::rustc_front::util::is_by_value_binop(op.node) {\n+                    PassArgs::ByValue\n+                } else {\n+                    PassArgs::ByRef\n+                };\n+\n+                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs], pass_args) {\n+                    self.mutate_expr(expr, &**lhs, WriteAndRead);\n+                    self.consume_expr(&**rhs);\n+                }\n             }\n \n             hir::ExprRepeat(ref base, ref count) => {"}, {"sha": "b7572d43fbe25072040d92041a3e547213a9aa99", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -286,6 +286,16 @@ lets_do_this! {\n     BitOrTraitLangItem,              \"bitor\",                   bitor_trait;\n     ShlTraitLangItem,                \"shl\",                     shl_trait;\n     ShrTraitLangItem,                \"shr\",                     shr_trait;\n+    AddAssignTraitLangItem,          \"add_assign\",              add_assign_trait;\n+    SubAssignTraitLangItem,          \"sub_assign\",              sub_assign_trait;\n+    MulAssignTraitLangItem,          \"mul_assign\",              mul_assign_trait;\n+    DivAssignTraitLangItem,          \"div_assign\",              div_assign_trait;\n+    RemAssignTraitLangItem,          \"rem_assign\",              rem_assign_trait;\n+    BitXorAssignTraitLangItem,       \"bitxor_assign\",           bitxor_assign_trait;\n+    BitAndAssignTraitLangItem,       \"bitand_assign\",           bitand_assign_trait;\n+    BitOrAssignTraitLangItem,        \"bitor_assign\",            bitor_assign_trait;\n+    ShlAssignTraitLangItem,          \"shl_assign\",              shl_assign_trait;\n+    ShrAssignTraitLangItem,          \"shr_assign\",              shr_assign_trait;\n     IndexTraitLangItem,              \"index\",                   index_trait;\n     IndexMutTraitLangItem,           \"index_mut\",               index_mut_trait;\n     RangeStructLangItem,             \"range\",                   range_struct;"}, {"sha": "83ff766f5da67f2cf8989aea1e0abfe654a1c6d4", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -1018,7 +1018,20 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         hir::ExprAssignOp(op, ref dst, ref src) => {\n-            trans_assign_op(bcx, expr, op, &**dst, &**src)\n+            let has_method_map = bcx.tcx()\n+                                    .tables\n+                                    .borrow()\n+                                    .method_map\n+                                    .contains_key(&MethodCall::expr(expr.id));\n+\n+            if has_method_map {\n+                let dst = unpack_datum!(bcx, trans(bcx, &**dst));\n+                let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n+                trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), dst,\n+                                    Some((src_datum, src.id)), None, false).bcx\n+            } else {\n+                trans_assign_op(bcx, expr, op, &**dst, &**src)\n+            }\n         }\n         hir::ExprInlineAsm(ref a) => {\n             asm::trans_inline_asm(bcx, a)\n@@ -1207,8 +1220,11 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // Trait casts used to come this way, now they should be coercions.\n             bcx.tcx().sess.span_bug(expr.span, \"DPS expr_cast (residual trait cast?)\")\n         }\n-        hir::ExprAssignOp(op, ref dst, ref src) => {\n-            trans_assign_op(bcx, expr, op, &**dst, &**src)\n+        hir::ExprAssignOp(op, _, _) => {\n+            bcx.tcx().sess.span_bug(\n+                expr.span,\n+                &format!(\"augmented assignment `{}=` should always be a rvalue_stmt\",\n+                         rustc_front::util::binop_to_string(op.node)))\n         }\n         _ => {\n             bcx.tcx().sess.span_bug("}, {"sha": "35bbf10d06cad192205052c44b36c054c11cfb00", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 68, "deletions": 47, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -17,10 +17,8 @@ use super::{\n     demand,\n     method,\n     FnCtxt,\n-    structurally_resolved_type,\n };\n use middle::def_id::DefId;\n-use middle::traits;\n use middle::ty::{Ty, HasTypeFlags, PreferMutLvalue};\n use syntax::ast;\n use syntax::parse::token;\n@@ -34,34 +32,24 @@ pub fn check_binop_assign<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                    lhs_expr: &'tcx hir::Expr,\n                                    rhs_expr: &'tcx hir::Expr)\n {\n-    let tcx = fcx.ccx.tcx;\n-\n     check_expr_with_lvalue_pref(fcx, lhs_expr, PreferMutLvalue);\n-    check_expr(fcx, rhs_expr);\n \n-    let lhs_ty = structurally_resolved_type(fcx, lhs_expr.span, fcx.expr_ty(lhs_expr));\n-    let rhs_ty = structurally_resolved_type(fcx, rhs_expr.span, fcx.expr_ty(rhs_expr));\n+    let lhs_ty = fcx.resolve_type_vars_if_possible(fcx.expr_ty(lhs_expr));\n+    let (rhs_ty, return_ty) =\n+        check_overloaded_binop(fcx, expr, lhs_expr, lhs_ty, rhs_expr, op, true);\n+    let rhs_ty = fcx.resolve_type_vars_if_possible(rhs_ty);\n \n-    if is_builtin_binop(lhs_ty, rhs_ty, op) {\n+    if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() && is_builtin_binop(lhs_ty, rhs_ty, op) {\n         enforce_builtin_binop_types(fcx, lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n         fcx.write_nil(expr.id);\n     } else {\n-        // error types are considered \"builtin\"\n-        assert!(!lhs_ty.references_error() || !rhs_ty.references_error());\n-        span_err!(tcx.sess, lhs_expr.span, E0368,\n-                  \"binary assignment operation `{}=` cannot be applied to types `{}` and `{}`\",\n-                  hir_util::binop_to_string(op.node),\n-                  lhs_ty,\n-                  rhs_ty);\n-        fcx.write_error(expr.id);\n+        fcx.write_ty(expr.id, return_ty);\n     }\n \n     let tcx = fcx.tcx();\n     if !tcx.expr_is_lval(lhs_expr) {\n         span_err!(tcx.sess, lhs_expr.span, E0067, \"invalid left-hand side expression\");\n     }\n-\n-    fcx.require_expr_have_sized_type(lhs_expr, traits::AssignmentLhsSized);\n }\n \n /// Check a potentially overloaded binary operator.\n@@ -95,7 +83,7 @@ pub fn check_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // overloaded. This is the way to be most flexible w/r/t\n             // types that get inferred.\n             let (rhs_ty, return_ty) =\n-                check_overloaded_binop(fcx, expr, lhs_expr, lhs_ty, rhs_expr, op);\n+                check_overloaded_binop(fcx, expr, lhs_expr, lhs_ty, rhs_expr, op, false);\n \n             // Supply type inference hints if relevant. Probably these\n             // hints should be enforced during select as part of the\n@@ -167,14 +155,16 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                     lhs_expr: &'tcx hir::Expr,\n                                     lhs_ty: Ty<'tcx>,\n                                     rhs_expr: &'tcx hir::Expr,\n-                                    op: hir::BinOp)\n+                                    op: hir::BinOp,\n+                                    assign: bool)\n                                     -> (Ty<'tcx>, Ty<'tcx>)\n {\n-    debug!(\"check_overloaded_binop(expr.id={}, lhs_ty={:?})\",\n+    debug!(\"check_overloaded_binop(expr.id={}, lhs_ty={:?}, assign={})\",\n            expr.id,\n-           lhs_ty);\n+           lhs_ty,\n+           assign);\n \n-    let (name, trait_def_id) = name_and_trait_def_id(fcx, op);\n+    let (name, trait_def_id) = name_and_trait_def_id(fcx, op, assign);\n \n     // NB: As we have not yet type-checked the RHS, we don't have the\n     // type at hand. Make a variable to represent it. The whole reason\n@@ -191,10 +181,17 @@ fn check_overloaded_binop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Err(()) => {\n             // error types are considered \"builtin\"\n             if !lhs_ty.references_error() {\n-                span_err!(fcx.tcx().sess, lhs_expr.span, E0369,\n-                          \"binary operation `{}` cannot be applied to type `{}`\",\n-                          hir_util::binop_to_string(op.node),\n-                          lhs_ty);\n+                if assign {\n+                    span_err!(fcx.tcx().sess, lhs_expr.span, E0368,\n+                              \"binary assignment operation `{}=` cannot be applied to type `{}`\",\n+                              hir_util::binop_to_string(op.node),\n+                              lhs_ty);\n+                } else {\n+                    span_err!(fcx.tcx().sess, lhs_expr.span, E0369,\n+                              \"binary operation `{}` cannot be applied to type `{}`\",\n+                              hir_util::binop_to_string(op.node),\n+                              lhs_ty);\n+                }\n             }\n             fcx.tcx().types.err\n         }\n@@ -231,27 +228,51 @@ pub fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-fn name_and_trait_def_id(fcx: &FnCtxt, op: hir::BinOp) -> (&'static str, Option<DefId>) {\n+fn name_and_trait_def_id(fcx: &FnCtxt,\n+                         op: hir::BinOp,\n+                         assign: bool)\n+                         -> (&'static str, Option<DefId>) {\n     let lang = &fcx.tcx().lang_items;\n-    match op.node {\n-        hir::BiAdd => (\"add\", lang.add_trait()),\n-        hir::BiSub => (\"sub\", lang.sub_trait()),\n-        hir::BiMul => (\"mul\", lang.mul_trait()),\n-        hir::BiDiv => (\"div\", lang.div_trait()),\n-        hir::BiRem => (\"rem\", lang.rem_trait()),\n-        hir::BiBitXor => (\"bitxor\", lang.bitxor_trait()),\n-        hir::BiBitAnd => (\"bitand\", lang.bitand_trait()),\n-        hir::BiBitOr => (\"bitor\", lang.bitor_trait()),\n-        hir::BiShl => (\"shl\", lang.shl_trait()),\n-        hir::BiShr => (\"shr\", lang.shr_trait()),\n-        hir::BiLt => (\"lt\", lang.ord_trait()),\n-        hir::BiLe => (\"le\", lang.ord_trait()),\n-        hir::BiGe => (\"ge\", lang.ord_trait()),\n-        hir::BiGt => (\"gt\", lang.ord_trait()),\n-        hir::BiEq => (\"eq\", lang.eq_trait()),\n-        hir::BiNe => (\"ne\", lang.eq_trait()),\n-        hir::BiAnd | hir::BiOr => {\n-            fcx.tcx().sess.span_bug(op.span, \"&& and || are not overloadable\")\n+\n+    if assign {\n+        match op.node {\n+            hir::BiAdd => (\"add_assign\", lang.add_assign_trait()),\n+            hir::BiSub => (\"sub_assign\", lang.sub_assign_trait()),\n+            hir::BiMul => (\"mul_assign\", lang.mul_assign_trait()),\n+            hir::BiDiv => (\"div_assign\", lang.div_assign_trait()),\n+            hir::BiRem => (\"rem_assign\", lang.rem_assign_trait()),\n+            hir::BiBitXor => (\"bitxor_assign\", lang.bitxor_assign_trait()),\n+            hir::BiBitAnd => (\"bitand_assign\", lang.bitand_assign_trait()),\n+            hir::BiBitOr => (\"bitor_assign\", lang.bitor_assign_trait()),\n+            hir::BiShl => (\"shl_assign\", lang.shl_assign_trait()),\n+            hir::BiShr => (\"shr_assign\", lang.shr_assign_trait()),\n+            hir::BiLt | hir::BiLe | hir::BiGe | hir::BiGt | hir::BiEq | hir::BiNe | hir::BiAnd |\n+            hir::BiOr => {\n+                fcx.tcx().sess.span_bug(op.span, &format!(\"impossible assignment operation: {}=\",\n+                                        hir_util::binop_to_string(op.node)))\n+            }\n+        }\n+    } else {\n+        match op.node {\n+            hir::BiAdd => (\"add\", lang.add_trait()),\n+            hir::BiSub => (\"sub\", lang.sub_trait()),\n+            hir::BiMul => (\"mul\", lang.mul_trait()),\n+            hir::BiDiv => (\"div\", lang.div_trait()),\n+            hir::BiRem => (\"rem\", lang.rem_trait()),\n+            hir::BiBitXor => (\"bitxor\", lang.bitxor_trait()),\n+            hir::BiBitAnd => (\"bitand\", lang.bitand_trait()),\n+            hir::BiBitOr => (\"bitor\", lang.bitor_trait()),\n+            hir::BiShl => (\"shl\", lang.shl_trait()),\n+            hir::BiShr => (\"shr\", lang.shr_trait()),\n+            hir::BiLt => (\"lt\", lang.ord_trait()),\n+            hir::BiLe => (\"le\", lang.ord_trait()),\n+            hir::BiGe => (\"ge\", lang.ord_trait()),\n+            hir::BiGt => (\"gt\", lang.ord_trait()),\n+            hir::BiEq => (\"eq\", lang.eq_trait()),\n+            hir::BiNe => (\"ne\", lang.eq_trait()),\n+            hir::BiAnd | hir::BiOr => {\n+                fcx.tcx().sess.span_bug(op.span, \"&& and || are not overloadable\")\n+            }\n         }\n     }\n }"}, {"sha": "b4a99dcb576cac0f3faece3d159b83b6d11ba94c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -695,7 +695,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n         hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n             if has_method_map {\n                 constrain_call(rcx, expr, Some(&**lhs),\n-                               Some(&**rhs).into_iter(), true);\n+                               Some(&**rhs).into_iter(), false);\n             }\n \n             visit::walk_expr(rcx, expr);"}, {"sha": "747d5ca6b723a6f33f2e0d38363229229d5c62b0", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -17,7 +17,7 @@ use astconv::AstConv;\n use check::FnCtxt;\n use middle::def_id::DefId;\n use middle::pat_util;\n-use middle::ty::{self, Ty, MethodCall, MethodCallee};\n+use middle::ty::{self, Ty, MethodCall, MethodCallee, HasTypeFlags};\n use middle::ty::adjustment;\n use middle::ty::fold::{TypeFolder,TypeFoldable};\n use middle::infer;\n@@ -91,24 +91,51 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     // we observe that something like `a+b` is (known to be)\n     // operating on scalars, we clear the overload.\n     fn fix_scalar_binary_expr(&mut self, e: &hir::Expr) {\n-        if let hir::ExprBinary(ref op, ref lhs, ref rhs) = e.node {\n-            let lhs_ty = self.fcx.node_ty(lhs.id);\n-            let lhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&lhs_ty);\n-\n-            let rhs_ty = self.fcx.node_ty(rhs.id);\n-            let rhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n-\n-            if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n-                self.fcx.inh.tables.borrow_mut().method_map.remove(&MethodCall::expr(e.id));\n-\n-                // weird but true: the by-ref binops put an\n-                // adjustment on the lhs but not the rhs; the\n-                // adjustment for rhs is kind of baked into the\n-                // system.\n-                if !hir_util::is_by_value_binop(op.node) {\n-                    self.fcx.inh.tables.borrow_mut().adjustments.remove(&lhs.id);\n+        match e.node {\n+            hir::ExprBinary(ref op, ref lhs, ref rhs) |\n+                hir::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n+                    let lhs_ty = self.fcx.node_ty(lhs.id);\n+                    let lhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&lhs_ty);\n+\n+                    let rhs_ty = self.fcx.node_ty(rhs.id);\n+                    let rhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n+\n+                    if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n+                        self.fcx.inh.tables.borrow_mut().method_map.remove(&MethodCall::expr(e.id));\n+\n+                        // weird but true: the by-ref binops put an\n+                        // adjustment on the lhs but not the rhs; the\n+                        // adjustment for rhs is kind of baked into the\n+                        // system.\n+                        match e.node {\n+                            hir::ExprBinary(..) => {\n+                                if !hir_util::is_by_value_binop(op.node) {\n+                                    self.fcx.inh.tables.borrow_mut().adjustments.remove(&lhs.id);\n+                                }\n+                            },\n+                            hir::ExprAssignOp(..) => {\n+                                self.fcx.inh.tables.borrow_mut().adjustments.remove(&lhs.id);\n+                            },\n+                            _ => {},\n+                        }\n+                    } else {\n+                        let tcx = self.tcx();\n+\n+                        if let hir::ExprAssignOp(..) = e.node {\n+                            if !tcx.sess.features.borrow().augmented_assignments &&\n+                                !self.fcx.expr_ty(e).references_error() {\n+                                tcx.sess.span_err(\n+                                    e.span,\n+                                    \"overloaded augmented assignments are not stable\");\n+                                fileline_help!(\n+                                    tcx.sess, e.span,\n+                                    \"add #![feature(augmented_assignments)] to the crate features \\\n+                                     to enable\");\n+                            }\n+                        }\n+                    }\n                 }\n-            }\n+            _ => {},\n         }\n     }\n }"}, {"sha": "54724f61f86c745dba0e5dc28c5528e52fddab46", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -2862,14 +2862,27 @@ impl <T: Foo> Drop for MyStructWrapper<T> {\n \n E0368: r##\"\n This error indicates that a binary assignment operator like `+=` or `^=` was\n-applied to the wrong types. For example:\n+applied to a type that doesn't support it. For example:\n \n ```\n-let mut x: u16 = 5;\n-x ^= true; // error, `^=` cannot be applied to types `u16` and `bool`\n-x += ();   // error, `+=` cannot be applied to types `u16` and `()`\n+let mut x = 12f32; // error: binary operation `<<` cannot be applied to\n+               //        type `f32`\n+\n+x <<= 2;\n+```\n+\n+To fix this error, please check that this type implements this binary\n+operation. Example:\n+\n+```\n+let x = 12u32; // the `u32` type does implement the `ShlAssign` trait\n+\n+x <<= 2; // ok!\n ```\n \n+It is also possible to overload most operators for your own type by\n+implementing the `[OP]Assign` traits from `std::ops`.\n+\n Another problem you might be facing is this: suppose you've overloaded the `+`\n operator for some type `Foo` by implementing the `std::ops::Add` trait for\n `Foo`, but you find that using `+=` does not work, as in this example:\n@@ -2889,15 +2902,12 @@ impl Add for Foo {\n \n fn main() {\n     let mut x: Foo = Foo(5);\n-    x += Foo(7); // error, `+= cannot be applied to types `Foo` and `Foo`\n+    x += Foo(7); // error, `+= cannot be applied to the type `Foo`\n }\n ```\n \n-This is because the binary assignment operators currently do not work off of\n-traits, so it is not possible to overload them. See [RFC 953] for a proposal\n-to change this.\n-\n-[RFC 953]: https://github.com/rust-lang/rfcs/pull/953\n+This is because `AddAssign` is not automatically implemented, so you need to\n+manually implement it for your type.\n \"##,\n \n E0369: r##\""}, {"sha": "1e9b244c57cc6e424a2bbe14b50b43e7b61a522b", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -194,6 +194,9 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n \n     // allow empty structs/enum variants with braces\n     (\"braced_empty_structs\", \"1.5.0\", None, Active),\n+\n+    // allow overloading augmented assignment operations like `a += b`\n+    (\"augmented_assignments\", \"1.5.0\", None, Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -457,6 +460,7 @@ pub struct Features {\n     pub default_type_parameter_fallback: bool,\n     pub type_macros: bool,\n     pub cfg_target_feature: bool,\n+    pub augmented_assignments: bool,\n }\n \n impl Features {\n@@ -485,6 +489,7 @@ impl Features {\n             default_type_parameter_fallback: false,\n             type_macros: false,\n             cfg_target_feature: false,\n+            augmented_assignments: false,\n         }\n     }\n }\n@@ -1053,6 +1058,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n         default_type_parameter_fallback: cx.has_feature(\"default_type_parameter_fallback\"),\n         type_macros: cx.has_feature(\"type_macros\"),\n         cfg_target_feature: cx.has_feature(\"cfg_target_feature\"),\n+        augmented_assignments: cx.has_feature(\"augmented_assignments\"),\n     }\n }\n "}, {"sha": "9577e1ff0c7d699fa330e5f673486297c9a8dd32", "filename": "src/test/auxiliary/augmented_assignments.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Ftest%2Fauxiliary%2Faugmented_assignments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Ftest%2Fauxiliary%2Faugmented_assignments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Faugmented_assignments.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(augmented_assignments)]\n+#![feature(op_assign_traits)]\n+\n+use std::ops::AddAssign;\n+\n+pub struct Int(i32);\n+\n+impl AddAssign<i32> for Int {\n+    fn add_assign(&mut self, _: i32) {\n+        unimplemented!();\n+    }\n+}"}, {"sha": "5b24c6bd79f96e75a4666054d35232886241a4a3", "filename": "src/test/compile-fail/assignment-operator-unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Ftest%2Fcompile-fail%2Fassignment-operator-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Ftest%2Fcompile-fail%2Fassignment-operator-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassignment-operator-unimplemented.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -13,5 +13,5 @@ struct Foo;\n fn main() {\n   let mut a = Foo;\n   let ref b = Foo;\n-  a += *b; //~ Error: binary assignment operation `+=` cannot be applied to types `Foo` and `Foo`\n+  a += *b; //~ Error: binary assignment operation `+=` cannot be applied to type `Foo`\n }"}, {"sha": "0aca9a5c7ee04fc1793e95122650c6a838ed88f6", "filename": "src/test/compile-fail/augmented-assignments-feature-gate-cross.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Ftest%2Fcompile-fail%2Faugmented-assignments-feature-gate-cross.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Ftest%2Fcompile-fail%2Faugmented-assignments-feature-gate-cross.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Faugmented-assignments-feature-gate-cross.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:augmented_assignments.rs\n+\n+// Test that the feature gate is needed when using augmented assignments that were overloaded in\n+// another crate\n+\n+extern crate augmented_assignments;\n+\n+use augmented_assignments::Int;\n+\n+fn main() {\n+    let mut x = Int(0);\n+    x += 1;\n+    //~^ error: overloaded augmented assignments are not stable\n+    // | help: add #![feature(augmented_assignments)] to the crate features to enable\n+}"}, {"sha": "66c3014c7a97020c6319a5117580deaa6532eb39", "filename": "src/test/compile-fail/augmented-assignments-feature-gate.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Ftest%2Fcompile-fail%2Faugmented-assignments-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Ftest%2Fcompile-fail%2Faugmented-assignments-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Faugmented-assignments-feature-gate.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::AddAssign;\n+\n+struct Int(i32);\n+\n+impl AddAssign<i32> for Int {\n+    fn add_assign(&mut self, _: i32) {\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {\n+    let mut x = Int(0);\n+    x += 1;\n+    //~^ error: overloaded augmented assignments are not stable\n+    // | help: add #![feature(augmented_assignments)] to the crate features to enable\n+}"}, {"sha": "ee64171fd8c1ebb0f9c2b8aa139c37582ace04d0", "filename": "src/test/compile-fail/augmented-assignments.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Ftest%2Fcompile-fail%2Faugmented-assignments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Ftest%2Fcompile-fail%2Faugmented-assignments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Faugmented-assignments.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(augmented_assignments)]\n+\n+use std::ops::AddAssign;\n+\n+struct Int(i32);\n+\n+impl AddAssign for Int {\n+    fn add_assign(&mut self, _: Int) {\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {\n+    let mut x = Int(1);\n+    x   //~ error: use of moved value: `x`\n+    +=\n+    x;  //~ note: `x` moved here because it has type `Int`, which is non-copyable\n+\n+    let y = Int(2);\n+    y   //~ error: cannot borrow immutable local variable `y` as mutable\n+    +=\n+    Int(1);\n+}"}, {"sha": "eb4c1dbb0b7b7cf8aa1a8221b990b31b4fc8817e", "filename": "src/test/run-pass/augmented-assignments.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Ftest%2Frun-pass%2Faugmented-assignments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf/src%2Ftest%2Frun-pass%2Faugmented-assignments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Faugmented-assignments.rs?ref=3ae3a5fc3c3edcc1a59273ed8caf7e42465b2daf", "patch": "@@ -0,0 +1,164 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(augmented_assignments)]\n+#![feature(op_assign_traits)]\n+\n+use std::mem;\n+use std::ops::{\n+    AddAssign, BitAndAssign, BitOrAssign, BitXorAssign, DivAssign, Index, MulAssign, RemAssign,\n+    ShlAssign, ShrAssign, SubAssign,\n+};\n+\n+#[derive(Debug, PartialEq)]\n+struct Int(i32);\n+\n+struct Slice([i32]);\n+\n+impl Slice {\n+    fn new(slice: &mut [i32]) -> &mut Slice {\n+        unsafe {\n+            mem::transmute(slice)\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut x = Int(1);\n+\n+    x += Int(2);\n+    assert_eq!(x, Int(0b11));\n+\n+    x &= Int(0b01);\n+    assert_eq!(x, Int(0b01));\n+\n+    x |= Int(0b10);\n+    assert_eq!(x, Int(0b11));\n+\n+    x ^= Int(0b01);\n+    assert_eq!(x, Int(0b10));\n+\n+    x /= Int(2);\n+    assert_eq!(x, Int(1));\n+\n+    x *= Int(3);\n+    assert_eq!(x, Int(3));\n+\n+    x %= Int(2);\n+    assert_eq!(x, Int(1));\n+\n+    // overloaded RHS\n+    x <<= 1u8;\n+    assert_eq!(x, Int(2));\n+\n+    x <<= 1u16;\n+    assert_eq!(x, Int(4));\n+\n+    x >>= 1u8;\n+    assert_eq!(x, Int(2));\n+\n+    x >>= 1u16;\n+    assert_eq!(x, Int(1));\n+\n+    x -= Int(1);\n+    assert_eq!(x, Int(0));\n+\n+    // indexed LHS\n+    let mut v = vec![Int(1), Int(2)];\n+    v[0] += Int(2);\n+    assert_eq!(v[0], Int(3));\n+\n+    // unsized RHS\n+    let mut array = [0, 1, 2];\n+    *Slice::new(&mut array) += 1;\n+    assert_eq!(array[0], 1);\n+    assert_eq!(array[1], 2);\n+    assert_eq!(array[2], 3);\n+}\n+\n+impl AddAssign for Int {\n+    fn add_assign(&mut self, rhs: Int) {\n+        self.0 += rhs.0;\n+    }\n+}\n+\n+impl BitAndAssign for Int {\n+    fn bitand_assign(&mut self, rhs: Int) {\n+        self.0 &= rhs.0;\n+    }\n+}\n+\n+impl BitOrAssign for Int {\n+    fn bitor_assign(&mut self, rhs: Int) {\n+        self.0 |= rhs.0;\n+    }\n+}\n+\n+impl BitXorAssign for Int {\n+    fn bitxor_assign(&mut self, rhs: Int) {\n+        self.0 ^= rhs.0;\n+    }\n+}\n+\n+impl DivAssign for Int {\n+    fn div_assign(&mut self, rhs: Int) {\n+        self.0 /= rhs.0;\n+    }\n+}\n+\n+impl MulAssign for Int {\n+    fn mul_assign(&mut self, rhs: Int) {\n+        self.0 *= rhs.0;\n+    }\n+}\n+\n+impl RemAssign for Int {\n+    fn rem_assign(&mut self, rhs: Int) {\n+        self.0 %= rhs.0;\n+    }\n+}\n+\n+impl ShlAssign<u8> for Int {\n+    fn shl_assign(&mut self, rhs: u8) {\n+        self.0 <<= rhs;\n+    }\n+}\n+\n+impl ShlAssign<u16> for Int {\n+    fn shl_assign(&mut self, rhs: u16) {\n+        self.0 <<= rhs;\n+    }\n+}\n+\n+impl ShrAssign<u8> for Int {\n+    fn shr_assign(&mut self, rhs: u8) {\n+        self.0 >>= rhs;\n+    }\n+}\n+\n+impl ShrAssign<u16> for Int {\n+    fn shr_assign(&mut self, rhs: u16) {\n+        self.0 >>= rhs;\n+    }\n+}\n+\n+impl SubAssign for Int {\n+    fn sub_assign(&mut self, rhs: Int) {\n+        self.0 -= rhs.0;\n+    }\n+}\n+\n+impl AddAssign<i32> for Slice {\n+    fn add_assign(&mut self, rhs: i32) {\n+        for lhs in &mut self.0 {\n+            *lhs += rhs;\n+        }\n+    }\n+}"}]}