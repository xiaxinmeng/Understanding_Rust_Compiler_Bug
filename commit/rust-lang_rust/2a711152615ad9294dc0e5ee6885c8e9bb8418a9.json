{"sha": "2a711152615ad9294dc0e5ee6885c8e9bb8418a9", "node_id": "C_kwDOAAsO6NoAKDJhNzExMTUyNjE1YWQ5Mjk0ZGMwZTVlZTY4ODVjOGU5YmI4NDE4YTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-16T03:06:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-16T03:06:46Z"}, "message": "Auto merge of #105888 - skyzh:skyzh/suggest-lifetime-closure, r=compiler-errors\n\nsuggest lifetime for closure parameter type when mismatch\n\nThis is a draft PR, will add test cases later and be ready for review.\n\nThis PR fixes https://github.com/rust-lang/rust/issues/105675 by adding a diagnostics suggestion. Also a partial fix to https://github.com/rust-lang/rust/issues/105528.\n\nThe following code will have a compile error now:\n\n```\nfn const_if_unit(input: bool) -> impl for<'a> FnOnce(&'a ()) -> usize {\n    let x = |_| 1;\n    x\n}\n```\n\nBefore this PR:\n\n```\nerror[E0308]: mismatched types\n --> src/lib.rs:3:5\n  |\n3 |     x\n  |     ^ one type is more general than the other\n  |\n  = note: expected trait `for<'a> FnOnce<(&'a (),)>`\n             found trait `FnOnce<(&(),)>`\nnote: this closure does not fulfill the lifetime requirements\n --> src/lib.rs:2:13\n  |\n2 |     let x = |_| 1;\n  |             ^^^\n\nerror: implementation of `FnOnce` is not general enough\n --> src/lib.rs:3:5\n  |\n3 |     x\n  |     ^ implementation of `FnOnce` is not general enough\n  |\n  = note: closure with signature `fn(&'2 ()) -> usize` must implement `FnOnce<(&'1 (),)>`, for any lifetime `'1`...\n  = note: ...but it actually implements `FnOnce<(&'2 (),)>`, for some specific lifetime `'2`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `rust-test` due to 2 previous errors\n```\n\nAfter this PR:\n\n```\nerror[E0308]: mismatched types\n --> src/lib.rs:3:5\n  |\n3 |     x\n  |     ^ one type is more general than the other\n  |\n  = note: expected trait `for<'a> FnOnce<(&'a (),)>`\n             found trait `FnOnce<(&(),)>`\nnote: this closure does not fulfill the lifetime requirements\n --> src/lib.rs:2:13\n  |\n2 |     let x = |_| 1;\n  |             ^^^\nhelp: consider changing the type of the closure parameters\n  |\n2 |     let x = |_: &_| 1;\n  |             ~~~~~~~\n\nerror: implementation of `FnOnce` is not general enough\n --> src/lib.rs:3:5\n  |\n3 |     x\n  |     ^ implementation of `FnOnce` is not general enough\n  |\n  = note: closure with signature `fn(&'2 ()) -> usize` must implement `FnOnce<(&'1 (),)>`, for any lifetime `'1`...\n  = note: ...but it actually implements `FnOnce<(&'2 (),)>`, for some specific lifetime `'2`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `rust-test` due to 2 previous errors\n```\n\nAfter applying the suggestion, it compiles. The suggestion might not always be correct as the generation procedure of that suggestion is quite simple...", "tree": {"sha": "65af8ebd96f84ea2af123065eb3d0faec38db7f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65af8ebd96f84ea2af123065eb3d0faec38db7f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a711152615ad9294dc0e5ee6885c8e9bb8418a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a711152615ad9294dc0e5ee6885c8e9bb8418a9", "html_url": "https://github.com/rust-lang/rust/commit/2a711152615ad9294dc0e5ee6885c8e9bb8418a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6fb7b9815aea87fb5ced1c683212871699c907c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6fb7b9815aea87fb5ced1c683212871699c907c", "html_url": "https://github.com/rust-lang/rust/commit/c6fb7b9815aea87fb5ced1c683212871699c907c"}, {"sha": "90dc6fe71d6a245b175da6293a41c3156e955526", "url": "https://api.github.com/repos/rust-lang/rust/commits/90dc6fe71d6a245b175da6293a41c3156e955526", "html_url": "https://github.com/rust-lang/rust/commit/90dc6fe71d6a245b175da6293a41c3156e955526"}], "stats": {"total": 253, "additions": 250, "deletions": 3}, "files": [{"sha": "992b07db1543dff0ab9a1494795a4d05f44329de", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=2a711152615ad9294dc0e5ee6885c8e9bb8418a9", "patch": "@@ -1927,6 +1927,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         {\n             let span = self.tcx.def_span(def_id);\n             diag.span_note(span, \"this closure does not fulfill the lifetime requirements\");\n+            self.suggest_for_all_lifetime_closure(span, self.tcx.hir().get_by_def_id(def_id), &exp_found, diag);\n         }\n \n         // It reads better to have the error origin as the final"}, {"sha": "4dc5fc451ddd4219cccf0780510a339f783923d6", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 78, "deletions": 2, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=2a711152615ad9294dc0e5ee6885c8e9bb8418a9", "patch": "@@ -1,14 +1,14 @@\n use hir::def::CtorKind;\n use hir::intravisit::{walk_expr, walk_stmt, Visitor};\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_errors::Diagnostic;\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_middle::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n     StatementAsExpression,\n };\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self as ty, IsSuggestable, Ty, TypeVisitableExt};\n+use rustc_middle::ty::{self as ty, GenericArgKind, IsSuggestable, Ty, TypeVisitableExt};\n use rustc_span::{sym, BytePos, Span};\n use rustc_target::abi::FieldIdx;\n \n@@ -536,6 +536,82 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n         None\n     }\n+\n+    /// For \"one type is more general than the other\" errors on closures, suggest changing the lifetime\n+    /// of the parameters to accept all lifetimes.\n+    pub(super) fn suggest_for_all_lifetime_closure(\n+        &self,\n+        span: Span,\n+        hir: hir::Node<'_>,\n+        exp_found: &ty::error::ExpectedFound<ty::PolyTraitRef<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        // 0. Extract fn_decl from hir\n+        let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(hir::Closure { body, fn_decl, .. }), .. }) = hir else { return; };\n+        let hir::Body { params, .. } = self.tcx.hir().body(*body);\n+\n+        // 1. Get the substs of the closure.\n+        // 2. Assume exp_found is FnOnce / FnMut / Fn, we can extract function parameters from [1].\n+        let Some(expected) = exp_found.expected.skip_binder().substs.get(1) else { return; };\n+        let Some(found) = exp_found.found.skip_binder().substs.get(1) else { return; };\n+        let expected = expected.unpack();\n+        let found = found.unpack();\n+        // 3. Extract the tuple type from Fn trait and suggest the change.\n+        if let GenericArgKind::Type(expected) = expected &&\n+            let GenericArgKind::Type(found) = found &&\n+            let ty::Tuple(expected) = expected.kind() &&\n+            let ty::Tuple(found)= found.kind() &&\n+            expected.len() == found.len() {\n+            let mut suggestion = \"|\".to_string();\n+            let mut is_first = true;\n+            let mut has_suggestion = false;\n+\n+            for (((expected, found), param_hir), arg_hir) in expected.iter()\n+                .zip(found.iter())\n+                .zip(params.iter())\n+                .zip(fn_decl.inputs.iter()) {\n+                if is_first {\n+                    is_first = false;\n+                } else {\n+                    suggestion += \", \";\n+                }\n+\n+                if let ty::Ref(expected_region, _, _) = expected.kind() &&\n+                    let ty::Ref(found_region, _, _) = found.kind() &&\n+                    expected_region.is_late_bound() &&\n+                    !found_region.is_late_bound() &&\n+                    let hir::TyKind::Infer = arg_hir.kind {\n+                    // If the expected region is late bound, the found region is not, and users are asking compiler\n+                    // to infer the type, we can suggest adding `: &_`.\n+                    if param_hir.pat.span == param_hir.ty_span {\n+                        // for `|x|`, `|_|`, `|x: impl Foo|`\n+                        let Ok(pat) = self.tcx.sess.source_map().span_to_snippet(param_hir.pat.span) else { return; };\n+                        suggestion += &format!(\"{}: &_\", pat);\n+                    } else {\n+                        // for `|x: ty|`, `|_: ty|`\n+                        let Ok(pat) = self.tcx.sess.source_map().span_to_snippet(param_hir.pat.span) else { return; };\n+                        let Ok(ty) = self.tcx.sess.source_map().span_to_snippet(param_hir.ty_span) else { return; };\n+                        suggestion += &format!(\"{}: &{}\", pat, ty);\n+                    }\n+                    has_suggestion = true;\n+                } else {\n+                    let Ok(arg) = self.tcx.sess.source_map().span_to_snippet(param_hir.span) else { return; };\n+                    // Otherwise, keep it as-is.\n+                    suggestion += &arg;\n+                }\n+            }\n+            suggestion += \"|\";\n+\n+            if has_suggestion {\n+                diag.span_suggestion_verbose(\n+                    span,\n+                    \"consider specifying the type of the closure parameters\",\n+                    suggestion,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n }\n \n impl<'tcx> TypeErrCtxt<'_, 'tcx> {"}, {"sha": "58d8be8b65f78822428412150801cca9cb682e20", "filename": "tests/ui/lifetimes/issue-105675.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/tests%2Fui%2Flifetimes%2Fissue-105675.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/tests%2Fui%2Flifetimes%2Fissue-105675.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes%2Fissue-105675.rs?ref=2a711152615ad9294dc0e5ee6885c8e9bb8418a9", "patch": "@@ -0,0 +1,14 @@\n+fn thing(x: impl FnOnce(&u32, &u32, u32)) {}\n+\n+fn main() {\n+    let f = | _ , y: &u32 , z | ();\n+    thing(f);\n+    //~^ ERROR mismatched types\n+    //~^^ ERROR mismatched types\n+    let f = | x, y: _  , z: u32 | ();\n+    thing(f);\n+    //~^ ERROR mismatched types\n+    //~^^ ERROR mismatched types\n+    //~^^^ ERROR implementation of `FnOnce` is not general enough\n+    //~^^^^ ERROR implementation of `FnOnce` is not general enough\n+}"}, {"sha": "66415f72bcb453537a5a19fba75edfcee58666e6", "filename": "tests/ui/lifetimes/issue-105675.stderr", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/tests%2Fui%2Flifetimes%2Fissue-105675.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/tests%2Fui%2Flifetimes%2Fissue-105675.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes%2Fissue-105675.stderr?ref=2a711152615ad9294dc0e5ee6885c8e9bb8418a9", "patch": "@@ -0,0 +1,109 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-105675.rs:5:5\n+   |\n+LL |     thing(f);\n+   |     ^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected trait `for<'a, 'b> FnOnce<(&'a u32, &'b u32, u32)>`\n+              found trait `for<'a> FnOnce<(&u32, &'a u32, u32)>`\n+note: this closure does not fulfill the lifetime requirements\n+  --> $DIR/issue-105675.rs:4:13\n+   |\n+LL |     let f = | _ , y: &u32 , z | ();\n+   |             ^^^^^^^^^^^^^^^^^^^\n+note: the lifetime requirement is introduced here\n+  --> $DIR/issue-105675.rs:1:18\n+   |\n+LL | fn thing(x: impl FnOnce(&u32, &u32, u32)) {}\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider specifying the type of the closure parameters\n+   |\n+LL |     let f = |_: &_, y: &u32, z| ();\n+   |             ~~~~~~~~~~~~~~~~~~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-105675.rs:5:5\n+   |\n+LL |     thing(f);\n+   |     ^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected trait `for<'a, 'b> FnOnce<(&'a u32, &'b u32, u32)>`\n+              found trait `for<'a> FnOnce<(&u32, &'a u32, u32)>`\n+note: this closure does not fulfill the lifetime requirements\n+  --> $DIR/issue-105675.rs:4:13\n+   |\n+LL |     let f = | _ , y: &u32 , z | ();\n+   |             ^^^^^^^^^^^^^^^^^^^\n+note: the lifetime requirement is introduced here\n+  --> $DIR/issue-105675.rs:1:18\n+   |\n+LL | fn thing(x: impl FnOnce(&u32, &u32, u32)) {}\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-105675.rs:9:5\n+   |\n+LL |     thing(f);\n+   |     ^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected trait `for<'a, 'b> FnOnce<(&'a u32, &'b u32, u32)>`\n+              found trait `FnOnce<(&u32, &u32, u32)>`\n+note: this closure does not fulfill the lifetime requirements\n+  --> $DIR/issue-105675.rs:8:13\n+   |\n+LL |     let f = | x, y: _  , z: u32 | ();\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n+note: the lifetime requirement is introduced here\n+  --> $DIR/issue-105675.rs:1:18\n+   |\n+LL | fn thing(x: impl FnOnce(&u32, &u32, u32)) {}\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider specifying the type of the closure parameters\n+   |\n+LL |     let f = |x: &_, y: &_, z: u32| ();\n+   |             ~~~~~~~~~~~~~~~~~~~~~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-105675.rs:9:5\n+   |\n+LL |     thing(f);\n+   |     ^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected trait `for<'a, 'b> FnOnce<(&'a u32, &'b u32, u32)>`\n+              found trait `FnOnce<(&u32, &u32, u32)>`\n+note: this closure does not fulfill the lifetime requirements\n+  --> $DIR/issue-105675.rs:8:13\n+   |\n+LL |     let f = | x, y: _  , z: u32 | ();\n+   |             ^^^^^^^^^^^^^^^^^^^^^\n+note: the lifetime requirement is introduced here\n+  --> $DIR/issue-105675.rs:1:18\n+   |\n+LL | fn thing(x: impl FnOnce(&u32, &u32, u32)) {}\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider specifying the type of the closure parameters\n+   |\n+LL |     let f = |x: &_, y: &_, z: u32| ();\n+   |             ~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/issue-105675.rs:9:5\n+   |\n+LL |     thing(f);\n+   |     ^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&'2 u32, &u32, u32)` must implement `FnOnce<(&'1 u32, &u32, u32)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 u32, &u32, u32)>`, for some specific lifetime `'2`\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/issue-105675.rs:9:5\n+   |\n+LL |     thing(f);\n+   |     ^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&u32, &'2 u32, u32)` must implement `FnOnce<(&u32, &'1 u32, u32)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&u32, &'2 u32, u32)>`, for some specific lifetime `'2`\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "75fd87b3fe9b3090df12bbb72908efdba24ef1ef", "filename": "tests/ui/lifetimes/issue-79187-2.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/tests%2Fui%2Flifetimes%2Fissue-79187-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/tests%2Fui%2Flifetimes%2Fissue-79187-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes%2Fissue-79187-2.stderr?ref=2a711152615ad9294dc0e5ee6885c8e9bb8418a9", "patch": "@@ -43,6 +43,10 @@ note: the lifetime requirement is introduced here\n    |\n LL | fn take_foo(_: impl Foo) {}\n    |                     ^^^\n+help: consider specifying the type of the closure parameters\n+   |\n+LL |     take_foo(|a: &_| a);\n+   |              ~~~~~~~\n \n error[E0308]: mismatched types\n   --> $DIR/issue-79187-2.rs:11:5"}, {"sha": "209f2b7b7398ab389a8c637dc92c1776c598afc3", "filename": "tests/ui/lifetimes/issue-79187.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/tests%2Fui%2Flifetimes%2Fissue-79187.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/tests%2Fui%2Flifetimes%2Fissue-79187.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flifetimes%2Fissue-79187.stderr?ref=2a711152615ad9294dc0e5ee6885c8e9bb8418a9", "patch": "@@ -16,6 +16,10 @@ note: the lifetime requirement is introduced here\n    |\n LL | fn thing(x: impl FnOnce(&u32)) {}\n    |                  ^^^^^^^^^^^^\n+help: consider specifying the type of the closure parameters\n+   |\n+LL |     let f = |_: &_| ();\n+   |             ~~~~~~~\n \n error: implementation of `FnOnce` is not general enough\n   --> $DIR/issue-79187.rs:5:5"}, {"sha": "4eb33497c39560cb4ec86d0aa16fb2df740caeec", "filename": "tests/ui/mismatched_types/closure-mismatch.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/tests%2Fui%2Fmismatched_types%2Fclosure-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/tests%2Fui%2Fmismatched_types%2Fclosure-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fclosure-mismatch.rs?ref=2a711152615ad9294dc0e5ee6885c8e9bb8418a9", "patch": "@@ -8,4 +8,7 @@ fn main() {\n     baz(|_| ());\n     //~^ ERROR implementation of `FnOnce` is not general enough\n     //~| ERROR mismatched types\n+    baz(|x| ());\n+    //~^ ERROR implementation of `FnOnce` is not general enough\n+    //~| ERROR mismatched types\n }"}, {"sha": "c5b8270ba84d57534260069e5353b8d39171c0e2", "filename": "tests/ui/mismatched_types/closure-mismatch.stderr", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/tests%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a711152615ad9294dc0e5ee6885c8e9bb8418a9/tests%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr?ref=2a711152615ad9294dc0e5ee6885c8e9bb8418a9", "patch": "@@ -25,7 +25,43 @@ note: the lifetime requirement is introduced here\n    |\n LL | fn baz<T: Foo>(_: T) {}\n    |           ^^^\n+help: consider specifying the type of the closure parameters\n+   |\n+LL |     baz(|_: &_| ());\n+   |         ~~~~~~~\n+\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/closure-mismatch.rs:11:5\n+   |\n+LL |     baz(|x| ());\n+   |     ^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&'2 ())` must implement `FnOnce<(&'1 (),)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 (),)>`, for some specific lifetime `'2`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/closure-mismatch.rs:11:5\n+   |\n+LL |     baz(|x| ());\n+   |     ^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected trait `for<'a> Fn<(&'a (),)>`\n+              found trait `Fn<(&(),)>`\n+note: this closure does not fulfill the lifetime requirements\n+  --> $DIR/closure-mismatch.rs:11:9\n+   |\n+LL |     baz(|x| ());\n+   |         ^^^\n+note: the lifetime requirement is introduced here\n+  --> $DIR/closure-mismatch.rs:5:11\n+   |\n+LL | fn baz<T: Foo>(_: T) {}\n+   |           ^^^\n+help: consider specifying the type of the closure parameters\n+   |\n+LL |     baz(|x: &_| ());\n+   |         ~~~~~~~\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}