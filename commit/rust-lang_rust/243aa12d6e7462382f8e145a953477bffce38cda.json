{"sha": "243aa12d6e7462382f8e145a953477bffce38cda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0M2FhMTJkNmU3NDYyMzgyZjhlMTQ1YTk1MzQ3N2JmZmNlMzhjZGE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-08-29T21:44:29Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-09-03T10:10:53Z"}, "message": "refactor and centralize `on_unimplemented` parsing", "tree": {"sha": "d8852291d2e3c2e4bcd7aa97152b088f602da2bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8852291d2e3c2e4bcd7aa97152b088f602da2bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/243aa12d6e7462382f8e145a953477bffce38cda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/243aa12d6e7462382f8e145a953477bffce38cda", "html_url": "https://github.com/rust-lang/rust/commit/243aa12d6e7462382f8e145a953477bffce38cda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/243aa12d6e7462382f8e145a953477bffce38cda/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc54bf949dd377fe5f606720a6ab190755a3a312", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc54bf949dd377fe5f606720a6ab190755a3a312", "html_url": "https://github.com/rust-lang/rust/commit/fc54bf949dd377fe5f606720a6ab190755a3a312"}], "stats": {"total": 488, "additions": 242, "deletions": 246}, "files": [{"sha": "0585c970937cae6966002fb14d6f716d71fe29f4", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 92, "deletions": 88, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/243aa12d6e7462382f8e145a953477bffce38cda/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/243aa12d6e7462382f8e145a953477bffce38cda/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=243aa12d6e7462382f8e145a953477bffce38cda", "patch": "@@ -688,8 +688,8 @@ See also https://doc.rust-lang.org/book/first-edition/no-stdlib.html\n \"##,\n \n E0214: r##\"\n-A generic type was described using parentheses rather than angle brackets. For\n-example:\n+A generic type was described using parentheses rather than angle brackets.\n+For example:\n \n ```compile_fail,E0214\n fn main() {\n@@ -702,6 +702,93 @@ Parentheses are currently only used with generic types when defining parameters\n for `Fn`-family traits.\n \"##,\n \n+E0230: r##\"\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```compile_fail\n+#![feature(on_unimplemented)]\n+\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { /* ... */ }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+There will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+As you can see, you can specify type parameters in curly braces for\n+substitution with the actual types (using the regular format string syntax) in\n+a given situation. Furthermore, `{Self}` will substitute to the type (in this\n+case, `bool`) that we tried to use.\n+\n+This error appears when the curly braces contain an identifier which doesn't\n+match with any of the type parameters or the string `Self`. This might happen\n+if you misspelled a type parameter, or if you intended to use literal curly\n+braces. If it is the latter, escape the curly braces with a second curly brace\n+of the same type; e.g. a literal `{` is `{{`.\n+\"##,\n+\n+E0231: r##\"\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```compile_fail\n+#![feature(on_unimplemented)]\n+\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { /* ... */ }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+As you can see, you can specify type parameters in curly braces for\n+substitution with the actual types (using the regular format string syntax) in\n+a given situation. Furthermore, `{Self}` will substitute to the type (in this\n+case, `bool`) that we tried to use.\n+\n+This error appears when the curly braces do not contain an identifier. Please\n+add one of the same name as a type parameter. If you intended to use literal\n+braces, use `{{` and `}}` to escape them.\n+\"##,\n+\n+E0232: r##\"\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```compile_fail\n+#![feature(on_unimplemented)]\n+\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { /* ... */ }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+For this to work, some note must be specified. An empty attribute will not do\n+anything, please remove the attribute or add some helpful note for users of the\n+trait.\n+\"##,\n+\n E0261: r##\"\n When using a lifetime like `'a` in a type, it must be declared before being\n used.\n@@ -917,92 +1004,6 @@ for v in &vs {\n ```\n \"##,\n \n-E0272: r##\"\n-The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n-message for when a particular trait isn't implemented on a type placed in a\n-position that needs that trait. For example, when the following code is\n-compiled:\n-\n-```compile_fail\n-#![feature(on_unimplemented)]\n-\n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n-```\n-\n-There will be an error about `bool` not implementing `Index<u8>`, followed by a\n-note saying \"the type `bool` cannot be indexed by `u8`\".\n-\n-As you can see, you can specify type parameters in curly braces for\n-substitution with the actual types (using the regular format string syntax) in\n-a given situation. Furthermore, `{Self}` will substitute to the type (in this\n-case, `bool`) that we tried to use.\n-\n-This error appears when the curly braces contain an identifier which doesn't\n-match with any of the type parameters or the string `Self`. This might happen\n-if you misspelled a type parameter, or if you intended to use literal curly\n-braces. If it is the latter, escape the curly braces with a second curly brace\n-of the same type; e.g. a literal `{` is `{{`.\n-\"##,\n-\n-E0273: r##\"\n-The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n-message for when a particular trait isn't implemented on a type placed in a\n-position that needs that trait. For example, when the following code is\n-compiled:\n-\n-```compile_fail\n-#![feature(on_unimplemented)]\n-\n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n-```\n-\n-there will be an error about `bool` not implementing `Index<u8>`, followed by a\n-note saying \"the type `bool` cannot be indexed by `u8`\".\n-\n-As you can see, you can specify type parameters in curly braces for\n-substitution with the actual types (using the regular format string syntax) in\n-a given situation. Furthermore, `{Self}` will substitute to the type (in this\n-case, `bool`) that we tried to use.\n-\n-This error appears when the curly braces do not contain an identifier. Please\n-add one of the same name as a type parameter. If you intended to use literal\n-braces, use `{{` and `}}` to escape them.\n-\"##,\n-\n-E0274: r##\"\n-The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n-message for when a particular trait isn't implemented on a type placed in a\n-position that needs that trait. For example, when the following code is\n-compiled:\n-\n-```compile_fail\n-#![feature(on_unimplemented)]\n-\n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n-```\n-\n-there will be an error about `bool` not implementing `Index<u8>`, followed by a\n-note saying \"the type `bool` cannot be indexed by `u8`\".\n-\n-For this to work, some note must be specified. An empty attribute will not do\n-anything, please remove the attribute or add some helpful note for users of the\n-trait.\n-\"##,\n \n E0275: r##\"\n This error occurs when there was a recursive trait requirement that overflowed\n@@ -2011,6 +2012,9 @@ register_diagnostics! {\n //  E0102, // replaced with E0282\n //  E0134,\n //  E0135,\n+//  E0271, // on_unimplemented #0\n+//  E0272, // on_unimplemented #1\n+//  E0273, // on_unimplemented #2\n     E0278, // requirement is not satisfied\n     E0279, // requirement is not satisfied\n     E0280, // requirement is not satisfied"}, {"sha": "8b1b11ff940260a6957b19e36783f7f0efc529b4", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 144, "deletions": 63, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/243aa12d6e7462382f8e145a953477bffce38cda/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/243aa12d6e7462382f8e145a953477bffce38cda/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=243aa12d6e7462382f8e145a953477bffce38cda", "patch": "@@ -39,9 +39,148 @@ use ty::fast_reject;\n use ty::fold::TypeFolder;\n use ty::subst::Subst;\n use ty::SubtypePredicate;\n+use util::common::ErrorReported;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::symbol::InternedString;\n+\n+pub struct OnUnimplementedFormatString(InternedString);\n+pub struct OnUnimplementedInfo {\n+    note: OnUnimplementedFormatString\n+}\n+\n+impl<'a, 'gcx, 'tcx> OnUnimplementedInfo {\n+    pub fn of_item(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                   trait_def_id: DefId,\n+                   impl_def_id: DefId,\n+                   span: Span)\n+                   -> Result<Option<Self>, ErrorReported>\n+    {\n+        let attrs = tcx.get_attrs(impl_def_id);\n+\n+        let attr = if let Some(item) =\n+            attrs.into_iter().find(|a| a.check_name(\"rustc_on_unimplemented\"))\n+        {\n+            item\n+        } else {\n+            return Ok(None);\n+        };\n+\n+        let span = attr.span.substitute_dummy(span);\n+        if let Some(label) = attr.value_str() {\n+            Ok(Some(OnUnimplementedInfo {\n+                note: OnUnimplementedFormatString::try_parse(\n+                    tcx, trait_def_id, label.as_str(), span)?\n+            }))\n+        } else {\n+            struct_span_err!(\n+                tcx.sess, span, E0232,\n+                \"this attribute must have a value\")\n+                .span_label(attr.span, \"attribute requires a value\")\n+                .note(&format!(\"eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\"))\n+                .emit();\n+            Err(ErrorReported)\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n+    pub fn try_parse(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                     trait_def_id: DefId,\n+                     from: InternedString,\n+                     err_sp: Span)\n+                     -> Result<Self, ErrorReported>\n+    {\n+        let result = OnUnimplementedFormatString(from);\n+        result.verify(tcx, trait_def_id, err_sp)?;\n+        Ok(result)\n+    }\n+\n+    fn verify(&self,\n+              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+              trait_def_id: DefId,\n+              span: Span)\n+              -> Result<(), ErrorReported>\n+    {\n+        let name = tcx.item_name(trait_def_id).as_str();\n+        let generics = tcx.generics_of(trait_def_id);\n+        let parser = Parser::new(&self.0);\n+        let types = &generics.types;\n+        let mut result = Ok(());\n+        for token in parser {\n+            match token {\n+                Piece::String(_) => (), // Normal string, no need to check it\n+                Piece::NextArgument(a) => match a.position {\n+                    // `{Self}` is allowed\n+                    Position::ArgumentNamed(s) if s == \"Self\" => (),\n+                    // `{ThisTraitsName}` is allowed\n+                    Position::ArgumentNamed(s) if s == name => (),\n+                    // So is `{A}` if A is a type parameter\n+                    Position::ArgumentNamed(s) => match types.iter().find(|t| {\n+                        t.name == s\n+                    }) {\n+                        Some(_) => (),\n+                        None => {\n+                            span_err!(tcx.sess, span, E0230,\n+                                      \"there is no type parameter \\\n+                                       {} on trait {}\",\n+                                      s, name);\n+                            result = Err(ErrorReported);\n+                        }\n+                    },\n+                    // `{:1}` and `{}` are not to be used\n+                    Position::ArgumentIs(_) => {\n+                        span_err!(tcx.sess, span, E0231,\n+                                  \"only named substitution \\\n+                                   parameters are allowed\");\n+                        result = Err(ErrorReported);\n+                    }\n+                }\n+            }\n+        }\n+\n+        result\n+    }\n+\n+    fn format(&self,\n+              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+              trait_ref: ty::TraitRef<'tcx>)\n+              -> String\n+    {\n+        let name = tcx.item_name(trait_ref.def_id).as_str();\n+        let trait_str = tcx.item_path_str(trait_ref.def_id);\n+        let generics = tcx.generics_of(trait_ref.def_id);\n+        let generic_map = generics.types.iter().map(|param| {\n+            (param.name.as_str().to_string(),\n+             trait_ref.substs.type_for_def(param).to_string())\n+        }).collect::<FxHashMap<String, String>>();\n+\n+        let parser = Parser::new(&self.0);\n+        parser.map(|p| {\n+            match p {\n+                Piece::String(s) => s,\n+                Piece::NextArgument(a) => match a.position {\n+                    Position::ArgumentNamed(s) => match generic_map.get(s) {\n+                        Some(val) => val,\n+                        None if s == name => {\n+                            &trait_str\n+                        }\n+                        None => {\n+                            bug!(\"broken on_unimplemented {:?} for {:?}: \\\n+                                  no argument matching {:?}\",\n+                                 self.0, trait_ref, s)\n+                        }\n+                    },\n+                    _ => {\n+                        bug!(\"broken on_unimplemented {:?} - bad \\\n+                              format arg\", self.0)\n+                    }\n+                }\n+            }\n+        }).collect()\n+    }\n+}\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_fulfillment_errors(&self,\n@@ -323,70 +462,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .unwrap_or(trait_ref.def_id());\n         let trait_ref = trait_ref.skip_binder();\n \n-        let span = obligation.cause.span;\n-        let mut report = None;\n-        if let Some(item) = self.tcx\n-            .get_attrs(def_id)\n-            .into_iter()\n-            .filter(|a| a.check_name(\"rustc_on_unimplemented\"))\n-            .next()\n-        {\n-            let name = self.tcx.item_name(def_id).as_str();\n-            let err_sp = item.span.substitute_dummy(span);\n-            let trait_str = self.tcx.item_path_str(trait_ref.def_id);\n-            if let Some(istring) = item.value_str() {\n-                let istring = &*istring.as_str();\n-                let generics = self.tcx.generics_of(trait_ref.def_id);\n-                let generic_map = generics.types.iter().map(|param| {\n-                    (param.name.as_str().to_string(),\n-                        trait_ref.substs.type_for_def(param).to_string())\n-                }).collect::<FxHashMap<String, String>>();\n-                let parser = Parser::new(istring);\n-                let mut errored = false;\n-                let err: String = parser.filter_map(|p| {\n-                    match p {\n-                        Piece::String(s) => Some(s),\n-                        Piece::NextArgument(a) => match a.position {\n-                            Position::ArgumentNamed(s) => match generic_map.get(s) {\n-                                Some(val) => Some(val),\n-                                None if s == name => {\n-                                    Some(&trait_str)\n-                                }\n-                                None => {\n-                                    span_err!(self.tcx.sess, err_sp, E0272,\n-                                              \"the #[rustc_on_unimplemented] attribute on trait \\\n-                                               definition for {} refers to non-existent type \\\n-                                               parameter {}\",\n-                                              trait_str, s);\n-                                    errored = true;\n-                                    None\n-                                }\n-                            },\n-                            _ => {\n-                                span_err!(self.tcx.sess, err_sp, E0273,\n-                                          \"the #[rustc_on_unimplemented] attribute on trait \\\n-                                           definition for {} must have named format arguments, eg \\\n-                                           `#[rustc_on_unimplemented = \\\"foo {{T}}\\\"]`\",\n-                                          trait_str);\n-                                errored = true;\n-                                None\n-                            }\n-                        }\n-                    }\n-                }).collect();\n-                // Report only if the format string checks out\n-                if !errored {\n-                    report = Some(err);\n-                }\n-            } else {\n-                span_err!(self.tcx.sess, err_sp, E0274,\n-                                        \"the #[rustc_on_unimplemented] attribute on \\\n-                                                    trait definition for {} must have a value, \\\n-                                                    eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n-                                                    trait_str);\n-            }\n+        match OnUnimplementedInfo::of_item(\n+            self.tcx, trait_ref.def_id, def_id, obligation.cause.span\n+        ) {\n+            Ok(Some(info)) => Some(info.note.format(self.tcx, *trait_ref)),\n+            _ => None\n         }\n-        report\n     }\n \n     fn find_similar_impl_candidates(&self,"}, {"sha": "cbc0389f48ef6318b271be5b56441d2cf4d39523", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/243aa12d6e7462382f8e145a953477bffce38cda/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/243aa12d6e7462382f8e145a953477bffce38cda/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=243aa12d6e7462382f8e145a953477bffce38cda", "patch": "@@ -31,6 +31,7 @@ use syntax_pos::{Span, DUMMY_SP};\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n+pub use self::error_reporting::OnUnimplementedInfo;\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, Normalized};"}, {"sha": "15002005832bb470d5fc6471ef9684cb0fe10c2d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 49, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/243aa12d6e7462382f8e145a953477bffce38cda/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/243aa12d6e7462382f8e145a953477bffce38cda/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=243aa12d6e7462382f8e145a953477bffce38cda", "patch": "@@ -85,7 +85,6 @@ use self::method::MethodCallee;\n use self::TupleArgumentsFlag::*;\n \n use astconv::AstConv;\n-use fmt_macros::{Parser, Piece, Position};\n use hir::def::{Def, CtorKind};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_back::slice::ref_slice;\n@@ -1215,55 +1214,12 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n }\n \n fn check_on_unimplemented<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    def_id: DefId,\n+                                    trait_def_id: DefId,\n                                     item: &hir::Item) {\n-    let generics = tcx.generics_of(def_id);\n-    if let Some(ref attr) = item.attrs.iter().find(|a| {\n-        a.check_name(\"rustc_on_unimplemented\")\n-    }) {\n-        if let Some(istring) = attr.value_str() {\n-            let istring = istring.as_str();\n-            let name = tcx.item_name(def_id).as_str();\n-            let parser = Parser::new(&istring);\n-            let types = &generics.types;\n-            for token in parser {\n-                match token {\n-                    Piece::String(_) => (), // Normal string, no need to check it\n-                    Piece::NextArgument(a) => match a.position {\n-                        // `{Self}` is allowed\n-                        Position::ArgumentNamed(s) if s == \"Self\" => (),\n-                        // `{ThisTraitsName}` is allowed\n-                        Position::ArgumentNamed(s) if s == name => (),\n-                        // So is `{A}` if A is a type parameter\n-                        Position::ArgumentNamed(s) => match types.iter().find(|t| {\n-                            t.name == s\n-                        }) {\n-                            Some(_) => (),\n-                            None => {\n-                                span_err!(tcx.sess, attr.span, E0230,\n-                                                 \"there is no type parameter \\\n-                                                          {} on trait {}\",\n-                                                           s, name);\n-                            }\n-                        },\n-                        // `{:1}` and `{}` are not to be used\n-                        Position::ArgumentIs(_) => {\n-                            span_err!(tcx.sess, attr.span, E0231,\n-                                                  \"only named substitution \\\n-                                                   parameters are allowed\");\n-                        }\n-                    }\n-                }\n-            }\n-        } else {\n-            struct_span_err!(\n-                tcx.sess, attr.span, E0232,\n-                \"this attribute must have a value\")\n-                .span_label(attr.span, \"attribute requires a value\")\n-                .note(&format!(\"eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\"))\n-                .emit();\n-        }\n-    }\n+    let item_def_id = tcx.hir.local_def_id(item.id);\n+    // an error would be reported if this fails.\n+    let _ = traits::OnUnimplementedInfo::of_item(\n+        tcx, trait_def_id, item_def_id, item.span);\n }\n \n fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "6bbe2233ff1fa40360beb0d62f6d6a01902c7455", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/243aa12d6e7462382f8e145a953477bffce38cda/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/243aa12d6e7462382f8e145a953477bffce38cda/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=243aa12d6e7462382f8e145a953477bffce38cda", "patch": "@@ -2505,50 +2505,6 @@ fn baz<I>(x: &<I as Foo>::A) where I: Foo<A=Bar> {}\n ```\n \"##,\n \n-E0230: r##\"\n-The trait has more type parameters specified than appear in its definition.\n-\n-Erroneous example code:\n-\n-```compile_fail,E0230\n-#![feature(on_unimplemented)]\n-#[rustc_on_unimplemented = \"Trait error on `{Self}` with `<{A},{B},{C}>`\"]\n-// error: there is no type parameter C on trait TraitWithThreeParams\n-trait TraitWithThreeParams<A,B>\n-{}\n-```\n-\n-Include the correct number of type parameters and the compilation should\n-proceed:\n-\n-```\n-#![feature(on_unimplemented)]\n-#[rustc_on_unimplemented = \"Trait error on `{Self}` with `<{A},{B},{C}>`\"]\n-trait TraitWithThreeParams<A,B,C> // ok!\n-{}\n-```\n-\"##,\n-\n-E0232: r##\"\n-The attribute must have a value. Erroneous code example:\n-\n-```compile_fail,E0232\n-#![feature(on_unimplemented)]\n-\n-#[rustc_on_unimplemented] // error: this attribute must have a value\n-trait Bar {}\n-```\n-\n-Please supply the missing value of the attribute. Example:\n-\n-```\n-#![feature(on_unimplemented)]\n-\n-#[rustc_on_unimplemented = \"foo\"] // ok!\n-trait Bar {}\n-```\n-\"##,\n-\n E0243: r##\"\n This error indicates that not enough type parameters were found in a type or\n trait.\n@@ -4690,7 +4646,6 @@ register_diagnostics! {\n     E0224, // at least one non-builtin train is required for an object type\n     E0227, // ambiguous lifetime bound, explicit lifetime bound required\n     E0228, // explicit lifetime bound required\n-    E0231, // only named substitution parameters are allowed\n //  E0233,\n //  E0234,\n //  E0235, // structure constructor specifies a structure of type but"}, {"sha": "7a6ee73b9b9e9f1c14d6a8ac0f7028afa843d819", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/243aa12d6e7462382f8e145a953477bffce38cda/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/243aa12d6e7462382f8e145a953477bffce38cda/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=243aa12d6e7462382f8e145a953477bffce38cda", "patch": "@@ -84,7 +84,6 @@ This API is completely unstable and subject to change.\n extern crate syntax_pos;\n \n extern crate arena;\n-extern crate fmt_macros;\n #[macro_use] extern crate rustc;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_back;"}]}