{"sha": "007246c17f1891cabb84c8a82250703f542cd58e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNzI0NmMxN2YxODkxY2FiYjg0YzhhODIyNTA3MDNmNTQyY2Q1OGU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-07-02T03:37:52Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-07-21T09:55:19Z"}, "message": "Allow for space between each filemap in the codemap\n\nSo if a filemap's last byte is at position n in the codemap, then n+1 will not refer to any filemap, and the next filemap will begin an n+2.\n\nThis is useful for empty files, it means that every file (even empty ones) has a byte in the codemap.\n\nCloses #23301, #26504", "tree": {"sha": "24e6e509571613f3edcc82876072692ed26d489a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24e6e509571613f3edcc82876072692ed26d489a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/007246c17f1891cabb84c8a82250703f542cd58e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/007246c17f1891cabb84c8a82250703f542cd58e", "html_url": "https://github.com/rust-lang/rust/commit/007246c17f1891cabb84c8a82250703f542cd58e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/007246c17f1891cabb84c8a82250703f542cd58e/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "691ce23479b08a292ad106606dab347306fc381f", "url": "https://api.github.com/repos/rust-lang/rust/commits/691ce23479b08a292ad106606dab347306fc381f", "html_url": "https://github.com/rust-lang/rust/commit/691ce23479b08a292ad106606dab347306fc381f"}], "stats": {"total": 175, "additions": 97, "deletions": 78}, "files": [{"sha": "2f109b589f143733fa9289167185e0c3e20791e0", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 90, "deletions": 72, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/007246c17f1891cabb84c8a82250703f542cd58e/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007246c17f1891cabb84c8a82250703f542cd58e/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=007246c17f1891cabb84c8a82250703f542cd58e", "patch": "@@ -115,6 +115,10 @@ impl Sub for CharPos {\n /// are *absolute* positions from the beginning of the codemap, not positions\n /// relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n /// to the original source.\n+/// You must be careful if the span crosses more than one file - you will not be\n+/// able to use many of the functions on spans in codemap and you cannot assume\n+/// that the length of the span = hi - lo; there may be space in the BytePos\n+/// range between files.\n #[derive(Clone, Copy, Hash)]\n pub struct Span {\n     pub lo: BytePos,\n@@ -339,7 +343,7 @@ pub struct MultiByteChar {\n     pub bytes: usize,\n }\n \n-/// A single source in the CodeMap\n+/// A single source in the CodeMap.\n pub struct FileMap {\n     /// The name of the file that the source came from, source that doesn't\n     /// originate from files has names between angle brackets by convention,\n@@ -508,6 +512,9 @@ impl FileMap {\n                 lines.get(line_number).map(|&line| {\n                     let begin: BytePos = line - self.start_pos;\n                     let begin = begin.to_usize();\n+                    // We can't use `lines.get(line_number+1)` because we might\n+                    // be parsing when we call this function and thus the current\n+                    // line is the last one we have line info for.\n                     let slice = &src[begin..];\n                     match slice.find('\\n') {\n                         Some(e) => &slice[..e],\n@@ -598,27 +605,27 @@ impl CodeMap {\n         Ok(self.new_filemap(path.to_str().unwrap().to_string(), src))\n     }\n \n+    fn next_start_pos(&self) -> usize {\n+        let files = self.files.borrow();\n+        match files.last() {\n+            None => 0,\n+            // Add one so there is some space between files. This lets us distinguish\n+            // positions in the codemap, even in the presence of zero-length files.\n+            Some(last) => last.end_pos.to_usize() + 1,\n+        }\n+    }\n+\n+    /// Creates a new filemap without setting its line information. If you don't\n+    /// intend to set the line information yourself, you should use new_filemap_and_lines.\n     pub fn new_filemap(&self, filename: FileName, mut src: String) -> Rc<FileMap> {\n+        let start_pos = self.next_start_pos();\n         let mut files = self.files.borrow_mut();\n-        let start_pos = match files.last() {\n-            None => 0,\n-            Some(last) => last.end_pos.to_usize(),\n-        };\n \n         // Remove utf-8 BOM if any.\n         if src.starts_with(\"\\u{feff}\") {\n             src.drain(..3);\n         }\n \n-        // Append '\\n' in case it's not already there.\n-        // This is a workaround to prevent CodeMap.lookup_filemap_idx from\n-        // accidentally overflowing into the next filemap in case the last byte\n-        // of span is also the last byte of filemap, which leads to incorrect\n-        // results from CodeMap.span_to_*.\n-        if !src.is_empty() && !src.ends_with(\"\\n\") {\n-            src.push('\\n');\n-        }\n-\n         let end_pos = start_pos + src.len();\n \n         let filemap = Rc::new(FileMap {\n@@ -645,11 +652,8 @@ impl CodeMap {\n                                 mut file_local_lines: Vec<BytePos>,\n                                 mut file_local_multibyte_chars: Vec<MultiByteChar>)\n                                 -> Rc<FileMap> {\n+        let start_pos = self.next_start_pos();\n         let mut files = self.files.borrow_mut();\n-        let start_pos = match files.last() {\n-            None => 0,\n-            Some(last) => last.end_pos.to_usize(),\n-        };\n \n         let end_pos = Pos::from_usize(start_pos + source_len);\n         let start_pos = Pos::from_usize(start_pos);\n@@ -686,39 +690,61 @@ impl CodeMap {\n \n     /// Lookup source information about a BytePos\n     pub fn lookup_char_pos(&self, pos: BytePos) -> Loc {\n-        let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n-        let line = a + 1; // Line numbers start at 1\n         let chpos = self.bytepos_to_file_charpos(pos);\n-        let linebpos = (*f.lines.borrow())[a];\n-        let linechpos = self.bytepos_to_file_charpos(linebpos);\n-        debug!(\"byte pos {:?} is on the line at byte pos {:?}\",\n-               pos, linebpos);\n-        debug!(\"char pos {:?} is on the line at char pos {:?}\",\n-               chpos, linechpos);\n-        debug!(\"byte is on line: {}\", line);\n-        assert!(chpos >= linechpos);\n-        Loc {\n-            file: f,\n-            line: line,\n-            col: chpos - linechpos\n+        match self.lookup_line(pos) {\n+            Ok(FileMapAndLine { fm: f, line: a }) => {\n+                let line = a + 1; // Line numbers start at 1\n+                let linebpos = (*f.lines.borrow())[a];\n+                let linechpos = self.bytepos_to_file_charpos(linebpos);\n+                debug!(\"byte pos {:?} is on the line at byte pos {:?}\",\n+                       pos, linebpos);\n+                debug!(\"char pos {:?} is on the line at char pos {:?}\",\n+                       chpos, linechpos);\n+                debug!(\"byte is on line: {}\", line);\n+                assert!(chpos >= linechpos);\n+                Loc {\n+                    file: f,\n+                    line: line,\n+                    col: chpos - linechpos,\n+                }\n+            }\n+            Err(f) => {\n+                Loc {\n+                    file: f,\n+                    line: 0,\n+                    col: chpos,\n+                }\n+            }\n         }\n     }\n \n-    fn lookup_line(&self, pos: BytePos) -> FileMapAndLine {\n+    // If the relevant filemap is empty, we don't return a line number.\n+    fn lookup_line(&self, pos: BytePos) -> Result<FileMapAndLine, Rc<FileMap>> {\n         let idx = self.lookup_filemap_idx(pos);\n \n         let files = self.files.borrow();\n         let f = (*files)[idx].clone();\n+\n+        let len = f.lines.borrow().len();\n+        if len == 0 {\n+            return Err(f);\n+        }\n+\n         let mut a = 0;\n         {\n             let lines = f.lines.borrow();\n             let mut b = lines.len();\n             while b - a > 1 {\n                 let m = (a + b) / 2;\n-                if (*lines)[m] > pos { b = m; } else { a = m; }\n+                if (*lines)[m] > pos {\n+                    b = m;\n+                } else {\n+                    a = m;\n+                }\n             }\n+            assert!(a <= lines.len());\n         }\n-        FileMapAndLine {fm: f, line: a}\n+        Ok(FileMapAndLine { fm: f, line: a })\n     }\n \n     pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt {\n@@ -880,12 +906,15 @@ impl CodeMap {\n         CharPos(bpos.to_usize() - map.start_pos.to_usize() - total_extra_bytes)\n     }\n \n+    // Return the index of the filemap (in self.files) which contains pos.\n     fn lookup_filemap_idx(&self, pos: BytePos) -> usize {\n         let files = self.files.borrow();\n         let files = &*files;\n-        let len = files.len();\n+        let count = files.len();\n+\n+        // Binary search for the filemap.\n         let mut a = 0;\n-        let mut b = len;\n+        let mut b = count;\n         while b - a > 1 {\n             let m = (a + b) / 2;\n             if files[m].start_pos > pos {\n@@ -894,26 +923,8 @@ impl CodeMap {\n                 a = m;\n             }\n         }\n-        // There can be filemaps with length 0. These have the same start_pos as\n-        // the previous filemap, but are not the filemaps we want (because they\n-        // are length 0, they cannot contain what we are looking for). So,\n-        // rewind until we find a useful filemap.\n-        loop {\n-            let lines = files[a].lines.borrow();\n-            let lines = lines;\n-            if !lines.is_empty() {\n-                break;\n-            }\n-            if a == 0 {\n-                panic!(\"position {} does not resolve to a source location\",\n-                      pos.to_usize());\n-            }\n-            a -= 1;\n-        }\n-        if a >= len {\n-            panic!(\"position {} does not resolve to a source location\",\n-                  pos.to_usize())\n-        }\n+\n+        assert!(a < count, \"position {} does not resolve to a source location\", pos.to_usize());\n \n         return a;\n     }\n@@ -1027,10 +1038,13 @@ mod tests {\n         let fm = cm.new_filemap(\"blork.rs\".to_string(),\n                                 \"first line.\\nsecond line\".to_string());\n         fm.next_line(BytePos(0));\n+        // Test we can get lines with partial line info.\n         assert_eq!(fm.get_line(0), Some(\"first line.\"));\n-        // TESTING BROKEN BEHAVIOR:\n+        // TESTING BROKEN BEHAVIOR: line break declared before actual line break.\n         fm.next_line(BytePos(10));\n         assert_eq!(fm.get_line(1), Some(\".\"));\n+        fm.next_line(BytePos(12));\n+        assert_eq!(fm.get_line(2), Some(\"second line\"));\n     }\n \n     #[test]\n@@ -1056,9 +1070,9 @@ mod tests {\n \n         fm1.next_line(BytePos(0));\n         fm1.next_line(BytePos(12));\n-        fm2.next_line(BytePos(24));\n-        fm3.next_line(BytePos(24));\n-        fm3.next_line(BytePos(34));\n+        fm2.next_line(fm2.start_pos);\n+        fm3.next_line(fm3.start_pos);\n+        fm3.next_line(fm3.start_pos + BytePos(12));\n \n         cm\n     }\n@@ -1068,11 +1082,15 @@ mod tests {\n         // Test lookup_byte_offset\n         let cm = init_code_map();\n \n-        let fmabp1 = cm.lookup_byte_offset(BytePos(22));\n+        let fmabp1 = cm.lookup_byte_offset(BytePos(23));\n         assert_eq!(fmabp1.fm.name, \"blork.rs\");\n-        assert_eq!(fmabp1.pos, BytePos(22));\n+        assert_eq!(fmabp1.pos, BytePos(23));\n+\n+        let fmabp1 = cm.lookup_byte_offset(BytePos(24));\n+        assert_eq!(fmabp1.fm.name, \"empty.rs\");\n+        assert_eq!(fmabp1.pos, BytePos(0));\n \n-        let fmabp2 = cm.lookup_byte_offset(BytePos(24));\n+        let fmabp2 = cm.lookup_byte_offset(BytePos(25));\n         assert_eq!(fmabp2.fm.name, \"blork2.rs\");\n         assert_eq!(fmabp2.pos, BytePos(0));\n     }\n@@ -1085,7 +1103,7 @@ mod tests {\n         let cp1 = cm.bytepos_to_file_charpos(BytePos(22));\n         assert_eq!(cp1, CharPos(22));\n \n-        let cp2 = cm.bytepos_to_file_charpos(BytePos(24));\n+        let cp2 = cm.bytepos_to_file_charpos(BytePos(25));\n         assert_eq!(cp2, CharPos(0));\n     }\n \n@@ -1099,7 +1117,7 @@ mod tests {\n         assert_eq!(loc1.line, 2);\n         assert_eq!(loc1.col, CharPos(10));\n \n-        let loc2 = cm.lookup_char_pos(BytePos(24));\n+        let loc2 = cm.lookup_char_pos(BytePos(25));\n         assert_eq!(loc2.file.name, \"blork2.rs\");\n         assert_eq!(loc2.line, 1);\n         assert_eq!(loc2.col, CharPos(0));\n@@ -1115,18 +1133,18 @@ mod tests {\n                                  \"first line\u20ac\u20ac.\\n\u20ac second line\".to_string());\n \n         fm1.next_line(BytePos(0));\n-        fm1.next_line(BytePos(22));\n-        fm2.next_line(BytePos(40));\n-        fm2.next_line(BytePos(58));\n+        fm1.next_line(BytePos(28));\n+        fm2.next_line(fm2.start_pos);\n+        fm2.next_line(fm2.start_pos + BytePos(20));\n \n         fm1.record_multibyte_char(BytePos(3), 3);\n         fm1.record_multibyte_char(BytePos(9), 3);\n         fm1.record_multibyte_char(BytePos(12), 3);\n         fm1.record_multibyte_char(BytePos(15), 3);\n         fm1.record_multibyte_char(BytePos(18), 3);\n-        fm2.record_multibyte_char(BytePos(50), 3);\n-        fm2.record_multibyte_char(BytePos(53), 3);\n-        fm2.record_multibyte_char(BytePos(58), 3);\n+        fm2.record_multibyte_char(fm2.start_pos + BytePos(10), 3);\n+        fm2.record_multibyte_char(fm2.start_pos + BytePos(13), 3);\n+        fm2.record_multibyte_char(fm2.start_pos + BytePos(18), 3);\n \n         cm\n     }"}, {"sha": "60f713b5289278e6577ff4a55c3487518cb9e9cf", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/007246c17f1891cabb84c8a82250703f542cd58e/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/007246c17f1891cabb84c8a82250703f542cd58e/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=007246c17f1891cabb84c8a82250703f542cd58e", "patch": "@@ -854,11 +854,12 @@ mod test {\n         println!(\"done\");\n         let vec = data.lock().unwrap().clone();\n         let vec: &[u8] = &vec;\n-        println!(\"{}\", from_utf8(vec).unwrap());\n-        assert_eq!(vec, \"dummy.txt: 8 \\n\\\n-                         dummy.txt: 9 \\n\\\n-                         dummy.txt:10 \\n\\\n-                         dummy.txt:11 \\n\\\n-                         dummy.txt:12 \\n\".as_bytes());\n+        let str = from_utf8(vec).unwrap();\n+        println!(\"{}\", str);\n+        assert_eq!(str, \"dummy.txt: 8         line8\\n\\\n+                         dummy.txt: 9         line9\\n\\\n+                         dummy.txt:10         line10\\n\\\n+                         dummy.txt:11         e-l\u00e4-v\u00e4n\\n\\\n+                         dummy.txt:12         tolv\\n\");\n     }\n }"}]}