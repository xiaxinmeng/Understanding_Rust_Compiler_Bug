{"sha": "76ddd2b1547dd461d0487233a0a19674292c976e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZGRkMmIxNTQ3ZGQ0NjFkMDQ4NzIzM2EwYTE5Njc0MjkyYzk3NmU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-11-03T18:22:34Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-11-21T21:18:08Z"}, "message": "unicode: Add stability attributes to u_char\n\nFree functions deprecated. UnicodeChar experimental pending\nfinal decisions about prelude.", "tree": {"sha": "aea21bde4cc3ff6961c39be9fc5a10f45438f821", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aea21bde4cc3ff6961c39be9fc5a10f45438f821"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76ddd2b1547dd461d0487233a0a19674292c976e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76ddd2b1547dd461d0487233a0a19674292c976e", "html_url": "https://github.com/rust-lang/rust/commit/76ddd2b1547dd461d0487233a0a19674292c976e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76ddd2b1547dd461d0487233a0a19674292c976e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6ee804b632ee03679d6de682841fc7785ef4fbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ee804b632ee03679d6de682841fc7785ef4fbb", "html_url": "https://github.com/rust-lang/rust/commit/d6ee804b632ee03679d6de682841fc7785ef4fbb"}], "stats": {"total": 141, "additions": 82, "deletions": 59}, "files": [{"sha": "ed86ad52bb5d4d8089df5fc6fa432db276bd5d41", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76ddd2b1547dd461d0487233a0a19674292c976e/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ddd2b1547dd461d0487233a0a19674292c976e/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=76ddd2b1547dd461d0487233a0a19674292c976e", "patch": "@@ -26,7 +26,6 @@ pub use self::Alignment::*;\n pub use self::Flag::*;\n pub use self::Count::*;\n \n-use std::char;\n use std::str;\n use std::string;\n \n@@ -221,7 +220,7 @@ impl<'a> Parser<'a> {\n     fn ws(&mut self) {\n         loop {\n             match self.cur.clone().next() {\n-                Some((_, c)) if char::is_whitespace(c) => { self.cur.next(); }\n+                Some((_, c)) if c.is_whitespace() => { self.cur.next(); }\n                 Some(..) | None => { return }\n             }\n         }\n@@ -261,7 +260,7 @@ impl<'a> Parser<'a> {\n             Some(i) => { ArgumentIs(i) }\n             None => {\n                 match self.cur.clone().next() {\n-                    Some((_, c)) if char::is_alphabetic(c) => {\n+                    Some((_, c)) if c.is_alphabetic() => {\n                         ArgumentNamed(self.word())\n                     }\n                     _ => ArgumentNext\n@@ -384,7 +383,7 @@ impl<'a> Parser<'a> {\n     /// characters.\n     fn word(&mut self) -> &'a str {\n         let start = match self.cur.clone().next() {\n-            Some((pos, c)) if char::is_XID_start(c) => {\n+            Some((pos, c)) if c.is_XID_start() => {\n                 self.cur.next();\n                 pos\n             }\n@@ -393,7 +392,7 @@ impl<'a> Parser<'a> {\n         let mut end;\n         loop {\n             match self.cur.clone().next() {\n-                Some((_, c)) if char::is_XID_continue(c) => {\n+                Some((_, c)) if c.is_XID_continue() => {\n                     self.cur.next();\n                 }\n                 Some((pos, _)) => { end = pos; break }"}, {"sha": "a182f582b5f34bcd54d0aec013f5933f114e736d", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76ddd2b1547dd461d0487233a0a19674292c976e/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ddd2b1547dd461d0487233a0a19674292c976e/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=76ddd2b1547dd461d0487233a0a19674292c976e", "patch": "@@ -886,7 +886,7 @@ fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n     }\n \n     let machine: |&mut bool, (uint, char)| -> bool = |cont, (i, c)| {\n-        let whitespace = if ::std::char::is_whitespace(c) { Ws }       else { Cr };\n+        let whitespace = if c.is_whitespace() { Ws }       else { Cr };\n         let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n \n         state = match (state, whitespace, limit) {"}, {"sha": "db9ebac163c737a85a86cf9a940942e6bfc72c0d", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76ddd2b1547dd461d0487233a0a19674292c976e/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ddd2b1547dd461d0487233a0a19674292c976e/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=76ddd2b1547dd461d0487233a0a19674292c976e", "patch": "@@ -27,7 +27,6 @@ use util::common::time;\n use util::ppaux;\n use util::sha2::{Digest, Sha256};\n \n-use std::char;\n use std::io::fs::PathExtensions;\n use std::io::{fs, TempDir, Command};\n use std::io;\n@@ -272,7 +271,7 @@ pub fn sanitize(s: &str) -> String {\n     // Underscore-qualify anything that didn't start as an ident.\n     if result.len() > 0u &&\n         result.as_bytes()[0] != '_' as u8 &&\n-        ! char::is_XID_start(result.as_bytes()[0] as char) {\n+        ! (result.as_bytes()[0] as char).is_XID_start() {\n         return format!(\"_{}\", result.as_slice());\n     }\n "}, {"sha": "63007cf15c651da3e9363edfac647f536ab53820", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76ddd2b1547dd461d0487233a0a19674292c976e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ddd2b1547dd461d0487233a0a19674292c976e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=76ddd2b1547dd461d0487233a0a19674292c976e", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::cell::RefCell;\n-use std::char;\n use std::dynamic_lib::DynamicLibrary;\n use std::io::{Command, TempDir};\n use std::io;\n@@ -300,8 +299,8 @@ impl Collector {\n             // we use these headings as test names, so it's good if\n             // they're valid identifiers.\n             let name = name.chars().enumerate().map(|(i, c)| {\n-                    if (i == 0 && char::is_XID_start(c)) ||\n-                        (i != 0 && char::is_XID_continue(c)) {\n+                    if (i == 0 && c.is_XID_start()) ||\n+                        (i != 0 && c.is_XID_continue()) {\n                         c\n                     } else {\n                         '_'"}, {"sha": "9b3e25c5851c9a10f94dfc59025312d2782dd65d", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76ddd2b1547dd461d0487233a0a19674292c976e/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ddd2b1547dd461d0487233a0a19674292c976e/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=76ddd2b1547dd461d0487233a0a19674292c976e", "patch": "@@ -1385,7 +1385,7 @@ fn ident_start(c: Option<char>) -> bool {\n     (c >= 'a' && c <= 'z')\n         || (c >= 'A' && c <= 'Z')\n         || c == '_'\n-        || (c > '\\x7f' && char::is_XID_start(c))\n+        || (c > '\\x7f' && c.is_XID_start())\n }\n \n fn ident_continue(c: Option<char>) -> bool {\n@@ -1395,7 +1395,7 @@ fn ident_continue(c: Option<char>) -> bool {\n         || (c >= 'A' && c <= 'Z')\n         || (c >= '0' && c <= '9')\n         || c == '_'\n-        || (c > '\\x7f' && char::is_XID_continue(c))\n+        || (c > '\\x7f' && c.is_XID_continue())\n }\n \n #[cfg(test)]"}, {"sha": "f347ab6a21e22098ffe30e017965e9de7d02d144", "filename": "src/libunicode/u_char.rs", "status": "modified", "additions": 64, "deletions": 39, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/76ddd2b1547dd461d0487233a0a19674292c976e/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ddd2b1547dd461d0487233a0a19674292c976e/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=76ddd2b1547dd461d0487233a0a19674292c976e", "patch": "@@ -20,12 +20,9 @@ use tables::{derived_property, property, general_category, conversions, charwidt\n \n /// Returns whether the specified `char` is considered a Unicode alphabetic\n /// code point\n+#[deprecated = \"use UnicodeChar::is_alphabetic\"]\n pub fn is_alphabetic(c: char) -> bool {\n-    match c {\n-        'a' ... 'z' | 'A' ... 'Z' => true,\n-        c if c > '\\x7f' => derived_property::Alphabetic(c),\n-        _ => false\n-    }\n+    c.is_alphabetic()\n }\n \n /// Returns whether the specified `char` satisfies the 'XID_Start' Unicode property\n@@ -34,6 +31,7 @@ pub fn is_alphabetic(c: char) -> bool {\n /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n /// mostly similar to ID_Start but modified for closure under NFKx.\n #[allow(non_snake_case)]\n+#[deprecated = \"use UnicodeChar::is_XID_start\"]\n pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }\n \n /// Returns whether the specified `char` satisfies the 'XID_Continue' Unicode property\n@@ -42,6 +40,7 @@ pub fn is_XID_start(c: char) -> bool    { derived_property::XID_Start(c) }\n /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n #[allow(non_snake_case)]\n+#[deprecated = \"use UnicodeChar::is_XID_continue\"]\n pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n \n ///\n@@ -50,12 +49,9 @@ pub fn is_XID_continue(c: char) -> bool { derived_property::XID_Continue(c) }\n /// This is defined according to the terms of the Unicode Derived Core Property 'Lowercase'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_lowercase\"]\n pub fn is_lowercase(c: char) -> bool {\n-    match c {\n-        'a' ... 'z' => true,\n-        c if c > '\\x7f' => derived_property::Lowercase(c),\n-        _ => false\n-    }\n+    c.is_lowercase()\n }\n \n ///\n@@ -64,12 +60,9 @@ pub fn is_lowercase(c: char) -> bool {\n /// This is defined according to the terms of the Unicode Derived Core Property 'Uppercase'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_uppercase\"]\n pub fn is_uppercase(c: char) -> bool {\n-    match c {\n-        'A' ... 'Z' => true,\n-        c if c > '\\x7f' => derived_property::Uppercase(c),\n-        _ => false\n-    }\n+    c.is_uppercase()\n }\n \n ///\n@@ -78,12 +71,9 @@ pub fn is_uppercase(c: char) -> bool {\n /// Whitespace is defined in terms of the Unicode Property 'White_Space'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_whitespace\"]\n pub fn is_whitespace(c: char) -> bool {\n-    match c {\n-        ' ' | '\\x09' ... '\\x0d' => true,\n-        c if c > '\\x7f' => property::White_Space(c),\n-        _ => false\n-    }\n+    c.is_whitespace()\n }\n \n ///\n@@ -93,9 +83,9 @@ pub fn is_whitespace(c: char) -> bool {\n /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_alphanumeric\"]\n pub fn is_alphanumeric(c: char) -> bool {\n-    is_alphabetic(c)\n-        || is_digit(c)\n+    c.is_alphanumeric()\n }\n \n ///\n@@ -105,16 +95,14 @@ pub fn is_alphanumeric(c: char) -> bool {\n /// 'Cc'.\n ///\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_control\"]\n pub fn is_control(c: char) -> bool { general_category::Cc(c) }\n \n /// Indicates whether the `char` is numeric (Nd, Nl, or No)\n #[inline]\n+#[deprecated = \"use UnicodeChar::is_numeric\"]\n pub fn is_digit(c: char) -> bool {\n-    match c {\n-        '0' ... '9' => true,\n-        c if c > '\\x7f' => general_category::N(c),\n-        _ => false\n-    }\n+    c.is_numeric()\n }\n \n /// Convert a char to its uppercase equivalent\n@@ -132,6 +120,7 @@ pub fn is_digit(c: char) -> bool {\n ///\n /// Returns the char itself if no conversion was made\n #[inline]\n+#[deprecated = \"use UnicodeChar::to_uppercase\"]\n pub fn to_uppercase(c: char) -> char {\n     conversions::to_upper(c)\n }\n@@ -145,6 +134,7 @@ pub fn to_uppercase(c: char) -> char {\n ///\n /// Returns the char itself if no conversion if possible\n #[inline]\n+#[deprecated = \"use UnicodeChar::to_lowercase\"]\n pub fn to_lowercase(c: char) -> char {\n     conversions::to_lower(c)\n }\n@@ -158,11 +148,13 @@ pub fn to_lowercase(c: char) -> char {\n /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n /// recommends that these characters be treated as 1 column (i.e.,\n /// `is_cjk` = `false`) if the context cannot be reliably determined.\n+#[deprecated = \"use UnicodeChar::width\"]\n pub fn width(c: char, is_cjk: bool) -> Option<uint> {\n     charwidth::width(c, is_cjk)\n }\n \n /// Useful functions for Unicode characters.\n+#[experimental = \"pending prelude organization\"]\n pub trait UnicodeChar {\n     /// Returns whether the specified character is considered a Unicode\n     /// alphabetic code point.\n@@ -265,29 +257,62 @@ pub trait UnicodeChar {\n     fn width(self, is_cjk: bool) -> Option<uint>;\n }\n \n+#[experimental = \"pending prelude organization\"]\n impl UnicodeChar for char {\n-    fn is_alphabetic(self) -> bool { is_alphabetic(self) }\n+    fn is_alphabetic(self) -> bool {\n+        match self {\n+            'a' ... 'z' | 'A' ... 'Z' => true,\n+            c if c > '\\x7f' => derived_property::Alphabetic(c),\n+            _ => false\n+        }\n+    }\n \n-    fn is_XID_start(self) -> bool { is_XID_start(self) }\n+    fn is_XID_start(self) -> bool { derived_property::XID_Start(self) }\n \n-    fn is_XID_continue(self) -> bool { is_XID_continue(self) }\n+    fn is_XID_continue(self) -> bool { derived_property::XID_Continue(self) }\n \n-    fn is_lowercase(self) -> bool { is_lowercase(self) }\n+    fn is_lowercase(self) -> bool {\n+        match self {\n+            'a' ... 'z' => true,\n+            c if c > '\\x7f' => derived_property::Lowercase(c),\n+            _ => false\n+        }\n+    }\n \n-    fn is_uppercase(self) -> bool { is_uppercase(self) }\n+    fn is_uppercase(self) -> bool {\n+        match self {\n+            'A' ... 'Z' => true,\n+            c if c > '\\x7f' => derived_property::Uppercase(c),\n+            _ => false\n+        }\n+    }\n \n-    fn is_whitespace(self) -> bool { is_whitespace(self) }\n+    fn is_whitespace(self) -> bool {\n+        match self {\n+            ' ' | '\\x09' ... '\\x0d' => true,\n+            c if c > '\\x7f' => property::White_Space(c),\n+            _ => false\n+        }\n+    }\n \n-    fn is_alphanumeric(self) -> bool { is_alphanumeric(self) }\n+    fn is_alphanumeric(self) -> bool {\n+        self.is_alphabetic() || self.is_numeric()\n+    }\n \n-    fn is_control(self) -> bool { is_control(self) }\n+    fn is_control(self) -> bool { general_category::Cc(self) }\n \n-    fn is_numeric(self) -> bool { is_digit(self) }\n+    fn is_numeric(self) -> bool {\n+        match self {\n+            '0' ... '9' => true,\n+            c if c > '\\x7f' => general_category::N(c),\n+            _ => false\n+        }\n+    }\n \n-    fn to_lowercase(self) -> char { to_lowercase(self) }\n+    fn to_lowercase(self) -> char { conversions::to_lower(self) }\n \n-    fn to_uppercase(self) -> char { to_uppercase(self) }\n+    fn to_uppercase(self) -> char { conversions::to_upper(self) }\n \n     #[experimental = \"needs expert opinion. is_cjk flag stands out as ugly\"]\n-    fn width(self, is_cjk: bool) -> Option<uint> { width(self, is_cjk) }\n+    fn width(self, is_cjk: bool) -> Option<uint> { charwidth::width(self, is_cjk) }\n }"}, {"sha": "56b1f0907d5a4c4c4338042f23d87fc092316936", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/76ddd2b1547dd461d0487233a0a19674292c976e/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ddd2b1547dd461d0487233a0a19674292c976e/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=76ddd2b1547dd461d0487233a0a19674292c976e", "patch": "@@ -24,13 +24,13 @@ use core::iter::{Filter, AdditiveIterator, Iterator, DoubleEndedIterator};\n use core::kinds::Sized;\n use core::option::{Option, None, Some};\n use core::str::{CharSplits, StrPrelude};\n-use u_char;\n use u_char::UnicodeChar;\n use tables::grapheme::GraphemeCat;\n \n /// An iterator over the words of a string, separated by a sequence of whitespace\n+/// FIXME: This should be opaque\n pub type Words<'a> =\n-    Filter<'a, &'a str, CharSplits<'a, extern \"Rust\" fn(char) -> bool>>;\n+    Filter<'a, &'a str, CharSplits<'a, |char|:'a -> bool>>;\n \n /// Methods for Unicode string slices\n pub trait UnicodeStrPrelude for Sized? {\n@@ -143,14 +143,15 @@ impl UnicodeStrPrelude for str {\n \n     #[inline]\n     fn words(&self) -> Words {\n-        self.split(u_char::is_whitespace).filter(|s| !s.is_empty())\n+        let f = |c: char| c.is_whitespace();\n+        self.split(f).filter(|s| !s.is_empty())\n     }\n \n     #[inline]\n-    fn is_whitespace(&self) -> bool { self.chars().all(u_char::is_whitespace) }\n+    fn is_whitespace(&self) -> bool { self.chars().all(|c| c.is_whitespace()) }\n \n     #[inline]\n-    fn is_alphanumeric(&self) -> bool { self.chars().all(u_char::is_alphanumeric) }\n+    fn is_alphanumeric(&self) -> bool { self.chars().all(|c| c.is_alphanumeric()) }\n \n     #[inline]\n     fn width(&self, is_cjk: bool) -> uint {\n@@ -164,12 +165,12 @@ impl UnicodeStrPrelude for str {\n \n     #[inline]\n     fn trim_left(&self) -> &str {\n-        self.trim_left_chars(u_char::is_whitespace)\n+        self.trim_left_chars(|c: char| c.is_whitespace())\n     }\n \n     #[inline]\n     fn trim_right(&self) -> &str {\n-        self.trim_right_chars(u_char::is_whitespace)\n+        self.trim_right_chars(|c: char| c.is_whitespace())\n     }\n }\n "}]}