{"sha": "4cbc0035776d2d56a58f3d077cfd8d292593c5ed", "node_id": "C_kwDOAAsO6NoAKDRjYmMwMDM1Nzc2ZDJkNTZhNThmM2QwNzdjZmQ4ZDI5MjU5M2M1ZWQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-04T18:41:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-04T18:41:33Z"}, "message": "Rollup merge of #95467 - ChrisDenton:async-read-pipe, r=joshtriplett\n\nWindows: Synchronize asynchronous pipe reads and writes\n\nOn Windows, the pipes used for spawned processes are opened for asynchronous access but `read` and `write` are done using the standard methods that assume synchronous access. This means that the buffer (and variables on the stack) may be read/written to after the function returns.\n\nThis PR ensures reads/writes complete before returning. Note that this only applies to pipes we create and does not affect the standard file read/write methods.\n\nFixes #95411", "tree": {"sha": "728ce222b0728e2060a37893602fa8588ec06e3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/728ce222b0728e2060a37893602fa8588ec06e3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cbc0035776d2d56a58f3d077cfd8d292593c5ed", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiSzvdCRBK7hj4Ov3rIwAACsUIAEp2ls3BGgGSFu2J1zCTXkuA\nlqmqOm8fHXZH1u41U2c7EBHMiMA/FzhQvtjhD28/tvkeZ3OLFx06knjMuSYN1jps\nDyMFbgG52Uq5O2YfE/eAyArGc0THZL7trX2lPDxefdjY/nnf6uaFL0Xy4C9Fn9U8\n5lxSdZhF83L5MeGK0hf+gCMIg9z22W4WSnErXVnUscza2JeYM2/RA1VTu25R4+xn\nrEWvduEtHg6axrMKZriIw3Pf81/DQbpxZJmkzE19UZ72vraZpYMMJuylAzFLEVrp\nEq37aui6jb7VAnzsYxKZQNajTq3hFOh+5vsgJoJ1tDtqrqLy7qyK2U9KMSRqBEM=\n=oGie\n-----END PGP SIGNATURE-----\n", "payload": "tree 728ce222b0728e2060a37893602fa8588ec06e3a\nparent 4d7d9d422b90c81b9e1ca347a1c139622d950f11\nparent cbbcd875e1074c244aed118d2582030ad1fa52a6\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1649097693 +0200\ncommitter GitHub <noreply@github.com> 1649097693 +0200\n\nRollup merge of #95467 - ChrisDenton:async-read-pipe, r=joshtriplett\n\nWindows: Synchronize asynchronous pipe reads and writes\n\nOn Windows, the pipes used for spawned processes are opened for asynchronous access but `read` and `write` are done using the standard methods that assume synchronous access. This means that the buffer (and variables on the stack) may be read/written to after the function returns.\n\nThis PR ensures reads/writes complete before returning. Note that this only applies to pipes we create and does not affect the standard file read/write methods.\n\nFixes #95411\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cbc0035776d2d56a58f3d077cfd8d292593c5ed", "html_url": "https://github.com/rust-lang/rust/commit/4cbc0035776d2d56a58f3d077cfd8d292593c5ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cbc0035776d2d56a58f3d077cfd8d292593c5ed/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d7d9d422b90c81b9e1ca347a1c139622d950f11", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d7d9d422b90c81b9e1ca347a1c139622d950f11", "html_url": "https://github.com/rust-lang/rust/commit/4d7d9d422b90c81b9e1ca347a1c139622d950f11"}, {"sha": "cbbcd875e1074c244aed118d2582030ad1fa52a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbbcd875e1074c244aed118d2582030ad1fa52a6", "html_url": "https://github.com/rust-lang/rust/commit/cbbcd875e1074c244aed118d2582030ad1fa52a6"}], "stats": {"total": 142, "additions": 140, "deletions": 2}, "files": [{"sha": "0ecc2a5cfdad51776d71f65e8ed2c9623248b2f8", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc0035776d2d56a58f3d077cfd8d292593c5ed/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc0035776d2d56a58f3d077cfd8d292593c5ed/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=4cbc0035776d2d56a58f3d077cfd8d292593c5ed", "patch": "@@ -326,6 +326,12 @@ impl Default for IO_STATUS_BLOCK {\n     }\n }\n \n+pub type LPOVERLAPPED_COMPLETION_ROUTINE = unsafe extern \"system\" fn(\n+    dwErrorCode: DWORD,\n+    dwNumberOfBytesTransfered: DWORD,\n+    lpOverlapped: *mut OVERLAPPED,\n+);\n+\n #[repr(C)]\n #[cfg(not(target_pointer_width = \"64\"))]\n pub struct WSADATA {\n@@ -891,6 +897,7 @@ extern \"system\" {\n     pub fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n     pub fn SwitchToThread() -> BOOL;\n     pub fn Sleep(dwMilliseconds: DWORD);\n+    pub fn SleepEx(dwMilliseconds: DWORD, bAlertable: BOOL) -> DWORD;\n     pub fn GetProcessId(handle: HANDLE) -> DWORD;\n     pub fn CopyFileExW(\n         lpExistingFileName: LPCWSTR,\n@@ -957,13 +964,27 @@ extern \"system\" {\n         lpNumberOfBytesRead: LPDWORD,\n         lpOverlapped: LPOVERLAPPED,\n     ) -> BOOL;\n+    pub fn ReadFileEx(\n+        hFile: BorrowedHandle<'_>,\n+        lpBuffer: LPVOID,\n+        nNumberOfBytesToRead: DWORD,\n+        lpOverlapped: LPOVERLAPPED,\n+        lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,\n+    ) -> BOOL;\n     pub fn WriteFile(\n         hFile: BorrowedHandle<'_>,\n         lpBuffer: LPVOID,\n         nNumberOfBytesToWrite: DWORD,\n         lpNumberOfBytesWritten: LPDWORD,\n         lpOverlapped: LPOVERLAPPED,\n     ) -> BOOL;\n+    pub fn WriteFileEx(\n+        hFile: BorrowedHandle<'_>,\n+        lpBuffer: LPVOID,\n+        nNumberOfBytesToWrite: DWORD,\n+        lpOverlapped: LPOVERLAPPED,\n+        lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE,\n+    ) -> BOOL;\n     pub fn CloseHandle(hObject: HANDLE) -> BOOL;\n     pub fn MoveFileExW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, dwFlags: DWORD)\n     -> BOOL;"}, {"sha": "df4f1b24eec261d3213b1e35d9b50d20999ec745", "filename": "library/std/src/sys/windows/pipe.rs", "status": "modified", "additions": 119, "deletions": 2, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/4cbc0035776d2d56a58f3d077cfd8d292593c5ed/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cbc0035776d2d56a58f3d077cfd8d292593c5ed/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs?ref=4cbc0035776d2d56a58f3d077cfd8d292593c5ed", "patch": "@@ -173,6 +173,15 @@ fn random_number() -> usize {\n     }\n }\n \n+// Abstracts over `ReadFileEx` and `WriteFileEx`\n+type AlertableIoFn = unsafe extern \"system\" fn(\n+    BorrowedHandle<'_>,\n+    c::LPVOID,\n+    c::DWORD,\n+    c::LPOVERLAPPED,\n+    c::LPOVERLAPPED_COMPLETION_ROUTINE,\n+) -> c::BOOL;\n+\n impl AnonPipe {\n     pub fn handle(&self) -> &Handle {\n         &self.inner\n@@ -182,7 +191,19 @@ impl AnonPipe {\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.inner.read(buf)\n+        let result = unsafe {\n+            let len = crate::cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;\n+            self.alertable_io_internal(c::ReadFileEx, buf.as_mut_ptr() as _, len)\n+        };\n+\n+        match result {\n+            // The special treatment of BrokenPipe is to deal with Windows\n+            // pipe semantics, which yields this error when *reading* from\n+            // a pipe after the other end has closed; we interpret that as\n+            // EOF on the pipe.\n+            Err(ref e) if e.kind() == io::ErrorKind::BrokenPipe => Ok(0),\n+            _ => result,\n+        }\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n@@ -195,7 +216,10 @@ impl AnonPipe {\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        self.inner.write(buf)\n+        unsafe {\n+            let len = crate::cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;\n+            self.alertable_io_internal(c::WriteFileEx, buf.as_ptr() as _, len)\n+        }\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n@@ -206,6 +230,99 @@ impl AnonPipe {\n     pub fn is_write_vectored(&self) -> bool {\n         self.inner.is_write_vectored()\n     }\n+\n+    /// Synchronizes asynchronous reads or writes using our anonymous pipe.\n+    ///\n+    /// This is a wrapper around [`ReadFileEx`] or [`WriteFileEx`] that uses\n+    /// [Asynchronous Procedure Call] (APC) to synchronize reads or writes.\n+    ///\n+    /// Note: This should not be used for handles we don't create.\n+    ///\n+    /// # Safety\n+    ///\n+    /// `buf` must be a pointer to a buffer that's valid for reads or writes\n+    /// up to `len` bytes. The `AlertableIoFn` must be either `ReadFileEx` or `WriteFileEx`\n+    ///\n+    /// [`ReadFileEx`]: https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfileex\n+    /// [`WriteFileEx`]: https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefileex\n+    /// [Asynchronous Procedure Call]: https://docs.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls\n+    unsafe fn alertable_io_internal(\n+        &self,\n+        io: AlertableIoFn,\n+        buf: c::LPVOID,\n+        len: c::DWORD,\n+    ) -> io::Result<usize> {\n+        // Use \"alertable I/O\" to synchronize the pipe I/O.\n+        // This has four steps.\n+        //\n+        // STEP 1: Start the asynchronous I/O operation.\n+        //         This simply calls either `ReadFileEx` or `WriteFileEx`,\n+        //         giving it a pointer to the buffer and callback function.\n+        //\n+        // STEP 2: Enter an alertable state.\n+        //         The callback set in step 1 will not be called until the thread\n+        //         enters an \"alertable\" state. This can be done using `SleepEx`.\n+        //\n+        // STEP 3: The callback\n+        //         Once the I/O is complete and the thread is in an alertable state,\n+        //         the callback will be run on the same thread as the call to\n+        //         `ReadFileEx` or `WriteFileEx` done in step 1.\n+        //         In the callback we simply set the result of the async operation.\n+        //\n+        // STEP 4: Return the result.\n+        //         At this point we'll have a result from the callback function\n+        //         and can simply return it. Note that we must not return earlier,\n+        //         while the I/O is still in progress.\n+\n+        // The result that will be set from the asynchronous callback.\n+        let mut async_result: Option<AsyncResult> = None;\n+        struct AsyncResult {\n+            error: u32,\n+            transfered: u32,\n+        }\n+\n+        // STEP 3: The callback.\n+        unsafe extern \"system\" fn callback(\n+            dwErrorCode: u32,\n+            dwNumberOfBytesTransfered: u32,\n+            lpOverlapped: *mut c::OVERLAPPED,\n+        ) {\n+            // Set `async_result` using a pointer smuggled through `hEvent`.\n+            let result = AsyncResult { error: dwErrorCode, transfered: dwNumberOfBytesTransfered };\n+            *(*lpOverlapped).hEvent.cast::<Option<AsyncResult>>() = Some(result);\n+        }\n+\n+        // STEP 1: Start the I/O operation.\n+        let mut overlapped: c::OVERLAPPED = crate::mem::zeroed();\n+        // `hEvent` is unused by `ReadFileEx` and `WriteFileEx`.\n+        // Therefore the documentation suggests using it to smuggle a pointer to the callback.\n+        overlapped.hEvent = &mut async_result as *mut _ as *mut _;\n+\n+        // Asynchronous read of the pipe.\n+        // If successful, `callback` will be called once it completes.\n+        let result = io(self.inner.as_handle(), buf, len, &mut overlapped, callback);\n+        if result == c::FALSE {\n+            // We can return here because the call failed.\n+            // After this we must not return until the I/O completes.\n+            return Err(io::Error::last_os_error());\n+        }\n+\n+        // Wait indefinitely for the result.\n+        let result = loop {\n+            // STEP 2: Enter an alertable state.\n+            // The second parameter of `SleepEx` is used to make this sleep alertable.\n+            c::SleepEx(c::INFINITE, c::TRUE);\n+            if let Some(result) = async_result {\n+                break result;\n+            }\n+        };\n+        // STEP 4: Return the result.\n+        // `async_result` is always `Some` at this point\n+        match result.error {\n+            c::ERROR_SUCCESS => Ok(result.transfered as usize),\n+            error => Err(io::Error::from_raw_os_error(error as _)),\n+        }\n+    }\n }\n \n pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {"}]}