{"sha": "83874d0ee77264a82a59513fa4362e86c39034c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzODc0ZDBlZTc3MjY0YTgyYTU5NTEzZmE0MzYyZTg2YzM5MDM0YzQ=", "commit": {"author": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2020-04-12T13:23:07Z"}, "committer": {"name": "Philipp Hansch", "email": "dev@phansch.net", "date": "2020-04-12T13:23:07Z"}, "message": "Make use of Option/Result diagnostic items", "tree": {"sha": "540aad2ce4f500ab0799c757756be99cc310b822", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/540aad2ce4f500ab0799c757756be99cc310b822"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83874d0ee77264a82a59513fa4362e86c39034c4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE6VFioMHrom999LRAK0OZxL9Ny94FAl6TFkgACgkQK0OZxL9N\ny97hAw//ddWyZs+Tm46LNLV1rEngbyF39uITv7nCuuPMrcLEPqeC5TJijYEQDxRS\n25UcBZJCnvqSSIJwWGcF95l6gFLOzyFZh9it62BL4IuKdqmw33jrjt6cU0RpXRHH\nHoMnBdAgyaygnvEc+daNagSU7+h6DqIXXCt+oxe0sNLnEA2isdVtQ8u/F2xIZp4B\nX4RMhdzCepxEeVBZBKCDKqGJry8Gb5ELYCpnhigG8oyP1xKtDwPmtafqwuBNIPWx\nSh5h/zYIEndw2xjuKV+Kigj1V3hkMj2lK+A36keFHMIkK+8SMy7SZsNxkFYSbCfA\nRX3/UZQQDLo9qFpVU2Hmog8zGhjHW1DuliErMk63Y1CdHptARwm80d33YW/RFufC\nTmkDcX04VcuUVRC6j4Bn8vAtX1d0+SnspwHcj7QmLBuKN/N0a1S3tjvp/c+B8Z7H\nruY9mL/tS0ZGmcSB1bCUIijllKrMg1iqEZXWWAzj3NN3bABQ8HySuWXpSWlwOvwG\nna8Q39htrnRzEVGpjlZW43eFzchjngF8GQdV4ZunrKuLLpIN55z+1B2ylcA3dEb8\nOU28v3pPF0jchOTzhfGp138WL5t3Sy2hgr2MYV09H16FvrTgeJPk30McE8B513rl\nJ3XHljlIDoknKxJN7zF7co5XCmudDQrvR+Alvb1erYBqxRQUIEA=\n=kNEY\n-----END PGP SIGNATURE-----", "payload": "tree 540aad2ce4f500ab0799c757756be99cc310b822\nparent 79982a2813c88e1426b17376b2a4b2bec352ee59\nauthor Philipp Hansch <dev@phansch.net> 1586697787 +0200\ncommitter Philipp Hansch <dev@phansch.net> 1586697787 +0200\n\nMake use of Option/Result diagnostic items\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83874d0ee77264a82a59513fa4362e86c39034c4", "html_url": "https://github.com/rust-lang/rust/commit/83874d0ee77264a82a59513fa4362e86c39034c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83874d0ee77264a82a59513fa4362e86c39034c4/comments", "author": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "phansch", "id": 2042399, "node_id": "MDQ6VXNlcjIwNDIzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2042399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/phansch", "html_url": "https://github.com/phansch", "followers_url": "https://api.github.com/users/phansch/followers", "following_url": "https://api.github.com/users/phansch/following{/other_user}", "gists_url": "https://api.github.com/users/phansch/gists{/gist_id}", "starred_url": "https://api.github.com/users/phansch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/phansch/subscriptions", "organizations_url": "https://api.github.com/users/phansch/orgs", "repos_url": "https://api.github.com/users/phansch/repos", "events_url": "https://api.github.com/users/phansch/events{/privacy}", "received_events_url": "https://api.github.com/users/phansch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79982a2813c88e1426b17376b2a4b2bec352ee59", "url": "https://api.github.com/repos/rust-lang/rust/commits/79982a2813c88e1426b17376b2a4b2bec352ee59", "html_url": "https://github.com/rust-lang/rust/commit/79982a2813c88e1426b17376b2a4b2bec352ee59"}], "stats": {"total": 100, "additions": 45, "deletions": 55}, "files": [{"sha": "f9d0f1e4fe7892b19facff78fd8681bcd43dc229", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=83874d0ee77264a82a59513fa4362e86c39034c4", "patch": "@@ -1,5 +1,5 @@\n use crate::utils::{\n-    get_trait_def_id, implements_trait, in_macro, match_type, paths, snippet_opt, span_lint_and_sugg,\n+    get_trait_def_id, is_type_diagnostic_item, implements_trait, in_macro, paths, snippet_opt, span_lint_and_sugg,\n     span_lint_and_then, SpanlessEq,\n };\n use if_chain::if_chain;\n@@ -249,7 +249,7 @@ fn simplify_not(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<String> {\n         },\n         ExprKind::MethodCall(path, _, args) if args.len() == 1 => {\n             let type_of_receiver = cx.tables.expr_ty(&args[0]);\n-            if !match_type(cx, type_of_receiver, &paths::OPTION) && !match_type(cx, type_of_receiver, &paths::RESULT) {\n+            if !is_type_diagnostic_item(cx, type_of_receiver, sym!(option_type)) && !is_type_diagnostic_item(cx, type_of_receiver, sym!(result_type)) {\n                 return None;\n             }\n             METHODS_WITH_NEGATION"}, {"sha": "50c8bbd39ab001d38f4549ca09330365b25801cc", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=83874d0ee77264a82a59513fa4362e86c39034c4", "patch": "@@ -9,7 +9,7 @@ use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_span::BytePos;\n \n-use crate::utils::{match_type, paths, snippet_opt, span_lint_and_help, LimitStack};\n+use crate::utils::{snippet_opt, span_lint_and_help, LimitStack, is_type_diagnostic_item};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for methods with high cognitive complexity.\n@@ -61,7 +61,7 @@ impl CognitiveComplexity {\n         helper.visit_expr(expr);\n         let CCHelper { cc, returns } = helper;\n         let ret_ty = cx.tables.node_type(expr.hir_id);\n-        let ret_adjust = if match_type(cx, ret_ty, &paths::RESULT) {\n+        let ret_adjust = if is_type_diagnostic_item(cx, ret_ty, sym!(result_type)) {\n             returns\n         } else {\n             #[allow(clippy::integer_division)]"}, {"sha": "926bd8ed001f631130ddcdd63eaa7a5b61f868ab", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=83874d0ee77264a82a59513fa4362e86c39034c4", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{implements_trait, is_entrypoint_fn, match_type, paths, return_ty, span_lint};\n+use crate::utils::{implements_trait, is_entrypoint_fn, is_type_diagnostic_item, return_ty, span_lint};\n use if_chain::if_chain;\n use itertools::Itertools;\n use rustc_ast::ast::{AttrKind, Attribute};\n@@ -217,7 +217,7 @@ fn lint_for_missing_headers<'a, 'tcx>(\n         );\n     }\n     if !headers.errors {\n-        if match_type(cx, return_ty(cx, hir_id), &paths::RESULT) {\n+        if is_type_diagnostic_item(cx, return_ty(cx, hir_id), sym!(result_type)) {\n             span_lint(\n                 cx,\n                 MISSING_ERRORS_DOC,\n@@ -235,7 +235,7 @@ fn lint_for_missing_headers<'a, 'tcx>(\n                 if let ty::Opaque(_, subs) = ret_ty.kind;\n                 if let Some(gen) = subs.types().next();\n                 if let ty::Generator(_, subs, _) = gen.kind;\n-                if match_type(cx, subs.as_generator().return_ty(), &paths::RESULT);\n+                if is_type_diagnostic_item(cx, subs.as_generator().return_ty(), sym!(result_type));\n                 then {\n                     span_lint(\n                         cx,"}, {"sha": "0aee84773dc11c94151eb3e57fffcc7cd8bb5d44", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=83874d0ee77264a82a59513fa4362e86c39034c4", "patch": "@@ -1,10 +1,10 @@\n-use crate::utils::paths::{BEGIN_PANIC, BEGIN_PANIC_FMT, FROM_TRAIT, OPTION, RESULT};\n-use crate::utils::{is_expn_of, match_def_path, method_chain_args, span_lint_and_then, walk_ptrs_ty};\n+use crate::utils::paths::{BEGIN_PANIC, BEGIN_PANIC_FMT, FROM_TRAIT};\n+use crate::utils::{is_expn_of, match_def_path, method_chain_args, span_lint_and_then, walk_ptrs_ty, is_type_diagnostic_item};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n \n@@ -76,7 +76,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n                 let reciever_ty = walk_ptrs_ty(self.tables.expr_ty(&arglists[0][0]));\n-                if match_type(self.lcx, reciever_ty, &OPTION) || match_type(self.lcx, reciever_ty, &RESULT) {\n+                if is_type_diagnostic_item(self.lcx, reciever_ty, sym!(option_type)) || is_type_diagnostic_item(self.lcx, reciever_ty, sym!(result_type)) {\n                     self.result.push(expr.span);\n                 }\n             }\n@@ -124,10 +124,3 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n         }\n     }\n }\n-\n-fn match_type(cx: &LateContext<'_, '_>, ty: Ty<'_>, path: &[&str]) -> bool {\n-    match ty.kind {\n-        ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n-        _ => false,\n-    }\n-}"}, {"sha": "9b13f7609247a26f122252b9d97ac34dbd1c8b08", "filename": "clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=83874d0ee77264a82a59513fa4362e86c39034c4", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{match_type, method_chain_args, paths, snippet_with_applicability, span_lint_and_sugg};\n+use crate::utils::{is_type_diagnostic_item, method_chain_args, snippet_with_applicability, span_lint_and_sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, MatchSource, PatKind, QPath};\n@@ -45,8 +45,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OkIfLet {\n             if let ExprKind::MethodCall(_, ok_span, ref result_types) = op.kind; //check is expr.ok() has type Result<T,E>.ok()\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.kind; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n-            let is_result_type = match_type(cx, cx.tables.expr_ty(&result_types[0]), &paths::RESULT);\n-            if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\" && is_result_type;\n+            if is_type_diagnostic_item(cx, cx.tables.expr_ty(&result_types[0]), sym!(result_type));\n+            if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;"}, {"sha": "6a4f86d7f0159f5a7ba2bd5ad947b1a49a910c61", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=83874d0ee77264a82a59513fa4362e86c39034c4", "patch": "@@ -1392,7 +1392,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>, e\n /// Checks for `for` loops over `Option`s and `Result`s.\n fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     let ty = cx.tables.expr_ty(arg);\n-    if match_type(cx, ty, &paths::OPTION) {\n+    if is_type_diagnostic_item(cx, ty, sym!(option_type)) {\n         span_lint_and_help(\n             cx,\n             FOR_LOOP_OVER_OPTION,\n@@ -1408,7 +1408,7 @@ fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n                 snippet(cx, arg.span, \"_\")\n             ),\n         );\n-    } else if match_type(cx, ty, &paths::RESULT) {\n+    } else if is_type_diagnostic_item(cx, ty, sym!(result_type)) {\n         span_lint_and_help(\n             cx,\n             FOR_LOOP_OVER_RESULT,"}, {"sha": "5c5cf8015f408e256d05dd66e90842e04fab53bd", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=83874d0ee77264a82a59513fa4362e86c39034c4", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::paths;\n use crate::utils::{\n-    is_copy, match_trait_method, match_type, remove_blocks, snippet_with_applicability, span_lint_and_sugg,\n+    is_copy, is_type_diagnostic_item, match_trait_method, remove_blocks, snippet_with_applicability, span_lint_and_sugg,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::Ident;\n@@ -52,7 +52,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n             if args.len() == 2;\n             if method.ident.as_str() == \"map\";\n             let ty = cx.tables.expr_ty(&args[0]);\n-            if match_type(cx, ty, &paths::OPTION) || match_trait_method(cx, e, &paths::ITERATOR);\n+            if is_type_diagnostic_item(cx, ty, sym!(option_type)) || match_trait_method(cx, e, &paths::ITERATOR);\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].kind;\n             let closure_body = cx.tcx.hir().body(body_id);\n             let closure_expr = remove_blocks(&closure_body.value);"}, {"sha": "ba10319ff46101bdbd2a47faa62c4f4228f80552", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=83874d0ee77264a82a59513fa4362e86c39034c4", "patch": "@@ -1,5 +1,4 @@\n-use crate::utils::paths;\n-use crate::utils::{iter_input_pats, match_type, method_chain_args, snippet, span_lint_and_then};\n+use crate::utils::{is_type_diagnostic_item, iter_input_pats, method_chain_args, snippet, span_lint_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -206,9 +205,9 @@ fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n fn lint_map_unit_fn(cx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr<'_>, map_args: &[hir::Expr<'_>]) {\n     let var_arg = &map_args[0];\n \n-    let (map_type, variant, lint) = if match_type(cx, cx.tables.expr_ty(var_arg), &paths::OPTION) {\n+    let (map_type, variant, lint) = if is_type_diagnostic_item(cx, cx.tables.expr_ty(var_arg), sym!(option_type)) {\n         (\"Option\", \"Some\", OPTION_MAP_UNIT_FN)\n-    } else if match_type(cx, cx.tables.expr_ty(var_arg), &paths::RESULT) {\n+    } else if is_type_diagnostic_item(cx, cx.tables.expr_ty(var_arg), sym!(result_type)) {\n         (\"Result\", \"Ok\", RESULT_MAP_UNIT_FN)\n     } else {\n         return;"}, {"sha": "f2678774c779cd32dbd366d71790de77899569bd", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=83874d0ee77264a82a59513fa4362e86c39034c4", "patch": "@@ -3,7 +3,7 @@ use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::is_unused;\n use crate::utils::{\n-    expr_block, get_arg_name, get_parent_expr, in_macro, indent_of, is_allowed, is_expn_of, is_refutable, is_wild,\n+    expr_block, get_arg_name, get_parent_expr, in_macro, indent_of, is_allowed, is_expn_of, is_refutable, is_type_diagnostic_item, is_wild,\n     match_qpath, match_type, match_var, multispan_sugg, remove_blocks, snippet, snippet_block,\n     snippet_with_applicability, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n     walk_ptrs_ty,\n@@ -642,7 +642,7 @@ fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr<'\n \n fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n     let ex_ty = walk_ptrs_ty(cx.tables.expr_ty(ex));\n-    if match_type(cx, ex_ty, &paths::RESULT) {\n+    if is_type_diagnostic_item(cx, ex_ty, sym!(result_type)) {\n         for arm in arms {\n             if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pat.kind {\n                 let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));"}, {"sha": "89a252630920796b7e1fb571248205fa1d8156fe", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=83874d0ee77264a82a59513fa4362e86c39034c4", "patch": "@@ -1836,9 +1836,9 @@ fn lint_expect_fun_call(\n     }\n \n     let receiver_type = cx.tables.expr_ty_adjusted(&args[0]);\n-    let closure_args = if match_type(cx, receiver_type, &paths::OPTION) {\n+    let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym!(option_type)) {\n         \"||\"\n-    } else if match_type(cx, receiver_type, &paths::RESULT) {\n+    } else if is_type_diagnostic_item(cx, receiver_type, sym!(result_type)) {\n         \"|_|\"\n     } else {\n         return;\n@@ -2067,7 +2067,7 @@ fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, source: &\n     if_chain! {\n         let source_type = cx.tables.expr_ty(source);\n         if let ty::Adt(def, substs) = source_type.kind;\n-        if match_def_path(cx, def.did, &paths::RESULT);\n+        if cx.tcx.is_diagnostic_item(sym!(result_type), def.did);\n         if match_type(cx, substs.type_at(0), &paths::CSTRING);\n         then {\n             span_lint_and_then(\n@@ -2395,9 +2395,9 @@ fn derefs_to_slice<'a, 'tcx>(\n fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&unwrap_args[0]));\n \n-    let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n         Some((OPTION_UNWRAP_USED, \"an Option\", \"None\"))\n-    } else if match_type(cx, obj_ty, &paths::RESULT) {\n+    } else if is_type_diagnostic_item(cx, obj_ty, sym!(result_type)) {\n         Some((RESULT_UNWRAP_USED, \"a Result\", \"Err\"))\n     } else {\n         None\n@@ -2422,9 +2422,9 @@ fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, unwrap_args: &[hi\n fn lint_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&expect_args[0]));\n \n-    let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n+    let mess = if is_type_diagnostic_item(cx, obj_ty, sym!(option_type)) {\n         Some((OPTION_EXPECT_USED, \"an Option\", \"None\"))\n-    } else if match_type(cx, obj_ty, &paths::RESULT) {\n+    } else if is_type_diagnostic_item(cx, obj_ty, sym!(result_type)) {\n         Some((RESULT_EXPECT_USED, \"a Result\", \"Err\"))\n     } else {\n         None\n@@ -2445,7 +2445,7 @@ fn lint_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, expect_args: &[hi\n fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n     if_chain! {\n         // lint if the caller of `ok()` is a `Result`\n-        if match_type(cx, cx.tables.expr_ty(&ok_args[0]), &paths::RESULT);\n+        if is_type_diagnostic_item(cx, cx.tables.expr_ty(&ok_args[0]), sym!(result_type));\n         let result_type = cx.tables.expr_ty(&ok_args[0]);\n         if let Some(error_type) = get_error_type(cx, result_type);\n         if has_debug_impl(error_type, cx);\n@@ -2491,8 +2491,8 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n     unwrap_args: &'tcx [hir::Expr<'_>],\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    let is_option = match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION);\n-    let is_result = match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::RESULT);\n+    let is_option = is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_args[0]), sym!(result_type));\n \n     if is_option || is_result {\n         // Don't make a suggestion that may fail to compile due to mutably borrowing\n@@ -2559,8 +2559,8 @@ fn lint_map_or_none<'a, 'tcx>(\n     expr: &'tcx hir::Expr<'_>,\n     map_or_args: &'tcx [hir::Expr<'_>],\n ) {\n-    let is_option = match_type(cx, cx.tables.expr_ty(&map_or_args[0]), &paths::OPTION);\n-    let is_result = match_type(cx, cx.tables.expr_ty(&map_or_args[0]), &paths::RESULT);\n+    let is_option = is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_or_args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_or_args[0]), sym!(result_type));\n \n     // There are two variants of this `map_or` lint:\n     // (1) using `map_or` as an adapter from `Result<T,E>` to `Option<T>`\n@@ -3210,7 +3210,6 @@ fn is_maybe_uninit_ty_valid(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n         ty::Array(ref component, _) => is_maybe_uninit_ty_valid(cx, component),\n         ty::Tuple(ref types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n         ty::Adt(ref adt, _) => {\n-            // needs to be a MaybeUninit\n             match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT)\n         },\n         _ => false,\n@@ -3326,7 +3325,7 @@ fn lint_option_as_ref_deref<'a, 'tcx>(\n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext<'_, '_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n     match ty.kind {\n-        ty::Adt(_, substs) if match_type(cx, ty, &paths::RESULT) => substs.types().nth(1),\n+        ty::Adt(_, substs) if is_type_diagnostic_item(cx, ty, sym!(result_type)) => substs.types().nth(1),\n         _ => None,\n     }\n }"}, {"sha": "35d481cf666e2d3926f704834b7e17a04bb62730", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=83874d0ee77264a82a59513fa4362e86c39034c4", "patch": "@@ -1,5 +1,5 @@\n-use crate::utils::{differing_macro_contexts, paths, snippet_with_applicability, span_lint_and_then};\n-use crate::utils::{is_copy, match_type};\n+use crate::utils::{differing_macro_contexts, snippet_with_applicability, span_lint_and_then};\n+use crate::utils::{is_copy, is_type_diagnostic_item};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_path, NestedVisitorMap, Visitor};\n@@ -20,7 +20,7 @@ pub(super) fn lint<'a, 'tcx>(\n     map_span: Span,\n ) {\n     // lint if the caller of `map()` is an `Option`\n-    if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n+    if is_type_diagnostic_item(cx, cx.tables.expr_ty(&map_args[0]), sym!(option_type)) {\n         if !is_copy(cx, cx.tables.expr_ty(&unwrap_args[1])) {\n             // Do not lint if the `map` argument uses identifiers in the `map`\n             // argument that are also used in the `unwrap_or` argument"}, {"sha": "e252afce33fd058bc9a0921dec1bc5e6cbd8d62a", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=83874d0ee77264a82a59513fa4362e86c39034c4", "patch": "@@ -5,10 +5,9 @@ use rustc_hir::{def, BindingAnnotation, Block, Expr, ExprKind, MatchSource, PatK\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n-use crate::utils::paths::{OPTION, OPTION_NONE};\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    higher, match_def_path, match_qpath, match_type, snippet_with_applicability, span_lint_and_sugg, SpanlessEq,\n+    higher, is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet_with_applicability, span_lint_and_sugg, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -141,7 +140,7 @@ impl QuestionMark {\n     fn is_option(cx: &LateContext<'_, '_>, expression: &Expr<'_>) -> bool {\n         let expr_ty = cx.tables.expr_ty(expression);\n \n-        match_type(cx, expr_ty, &OPTION)\n+        is_type_diagnostic_item(cx, expr_ty, sym!(option_type))\n     }\n \n     fn expression_returns_none(cx: &LateContext<'_, '_>, expression: &Expr<'_>) -> bool {\n@@ -158,7 +157,7 @@ impl QuestionMark {\n                 if let Res::Def(DefKind::Ctor(def::CtorOf::Variant, def::CtorKind::Const), def_id) =\n                     cx.tables.qpath_res(qp, expression.hir_id)\n                 {\n-                    return match_def_path(cx, def_id, &OPTION_NONE);\n+                    return match_def_path(cx, def_id, &paths::OPTION_NONE);\n                 }\n \n                 false"}, {"sha": "67b69f5243c2dbfebbe01afa8c3d90a38bab03a2", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=83874d0ee77264a82a59513fa4362e86c39034c4", "patch": "@@ -420,7 +420,7 @@ impl Types {\n                                 return; // don't recurse into the type\n                             }\n                         }\n-                    } else if match_def_path(cx, def_id, &paths::OPTION) {\n+                    } else if cx.tcx.is_diagnostic_item(sym!(option_type), def_id) {\n                         if match_type_parameter(cx, qpath, &paths::OPTION).is_some() {\n                             span_lint(\n                                 cx,"}, {"sha": "4b4eba525452e6c3a7b08724dab51c99c7c8efbb", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83874d0ee77264a82a59513fa4362e86c39034c4/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=83874d0ee77264a82a59513fa4362e86c39034c4", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{higher::if_block, match_type, paths, span_lint_and_then, usage::is_potentially_mutated};\n+use crate::utils::{higher::if_block, span_lint_and_then, usage::is_potentially_mutated, is_type_diagnostic_item};\n use if_chain::if_chain;\n use rustc_hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{BinOpKind, Body, Expr, ExprKind, FnDecl, HirId, Path, QPath, UnOp};\n@@ -100,7 +100,7 @@ fn collect_unwrap_info<'a, 'tcx>(\n             if let ExprKind::MethodCall(method_name, _, args) = &expr.kind;\n             if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].kind;\n             let ty = cx.tables.expr_ty(&args[0]);\n-            if match_type(cx, ty, &paths::OPTION) || match_type(cx, ty, &paths::RESULT);\n+            if is_type_diagnostic_item(cx, ty, sym!(option_type)) || is_type_diagnostic_item(cx, ty, sym!(result_type));\n             let name = method_name.ident.as_str();\n             if [\"is_some\", \"is_none\", \"is_ok\", \"is_err\"].contains(&&*name);\n             then {"}]}