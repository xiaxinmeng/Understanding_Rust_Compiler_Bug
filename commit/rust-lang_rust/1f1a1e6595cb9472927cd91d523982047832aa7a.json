{"sha": "1f1a1e6595cb9472927cd91d523982047832aa7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmMWExZTY1OTVjYjk0NzI5MjdjZDkxZDUyMzk4MjA0NzgzMmFhN2E=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-11-23T02:32:40Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-11-23T22:23:17Z"}, "message": "rustfmt: liballoc, liballoc_*, libarena", "tree": {"sha": "68f29cad27493cb7493d5bd2c786cecdaf45f3b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68f29cad27493cb7493d5bd2c786cecdaf45f3b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f1a1e6595cb9472927cd91d523982047832aa7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f1a1e6595cb9472927cd91d523982047832aa7a", "html_url": "https://github.com/rust-lang/rust/commit/1f1a1e6595cb9472927cd91d523982047832aa7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f1a1e6595cb9472927cd91d523982047832aa7a/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e24fffef8a560ddf968a866db8da96bc461f4038", "url": "https://api.github.com/repos/rust-lang/rust/commits/e24fffef8a560ddf968a866db8da96bc461f4038", "html_url": "https://github.com/rust-lang/rust/commit/e24fffef8a560ddf968a866db8da96bc461f4038"}], "stats": {"total": 103, "additions": 52, "deletions": 51}, "files": [{"sha": "77ef8a50619c59c52280862c34632947a2d6716e", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=1f1a1e6595cb9472927cd91d523982047832aa7a", "patch": "@@ -131,11 +131,12 @@ pub struct Arc<T: ?Sized> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: ?Sized + Sync + Send> Send for Arc<T> { }\n+unsafe impl<T: ?Sized + Sync + Send> Send for Arc<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> { }\n+unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}\n \n-#[cfg(not(stage0))] // remove cfg after new snapshot\n+// remove cfg after new snapshot\n+#[cfg(not(stage0))]\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n \n@@ -152,11 +153,12 @@ pub struct Weak<T: ?Sized> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: ?Sized + Sync + Send> Send for Weak<T> { }\n+unsafe impl<T: ?Sized + Sync + Send> Send for Weak<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: ?Sized + Sync + Send> Sync for Weak<T> { }\n+unsafe impl<T: ?Sized + Sync + Send> Sync for Weak<T> {}\n \n-#[cfg(not(stage0))] // remove cfg after new snapshot\n+// remove cfg after new snapshot\n+#[cfg(not(stage0))]\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n@@ -226,7 +228,7 @@ impl<T> Arc<T> {\n     pub fn try_unwrap(this: Self) -> Result<T, Self> {\n         // See `drop` for why all these atomics are like this\n         if this.inner().strong.compare_and_swap(1, 0, Release) != 1 {\n-            return Err(this)\n+            return Err(this);\n         }\n \n         atomic::fence(Acquire);\n@@ -265,7 +267,7 @@ impl<T: ?Sized> Arc<T> {\n \n             // check if the weak counter is currently \"locked\"; if so, spin.\n             if cur == usize::MAX {\n-                continue\n+                continue;\n             }\n \n             // NOTE: this code currently ignores the possibility of overflow\n@@ -276,7 +278,7 @@ impl<T: ?Sized> Arc<T> {\n             // synchronize with the write coming from `is_unique`, so that the\n             // events prior to that write happen before this read.\n             if this.inner().weak.compare_and_swap(cur, cur + 1, Acquire) == cur {\n-                return Weak { _ptr: this._ptr }\n+                return Weak { _ptr: this._ptr };\n             }\n         }\n     }\n@@ -568,14 +570,14 @@ impl<T: ?Sized> Drop for Arc<T> {\n         let ptr = *self._ptr;\n         // if ptr.is_null() { return }\n         if ptr as *mut u8 as usize == 0 || ptr as *mut u8 as usize == mem::POST_DROP_USIZE {\n-            return\n+            return;\n         }\n \n         // Because `fetch_sub` is already atomic, we do not need to synchronize\n         // with other threads unless we are going to delete the object. This\n         // same logic applies to the below `fetch_sub` to the `weak` count.\n         if self.inner().strong.fetch_sub(1, Release) != 1 {\n-            return\n+            return;\n         }\n \n         // This fence is needed to prevent reordering of use of the data and\n@@ -634,13 +636,13 @@ impl<T: ?Sized> Weak<T> {\n             // confirmed via the CAS below.\n             let n = inner.strong.load(Relaxed);\n             if n == 0 {\n-                return None\n+                return None;\n             }\n \n             // Relaxed is valid for the same reason it is on Arc's Clone impl\n             let old = inner.strong.compare_and_swap(n, n + 1, Relaxed);\n             if old == n {\n-                return Some(Arc { _ptr: self._ptr })\n+                return Some(Arc { _ptr: self._ptr });\n             }\n         }\n     }\n@@ -682,7 +684,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n             }\n         }\n \n-        return Weak { _ptr: self._ptr }\n+        return Weak { _ptr: self._ptr };\n     }\n }\n \n@@ -718,7 +720,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n         // see comments above for why this check is here\n         if ptr as *mut u8 as usize == 0 || ptr as *mut u8 as usize == mem::POST_DROP_USIZE {\n-            return\n+            return;\n         }\n \n         // If we find out that we were the last weak pointer, then its time to\n@@ -928,8 +930,7 @@ mod tests {\n \n     struct Canary(*mut atomic::AtomicUsize);\n \n-    impl Drop for Canary\n-    {\n+    impl Drop for Canary {\n         fn drop(&mut self) {\n             unsafe {\n                 match *self {\n@@ -943,7 +944,7 @@ mod tests {\n \n     #[test]\n     fn manually_share_arc() {\n-        let v = vec!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n+        let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         let arc_v = Arc::new(v);\n \n         let (tx, rx) = channel();"}, {"sha": "804c593467e5b723a3feb9b15e5d3af74e38939b", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=1f1a1e6595cb9472927cd91d523982047832aa7a", "patch": "@@ -88,8 +88,7 @@ use core::convert::From;\n #[unstable(feature = \"box_heap\",\n            reason = \"may be renamed; uncertain about custom allocator design\",\n            issue = \"27779\")]\n-pub const HEAP: ExchangeHeapSingleton =\n-    ExchangeHeapSingleton { _force_singleton: () };\n+pub const HEAP: ExchangeHeapSingleton = ExchangeHeapSingleton { _force_singleton: () };\n \n /// This the singleton type used solely for `boxed::HEAP`.\n #[unstable(feature = \"box_heap\",\n@@ -238,7 +237,7 @@ impl<T> Box<T> {\n     }\n }\n \n-impl<T : ?Sized> Box<T> {\n+impl<T: ?Sized> Box<T> {\n     /// Constructs a box from the raw pointer.\n     ///\n     /// After this function call, pointer is owned by resulting box.\n@@ -535,8 +534,7 @@ pub trait FnBox<A> {\n }\n \n #[unstable(feature = \"fnbox\", reason = \"Newly introduced\", issue = \"0\")]\n-impl<A,F> FnBox<A> for F\n-    where F: FnOnce<A>\n+impl<A, F> FnBox<A> for F where F: FnOnce<A>\n {\n     type Output = F::Output;\n \n@@ -546,7 +544,7 @@ impl<A,F> FnBox<A> for F\n }\n \n #[unstable(feature = \"fnbox\", reason = \"Newly introduced\", issue = \"0\")]\n-impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+'a> {\n+impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + 'a> {\n     type Output = R;\n \n     extern \"rust-call\" fn call_once(self, args: A) -> R {\n@@ -555,7 +553,7 @@ impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+'a> {\n }\n \n #[unstable(feature = \"fnbox\", reason = \"Newly introduced\", issue = \"0\")]\n-impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+Send+'a> {\n+impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + Send + 'a> {\n     type Output = R;\n \n     extern \"rust-call\" fn call_once(self, args: A) -> R {\n@@ -564,7 +562,7 @@ impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+Send+'a> {\n }\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n \n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n impl<T: Clone> Clone for Box<[T]> {"}, {"sha": "e7da6d04d3f8fce438f9832dd03401b51136c585", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=1f1a1e6595cb9472927cd91d523982047832aa7a", "patch": "@@ -74,8 +74,7 @@ fn test_show() {\n \n #[test]\n fn deref() {\n-    fn homura<T: Deref<Target = i32>>(_: T) {\n-    }\n+    fn homura<T: Deref<Target = i32>>(_: T) {}\n     homura(Box::new(765));\n }\n "}, {"sha": "7e7e3c619cb3a9d6552d43e99110d0171b4cb596", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=1f1a1e6595cb9472927cd91d523982047832aa7a", "patch": "@@ -18,7 +18,7 @@\n use core::{isize, usize};\n \n #[allow(improper_ctypes)]\n-extern {\n+extern \"C\" {\n     #[allocator]\n     fn __rust_allocate(size: usize, align: usize) -> *mut u8;\n     fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize);"}, {"sha": "a77e4f063386602520d258dc4dad55fd50e695fa", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=1f1a1e6595cb9472927cd91d523982047832aa7a", "patch": "@@ -196,9 +196,10 @@ impl<T: ?Sized> !marker::Send for Rc<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> !marker::Sync for Rc<T> {}\n \n-#[cfg(not(stage0))] // remove cfg after new snapshot\n+// remove cfg after new snapshot\n+#[cfg(not(stage0))]\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}\n \n impl<T> Rc<T> {\n     /// Constructs a new `Rc<T>`.\n@@ -482,7 +483,6 @@ impl<T: ?Sized> Drop for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for Rc<T> {\n-\n     /// Makes a clone of the `Rc<T>`.\n     ///\n     /// When you clone an `Rc<T>`, it will create another pointer to the data and\n@@ -678,21 +678,21 @@ impl<T: ?Sized + Ord> Ord for Rc<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized+Hash> Hash for Rc<T> {\n+impl<T: ?Sized + Hash> Hash for Rc<T> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         (**self).hash(state);\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized+fmt::Display> fmt::Display for Rc<T> {\n+impl<T: ?Sized + fmt::Display> fmt::Display for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized+fmt::Debug> fmt::Debug for Rc<T> {\n+impl<T: ?Sized + fmt::Debug> fmt::Debug for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n@@ -731,9 +731,10 @@ impl<T: ?Sized> !marker::Send for Weak<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> !marker::Sync for Weak<T> {}\n \n-#[cfg(not(stage0))] // remove cfg after new snapshot\n+// remove cfg after new snapshot\n+#[cfg(not(stage0))]\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n impl<T: ?Sized> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n@@ -810,7 +811,6 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-\n     /// Makes a clone of the `Weak<T>`.\n     ///\n     /// This increases the weak reference count.\n@@ -832,7 +832,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized+fmt::Debug> fmt::Debug for Weak<T> {\n+impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"(Weak)\")\n     }"}, {"sha": "f53bc404b8885b2083452ec5474f078f9cad7969", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=1f1a1e6595cb9472927cd91d523982047832aa7a", "patch": "@@ -41,7 +41,7 @@ use libc::{c_int, c_void, size_t};\n                not(target_os = \"android\"),\n                not(target_env = \"musl\")),\n            link(name = \"pthread\"))]\n-extern {\n+extern \"C\" {\n     fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;\n     fn je_rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n     fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;"}, {"sha": "1befbd61d6d44c402a67189529b45ee5a5ec6901", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=1f1a1e6595cb9472927cd91d523982047832aa7a", "patch": "@@ -79,7 +79,7 @@ mod imp {\n     use libc;\n     use MIN_ALIGN;\n \n-    extern {\n+    extern \"C\" {\n         // Apparently android doesn't have posix_memalign\n         #[cfg(target_os = \"android\")]\n         fn memalign(align: libc::size_t, size: libc::size_t) -> *mut libc::c_void;\n@@ -180,7 +180,7 @@ mod imp {\n         } else {\n             let ptr = HeapAlloc(GetProcessHeap(), 0, (size + align) as SIZE_T) as *mut u8;\n             if ptr.is_null() {\n-                return ptr\n+                return ptr;\n             }\n             align_ptr(ptr, align)\n         }\n@@ -196,7 +196,7 @@ mod imp {\n                                   header.0 as LPVOID,\n                                   (size + align) as SIZE_T) as *mut u8;\n             if new.is_null() {\n-                return new\n+                return new;\n             }\n             align_ptr(new, align)\n         }"}, {"sha": "abc15df804d496c9389e6c95f0ebe2809171816a", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f1a1e6595cb9472927cd91d523982047832aa7a/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=1f1a1e6595cb9472927cd91d523982047832aa7a", "patch": "@@ -168,8 +168,8 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n \n         let start = round_up(after_tydesc, align);\n \n-        //debug!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n-        //       start, size, align, is_done);\n+        // debug!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n+        //        start, size, align, is_done);\n         if is_done {\n             ((*tydesc).drop_glue)(buf.offset(start as isize) as *const i8);\n         }\n@@ -201,8 +201,11 @@ struct TyDesc {\n     align: usize,\n }\n \n-trait AllTypes { fn dummy(&self) { } }\n-impl<T:?Sized> AllTypes for T { }\n+trait AllTypes {\n+    fn dummy(&self) {}\n+}\n+\n+impl<T: ?Sized> AllTypes for T {}\n \n unsafe fn get_tydesc<T>() -> *const TyDesc {\n     use std::raw::TraitObject;\n@@ -624,7 +627,7 @@ mod tests {\n         for _ in 0..100000 {\n             arena.alloc(Noncopy {\n                 string: \"hello world\".to_string(),\n-                array: vec!(1, 2, 3, 4, 5),\n+                array: vec![1, 2, 3, 4, 5],\n             });\n         }\n     }\n@@ -635,7 +638,7 @@ mod tests {\n         b.iter(|| {\n             arena.alloc(Noncopy {\n                 string: \"hello world\".to_string(),\n-                array: vec!(1, 2, 3, 4, 5),\n+                array: vec![1, 2, 3, 4, 5],\n             })\n         })\n     }\n@@ -645,7 +648,7 @@ mod tests {\n         b.iter(|| {\n             let _: Box<_> = box Noncopy {\n                 string: \"hello world\".to_string(),\n-                array: vec!(1, 2, 3, 4, 5),\n+                array: vec![1, 2, 3, 4, 5],\n             };\n         })\n     }\n@@ -657,7 +660,7 @@ mod tests {\n             arena.alloc(|| {\n                 Noncopy {\n                     string: \"hello world\".to_string(),\n-                    array: vec!(1, 2, 3, 4, 5),\n+                    array: vec![1, 2, 3, 4, 5],\n                 }\n             })\n         })"}]}