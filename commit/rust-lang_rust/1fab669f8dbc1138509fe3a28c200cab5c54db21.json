{"sha": "1fab669f8dbc1138509fe3a28c200cab5c54db21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmYWI2NjlmOGRiYzExMzg1MDlmZTNhMjhjMjAwY2FiNWM1NGRiMjE=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-20T01:31:21Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T03:09:55Z"}, "message": "Be honest about being able to list constructors\n\nThe test change is because we used to treat `&str` like other `&T`s, ie\nas having a single constructor. That's not quite true though since we\nconsider `&str` constants as atomic instead of refs to `str` constants.", "tree": {"sha": "775b30b78a289ba4e71048a8e78f5e71e4ce8f72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/775b30b78a289ba4e71048a8e78f5e71e4ce8f72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fab669f8dbc1138509fe3a28c200cab5c54db21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fab669f8dbc1138509fe3a28c200cab5c54db21", "html_url": "https://github.com/rust-lang/rust/commit/1fab669f8dbc1138509fe3a28c200cab5c54db21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fab669f8dbc1138509fe3a28c200cab5c54db21/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db9a8480c481deb0936508c224dc0514e4fe0e80", "url": "https://api.github.com/repos/rust-lang/rust/commits/db9a8480c481deb0936508c224dc0514e4fe0e80", "html_url": "https://github.com/rust-lang/rust/commit/db9a8480c481deb0936508c224dc0514e4fe0e80"}], "stats": {"total": 86, "additions": 47, "deletions": 39}, "files": [{"sha": "b6b1491e363216403e2a8b4a37db07aa95cbcd65", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1fab669f8dbc1138509fe3a28c200cab5c54db21/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fab669f8dbc1138509fe3a28c200cab5c54db21/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=1fab669f8dbc1138509fe3a28c200cab5c54db21", "patch": "@@ -846,6 +846,9 @@ enum Constructor<'tcx> {\n     Opaque,\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n     NonExhaustive,\n+    /// Fake constructor for those types for which we can't list constructors explicitely, like\n+    /// `f64` and `&str`.\n+    Unlistable,\n     /// Wildcard pattern.\n     Wildcard,\n }\n@@ -949,6 +952,9 @@ impl<'tcx> Constructor<'tcx> {\n             }\n             // This constructor is never covered by anything else\n             NonExhaustive => vec![NonExhaustive],\n+            // This constructor is only covered by `Single`s\n+            Unlistable if other_ctors.iter().any(|c| *c == Single) => vec![],\n+            Unlistable => vec![Unlistable],\n             Opaque => bug!(\"found unexpected opaque ctor in all_ctors\"),\n             Wildcard => bug!(\"found unexpected wildcard ctor in all_ctors\"),\n         }\n@@ -1068,6 +1074,11 @@ impl<'tcx> Constructor<'tcx> {\n             (Opaque, _) | (_, Opaque) => false,\n             // Only a wildcard pattern can match the special extra constructor.\n             (NonExhaustive, _) => false,\n+            // If we encounter a `Single` here, this means there was only one constructor for this\n+            // type after all.\n+            (Unlistable, Single) => true,\n+            // Otherwise, only a wildcard pattern can match the special extra constructor.\n+            (Unlistable, _) => false,\n \n             _ => bug!(\"trying to compare incompatible constructors {:?} and {:?}\", self, other),\n         }\n@@ -1146,7 +1157,7 @@ impl<'tcx> Constructor<'tcx> {\n             &Str(value) => PatKind::Constant { value },\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n             IntRange(range) => return range.to_pat(pcx.cx.tcx),\n-            NonExhaustive => PatKind::Wild,\n+            NonExhaustive | Unlistable => PatKind::Wild,\n             Opaque => bug!(\"we should not try to apply an opaque constructor\"),\n             Wildcard => bug!(\n                 \"trying to apply a wildcard constructor; this should have been done in `apply_constructors`\"\n@@ -1286,7 +1297,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         }\n                     }\n                 }\n-                _ => Fields::empty(),\n+                _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", ty),\n             },\n             Slice(slice) => match *ty.kind() {\n                 ty::Slice(ty) | ty::Array(ty, _) => {\n@@ -1295,9 +1306,8 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n             },\n-            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque | Wildcard => {\n-                Fields::empty()\n-            }\n+            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque | Unlistable\n+            | Wildcard => Fields::empty(),\n         };\n         debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n         ret\n@@ -1616,9 +1626,9 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n                 .unwrap(),\n         )\n     };\n-    match *pcx.ty.kind() {\n+    match pcx.ty.kind() {\n         ty::Bool => vec![make_range(0, 1)],\n-        ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n+        ty::Array(sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n             let len = len.eval_usize(cx.tcx, cx.param_env);\n             if len != 0 && cx.is_uninhabited(sub_ty) {\n                 vec![]\n@@ -1627,26 +1637,11 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n             }\n         }\n         // Treat arrays of a constant but unknown length like slices.\n-        ty::Array(ref sub_ty, _) | ty::Slice(ref sub_ty) => {\n+        ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n             let kind = if cx.is_uninhabited(sub_ty) { FixedLen(0) } else { VarLen(0, 0) };\n             vec![Slice(Slice { array_len: None, kind })]\n         }\n         ty::Adt(def, substs) if def.is_enum() => {\n-            let ctors: Vec<_> = if cx.tcx.features().exhaustive_patterns {\n-                // If `exhaustive_patterns` is enabled, we exclude variants known to be\n-                // uninhabited.\n-                def.variants\n-                    .iter()\n-                    .filter(|v| {\n-                        !v.uninhabited_from(cx.tcx, substs, def.adt_kind(), cx.param_env)\n-                            .contains(cx.tcx, cx.module)\n-                    })\n-                    .map(|v| Variant(v.def_id))\n-                    .collect()\n-            } else {\n-                def.variants.iter().map(|v| Variant(v.def_id)).collect()\n-            };\n-\n             // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n             // additional \"unknown\" constructor.\n             // There is no point in enumerating all possible variants, because the user can't\n@@ -1672,7 +1667,22 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n             let is_secretly_empty =\n                 def.variants.is_empty() && !cx.tcx.features().exhaustive_patterns;\n \n-            if is_secretly_empty || is_declared_nonexhaustive { vec![NonExhaustive] } else { ctors }\n+            if is_secretly_empty || is_declared_nonexhaustive {\n+                vec![NonExhaustive]\n+            } else if cx.tcx.features().exhaustive_patterns {\n+                // If `exhaustive_patterns` is enabled, we exclude variants known to be\n+                // uninhabited.\n+                def.variants\n+                    .iter()\n+                    .filter(|v| {\n+                        !v.uninhabited_from(cx.tcx, substs, def.adt_kind(), cx.param_env)\n+                            .contains(cx.tcx, cx.module)\n+                    })\n+                    .map(|v| Variant(v.def_id))\n+                    .collect()\n+            } else {\n+                def.variants.iter().map(|v| Variant(v.def_id)).collect()\n+            }\n         }\n         ty::Char => {\n             vec![\n@@ -1690,24 +1700,22 @@ fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tc\n             // `#[non_exhaustive]` enums by returning a special unmatcheable constructor.\n             vec![NonExhaustive]\n         }\n-        ty::Int(ity) => {\n+        &ty::Int(ity) => {\n             let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n             let max = min - 1;\n             vec![make_range(min, max)]\n         }\n-        ty::Uint(uty) => {\n+        &ty::Uint(uty) => {\n             let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n             let max = truncate(u128::MAX, size);\n             vec![make_range(0, max)]\n         }\n-        _ => {\n-            if cx.is_uninhabited(pcx.ty) {\n-                vec![]\n-            } else {\n-                vec![Single]\n-            }\n-        }\n+        _ if cx.is_uninhabited(pcx.ty) => vec![],\n+        ty::Adt(..) | ty::Tuple(..) => vec![Single],\n+        ty::Ref(_, t, _) if !t.is_str() => vec![Single],\n+        // This type is one for which we don't know how to list constructors, like &str of f64.\n+        _ => vec![Unlistable],\n     }\n }\n "}, {"sha": "8075532c37d76cd0b07f7f1f38aee210e8c1ed0c", "filename": "src/test/ui/issues/issue-30240.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1fab669f8dbc1138509fe3a28c200cab5c54db21/src%2Ftest%2Fui%2Fissues%2Fissue-30240.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fab669f8dbc1138509fe3a28c200cab5c54db21/src%2Ftest%2Fui%2Fissues%2Fissue-30240.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30240.rs?ref=1fab669f8dbc1138509fe3a28c200cab5c54db21", "patch": "@@ -1,9 +1,9 @@\n fn main() {\n-    match \"world\" { //~ ERROR non-exhaustive patterns: `&_`\n+    match \"world\" { //~ ERROR non-exhaustive patterns: `_`\n         \"hello\" => {}\n     }\n \n-    match \"world\" { //~ ERROR non-exhaustive patterns: `&_`\n+    match \"world\" { //~ ERROR non-exhaustive patterns: `_`\n         ref _x if false => {}\n         \"hello\" => {}\n     }"}, {"sha": "71a8bcb50cda433e0c9fd75082e610458d3251e2", "filename": "src/test/ui/issues/issue-30240.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fab669f8dbc1138509fe3a28c200cab5c54db21/src%2Ftest%2Fui%2Fissues%2Fissue-30240.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fab669f8dbc1138509fe3a28c200cab5c54db21/src%2Ftest%2Fui%2Fissues%2Fissue-30240.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30240.stderr?ref=1fab669f8dbc1138509fe3a28c200cab5c54db21", "patch": "@@ -1,17 +1,17 @@\n-error[E0004]: non-exhaustive patterns: `&_` not covered\n+error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/issue-30240.rs:2:11\n    |\n LL |     match \"world\" {\n-   |           ^^^^^^^ pattern `&_` not covered\n+   |           ^^^^^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&str`\n \n-error[E0004]: non-exhaustive patterns: `&_` not covered\n+error[E0004]: non-exhaustive patterns: `_` not covered\n   --> $DIR/issue-30240.rs:6:11\n    |\n LL |     match \"world\" {\n-   |           ^^^^^^^ pattern `&_` not covered\n+   |           ^^^^^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&str`"}]}