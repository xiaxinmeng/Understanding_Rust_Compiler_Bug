{"sha": "d662083a6c78928c70cc74b600205c246dab3bf6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NjIwODNhNmM3ODkyOGM3MGNjNzRiNjAwMjA1YzI0NmRhYjNiZjY=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-08-14T15:55:22Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-08-15T12:50:54Z"}, "message": "Use CGU name as LLVM module name and add some caching to CGU name generation.", "tree": {"sha": "a835686a578e48c5082f6c9e736f8babbf9f9c01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a835686a578e48c5082f6c9e736f8babbf9f9c01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d662083a6c78928c70cc74b600205c246dab3bf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d662083a6c78928c70cc74b600205c246dab3bf6", "html_url": "https://github.com/rust-lang/rust/commit/d662083a6c78928c70cc74b600205c246dab3bf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d662083a6c78928c70cc74b600205c246dab3bf6/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e192e498ab2bff4a23692ffb6dc7a94122de0b72", "url": "https://api.github.com/repos/rust-lang/rust/commits/e192e498ab2bff4a23692ffb6dc7a94122de0b72", "html_url": "https://github.com/rust-lang/rust/commit/e192e498ab2bff4a23692ffb6dc7a94122de0b72"}], "stats": {"total": 378, "additions": 208, "deletions": 170}, "files": [{"sha": "9d2f62bd03046a8749fcf691c3d90a2e6476a060", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 92, "deletions": 74, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=d662083a6c78928c70cc74b600205c246dab3bf6", "patch": "@@ -171,80 +171,6 @@ impl<'tcx> CodegenUnit<'tcx> {\n             self.size_estimate = Some(size_estimate + delta);\n         }\n     }\n-\n-    /// CGU names should fulfill the following requirements:\n-    /// - They should be able to act as a file name on any kind of file system\n-    /// - They should not collide with other CGU names, even for different versions\n-    ///   of the same crate.\n-    ///\n-    /// Consequently, we don't use special characters except for '.' and '-' and we\n-    /// prefix each name with the crate-name and crate-disambiguator.\n-    ///\n-    /// This function will build CGU names of the form:\n-    ///\n-    /// ```\n-    /// <crate-name>.<crate-disambiguator>(-<component>)*[.<special-suffix>]\n-    /// ```\n-    ///\n-    /// The '.' before `<special-suffix>` makes sure that names with a special\n-    /// suffix can never collide with a name built out of regular Rust\n-    /// identifiers (e.g. module paths).\n-    pub fn build_cgu_name<I, C, S>(tcx: TyCtxt,\n-                                   cnum: CrateNum,\n-                                   components: I,\n-                                   special_suffix: Option<S>)\n-                                   -> InternedString\n-        where I: IntoIterator<Item=C>,\n-              C: fmt::Display,\n-              S: fmt::Display,\n-    {\n-        let cgu_name = CodegenUnit::build_cgu_name_no_mangle(tcx,\n-                                                             cnum,\n-                                                             components,\n-                                                             special_suffix);\n-\n-        if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n-            cgu_name\n-        } else {\n-            let cgu_name = &cgu_name.as_str()[..];\n-            Symbol::intern(&CodegenUnit::mangle_name(cgu_name)).as_interned_str()\n-        }\n-    }\n-\n-    /// Same as `CodegenUnit::build_cgu_name()` but will never mangle the\n-    /// resulting name.\n-    pub fn build_cgu_name_no_mangle<I, C, S>(tcx: TyCtxt,\n-                                             cnum: CrateNum,\n-                                             components: I,\n-                                             special_suffix: Option<S>)\n-                                             -> InternedString\n-        where I: IntoIterator<Item=C>,\n-              C: fmt::Display,\n-              S: fmt::Display,\n-    {\n-        use std::fmt::Write;\n-\n-        let mut cgu_name = String::with_capacity(64);\n-\n-        // Start out with the crate name and disambiguator\n-        write!(cgu_name,\n-               \"{}.{}\",\n-               tcx.crate_name(cnum),\n-               tcx.crate_disambiguator(cnum)).unwrap();\n-\n-        // Add the components\n-        for component in components {\n-            write!(cgu_name, \"-{}\", component).unwrap();\n-        }\n-\n-        if let Some(special_suffix) = special_suffix {\n-            // We add a dot in here so it cannot clash with anything in a regular\n-            // Rust identifier\n-            write!(cgu_name, \".{}\", special_suffix).unwrap();\n-        }\n-\n-        Symbol::intern(&cgu_name[..]).as_interned_str()\n-    }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n@@ -314,3 +240,95 @@ impl Stats {\n         self.fn_stats.extend(stats.fn_stats);\n     }\n }\n+\n+pub struct CodegenUnitNameBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    cache: FxHashMap<CrateNum, String>,\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a> CodegenUnitNameBuilder<'a, 'gcx, 'tcx> {\n+\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        CodegenUnitNameBuilder {\n+            tcx,\n+            cache: FxHashMap(),\n+        }\n+    }\n+\n+    /// CGU names should fulfill the following requirements:\n+    /// - They should be able to act as a file name on any kind of file system\n+    /// - They should not collide with other CGU names, even for different versions\n+    ///   of the same crate.\n+    ///\n+    /// Consequently, we don't use special characters except for '.' and '-' and we\n+    /// prefix each name with the crate-name and crate-disambiguator.\n+    ///\n+    /// This function will build CGU names of the form:\n+    ///\n+    /// ```\n+    /// <crate-name>.<crate-disambiguator>(-<component>)*[.<special-suffix>]\n+    /// ```\n+    ///\n+    /// The '.' before `<special-suffix>` makes sure that names with a special\n+    /// suffix can never collide with a name built out of regular Rust\n+    /// identifiers (e.g. module paths).\n+    pub fn build_cgu_name<I, C, S>(&mut self,\n+                                   cnum: CrateNum,\n+                                   components: I,\n+                                   special_suffix: Option<S>)\n+                                   -> InternedString\n+        where I: IntoIterator<Item=C>,\n+              C: fmt::Display,\n+              S: fmt::Display,\n+    {\n+        let cgu_name = self.build_cgu_name_no_mangle(cnum,\n+                                                     components,\n+                                                     special_suffix);\n+\n+        if self.tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n+            cgu_name\n+        } else {\n+            let cgu_name = &cgu_name.as_str()[..];\n+            Symbol::intern(&CodegenUnit::mangle_name(cgu_name)).as_interned_str()\n+        }\n+    }\n+\n+    /// Same as `CodegenUnit::build_cgu_name()` but will never mangle the\n+    /// resulting name.\n+    pub fn build_cgu_name_no_mangle<I, C, S>(&mut self,\n+                                             cnum: CrateNum,\n+                                             components: I,\n+                                             special_suffix: Option<S>)\n+                                             -> InternedString\n+        where I: IntoIterator<Item=C>,\n+              C: fmt::Display,\n+              S: fmt::Display,\n+    {\n+        use std::fmt::Write;\n+\n+        let mut cgu_name = String::with_capacity(64);\n+\n+        // Start out with the crate name and disambiguator\n+        let tcx = self.tcx;\n+        let crate_prefix = self.cache.entry(cnum).or_insert_with(|| {\n+            let crate_disambiguator = format!(\"{}\", tcx.crate_disambiguator(cnum));\n+            // Using a shortened disambiguator of about 40 bits\n+            format!(\"{}.{}\", tcx.crate_name(cnum), &crate_disambiguator[0 .. 8])\n+        });\n+\n+        write!(cgu_name, \"{}\", crate_prefix).unwrap();\n+\n+        // Add the components\n+        for component in components {\n+            write!(cgu_name, \"-{}\", component).unwrap();\n+        }\n+\n+        if let Some(special_suffix) = special_suffix {\n+            // We add a dot in here so it cannot clash with anything in a regular\n+            // Rust identifier\n+            write!(cgu_name, \".{}\", special_suffix).unwrap();\n+        }\n+\n+        Symbol::intern(&cgu_name[..]).as_interned_str()\n+    }\n+}"}, {"sha": "37c99932f565ce7e93c11db8149077b1018ad296", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=d662083a6c78928c70cc74b600205c246dab3bf6", "patch": "@@ -46,13 +46,6 @@ use std::process::{Output, Stdio};\n use std::str;\n use syntax::attr;\n \n-/// The LLVM module name containing crate-metadata. This includes a `.` on\n-/// purpose, so it cannot clash with the name of a user-defined module.\n-pub const METADATA_MODULE_NAME: &'static str = \"crate.metadata\";\n-\n-// same as for metadata above, but for allocator shim\n-pub const ALLOCATOR_MODULE_NAME: &'static str = \"crate.allocator\";\n-\n pub use rustc_codegen_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n                                   invalid_output_for_target, build_link_meta, out_filename,\n                                   check_file_is_writeable};"}, {"sha": "56858a31efd25fd5fe3584f10b979d3474ec950b", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=d662083a6c78928c70cc74b600205c246dab3bf6", "patch": "@@ -242,7 +242,7 @@ fn fat_lto(cgcx: &CodegenContext,\n             let llvm = module.llvm().expect(\"can't lto pre-codegened modules\");\n             (&llvm.llcx, llvm.llmod())\n         };\n-        info!(\"using {:?} as a base module\", module.llmod_id);\n+        info!(\"using {:?} as a base module\", module.name);\n \n         // The linking steps below may produce errors and diagnostics within LLVM\n         // which we'd like to handle and print, so set up our diagnostic handlers\n@@ -257,7 +257,7 @@ fn fat_lto(cgcx: &CodegenContext,\n         for module in modules {\n             let llvm = module.llvm().expect(\"can't lto pre-codegened modules\");\n             let buffer = ModuleBuffer::new(llvm.llmod());\n-            let llmod_id = CString::new(&module.llmod_id[..]).unwrap();\n+            let llmod_id = CString::new(&module.name[..]).unwrap();\n             serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n         }\n \n@@ -384,9 +384,9 @@ fn thin_lto(diag_handler: &Handler,\n         //        the most expensive portion of this small bit of global\n         //        analysis!\n         for (i, module) in modules.iter().enumerate() {\n-            info!(\"local module: {} - {}\", i, module.llmod_id);\n+            info!(\"local module: {} - {}\", i, module.name);\n             let llvm = module.llvm().expect(\"can't lto precodegened module\");\n-            let name = CString::new(module.llmod_id.clone()).unwrap();\n+            let name = CString::new(module.name.clone()).unwrap();\n             let buffer = ThinBuffer::new(llvm.llmod());\n             thin_modules.push(llvm::ThinLTOModule {\n                 identifier: name.as_ptr(),\n@@ -395,7 +395,7 @@ fn thin_lto(diag_handler: &Handler,\n             });\n             thin_buffers.push(buffer);\n             module_names.push(name);\n-            timeline.record(&module.llmod_id);\n+            timeline.record(&module.name);\n         }\n \n         // FIXME: All upstream crates are deserialized internally in the\n@@ -668,7 +668,6 @@ impl ThinModule {\n                 llcx,\n                 tm,\n             }),\n-            llmod_id: self.name().to_string(),\n             name: self.name().to_string(),\n             kind: ModuleKind::Regular,\n         };"}, {"sha": "b62836ec255d48e9f86a76206a2308005e61bba7", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=d662083a6c78928c70cc74b600205c246dab3bf6", "patch": "@@ -728,7 +728,7 @@ unsafe fn codegen(cgcx: &CodegenContext,\n \n             if config.emit_bc_compressed {\n                 let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n-                let data = bytecode::encode(&module.llmod_id, data);\n+                let data = bytecode::encode(&module.name, data);\n                 if let Err(e) = fs::write(&dst, data) {\n                     diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n                 }\n@@ -1338,7 +1338,6 @@ fn execute_work_item(cgcx: &CodegenContext,\n         assert_eq!(bytecode_compressed.is_some(), config.emit_bc_compressed);\n \n         Ok(WorkItemResult::Compiled(CompiledModule {\n-            llmod_id: module.llmod_id.clone(),\n             name: module_name,\n             kind: ModuleKind::Regular,\n             pre_existing: true,"}, {"sha": "e626cc3870fe91b951d02924119b25462bd643cf", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 24, "deletions": 43, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=d662083a6c78928c70cc74b600205c246dab3bf6", "patch": "@@ -36,7 +36,7 @@ use metadata;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::middle::lang_items::StartFnLangItem;\n use rustc::middle::weak_lang_items;\n-use rustc::mir::mono::{Linkage, Visibility, Stats};\n+use rustc::mir::mono::{Linkage, Visibility, Stats, CodegenUnitNameBuilder};\n use rustc::middle::cstore::{EncodedMetadata};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, TyLayout, LayoutOf};\n@@ -742,19 +742,23 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n     let link_meta = link::build_link_meta(crate_hash);\n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n \n     // Codegen the metadata.\n     tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen));\n-    let llmod_id = \"metadata\";\n-    let metadata_llvm_module = ModuleLlvm::new(tcx.sess, llmod_id);\n+\n+    let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n+                                                            &[\"crate\"],\n+                                                            Some(\"metadata\")).as_str()\n+                                                                             .to_string();\n+    let metadata_llvm_module = ModuleLlvm::new(tcx.sess, &metadata_cgu_name);\n     let metadata = time(tcx.sess, \"write metadata\", || {\n         write_metadata(tcx, &metadata_llvm_module, &link_meta)\n     });\n     tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n \n     let metadata_module = ModuleCodegen {\n-        name: link::METADATA_MODULE_NAME.to_string(),\n-        llmod_id: llmod_id.to_string(),\n+        name: metadata_cgu_name,\n         source: ModuleSource::Codegened(metadata_llvm_module),\n         kind: ModuleKind::Metadata,\n     };\n@@ -833,20 +837,22 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let allocator_module = if any_dynamic_crate {\n         None\n     } else if let Some(kind) = *tcx.sess.allocator_kind.get() {\n-        unsafe {\n-            let llmod_id = \"allocator\";\n-            let modules = ModuleLlvm::new(tcx.sess, llmod_id);\n-            time(tcx.sess, \"write allocator module\", || {\n+        let llmod_id = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n+                                                       &[\"crate\"],\n+                                                       Some(\"allocator\")).as_str()\n+                                                                         .to_string();\n+        let modules = ModuleLlvm::new(tcx.sess, &llmod_id);\n+        time(tcx.sess, \"write allocator module\", || {\n+            unsafe {\n                 allocator::codegen(tcx, &modules, kind)\n-            });\n+            }\n+        });\n \n-            Some(ModuleCodegen {\n-                name: link::ALLOCATOR_MODULE_NAME.to_string(),\n-                llmod_id: llmod_id.to_string(),\n-                source: ModuleSource::Codegened(modules),\n-                kind: ModuleKind::Allocator,\n-            })\n-        }\n+        Some(ModuleCodegen {\n+            name: llmod_id,\n+            source: ModuleSource::Codegened(modules),\n+            kind: ModuleKind::Allocator,\n+        })\n     } else {\n         None\n     };\n@@ -889,21 +895,10 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // succeed it means that none of the dependencies has changed\n                 // and we can safely re-use.\n                 if let Some(dep_node_index) = tcx.dep_graph.try_mark_green(tcx, dep_node) {\n-                    // Append \".rs\" to LLVM module identifier.\n-                    //\n-                    // LLVM code generator emits a \".file filename\" directive\n-                    // for ELF backends. Value of the \"filename\" is set as the\n-                    // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n-                    // crashes if the module identifier is same as other symbols\n-                    // such as a function name in the module.\n-                    // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-                    let llmod_id = format!(\"{}.rs\", cgu.name());\n-\n                     let module = ModuleCodegen {\n                         name: cgu.name().to_string(),\n                         source: ModuleSource::Preexisting(buf),\n                         kind: ModuleKind::Regular,\n-                        llmod_id,\n                     };\n                     tcx.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n                     write::submit_codegened_module_to_llvm(tcx, module, 0);\n@@ -1212,21 +1207,8 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     {\n         let cgu_name = cgu.name().to_string();\n \n-        // Append \".rs\" to LLVM module identifier.\n-        //\n-        // LLVM code generator emits a \".file filename\" directive\n-        // for ELF backends. Value of the \"filename\" is set as the\n-        // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n-        // crashes if the module identifier is same as other symbols\n-        // such as a function name in the module.\n-        // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-        let llmod_id = format!(\"{}-{}.rs\",\n-                               cgu.name(),\n-                               tcx.crate_disambiguator(LOCAL_CRATE)\n-                                   .to_fingerprint().to_hex());\n-\n         // Instantiate monomorphizations without filling out definitions yet...\n-        let llvm_module = ModuleLlvm::new(tcx.sess, &llmod_id);\n+        let llvm_module = ModuleLlvm::new(tcx.sess, &cgu_name);\n         let stats = {\n             let cx = CodegenCx::new(tcx, cgu, &llvm_module);\n             let mono_items = cx.codegen_unit\n@@ -1282,7 +1264,6 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             name: cgu_name,\n             source: ModuleSource::Codegened(llvm_module),\n             kind: ModuleKind::Regular,\n-            llmod_id,\n         })\n     }\n }"}, {"sha": "a65511a24af727413a9b7a26835513da7c2be97d", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=d662083a6c78928c70cc74b600205c246dab3bf6", "patch": "@@ -269,8 +269,8 @@ struct ModuleCodegen {\n     /// unique amongst **all** crates.  Therefore, it should contain\n     /// something unique to this crate (e.g., a module path) as well\n     /// as the crate name and disambiguator.\n+    /// We currently generate these names via CodegenUnit::build_cgu_name().\n     name: String,\n-    llmod_id: String,\n     source: ModuleSource,\n     kind: ModuleKind,\n }\n@@ -317,7 +317,6 @@ impl ModuleCodegen {\n         };\n \n         CompiledModule {\n-            llmod_id: self.llmod_id,\n             name: self.name.clone(),\n             kind: self.kind,\n             pre_existing,\n@@ -331,7 +330,6 @@ impl ModuleCodegen {\n #[derive(Debug)]\n struct CompiledModule {\n     name: String,\n-    llmod_id: String,\n     kind: ModuleKind,\n     pre_existing: bool,\n     object: Option<PathBuf>,"}, {"sha": "9b8e2c450d5f835187a37d4bb7feb6dca7fd6188", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=d662083a6c78928c70cc74b600205c246dab3bf6", "patch": "@@ -29,7 +29,7 @@\n \n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::dep_graph::{DepNode, DepConstructor};\n-use rustc::mir::mono::CodegenUnit;\n+use rustc::mir::mono::CodegenUnitNameBuilder;\n use rustc::ty::TyCtxt;\n use syntax::ast;\n use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED};\n@@ -94,10 +94,10 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         // Remove the crate name\n         assert_eq!(cgu_path_components.remove(0), crate_name);\n \n-        let cgu_name = CodegenUnit::build_cgu_name(self.tcx,\n-                                                   LOCAL_CRATE,\n-                                                   cgu_path_components,\n-                                                   cgu_special_suffix);\n+        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(self.tcx);\n+        let cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n+                                                       cgu_path_components,\n+                                                       cgu_special_suffix);\n \n         debug!(\"mapping '{}' to cgu name '{}'\", self.field(attr, MODULE), cgu_name);\n "}, {"sha": "73d5d1d0948bfab6a27b8f3639b98e158bd8d27a", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 79, "deletions": 29, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=d662083a6c78928c70cc74b600205c246dab3bf6", "patch": "@@ -105,9 +105,9 @@\n use monomorphize::collector::InliningMap;\n use rustc::dep_graph::WorkProductId;\n use rustc::hir::CodegenFnAttrFlags;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc::hir::map::DefPathData;\n-use rustc::mir::mono::{Linkage, Visibility};\n+use rustc::mir::mono::{Linkage, Visibility, CodegenUnitNameBuilder};\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n@@ -203,8 +203,8 @@ impl<'tcx> CodegenUnitExt<'tcx> for CodegenUnit<'tcx> {\n }\n \n // Anything we can't find a proper codegen unit for goes into this.\n-fn fallback_cgu_name(tcx: TyCtxt) -> InternedString {\n-    CodegenUnit::build_cgu_name(tcx, LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n+fn fallback_cgu_name(name_builder: &mut CodegenUnitNameBuilder) -> InternedString {\n+    name_builder.build_cgu_name(LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n }\n \n pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -300,6 +300,9 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let export_generics = tcx.sess.opts.share_generics() &&\n                           tcx.local_crate_exports_generics();\n \n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n+    let cgu_name_cache = &mut FxHashMap();\n+\n     for mono_item in mono_items {\n         match mono_item.instantiation_mode(tcx) {\n             InstantiationMode::GloballyShared { .. } => {}\n@@ -311,8 +314,12 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           mono_item.is_generic_fn();\n \n         let codegen_unit_name = match characteristic_def_id {\n-            Some(def_id) => compute_codegen_unit_name(tcx, def_id, is_volatile),\n-            None => fallback_cgu_name(tcx),\n+            Some(def_id) => compute_codegen_unit_name(tcx,\n+                                                      cgu_name_builder,\n+                                                      def_id,\n+                                                      is_volatile,\n+                                                      cgu_name_cache),\n+            None => fallback_cgu_name(cgu_name_builder),\n         };\n \n         let codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n@@ -336,7 +343,7 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // always ensure we have at least one CGU; otherwise, if we have a\n     // crate with just types (for example), we could wind up with no CGU\n     if codegen_units.is_empty() {\n-        let codegen_unit_name = fallback_cgu_name(tcx);\n+        let codegen_unit_name = fallback_cgu_name(cgu_name_builder);\n         codegen_units.insert(codegen_unit_name.clone(),\n                              CodegenUnit::new(codegen_unit_name.clone()));\n     }\n@@ -574,14 +581,15 @@ fn merge_codegen_units<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n         }\n     }\n \n+    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n     for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-        cgu.set_name(numbered_codegen_unit_name(tcx, index));\n+        cgu.set_name(numbered_codegen_unit_name(cgu_name_builder, index));\n     }\n }\n \n fn place_inlined_mono_items<'tcx>(initial_partitioning: PreInliningPartitioning<'tcx>,\n-                                         inlining_map: &InliningMap<'tcx>)\n-                                         -> PostInliningPartitioning<'tcx> {\n+                                  inlining_map: &InliningMap<'tcx>)\n+                                  -> PostInliningPartitioning<'tcx> {\n     let mut new_partitioning = Vec::new();\n     let mut mono_item_placements = FxHashMap();\n \n@@ -775,30 +783,72 @@ fn characteristic_def_id_of_mono_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       def_id: DefId,\n-                                       volatile: bool)\n-                                       -> InternedString {\n-    let def_path = tcx.def_path(def_id);\n-\n-    let components = def_path.data.iter().take_while(|part| {\n-        match part.data {\n-            DefPathData::Module(..) => true,\n-            _ => false,\n+type CguNameCache = FxHashMap<(DefId, bool), InternedString>;\n+\n+fn compute_codegen_unit_name(tcx: TyCtxt,\n+                             name_builder: &mut CodegenUnitNameBuilder,\n+                             def_id: DefId,\n+                             volatile: bool,\n+                             cache: &mut CguNameCache)\n+                             -> InternedString {\n+    // Find the innermost module that is not nested within a function\n+    let mut current_def_id = def_id;\n+    let mut cgu_def_id = None;\n+    // Walk backwards from the item we want to find the module for:\n+    loop {\n+        let def_key = tcx.def_key(current_def_id);\n+\n+        match def_key.disambiguated_data.data {\n+            DefPathData::Module(..) => {\n+                if cgu_def_id.is_none() {\n+                    cgu_def_id = Some(current_def_id);\n+                }\n+            }\n+            DefPathData::CrateRoot { .. } => {\n+                if cgu_def_id.is_none() {\n+                    // If we have not found a module yet, take the crate root.\n+                    cgu_def_id = Some(DefId {\n+                        krate: def_id.krate,\n+                        index: CRATE_DEF_INDEX,\n+                    });\n+                }\n+                break\n+            }\n+            _ => {\n+                // If we encounter something that is not a module, throw away\n+                // any module that we've found so far because we now know that\n+                // it is nested within something else.\n+                cgu_def_id = None;\n+            }\n         }\n-    }).map(|part| part.data.as_interned_str());\n \n-    let volatile_suffix = if volatile {\n-        Some(\"volatile\")\n-    } else {\n-        None\n-    };\n+        current_def_id.index = def_key.parent.unwrap();\n+    }\n+\n+    let cgu_def_id = cgu_def_id.unwrap();\n+\n+    cache.entry((cgu_def_id, volatile)).or_insert_with(|| {\n+        let def_path = tcx.def_path(cgu_def_id);\n+\n+        let components = def_path\n+            .data\n+            .iter()\n+            .map(|part| part.data.as_interned_str());\n+\n+        let volatile_suffix = if volatile {\n+            Some(\"volatile\")\n+        } else {\n+            None\n+        };\n \n-    CodegenUnit::build_cgu_name(tcx, def_path.krate, components, volatile_suffix)\n+        name_builder.build_cgu_name(def_path.krate, components, volatile_suffix)\n+    }).clone()\n }\n \n-fn numbered_codegen_unit_name(tcx: TyCtxt, index: usize) -> InternedString {\n-    CodegenUnit::build_cgu_name_no_mangle(tcx, LOCAL_CRATE, &[\"cgu\"], Some(index))\n+fn numbered_codegen_unit_name(name_builder: &mut CodegenUnitNameBuilder,\n+                              index: usize)\n+                              -> InternedString {\n+    name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index))\n }\n \n fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "5760cb9a8fdb651a01ba6584e072ce075c64158b", "filename": "src/test/ui/lto-duplicate-symbols.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d662083a6c78928c70cc74b600205c246dab3bf6/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr?ref=d662083a6c78928c70cc74b600205c246dab3bf6", "patch": "@@ -1,6 +1,6 @@\n warning: Linking globals named 'foo': symbol multiply defined!\n \n-error: failed to load bc of \"lto_duplicate_symbols10-8787f43e282added376259c1adb08b80.rs\": \n+error: failed to load bc of \"lto_duplicate_symbols1.3a1fbbbh-cgu.0\": \n \n error: aborting due to previous error\n "}]}