{"sha": "2d2bccf7515710b38edb45fe359e84d4a617a402", "node_id": "C_kwDOAAsO6NoAKDJkMmJjY2Y3NTE1NzEwYjM4ZWRiNDVmZTM1OWU4NGQ0YTYxN2E0MDI", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-11-10T12:59:01Z"}, "committer": {"name": "b-naber", "email": "b_naber@gmx.de", "date": "2023-02-19T22:13:07Z"}, "message": "rebase", "tree": {"sha": "fa9556fe70fb54052565eb535a034427e99d6397", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa9556fe70fb54052565eb535a034427e99d6397"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d2bccf7515710b38edb45fe359e84d4a617a402", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d2bccf7515710b38edb45fe359e84d4a617a402", "html_url": "https://github.com/rust-lang/rust/commit/2d2bccf7515710b38edb45fe359e84d4a617a402", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d2bccf7515710b38edb45fe359e84d4a617a402/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46bd77aa808ad270a4bda28104b5f9a1b42ea159", "url": "https://api.github.com/repos/rust-lang/rust/commits/46bd77aa808ad270a4bda28104b5f9a1b42ea159", "html_url": "https://github.com/rust-lang/rust/commit/46bd77aa808ad270a4bda28104b5f9a1b42ea159"}], "stats": {"total": 173, "additions": 92, "deletions": 81}, "files": [{"sha": "c0cb74098fb01738edecf7d4111668df75457868", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2d2bccf7515710b38edb45fe359e84d4a617a402/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2bccf7515710b38edb45fe359e84d4a617a402/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=2d2bccf7515710b38edb45fe359e84d4a617a402", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir::{Body, Location, Promoted};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n #[cfg(debug_assertions)]\n-use rustc_span::Symbol;\n+use rustc_span::{Span, Symbol};\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n@@ -62,16 +62,23 @@ where\n     })\n }\n \n+#[cfg(debug_assertions)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n+pub(crate) enum BoundRegionInfo {\n+    Name(Symbol),\n+    Span(Span),\n+}\n+\n #[cfg(debug_assertions)]\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n pub(crate) enum RegionCtxt {\n     Location(Location),\n     TyContext(TyContext),\n     Free(Symbol),\n-    Bound(Symbol),\n-    LateBound(Symbol),\n+    Bound(BoundRegionInfo),\n+    LateBound(BoundRegionInfo),\n     Existential(Option<Symbol>),\n-    Placeholder(Symbol),\n+    Placeholder(BoundRegionInfo),\n     Unknown,\n }\n \n@@ -86,10 +93,7 @@ impl RegionCtxt {\n         match self {\n             RegionCtxt::Unknown => 1,\n             RegionCtxt::Existential(None) => 2,\n-            RegionCtxt::Existential(Some(_anon))\n-            | RegionCtxt::Free(_anon)\n-            | RegionCtxt::Bound(_anon)\n-            | RegionCtxt::LateBound(_anon) => 2,\n+            RegionCtxt::Existential(Some(_anon)) | RegionCtxt::Free(_anon) => 2,\n             RegionCtxt::Location(_) => 3,\n             RegionCtxt::TyContext(_) => 4,\n             _ => 5,"}, {"sha": "5d3828b14c9a76f3cca3ccd026619bc1fce0b9e7", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2d2bccf7515710b38edb45fe359e84d4a617a402/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2bccf7515710b38edb45fe359e84d4a617a402/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=2d2bccf7515710b38edb45fe359e84d4a617a402", "patch": "@@ -1346,13 +1346,21 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                     #[cfg(debug_assertions)]\n                     {\n-                        use crate::renumber::RegionCtxt;\n+                        use crate::renumber::{BoundRegionInfo, RegionCtxt};\n                         use rustc_span::Symbol;\n \n-                        let name = match br.kind {\n-                            ty::BoundRegionKind::BrAnon(_) => Symbol::intern(\"anon\"),\n-                            ty::BoundRegionKind::BrNamed(_, name) => name,\n-                            ty::BoundRegionKind::BrEnv => Symbol::intern(\"env\"),\n+                        let reg_info = match br.kind {\n+                            // FIXME Probably better to use the `Span` here\n+                            ty::BoundRegionKind::BrAnon(_, Some(span)) => {\n+                                BoundRegionInfo::Span(span)\n+                            }\n+                            ty::BoundRegionKind::BrAnon(..) => {\n+                                BoundRegionInfo::Name(Symbol::intern(\"anon\"))\n+                            }\n+                            ty::BoundRegionKind::BrNamed(_, name) => BoundRegionInfo::Name(name),\n+                            ty::BoundRegionKind::BrEnv => {\n+                                BoundRegionInfo::Name(Symbol::intern(\"env\"))\n+                            }\n                         };\n \n                         self.infcx.next_region_var(\n@@ -1361,7 +1369,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 br.kind,\n                                 LateBoundRegionConversionTime::FnCall,\n                             ),\n-                            RegionCtxt::LateBound(name),\n+                            RegionCtxt::LateBound(reg_info),\n                         )\n                     }\n                 });"}, {"sha": "51ddf02629c6870da62af11d5101aa589d2c52e3", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d2bccf7515710b38edb45fe359e84d4a617a402/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2bccf7515710b38edb45fe359e84d4a617a402/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=2d2bccf7515710b38edb45fe359e84d4a617a402", "patch": "@@ -10,7 +10,7 @@ use rustc_trait_selection::traits::query::Fallible;\n use crate::constraints::OutlivesConstraint;\n use crate::diagnostics::UniverseInfo;\n #[cfg(debug_assertions)]\n-use crate::renumber::RegionCtxt;\n+use crate::renumber::{BoundRegionInfo, RegionCtxt};\n use crate::type_check::{InstantiateOpaqueType, Locations, TypeChecker};\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n@@ -130,17 +130,19 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n \n         #[cfg(debug_assertions)]\n         {\n-            let name = match placeholder.name {\n-                ty::BoundRegionKind::BrAnon(_) => Symbol::intern(\"anon\"),\n-                ty::BoundRegionKind::BrNamed(_, name) => name,\n-                ty::BoundRegionKind::BrEnv => Symbol::intern(\"env\"),\n+            let reg_info = match placeholder.name {\n+                // FIXME Probably better to use the `Span` here\n+                ty::BoundRegionKind::BrAnon(_, Some(span)) => BoundRegionInfo::Span(span),\n+                ty::BoundRegionKind::BrAnon(..) => BoundRegionInfo::Name(Symbol::intern(\"anon\")),\n+                ty::BoundRegionKind::BrNamed(_, name) => BoundRegionInfo::Name(name),\n+                ty::BoundRegionKind::BrEnv => BoundRegionInfo::Name(Symbol::intern(\"env\")),\n             };\n \n             let reg_var = reg\n                 .try_get_var()\n                 .unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n             let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-            let prev = var_to_origin.insert(reg_var, RegionCtxt::Placeholder(name));\n+            let prev = var_to_origin.insert(reg_var, RegionCtxt::Placeholder(reg_info));\n             assert!(matches!(prev, None));\n         }\n "}, {"sha": "e6abdd9b2714989eb7c93295f947b2b120646be2", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 58, "deletions": 61, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/2d2bccf7515710b38edb45fe359e84d4a617a402/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2bccf7515710b38edb45fe359e84d4a617a402/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=2d2bccf7515710b38edb45fe359e84d4a617a402", "patch": "@@ -32,7 +32,7 @@ use std::iter;\n \n use crate::nll::ToRegionVid;\n #[cfg(debug_assertions)]\n-use crate::renumber::RegionCtxt;\n+use crate::renumber::{BoundRegionInfo, RegionCtxt};\n use crate::BorrowckInferCtxt;\n \n #[derive(Debug)]\n@@ -446,7 +446,22 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 |r| {\n                     debug!(?r);\n                     if !indices.indices.contains_key(&r) {\n+                        #[cfg(not(debug_assertions))]\n                         let region_vid = self.infcx.next_nll_region_var(FR);\n+\n+                        #[cfg(debug_assertions)]\n+                        let region_vid = {\n+                            let name = match r.get_name() {\n+                                Some(name) => name,\n+                                _ => Symbol::intern(\"anon\"),\n+                            };\n+\n+                            self.infcx.next_nll_region_var(\n+                                FR,\n+                                RegionCtxt::LateBound(BoundRegionInfo::Name(name)),\n+                            )\n+                        };\n+\n                         debug!(?region_vid);\n                         indices.insert_late_bound_region(r, region_vid.to_region_vid());\n                     }\n@@ -474,7 +489,20 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         for_each_late_bound_region_in_item(self.infcx.tcx, self.mir_def.did, |r| {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n+                #[cfg(not(debug_assertions))]\n                 let region_vid = self.infcx.next_nll_region_var(FR);\n+\n+                #[cfg(debug_assertions)]\n+                let region_vid = {\n+                    let name = match r.get_name() {\n+                        Some(name) => name,\n+                        _ => Symbol::intern(\"anon\"),\n+                    };\n+\n+                    self.infcx\n+                        .next_nll_region_var(FR, RegionCtxt::LateBound(BoundRegionInfo::Name(name)))\n+                };\n+\n                 debug!(?region_vid);\n                 indices.insert_late_bound_region(r, region_vid.to_region_vid());\n             }\n@@ -773,7 +801,6 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n         })\n     }\n \n-    #[cfg(not(debug_assertions))]\n     #[instrument(level = \"debug\", skip(self, indices))]\n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n@@ -788,39 +815,19 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n         let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n             debug!(?br);\n             let liberated_region = self.tcx.mk_re_free(all_outlive_scope.to_def_id(), br.kind);\n+            #[cfg(not(debug_assertions))]\n             let region_vid = self.next_nll_region_var(origin);\n-            indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n-            debug!(?liberated_region, ?region_vid);\n-            region_vid\n-        });\n-        value\n-    }\n \n-    #[cfg(debug_assertions)]\n-    #[instrument(level = \"debug\", skip(self, indices))]\n-    fn replace_bound_regions_with_nll_infer_vars<T>(\n-        &self,\n-        origin: NllRegionVariableOrigin,\n-        all_outlive_scope: LocalDefId,\n-        value: ty::Binder<'tcx, T>,\n-        indices: &mut UniversalRegionIndices<'tcx>,\n-    ) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n-            debug!(?br);\n-            let liberated_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: all_outlive_scope.to_def_id(),\n-                bound_region: br.kind,\n-            }));\n+            #[cfg(debug_assertions)]\n+            let region_vid = {\n+                let name = match br.kind.get_name() {\n+                    Some(name) => name,\n+                    _ => Symbol::intern(\"anon\"),\n+                };\n \n-            let name = match br.kind.get_name() {\n-                Some(name) => name,\n-                _ => Symbol::intern(\"anon\"),\n+                self.next_nll_region_var(origin, RegionCtxt::Bound(BoundRegionInfo::Name(name)))\n             };\n \n-            let region_vid = self.next_nll_region_var(origin, RegionCtxt::Bound(name));\n             indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n             debug!(?liberated_region, ?region_vid);\n             region_vid\n@@ -837,7 +844,6 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n     /// entries for them and store them in the indices map. This code iterates over the complete\n     /// set of late-bound regions and checks for any that we have not yet seen, adding them to the\n     /// inputs vector.\n-    #[cfg(not(debug_assertions))]\n     #[instrument(skip(self, indices))]\n     fn replace_late_bound_regions_with_nll_infer_vars_in_recursive_scope(\n         &self,\n@@ -847,7 +853,19 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n         for_each_late_bound_region_in_recursive_scope(self.tcx, mir_def_id, |r| {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n+                #[cfg(not(debug_assertions))]\n                 let region_vid = self.next_nll_region_var(FR);\n+\n+                #[cfg(debug_assertions)]\n+                let region_vid = {\n+                    let name = match r.get_name() {\n+                        Some(name) => name,\n+                        _ => Symbol::intern(\"anon\"),\n+                    };\n+\n+                    self.next_nll_region_var(FR, RegionCtxt::LateBound(BoundRegionInfo::Name(name)))\n+                };\n+\n                 debug!(?region_vid);\n                 indices.insert_late_bound_region(r, region_vid.to_region_vid());\n             }\n@@ -863,40 +881,19 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n         for_each_late_bound_region_in_item(self.tcx, mir_def_id, |r| {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n+                #[cfg(not(debug_assertions))]\n                 let region_vid = self.next_nll_region_var(FR);\n-                debug!(?region_vid);\n-                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n-            }\n-        });\n-    }\n \n-    /// Finds late-bound regions that do not appear in the parameter listing and adds them to the\n-    /// indices vector. Typically, we identify late-bound regions as we process the inputs and\n-    /// outputs of the closure/function. However, sometimes there are late-bound regions which do\n-    /// not appear in the fn parameters but which are nonetheless in scope. The simplest case of\n-    /// this are unused functions, like fn foo<'a>() { } (see e.g., #51351). Despite not being used,\n-    /// users can still reference these regions (e.g., let x: &'a u32 = &22;), so we need to create\n-    /// entries for them and store them in the indices map. This code iterates over the complete\n-    /// set of late-bound regions and checks for any that we have not yet seen, adding them to the\n-    /// inputs vector.\n-    #[cfg(debug_assertions)]\n-    #[instrument(skip(self, indices))]\n-    fn replace_late_bound_regions_with_nll_infer_vars(\n-        &self,\n-        mir_def_id: LocalDefId,\n-        indices: &mut UniversalRegionIndices<'tcx>,\n-    ) {\n-        let typeck_root_def_id = self.tcx.typeck_root_def_id(mir_def_id.to_def_id());\n-        for_each_late_bound_region_defined_on(self.tcx, typeck_root_def_id, |r| {\n-            debug!(?r);\n-            if !indices.indices.contains_key(&r) {\n-                let name = match r.get_name() {\n-                    Some(name) => name,\n-                    _ => Symbol::intern(\"anon\"),\n+                #[cfg(debug_assertions)]\n+                let region_vid = {\n+                    let name = match r.get_name() {\n+                        Some(name) => name,\n+                        _ => Symbol::intern(\"anon\"),\n+                    };\n+\n+                    self.next_nll_region_var(FR, RegionCtxt::LateBound(BoundRegionInfo::Name(name)))\n                 };\n \n-                let region_vid = self.next_nll_region_var(FR, RegionCtxt::LateBound(name));\n-                debug!(?region_vid);\n                 indices.insert_late_bound_region(r, region_vid.to_region_vid());\n             }\n         });"}]}