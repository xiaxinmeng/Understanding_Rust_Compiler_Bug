{"sha": "5fbfcd88728a2c2c6400868fbd19117527d81e0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYmZjZDg4NzI4YTJjMmM2NDAwODY4ZmJkMTkxMTc1MjdkODFlMGI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T15:54:33Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T17:57:05Z"}, "message": "typeck/pat.rs: extract `error_inexistent_fields`.", "tree": {"sha": "afa4f4fe183ac48bbf6ceb74d23a84e26c1f6844", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afa4f4fe183ac48bbf6ceb74d23a84e26c1f6844"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fbfcd88728a2c2c6400868fbd19117527d81e0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fbfcd88728a2c2c6400868fbd19117527d81e0b", "html_url": "https://github.com/rust-lang/rust/commit/5fbfcd88728a2c2c6400868fbd19117527d81e0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fbfcd88728a2c2c6400868fbd19117527d81e0b/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba2a784c38c5e87e746457645184d4dec957941f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba2a784c38c5e87e746457645184d4dec957941f", "html_url": "https://github.com/rust-lang/rust/commit/ba2a784c38c5e87e746457645184d4dec957941f"}], "stats": {"total": 130, "additions": 74, "deletions": 56}, "files": [{"sha": "f0ecbd674c07dcccaa035db114c92d6aa536eca5", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 74, "deletions": 56, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/5fbfcd88728a2c2c6400868fbd19117527d81e0b/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbfcd88728a2c2c6400868fbd19117527d81e0b/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=5fbfcd88728a2c2c6400868fbd19117527d81e0b", "patch": "@@ -796,66 +796,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             self.check_pat(&field.pat, field_ty, def_bm, None);\n         }\n+\n         let mut unmentioned_fields = variant.fields\n                 .iter()\n                 .map(|field| field.ident.modern())\n                 .filter(|ident| !used_fields.contains_key(&ident))\n                 .collect::<Vec<_>>();\n-        if inexistent_fields.len() > 0 && !variant.recovered {\n-            let (field_names, t, plural) = if inexistent_fields.len() == 1 {\n-                (format!(\"a field named `{}`\", inexistent_fields[0]), \"this\", \"\")\n-            } else {\n-                (format!(\"fields named {}\",\n-                         inexistent_fields.iter()\n-                            .map(|ident| format!(\"`{}`\", ident))\n-                            .collect::<Vec<String>>()\n-                            .join(\", \")), \"these\", \"s\")\n-            };\n-            let spans = inexistent_fields.iter().map(|ident| ident.span).collect::<Vec<_>>();\n-            let mut err = struct_span_err!(tcx.sess,\n-                                           spans,\n-                                           E0026,\n-                                           \"{} `{}` does not have {}\",\n-                                           kind_name,\n-                                           tcx.def_path_str(variant.def_id),\n-                                           field_names);\n-            if let Some(ident) = inexistent_fields.last() {\n-                err.span_label(ident.span,\n-                               format!(\"{} `{}` does not have {} field{}\",\n-                                       kind_name,\n-                                       tcx.def_path_str(variant.def_id),\n-                                       t,\n-                                       plural));\n-                if plural == \"\" {\n-                    let input = unmentioned_fields.iter().map(|field| &field.name);\n-                    let suggested_name =\n-                        find_best_match_for_name(input, &ident.as_str(), None);\n-                    if let Some(suggested_name) = suggested_name {\n-                        err.span_suggestion(\n-                            ident.span,\n-                            \"a field with a similar name exists\",\n-                            suggested_name.to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n \n-                        // we don't want to throw `E0027` in case we have thrown `E0026` for them\n-                        unmentioned_fields.retain(|&x| x.as_str() != suggested_name.as_str());\n-                    }\n-                }\n-            }\n-            if tcx.sess.teach(&err.get_code().unwrap()) {\n-                err.note(\n-                    \"This error indicates that a struct pattern attempted to \\\n-                     extract a non-existent field from a struct. Struct fields \\\n-                     are identified by the name used before the colon : so struct \\\n-                     patterns should resemble the declaration of the struct type \\\n-                     being matched.\\n\\n\\\n-                     If you are using shorthand field patterns but want to refer \\\n-                     to the struct field by a different name, you should rename \\\n-                     it explicitly.\"\n-                );\n-            }\n-            err.emit();\n+        if inexistent_fields.len() > 0 && !variant.recovered {\n+            self.error_inexistent_fields(\n+                kind_name,\n+                &inexistent_fields,\n+                &mut unmentioned_fields,\n+                variant\n+            );\n         }\n \n         // Require `..` if struct has non_exhaustive attribute.\n@@ -874,7 +828,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 tcx.sess.span_err(span, \"`..` cannot be used in union patterns\");\n             }\n         } else if !etc && unmentioned_fields.len() > 0 {\n-            self.error_unmentioned_fields(span, unmentioned_fields, variant);\n+            self.error_unmentioned_fields(span, &unmentioned_fields, variant);\n         }\n         no_field_errors\n     }\n@@ -890,10 +844,74 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         .emit();\n     }\n \n+    fn error_inexistent_fields(\n+        &self,\n+        kind_name: &str,\n+        inexistent_fields: &[ast::Ident],\n+        unmentioned_fields: &mut Vec<ast::Ident>,\n+        variant: &ty::VariantDef,\n+    ) {\n+        let tcx = self.tcx;\n+        let (field_names, t, plural) = if inexistent_fields.len() == 1 {\n+            (format!(\"a field named `{}`\", inexistent_fields[0]), \"this\", \"\")\n+        } else {\n+            (format!(\"fields named {}\",\n+                        inexistent_fields.iter()\n+                        .map(|ident| format!(\"`{}`\", ident))\n+                        .collect::<Vec<String>>()\n+                        .join(\", \")), \"these\", \"s\")\n+        };\n+        let spans = inexistent_fields.iter().map(|ident| ident.span).collect::<Vec<_>>();\n+        let mut err = struct_span_err!(tcx.sess,\n+                                        spans,\n+                                        E0026,\n+                                        \"{} `{}` does not have {}\",\n+                                        kind_name,\n+                                        tcx.def_path_str(variant.def_id),\n+                                        field_names);\n+        if let Some(ident) = inexistent_fields.last() {\n+            err.span_label(ident.span,\n+                            format!(\"{} `{}` does not have {} field{}\",\n+                                    kind_name,\n+                                    tcx.def_path_str(variant.def_id),\n+                                    t,\n+                                    plural));\n+            if plural == \"\" {\n+                let input = unmentioned_fields.iter().map(|field| &field.name);\n+                let suggested_name =\n+                    find_best_match_for_name(input, &ident.as_str(), None);\n+                if let Some(suggested_name) = suggested_name {\n+                    err.span_suggestion(\n+                        ident.span,\n+                        \"a field with a similar name exists\",\n+                        suggested_name.to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+\n+                    // we don't want to throw `E0027` in case we have thrown `E0026` for them\n+                    unmentioned_fields.retain(|&x| x.as_str() != suggested_name.as_str());\n+                }\n+            }\n+        }\n+        if tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\n+                \"This error indicates that a struct pattern attempted to \\\n+                    extract a non-existent field from a struct. Struct fields \\\n+                    are identified by the name used before the colon : so struct \\\n+                    patterns should resemble the declaration of the struct type \\\n+                    being matched.\\n\\n\\\n+                    If you are using shorthand field patterns but want to refer \\\n+                    to the struct field by a different name, you should rename \\\n+                    it explicitly.\"\n+            );\n+        }\n+        err.emit();\n+    }\n+\n     fn error_unmentioned_fields(\n         &self,\n         span: Span,\n-        unmentioned_fields: Vec<ast::Ident>,\n+        unmentioned_fields: &[ast::Ident],\n         variant: &ty::VariantDef,\n     ) {\n         let field_names = if unmentioned_fields.len() == 1 {"}]}