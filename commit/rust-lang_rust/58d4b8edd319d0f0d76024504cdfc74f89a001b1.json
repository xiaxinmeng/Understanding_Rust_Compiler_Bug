{"sha": "58d4b8edd319d0f0d76024504cdfc74f89a001b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZDRiOGVkZDMxOWQwZjBkNzYwMjQ1MDRjZGZjNzRmODlhMDAxYjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-21T16:49:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-28T16:05:45Z"}, "message": "Modify trans to skip generating `.o` files\n\nThis checks the `previous_work_products` data from the dep-graph and\ntries to simply copy a `.o` file if possible.  We also add new\nwork-products into the dep-graph, and create edges to/from the dep-node\nfor a work-product.", "tree": {"sha": "83a92fe303444117e45ba19cfc78bbef41e2ff7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83a92fe303444117e45ba19cfc78bbef41e2ff7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58d4b8edd319d0f0d76024504cdfc74f89a001b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58d4b8edd319d0f0d76024504cdfc74f89a001b1", "html_url": "https://github.com/rust-lang/rust/commit/58d4b8edd319d0f0d76024504cdfc74f89a001b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58d4b8edd319d0f0d76024504cdfc74f89a001b1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cca4804251957646d4840bf33b3b13e3f2b645de", "url": "https://api.github.com/repos/rust-lang/rust/commits/cca4804251957646d4840bf33b3b13e3f2b645de", "html_url": "https://github.com/rust-lang/rust/commit/cca4804251957646d4840bf33b3b13e3f2b645de"}], "stats": {"total": 483, "additions": 385, "deletions": 98}, "files": [{"sha": "0d11b0794feacea61a4292f1be2c7bc7286b0d58", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=58d4b8edd319d0f0d76024504cdfc74f89a001b1", "patch": "@@ -41,4 +41,6 @@ pub use assert_dep_graph::assert_dep_graph;\n pub use calculate_svh::SvhCalculate;\n pub use persist::load_dep_graph;\n pub use persist::save_dep_graph;\n+pub use persist::save_trans_partition;\n pub use persist::save_work_products;\n+pub use persist::in_incr_comp_dir;"}, {"sha": "1157f494ce604e32c2d9fdd5512416f1c8c967fe", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=58d4b8edd319d0f0d76024504cdfc74f89a001b1", "patch": "@@ -19,7 +19,10 @@ mod hash;\n mod load;\n mod save;\n mod util;\n+mod work_product;\n \n pub use self::load::load_dep_graph;\n pub use self::save::save_dep_graph;\n pub use self::save::save_work_products;\n+pub use self::work_product::save_trans_partition;\n+pub use self::util::in_incr_comp_dir;"}, {"sha": "01ac3f6c391d9d2708ca8ec30042b775b46acd14", "filename": "src/librustc_incremental/persist/work_product.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs?ref=58d4b8edd319d0f0d76024504cdfc74f89a001b1", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains files for saving intermediate work-products.\n+\n+use persist::util::*;\n+use rustc::dep_graph::{WorkProduct, WorkProductId};\n+use rustc::session::Session;\n+use std::fs;\n+use std::path::Path;\n+use std::sync::Arc;\n+\n+pub fn save_trans_partition(sess: &Session,\n+                            partition_name: &str,\n+                            partition_hash: u64,\n+                            path_to_obj_file: &Path) {\n+    debug!(\"save_trans_partition({:?},{},{})\",\n+           partition_name,\n+           partition_hash,\n+           path_to_obj_file.display());\n+    if sess.opts.incremental.is_none() {\n+        return;\n+    }\n+    let id = Arc::new(WorkProductId::PartitionObjectFile(partition_name.to_string()));\n+    let file_name = format!(\"cgu-{}\", partition_name);\n+    let path_in_incr_dir = in_incr_comp_dir(sess, &file_name).unwrap();\n+\n+    // try to delete the file if it already exists\n+    //\n+    // FIXME(#34955) we can be smarter here -- if we are re-using, no need to do anything\n+    if path_in_incr_dir.exists() {\n+        let _ = fs::remove_file(&path_in_incr_dir);\n+    }\n+\n+    match\n+        fs::hard_link(path_to_obj_file, &path_in_incr_dir)\n+        .or_else(|_| fs::copy(path_to_obj_file, &path_in_incr_dir).map(|_| ()))\n+    {\n+        Ok(_) => {\n+            let work_product = WorkProduct {\n+                input_hash: partition_hash,\n+                file_name: file_name,\n+            };\n+            sess.dep_graph.insert_work_product(&id, work_product);\n+        }\n+        Err(err) => {\n+            sess.warn(&format!(\"error copying object file `{}` \\\n+                                to incremental directory as `{}`: {}\",\n+                               path_to_obj_file.display(),\n+                               path_in_incr_dir.display(),\n+                               err));\n+        }\n+    }\n+}"}, {"sha": "70925218781bd1144046b1a6951c78be52743413", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=58d4b8edd319d0f0d76024504cdfc74f89a001b1", "patch": "@@ -10,13 +10,14 @@\n \n use back::lto;\n use back::link::{get_linker, remove};\n+use rustc_incremental::save_trans_partition;\n use session::config::{OutputFilenames, Passes, SomePasses, AllPasses};\n use session::Session;\n use session::config::{self, OutputType};\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef, ContextRef};\n use llvm::SMDiagnosticRef;\n-use {CrateTranslation, ModuleTranslation};\n+use {CrateTranslation, ModuleLlvm, ModuleSource, ModuleTranslation};\n use util::common::time;\n use util::common::path2cstr;\n use errors::{self, Handler, Level, DiagnosticBuilder};\n@@ -26,6 +27,7 @@ use syntax_pos::MultiSpan;\n use std::collections::HashMap;\n use std::ffi::{CStr, CString};\n use std::fs;\n+use std::io;\n use std::path::{Path, PathBuf};\n use std::str;\n use std::sync::{Arc, Mutex};\n@@ -422,10 +424,11 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n // Unsafe due to LLVM calls.\n unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                                mtrans: ModuleTranslation,\n+                               mllvm: ModuleLlvm,\n                                config: ModuleConfig,\n                                output_names: OutputFilenames) {\n-    let llmod = mtrans.llmod;\n-    let llcx = mtrans.llcx;\n+    let llmod = mllvm.llmod;\n+    let llcx = mllvm.llcx;\n     let tm = config.tm;\n \n     // llcx doesn't outlive this function, so we can put this on the stack.\n@@ -628,8 +631,14 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n pub fn cleanup_llvm(trans: &CrateTranslation) {\n     for module in trans.modules.iter() {\n         unsafe {\n-            llvm::LLVMDisposeModule(module.llmod);\n-            llvm::LLVMContextDispose(module.llcx);\n+            match module.source {\n+                ModuleSource::Translated(llvm) => {\n+                    llvm::LLVMDisposeModule(llvm.llmod);\n+                    llvm::LLVMContextDispose(llvm.llcx);\n+                }\n+                ModuleSource::Preexisting(_) => {\n+                }\n+            }\n         }\n     }\n }\n@@ -743,6 +752,13 @@ pub fn run_passes(sess: &Session,\n         run_work_multithreaded(sess, work_items, num_workers);\n     }\n \n+    // If in incr. comp. mode, preserve the `.o` files for potential re-use\n+    for mtrans in trans.modules.iter() {\n+        let path_to_obj = crate_output.temp_path(OutputType::Object, Some(&mtrans.name));\n+        debug!(\"wrote module {:?} to {:?}\", mtrans.name, path_to_obj);\n+        save_trans_partition(sess, &mtrans.name, mtrans.symbol_name_hash, &path_to_obj);\n+    }\n+\n     // All codegen is finished.\n     unsafe {\n         llvm::LLVMRustDisposeTargetMachine(tm);\n@@ -913,13 +929,46 @@ fn build_work_item(sess: &Session,\n     }\n }\n \n+fn link_or_copy<P: AsRef<Path>, Q: AsRef<Path>>(p: P, q: Q) -> io::Result<()> {\n+    let p = p.as_ref();\n+    let q = q.as_ref();\n+    if q.exists() {\n+        try!(fs::remove_file(&q));\n+    }\n+    fs::hard_link(p, q)\n+        .or_else(|_| fs::copy(p, q).map(|_| ()))\n+}\n+\n fn execute_work_item(cgcx: &CodegenContext,\n                      work_item: WorkItem) {\n     unsafe {\n-        optimize_and_codegen(cgcx,\n-                             work_item.mtrans,\n-                             work_item.config,\n-                             work_item.output_names);\n+        match work_item.mtrans.source {\n+            ModuleSource::Translated(mllvm) => {\n+                debug!(\"llvm-optimizing {:?}\", work_item.mtrans.name);\n+                optimize_and_codegen(cgcx,\n+                                     work_item.mtrans,\n+                                     mllvm,\n+                                     work_item.config,\n+                                     work_item.output_names);\n+            }\n+            ModuleSource::Preexisting(ref buf) => {\n+                let obj_out = work_item.output_names.temp_path(OutputType::Object,\n+                                                               Some(&work_item.mtrans.name));\n+                debug!(\"copying pre-existing module `{}` from {} to {}\",\n+                       work_item.mtrans.name,\n+                       buf.display(),\n+                       obj_out.display());\n+                match link_or_copy(buf, &obj_out) {\n+                    Ok(()) => { }\n+                    Err(err) => {\n+                        cgcx.handler.err(&format!(\"unable to copy {} to {}: {}\",\n+                                                  buf.display(),\n+                                                  obj_out.display(),\n+                                                  err));\n+                    }\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "a77ababaa63556ef0b5a4358240bca8043394bf2", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 97, "deletions": 40, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=58d4b8edd319d0f0d76024504cdfc74f89a001b1", "patch": "@@ -26,6 +26,8 @@\n #![allow(non_camel_case_types)]\n \n use super::CrateTranslation;\n+use super::ModuleLlvm;\n+use super::ModuleSource;\n use super::ModuleTranslation;\n \n use back::link;\n@@ -43,6 +45,7 @@ use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n+use rustc_incremental::in_incr_comp_dir;\n use rustc::mir::mir_map::MirMap;\n use rustc_data_structures::graph::OUTGOING;\n use session::config::{self, NoDebugInfo, FullDebugInfo};\n@@ -99,6 +102,7 @@ use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n use std::ptr;\n use std::rc::Rc;\n+use std::path::PathBuf;\n use std::str;\n use std::{i8, i16, i32, i64};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -2133,7 +2137,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n \n     let instance = Instance::mono(ccx.shared(), main_def_id);\n \n-    if !ccx.codegen_unit().items.contains_key(&TransItem::Fn(instance)) {\n+    if !ccx.codegen_unit().contains_item(&TransItem::Fn(instance)) {\n         // We want to create the wrapper in the same codegen unit as Rust's main\n         // function.\n         return;\n@@ -2270,7 +2274,7 @@ fn internalize_symbols<'a, 'tcx>(ccxs: &CrateContextList<'a, 'tcx>,\n \n         // Collect all symbols that need to stay externally visible because they\n         // are referenced via a declaration in some other codegen unit.\n-        for ccx in ccxs.iter() {\n+        for ccx in ccxs.iter_need_trans() {\n             for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n                 // We only care about external declarations (not definitions)\n@@ -2315,7 +2319,7 @@ fn internalize_symbols<'a, 'tcx>(ccxs: &CrateContextList<'a, 'tcx>,\n         // Examine each external definition.  If the definition is not used in\n         // any other compilation unit, and is not reachable from other crates,\n         // then give it internal linkage.\n-        for ccx in ccxs.iter() {\n+        for ccx in ccxs.iter_need_trans() {\n             for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n \n@@ -2362,7 +2366,7 @@ fn create_imps(cx: &CrateContextList) {\n         \"\\x01__imp_\"\n     };\n     unsafe {\n-        for ccx in cx.iter() {\n+        for ccx in cx.iter_need_trans() {\n             let exported: Vec<_> = iter_globals(ccx.llmod())\n                                        .filter(|&val| {\n                                            llvm::LLVMGetLinkage(val) ==\n@@ -2514,8 +2518,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let metadata_module = ModuleTranslation {\n         name: \"metadata\".to_string(),\n-        llcx: shared_ccx.metadata_llcx(),\n-        llmod: shared_ccx.metadata_llmod(),\n+        symbol_name_hash: 0, // we always rebuild metadata, at least for now\n+        source: ModuleSource::Translated(ModuleLlvm {\n+            llcx: shared_ccx.metadata_llcx(),\n+            llmod: shared_ccx.metadata_llmod(),\n+        }),\n     };\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n@@ -2525,14 +2532,29 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let symbol_map = Rc::new(symbol_map);\n \n+    let previous_work_products = trans_reuse_previous_work_products(tcx,\n+                                                                    &codegen_units,\n+                                                                    &symbol_map);\n+\n     let crate_context_list = CrateContextList::new(&shared_ccx,\n                                                    codegen_units,\n+                                                   previous_work_products,\n                                                    symbol_map.clone());\n-    let modules = crate_context_list.iter()\n-        .map(|ccx| ModuleTranslation {\n-            name: String::from(&ccx.codegen_unit().name[..]),\n-            llcx: ccx.llcx(),\n-            llmod: ccx.llmod()\n+    let modules: Vec<_> = crate_context_list.iter_all()\n+        .map(|ccx| {\n+            let source = match ccx.previous_work_product() {\n+                Some(buf) => ModuleSource::Preexisting(buf.clone()),\n+                None => ModuleSource::Translated(ModuleLlvm {\n+                    llcx: ccx.llcx(),\n+                    llmod: ccx.llmod(),\n+                }),\n+            };\n+\n+            ModuleTranslation {\n+                name: String::from(ccx.codegen_unit().name()),\n+                symbol_name_hash: ccx.codegen_unit().compute_symbol_name_hash(tcx, &symbol_map),\n+                source: source,\n+            }\n         })\n         .collect();\n \n@@ -2551,41 +2573,44 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     // Instantiate translation items without filling out definitions yet...\n-    for ccx in crate_context_list.iter() {\n-        let trans_items = ccx.codegen_unit()\n-                             .items_in_deterministic_order(tcx, &symbol_map);\n+    for ccx in crate_context_list.iter_need_trans() {\n+        let cgu = ccx.codegen_unit();\n+        let trans_items = cgu.items_in_deterministic_order(tcx, &symbol_map);\n \n-        for (trans_item, linkage) in trans_items {\n-            trans_item.predefine(&ccx, linkage);\n-        }\n+        tcx.dep_graph.with_task(cgu.work_product_dep_node(), || {\n+            for (trans_item, linkage) in trans_items {\n+                trans_item.predefine(&ccx, linkage);\n+            }\n+        });\n     }\n \n     // ... and now that we have everything pre-defined, fill out those definitions.\n-    for ccx in crate_context_list.iter() {\n-        let trans_items = ccx.codegen_unit()\n-                             .items_in_deterministic_order(tcx, &symbol_map);\n-\n-        for (trans_item, _) in trans_items {\n-           trans_item.define(&ccx);\n-        }\n+    for ccx in crate_context_list.iter_need_trans() {\n+        let cgu = ccx.codegen_unit();\n+        let trans_items = cgu.items_in_deterministic_order(tcx, &symbol_map);\n+        tcx.dep_graph.with_task(cgu.work_product_dep_node(), || {\n+            for (trans_item, _) in trans_items {\n+                trans_item.define(&ccx);\n+            }\n \n-        // If this codegen unit contains the main function, also create the\n-        // wrapper here\n-        maybe_create_entry_wrapper(&ccx);\n+            // If this codegen unit contains the main function, also create the\n+            // wrapper here\n+            maybe_create_entry_wrapper(&ccx);\n \n-        // Run replace-all-uses-with for statics that need it\n-        for &(old_g, new_g) in ccx.statics_to_rauw().borrow().iter() {\n-            unsafe {\n-                let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n-                llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n-                llvm::LLVMDeleteGlobal(old_g);\n+            // Run replace-all-uses-with for statics that need it\n+            for &(old_g, new_g) in ccx.statics_to_rauw().borrow().iter() {\n+                unsafe {\n+                    let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n+                    llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n+                    llvm::LLVMDeleteGlobal(old_g);\n+                }\n             }\n-        }\n \n-        // Finalize debuginfo\n-        if ccx.sess().opts.debuginfo != NoDebugInfo {\n-            debuginfo::finalize(&ccx);\n-        }\n+            // Finalize debuginfo\n+            if ccx.sess().opts.debuginfo != NoDebugInfo {\n+                debuginfo::finalize(&ccx);\n+            }\n+        });\n     }\n \n     symbol_names_test::report_symbol_names(&shared_ccx);\n@@ -2679,6 +2704,38 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+/// For each CGU, identify if we can reuse an existing object file (or\n+/// maybe other context).\n+fn trans_reuse_previous_work_products(tcx: TyCtxt,\n+                                      codegen_units: &[CodegenUnit],\n+                                      symbol_map: &SymbolMap)\n+                                      -> Vec<Option<PathBuf>> {\n+    debug!(\"trans_reuse_previous_work_products()\");\n+    codegen_units\n+        .iter()\n+        .map(|cgu| {\n+            let id = cgu.work_product_id();\n+\n+            let hash = cgu.compute_symbol_name_hash(tcx, symbol_map);\n+\n+            debug!(\"trans_reuse_previous_work_products: id={:?} hash={}\", id, hash);\n+\n+            if let Some(work_product) = tcx.dep_graph.previous_work_product(&id) {\n+                if work_product.input_hash == hash {\n+                    debug!(\"trans_reuse_previous_work_products: reusing {:?}\", work_product);\n+                    return Some(in_incr_comp_dir(tcx.sess, &work_product.file_name).unwrap());\n+                } else {\n+                    debug!(\"trans_reuse_previous_work_products: \\\n+                            not reusing {:?} because hash changed to {:?}\",\n+                           work_product, hash);\n+                }\n+            }\n+\n+            None\n+        })\n+        .collect()\n+}\n+\n fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n                                                      -> (Vec<CodegenUnit<'tcx>>, SymbolMap<'tcx>) {\n     let time_passes = scx.sess().time_passes();\n@@ -2739,10 +2796,10 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         let mut item_to_cgus = HashMap::new();\n \n         for cgu in &codegen_units {\n-            for (&trans_item, &linkage) in &cgu.items {\n+            for (&trans_item, &linkage) in cgu.items() {\n                 item_to_cgus.entry(trans_item)\n                             .or_insert(Vec::new())\n-                            .push((cgu.name.clone(), linkage));\n+                            .push((cgu.name().clone(), linkage));\n             }\n         }\n "}, {"sha": "571d2731fb21648be44c087a2541cd892c2945e7", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=58d4b8edd319d0f0d76024504cdfc74f89a001b1", "patch": "@@ -1029,7 +1029,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                 assert!(!ccx.external_srcs().borrow().contains_key(&id));\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n-                                                         .items\n+                                                         .items()\n                                                          .contains_key(&TransItem::Static(id));\n                 if defined_in_current_codegen_unit {\n                     if declare::get_declared_value(ccx, sym).is_none() {"}, {"sha": "bf69629821285af952ae2b268e4ac42743ccaefb", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 53, "deletions": 16, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=58d4b8edd319d0f0d76024504cdfc74f89a001b1", "patch": "@@ -40,6 +40,7 @@ use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n+use std::path::PathBuf;\n use std::marker::PhantomData;\n use std::ptr;\n use std::rc::Rc;\n@@ -95,6 +96,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n pub struct LocalCrateContext<'tcx> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n+    previous_work_product: Option<PathBuf>,\n     tn: TypeNames, // FIXME: This seems to be largely unused.\n     codegen_unit: CodegenUnit<'tcx>,\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n@@ -198,24 +200,39 @@ pub struct CrateContextList<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n-\n     pub fn new(shared_ccx: &'a SharedCrateContext<'a, 'tcx>,\n                codegen_units: Vec<CodegenUnit<'tcx>>,\n+               previous_work_products: Vec<Option<PathBuf>>,\n                symbol_map: Rc<SymbolMap<'tcx>>)\n                -> CrateContextList<'a, 'tcx> {\n         CrateContextList {\n             shared: shared_ccx,\n-            local_ccxs: codegen_units.into_iter().map(|codegen_unit| {\n-                LocalCrateContext::new(shared_ccx, codegen_unit, symbol_map.clone())\n+            local_ccxs: codegen_units.into_iter().zip(previous_work_products).map(|(cgu, path)| {\n+                LocalCrateContext::new(shared_ccx, cgu, path, symbol_map.clone())\n             }).collect()\n         }\n     }\n \n-    pub fn iter<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n+    /// Iterate over all crate contexts, whether or not they need\n+    /// translation.  That is, whether or not a `.o` file is available\n+    /// for re-use from a previous incr. comp.).\n+    pub fn iter_all<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n         CrateContextIterator {\n             shared: self.shared,\n             index: 0,\n-            local_ccxs: &self.local_ccxs[..]\n+            local_ccxs: &self.local_ccxs[..],\n+            filter_to_previous_work_product_unavail: false,\n+        }\n+    }\n+\n+    /// Iterator over all CCX that need translation (cannot reuse results from\n+    /// previous incr. comp.).\n+    pub fn iter_need_trans<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n+        CrateContextIterator {\n+            shared: self.shared,\n+            index: 0,\n+            local_ccxs: &self.local_ccxs[..],\n+            filter_to_previous_work_product_unavail: true,\n         }\n     }\n \n@@ -239,24 +256,38 @@ pub struct CrateContextIterator<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n     local_ccxs: &'a [LocalCrateContext<'tcx>],\n     index: usize,\n+\n+    /// if true, only return results where `previous_work_product` is none\n+    filter_to_previous_work_product_unavail: bool,\n }\n \n impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n     type Item = CrateContext<'a, 'tcx>;\n \n     fn next(&mut self) -> Option<CrateContext<'a, 'tcx>> {\n-        if self.index >= self.local_ccxs.len() {\n-            return None;\n-        }\n+        loop {\n+            if self.index >= self.local_ccxs.len() {\n+                return None;\n+            }\n \n-        let index = self.index;\n-        self.index += 1;\n+            let index = self.index;\n+            self.index += 1;\n \n-        Some(CrateContext {\n-            shared: self.shared,\n-            index: index,\n-            local_ccxs: self.local_ccxs,\n-        })\n+            let ccx = CrateContext {\n+                shared: self.shared,\n+                index: index,\n+                local_ccxs: self.local_ccxs,\n+            };\n+\n+            if\n+                self.filter_to_previous_work_product_unavail &&\n+                ccx.previous_work_product().is_some()\n+            {\n+                continue;\n+            }\n+\n+            return Some(ccx);\n+        }\n     }\n }\n \n@@ -510,6 +541,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n impl<'tcx> LocalCrateContext<'tcx> {\n     fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n                codegen_unit: CodegenUnit<'tcx>,\n+               previous_work_product: Option<PathBuf>,\n                symbol_map: Rc<SymbolMap<'tcx>>)\n            -> LocalCrateContext<'tcx> {\n         unsafe {\n@@ -521,7 +553,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n             // crashes if the module identifier is same as other symbols\n             // such as a function name in the module.\n             // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-            let llmod_id = format!(\"{}.rs\", codegen_unit.name);\n+            let llmod_id = format!(\"{}.rs\", codegen_unit.name());\n \n             let (llcx, llmod) = create_context_and_module(&shared.tcx.sess,\n                                                           &llmod_id[..]);\n@@ -535,6 +567,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n             let local_ccx = LocalCrateContext {\n                 llmod: llmod,\n                 llcx: llcx,\n+                previous_work_product: previous_work_product,\n                 codegen_unit: codegen_unit,\n                 tn: TypeNames::new(),\n                 needs_unwind_cleanup_cache: RefCell::new(FnvHashMap()),\n@@ -694,6 +727,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().llcx\n     }\n \n+    pub fn previous_work_product(&self) -> Option<&PathBuf> {\n+        self.local().previous_work_product.as_ref()\n+    }\n+\n     pub fn codegen_unit(&self) -> &CodegenUnit<'tcx> {\n         &self.local().codegen_unit\n     }"}, {"sha": "6bc48546dfa8c7c9b7b9f4454d0218d7618c8137", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=58d4b8edd319d0f0d76024504cdfc74f89a001b1", "patch": "@@ -239,7 +239,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     Falling back to on-demand instantiation.\",\n                     g,\n                     TransItem::DropGlue(g).to_raw_string(),\n-                    ccx.codegen_unit().name);\n+                    ccx.codegen_unit().name());\n \n             ccx.stats().n_fallback_instantiations.set(ccx.stats()\n                                                          .n_fallback_instantiations"}, {"sha": "6ac64d3291084de2eb286579213e5782a6a9bc4d", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=58d4b8edd319d0f0d76024504cdfc74f89a001b1", "patch": "@@ -37,6 +37,8 @@\n #![feature(unicode)]\n #![feature(question_mark)]\n \n+use std::path::PathBuf;\n+\n extern crate arena;\n extern crate flate;\n extern crate getopts;\n@@ -133,6 +135,18 @@ mod value;\n #[derive(Clone)]\n pub struct ModuleTranslation {\n     pub name: String,\n+    pub symbol_name_hash: u64,\n+    pub source: ModuleSource,\n+}\n+\n+#[derive(Clone)]\n+pub enum ModuleSource {\n+    Preexisting(PathBuf),\n+    Translated(ModuleLlvm),\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct ModuleLlvm {\n     pub llcx: llvm::ContextRef,\n     pub llmod: llvm::ModuleRef,\n }"}, {"sha": "96a05f11bfd119e65fcecc4b9b7a6e7c92bf81b6", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=58d4b8edd319d0f0d76024504cdfc74f89a001b1", "patch": "@@ -52,7 +52,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"leaving monomorphic fn {:?}\", instance);\n         return (val, mono_ty);\n     } else {\n-        assert!(!ccx.codegen_unit().items.contains_key(&TransItem::Fn(instance)));\n+        assert!(!ccx.codegen_unit().contains_item(&TransItem::Fn(instance)));\n     }\n \n     debug!(\"monomorphic_fn({:?})\", instance);"}, {"sha": "12df8bd83708c77cf5425cfff873574ca0a54a1a", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=58d4b8edd319d0f0d76024504cdfc74f89a001b1", "patch": "@@ -119,12 +119,15 @@\n use collector::InliningMap;\n use llvm;\n use monomorphize;\n+use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::TyCtxt;\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use std::cmp::Ordering;\n+use std::hash::{Hash, Hasher, SipHasher};\n+use std::sync::Arc;\n use symbol_map::SymbolMap;\n use syntax::ast::NodeId;\n use syntax::parse::token::{self, InternedString};\n@@ -140,11 +143,54 @@ pub enum PartitioningStrategy {\n }\n \n pub struct CodegenUnit<'tcx> {\n-    pub name: InternedString,\n-    pub items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n+    name: InternedString,\n+    items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n }\n \n impl<'tcx> CodegenUnit<'tcx> {\n+    pub fn new(name: InternedString,\n+               items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>)\n+               -> Self {\n+        CodegenUnit {\n+            name: name,\n+            items: items,\n+        }\n+    }\n+\n+    pub fn empty(name: InternedString) -> Self {\n+        Self::new(name, FnvHashMap())\n+    }\n+\n+    pub fn contains_item(&self, item: &TransItem<'tcx>) -> bool {\n+        self.items.contains_key(item)\n+    }\n+\n+    pub fn name(&self) -> &str {\n+        &self.name\n+    }\n+\n+    pub fn items(&self) -> &FnvHashMap<TransItem<'tcx>, llvm::Linkage> {\n+        &self.items\n+    }\n+\n+    pub fn work_product_id(&self) -> Arc<WorkProductId> {\n+        Arc::new(WorkProductId::PartitionObjectFile(self.name().to_string()))\n+    }\n+\n+    pub fn work_product_dep_node(&self) -> DepNode<DefId> {\n+        DepNode::WorkProduct(self.work_product_id())\n+    }\n+\n+    pub fn compute_symbol_name_hash(&self, tcx: TyCtxt, symbol_map: &SymbolMap) -> u64 {\n+        let mut state = SipHasher::new();\n+        let all_items = self.items_in_deterministic_order(tcx, symbol_map);\n+        for (item, _) in all_items {\n+            let symbol_name = symbol_map.get(item).unwrap();\n+            symbol_name.hash(&mut state);\n+        }\n+        state.finish()\n+    }\n+\n     pub fn items_in_deterministic_order(&self,\n                                         tcx: TyCtxt,\n                                         symbol_map: &SymbolMap)\n@@ -277,10 +323,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             };\n \n             let make_codegen_unit = || {\n-                CodegenUnit {\n-                    name: codegen_unit_name.clone(),\n-                    items: FnvHashMap(),\n-                }\n+                CodegenUnit::empty(codegen_unit_name.clone())\n             };\n \n             let mut codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n@@ -319,10 +362,8 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if codegen_units.is_empty() {\n         let codegen_unit_name = InternedString::new(FALLBACK_CODEGEN_UNIT);\n         codegen_units.entry(codegen_unit_name.clone())\n-                     .or_insert_with(|| CodegenUnit {\n-                         name: codegen_unit_name.clone(),\n-                         items: FnvHashMap(),\n-                     });\n+                     .or_insert_with(|| CodegenUnit::new(codegen_unit_name.clone(),\n+                                                         FnvHashMap()));\n     }\n \n     PreInliningPartitioning {\n@@ -362,10 +403,8 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n     // we reach the target count\n     while codegen_units.len() < target_cgu_count {\n         let index = codegen_units.len();\n-        codegen_units.push(CodegenUnit {\n-            name: numbered_codegen_unit_name(crate_name, index),\n-            items: FnvHashMap()\n-        });\n+        codegen_units.push(\n+            CodegenUnit::empty(numbered_codegen_unit_name(crate_name, index)));\n     }\n }\n \n@@ -381,10 +420,8 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n             follow_inlining(*root, inlining_map, &mut reachable);\n         }\n \n-        let mut new_codegen_unit = CodegenUnit {\n-            name: codegen_unit.name.clone(),\n-            items: FnvHashMap(),\n-        };\n+        let mut new_codegen_unit =\n+            CodegenUnit::empty(codegen_unit.name.clone());\n \n         // Add all translation items that are not already there\n         for trans_item in reachable {\n@@ -560,10 +597,9 @@ fn single_codegen_unit<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         items.insert(trans_item, linkage);\n     }\n \n-    CodegenUnit {\n-        name: numbered_codegen_unit_name(&tcx.crate_name[..], 0),\n-        items: items\n-    }\n+    CodegenUnit::new(\n+        numbered_codegen_unit_name(&tcx.crate_name[..], 0),\n+        items)\n }\n \n fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {"}, {"sha": "3afedb4909067380f0e290325d00f8f7e0a6b1de", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=58d4b8edd319d0f0d76024504cdfc74f89a001b1", "patch": "@@ -23,12 +23,12 @@ use glue::DropGlueKind;\n use llvm;\n use monomorphize::{self, Instance};\n use inline;\n+use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst;\n-use rustc::dep_graph::DepNode;\n use rustc_const_eval::fatal_const_eval_err;\n use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n@@ -68,16 +68,27 @@ impl<'tcx> Hash for TransItem<'tcx> {\n impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n-\n         debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n                   self.to_string(ccx.tcx()),\n                   self.to_raw_string(),\n-                  ccx.codegen_unit().name);\n+                  ccx.codegen_unit().name());\n+\n+        // (*) This code executes in the context of a dep-node for the\n+        // entire CGU. In some cases, we introduce dep-nodes for\n+        // particular items that we are translating (these nodes will\n+        // have read edges coming into the CGU node). These smaller\n+        // nodes are not needed for correctness -- we always\n+        // invalidate an entire CGU at a time -- but they enable\n+        // finer-grained testing, since you can write tests that check\n+        // that the incoming edges to a particular fn are from a\n+        // particular set.\n \n         self.register_reads(ccx);\n \n         match *self {\n             TransItem::Static(node_id) => {\n+                let def_id = ccx.tcx().map.local_def_id(node_id);\n+                let _task = ccx.tcx().dep_graph.in_task(DepNode::TransCrateItem(def_id)); // (*)\n                 let item = ccx.tcx().map.expect_item(node_id);\n                 if let hir::ItemStatic(_, m, ref expr) = item.node {\n                     match consts::trans_static(&ccx, m, expr, item.id, &item.attrs) {\n@@ -93,6 +104,13 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                 }\n             }\n             TransItem::Fn(instance) => {\n+                let _task;\n+\n+                if instance.def.is_local() {\n+                    _task = ccx.tcx().dep_graph.in_task(\n+                        DepNode::TransCrateItem(instance.def)); // (*)\n+                }\n+\n                 base::trans_instance(&ccx, instance);\n             }\n             TransItem::DropGlue(dg) => {\n@@ -103,7 +121,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         debug!(\"END IMPLEMENTING '{} ({})' in cgu {}\",\n                self.to_string(ccx.tcx()),\n                self.to_raw_string(),\n-               ccx.codegen_unit().name);\n+               ccx.codegen_unit().name());\n     }\n \n     /// If necessary, creates a subtask for trans'ing a particular item and registers reads on\n@@ -152,7 +170,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n                self.to_string(ccx.tcx()),\n                self.to_raw_string(),\n-               ccx.codegen_unit().name);\n+               ccx.codegen_unit().name());\n \n         let symbol_name = ccx.symbol_map()\n                              .get_or_compute(ccx.shared(), *self);\n@@ -174,7 +192,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n                self.to_string(ccx.tcx()),\n                self.to_raw_string(),\n-               ccx.codegen_unit().name);\n+               ccx.codegen_unit().name());\n     }\n \n     fn predefine_static(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "b58295d47f21d2633160a79b350e378db8b43d09", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=58d4b8edd319d0f0d76024504cdfc74f89a001b1", "patch": "@@ -20,6 +20,7 @@ extern crate rustc_metadata;\n extern crate rustc_resolve;\n extern crate rustc_errors;\n extern crate rustc_errors as errors;\n+extern crate rustc_trans;\n #[macro_use] extern crate syntax;\n \n use std::ffi::{CStr, CString};\n@@ -37,6 +38,7 @@ use rustc::session::build_session;\n use rustc_driver::{driver, abort_on_err};\n use rustc_resolve::MakeGlobMap;\n use rustc_metadata::cstore::CStore;\n+use rustc_trans::ModuleSource;\n use libc::c_void;\n \n use rustc_errors::registry::Registry;\n@@ -261,7 +263,10 @@ fn compile_program(input: &str, sysroot: PathBuf)\n                 .filter_map(|(_, p)| p).collect();\n \n             assert_eq!(trans.modules.len(), 1);\n-            let llmod = trans.modules[0].llmod;\n+            let llmod = match trans.modules[0].source {\n+                ModuleSource::Preexisting(_) => unimplemented!(),\n+                ModuleSource::Translated(llvm) => llvm.llmod,\n+            };\n \n             // Workaround because raw pointers do not impl Send\n             let modp = llmod as usize;"}, {"sha": "19e410fef538821dad9b6c7ff9d1b8422a7661d2", "filename": "src/test/run-make/llvm-phase/test.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58d4b8edd319d0f0d76024504cdfc74f89a001b1/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs?ref=58d4b8edd319d0f0d76024504cdfc74f89a001b1", "patch": "@@ -13,11 +13,13 @@\n extern crate rustc;\n extern crate rustc_driver;\n extern crate rustc_llvm;\n+extern crate rustc_trans;\n #[macro_use] extern crate syntax;\n extern crate getopts;\n \n use rustc_driver::{CompilerCalls, Compilation};\n use rustc_driver::driver::CompileController;\n+use rustc_trans::ModuleSource;\n use rustc::session::Session;\n use syntax::codemap::FileLoader;\n use std::io;\n@@ -51,7 +53,10 @@ impl<'a> CompilerCalls<'a> for JitCalls {\n             state.session.abort_if_errors();\n             let trans = state.trans.unwrap();\n             assert_eq!(trans.modules.len(), 1);\n-            let rs_llmod = trans.modules[0].llmod;\n+            let rs_llmod = match trans.modules[0].source {\n+                ModuleSource::Preexisting(_) => unimplemented!(),\n+                ModuleSource::Translated(llvm) => llvm.llmod,\n+            };\n             unsafe { rustc_llvm::LLVMDumpModule(rs_llmod) };\n         });\n         cc"}]}