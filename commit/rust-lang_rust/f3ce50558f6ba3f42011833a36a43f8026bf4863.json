{"sha": "f3ce50558f6ba3f42011833a36a43f8026bf4863", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzY2U1MDU1OGY2YmEzZjQyMDExODMzYTM2YTQzZjgwMjZiZjQ4NjM=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-07-26T09:41:34Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-31T13:15:09Z"}, "message": "async-llvm(11): Delay joining ongoing translation until right before linking.", "tree": {"sha": "83422f4510b5d0de96281b639b27e983ae86278e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83422f4510b5d0de96281b639b27e983ae86278e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3ce50558f6ba3f42011833a36a43f8026bf4863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3ce50558f6ba3f42011833a36a43f8026bf4863", "html_url": "https://github.com/rust-lang/rust/commit/f3ce50558f6ba3f42011833a36a43f8026bf4863", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3ce50558f6ba3f42011833a36a43f8026bf4863/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28589ec3e474a7cce15f761d6bcd24f80aebdee1", "url": "https://api.github.com/repos/rust-lang/rust/commits/28589ec3e474a7cce15f761d6bcd24f80aebdee1", "html_url": "https://github.com/rust-lang/rust/commit/28589ec3e474a7cce15f761d6bcd24f80aebdee1"}], "stats": {"total": 208, "additions": 98, "deletions": 110}, "files": [{"sha": "c33d65e3e536925deb858c0fe62e7ac436a44de1", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 49, "deletions": 56, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f3ce50558f6ba3f42011833a36a43f8026bf4863/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ce50558f6ba3f42011833a36a43f8026bf4863/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=f3ce50558f6ba3f42011833a36a43f8026bf4863", "patch": "@@ -259,10 +259,10 @@ impl ModuleConfig {\n         }\n     }\n \n-    fn set_flags(&mut self, sess: &Session, trans: &OngoingCrateTranslation) {\n+    fn set_flags(&mut self, sess: &Session, no_builtins: bool) {\n         self.no_verify = sess.no_verify();\n         self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n-        self.no_builtins = trans.no_builtins;\n+        self.no_builtins = no_builtins;\n         self.time_passes = sess.time_passes();\n         self.inline_threshold = sess.opts.cg.inline_threshold;\n         self.obj_is_bitcode = sess.target.target.options.obj_is_bitcode;\n@@ -662,12 +662,21 @@ fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n }\n \n pub fn run_passes(sess: &Session,\n-                  trans: &OngoingCrateTranslation,\n                   modules: Vec<ModuleTranslation>,\n                   metadata_module: ModuleTranslation,\n                   allocator_module: Option<ModuleTranslation>,\n-                  output_types: &OutputTypes,\n-                  crate_output: &OutputFilenames) {\n+                  output_types_override: &OutputTypes,\n+                  crate_output: &OutputFilenames,\n+\n+                  crate_name: Symbol,\n+                  link: LinkMeta,\n+                  metadata: EncodedMetadata,\n+                  exported_symbols: Arc<ExportedSymbols>,\n+                  no_builtins: bool,\n+                  windows_subsystem: Option<String>,\n+                  linker_info: LinkerInfo,\n+                  no_integrated_as: bool)\n+                  -> OngoingCrateTranslation {\n     // It's possible that we have `codegen_units > 1` but only one item in\n     // `trans.modules`.  We could theoretically proceed and do LTO in that\n     // case, but it would be confusing to have the validity of\n@@ -732,7 +741,7 @@ pub fn run_passes(sess: &Session,\n         modules_config.emit_bc = true;\n     }\n \n-    for output_type in output_types.keys() {\n+    for output_type in output_types_override.keys() {\n         match *output_type {\n             OutputType::Bitcode => { modules_config.emit_bc = true; }\n             OutputType::LlvmAssembly => { modules_config.emit_ir = true; }\n@@ -758,9 +767,9 @@ pub fn run_passes(sess: &Session,\n         }\n     }\n \n-    modules_config.set_flags(sess, trans);\n-    metadata_config.set_flags(sess, trans);\n-    allocator_config.set_flags(sess, trans);\n+    modules_config.set_flags(sess, no_builtins);\n+    metadata_config.set_flags(sess, no_builtins);\n+    allocator_config.set_flags(sess, no_builtins);\n \n \n     // Populate a buffer with a list of codegen threads.  Items are processed in\n@@ -797,12 +806,8 @@ pub fn run_passes(sess: &Session,\n         Client::new(num_workers).expect(\"failed to create jobserver\")\n     });\n \n-    drop(modules_config);\n-    drop(metadata_config);\n-    drop(allocator_config);\n-\n     let (shared_emitter, shared_emitter_main) = SharedEmitter::new();\n-    let (trans_worker_send, trans_worker_receive) = channel();\n+    let (trans_worker_send, _trans_worker_receive) = channel();\n     let (coordinator_send, coordinator_receive) = channel();\n \n     let coordinator_thread = start_executing_work(sess,\n@@ -812,47 +817,24 @@ pub fn run_passes(sess: &Session,\n                                                   coordinator_send.clone(),\n                                                   coordinator_receive,\n                                                   client,\n-                                                  trans.exported_symbols.clone());\n+                                                  exported_symbols.clone());\n     for work_item in work_items {\n         coordinator_send.send(Message::WorkItem(work_item)).unwrap();\n     }\n \n-    loop {\n-        shared_emitter_main.check(sess, false);\n-\n-        match trans_worker_receive.recv() {\n-            Err(_) => {\n-                // An `Err` here means that all senders for this channel have\n-                // been closed. This could happen because all work has\n-                // completed successfully or there has been some error.\n-                // At this point we don't care which it is.\n-                break\n-            }\n-\n-            Ok(Message::CheckErrorMessages) => continue,\n-            Ok(msg) => {\n-                bug!(\"unexpected message {:?}\", msg);\n-            }\n-        }\n-    }\n-\n-    let compiled_modules = coordinator_thread.join().unwrap();\n-\n-    // Just in case, check this on the way out.\n-    shared_emitter_main.check(sess, false);\n-    sess.diagnostic().abort_if_errors();\n-\n-    copy_module_artifacts_into_incr_comp_cache(sess, &compiled_modules, crate_output);\n-\n-    produce_final_output_artifacts(sess, &compiled_modules, crate_output);\n-\n-    // FIXME: time_llvm_passes support - does this use a global context or\n-    // something?\n-    if sess.opts.cg.codegen_units == 1 && sess.time_llvm_passes() {\n-        unsafe { llvm::LLVMRustPrintPassTimings(); }\n+    OngoingCrateTranslation {\n+        crate_name,\n+        link,\n+        metadata,\n+        exported_symbols,\n+        no_builtins,\n+        windows_subsystem,\n+        linker_info,\n+        no_integrated_as,\n+\n+        shared_emitter_main,\n+        future: coordinator_thread\n     }\n-\n-    *trans.result.borrow_mut() = Some(compiled_modules);\n }\n \n fn copy_module_artifacts_into_incr_comp_cache(sess: &Session,\n@@ -1596,17 +1578,28 @@ pub struct OngoingCrateTranslation {\n     pub linker_info: LinkerInfo,\n     pub no_integrated_as: bool,\n \n-    // This will be replaced by a Future.\n-    pub result: ::std::cell::RefCell<Option<CompiledModules>>,\n+    shared_emitter_main: SharedEmitterMain,\n+    future: thread::JoinHandle<CompiledModules>,\n }\n \n impl OngoingCrateTranslation {\n     pub fn join(self,\n                 sess: &Session,\n                 outputs: &OutputFilenames)\n                 -> CrateTranslation {\n+        self.shared_emitter_main.check(sess, true);\n+        let compiled_modules = self.future.join().unwrap();\n+\n+        sess.abort_if_errors();\n \n-        let result = self.result.borrow_mut().take().unwrap();\n+        copy_module_artifacts_into_incr_comp_cache(sess, &compiled_modules, outputs);\n+        produce_final_output_artifacts(sess, &compiled_modules, outputs);\n+\n+        // FIXME: time_llvm_passes support - does this use a global context or\n+        // something?\n+        if sess.opts.cg.codegen_units == 1 && sess.time_llvm_passes() {\n+            unsafe { llvm::LLVMRustPrintPassTimings(); }\n+        }\n \n         let trans = CrateTranslation {\n             crate_name: self.crate_name,\n@@ -1617,9 +1610,9 @@ impl OngoingCrateTranslation {\n             windows_subsystem: self.windows_subsystem,\n             linker_info: self.linker_info,\n \n-            modules: result.modules,\n-            metadata_module: result.metadata_module,\n-            allocator_module: result.allocator_module,\n+            modules: compiled_modules.modules,\n+            metadata_module: compiled_modules.metadata_module,\n+            allocator_module: compiled_modules.allocator_module,\n         };\n \n         if self.no_integrated_as {"}, {"sha": "65041e60fe39a08299765e224b0761c709b5b0ce", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 49, "deletions": 54, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/f3ce50558f6ba3f42011833a36a43f8026bf4863/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3ce50558f6ba3f42011833a36a43f8026bf4863/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=f3ce50558f6ba3f42011833a36a43f8026bf4863", "patch": "@@ -32,7 +32,7 @@ use assert_module_sources;\n use back::link;\n use back::linker::LinkerInfo;\n use back::symbol_export::{self, ExportedSymbols};\n-use back::write::OngoingCrateTranslation;\n+use back::write::{self, OngoingCrateTranslation};\n use llvm::{ContextRef, Linkage, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n use metadata;\n@@ -963,27 +963,21 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n        !tcx.sess.opts.output_types.should_trans() {\n         let empty_exported_symbols = ExportedSymbols::empty();\n         let linker_info = LinkerInfo::new(&shared_ccx, &empty_exported_symbols);\n-        let crate_translation = OngoingCrateTranslation {\n-            crate_name: tcx.crate_name(LOCAL_CRATE),\n-            link: link_meta,\n-            metadata: metadata,\n-            exported_symbols: Arc::new(empty_exported_symbols),\n-            no_builtins: no_builtins,\n-            linker_info: linker_info,\n-            windows_subsystem: None,\n-            no_integrated_as: false,\n-            result: ::std::cell::RefCell::new(None),\n-        };\n-\n-        ::back::write::run_passes(tcx.sess,\n-                                  &crate_translation,\n-                                  vec![],\n-                                  metadata_module,\n-                                  None,\n-                                  &output_filenames.outputs,\n-                                  output_filenames);\n-\n-        return crate_translation;\n+        return write::run_passes(tcx.sess,\n+                                 vec![],\n+                                 metadata_module,\n+                                 None,\n+                                 &output_filenames.outputs,\n+                                 output_filenames,\n+\n+                                 tcx.crate_name(LOCAL_CRATE),\n+                                 link_meta,\n+                                 metadata,\n+                                 Arc::new(empty_exported_symbols),\n+                                 no_builtins,\n+                                 None,\n+                                 linker_info,\n+                                 false);\n     }\n \n     let exported_symbols = Arc::new(ExportedSymbols::compute(tcx,\n@@ -1231,19 +1225,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n          (outputs.outputs.contains_key(&OutputType::Object) ||\n           outputs.outputs.contains_key(&OutputType::Exe)));\n \n-    let crate_translation = OngoingCrateTranslation {\n-        crate_name: tcx.crate_name(LOCAL_CRATE),\n-        link: link_meta,\n-        metadata: metadata,\n-        exported_symbols,\n-        no_builtins,\n-        linker_info,\n-        windows_subsystem,\n-        no_integrated_as,\n-\n-        result: ::std::cell::RefCell::new(None),\n-    };\n-\n     time(sess.time_passes(),\n          \"assert dep graph\",\n          || rustc_incremental::assert_dep_graph(tcx));\n@@ -1252,34 +1233,48 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n          \"serialize dep graph\",\n          || rustc_incremental::save_dep_graph(tcx,\n                                               incremental_hashes_map,\n-                                              &crate_translation.metadata.hashes,\n-                                              crate_translation.link.crate_hash));\n+                                              &metadata.hashes,\n+                                              link_meta.crate_hash));\n     // ---\n \n     if no_integrated_as {\n         let output_types = OutputTypes::new(&[(OutputType::Assembly, None)]);\n         time(sess.time_passes(),\n              \"LLVM passes\",\n-             || ::back::write::run_passes(sess,\n-                                          &crate_translation,\n-                                          modules,\n-                                          metadata_module,\n-                                          allocator_module,\n-                                          &output_types,\n-                                          outputs))\n+             || write::run_passes(sess,\n+                                  modules,\n+                                  metadata_module,\n+                                  allocator_module,\n+                                  &output_types,\n+                                  outputs,\n+\n+                                  tcx.crate_name(LOCAL_CRATE),\n+                                  link_meta,\n+                                  metadata,\n+                                  exported_symbols,\n+                                  no_builtins,\n+                                  windows_subsystem,\n+                                  linker_info,\n+                                  no_integrated_as))\n     } else {\n         time(sess.time_passes(),\n              \"LLVM passes\",\n-             || ::back::write::run_passes(sess,\n-                                          &crate_translation,\n-                                          modules,\n-                                          metadata_module,\n-                                          allocator_module,\n-                                          &sess.opts.output_types,\n-                                          outputs))\n-    };\n-\n-    crate_translation\n+             || write::run_passes(sess,\n+                                  modules,\n+                                  metadata_module,\n+                                  allocator_module,\n+                                  &sess.opts.output_types,\n+                                  outputs,\n+\n+                                  tcx.crate_name(LOCAL_CRATE),\n+                                  link_meta,\n+                                  metadata,\n+                                  exported_symbols,\n+                                  no_builtins,\n+                                  windows_subsystem,\n+                                  linker_info,\n+                                  no_integrated_as))\n+    }\n }\n \n #[inline(never)] // give this a place in the profiler"}]}