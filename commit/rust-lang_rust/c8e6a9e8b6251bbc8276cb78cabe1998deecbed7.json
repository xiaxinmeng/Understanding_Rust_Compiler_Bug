{"sha": "c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "node_id": "C_kwDOAAsO6NoAKGM4ZTZhOWU4YjYyNTFiYmM4Mjc2Y2I3OGNhYmUxOTk4ZGVlY2JlZDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-23T13:07:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-23T13:07:16Z"}, "message": "Auto merge of #107220 - JohnTitor:rollup-5pvuz0z, r=JohnTitor\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #106796 (BPF: Disable atomic CAS)\n - #106886 (Make stage2 rustdoc and proc-macro-srv disableable in x.py install)\n - #107101 (Filter param-env predicates for errors before calling `to_opt_poly_trait_pred`)\n - #107109 (ThinBox: Add intra-doc-links for Metadata)\n - #107148 (remove error code from `E0789`, add UI test/docs)\n - #107151 (Instantiate dominators algorithm only once)\n - #107153 (Consistently use dominates instead of is_dominated_by)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f3fe6240d1392fe749d539d18df606b3b5b719fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3fe6240d1392fe749d539d18df606b3b5b719fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "html_url": "https://github.com/rust-lang/rust/commit/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bef91c6e902f3bded724713bd2a64ea50abbd25", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bef91c6e902f3bded724713bd2a64ea50abbd25", "html_url": "https://github.com/rust-lang/rust/commit/5bef91c6e902f3bded724713bd2a64ea50abbd25"}, {"sha": "eae7f947b5394aabaa9ec104ce9bc7a8633badfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/eae7f947b5394aabaa9ec104ce9bc7a8633badfc", "html_url": "https://github.com/rust-lang/rust/commit/eae7f947b5394aabaa9ec104ce9bc7a8633badfc"}], "stats": {"total": 163, "additions": 126, "deletions": 37}, "files": [{"sha": "6398a501983cfbd61089c6902cb9baa6d81f405e", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -285,7 +285,7 @@ impl<Node: Idx> Dominators<Node> {\n         Iter { dominators: self, node: Some(node) }\n     }\n \n-    pub fn is_dominated_by(&self, node: Node, dom: Node) -> bool {\n+    pub fn dominates(&self, dom: Node, node: Node) -> bool {\n         // FIXME -- could be optimized by using post-order-rank\n         self.dominators(node).any(|n| n == dom)\n     }"}, {"sha": "4ae372bb90432cc86908ed3f41dc6d0b64982806", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -506,6 +506,7 @@ E0785: include_str!(\"./error_codes/E0785.md\"),\n E0786: include_str!(\"./error_codes/E0786.md\"),\n E0787: include_str!(\"./error_codes/E0787.md\"),\n E0788: include_str!(\"./error_codes/E0788.md\"),\n+E0789: include_str!(\"./error_codes/E0789.md\"),\n E0790: include_str!(\"./error_codes/E0790.md\"),\n E0791: include_str!(\"./error_codes/E0791.md\"),\n E0792: include_str!(\"./error_codes/E0792.md\"),\n@@ -645,5 +646,4 @@ E0792: include_str!(\"./error_codes/E0792.md\"),\n //  E0721, // `await` keyword\n //  E0723, // unstable feature in `const` context\n //  E0738, // Removed; errored on `#[track_caller] fn`s in `extern \"Rust\" { ... }`.\n-    E0789, // rustc_allowed_through_unstable_modules without stability attribute\n }"}, {"sha": "89b7cd422fe966a56e805cfeb21061d06fedd0c6", "filename": "compiler/rustc_error_codes/src/error_codes/E0789.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0789.md", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0789.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0789.md?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -0,0 +1,30 @@\n+#### This error code is internal to the compiler and will not be emitted with normal Rust code.\n+\n+The internal `rustc_allowed_through_unstable_modules` attribute must be used\n+on an item with a `stable` attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0789\n+// NOTE: both of these attributes are perma-unstable and should *never* be\n+//       used outside of the compiler and standard library.\n+#![feature(rustc_attrs)]\n+#![feature(staged_api)]\n+\n+#![unstable(feature = \"foo_module\", reason = \"...\", issue = \"123\")]\n+\n+#[rustc_allowed_through_unstable_modules]\n+// #[stable(feature = \"foo\", since = \"1.0\")]\n+struct Foo;\n+// ^^^ error: `rustc_allowed_through_unstable_modules` attribute must be\n+//            paired with a `stable` attribute\n+```\n+\n+Typically when an item is marked with a `stable` attribute, the modules that\n+enclose the item must also be marked with `stable` attributes, otherwise the\n+item becomes *de facto* unstable. `#[rustc_allowed_through_unstable_modules]`\n+is a workaround which allows an item to \"escape\" its unstable parent modules.\n+This error occurs when an item is marked with\n+`#[rustc_allowed_through_unstable_modules]` but no supplementary `stable`\n+attribute exists. See [#99288](https://github.com/rust-lang/rust/pull/99288)\n+for an example of `#[rustc_allowed_through_unstable_modules]` in use."}, {"sha": "b93871769b791c9ab7de6f3c0aa605d3cef4f89b", "filename": "compiler/rustc_middle/src/mir/basic_blocks.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -41,7 +41,6 @@ impl<'tcx> BasicBlocks<'tcx> {\n         *self.cache.is_cyclic.get_or_init(|| graph::is_cyclic(self))\n     }\n \n-    #[inline]\n     pub fn dominators(&self) -> Dominators<BasicBlock> {\n         dominators(&self)\n     }"}, {"sha": "4da893e4c0716d01ad88deccc0d83ee939ebed2b", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -3046,7 +3046,7 @@ impl Location {\n         if self.block == other.block {\n             self.statement_index <= other.statement_index\n         } else {\n-            dominators.is_dominated_by(other.block, self.block)\n+            dominators.dominates(self.block, other.block)\n         }\n     }\n }"}, {"sha": "658e01d9310317d4bf955b528a0b662d3b1eb6a3", "filename": "compiler/rustc_mir_transform/src/coverage/counters.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fcounters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fcounters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fcounters.rs?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -520,7 +520,7 @@ impl<'a> BcbCounters<'a> {\n                 let mut found_loop_exit = false;\n                 for &branch in branches.iter() {\n                     if backedge_from_bcbs.iter().any(|&backedge_from_bcb| {\n-                        self.bcb_is_dominated_by(backedge_from_bcb, branch.target_bcb)\n+                        self.bcb_dominates(branch.target_bcb, backedge_from_bcb)\n                     }) {\n                         if let Some(reloop_branch) = some_reloop_branch {\n                             if reloop_branch.counter(&self.basic_coverage_blocks).is_none() {\n@@ -603,8 +603,8 @@ impl<'a> BcbCounters<'a> {\n     }\n \n     #[inline]\n-    fn bcb_is_dominated_by(&self, node: BasicCoverageBlock, dom: BasicCoverageBlock) -> bool {\n-        self.basic_coverage_blocks.is_dominated_by(node, dom)\n+    fn bcb_dominates(&self, dom: BasicCoverageBlock, node: BasicCoverageBlock) -> bool {\n+        self.basic_coverage_blocks.dominates(dom, node)\n     }\n \n     #[inline]"}, {"sha": "a2671eef2e940ef09ae4170ee8deea7b3298cf60", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -209,8 +209,8 @@ impl CoverageGraph {\n     }\n \n     #[inline(always)]\n-    pub fn is_dominated_by(&self, node: BasicCoverageBlock, dom: BasicCoverageBlock) -> bool {\n-        self.dominators.as_ref().unwrap().is_dominated_by(node, dom)\n+    pub fn dominates(&self, dom: BasicCoverageBlock, node: BasicCoverageBlock) -> bool {\n+        self.dominators.as_ref().unwrap().dominates(dom, node)\n     }\n \n     #[inline(always)]\n@@ -312,7 +312,7 @@ rustc_index::newtype_index! {\n /// to the BCB's primary counter or expression).\n ///\n /// The BCB CFG is critical to simplifying the coverage analysis by ensuring graph path-based\n-/// queries (`is_dominated_by()`, `predecessors`, `successors`, etc.) have branch (control flow)\n+/// queries (`dominates()`, `predecessors`, `successors`, etc.) have branch (control flow)\n /// significance.\n #[derive(Debug, Clone)]\n pub(super) struct BasicCoverageBlockData {\n@@ -594,7 +594,7 @@ impl TraverseCoverageGraphWithLoops {\n                 // branching block would have given an `Expression` (or vice versa).\n                 let (some_successor_to_add, some_loop_header) =\n                     if let Some((_, loop_header)) = context.loop_backedges {\n-                        if basic_coverage_blocks.is_dominated_by(successor, loop_header) {\n+                        if basic_coverage_blocks.dominates(loop_header, successor) {\n                             (Some(successor), Some(loop_header))\n                         } else {\n                             (None, None)\n@@ -666,15 +666,15 @@ pub(super) fn find_loop_backedges(\n     //\n     // The overall complexity appears to be comparable to many other MIR transform algorithms, and I\n     // don't expect that this function is creating a performance hot spot, but if this becomes an\n-    // issue, there may be ways to optimize the `is_dominated_by` algorithm (as indicated by an\n+    // issue, there may be ways to optimize the `dominates` algorithm (as indicated by an\n     // existing `FIXME` comment in that code), or possibly ways to optimize it's usage here, perhaps\n     // by keeping track of results for visited `BasicCoverageBlock`s if they can be used to short\n-    // circuit downstream `is_dominated_by` checks.\n+    // circuit downstream `dominates` checks.\n     //\n     // For now, that kind of optimization seems unnecessarily complicated.\n     for (bcb, _) in basic_coverage_blocks.iter_enumerated() {\n         for &successor in &basic_coverage_blocks.successors[bcb] {\n-            if basic_coverage_blocks.is_dominated_by(bcb, successor) {\n+            if basic_coverage_blocks.dominates(successor, bcb) {\n                 let loop_header = successor;\n                 let backedge_from_bcb = bcb;\n                 debug!("}, {"sha": "31d5541a31b6b7a26c95d44ab7a3fb0b53f9e9d9", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -63,7 +63,7 @@ impl CoverageStatement {\n /// Note: A `CoverageStatement` merged into another CoverageSpan may come from a `BasicBlock` that\n /// is not part of the `CoverageSpan` bcb if the statement was included because it's `Span` matches\n /// or is subsumed by the `Span` associated with this `CoverageSpan`, and it's `BasicBlock`\n-/// `is_dominated_by()` the `BasicBlock`s in this `CoverageSpan`.\n+/// `dominates()` the `BasicBlock`s in this `CoverageSpan`.\n #[derive(Debug, Clone)]\n pub(super) struct CoverageSpan {\n     pub span: Span,\n@@ -705,12 +705,12 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     fn hold_pending_dups_unless_dominated(&mut self) {\n         // Equal coverage spans are ordered by dominators before dominated (if any), so it should be\n         // impossible for `curr` to dominate any previous `CoverageSpan`.\n-        debug_assert!(!self.span_bcb_is_dominated_by(self.prev(), self.curr()));\n+        debug_assert!(!self.span_bcb_dominates(self.curr(), self.prev()));\n \n         let initial_pending_count = self.pending_dups.len();\n         if initial_pending_count > 0 {\n             let mut pending_dups = self.pending_dups.split_off(0);\n-            pending_dups.retain(|dup| !self.span_bcb_is_dominated_by(self.curr(), dup));\n+            pending_dups.retain(|dup| !self.span_bcb_dominates(dup, self.curr()));\n             self.pending_dups.append(&mut pending_dups);\n             if self.pending_dups.len() < initial_pending_count {\n                 debug!(\n@@ -721,7 +721,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n             }\n         }\n \n-        if self.span_bcb_is_dominated_by(self.curr(), self.prev()) {\n+        if self.span_bcb_dominates(self.prev(), self.curr()) {\n             debug!(\n                 \"  different bcbs but SAME spans, and prev dominates curr. Discard prev={:?}\",\n                 self.prev()\n@@ -787,8 +787,8 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n         }\n     }\n \n-    fn span_bcb_is_dominated_by(&self, covspan: &CoverageSpan, dom_covspan: &CoverageSpan) -> bool {\n-        self.basic_coverage_blocks.is_dominated_by(covspan.bcb, dom_covspan.bcb)\n+    fn span_bcb_dominates(&self, dom_covspan: &CoverageSpan, covspan: &CoverageSpan) -> bool {\n+        self.basic_coverage_blocks.dominates(dom_covspan.bcb, covspan.bcb)\n     }\n }\n "}, {"sha": "4d03747d0165f698ae7ce3d7867f27110b3316d1", "filename": "compiler/rustc_target/src/spec/bpf_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_target%2Fsrc%2Fspec%2Fbpf_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_target%2Fsrc%2Fspec%2Fbpf_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fbpf_base.rs?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -6,7 +6,7 @@ pub fn opts(endian: Endian) -> TargetOptions {\n         allow_asm: true,\n         endian,\n         linker_flavor: LinkerFlavor::Bpf,\n-        atomic_cas: true,\n+        atomic_cas: false,\n         dynamic_linking: true,\n         no_builtins: true,\n         panic_strategy: PanicStrategy::Abort,"}, {"sha": "87d574ff107b29b9d4a09c1195566bf2f66a050d", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -174,8 +174,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .param_env\n             .caller_bounds()\n             .iter()\n-            .filter_map(|p| p.to_opt_poly_trait_pred())\n-            .filter(|p| !p.references_error());\n+            .filter(|p| !p.references_error())\n+            .filter_map(|p| p.to_opt_poly_trait_pred());\n \n         // Micro-optimization: filter out predicates relating to different traits.\n         let matching_bounds ="}, {"sha": "299bfd779e57a83461efc1167ae9de9e3d603ab8", "filename": "config.toml.example", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -285,11 +285,24 @@ changelog-seen = 2\n # be built if `extended = true`.\n #extended = false\n \n-# Installs chosen set of extended tools if `extended = true`. By default builds\n-# all extended tools except `rust-demangler`, unless the target is also being\n-# built with `profiler = true`. If chosen tool failed to build the installation\n-# fails. If `extended = false`, this option is ignored.\n-#tools = [\"cargo\", \"rls\", \"clippy\", \"rustfmt\", \"analysis\", \"src\"] # + \"rust-demangler\" if `profiler`\n+# Set of tools to be included in the installation.\n+#\n+# If `extended = false`, the only one of these built by default is rustdoc.\n+#\n+# If `extended = true`, they're all included, with the exception of\n+# rust-demangler which additionally requires `profiler = true` to be set.\n+#\n+# If any enabled tool fails to build, the installation fails.\n+#tools = [\n+#    \"cargo\",\n+#    \"clippy\",\n+#    \"rustdoc\",\n+#    \"rustfmt\",\n+#    \"rust-analyzer\",\n+#    \"analysis\",\n+#    \"src\",\n+#    \"rust-demangler\",  # if profiler = true\n+#]\n \n # Verbosity level: 0 == not verbose, 1 == verbose, 2 == very verbose\n #verbose = 0"}, {"sha": "ad48315fd70cc070bb116f9f964d4b0b55ad212a", "filename": "library/alloc/src/boxed/thin.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed%2Fthin.rs?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -48,7 +48,7 @@ unsafe impl<T: ?Sized + Sync> Sync for ThinBox<T> {}\n \n #[unstable(feature = \"thin_box\", issue = \"92791\")]\n impl<T> ThinBox<T> {\n-    /// Moves a type to the heap with its `Metadata` stored in the heap allocation instead of on\n+    /// Moves a type to the heap with its [`Metadata`] stored in the heap allocation instead of on\n     /// the stack.\n     ///\n     /// # Examples\n@@ -59,6 +59,8 @@ impl<T> ThinBox<T> {\n     ///\n     /// let five = ThinBox::new(5);\n     /// ```\n+    ///\n+    /// [`Metadata`]: core::ptr::Pointee::Metadata\n     #[cfg(not(no_global_oom_handling))]\n     pub fn new(value: T) -> Self {\n         let meta = ptr::metadata(&value);\n@@ -69,7 +71,7 @@ impl<T> ThinBox<T> {\n \n #[unstable(feature = \"thin_box\", issue = \"92791\")]\n impl<Dyn: ?Sized> ThinBox<Dyn> {\n-    /// Moves a type to the heap with its `Metadata` stored in the heap allocation instead of on\n+    /// Moves a type to the heap with its [`Metadata`] stored in the heap allocation instead of on\n     /// the stack.\n     ///\n     /// # Examples\n@@ -80,6 +82,8 @@ impl<Dyn: ?Sized> ThinBox<Dyn> {\n     ///\n     /// let thin_slice = ThinBox::<[i32]>::new_unsize([1, 2, 3, 4]);\n     /// ```\n+    ///\n+    /// [`Metadata`]: core::ptr::Pointee::Metadata\n     #[cfg(not(no_global_oom_handling))]\n     pub fn new_unsize<T>(value: T) -> Self\n     where"}, {"sha": "2d86ff1d2baeafff219b642ca5e5338bfd84cf01", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -392,19 +392,29 @@ impl Step for Rustc {\n             t!(fs::create_dir_all(image.join(\"bin\")));\n             builder.cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n \n-            builder.install(&builder.rustdoc(compiler), &image.join(\"bin\"), 0o755);\n+            if builder\n+                .config\n+                .tools\n+                .as_ref()\n+                .map_or(true, |tools| tools.iter().any(|tool| tool == \"rustdoc\"))\n+            {\n+                let rustdoc = builder.rustdoc(compiler);\n+                builder.install(&rustdoc, &image.join(\"bin\"), 0o755);\n+            }\n \n-            let ra_proc_macro_srv = builder\n-                .ensure(tool::RustAnalyzerProcMacroSrv {\n+            if let Some(ra_proc_macro_srv) = builder.ensure_if_default(\n+                tool::RustAnalyzerProcMacroSrv {\n                     compiler: builder.compiler_for(\n                         compiler.stage,\n                         builder.config.build,\n                         compiler.host,\n                     ),\n                     target: compiler.host,\n-                })\n-                .expect(\"rust-analyzer-proc-macro-server always builds\");\n-            builder.install(&ra_proc_macro_srv, &image.join(\"libexec\"), 0o755);\n+                },\n+                builder.kind,\n+            ) {\n+                builder.install(&ra_proc_macro_srv, &image.join(\"libexec\"), 0o755);\n+            }\n \n             let libdir_relative = builder.libdir_relative(compiler);\n "}, {"sha": "ca5f500f93bc41deea9db9be5a6698f1154ab021", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -765,9 +765,15 @@ impl Step for RustAnalyzerProcMacroSrv {\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        let builder = run.builder;\n         // Allow building `rust-analyzer-proc-macro-srv` both as part of the `rust-analyzer` and as a stand-alone tool.\n         run.path(\"src/tools/rust-analyzer\")\n             .path(\"src/tools/rust-analyzer/crates/proc-macro-srv-cli\")\n+            .default_condition(builder.config.tools.as_ref().map_or(true, |tools| {\n+                tools\n+                    .iter()\n+                    .any(|tool| tool == \"rust-analyzer\" || tool == \"rust-analyzer-proc-macro-srv\")\n+            }))\n     }\n \n     fn make_run(run: RunConfig<'_>) {"}, {"sha": "6bb4d32f87d0a25bd2b5a065741ce3e3fc5e6cb8", "filename": "src/tools/tidy/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferror_codes.rs?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -31,7 +31,7 @@ const IGNORE_DOCTEST_CHECK: &[&str] = &[\"E0464\", \"E0570\", \"E0601\", \"E0602\", \"E06\n \n // Error codes that don't yet have a UI test. This list will eventually be removed.\n const IGNORE_UI_TEST_CHECK: &[&str] =\n-    &[\"E0461\", \"E0465\", \"E0476\", \"E0514\", \"E0523\", \"E0554\", \"E0640\", \"E0717\", \"E0729\", \"E0789\"];\n+    &[\"E0461\", \"E0465\", \"E0476\", \"E0514\", \"E0523\", \"E0554\", \"E0640\", \"E0717\", \"E0729\"];\n \n macro_rules! verbose_print {\n     ($verbose:expr, $($fmt:tt)*) => {"}, {"sha": "c0cbbcc9d2dc26f758eb5780d482799453fdb8de", "filename": "tests/ui/error-codes/E0789.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/tests%2Fui%2Ferror-codes%2FE0789.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/tests%2Fui%2Ferror-codes%2FE0789.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0789.rs?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -0,0 +1,12 @@\n+// compile-flags: --crate-type lib\n+\n+#![feature(rustc_attrs)]\n+#![feature(staged_api)]\n+#![unstable(feature = \"foo_module\", reason = \"...\", issue = \"123\")]\n+\n+#[rustc_allowed_through_unstable_modules]\n+// #[stable(feature = \"foo\", since = \"1.0\")]\n+struct Foo;\n+//~^ ERROR `rustc_allowed_through_unstable_modules` attribute must be paired with a `stable` attribute\n+//~^^ ERROR `rustc_allowed_through_unstable_modules` attribute must be paired with a `stable` attribute\n+// FIXME: we shouldn't have two errors here, only occurs when using `-Zdeduplicate-diagnostics=no`"}, {"sha": "faab92bae035dc9408bd72006097ee68ab3d6426", "filename": "tests/ui/error-codes/E0789.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/tests%2Fui%2Ferror-codes%2FE0789.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c8e6a9e8b6251bbc8276cb78cabe1998deecbed7/tests%2Fui%2Ferror-codes%2FE0789.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0789.stderr?ref=c8e6a9e8b6251bbc8276cb78cabe1998deecbed7", "patch": "@@ -0,0 +1,15 @@\n+error[E0789]: `rustc_allowed_through_unstable_modules` attribute must be paired with a `stable` attribute\n+  --> $DIR/E0789.rs:9:1\n+   |\n+LL | struct Foo;\n+   | ^^^^^^^^^^^\n+\n+error[E0789]: `rustc_allowed_through_unstable_modules` attribute must be paired with a `stable` attribute\n+  --> $DIR/E0789.rs:9:1\n+   |\n+LL | struct Foo;\n+   | ^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0789`."}]}