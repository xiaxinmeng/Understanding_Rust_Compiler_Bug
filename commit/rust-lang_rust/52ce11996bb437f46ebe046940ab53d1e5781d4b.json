{"sha": "52ce11996bb437f46ebe046940ab53d1e5781d4b", "node_id": "C_kwDOAAsO6NoAKDUyY2UxMTk5NmJiNDM3ZjQ2ZWJlMDQ2OTQwYWI1M2QxZTU3ODFkNGI", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-10-19T12:37:27Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-03-05T10:39:03Z"}, "message": "Implement RFC 3184 - thread local cell methods.", "tree": {"sha": "678a0a945d85454a407ddd5f35d7b6083f679884", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/678a0a945d85454a407ddd5f35d7b6083f679884"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52ce11996bb437f46ebe046940ab53d1e5781d4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52ce11996bb437f46ebe046940ab53d1e5781d4b", "html_url": "https://github.com/rust-lang/rust/commit/52ce11996bb437f46ebe046940ab53d1e5781d4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52ce11996bb437f46ebe046940ab53d1e5781d4b/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86067bb461d044ee30e7880ab6f3b34d5070f1db", "url": "https://api.github.com/repos/rust-lang/rust/commits/86067bb461d044ee30e7880ab6f3b34d5070f1db", "html_url": "https://github.com/rust-lang/rust/commit/86067bb461d044ee30e7880ab6f3b34d5070f1db"}], "stats": {"total": 358, "additions": 348, "deletions": 10}, "files": [{"sha": "36e6032b5e4e5204c4d51a4aa822cabe45ba7066", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52ce11996bb437f46ebe046940ab53d1e5781d4b/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ce11996bb437f46ebe046940ab53d1e5781d4b/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=52ce11996bb437f46ebe046940ab53d1e5781d4b", "patch": "@@ -249,6 +249,7 @@\n #![feature(const_ip)]\n #![feature(const_ipv4)]\n #![feature(const_ipv6)]\n+#![feature(const_mut_refs)]\n #![feature(const_option)]\n #![feature(const_socketaddr)]\n #![feature(const_trait_impl)]"}, {"sha": "03a402a5a47c801bd538aeb9714b00ab5363b56d", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 347, "deletions": 10, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/52ce11996bb437f46ebe046940ab53d1e5781d4b/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52ce11996bb437f46ebe046940ab53d1e5781d4b/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=52ce11996bb437f46ebe046940ab53d1e5781d4b", "patch": "@@ -8,6 +8,7 @@ mod tests;\n #[cfg(test)]\n mod dynamic_tests;\n \n+use crate::cell::{Cell, RefCell};\n use crate::error::Error;\n use crate::fmt;\n \n@@ -108,7 +109,7 @@ pub struct LocalKey<T: 'static> {\n     // trivially devirtualizable by LLVM because the value of `inner` never\n     // changes and the constant should be readonly within a crate. This mainly\n     // only runs into problems when TLS statics are exported across crates.\n-    inner: unsafe fn() -> Option<&'static T>,\n+    inner: unsafe fn(Option<&mut Option<T>>) -> Option<&'static T>,\n }\n \n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n@@ -178,7 +179,9 @@ macro_rules! __thread_local_inner {\n     // used to generate the `LocalKey` value for const-initialized thread locals\n     (@key $t:ty, const $init:expr) => {{\n         #[cfg_attr(not(windows), inline(always))] // see comments below\n-        unsafe fn __getit() -> $crate::option::Option<&'static $t> {\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n             const INIT_EXPR: $t = $init;\n \n             // wasm without atomics maps directly to `static mut`, and dtors\n@@ -260,7 +263,16 @@ macro_rules! __thread_local_inner {\n                 static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                     $crate::thread::__OsLocalKeyInner::new();\n                 #[allow(unused_unsafe)]\n-                unsafe { __KEY.get(__init) }\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = _init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n             }\n         }\n \n@@ -298,7 +310,9 @@ macro_rules! __thread_local_inner {\n             //\n             // The issue of \"should enable on Windows sometimes\" is #84933\n             #[cfg_attr(not(windows), inline(always))]\n-            unsafe fn __getit() -> $crate::option::Option<&'static $t> {\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n                 #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n                 static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n                     $crate::thread::__StaticLocalKeyInner::new();\n@@ -322,7 +336,16 @@ macro_rules! __thread_local_inner {\n                 // raise warning for missing/extraneous unsafe blocks anymore.\n                 // See https://github.com/rust-lang/rust/issues/74838.\n                 #[allow(unused_unsafe)]\n-                unsafe { __KEY.get(__init) }\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n             }\n \n             unsafe {\n@@ -367,7 +390,9 @@ impl<T: 'static> LocalKey<T> {\n         issue = \"none\"\n     )]\n     #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n-    pub const unsafe fn new(inner: unsafe fn() -> Option<&'static T>) -> LocalKey<T> {\n+    pub const unsafe fn new(\n+        inner: unsafe fn(Option<&mut Option<T>>) -> Option<&'static T>,\n+    ) -> LocalKey<T> {\n         LocalKey { inner }\n     }\n \n@@ -409,10 +434,322 @@ impl<T: 'static> LocalKey<T> {\n         F: FnOnce(&T) -> R,\n     {\n         unsafe {\n-            let thread_local = (self.inner)().ok_or(AccessError)?;\n+            let thread_local = (self.inner)(None).ok_or(AccessError)?;\n             Ok(f(thread_local))\n         }\n     }\n+\n+    fn initialize_with<F, R>(&'static self, init: T, f: F) -> R\n+    where\n+        F: FnOnce(Option<T>, &T) -> R,\n+    {\n+        unsafe {\n+            let mut init = Some(init);\n+            let reference = (self.inner)(Some(&mut init)).expect(\n+                \"cannot access a Thread Local Storage value \\\n+                 during or after destruction\",\n+            );\n+            f(init, reference)\n+        }\n+    }\n+}\n+\n+impl<T: 'static> LocalKey<Cell<T>> {\n+    /// Sets or initializes the contained value.\n+    ///\n+    /// Unlike the other methods, this will *not* run the lazy initializer of\n+    /// the thread local. Instead, it will be directly initialized with the\n+    /// given value if it wasn't initialized yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: Cell<i32> = panic!(\"!\");\n+    /// }\n+    ///\n+    /// // Calling X.get() here would result in a panic.\n+    ///\n+    /// X.set(123); // But X.set() is fine, as it skips the initializer above.\n+    ///\n+    /// assert_eq!(X.get(), 123);\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"none\")]\n+    pub fn set(&'static self, value: T) {\n+        self.initialize_with(Cell::new(value), |init, cell| {\n+            if let Some(init) = init {\n+                cell.set(init.into_inner());\n+            }\n+        });\n+    }\n+\n+    /// Returns a copy of the contained value.\n+    ///\n+    /// This will lazily initialize the value if this thread has not referenced\n+    /// this key yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: Cell<i32> = Cell::new(1);\n+    /// }\n+    ///\n+    /// assert_eq!(X.get(), 1);\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"none\")]\n+    pub fn get(&'static self) -> T\n+    where\n+        T: Copy,\n+    {\n+        self.with(|cell| cell.get())\n+    }\n+\n+    /// Takes the contained value, leaving `Default::default()` in its place.\n+    ///\n+    /// This will lazily initialize the value if this thread has not referenced\n+    /// this key yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: Cell<Option<i32>> = Cell::new(Some(1));\n+    /// }\n+    ///\n+    /// assert_eq!(X.take(), Some(1));\n+    /// assert_eq!(X.take(), None);\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"none\")]\n+    pub fn take(&'static self) -> T\n+    where\n+        T: Default,\n+    {\n+        self.with(|cell| cell.take())\n+    }\n+\n+    /// Replaces the contained value, returning the old value.\n+    ///\n+    /// This will lazily initialize the value if this thread has not referenced\n+    /// this key yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::Cell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: Cell<i32> = Cell::new(1);\n+    /// }\n+    ///\n+    /// assert_eq!(X.replace(2), 1);\n+    /// assert_eq!(X.replace(3), 2);\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"none\")]\n+    pub fn replace(&'static self, value: T) -> T {\n+        self.with(|cell| cell.replace(value))\n+    }\n+}\n+\n+impl<T: 'static> LocalKey<RefCell<T>> {\n+    /// Acquires a reference to the contained value.\n+    ///\n+    /// This will lazily initialize the value if this thread has not referenced\n+    /// this key yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is currently borrowed.\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::RefCell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: RefCell<Vec<i32>> = RefCell::new(Vec::new());\n+    /// }\n+    ///\n+    /// X.with_ref(|v| assert!(v.is_empty()));\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"none\")]\n+    pub fn with_ref<F, R>(&'static self, f: F) -> R\n+    where\n+        F: FnOnce(&T) -> R,\n+    {\n+        self.with(|cell| f(&mut cell.borrow()))\n+    }\n+\n+    /// Acquires a mutable reference to the contained value.\n+    ///\n+    /// This will lazily initialize the value if this thread has not referenced\n+    /// this key yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is currently borrowed.\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::RefCell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: RefCell<Vec<i32>> = RefCell::new(Vec::new());\n+    /// }\n+    ///\n+    /// X.with_mut(|v| v.push(1));\n+    ///\n+    /// X.with_ref(|v| assert_eq!(*v, vec![1]));\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"none\")]\n+    pub fn with_mut<F, R>(&'static self, f: F) -> R\n+    where\n+        F: FnOnce(&mut T) -> R,\n+    {\n+        self.with(|cell| f(&mut cell.borrow_mut()))\n+    }\n+\n+    /// Sets or initializes the contained value.\n+    ///\n+    /// Unlike the other methods, this will *not* run the lazy initializer of\n+    /// the thread local. Instead, it will be directly initialized with the\n+    /// given value if it wasn't initialized yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::RefCell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: RefCell<Vec<i32>> = panic!(\"!\");\n+    /// }\n+    ///\n+    /// // Calling X.with() here would result in a panic.\n+    ///\n+    /// X.set(vec![1, 2, 3]); // But X.set() is fine, as it skips the initializer above.\n+    ///\n+    /// X.with_ref(|v| assert_eq!(*v, vec![1, 2, 3]));\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"none\")]\n+    pub fn set(&'static self, value: T) {\n+        self.initialize_with(RefCell::new(value), |init, cell| {\n+            if let Some(init) = init {\n+                cell.replace(init.into_inner());\n+            }\n+        });\n+    }\n+\n+    /// Takes the contained value, leaving `Default::default()` in its place.\n+    ///\n+    /// This will lazily initialize the value if this thread has not referenced\n+    /// this key yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is currently borrowed.\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::RefCell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: RefCell<Vec<i32>> = RefCell::new(Vec::new());\n+    /// }\n+    ///\n+    /// X.with_mut(|v| v.push(1));\n+    ///\n+    /// let a = X.take();\n+    ///\n+    /// assert_eq!(a, vec![1]);\n+    ///\n+    /// X.with_ref(|v| assert!(v.is_empty()));\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"none\")]\n+    pub fn take(&'static self) -> T\n+    where\n+        T: Default,\n+    {\n+        self.with(|cell| cell.take())\n+    }\n+\n+    /// Replaces the contained value, returning the old value.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is currently borrowed.\n+    ///\n+    /// Panics if the key currently has its destructor running,\n+    /// and it **may** panic if the destructor has previously been run for this thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(local_key_cell_methods)]\n+    /// use std::cell::RefCell;\n+    ///\n+    /// thread_local! {\n+    ///     static X: RefCell<Vec<i32>> = RefCell::new(Vec::new());\n+    /// }\n+    ///\n+    /// let prev = X.replace(vec![1, 2, 3]);\n+    /// assert!(prev.is_empty());\n+    ///\n+    /// X.with_ref(|v| assert_eq!(*v, vec![1, 2, 3]));\n+    /// ```\n+    #[unstable(feature = \"local_key_cell_methods\", issue = \"none\")]\n+    pub fn replace(&'static self, value: T) -> T {\n+        self.with(|cell| cell.replace(value))\n+    }\n }\n \n mod lazy {\n@@ -518,7 +855,7 @@ pub mod statik {\n             Key { inner: LazyKeyInner::new() }\n         }\n \n-        pub unsafe fn get(&self, init: fn() -> T) -> Option<&'static T> {\n+        pub unsafe fn get(&self, init: impl FnOnce() -> T) -> Option<&'static T> {\n             // SAFETY: The caller must ensure no reference is ever handed out to\n             // the inner cell nor mutable reference to the Option<T> inside said\n             // cell. This make it safe to hand a reference, though the lifetime\n@@ -707,7 +1044,7 @@ pub mod os {\n \n         /// It is a requirement for the caller to ensure that no mutable\n         /// reference is active when this method is called.\n-        pub unsafe fn get(&'static self, init: fn() -> T) -> Option<&'static T> {\n+        pub unsafe fn get(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n             // SAFETY: See the documentation for this method.\n             let ptr = unsafe { self.os.get() as *mut Value<T> };\n             if ptr as usize > 1 {\n@@ -725,7 +1062,7 @@ pub mod os {\n         // `try_initialize` is only called once per os thread local variable,\n         // except in corner cases where thread_local dtors reference other\n         // thread_local's, or it is being recursively initialized.\n-        unsafe fn try_initialize(&'static self, init: fn() -> T) -> Option<&'static T> {\n+        unsafe fn try_initialize(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n             // SAFETY: No mutable references are ever handed out meaning getting\n             // the value is ok.\n             let ptr = unsafe { self.os.get() as *mut Value<T> };"}]}