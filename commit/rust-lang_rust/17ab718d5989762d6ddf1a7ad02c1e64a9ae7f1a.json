{"sha": "17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3YWI3MThkNTk4OTc2MmQ2ZGRmMWE3YWQwMmMxZTY0YTlhZTdmMWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-03T22:07:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-03T22:07:00Z"}, "message": "auto merge of #5698 : Thiez/rust/de-mutfielding, r=pcwalton\n\nThis pull request removes some mut-fields from at_vec, str, vec, unstable, and cell. Sadly in case of Cell this required using either transmute_mut (2 instances) or changing the interface. I chose the former. Perhaps it would be a good idea to merge Cell and Option, and take that opportunity to change the interface to use '&mut self' instead of '&self' (which would enable removing the transmutations) for take and put_back.\r\n\r\nr?", "tree": {"sha": "5ffc056b80c192ee5f1ed2a2c2cf5cedf10378ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ffc056b80c192ee5f1ed2a2c2cf5cedf10378ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a", "html_url": "https://github.com/rust-lang/rust/commit/17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b933aeba22a718d5dadeb395b5e3b2d183812bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b933aeba22a718d5dadeb395b5e3b2d183812bf", "html_url": "https://github.com/rust-lang/rust/commit/5b933aeba22a718d5dadeb395b5e3b2d183812bf"}, {"sha": "397a47852849ac2e286508f2315e695f5d8168cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/397a47852849ac2e286508f2315e695f5d8168cf", "html_url": "https://github.com/rust-lang/rust/commit/397a47852849ac2e286508f2315e695f5d8168cf"}], "stats": {"total": 46, "additions": 22, "deletions": 24}, "files": [{"sha": "38a663dc24504cd4adf58600b3ccbd04346a36f1", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a", "patch": "@@ -208,7 +208,7 @@ pub mod raw {\n      */\n     #[inline(always)]\n     pub unsafe fn set_len<T>(v: @[T], new_len: uint) {\n-        let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(&v));\n+        let repr: **mut VecRepr = ::cast::reinterpret_cast(&addr_of(&v));\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n@@ -226,7 +226,7 @@ pub mod raw {\n \n     #[inline(always)] // really pretty please\n     pub unsafe fn push_fast<T>(v: &mut @[T], initval: T) {\n-        let repr: **VecRepr = ::cast::reinterpret_cast(&v);\n+        let repr: **mut VecRepr = ::cast::reinterpret_cast(&v);\n         let fill = (**repr).unboxed.fill;\n         (**repr).unboxed.fill += sys::size_of::<T>();\n         let p = addr_of(&((**repr).unboxed.data));"}, {"sha": "c2983e033e537af276f978ad878de0472f54ee6b", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a", "patch": "@@ -10,7 +10,7 @@\n \n //! A mutable, nullable memory location\n \n-use cast::transmute;\n+use cast::transmute_mut;\n use prelude::*;\n \n /*\n@@ -20,16 +20,12 @@ Similar to a mutable option type, but friendlier.\n */\n \n pub struct Cell<T> {\n-    mut value: Option<T>\n+    value: Option<T>\n }\n \n impl<T:cmp::Eq> cmp::Eq for Cell<T> {\n     fn eq(&self, other: &Cell<T>) -> bool {\n-        unsafe {\n-            let frozen_self: &Option<T> = transmute(&mut self.value);\n-            let frozen_other: &Option<T> = transmute(&mut other.value);\n-            frozen_self == frozen_other\n-        }\n+        (self.value) == (other.value)\n     }\n     fn ne(&self, other: &Cell<T>) -> bool { !self.eq(other) }\n }\n@@ -46,6 +42,7 @@ pub fn empty_cell<T>() -> Cell<T> {\n pub impl<T> Cell<T> {\n     /// Yields the value, failing if the cell is empty.\n     fn take(&self) -> T {\n+        let mut self = unsafe { transmute_mut(self) };\n         if self.is_empty() {\n             fail!(~\"attempt to take an empty cell\");\n         }\n@@ -57,6 +54,7 @@ pub impl<T> Cell<T> {\n \n     /// Returns the value, failing if the cell is full.\n     fn put_back(&self, value: T) {\n+        let mut self = unsafe { transmute_mut(self) };\n         if !self.is_empty() {\n             fail!(~\"attempt to put a value back into a full cell\");\n         }"}, {"sha": "18ea169d96e5cbcb64f968783b86f0e2c96c7bed", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a", "patch": "@@ -2274,8 +2274,8 @@ pub mod raw {\n \n     /// Sets the length of the string and adds the null terminator\n     pub unsafe fn set_len(v: &mut ~str, new_len: uint) {\n-        let v: **vec::raw::VecRepr = cast::transmute(v);\n-        let repr: *vec::raw::VecRepr = *v;\n+        let v: **mut vec::raw::VecRepr = cast::transmute(v);\n+        let repr: *mut vec::raw::VecRepr = *v;\n         (*repr).unboxed.fill = new_len + 1u;\n         let null = ptr::mut_offset(cast::transmute(&((*repr).unboxed.data)),\n                                    new_len);"}, {"sha": "c717c1692a8c532593fcd1073bd089ea83ff49ad", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a", "patch": "@@ -106,21 +106,21 @@ fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n  ****************************************************************************/\n \n struct ArcData<T> {\n-    mut count:     libc::intptr_t,\n+    count:     libc::intptr_t,\n     // FIXME(#3224) should be able to make this non-option to save memory\n-    mut data:      Option<T>,\n+    data:      Option<T>,\n }\n \n struct ArcDestruct<T> {\n-    mut data: *libc::c_void,\n+    data: *libc::c_void,\n }\n \n #[unsafe_destructor]\n impl<T> Drop for ArcDestruct<T>{\n     fn finalize(&self) {\n         unsafe {\n             do task::unkillable {\n-                let data: ~ArcData<T> = cast::reinterpret_cast(&self.data);\n+                let mut data: ~ArcData<T> = cast::reinterpret_cast(&self.data);\n                 let new_count =\n                     intrinsics::atomic_xsub(&mut data.count, 1) - 1;\n                 assert!(new_count >= 0);\n@@ -185,7 +185,7 @@ pub unsafe fn get_shared_immutable_state<'a,T:Owned>(\n pub unsafe fn clone_shared_mutable_state<T:Owned>(rc: &SharedMutableState<T>)\n         -> SharedMutableState<T> {\n     unsafe {\n-        let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n+        let mut ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         let new_count = intrinsics::atomic_xadd(&mut ptr.count, 1) + 1;\n         assert!(new_count >= 2);\n         cast::forget(ptr);\n@@ -252,15 +252,15 @@ pub impl LittleLock {\n     }\n }\n \n-struct ExData<T> { lock: LittleLock, mut failed: bool, mut data: T, }\n+struct ExData<T> { lock: LittleLock, failed: bool, data: T, }\n /**\n  * An arc over mutable data that is protected by a lock. For library use only.\n  */\n pub struct Exclusive<T> { x: SharedMutableState<ExData<T>> }\n \n pub fn exclusive<T:Owned>(user_data: T) -> Exclusive<T> {\n     let data = ExData {\n-        lock: LittleLock(), mut failed: false, mut data: user_data\n+        lock: LittleLock(), failed: false, data: user_data\n     };\n     Exclusive { x: unsafe { shared_mutable_state(data) } }\n }"}, {"sha": "21e876ea0fb02e6da62a4b916822aa8edef93cf1", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=17ab718d5989762d6ddf1a7ad02c1e64a9ae7f1a", "patch": "@@ -633,7 +633,7 @@ pub fn push<T>(v: &mut ~[T], initval: T) {\n // This doesn't bother to make sure we have space.\n #[inline(always)] // really pretty please\n unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n-    let repr: **raw::VecRepr = ::cast::transmute(v);\n+    let repr: **mut raw::VecRepr = ::cast::transmute(v);\n     let fill = (**repr).unboxed.fill;\n     (**repr).unboxed.fill += sys::nonzero_size_of::<T>();\n     let p = addr_of(&((**repr).unboxed.data));\n@@ -2148,8 +2148,8 @@ pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n \n /// The internal 'unboxed' representation of a vector\n pub struct UnboxedVecRepr {\n-    mut fill: uint,\n-    mut alloc: uint,\n+    fill: uint,\n+    alloc: uint,\n     data: u8\n }\n \n@@ -2171,8 +2171,8 @@ pub mod raw {\n     }\n \n     pub struct SliceRepr {\n-        mut data: *u8,\n-        mut len: uint\n+        data: *u8,\n+        len: uint\n     }\n \n     /**\n@@ -2184,7 +2184,7 @@ pub mod raw {\n      */\n     #[inline(always)]\n     pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n-        let repr: **VecRepr = ::cast::transmute(v);\n+        let repr: **mut VecRepr = ::cast::transmute(v);\n         (**repr).unboxed.fill = new_len * sys::nonzero_size_of::<T>();\n     }\n "}]}