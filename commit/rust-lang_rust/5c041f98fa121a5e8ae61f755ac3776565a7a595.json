{"sha": "5c041f98fa121a5e8ae61f755ac3776565a7a595", "node_id": "C_kwDOAAsO6NoAKDVjMDQxZjk4ZmExMjFhNWU4YWU2MWY3NTVhYzM3NzY1NjVhN2E1OTU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-06-02T09:13:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-02T09:13:22Z"}, "message": "Rollup merge of #97023 - cjgillot:uniform-anon, r=estebank\n\nDiagnose anonymous lifetimes errors more uniformly between async and regular fns\n\nAsync fns and regular fns are desugared differently.  For the former, we create a generic parameter at HIR level.  For the latter, we just create an anonymous region for typeck.\n\nI plan to migrate regular fns to the async fn desugaring.\n\nBefore that, this PR attempts to merge the diagnostics for both cases.\n\nr? ```@estebank```", "tree": {"sha": "71073f83e134445b7797a01d9066768d449801a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71073f83e134445b7797a01d9066768d449801a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c041f98fa121a5e8ae61f755ac3776565a7a595", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJimH8yCRBK7hj4Ov3rIwAA66IIAGYBvusJDqJhoJ5A/AKUB6/3\ntuo9CSb3thw1/OJ6V/5rJi856jjcM74izmqFFPXfhVvonirZP96gY59Xxxf83Emw\nFdilK/24oZanhHRZmpx4NNEQf1DPdh7C78TYJwXLUK5qrlmp1B4ZKZj1ImAmd1o6\naayvFNxq59C+C/BB5qpd6uB8p/Btn1UlzhTN3CwkEqYiazj9cM1lySZVatTCSO4F\nlzUuVtpwNW3aBlhmFzGkss8cjQHb6Q04i0JHXMGEHjW4bpTNZFx9/3WN9XSOtZp1\nGNRMhCZAcsnNer6e6rlAtchphgUvQgYhKFe47mLN904K4zwH2h1gx6AjnCk8dbs=\n=q/Go\n-----END PGP SIGNATURE-----\n", "payload": "tree 71073f83e134445b7797a01d9066768d449801a7\nparent ddc5d2c9d2c0d100707666d5f2168ccc0dab40ed\nparent 0cf79d7d680bf8ef6f5c9939e7d2d730b504f5e0\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1654161202 +0200\ncommitter GitHub <noreply@github.com> 1654161202 +0200\n\nRollup merge of #97023 - cjgillot:uniform-anon, r=estebank\n\nDiagnose anonymous lifetimes errors more uniformly between async and regular fns\n\nAsync fns and regular fns are desugared differently.  For the former, we create a generic parameter at HIR level.  For the latter, we just create an anonymous region for typeck.\n\nI plan to migrate regular fns to the async fn desugaring.\n\nBefore that, this PR attempts to merge the diagnostics for both cases.\n\nr? ```@estebank```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c041f98fa121a5e8ae61f755ac3776565a7a595", "html_url": "https://github.com/rust-lang/rust/commit/5c041f98fa121a5e8ae61f755ac3776565a7a595", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c041f98fa121a5e8ae61f755ac3776565a7a595/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddc5d2c9d2c0d100707666d5f2168ccc0dab40ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc5d2c9d2c0d100707666d5f2168ccc0dab40ed", "html_url": "https://github.com/rust-lang/rust/commit/ddc5d2c9d2c0d100707666d5f2168ccc0dab40ed"}, {"sha": "0cf79d7d680bf8ef6f5c9939e7d2d730b504f5e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cf79d7d680bf8ef6f5c9939e7d2d730b504f5e0", "html_url": "https://github.com/rust-lang/rust/commit/0cf79d7d680bf8ef6f5c9939e7d2d730b504f5e0"}], "stats": {"total": 814, "additions": 620, "deletions": 194}, "files": [{"sha": "cb4b154d271a54a0a9c0e7b2a5f436f64eb4747d", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -567,15 +567,17 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         let lifetime =\n             self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n         match lifetime.name {\n-            hir::LifetimeName::Param(_)\n+            hir::LifetimeName::Param(hir::ParamName::Plain(_) | hir::ParamName::Error)\n             | hir::LifetimeName::Error\n-            | hir::LifetimeName::Static\n-            | hir::LifetimeName::Underscore => {\n+            | hir::LifetimeName::Static => {\n                 let lifetime_span = lifetime.span;\n                 Some(RegionNameHighlight::MatchedAdtAndSegment(lifetime_span))\n             }\n \n-            hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Implicit => {\n+            hir::LifetimeName::Param(hir::ParamName::Fresh(_))\n+            | hir::LifetimeName::ImplicitObjectLifetimeDefault\n+            | hir::LifetimeName::Implicit\n+            | hir::LifetimeName::Underscore => {\n                 // In this case, the user left off the lifetime; so\n                 // they wrote something like:\n                 //"}, {"sha": "dbe6fe6ea84022e7da78650cdbed48e941d5a419", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -131,6 +131,17 @@ impl LifetimeName {\n         }\n     }\n \n+    pub fn is_anonymous(&self) -> bool {\n+        match *self {\n+            LifetimeName::ImplicitObjectLifetimeDefault\n+            | LifetimeName::Implicit\n+            | LifetimeName::Underscore\n+            | LifetimeName::Param(ParamName::Fresh(_))\n+            | LifetimeName::Error => true,\n+            LifetimeName::Static | LifetimeName::Param(_) => false,\n+        }\n+    }\n+\n     pub fn is_elided(&self) -> bool {\n         match self {\n             LifetimeName::ImplicitObjectLifetimeDefault"}, {"sha": "579d7efb56803ec26da25fa6aa5e82cbf1f74f91", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -72,7 +72,7 @@ use rustc_middle::ty::{\n     subst::{GenericArgKind, Subst, SubstsRef},\n     Binder, EarlyBinder, List, Region, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_span::{sym, BytePos, DesugaringKind, Pos, Span};\n+use rustc_span::{sym, symbol::kw, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::ops::ControlFlow;\n use std::{cmp, fmt, iter};\n@@ -161,35 +161,45 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n             {\n                 sp = param.span;\n             }\n-            (format!(\"the lifetime `{}` as defined here\", br.name), sp)\n+            let text = if br.has_name() {\n+                format!(\"the lifetime `{}` as defined here\", br.name)\n+            } else {\n+                format!(\"the anonymous lifetime as defined here\")\n+            };\n+            (text, sp)\n         }\n-        ty::ReFree(ty::FreeRegion {\n-            bound_region: ty::BoundRegionKind::BrNamed(_, name), ..\n-        }) => {\n-            let mut sp = sm.guess_head_span(tcx.def_span(scope));\n-            if let Some(param) =\n-                tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n+        ty::ReFree(ref fr) => {\n+            if !fr.bound_region.is_named()\n+                && let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region)\n             {\n-                sp = param.span;\n-            }\n-            (format!(\"the lifetime `{}` as defined here\", name), sp)\n-        }\n-        ty::ReFree(ref fr) => match fr.bound_region {\n-            ty::BrAnon(idx) => {\n-                if let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region) {\n-                    (\"the anonymous lifetime defined here\".to_string(), ty.span)\n-                } else {\n-                    (\n+                (\"the anonymous lifetime defined here\".to_string(), ty.span)\n+            } else {\n+                match fr.bound_region {\n+                    ty::BoundRegionKind::BrNamed(_, name) => {\n+                        let mut sp = sm.guess_head_span(tcx.def_span(scope));\n+                        if let Some(param) =\n+                            tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n+                        {\n+                            sp = param.span;\n+                        }\n+                        let text = if name == kw::UnderscoreLifetime {\n+                            format!(\"the anonymous lifetime as defined here\")\n+                        } else {\n+                            format!(\"the lifetime `{}` as defined here\", name)\n+                        };\n+                        (text, sp)\n+                    }\n+                    ty::BrAnon(idx) => (\n                         format!(\"the anonymous lifetime #{} defined here\", idx + 1),\n-                        tcx.def_span(scope),\n-                    )\n+                        tcx.def_span(scope)\n+                    ),\n+                    _ => (\n+                        format!(\"the lifetime `{}` as defined here\", region),\n+                        sm.guess_head_span(tcx.def_span(scope)),\n+                    ),\n                 }\n             }\n-            _ => (\n-                format!(\"the lifetime `{}` as defined here\", region),\n-                sm.guess_head_span(tcx.def_span(scope)),\n-            ),\n-        },\n+        }\n         _ => bug!(),\n     }\n }\n@@ -2552,7 +2562,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 ty::ReEarlyBound(ty::EarlyBoundRegion { name, .. })\n                 | ty::ReFree(ty::FreeRegion { bound_region: ty::BrNamed(_, name), .. }),\n                 _,\n-            ) => {\n+            ) if name != kw::UnderscoreLifetime => {\n                 // Does the required lifetime have a nice name we can print?\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,"}, {"sha": "b744594ddb7e6b0e6bd2548c5b87c77a22394254", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -12,6 +12,7 @@ use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::{GenericParamKind, Ty};\n use rustc_middle::ty::Region;\n+use rustc_span::symbol::kw;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when both the concerned regions are anonymous.\n@@ -169,7 +170,7 @@ pub fn suggest_adding_lifetime_params<'tcx>(\n         return false;\n     };\n \n-    if !lifetime_sub.name.is_elided() || !lifetime_sup.name.is_elided() {\n+    if !lifetime_sub.name.is_anonymous() || !lifetime_sup.name.is_anonymous() {\n         return false;\n     };\n \n@@ -188,32 +189,37 @@ pub fn suggest_adding_lifetime_params<'tcx>(\n         _ => return false,\n     };\n \n-    let (suggestion_param_name, introduce_new) = generics\n+    let suggestion_param_name = generics\n         .params\n         .iter()\n-        .find(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }))\n-        .and_then(|p| tcx.sess.source_map().span_to_snippet(p.span).ok())\n-        .map(|name| (name, false))\n-        .unwrap_or_else(|| (\"'a\".to_string(), true));\n-\n-    let mut suggestions = vec![\n-        if let hir::LifetimeName::Underscore = lifetime_sub.name {\n-            (lifetime_sub.span, suggestion_param_name.clone())\n+        .filter(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }))\n+        .map(|p| p.name.ident().name)\n+        .find(|i| *i != kw::UnderscoreLifetime);\n+    let introduce_new = suggestion_param_name.is_none();\n+    let suggestion_param_name =\n+        suggestion_param_name.map(|n| n.to_string()).unwrap_or_else(|| \"'a\".to_owned());\n+\n+    debug!(?lifetime_sup.span);\n+    debug!(?lifetime_sub.span);\n+    let make_suggestion = |span: rustc_span::Span| {\n+        if span.is_empty() {\n+            (span, format!(\"{}, \", suggestion_param_name))\n+        } else if let Ok(\"&\") = tcx.sess.source_map().span_to_snippet(span).as_deref() {\n+            (span.shrink_to_hi(), format!(\"{} \", suggestion_param_name))\n         } else {\n-            (lifetime_sub.span.shrink_to_hi(), suggestion_param_name.clone() + \" \")\n-        },\n-        if let hir::LifetimeName::Underscore = lifetime_sup.name {\n-            (lifetime_sup.span, suggestion_param_name.clone())\n-        } else {\n-            (lifetime_sup.span.shrink_to_hi(), suggestion_param_name.clone() + \" \")\n-        },\n-    ];\n+            (span, suggestion_param_name.clone())\n+        }\n+    };\n+    let mut suggestions =\n+        vec![make_suggestion(lifetime_sub.span), make_suggestion(lifetime_sup.span)];\n \n     if introduce_new {\n-        let new_param_suggestion = match &generics.params {\n-            [] => (generics.span, format!(\"<{}>\", suggestion_param_name)),\n-            [first, ..] => (first.span.shrink_to_lo(), format!(\"{}, \", suggestion_param_name)),\n-        };\n+        let new_param_suggestion =\n+            if let Some(first) = generics.params.iter().find(|p| !p.name.ident().span.is_empty()) {\n+                (first.span.shrink_to_lo(), format!(\"{}, \", suggestion_param_name))\n+            } else {\n+                (generics.span, format!(\"<{}>\", suggestion_param_name))\n+            };\n \n         suggestions.push(new_param_suggestion);\n     }"}, {"sha": "375ad8d3736dc2fb2f266956346d42d6d1cfabec", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -4,6 +4,7 @@ use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_middle::ty;\n+use rustc_span::symbol::kw;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with parameters containing a named region and\n@@ -67,7 +68,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let is_impl_item = region_info.is_impl_item;\n \n         match br {\n-            ty::BrAnon(_) => {}\n+            ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(_) => {}\n             _ => {\n                 /* not an anonymous region */\n                 debug!(\"try_report_named_anon_conflict: not an anonymous region\");"}, {"sha": "64c63e3d567d039d91b133a01662b1f46e6a4b29", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 28, "deletions": 43, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -2177,61 +2177,47 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         define_scoped_cx!(self);\n \n         let mut region_index = self.region_index;\n+        let mut next_name = |this: &Self| loop {\n+            let name = name_by_region_index(region_index);\n+            region_index += 1;\n+            if !this.used_region_names.contains(&name) {\n+                break name;\n+            }\n+        };\n+\n         // If we want to print verbosely, then print *all* binders, even if they\n         // aren't named. Eventually, we might just want this as the default, but\n         // this is not *quite* right and changes the ordering of some output\n         // anyways.\n         let (new_value, map) = if self.tcx().sess.verbose() {\n             // anon index + 1 (BrEnv takes 0) -> name\n-            let mut region_map: BTreeMap<u32, Symbol> = BTreeMap::default();\n+            let mut region_map: FxHashMap<_, _> = Default::default();\n             let bound_vars = value.bound_vars();\n             for var in bound_vars {\n+                let ty::BoundVariableKind::Region(var) = var else { continue };\n                 match var {\n-                    ty::BoundVariableKind::Region(ty::BrNamed(_, name)) => {\n+                    ty::BrAnon(_) | ty::BrEnv => {\n                         start_or_continue(&mut self, \"for<\", \", \");\n+                        let name = next_name(&self);\n                         do_continue(&mut self, name);\n+                        region_map.insert(var, ty::BrNamed(CRATE_DEF_ID.to_def_id(), name));\n                     }\n-                    ty::BoundVariableKind::Region(ty::BrAnon(i)) => {\n+                    ty::BrNamed(def_id, kw::UnderscoreLifetime) => {\n                         start_or_continue(&mut self, \"for<\", \", \");\n-                        let name = loop {\n-                            let name = name_by_region_index(region_index);\n-                            region_index += 1;\n-                            if !self.used_region_names.contains(&name) {\n-                                break name;\n-                            }\n-                        };\n+                        let name = next_name(&self);\n                         do_continue(&mut self, name);\n-                        region_map.insert(i + 1, name);\n+                        region_map.insert(var, ty::BrNamed(def_id, name));\n                     }\n-                    ty::BoundVariableKind::Region(ty::BrEnv) => {\n+                    ty::BrNamed(_, name) => {\n                         start_or_continue(&mut self, \"for<\", \", \");\n-                        let name = loop {\n-                            let name = name_by_region_index(region_index);\n-                            region_index += 1;\n-                            if !self.used_region_names.contains(&name) {\n-                                break name;\n-                            }\n-                        };\n                         do_continue(&mut self, name);\n-                        region_map.insert(0, name);\n                     }\n-                    _ => continue,\n                 }\n             }\n             start_or_continue(&mut self, \"\", \"> \");\n \n             self.tcx.replace_late_bound_regions(value.clone(), |br| {\n-                let kind = match br.kind {\n-                    ty::BrNamed(_, _) => br.kind,\n-                    ty::BrAnon(i) => {\n-                        let name = region_map[&(i + 1)];\n-                        ty::BrNamed(CRATE_DEF_ID.to_def_id(), name)\n-                    }\n-                    ty::BrEnv => {\n-                        let name = region_map[&0];\n-                        ty::BrNamed(CRATE_DEF_ID.to_def_id(), name)\n-                    }\n-                };\n+                let kind = region_map[&br.kind];\n                 self.tcx.mk_region(ty::ReLateBound(\n                     ty::INNERMOST,\n                     ty::BoundRegion { var: br.var, kind },\n@@ -2242,21 +2228,20 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n             let mut name = |br: ty::BoundRegion| {\n                 start_or_continue(&mut self, \"for<\", \", \");\n                 let kind = match br.kind {\n-                    ty::BrNamed(_, name) => {\n-                        do_continue(&mut self, name);\n-                        br.kind\n-                    }\n                     ty::BrAnon(_) | ty::BrEnv => {\n-                        let name = loop {\n-                            let name = name_by_region_index(region_index);\n-                            region_index += 1;\n-                            if !self.used_region_names.contains(&name) {\n-                                break name;\n-                            }\n-                        };\n+                        let name = next_name(&self);\n                         do_continue(&mut self, name);\n                         ty::BrNamed(CRATE_DEF_ID.to_def_id(), name)\n                     }\n+                    ty::BrNamed(def_id, kw::UnderscoreLifetime) => {\n+                        let name = next_name(&self);\n+                        do_continue(&mut self, name);\n+                        ty::BrNamed(def_id, name)\n+                    }\n+                    ty::BrNamed(_, name) => {\n+                        do_continue(&mut self, name);\n+                        br.kind\n+                    }\n                 };\n                 tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { var: br.var, kind }))\n             };"}, {"sha": "de5367ca27c3a65af21bab6cdc8b198881c27712", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 107, "deletions": 70, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -8,10 +8,11 @@ use super::*;\n use rustc_attr as attr;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{def::Res, ItemKind, Node, PathSegment};\n+use rustc_hir::{ItemKind, Node, PathSegment};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n@@ -29,7 +30,6 @@ use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_ty_utils::representability::{self, Representability};\n \n-use rustc_hir::def::DefKind;\n use std::iter;\n use std::ops::ControlFlow;\n \n@@ -93,7 +93,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n     fcx.return_type_pre_known = return_type_pre_known;\n \n     let tcx = fcx.tcx;\n-    let sess = tcx.sess;\n     let hir = tcx.hir();\n \n     let declared_ret_ty = fn_sig.output();\n@@ -259,85 +258,123 @@ pub(super) fn check_fn<'a, 'tcx>(\n     if let Some(panic_impl_did) = tcx.lang_items().panic_impl()\n         && panic_impl_did == hir.local_def_id(fn_id).to_def_id()\n     {\n-        if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n-            if *declared_ret_ty.kind() != ty::Never {\n-                sess.span_err(decl.output.span(), \"return type should be `!`\");\n-            }\n-\n-            let inputs = fn_sig.inputs();\n-            let span = hir.span(fn_id);\n-            if inputs.len() == 1 {\n-                let arg_is_panic_info = match *inputs[0].kind() {\n-                    ty::Ref(region, ty, mutbl) => match *ty.kind() {\n-                        ty::Adt(ref adt, _) => {\n-                            adt.did() == panic_info_did\n-                                && mutbl == hir::Mutability::Not\n-                                && !region.is_static()\n-                        }\n-                        _ => false,\n-                    },\n-                    _ => false,\n-                };\n-\n-                if !arg_is_panic_info {\n-                    sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n-                }\n-\n-                if let Node::Item(item) = hir.get(fn_id)\n-                    && let ItemKind::Fn(_, ref generics, _) = item.kind\n-                    && !generics.params.is_empty()\n-                {\n-                            sess.span_err(span, \"should have no type parameters\");\n-                        }\n-            } else {\n-                let span = sess.source_map().guess_head_span(span);\n-                sess.span_err(span, \"function should have one argument\");\n-            }\n-        } else {\n-            sess.err(\"language item required, but not found: `panic_info`\");\n-        }\n+        check_panic_info_fn(tcx, panic_impl_did.expect_local(), fn_sig, decl, declared_ret_ty);\n     }\n \n     // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n     if let Some(alloc_error_handler_did) = tcx.lang_items().oom()\n         && alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id()\n     {\n-        if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n-            if *declared_ret_ty.kind() != ty::Never {\n-                sess.span_err(decl.output.span(), \"return type should be `!`\");\n-            }\n+        check_alloc_error_fn(tcx, alloc_error_handler_did.expect_local(), fn_sig, decl, declared_ret_ty);\n+    }\n \n-            let inputs = fn_sig.inputs();\n-            let span = hir.span(fn_id);\n-            if inputs.len() == 1 {\n-                let arg_is_alloc_layout = match inputs[0].kind() {\n-                    ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n-                    _ => false,\n-                };\n+    (fcx, gen_ty)\n+}\n \n-                if !arg_is_alloc_layout {\n-                    sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n-                }\n+fn check_panic_info_fn(\n+    tcx: TyCtxt<'_>,\n+    fn_id: LocalDefId,\n+    fn_sig: ty::FnSig<'_>,\n+    decl: &hir::FnDecl<'_>,\n+    declared_ret_ty: Ty<'_>,\n+) {\n+    let Some(panic_info_did) = tcx.lang_items().panic_info() else {\n+        tcx.sess.err(\"language item required, but not found: `panic_info`\");\n+        return;\n+    };\n \n-                if let Node::Item(item) = hir.get(fn_id)\n-                    && let ItemKind::Fn(_, ref generics, _) = item.kind\n-                    && !generics.params.is_empty()\n-                {\n-                            sess.span_err(\n-                                span,\n-                        \"`#[alloc_error_handler]` function should have no type parameters\",\n-                            );\n-                        }\n-            } else {\n-                let span = sess.source_map().guess_head_span(span);\n-                sess.span_err(span, \"function should have one argument\");\n+    if *declared_ret_ty.kind() != ty::Never {\n+        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+    }\n+\n+    let span = tcx.def_span(fn_id);\n+    let inputs = fn_sig.inputs();\n+    if inputs.len() != 1 {\n+        let span = tcx.sess.source_map().guess_head_span(span);\n+        tcx.sess.span_err(span, \"function should have one argument\");\n+        return;\n+    }\n+\n+    let arg_is_panic_info = match *inputs[0].kind() {\n+        ty::Ref(region, ty, mutbl) => match *ty.kind() {\n+            ty::Adt(ref adt, _) => {\n+                adt.did() == panic_info_did && mutbl == hir::Mutability::Not && !region.is_static()\n             }\n-        } else {\n-            sess.err(\"language item required, but not found: `alloc_layout`\");\n-        }\n+            _ => false,\n+        },\n+        _ => false,\n+    };\n+\n+    if !arg_is_panic_info {\n+        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n     }\n \n-    (fcx, gen_ty)\n+    let DefKind::Fn = tcx.def_kind(fn_id) else {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should be a function\");\n+        return;\n+    };\n+\n+    let generic_counts = tcx.generics_of(fn_id).own_counts();\n+    if generic_counts.types != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should have no type parameters\");\n+    }\n+    if generic_counts.consts != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should have no const parameters\");\n+    }\n+}\n+\n+fn check_alloc_error_fn(\n+    tcx: TyCtxt<'_>,\n+    fn_id: LocalDefId,\n+    fn_sig: ty::FnSig<'_>,\n+    decl: &hir::FnDecl<'_>,\n+    declared_ret_ty: Ty<'_>,\n+) {\n+    let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() else {\n+        tcx.sess.err(\"language item required, but not found: `alloc_layout`\");\n+        return;\n+    };\n+\n+    if *declared_ret_ty.kind() != ty::Never {\n+        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+    }\n+\n+    let inputs = fn_sig.inputs();\n+    if inputs.len() != 1 {\n+        let span = tcx.def_span(fn_id);\n+        let span = tcx.sess.source_map().guess_head_span(span);\n+        tcx.sess.span_err(span, \"function should have one argument\");\n+        return;\n+    }\n+\n+    let arg_is_alloc_layout = match inputs[0].kind() {\n+        ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n+        _ => false,\n+    };\n+\n+    if !arg_is_alloc_layout {\n+        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n+    }\n+\n+    let DefKind::Fn = tcx.def_kind(fn_id) else {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"`#[alloc_error_handler]` should be a function\");\n+        return;\n+    };\n+\n+    let generic_counts = tcx.generics_of(fn_id).own_counts();\n+    if generic_counts.types != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"`#[alloc_error_handler]` function should have no type parameters\");\n+    }\n+    if generic_counts.consts != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess\n+            .span_err(span, \"`#[alloc_error_handler]` function should have no const parameters\");\n+    }\n }\n \n fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) {"}, {"sha": "4d17307ddb968bd72993d422bdea2dbfba07be3f", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -660,8 +660,24 @@ fn compare_number_of_generics<'tcx>(\n                     _ => None,\n                 })\n                 .collect();\n-            let spans = impl_item.generics.spans();\n-            let span = spans.primary_span();\n+            let spans = if impl_item.generics.params.is_empty() {\n+                vec![impl_item.generics.span]\n+            } else {\n+                impl_item\n+                    .generics\n+                    .params\n+                    .iter()\n+                    .filter(|p| {\n+                        matches!(\n+                            p.kind,\n+                            hir::GenericParamKind::Type { .. }\n+                                | hir::GenericParamKind::Const { .. }\n+                        )\n+                    })\n+                    .map(|p| p.span)\n+                    .collect::<Vec<Span>>()\n+            };\n+            let span = spans.first().copied();\n \n             let mut err = tcx.sess.struct_span_err_with_code(\n                 spans,"}, {"sha": "109883fbeb7cb2ca77c1417818c67eee68f780b8", "filename": "src/test/ui/async-await/issue-76547.base.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.base.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -5,6 +5,12 @@ LL | async fn fut(bufs: &mut [&mut [u8]]) {\n    |                    ---------------- these two types are declared with different lifetimes...\n LL |     ListFut(bufs).await\n    |             ^^^^ ...but data from `bufs` flows into `bufs` here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | async fn fut<'a>(bufs: &'a mut [&'a mut [u8]]) {\n+   |             ++++        ++       ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/issue-76547.rs:39:14\n@@ -13,6 +19,12 @@ LL | async fn fut2(bufs: &mut [&mut [u8]]) -> i32 {\n    |                     ---------------- these two types are declared with different lifetimes...\n LL |     ListFut2(bufs).await\n    |              ^^^^ ...but data from `bufs` flows into `bufs` here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | async fn fut2<'a>(bufs: &'a mut [&'a mut [u8]]) -> i32 {\n+   |              ++++        ++       ++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0a5a52cb79e4ce06dfb9fde3014505e651207e9a", "filename": "src/test/ui/async-await/issue-76547.nll.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.nll.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -7,6 +7,11 @@ LL | async fn fut(bufs: &mut [&mut [u8]]) {\n    |                    let's call the lifetime of this reference `'1`\n LL |     ListFut(bufs).await\n    |             ^^^^ this usage requires that `'1` must outlive `'2`\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | async fn fut<'a>(bufs: &'a mut [&'a mut [u8]]) {\n+   |             ++++        ++       ++\n \n error: lifetime may not live long enough\n   --> $DIR/issue-76547.rs:39:14\n@@ -17,6 +22,11 @@ LL | async fn fut2(bufs: &mut [&mut [u8]]) -> i32 {\n    |                     let's call the lifetime of this reference `'1`\n LL |     ListFut2(bufs).await\n    |              ^^^^ this usage requires that `'1` must outlive `'2`\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | async fn fut2<'a>(bufs: &'a mut [&'a mut [u8]]) -> i32 {\n+   |              ++++        ++       ++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f5409a7ca5d29ecd7c9a88a4bbd248d9f8712135", "filename": "src/test/ui/async-await/issues/issue-63388-1.base.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.base.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -1,14 +1,12 @@\n-error[E0623]: lifetime mismatch\n+error[E0621]: explicit lifetime required in the type of `foo`\n   --> $DIR/issue-63388-1.rs:19:9\n    |\n LL |         &'a self, foo: &dyn Foo\n-   |                        -------- this parameter and the return type are declared with different lifetimes...\n-LL |     ) -> &dyn Foo\n-   |          --------\n+   |                        -------- help: add explicit lifetime `'a` to the type of `foo`: `&'a (dyn Foo + 'a)`\n ...\n LL |         foo\n-   |         ^^^ ...but data from `foo` is returned here\n+   |         ^^^ lifetime `'a` required\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0623`.\n+For more information about this error, try `rustc --explain E0621`."}, {"sha": "9263a81bb6af42c3a4f2e20d3f7f6986548ff7d0", "filename": "src/test/ui/async-await/issues/issue-63388-1.nll.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -1,17 +1,16 @@\n-error: lifetime may not live long enough\n+error[E0621]: explicit lifetime required in the type of `foo`\n   --> $DIR/issue-63388-1.rs:17:5\n    |\n-LL |       async fn do_sth<'a>(\n-   |                       -- lifetime `'a` defined here\n LL |           &'a self, foo: &dyn Foo\n-   |                          - let's call the lifetime of this reference `'1`\n+   |                          -------- help: add explicit lifetime `'a` to the type of `foo`: `&'a (dyn Foo + 'a)`\n LL |       ) -> &dyn Foo\n LL | /     {\n LL | |\n LL | |         foo\n LL | |\n LL | |     }\n-   | |_____^ associated function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'1`\n+   | |_____^ lifetime `'a` required\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0621`."}, {"sha": "f00f92954064095e13e9e4e0a7194b63fafea198", "filename": "src/test/ui/async-await/issues/issue-63388-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.rs?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -15,9 +15,9 @@ impl Xyz {\n         &'a self, foo: &dyn Foo\n     ) -> &dyn Foo\n     {\n-        //[nll]~^ ERROR lifetime may not live long enough\n+        //[nll]~^ ERROR explicit lifetime required in the type of `foo` [E0621]\n         foo\n-        //[base]~^ ERROR lifetime mismatch\n+        //[base]~^ ERROR explicit lifetime required in the type of `foo` [E0621]\n     }\n }\n "}, {"sha": "de54a417253d406a36d29920a2f6346b1895b6ea", "filename": "src/test/ui/error-codes/E0308-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Ferror-codes%2FE0308-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Ferror-codes%2FE0308-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0308-2.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -6,7 +6,7 @@ LL | impl Eq for &dyn DynEq {}\n    |\n    = note: expected trait `<&dyn DynEq as PartialEq>`\n               found trait `<&(dyn DynEq + 'static) as PartialEq>`\n-note: the lifetime `'_` as defined here...\n+note: the anonymous lifetime as defined here...\n   --> $DIR/E0308-2.rs:9:13\n    |\n LL | impl Eq for &dyn DynEq {}"}, {"sha": "76d39c88b61c3e38863642186da8178524577030", "filename": "src/test/ui/generic-associated-types/parameter_number_and_kind_impl.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fparameter_number_and_kind_impl.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -8,17 +8,15 @@ LL |     type A = u32;\n    |           ^ lifetimes do not match type in trait\n \n error[E0049]: type `B` has 1 type parameter but its trait declaration has 0 type parameters\n-  --> $DIR/parameter_number_and_kind_impl.rs:17:12\n+  --> $DIR/parameter_number_and_kind_impl.rs:17:16\n    |\n LL |     type B<'a, 'b>;\n    |            --  --\n    |            |\n    |            expected 0 type parameters\n ...\n LL |     type B<'a, T> = Vec<T>;\n-   |            ^^  ^\n-   |            |\n-   |            found 1 type parameter\n+   |                ^ found 1 type parameter\n \n error[E0195]: lifetime parameters or bounds on type `C` do not match the trait declaration\n   --> $DIR/parameter_number_and_kind_impl.rs:19:11"}, {"sha": "88b5fbec6cf03a860e548461e3c0309ae753db21", "filename": "src/test/ui/issues/issue-17905-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fissues%2Fissue-17905-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fissues%2Fissue-17905-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17905-2.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -11,7 +11,7 @@ note: the anonymous lifetime defined here...\n    |\n LL |     fn say(self: &Pair<&str, isize>) {\n    |                        ^^^^\n-note: ...does not necessarily outlive the lifetime `'_` as defined here\n+note: ...does not necessarily outlive the anonymous lifetime as defined here\n   --> $DIR/issue-17905-2.rs:5:5\n    |\n LL |     &str,\n@@ -25,7 +25,7 @@ LL |     fn say(self: &Pair<&str, isize>) {\n    |\n    = note: expected struct `Pair<&str, _>`\n               found struct `Pair<&str, _>`\n-note: the lifetime `'_` as defined here...\n+note: the anonymous lifetime as defined here...\n   --> $DIR/issue-17905-2.rs:5:5\n    |\n LL |     &str,"}, {"sha": "fcabcdea74fc299305032f124e33ee9ce56aeff3", "filename": "src/test/ui/issues/issue-65230.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fissues%2Fissue-65230.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fissues%2Fissue-65230.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65230.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -6,7 +6,7 @@ LL | impl T1 for &dyn T2 {}\n    |\n    = note: expected trait `<&dyn T2 as T0>`\n               found trait `<&(dyn T2 + 'static) as T0>`\n-note: the lifetime `'_` as defined here...\n+note: the anonymous lifetime as defined here...\n   --> $DIR/issue-65230.rs:8:13\n    |\n LL | impl T1 for &dyn T2 {}"}, {"sha": "7b1fac082e42f18a4774857bcdf50a6642a74305", "filename": "src/test/ui/nll/issue-52742.base.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fnll%2Fissue-52742.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fnll%2Fissue-52742.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52742.base.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -4,7 +4,7 @@ error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n LL |         self.y = b.z\n    |                  ^^^\n    |\n-note: ...the reference is valid for the lifetime `'_` as defined here...\n+note: ...the reference is valid for the anonymous lifetime as defined here...\n   --> $DIR/issue-52742.rs:15:10\n    |\n LL | impl Foo<'_, '_> {"}, {"sha": "1a2165e0a9dac1578af9ee00974cd4e37901d4a4", "filename": "src/test/ui/nll/issue-52742.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fnll%2Fissue-52742.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fnll%2Fissue-52742.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52742.nll.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -2,7 +2,7 @@ error: lifetime may not live long enough\n   --> $DIR/issue-52742.rs:17:9\n    |\n LL |     fn take_bar(&mut self, b: Bar<'_>) {\n-   |                 ---------         -- let's call this `'1`\n+   |                 ---------  - has type `Bar<'1>`\n    |                 |\n    |                 has type `&mut Foo<'_, '2>`\n LL |         self.y = b.z"}, {"sha": "2ec6a7af3f25747af97e73c1ec28ab741c9b9cac", "filename": "src/test/ui/nll/issue-55394.base.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fnll%2Fissue-55394.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fnll%2Fissue-55394.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55394.base.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -14,7 +14,7 @@ note: ...so that reference does not outlive borrowed content\n    |\n LL |         Foo { bar }\n    |               ^^^\n-note: but, the lifetime must be valid for the lifetime `'_` as defined here...\n+note: but, the lifetime must be valid for the anonymous lifetime as defined here...\n   --> $DIR/issue-55394.rs:11:10\n    |\n LL | impl Foo<'_> {"}, {"sha": "5b8b9bb68ad1e916c397e2413614d6ad3b6baebd", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -2,9 +2,9 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:48\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                          -                     ^^^^^^^^\n+   |                          -----                 ^^^^^^^^\n    |                          |\n-   |                          hidden type `Pin<&Foo>` captures the lifetime `'_` as defined here\n+   |                          hidden type `Pin<&Foo>` captures the anonymous lifetime defined here\n    |\n help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n    |"}, {"sha": "d2106630dfed799deade85311de88b7308030239", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_mismatch-async.base.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.base.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -5,6 +5,12 @@ LL |     async fn a(self: Pin<&Foo>, f: &Foo) -> &Foo { f }\n    |                                    ----     ----   ^ ...but data from `f` is returned here\n    |                                    |\n    |                                    this parameter and the return type are declared with different lifetimes...\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn a<'a>(self: Pin<&'a Foo>, f: &'a Foo) -> &Foo { f }\n+   |               ++++            ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:15:82\n@@ -13,6 +19,12 @@ LL |     async fn c(self: Pin<&Self>, f: &Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (\n    |                                     ----              -----------------          ^ ...but data from `f` is returned here\n    |                                     |\n    |                                     this parameter and the return type are declared with different lifetimes...\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn c<'a>(self: Pin<&'a Self>, f: &'a Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (self, f) }\n+   |               ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:22:64"}, {"sha": "3fd58725d02b7fcf3ba0218e83d8156e794d4c14", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -6,6 +6,11 @@ LL |     async fn a(self: Pin<&Foo>, f: &Foo) -> &Foo { f }\n    |                          |         |\n    |                          |         let's call the lifetime of this reference `'1`\n    |                          let's call the lifetime of this reference `'2`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn a<'a>(self: Pin<&'a Foo>, f: &'a Foo) -> &Foo { f }\n+   |               ++++            ++           ++\n \n error: lifetime may not live long enough\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:15:75\n@@ -15,6 +20,11 @@ LL |     async fn c(self: Pin<&Self>, f: &Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (\n    |                          |          |\n    |                          |          let's call the lifetime of this reference `'1`\n    |                          let's call the lifetime of this reference `'2`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn c<'a>(self: Pin<&'a Self>, f: &'a Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (self, f) }\n+   |               ++++            ++            ++\n \n error: lifetime may not live long enough\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:22:64"}, {"sha": "0e2bbcc3c04db4f5eca744dc41570bba4503ebcb", "filename": "src/test/ui/self/elision/lt-ref-self-async.base.stderr", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.base.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -7,6 +7,12 @@ LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n    |                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_self<'a>(&'a self, f: &'a u32) -> &u32 {\n+   |                      ++++  ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:24:9\n@@ -17,6 +23,12 @@ LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n    |                                       this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Self<'a>(self: &'a Self, f: &'a u32) -> &u32 {\n+   |                      ++++        ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:30:9\n@@ -27,6 +39,12 @@ LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n    |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Self<'a>(self: Box<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:36:9\n@@ -37,6 +55,12 @@ LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n    |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Self<'a>(self: Pin<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:42:9\n@@ -47,6 +71,12 @@ LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n    |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Self<'a>(self: Box<Box<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++             ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:48:9\n@@ -57,6 +87,12 @@ LL |     async fn box_pin_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n    |                                                     this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_Self<'a>(self: Box<Pin<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                          ++++                ++             ++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "1c889838e7082cabbd3c4f95d18bec503f726fb9", "filename": "src/test/ui/self/elision/lt-ref-self-async.nll.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.nll.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -7,6 +7,11 @@ LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n    |                       let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_self<'a>(&'a self, f: &'a u32) -> &u32 {\n+   |                      ++++  ++           ++\n \n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:24:9\n@@ -17,6 +22,11 @@ LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n    |                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Self<'a>(self: &'a Self, f: &'a u32) -> &u32 {\n+   |                      ++++        ++           ++\n \n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:30:9\n@@ -27,6 +37,11 @@ LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n    |                                     let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Self<'a>(self: Box<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:36:9\n@@ -37,6 +52,11 @@ LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n    |                                     let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Self<'a>(self: Pin<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:42:9\n@@ -47,6 +67,11 @@ LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n    |                                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Self<'a>(self: Box<Box<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++             ++\n \n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:48:9\n@@ -57,6 +82,11 @@ LL |     async fn box_pin_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n    |                                         let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_Self<'a>(self: Box<Pin<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                          ++++                ++             ++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "8ffc0d62242129748939bfb5796ce1ad626bca07", "filename": "src/test/ui/self/elision/ref-mut-self-async.base.stderr", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.base.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -7,6 +7,12 @@ LL |     async fn ref_self(&mut self, f: &u32) -> &u32 {\n    |                                     this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_self<'a>(&'a mut self, f: &'a u32) -> &u32 {\n+   |                      ++++  ++               ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:24:9\n@@ -17,6 +23,12 @@ LL |     async fn ref_Self(self: &mut Self, f: &u32) -> &u32 {\n    |                                           this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Self<'a>(self: &'a mut Self, f: &'a u32) -> &u32 {\n+   |                      ++++        ++               ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:30:9\n@@ -27,6 +39,12 @@ LL |     async fn box_ref_Self(self: Box<&mut Self>, f: &u32) -> &u32 {\n    |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Self<'a>(self: Box<&'a mut Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++                ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:36:9\n@@ -37,6 +55,12 @@ LL |     async fn pin_ref_Self(self: Pin<&mut Self>, f: &u32) -> &u32 {\n    |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Self<'a>(self: Pin<&'a mut Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++                ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:42:9\n@@ -47,6 +71,12 @@ LL |     async fn box_box_ref_Self(self: Box<Box<&mut Self>>, f: &u32) -> &u32 {\n    |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Self<'a>(self: Box<Box<&'a mut Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++                 ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:48:9\n@@ -57,6 +87,12 @@ LL |     async fn box_pin_ref_Self(self: Box<Pin<&mut Self>>, f: &u32) -> &u32 {\n    |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_ref_Self<'a>(self: Box<Pin<&'a mut Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++                 ++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "9beafcd4ff994c3e000e13dfea4c475eaa474831", "filename": "src/test/ui/self/elision/ref-mut-self-async.nll.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.nll.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -7,6 +7,11 @@ LL |     async fn ref_self(&mut self, f: &u32) -> &u32 {\n    |                       let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_self<'a>(&'a mut self, f: &'a u32) -> &u32 {\n+   |                      ++++  ++               ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:24:9\n@@ -17,6 +22,11 @@ LL |     async fn ref_Self(self: &mut Self, f: &u32) -> &u32 {\n    |                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Self<'a>(self: &'a mut Self, f: &'a u32) -> &u32 {\n+   |                      ++++        ++               ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:30:9\n@@ -27,6 +37,11 @@ LL |     async fn box_ref_Self(self: Box<&mut Self>, f: &u32) -> &u32 {\n    |                                     let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Self<'a>(self: Box<&'a mut Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++                ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:36:9\n@@ -37,6 +52,11 @@ LL |     async fn pin_ref_Self(self: Pin<&mut Self>, f: &u32) -> &u32 {\n    |                                     let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Self<'a>(self: Pin<&'a mut Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++                ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:42:9\n@@ -47,6 +67,11 @@ LL |     async fn box_box_ref_Self(self: Box<Box<&mut Self>>, f: &u32) -> &u32 {\n    |                                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Self<'a>(self: Box<Box<&'a mut Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++                 ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:48:9\n@@ -57,6 +82,11 @@ LL |     async fn box_pin_ref_Self(self: Box<Pin<&mut Self>>, f: &u32) -> &u32 {\n    |                                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_ref_Self<'a>(self: Box<Pin<&'a mut Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++                 ++\n \n error: aborting due to 6 previous errors\n "}, {"sha": "fefb3fc1944393f057946d08ce43e43f72994e80", "filename": "src/test/ui/self/elision/ref-mut-struct-async.base.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.base.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -7,6 +7,12 @@ LL |     async fn ref_Struct(self: &mut Struct, f: &u32) -> &u32 {\n    |                                               this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Struct<'a>(self: &'a mut Struct, f: &'a u32) -> &u32 {\n+   |                        ++++        ++                 ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:22:9\n@@ -17,6 +23,12 @@ LL |     async fn box_ref_Struct(self: Box<&mut Struct>, f: &u32) -> &u32 {\n    |                                                        this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Struct<'a>(self: Box<&'a mut Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++                  ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:28:9\n@@ -27,6 +39,12 @@ LL |     async fn pin_ref_Struct(self: Pin<&mut Struct>, f: &u32) -> &u32 {\n    |                                                        this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Struct<'a>(self: Pin<&'a mut Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++                  ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:34:9\n@@ -37,6 +55,12 @@ LL |     async fn box_box_ref_Struct(self: Box<Box<&mut Struct>>, f: &u32) -> &u\n    |                                                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Struct<'a>(self: Box<Box<&'a mut Struct>>, f: &'a u32) -> &u32 {\n+   |                                ++++                ++                   ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:40:9\n@@ -47,6 +71,12 @@ LL |     async fn box_pin_ref_Struct(self: Box<Pin<&mut Struct>>, f: &u32) -> &u\n    |                                                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_ref_Struct<'a>(self: Box<Pin<&'a mut Struct>>, f: &'a u32) -> &u32 {\n+   |                                ++++                ++                   ++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "7fbecbe76a5485f1801321187082d8dbed49a8a5", "filename": "src/test/ui/self/elision/ref-mut-struct-async.nll.stderr", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.nll.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -7,6 +7,11 @@ LL |     async fn ref_Struct(self: &mut Struct, f: &u32) -> &u32 {\n    |                               let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Struct<'a>(self: &'a mut Struct, f: &'a u32) -> &u32 {\n+   |                        ++++        ++                 ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:22:9\n@@ -17,6 +22,11 @@ LL |     async fn box_ref_Struct(self: Box<&mut Struct>, f: &u32) -> &u32 {\n    |                                       let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Struct<'a>(self: Box<&'a mut Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++                  ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:28:9\n@@ -27,6 +37,11 @@ LL |     async fn pin_ref_Struct(self: Pin<&mut Struct>, f: &u32) -> &u32 {\n    |                                       let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Struct<'a>(self: Pin<&'a mut Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++                  ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:34:9\n@@ -37,6 +52,11 @@ LL |     async fn box_box_ref_Struct(self: Box<Box<&mut Struct>>, f: &u32) -> &u\n    |                                               let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Struct<'a>(self: Box<Box<&'a mut Struct>>, f: &'a u32) -> &u32 {\n+   |                                ++++                ++                   ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:40:9\n@@ -47,6 +67,11 @@ LL |     async fn box_pin_ref_Struct(self: Box<Pin<&mut Struct>>, f: &u32) -> &u\n    |                                               let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_ref_Struct<'a>(self: Box<Pin<&'a mut Struct>>, f: &'a u32) -> &u32 {\n+   |                                ++++                ++                   ++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "2b142b089d51b423e19457468791371a08fc5e86", "filename": "src/test/ui/self/elision/ref-self-async.base.stderr", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.base.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -7,6 +7,12 @@ LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n    |                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_self<'a>(&'a self, f: &'a u32) -> &u32 {\n+   |                      ++++  ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:34:9\n@@ -17,6 +23,12 @@ LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n    |                                       this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Self<'a>(self: &'a Self, f: &'a u32) -> &u32 {\n+   |                      ++++        ++           ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:40:9\n@@ -27,6 +39,12 @@ LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n    |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Self<'a>(self: Box<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:46:9\n@@ -37,6 +55,12 @@ LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n    |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Self<'a>(self: Pin<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:52:9\n@@ -47,6 +71,12 @@ LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n    |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Self<'a>(self: Box<Box<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++             ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:58:9\n@@ -57,6 +87,12 @@ LL |     async fn box_pin_ref_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n    |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_ref_Self<'a>(self: Box<Pin<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++             ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:64:9\n@@ -67,6 +103,12 @@ LL |     async fn wrap_ref_Self_Self(self: Wrap<&Self, Self>, f: &u8) -> &u8 {\n    |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn wrap_ref_Self_Self<'a>(self: Wrap<&'a Self, Self>, f: &'a u8) -> &u8 {\n+   |                                ++++             ++                  ++\n \n error: aborting due to 7 previous errors\n "}, {"sha": "f4e531a817c3d067a8acd0a00240164b3f0414e7", "filename": "src/test/ui/self/elision/ref-self-async.nll.stderr", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.nll.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -7,6 +7,11 @@ LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n    |                       let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_self<'a>(&'a self, f: &'a u32) -> &u32 {\n+   |                      ++++  ++           ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-self-async.rs:34:9\n@@ -17,6 +22,11 @@ LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n    |                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Self<'a>(self: &'a Self, f: &'a u32) -> &u32 {\n+   |                      ++++        ++           ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-self-async.rs:40:9\n@@ -27,6 +37,11 @@ LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n    |                                     let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Self<'a>(self: Box<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-self-async.rs:46:9\n@@ -37,6 +52,11 @@ LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n    |                                     let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Self<'a>(self: Pin<&'a Self>, f: &'a u32) -> &u32 {\n+   |                          ++++            ++            ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-self-async.rs:52:9\n@@ -47,6 +67,11 @@ LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n    |                                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Self<'a>(self: Box<Box<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++             ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-self-async.rs:58:9\n@@ -57,6 +82,11 @@ LL |     async fn box_pin_ref_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n    |                                             let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_ref_Self<'a>(self: Box<Pin<&'a Self>>, f: &'a u32) -> &u32 {\n+   |                              ++++                ++             ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-self-async.rs:64:9\n@@ -67,6 +97,11 @@ LL |     async fn wrap_ref_Self_Self(self: Wrap<&Self, Self>, f: &u8) -> &u8 {\n    |                                            let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn wrap_ref_Self_Self<'a>(self: Wrap<&'a Self, Self>, f: &'a u8) -> &u8 {\n+   |                                ++++             ++                  ++\n \n error: aborting due to 7 previous errors\n "}, {"sha": "88ddca89804f6833085f233684117a2cde1d009d", "filename": "src/test/ui/self/elision/ref-struct-async.base.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.base.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.base.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.base.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -7,6 +7,12 @@ LL |     async fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n    |                                           this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Struct<'a>(self: &'a Struct, f: &'a u32) -> &u32 {\n+   |                        ++++        ++             ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:22:9\n@@ -17,6 +23,12 @@ LL |     async fn box_ref_Struct(self: Box<&Struct>, f: &u32) -> &u32 {\n    |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Struct<'a>(self: Box<&'a Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++              ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:28:9\n@@ -27,6 +39,12 @@ LL |     async fn pin_ref_Struct(self: Pin<&Struct>, f: &u32) -> &u32 {\n    |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Struct<'a>(self: Pin<&'a Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++              ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:34:9\n@@ -37,6 +55,12 @@ LL |     async fn box_box_ref_Struct(self: Box<Box<&Struct>>, f: &u32) -> &u32 {\n    |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Struct<'a>(self: Box<Box<&'a Struct>>, f: &'a u32) -> &u32 {\n+   |                                ++++                ++               ++\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:40:9\n@@ -47,6 +71,12 @@ LL |     async fn box_pin_Struct(self: Box<Pin<&Struct>>, f: &u32) -> &u32 {\n    |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n    |         ^ ...but data from `f` is returned here\n+   |\n+   = note: each elided lifetime in input position becomes a distinct lifetime\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_Struct<'a>(self: Box<Pin<&'a Struct>>, f: &'a u32) -> &u32 {\n+   |                            ++++                ++               ++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "83c20329c3dad9601a736bf9069a5ac1fe4aa0fd", "filename": "src/test/ui/self/elision/ref-struct-async.nll.stderr", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c041f98fa121a5e8ae61f755ac3776565a7a595/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.nll.stderr?ref=5c041f98fa121a5e8ae61f755ac3776565a7a595", "patch": "@@ -7,6 +7,11 @@ LL |     async fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n    |                               let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn ref_Struct<'a>(self: &'a Struct, f: &'a u32) -> &u32 {\n+   |                        ++++        ++             ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:22:9\n@@ -17,6 +22,11 @@ LL |     async fn box_ref_Struct(self: Box<&Struct>, f: &u32) -> &u32 {\n    |                                       let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_ref_Struct<'a>(self: Box<&'a Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++              ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:28:9\n@@ -27,6 +37,11 @@ LL |     async fn pin_ref_Struct(self: Pin<&Struct>, f: &u32) -> &u32 {\n    |                                       let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn pin_ref_Struct<'a>(self: Pin<&'a Struct>, f: &'a u32) -> &u32 {\n+   |                            ++++            ++              ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:34:9\n@@ -37,6 +52,11 @@ LL |     async fn box_box_ref_Struct(self: Box<Box<&Struct>>, f: &u32) -> &u32 {\n    |                                               let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_box_ref_Struct<'a>(self: Box<Box<&'a Struct>>, f: &'a u32) -> &u32 {\n+   |                                ++++                ++               ++\n \n error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:40:9\n@@ -47,6 +67,11 @@ LL |     async fn box_pin_Struct(self: Box<Pin<&Struct>>, f: &u32) -> &u32 {\n    |                                           let's call the lifetime of this reference `'2`\n LL |         f\n    |         ^ associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n+   |\n+help: consider introducing a named lifetime parameter and update trait if needed\n+   |\n+LL |     async fn box_pin_Struct<'a>(self: Box<Pin<&'a Struct>>, f: &'a u32) -> &u32 {\n+   |                            ++++                ++               ++\n \n error: aborting due to 5 previous errors\n "}]}