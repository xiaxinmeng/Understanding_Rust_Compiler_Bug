{"sha": "e73077e10603b3586828f2d3d067f804c2fc0a1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MzA3N2UxMDYwM2IzNTg2ODI4ZjJkM2QwNjdmODA0YzJmYzBhMWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-23T02:54:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-23T02:54:24Z"}, "message": "Auto merge of #53520 - nnethercote:merge-IdxSet-IdxSetBuf, r=nikomatsakis\n\nMerge `IdxSet` and `IdxSetBuf`\n\nBecause it simplifies things.\n\n@r? nikomatsakis", "tree": {"sha": "9d65dd4a735a543507f8640063e2713523d33e2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d65dd4a735a543507f8640063e2713523d33e2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e73077e10603b3586828f2d3d067f804c2fc0a1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e73077e10603b3586828f2d3d067f804c2fc0a1f", "html_url": "https://github.com/rust-lang/rust/commit/e73077e10603b3586828f2d3d067f804c2fc0a1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e73077e10603b3586828f2d3d067f804c2fc0a1f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "917945d662c42053383fe3e71cb0f313d585e459", "url": "https://api.github.com/repos/rust-lang/rust/commits/917945d662c42053383fe3e71cb0f313d585e459", "html_url": "https://github.com/rust-lang/rust/commit/917945d662c42053383fe3e71cb0f313d585e459"}, {"sha": "e7e9f2e6997ae12573cf4726935f232bf13fb40b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7e9f2e6997ae12573cf4726935f232bf13fb40b", "html_url": "https://github.com/rust-lang/rust/commit/e7e9f2e6997ae12573cf4726935f232bf13fb40b"}], "stats": {"total": 352, "additions": 120, "deletions": 232}, "files": [{"sha": "6f61583e49b8e8f0d1e9250ed2b26fa8c729dce1", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=e73077e10603b3586828f2d3d067f804c2fc0a1f", "patch": "@@ -49,7 +49,7 @@ use util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n use util::common::{ErrorReported};\n use util::profiling::ProfileCategory::*;\n \n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc_target::spec::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -208,7 +208,7 @@ define_queries! { <'tcx>\n         /// Maps DefId's that have an associated Mir to the result\n         /// of the MIR qualify_consts pass. The actual meaning of\n         /// the value isn't known except to the pass itself.\n-        [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Lrc<IdxSetBuf<mir::Local>>),\n+        [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Lrc<IdxSet<mir::Local>>),\n \n         /// Fetch the MIR for a given def-id right after it's built - this includes\n         /// unreachable code."}, {"sha": "f21c898a28a340df42206d98ad594f4abea33aa3", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 59, "deletions": 145, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=e73077e10603b3586828f2d3d067f804c2fc0a1f", "patch": "@@ -9,100 +9,56 @@\n // except according to those terms.\n \n use array_vec::ArrayVec;\n-use std::borrow::{Borrow, BorrowMut, ToOwned};\n use std::fmt;\n use std::iter;\n use std::marker::PhantomData;\n use std::mem;\n-use std::ops::{Deref, DerefMut, Range};\n use std::slice;\n use bitslice::{BitSlice, Word};\n use bitslice::{bitwise, Union, Subtract, Intersect};\n use indexed_vec::Idx;\n use rustc_serialize;\n \n-/// Represents a set (or packed family of sets), of some element type\n-/// E, where each E is identified by some unique index type `T`.\n+/// Represents a set of some element type E, where each E is identified by some\n+/// unique index type `T`.\n ///\n /// In other words, `T` is the type used to index into the bitvector\n /// this type uses to represent the set of object it holds.\n ///\n /// The representation is dense, using one bit per possible element.\n #[derive(Eq, PartialEq)]\n-pub struct IdxSetBuf<T: Idx> {\n+pub struct IdxSet<T: Idx> {\n     _pd: PhantomData<fn(&T)>,\n     bits: Vec<Word>,\n }\n \n-impl<T: Idx> Clone for IdxSetBuf<T> {\n+impl<T: Idx> Clone for IdxSet<T> {\n     fn clone(&self) -> Self {\n-        IdxSetBuf { _pd: PhantomData, bits: self.bits.clone() }\n+        IdxSet { _pd: PhantomData, bits: self.bits.clone() }\n     }\n }\n \n-impl<T: Idx> rustc_serialize::Encodable for IdxSetBuf<T> {\n+impl<T: Idx> rustc_serialize::Encodable for IdxSet<T> {\n     fn encode<E: rustc_serialize::Encoder>(&self,\n                                      encoder: &mut E)\n                                      -> Result<(), E::Error> {\n         self.bits.encode(encoder)\n     }\n }\n \n-impl<T: Idx> rustc_serialize::Decodable for IdxSetBuf<T> {\n-    fn decode<D: rustc_serialize::Decoder>(d: &mut D) -> Result<IdxSetBuf<T>, D::Error> {\n+impl<T: Idx> rustc_serialize::Decodable for IdxSet<T> {\n+    fn decode<D: rustc_serialize::Decoder>(d: &mut D) -> Result<IdxSet<T>, D::Error> {\n         let words: Vec<Word> = rustc_serialize::Decodable::decode(d)?;\n \n-        Ok(IdxSetBuf {\n+        Ok(IdxSet {\n             _pd: PhantomData,\n             bits: words,\n         })\n     }\n }\n \n-\n-// pnkfelix wants to have this be `IdxSet<T>([Word]) and then pass\n-// around `&mut IdxSet<T>` or `&IdxSet<T>`.\n-\n-/// Represents a set (or packed family of sets), of some element type\n-/// E, where each E is identified by some unique index type `T`.\n-///\n-/// In other words, `T` is the type used to index into the bitslice\n-/// this type uses to represent the set of object it holds.\n-#[repr(transparent)]\n-pub struct IdxSet<T: Idx> {\n-    _pd: PhantomData<fn(&T)>,\n-    bits: [Word],\n-}\n-\n-impl<T: Idx> Borrow<IdxSet<T>> for IdxSetBuf<T> {\n-    fn borrow(&self) -> &IdxSet<T> {\n-        &*self\n-    }\n-}\n-\n-impl<T: Idx> BorrowMut<IdxSet<T>> for IdxSetBuf<T> {\n-    fn borrow_mut(&mut self) -> &mut IdxSet<T> {\n-        &mut *self\n-    }\n-}\n-\n-impl<T: Idx> ToOwned for IdxSet<T> {\n-    type Owned = IdxSetBuf<T>;\n-    fn to_owned(&self) -> Self::Owned {\n-        IdxSet::to_owned(self)\n-    }\n-}\n-\n const BITS_PER_WORD: usize = mem::size_of::<Word>() * 8;\n \n-impl<T: Idx> fmt::Debug for IdxSetBuf<T> {\n-    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n-        w.debug_list()\n-         .entries(self.iter())\n-         .finish()\n-    }\n-}\n-\n impl<T: Idx> fmt::Debug for IdxSet<T> {\n     fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n         w.debug_list()\n@@ -111,10 +67,10 @@ impl<T: Idx> fmt::Debug for IdxSet<T> {\n     }\n }\n \n-impl<T: Idx> IdxSetBuf<T> {\n+impl<T: Idx> IdxSet<T> {\n     fn new(init: Word, universe_size: usize) -> Self {\n         let num_words = (universe_size + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n-        IdxSetBuf {\n+        IdxSet {\n             _pd: Default::default(),\n             bits: vec![init; num_words],\n         }\n@@ -131,47 +87,15 @@ impl<T: Idx> IdxSetBuf<T> {\n     pub fn new_empty(universe_size: usize) -> Self {\n         Self::new(0, universe_size)\n     }\n-}\n-\n-impl<T: Idx> IdxSet<T> {\n-    unsafe fn from_slice(s: &[Word]) -> &Self {\n-        &*(s as *const [Word] as *const Self)\n-    }\n-\n-    unsafe fn from_slice_mut(s: &mut [Word]) -> &mut Self {\n-        &mut *(s as *mut [Word] as *mut Self)\n-    }\n-}\n-\n-impl<T: Idx> Deref for IdxSetBuf<T> {\n-    type Target = IdxSet<T>;\n-    fn deref(&self) -> &IdxSet<T> {\n-        unsafe { IdxSet::from_slice(&self.bits) }\n-    }\n-}\n-\n-impl<T: Idx> DerefMut for IdxSetBuf<T> {\n-    fn deref_mut(&mut self) -> &mut IdxSet<T> {\n-        unsafe { IdxSet::from_slice_mut(&mut self.bits) }\n-    }\n-}\n-\n-impl<T: Idx> IdxSet<T> {\n-    pub fn to_owned(&self) -> IdxSetBuf<T> {\n-        IdxSetBuf {\n-            _pd: Default::default(),\n-            bits: self.bits.to_owned(),\n-        }\n-    }\n \n     /// Duplicates as a hybrid set.\n-    pub fn to_hybrid(&self) -> HybridIdxSetBuf<T> {\n+    pub fn to_hybrid(&self) -> HybridIdxSet<T> {\n         // This universe_size may be slightly larger than the one specified\n         // upon creation, due to rounding up to a whole word. That's ok.\n         let universe_size = self.bits.len() * BITS_PER_WORD;\n \n         // Note: we currently don't bother trying to make a Sparse set.\n-        HybridIdxSetBuf::Dense(self.to_owned(), universe_size)\n+        HybridIdxSet::Dense(self.to_owned(), universe_size)\n     }\n \n     /// Removes all elements\n@@ -219,16 +143,6 @@ impl<T: Idx> IdxSet<T> {\n         self.bits.set_bit(elem.index())\n     }\n \n-    pub fn range(&self, elems: &Range<T>) -> &Self {\n-        let elems = elems.start.index()..elems.end.index();\n-        unsafe { Self::from_slice(&self.bits[elems]) }\n-    }\n-\n-    pub fn range_mut(&mut self, elems: &Range<T>) -> &mut Self {\n-        let elems = elems.start.index()..elems.end.index();\n-        unsafe { Self::from_slice_mut(&mut self.bits[elems]) }\n-    }\n-\n     /// Returns true iff set `self` contains `elem`.\n     pub fn contains(&self, elem: &T) -> bool {\n         self.bits.get_bit(elem.index())\n@@ -254,20 +168,20 @@ impl<T: Idx> IdxSet<T> {\n         bitwise(self.words_mut(), other.words(), &Union)\n     }\n \n-    /// Like `union()`, but takes a `SparseIdxSetBuf` argument.\n-    fn union_sparse(&mut self, other: &SparseIdxSetBuf<T>) -> bool {\n+    /// Like `union()`, but takes a `SparseIdxSet` argument.\n+    fn union_sparse(&mut self, other: &SparseIdxSet<T>) -> bool {\n         let mut changed = false;\n         for elem in other.iter() {\n             changed |= self.add(&elem);\n         }\n         changed\n     }\n \n-    /// Like `union()`, but takes a `HybridIdxSetBuf` argument.\n-    pub fn union_hybrid(&mut self, other: &HybridIdxSetBuf<T>) -> bool {\n+    /// Like `union()`, but takes a `HybridIdxSet` argument.\n+    pub fn union_hybrid(&mut self, other: &HybridIdxSet<T>) -> bool {\n         match other {\n-            HybridIdxSetBuf::Sparse(sparse, _) => self.union_sparse(sparse),\n-            HybridIdxSetBuf::Dense(dense, _) => self.union(dense),\n+            HybridIdxSet::Sparse(sparse, _) => self.union_sparse(sparse),\n+            HybridIdxSet::Dense(dense, _) => self.union(dense),\n         }\n     }\n \n@@ -277,20 +191,20 @@ impl<T: Idx> IdxSet<T> {\n         bitwise(self.words_mut(), other.words(), &Subtract)\n     }\n \n-    /// Like `subtract()`, but takes a `SparseIdxSetBuf` argument.\n-    fn subtract_sparse(&mut self, other: &SparseIdxSetBuf<T>) -> bool {\n+    /// Like `subtract()`, but takes a `SparseIdxSet` argument.\n+    fn subtract_sparse(&mut self, other: &SparseIdxSet<T>) -> bool {\n         let mut changed = false;\n         for elem in other.iter() {\n             changed |= self.remove(&elem);\n         }\n         changed\n     }\n \n-    /// Like `subtract()`, but takes a `HybridIdxSetBuf` argument.\n-    pub fn subtract_hybrid(&mut self, other: &HybridIdxSetBuf<T>) -> bool {\n+    /// Like `subtract()`, but takes a `HybridIdxSet` argument.\n+    pub fn subtract_hybrid(&mut self, other: &HybridIdxSet<T>) -> bool {\n         match other {\n-            HybridIdxSetBuf::Sparse(sparse, _) => self.subtract_sparse(sparse),\n-            HybridIdxSetBuf::Dense(dense, _) => self.subtract(dense),\n+            HybridIdxSet::Sparse(sparse, _) => self.subtract_sparse(sparse),\n+            HybridIdxSet::Dense(dense, _) => self.subtract(dense),\n         }\n     }\n \n@@ -338,15 +252,15 @@ impl<'a, T: Idx> Iterator for Iter<'a, T> {\n const SPARSE_MAX: usize = 8;\n \n /// A sparse index set with a maximum of SPARSE_MAX elements. Used by\n-/// HybridIdxSetBuf; do not use directly.\n+/// HybridIdxSet; do not use directly.\n ///\n /// The elements are stored as an unsorted vector with no duplicates.\n #[derive(Clone, Debug)]\n-pub struct SparseIdxSetBuf<T: Idx>(ArrayVec<[T; SPARSE_MAX]>);\n+pub struct SparseIdxSet<T: Idx>(ArrayVec<[T; SPARSE_MAX]>);\n \n-impl<T: Idx> SparseIdxSetBuf<T> {\n+impl<T: Idx> SparseIdxSet<T> {\n     fn new() -> Self {\n-        SparseIdxSetBuf(ArrayVec::new())\n+        SparseIdxSet(ArrayVec::new())\n     }\n \n     fn len(&self) -> usize {\n@@ -379,8 +293,8 @@ impl<T: Idx> SparseIdxSetBuf<T> {\n         }\n     }\n \n-    fn to_dense(&self, universe_size: usize) -> IdxSetBuf<T> {\n-        let mut dense = IdxSetBuf::new_empty(universe_size);\n+    fn to_dense(&self, universe_size: usize) -> IdxSet<T> {\n+        let mut dense = IdxSet::new_empty(universe_size);\n         for elem in self.0.iter() {\n             dense.add(elem);\n         }\n@@ -406,97 +320,97 @@ impl<'a, T: Idx> Iterator for SparseIter<'a, T> {\n     }\n }\n \n-/// Like IdxSetBuf, but with a hybrid representation: sparse when there are few\n+/// Like IdxSet, but with a hybrid representation: sparse when there are few\n /// elements in the set, but dense when there are many. It's especially\n /// efficient for sets that typically have a small number of elements, but a\n /// large `universe_size`, and are cleared frequently.\n #[derive(Clone, Debug)]\n-pub enum HybridIdxSetBuf<T: Idx> {\n-    Sparse(SparseIdxSetBuf<T>, usize),\n-    Dense(IdxSetBuf<T>, usize),\n+pub enum HybridIdxSet<T: Idx> {\n+    Sparse(SparseIdxSet<T>, usize),\n+    Dense(IdxSet<T>, usize),\n }\n \n-impl<T: Idx> HybridIdxSetBuf<T> {\n+impl<T: Idx> HybridIdxSet<T> {\n     pub fn new_empty(universe_size: usize) -> Self {\n-        HybridIdxSetBuf::Sparse(SparseIdxSetBuf::new(), universe_size)\n+        HybridIdxSet::Sparse(SparseIdxSet::new(), universe_size)\n     }\n \n     fn universe_size(&mut self) -> usize {\n         match *self {\n-            HybridIdxSetBuf::Sparse(_, size) => size,\n-            HybridIdxSetBuf::Dense(_, size) => size,\n+            HybridIdxSet::Sparse(_, size) => size,\n+            HybridIdxSet::Dense(_, size) => size,\n         }\n     }\n \n     pub fn clear(&mut self) {\n         let universe_size = self.universe_size();\n-        *self = HybridIdxSetBuf::new_empty(universe_size);\n+        *self = HybridIdxSet::new_empty(universe_size);\n     }\n \n     /// Returns true iff set `self` contains `elem`.\n     pub fn contains(&self, elem: &T) -> bool {\n         match self {\n-            HybridIdxSetBuf::Sparse(sparse, _) => sparse.contains(elem),\n-            HybridIdxSetBuf::Dense(dense, _) => dense.contains(elem),\n+            HybridIdxSet::Sparse(sparse, _) => sparse.contains(elem),\n+            HybridIdxSet::Dense(dense, _) => dense.contains(elem),\n         }\n     }\n \n     /// Adds `elem` to the set `self`.\n     pub fn add(&mut self, elem: &T) -> bool {\n         match self {\n-            HybridIdxSetBuf::Sparse(sparse, _) if sparse.len() < SPARSE_MAX => {\n+            HybridIdxSet::Sparse(sparse, _) if sparse.len() < SPARSE_MAX => {\n                 // The set is sparse and has space for `elem`.\n                 sparse.add(elem)\n             }\n-            HybridIdxSetBuf::Sparse(sparse, _) if sparse.contains(elem) => {\n+            HybridIdxSet::Sparse(sparse, _) if sparse.contains(elem) => {\n                 // The set is sparse and does not have space for `elem`, but\n                 // that doesn't matter because `elem` is already present.\n                 false\n             }\n-            HybridIdxSetBuf::Sparse(_, _) => {\n+            HybridIdxSet::Sparse(_, _) => {\n                 // The set is sparse and full. Convert to a dense set.\n                 //\n                 // FIXME: This code is awful, but I can't work out how else to\n                 //        appease the borrow checker.\n-                let dummy = HybridIdxSetBuf::Sparse(SparseIdxSetBuf::new(), 0);\n+                let dummy = HybridIdxSet::Sparse(SparseIdxSet::new(), 0);\n                 match mem::replace(self, dummy) {\n-                    HybridIdxSetBuf::Sparse(sparse, universe_size) => {\n+                    HybridIdxSet::Sparse(sparse, universe_size) => {\n                         let mut dense = sparse.to_dense(universe_size);\n                         let changed = dense.add(elem);\n                         assert!(changed);\n-                        mem::replace(self, HybridIdxSetBuf::Dense(dense, universe_size));\n+                        mem::replace(self, HybridIdxSet::Dense(dense, universe_size));\n                         changed\n                     }\n                     _ => panic!(\"impossible\"),\n                 }\n             }\n \n-            HybridIdxSetBuf::Dense(dense, _) => dense.add(elem),\n+            HybridIdxSet::Dense(dense, _) => dense.add(elem),\n         }\n     }\n \n     /// Removes `elem` from the set `self`.\n     pub fn remove(&mut self, elem: &T) -> bool {\n         // Note: we currently don't bother going from Dense back to Sparse.\n         match self {\n-            HybridIdxSetBuf::Sparse(sparse, _) => sparse.remove(elem),\n-            HybridIdxSetBuf::Dense(dense, _) => dense.remove(elem),\n+            HybridIdxSet::Sparse(sparse, _) => sparse.remove(elem),\n+            HybridIdxSet::Dense(dense, _) => dense.remove(elem),\n         }\n     }\n \n     /// Converts to a dense set, consuming itself in the process.\n-    pub fn to_dense(self) -> IdxSetBuf<T> {\n+    pub fn to_dense(self) -> IdxSet<T> {\n         match self {\n-            HybridIdxSetBuf::Sparse(sparse, universe_size) => sparse.to_dense(universe_size),\n-            HybridIdxSetBuf::Dense(dense, _) => dense,\n+            HybridIdxSet::Sparse(sparse, universe_size) => sparse.to_dense(universe_size),\n+            HybridIdxSet::Dense(dense, _) => dense,\n         }\n     }\n \n     /// Iteration order is unspecified.\n     pub fn iter(&self) -> HybridIter<T> {\n         match self {\n-            HybridIdxSetBuf::Sparse(sparse, _) => HybridIter::Sparse(sparse.iter()),\n-            HybridIdxSetBuf::Dense(dense, _) => HybridIter::Dense(dense.iter()),\n+            HybridIdxSet::Sparse(sparse, _) => HybridIter::Sparse(sparse.iter()),\n+            HybridIdxSet::Dense(dense, _) => HybridIter::Dense(dense.iter()),\n         }\n     }\n }\n@@ -522,7 +436,7 @@ fn test_trim_to() {\n     use std::cmp;\n \n     for i in 0..256 {\n-        let mut idx_buf: IdxSetBuf<usize> = IdxSetBuf::new_filled(128);\n+        let mut idx_buf: IdxSet<usize> = IdxSet::new_filled(128);\n         idx_buf.trim_to(i);\n \n         let elems: Vec<usize> = idx_buf.iter().collect();\n@@ -535,7 +449,7 @@ fn test_trim_to() {\n fn test_set_up_to() {\n     for i in 0..128 {\n         for mut idx_buf in\n-            vec![IdxSetBuf::new_empty(128), IdxSetBuf::new_filled(128)]\n+            vec![IdxSet::new_empty(128), IdxSet::new_filled(128)]\n             .into_iter()\n         {\n             idx_buf.set_up_to(i);\n@@ -550,7 +464,7 @@ fn test_set_up_to() {\n #[test]\n fn test_new_filled() {\n     for i in 0..128 {\n-        let idx_buf = IdxSetBuf::new_filled(i);\n+        let idx_buf = IdxSet::new_filled(i);\n         let elems: Vec<usize> = idx_buf.iter().collect();\n         let expected: Vec<usize> = (0..i).collect();\n         assert_eq!(elems, expected);"}, {"sha": "1024e69cc2b0e889b67d74b35ad75fbfba58240e", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=e73077e10603b3586828f2d3d067f804c2fc0a1f", "patch": "@@ -432,7 +432,7 @@ impl<I: ::indexed_vec::Idx, T, CTX> HashStable<CTX> for ::indexed_vec::IndexVec<\n }\n \n \n-impl<I: ::indexed_vec::Idx, CTX> HashStable<CTX> for ::indexed_set::IdxSetBuf<I>\n+impl<I: ::indexed_vec::Idx, CTX> HashStable<CTX> for ::indexed_set::IdxSet<I>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,"}, {"sha": "0c8ec753a18f6e6e126e7d263d4fce910c7c5506", "filename": "src/librustc_data_structures/work_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_data_structures%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_data_structures%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fwork_queue.rs?ref=e73077e10603b3586828f2d3d067f804c2fc0a1f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use indexed_set::IdxSetBuf;\n+use indexed_set::IdxSet;\n use indexed_vec::Idx;\n use std::collections::VecDeque;\n \n@@ -20,7 +20,7 @@ use std::collections::VecDeque;\n /// and also use a bit set to track occupancy.\n pub struct WorkQueue<T: Idx> {\n     deque: VecDeque<T>,\n-    set: IdxSetBuf<T>,\n+    set: IdxSet<T>,\n }\n \n impl<T: Idx> WorkQueue<T> {\n@@ -29,7 +29,7 @@ impl<T: Idx> WorkQueue<T> {\n     pub fn with_all(len: usize) -> Self {\n         WorkQueue {\n             deque: (0..len).map(T::new).collect(),\n-            set: IdxSetBuf::new_filled(len),\n+            set: IdxSet::new_filled(len),\n         }\n     }\n \n@@ -38,7 +38,7 @@ impl<T: Idx> WorkQueue<T> {\n     pub fn with_none(len: usize) -> Self {\n         WorkQueue {\n             deque: VecDeque::with_capacity(len),\n-            set: IdxSetBuf::new_empty(len),\n+            set: IdxSet::new_empty(len),\n         }\n     }\n "}, {"sha": "5aa05270a2a0ba8d674c7d22571881d780809643", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e73077e10603b3586828f2d3d067f804c2fc0a1f", "patch": "@@ -42,7 +42,7 @@ use syntax::edition::Edition;\n use syntax::parse::source_file_to_stream;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc::hir;\n \n macro_rules! provide {\n@@ -141,7 +141,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         mir\n     }\n     mir_const_qualif => {\n-        (cdata.mir_const_qualif(def_id.index), Lrc::new(IdxSetBuf::new_empty(0)))\n+        (cdata.mir_const_qualif(def_id.index), Lrc::new(IdxSet::new_empty(0)))\n     }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { Lrc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }"}, {"sha": "f96f612734904ce5c01a38be71e0bbfecc34660b", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=e73077e10603b3586828f2d3d067f804c2fc0a1f", "patch": "@@ -27,7 +27,7 @@ use rustc::ty::{self, ParamEnv, TyCtxt, Ty};\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, Level};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::small_vec::SmallVec;\n \n@@ -166,7 +166,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         _ => Some(tcx.hir.body_owned_by(id)),\n     };\n \n-    let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+    let dead_unwinds = IdxSet::new_empty(mir.basic_blocks().len());\n     let mut flow_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,"}, {"sha": "ff68b5987e85a21d2ec9072e21c4dbb99f5a8b61", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=e73077e10603b3586828f2d3d067f804c2fc0a1f", "patch": "@@ -27,7 +27,7 @@ use rustc::mir::{\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common;\n use rustc_data_structures::graph::scc::Sccs;\n-use rustc_data_structures::indexed_set::{IdxSet, IdxSetBuf};\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::Diagnostic;\n \n@@ -468,7 +468,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // SCC. For each SCC, we visit its successors and compute\n         // their values, then we union all those values to get our\n         // own.\n-        let visited = &mut IdxSetBuf::new_empty(self.constraint_sccs.num_sccs());\n+        let visited = &mut IdxSet::new_empty(self.constraint_sccs.num_sccs());\n         for scc_index in self.constraint_sccs.all_sccs() {\n             self.propagate_constraint_sccs_if_new(scc_index, visited);\n         }"}, {"sha": "0dfc5b5b4b7e0cabd51c2845010c022b9e834c0f", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=e73077e10603b3586828f2d3d067f804c2fc0a1f", "patch": "@@ -12,7 +12,7 @@\n //! locations.\n \n use rustc::mir::{BasicBlock, Location};\n-use rustc_data_structures::indexed_set::{HybridIdxSetBuf, IdxSetBuf, Iter};\n+use rustc_data_structures::indexed_set::{HybridIdxSet, IdxSet, Iter};\n use rustc_data_structures::indexed_vec::Idx;\n \n use dataflow::{BitDenotation, BlockSets, DataflowResults};\n@@ -67,9 +67,9 @@ where\n     BD: BitDenotation,\n {\n     base_results: DataflowResults<BD>,\n-    curr_state: IdxSetBuf<BD::Idx>,\n-    stmt_gen: HybridIdxSetBuf<BD::Idx>,\n-    stmt_kill: HybridIdxSetBuf<BD::Idx>,\n+    curr_state: IdxSet<BD::Idx>,\n+    stmt_gen: HybridIdxSet<BD::Idx>,\n+    stmt_kill: HybridIdxSet<BD::Idx>,\n }\n \n impl<BD> FlowAtLocation<BD>\n@@ -96,9 +96,9 @@ where\n \n     pub fn new(results: DataflowResults<BD>) -> Self {\n         let bits_per_block = results.sets().bits_per_block();\n-        let curr_state = IdxSetBuf::new_empty(bits_per_block);\n-        let stmt_gen = HybridIdxSetBuf::new_empty(bits_per_block);\n-        let stmt_kill = HybridIdxSetBuf::new_empty(bits_per_block);\n+        let curr_state = IdxSet::new_empty(bits_per_block);\n+        let stmt_gen = HybridIdxSet::new_empty(bits_per_block);\n+        let stmt_kill = HybridIdxSet::new_empty(bits_per_block);\n         FlowAtLocation {\n             base_results: results,\n             curr_state: curr_state,"}, {"sha": "598e827b2564ea13dda1137162bb060124929fd8", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 23, "deletions": 49, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=e73077e10603b3586828f2d3d067f804c2fc0a1f", "patch": "@@ -10,8 +10,8 @@\n \n use syntax::ast::{self, MetaItem};\n \n-use rustc_data_structures::bitslice::{bitwise, BitwiseOperator, Word};\n-use rustc_data_structures::indexed_set::{HybridIdxSetBuf, IdxSet, IdxSetBuf};\n+use rustc_data_structures::bitslice::{bitwise, BitwiseOperator};\n+use rustc_data_structures::indexed_set::{HybridIdxSet, IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::work_queue::WorkQueue;\n \n@@ -23,7 +23,6 @@ use rustc::session::Session;\n use std::borrow::Borrow;\n use std::fmt;\n use std::io;\n-use std::mem;\n use std::path::PathBuf;\n use std::usize;\n \n@@ -183,7 +182,7 @@ struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O> where O: 'b + BitDenotation\n impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n {\n     fn propagate(&mut self) {\n-        let mut temp = IdxSetBuf::new_empty(self.flow_state.sets.bits_per_block);\n+        let mut temp = IdxSet::new_empty(self.flow_state.sets.bits_per_block);\n         let mut propcx = PropagationContext {\n             builder: self,\n         };\n@@ -287,18 +286,6 @@ impl<'a, 'tcx: 'a, BD> DataflowBuilder<'a, 'tcx, BD> where BD: BitDenotation\n     }\n }\n \n-/// Maps each block to a set of bits\n-#[derive(Clone, Debug)]\n-pub(crate) struct Bits<E:Idx> {\n-    bits: IdxSetBuf<E>,\n-}\n-\n-impl<E:Idx> Bits<E> {\n-    fn new(bits: IdxSetBuf<E>) -> Self {\n-        Bits { bits: bits }\n-    }\n-}\n-\n /// DataflowResultsConsumer abstracts over walking the MIR with some\n /// already constructed dataflow results.\n ///\n@@ -366,7 +353,7 @@ pub fn state_for_location<'tcx, T: BitDenotation>(loc: Location,\n                                                   analysis: &T,\n                                                   result: &DataflowResults<T>,\n                                                   mir: &Mir<'tcx>)\n-    -> IdxSetBuf<T::Idx> {\n+    -> IdxSet<T::Idx> {\n     let mut on_entry = result.sets().on_entry_set_for(loc.block.index()).to_owned();\n     let mut kill_set = on_entry.to_hybrid();\n     let mut gen_set = kill_set.clone();\n@@ -450,7 +437,7 @@ impl<O: BitDenotation> DataflowState<O> {\n \n     pub(crate) fn interpret_hybrid_set<'c, P>(&self,\n                                               o: &'c O,\n-                                              set: &HybridIdxSetBuf<O::Idx>,\n+                                              set: &HybridIdxSet<O::Idx>,\n                                               render_idx: &P)\n                                               -> Vec<DebugFormatted>\n         where P: Fn(&O, O::Idx) -> DebugFormatted\n@@ -464,22 +451,18 @@ pub struct AllSets<E: Idx> {\n     /// Analysis bitwidth for each block.\n     bits_per_block: usize,\n \n-    /// Number of words associated with each block entry\n-    /// equal to bits_per_block / (mem::size_of::<Word> * 8), rounded up.\n-    words_per_block: usize,\n-\n     /// For each block, bits valid on entry to the block.\n-    on_entry_sets: Bits<E>,\n+    on_entry_sets: Vec<IdxSet<E>>,\n \n     /// For each block, bits generated by executing the statements in\n     /// the block. (For comparison, the Terminator for each block is\n     /// handled in a flow-specific manner during propagation.)\n-    gen_sets: Vec<HybridIdxSetBuf<E>>,\n+    gen_sets: Vec<HybridIdxSet<E>>,\n \n     /// For each block, bits killed by executing the statements in the\n     /// block. (For comparison, the Terminator for each block is\n     /// handled in a flow-specific manner during propagation.)\n-    kill_sets: Vec<HybridIdxSetBuf<E>>,\n+    kill_sets: Vec<HybridIdxSet<E>>,\n }\n \n /// Triple of sets associated with a given block.\n@@ -503,11 +486,11 @@ pub struct BlockSets<'a, E: Idx> {\n \n     /// Bits that are set to 1 by the time we exit the given block. Hybrid\n     /// because it usually contains only 0 or 1 elements.\n-    pub(crate) gen_set: &'a mut HybridIdxSetBuf<E>,\n+    pub(crate) gen_set: &'a mut HybridIdxSet<E>,\n \n     /// Bits that are set to 0 by the time we exit the given block. Hybrid\n     /// because it usually contains only 0 or 1 elements.\n-    pub(crate) kill_set: &'a mut HybridIdxSetBuf<E>,\n+    pub(crate) kill_set: &'a mut HybridIdxSet<E>,\n }\n \n impl<'a, E:Idx> BlockSets<'a, E> {\n@@ -559,24 +542,20 @@ impl<'a, E:Idx> BlockSets<'a, E> {\n impl<E:Idx> AllSets<E> {\n     pub fn bits_per_block(&self) -> usize { self.bits_per_block }\n     pub fn for_block(&mut self, block_idx: usize) -> BlockSets<E> {\n-        let offset = self.words_per_block * block_idx;\n-        let range = E::new(offset)..E::new(offset + self.words_per_block);\n         BlockSets {\n-            on_entry: self.on_entry_sets.bits.range_mut(&range),\n+            on_entry: &mut self.on_entry_sets[block_idx],\n             gen_set: &mut self.gen_sets[block_idx],\n             kill_set: &mut self.kill_sets[block_idx],\n         }\n     }\n \n     pub fn on_entry_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n-        let offset = self.words_per_block * block_idx;\n-        let range = E::new(offset)..E::new(offset + self.words_per_block);\n-        self.on_entry_sets.bits.range(&range)\n+        &self.on_entry_sets[block_idx]\n     }\n-    pub fn gen_set_for(&self, block_idx: usize) -> &HybridIdxSetBuf<E> {\n+    pub fn gen_set_for(&self, block_idx: usize) -> &HybridIdxSet<E> {\n         &self.gen_sets[block_idx]\n     }\n-    pub fn kill_set_for(&self, block_idx: usize) -> &HybridIdxSetBuf<E> {\n+    pub fn kill_set_for(&self, block_idx: usize) -> &HybridIdxSet<E> {\n         &self.kill_sets[block_idx]\n     }\n }\n@@ -731,29 +710,25 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n                dead_unwinds: &'a IdxSet<mir::BasicBlock>,\n                denotation: D) -> Self where D: InitialFlow {\n         let bits_per_block = denotation.bits_per_block();\n-        let bits_per_word = mem::size_of::<Word>() * 8;\n-        let words_per_block = (bits_per_block + bits_per_word - 1) / bits_per_word;\n-        let bits_per_block_rounded_up = words_per_block * bits_per_word; // a multiple of word size\n         let num_blocks = mir.basic_blocks().len();\n-        let num_overall = num_blocks * bits_per_block_rounded_up;\n \n-        let on_entry = Bits::new(if D::bottom_value() {\n-            IdxSetBuf::new_filled(num_overall)\n+        let on_entry_sets = if D::bottom_value() {\n+            vec![IdxSet::new_filled(bits_per_block); num_blocks]\n         } else {\n-            IdxSetBuf::new_empty(num_overall)\n-        });\n-        let empties = vec![HybridIdxSetBuf::new_empty(bits_per_block); num_blocks];\n+            vec![IdxSet::new_empty(bits_per_block); num_blocks]\n+        };\n+        let gen_sets = vec![HybridIdxSet::new_empty(bits_per_block); num_blocks];\n+        let kill_sets = gen_sets.clone();\n \n         DataflowAnalysis {\n             mir,\n             dead_unwinds,\n             flow_state: DataflowState {\n                 sets: AllSets {\n                     bits_per_block,\n-                    words_per_block,\n-                    on_entry_sets: on_entry,\n-                    gen_sets: empties.clone(),\n-                    kill_sets: empties,\n+                    on_entry_sets,\n+                    gen_sets,\n+                    kill_sets,\n                 },\n                 operator: denotation,\n             }\n@@ -873,5 +848,4 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n             dirty_queue.insert(bb);\n         }\n     }\n-\n }"}, {"sha": "bbf896e624f205cd23ea692997ce2d13f5c57d92", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=e73077e10603b3586828f2d3d067f804c2fc0a1f", "patch": "@@ -18,7 +18,7 @@ use dataflow::{self, do_dataflow, DebugFormatted};\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::Idx;\n use transform::{MirPass, MirSource};\n use util::patch::MirPatch;\n@@ -93,12 +93,12 @@ fn find_dead_unwinds<'a, 'tcx>(\n     mir: &Mir<'tcx>,\n     id: ast::NodeId,\n     env: &MoveDataParamEnv<'tcx, 'tcx>)\n-    -> IdxSetBuf<BasicBlock>\n+    -> IdxSet<BasicBlock>\n {\n     debug!(\"find_dead_unwinds({:?})\", mir.span);\n     // We only need to do this pass once, because unwind edges can only\n     // reach cleanup blocks, which can't have unwind edges themselves.\n-    let mut dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+    let mut dead_unwinds = IdxSet::new_empty(mir.basic_blocks().len());\n     let flow_inits =\n         do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n                     MaybeInitializedPlaces::new(tcx, mir, &env),\n@@ -112,7 +112,7 @@ fn find_dead_unwinds<'a, 'tcx>(\n \n         let mut init_data = InitializationData {\n             live: flow_inits.sets().on_entry_set_for(bb.index()).to_owned(),\n-            dead: IdxSetBuf::new_empty(env.move_data.move_paths.len()),\n+            dead: IdxSet::new_empty(env.move_data.move_paths.len()),\n         };\n         debug!(\"find_dead_unwinds @ {:?}: {:?}; init_data={:?}\",\n                bb, bb_data, init_data.live);\n@@ -147,8 +147,8 @@ fn find_dead_unwinds<'a, 'tcx>(\n }\n \n struct InitializationData {\n-    live: IdxSetBuf<MovePathIndex>,\n-    dead: IdxSetBuf<MovePathIndex>\n+    live: IdxSet<MovePathIndex>,\n+    dead: IdxSet<MovePathIndex>\n }\n \n impl InitializationData {"}, {"sha": "dc657f228c9fc9d8878dbac2e55b4c458f70819f", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=e73077e10603b3586828f2d3d067f804c2fc0a1f", "patch": "@@ -68,7 +68,7 @@ use rustc::ty::subst::Substs;\n use util::dump_mir;\n use util::liveness::{self, IdentityMap, LivenessMode};\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use std::collections::HashMap;\n use std::borrow::Cow;\n use std::iter::once;\n@@ -369,7 +369,7 @@ fn locals_live_across_suspend_points<'a, 'tcx,>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                movable: bool) ->\n                                                (liveness::LiveVarSet<Local>,\n                                                 HashMap<BasicBlock, liveness::LiveVarSet<Local>>) {\n-    let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+    let dead_unwinds = IdxSet::new_empty(mir.basic_blocks().len());\n     let node_id = tcx.hir.as_local_node_id(source.def_id).unwrap();\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n@@ -381,7 +381,7 @@ fn locals_live_across_suspend_points<'a, 'tcx,>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Find the MIR locals which do not use StorageLive/StorageDead statements.\n     // The storage of these locals are always live.\n-    let mut ignored = StorageIgnored(IdxSetBuf::new_filled(mir.local_decls.len()));\n+    let mut ignored = StorageIgnored(IdxSet::new_filled(mir.local_decls.len()));\n     ignored.visit_mir(mir);\n \n     // Calculate the MIR locals which have been previously"}, {"sha": "7582792b10d98396b1c1dbcafdf1ccc0ea1af541", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=e73077e10603b3586828f2d3d067f804c2fc0a1f", "patch": "@@ -15,7 +15,7 @@\n //! diagnostics as to why a constant rvalue wasn't promoted.\n \n use rustc_data_structures::bitvec::BitArray;\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::fx::FxHashSet;\n use rustc::hir;\n@@ -279,7 +279,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     /// Qualify a whole const, static initializer or const fn.\n-    fn qualify_const(&mut self) -> (Qualif, Lrc<IdxSetBuf<Local>>) {\n+    fn qualify_const(&mut self) -> (Qualif, Lrc<IdxSet<Local>>) {\n         debug!(\"qualifying {} {:?}\", self.mode, self.def_id);\n \n         let mir = self.mir;\n@@ -382,7 +382,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n \n \n         // Collect all the temps we need to promote.\n-        let mut promoted_temps = IdxSetBuf::new_empty(self.temp_promotion_state.len());\n+        let mut promoted_temps = IdxSet::new_empty(self.temp_promotion_state.len());\n \n         for candidate in &self.promotion_candidates {\n             match *candidate {\n@@ -1104,7 +1104,7 @@ pub fn provide(providers: &mut Providers) {\n \n fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               def_id: DefId)\n-                              -> (u8, Lrc<IdxSetBuf<Local>>) {\n+                              -> (u8, Lrc<IdxSet<Local>>) {\n     // NB: This `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n@@ -1113,7 +1113,7 @@ fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if mir.return_ty().references_error() {\n         tcx.sess.delay_span_bug(mir.span, \"mir_const_qualif: Mir had errors\");\n-        return (Qualif::NOT_CONST.bits(), Lrc::new(IdxSetBuf::new_empty(0)));\n+        return (Qualif::NOT_CONST.bits(), Lrc::new(IdxSet::new_empty(0)));\n     }\n \n     let mut qualifier = Qualifier::new(tcx, def_id, mir, Mode::Const);"}, {"sha": "63675f056ab7851646b991d77f79a6e941defc0f", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=e73077e10603b3586828f2d3d067f804c2fc0a1f", "patch": "@@ -14,7 +14,7 @@ use syntax_pos::Span;\n \n use rustc::ty::{self, TyCtxt};\n use rustc::mir::{self, Mir, Location};\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::Idx;\n use transform::{MirPass, MirSource};\n \n@@ -47,7 +47,7 @@ impl MirPass for SanityCheck {\n         let param_env = tcx.param_env(def_id);\n         let move_data = MoveData::gather_moves(mir, tcx).unwrap();\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n-        let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+        let dead_unwinds = IdxSet::new_empty(mir.basic_blocks().len());\n         let flow_inits =\n             do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n                         MaybeInitializedPlaces::new(tcx, mir, &mdpe),"}, {"sha": "04fa516a655a66c9878e736128e2bc9d81927078", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73077e10603b3586828f2d3d067f804c2fc0a1f/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=e73077e10603b3586828f2d3d067f804c2fc0a1f", "patch": "@@ -38,7 +38,7 @@ use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::mir::Local;\n use rustc::mir::*;\n use rustc::ty::{item_path, TyCtxt};\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::work_queue::WorkQueue;\n use std::fs;\n@@ -47,7 +47,7 @@ use std::path::{Path, PathBuf};\n use transform::MirSource;\n use util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n \n-pub type LiveVarSet<V> = IdxSetBuf<V>;\n+pub type LiveVarSet<V> = IdxSet<V>;\n \n /// This gives the result of the liveness analysis at the boundary of\n /// basic blocks. You can use `simulate_block` to obtain the"}]}