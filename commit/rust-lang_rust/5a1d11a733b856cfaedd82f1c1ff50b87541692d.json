{"sha": "5a1d11a733b856cfaedd82f1c1ff50b87541692d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMWQxMWE3MzNiODU2Y2ZhZWRkODJmMWMxZmY1MGI4NzU0MTY5MmQ=", "commit": {"author": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2017-10-01T19:13:49Z"}, "committer": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2017-11-03T20:27:40Z"}, "message": "Copy `AsciiExt` methods to `[u8]` directly\n\nThis is done in order to deprecate AsciiExt eventually. Note that\nthis commit contains a bunch of `cfg(stage0)` statements. This is\ndue to a new compiler feature I am using: the `slice_u8` lang item.\nOnce this lang item is available in the stage0 compiler, all those\ncfg flags (and more) can be removed.", "tree": {"sha": "8ba0bb6bddc0191037ec77f1fcd07abd4e12a8b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ba0bb6bddc0191037ec77f1fcd07abd4e12a8b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a1d11a733b856cfaedd82f1c1ff50b87541692d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a1d11a733b856cfaedd82f1c1ff50b87541692d", "html_url": "https://github.com/rust-lang/rust/commit/5a1d11a733b856cfaedd82f1c1ff50b87541692d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a1d11a733b856cfaedd82f1c1ff50b87541692d/comments", "author": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e441c76f76521466f2f83c90d5f2811a1e9a714", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e441c76f76521466f2f83c90d5f2811a1e9a714", "html_url": "https://github.com/rust-lang/rust/commit/9e441c76f76521466f2f83c90d5f2811a1e9a714"}], "stats": {"total": 219, "additions": 219, "deletions": 0}, "files": [{"sha": "8268528acbd4ecf3afb3318c6c4cd53d4c55a866", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/5a1d11a733b856cfaedd82f1c1ff50b87541692d/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a1d11a733b856cfaedd82f1c1ff50b87541692d/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=5a1d11a733b856cfaedd82f1c1ff50b87541692d", "patch": "@@ -1533,6 +1533,215 @@ impl<T> [T] {\n     }\n }\n \n+// TODO(LukasKalbertodt): the `not(stage0)` constraint can be removed in the\n+// future once the stage0 compiler is new enough to know about the `slice_u8`\n+// lang item.\n+#[lang = \"slice_u8\"]\n+#[cfg(all(not(stage0), not(test)))]\n+impl [u8] {\n+    /// Checks if all bytes in this slice are within the ASCII range.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii())\n+    }\n+\n+    /// Returns a vector containing a copy of this slice where each byte\n+    /// is mapped to its ASCII upper case equivalent.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To uppercase the value in-place, use [`make_ascii_uppercase`].\n+    ///\n+    /// [`make_ascii_uppercase`]: #method.make_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_uppercase(&self) -> Vec<u8> {\n+        let mut me = self.to_vec();\n+        me.make_ascii_uppercase();\n+        me\n+    }\n+\n+    /// Returns a vector containing a copy of this slice where each byte\n+    /// is mapped to its ASCII lower case equivalent.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To lowercase the value in-place, use [`make_ascii_lowercase`].\n+    ///\n+    /// [`make_ascii_lowercase`]: #method.make_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn to_ascii_lowercase(&self) -> Vec<u8> {\n+        let mut me = self.to_vec();\n+        me.make_ascii_lowercase();\n+        me\n+    }\n+\n+    /// Checks that two slices are an ASCII case-insensitive match.\n+    ///\n+    /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n+    /// but without allocating and copying temporaries.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n+        self.len() == other.len() &&\n+            self.iter().zip(other).all(|(a, b)| {\n+                a.eq_ignore_ascii_case(b)\n+            })\n+    }\n+\n+    /// Converts this slice to its ASCII upper case equivalent in-place.\n+    ///\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new uppercased value without modifying the existing one, use\n+    /// [`to_ascii_uppercase`].\n+    ///\n+    /// [`to_ascii_uppercase`]: #method.to_ascii_uppercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn make_ascii_uppercase(&mut self) {\n+        for byte in self {\n+            byte.make_ascii_uppercase();\n+        }\n+    }\n+\n+    /// Converts this slice to its ASCII lower case equivalent in-place.\n+    ///\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    ///\n+    /// To return a new lowercased value without modifying the existing one, use\n+    /// [`to_ascii_lowercase`].\n+    ///\n+    /// [`to_ascii_lowercase`]: #method.to_ascii_lowercase\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn make_ascii_lowercase(&mut self) {\n+        for byte in self {\n+            byte.make_ascii_lowercase();\n+        }\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII alphabetic characters:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z'.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_alphabetic(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_alphabetic())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII uppercase characters:\n+    /// U+0041 'A' ... U+005A 'Z'.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_uppercase(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_uppercase())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII lowercase characters:\n+    /// U+0061 'a' ... U+007A 'z'.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_lowercase(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_lowercase())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII alphanumeric characters:\n+    ///\n+    /// - U+0041 'A' ... U+005A 'Z', or\n+    /// - U+0061 'a' ... U+007A 'z', or\n+    /// - U+0030 '0' ... U+0039 '9'.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_alphanumeric(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_alphanumeric())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII decimal digit:\n+    /// U+0030 '0' ... U+0039 '9'.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_digit(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_digit())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII hexadecimal digits:\n+    ///\n+    /// - U+0030 '0' ... U+0039 '9', or\n+    /// - U+0041 'A' ... U+0046 'F', or\n+    /// - U+0061 'a' ... U+0066 'f'.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_hexdigit(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_hexdigit())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII punctuation characters:\n+    ///\n+    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n+    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n+    /// - U+005B ... U+0060 `[ \\\\ ] ^ _ \\``, or\n+    /// - U+007B ... U+007E `{ | } ~`\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_punctuation(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_punctuation())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII graphic characters:\n+    /// U+0021 '@' ... U+007E '~'.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_graphic(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_graphic())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII whitespace characters:\n+    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n+    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n+    ///\n+    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n+    /// whitespace][infra-aw]. There are several other definitions in\n+    /// wide use. For instance, [the POSIX locale][pct] includes\n+    /// U+000B VERTICAL TAB as well as all the above characters,\n+    /// but\u2014from the very same specification\u2014[the default rule for\n+    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n+    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n+    ///\n+    /// If you are writing a program that will process an existing\n+    /// file format, check what that format's definition of whitespace is\n+    /// before using this function.\n+    ///\n+    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n+    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n+    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_whitespace(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_whitespace())\n+    }\n+\n+    /// Checks if all bytes of this slice are ASCII control characters:\n+    ///\n+    /// - U+0000 NUL ... U+001F UNIT SEPARATOR, or\n+    /// - U+007F DELETE.\n+    ///\n+    /// Note that most ASCII whitespace characters are control\n+    /// characters, but SPACE is not.\n+    #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.21.0\")]\n+    #[inline]\n+    pub fn is_ascii_control(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_control())\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "7a474c1f2541024073ef16c5b2e2effa96433f3f", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a1d11a733b856cfaedd82f1c1ff50b87541692d/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a1d11a733b856cfaedd82f1c1ff50b87541692d/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=5a1d11a733b856cfaedd82f1c1ff50b87541692d", "patch": "@@ -389,6 +389,10 @@ impl AsciiExt for str {\n     }\n }\n \n+// TODO(LukasKalbertodt): this impl block can be removed in the future. This is\n+// possible once the stage0 compiler is new enough to contain the inherent\n+// ascii methods for `[u8]`. See TODO comment further down.\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsciiExt for [u8] {\n     type Owned = Vec<u8>;\n@@ -542,6 +546,12 @@ macro_rules! impl_by_delegating {\n impl_by_delegating!(u8, u8);\n impl_by_delegating!(char, char);\n \n+// TODO(LukasKalbertodt): the macro invocation should replace the impl block\n+// for `[u8]` above. But this is not possible until the stage0 compiler is new\n+// enough to contain the inherent ascii methods for `[u8]`.\n+#[cfg(not(stage0))]\n+impl_by_delegating!([u8], Vec<u8>);\n+\n /// An iterator over the escaped version of a byte.\n ///\n /// This `struct` is created by the [`escape_default`] function. See its"}]}