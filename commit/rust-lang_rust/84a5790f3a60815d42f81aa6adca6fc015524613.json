{"sha": "84a5790f3a60815d42f81aa6adca6fc015524613", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0YTU3OTBmM2E2MDgxNWQ0MmY4MWFhNmFkY2E2ZmMwMTU1MjQ2MTM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-01-19T09:47:27Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-01-19T09:47:27Z"}, "message": "fix the docs and simplify the implementation of unsigned wrapping ops", "tree": {"sha": "4726dbb3dfd3446d0ab9cadc307dc433b98b7c11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4726dbb3dfd3446d0ab9cadc307dc433b98b7c11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84a5790f3a60815d42f81aa6adca6fc015524613", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84a5790f3a60815d42f81aa6adca6fc015524613", "html_url": "https://github.com/rust-lang/rust/commit/84a5790f3a60815d42f81aa6adca6fc015524613", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84a5790f3a60815d42f81aa6adca6fc015524613/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c66e88289e6ffa8be4701933369820613b9d345d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c66e88289e6ffa8be4701933369820613b9d345d", "html_url": "https://github.com/rust-lang/rust/commit/c66e88289e6ffa8be4701933369820613b9d345d"}], "stats": {"total": 93, "additions": 43, "deletions": 50}, "files": [{"sha": "99a74cf09f571ac5987dab52b02ce18302fdaa6b", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 43, "deletions": 50, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/84a5790f3a60815d42f81aa6adca6fc015524613/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84a5790f3a60815d42f81aa6adca6fc015524613/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=84a5790f3a60815d42f81aa6adca6fc015524613", "patch": "@@ -1153,7 +1153,7 @@ impl isize {\n         intrinsics::mul_with_overflow }\n }\n \n-// `Int` + `UnsignedInt` implemented for signed integers\n+// `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n     ($ActualT:ty, $BITS:expr,\n      $ctpop:path,\n@@ -1457,8 +1457,8 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n-        /// assert_eq!((-128i8).checked_sub(1), None);\n+        /// assert_eq!(1u8.checked_sub(1), Some(0));\n+        /// assert_eq!(0u8.checked_sub(1), None);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -1493,9 +1493,8 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!((-127i8).checked_div(-1), Some(127));\n-        /// assert_eq!((-128i8).checked_div(-1), None);\n-        /// assert_eq!((1i8).checked_div(0), None);\n+        /// assert_eq!(128u8.checked_div(2), Some(64));\n+        /// assert_eq!(1u8.checked_div(0), None);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -1591,16 +1590,15 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!(100i8.saturating_add(1), 101);\n-        /// assert_eq!(100i8.saturating_add(127), 127);\n+        /// assert_eq!(100u8.saturating_add(1), 101);\n+        /// assert_eq!(200u8.saturating_add(127), 255);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn saturating_add(self, other: Self) -> Self {\n             match self.checked_add(other) {\n-                Some(x)                       => x,\n-                None if other >= Self::zero() => Self::max_value(),\n-                None => Self::min_value(),\n+                Some(x) => x,\n+                None => Self::max_value(),\n             }\n         }\n \n@@ -1612,16 +1610,15 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!(100i8.saturating_sub(127), -27);\n-        /// assert_eq!((-100i8).saturating_sub(127), -128);\n+        /// assert_eq!(100u8.saturating_sub(27), 73);\n+        /// assert_eq!(13u8.saturating_sub(127), 0);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn saturating_sub(self, other: Self) -> Self {\n             match self.checked_sub(other) {\n-                Some(x)                       => x,\n-                None if other >= Self::zero() => Self::min_value(),\n-                None => Self::max_value(),\n+                Some(x) => x,\n+                None => Self::min_value(),\n             }\n         }\n \n@@ -1652,8 +1649,8 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!(100i8.wrapping_add(27), 127);\n-        /// assert_eq!(100i8.wrapping_add(127), -29);\n+        /// assert_eq!(200u8.wrapping_add(55), 255);\n+        /// assert_eq!(200u8.wrapping_add(155), 99);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -1671,8 +1668,8 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!(0i8.wrapping_sub(127), -127);\n-        /// assert_eq!((-2i8).wrapping_sub(127), 127);\n+        /// assert_eq!(100u8.wrapping_sub(100), 0);\n+        /// assert_eq!(100u8.wrapping_sub(155), 201);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -1690,8 +1687,8 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!(10i8.wrapping_mul(12), 120);\n-        /// assert_eq!(11i8.wrapping_mul(12), -124);\n+        /// assert_eq!(10u8.wrapping_mul(12), 120);\n+        /// assert_eq!(25u8.wrapping_mul(12), 44);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n@@ -1701,68 +1698,64 @@ macro_rules! uint_impl {\n             }\n         }\n \n-        /// Wrapping (modular) division. Computes `self / other`,\n-        /// wrapping around at the boundary of the type.\n-        ///\n-        /// The only case where such wrapping can occur is when one\n-        /// divides `MIN / -1` on a signed type (where `MIN` is the\n-        /// negative minimal value for the type); this is equivalent\n-        /// to `-MIN`, a positive value that is too large to represent\n-        /// in the type. In such a case, this function returns `MIN`\n-        /// itself.\n+        /// Wrapping (modular) division. Computes `self / other`.\n+        /// Wrapped division on unsigned types is just normal division.\n+        /// There's no way wrapping could ever happen.\n+        /// This function exists, so that all operations\n+        /// are accounted for in the wrapping operations.\n         ///\n         /// # Examples\n         ///\n         /// Basic usage:\n         ///\n         /// ```\n         /// assert_eq!(100u8.wrapping_div(10), 10);\n-        /// assert_eq!((-128i8).wrapping_div(-1), -128);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_div(self, rhs: Self) -> Self {\n-            self.overflowing_div(rhs).0\n+            self / rhs\n         }\n \n-        /// Wrapping (modular) remainder. Computes `self % other`,\n-        /// wrapping around at the boundary of the type.\n-        ///\n-        /// Such wrap-around never actually occurs mathematically;\n-        /// implementation artifacts make `x % y` invalid for `MIN /\n-        /// -1` on a signed type (where `MIN` is the negative\n-        /// minimal value). In such a case, this function returns `0`.\n+        /// Wrapping (modular) remainder. Computes `self % other`.\n+        /// Wrapped remainder calculation on unsigned types is\n+        /// just the regular remainder calculation.\n+        /// There's no way wrapping could ever happen.\n+        /// This function exists, so that all operations\n+        /// are accounted for in the wrapping operations.\n         ///\n         /// # Examples\n         ///\n         /// Basic usage:\n         ///\n         /// ```\n         /// assert_eq!(100i8.wrapping_rem(10), 0);\n-        /// assert_eq!((-128i8).wrapping_rem(-1), 0);\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n         pub fn wrapping_rem(self, rhs: Self) -> Self {\n-            self.overflowing_rem(rhs).0\n+            self % rhs\n         }\n \n         /// Wrapping (modular) negation. Computes `-self`,\n         /// wrapping around at the boundary of the type.\n         ///\n-        /// The only case where such wrapping can occur is when one\n-        /// negates `MIN` on a signed type (where `MIN` is the\n-        /// negative minimal value for the type); this is a positive\n-        /// value that is too large to represent in the type. In such\n-        /// a case, this function returns `MIN` itself.\n+        /// Since unsigned types do not have negative equivalents\n+        /// all applications of this function will wrap (except for `-0`).\n+        /// For values smaller than the corresponding signed type's maximum\n+        /// the result is the same as casting the corresponding signed value.\n+        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n+        /// `MAX` is the corresponding signed type's maximum.\n         ///\n         /// # Examples\n         ///\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!(100i8.wrapping_neg(), -100);\n-        /// assert_eq!((-128i8).wrapping_neg(), -128);\n+        /// assert_eq!(100u8.wrapping_neg(), 156);\n+        /// assert_eq!(0u8.wrapping_neg(), 0);\n+        /// assert_eq!(180u8.wrapping_neg(), 76);\n+        /// assert_eq!(180u8.wrapping_neg(), (127 + 1) - (180u8 - (127 + 1)));\n         /// ```\n         #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n         #[inline(always)]\n@@ -2002,7 +1995,7 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// assert_eq!(2i32.pow(4), 16);\n+        /// assert_eq!(2u32.pow(4), 16);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]"}]}