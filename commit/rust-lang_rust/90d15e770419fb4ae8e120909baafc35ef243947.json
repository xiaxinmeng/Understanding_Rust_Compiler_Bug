{"sha": "90d15e770419fb4ae8e120909baafc35ef243947", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZDE1ZTc3MDQxOWZiNGFlOGUxMjA5MDliYWFmYzM1ZWYyNDM5NDc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-19T16:56:45Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-23T09:46:41Z"}, "message": "syntax: Some code cleanup", "tree": {"sha": "8a606f3b49b34a49075323f75e86862d7441d9c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a606f3b49b34a49075323f75e86862d7441d9c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90d15e770419fb4ae8e120909baafc35ef243947", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90d15e770419fb4ae8e120909baafc35ef243947", "html_url": "https://github.com/rust-lang/rust/commit/90d15e770419fb4ae8e120909baafc35ef243947", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90d15e770419fb4ae8e120909baafc35ef243947/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca2a50fad7439f02a9e99f8107ffed8460fc8c44", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca2a50fad7439f02a9e99f8107ffed8460fc8c44", "html_url": "https://github.com/rust-lang/rust/commit/ca2a50fad7439f02a9e99f8107ffed8460fc8c44"}], "stats": {"total": 405, "additions": 177, "deletions": 228}, "files": [{"sha": "0305b1f59b94652e4f1027bdd10af7c85fbf4d1d", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 146, "deletions": 204, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/90d15e770419fb4ae8e120909baafc35ef243947/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d15e770419fb4ae8e120909baafc35ef243947/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=90d15e770419fb4ae8e120909baafc35ef243947", "patch": "@@ -6,7 +6,7 @@ use crate::parse::PResult;\n use crate::parse::token::{self, Token};\n use crate::parse::unescape::{unescape_str, unescape_char, unescape_byte_str, unescape_byte};\n use crate::print::pprust;\n-use crate::symbol::{kw, Symbol};\n+use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{TokenStream, TokenTree};\n \n use errors::{Applicability, Handler};\n@@ -22,22 +22,23 @@ crate enum LitError {\n     InvalidSuffix,\n     InvalidIntSuffix,\n     InvalidFloatSuffix,\n-    NonDecimalFloat(&'static str),\n+    NonDecimalFloat(u32),\n     IntTooLarge,\n }\n \n impl LitError {\n-    crate fn report(\n-        &self,\n-        diag: &Handler,\n-        token::Lit { kind, suffix, .. }: token::Lit,\n-        span: Span,\n-    ) {\n+    fn report(&self, diag: &Handler, lit: token::Lit, span: Span) {\n+        let token::Lit { kind, suffix, .. } = lit;\n         match *self {\n-            LitError::NotLiteral | LitError::LexerError => {}\n+            // `NotLiteral` is not an error by itself, so we don't report\n+            // it and give the parser opportunity to try something else.\n+            LitError::NotLiteral => {}\n+            // `LexerError` *is* an error, but it was already reported\n+            // by lexer, so here we don't report it the second time.\n+            LitError::LexerError => {}\n             LitError::InvalidSuffix => {\n                 expect_no_suffix(\n-                    diag, span, &format!(\"{} {}\", kind.article(), kind.descr()), suffix\n+                    diag, span, &format!(\"{} {} literal\", kind.article(), kind.descr()), suffix\n                 );\n             }\n             LitError::InvalidIntSuffix => {\n@@ -72,7 +73,13 @@ impl LitError {\n                         .emit();\n                 }\n             }\n-            LitError::NonDecimalFloat(descr) => {\n+            LitError::NonDecimalFloat(base) => {\n+                let descr = match base {\n+                    16 => \"hexadecimal\",\n+                    8 => \"octal\",\n+                    2 => \"binary\",\n+                    _ => unreachable!(),\n+                };\n                 diag.struct_span_err(span, &format!(\"{} float literal is not supported\", descr))\n                     .span_label(span, \"not supported\")\n                     .emit();\n@@ -86,13 +93,9 @@ impl LitError {\n }\n \n impl LitKind {\n-    /// Converts literal token with a suffix into a semantic literal.\n-    /// Works speculatively and may return `None` if diagnostic handler is not passed.\n-    /// If diagnostic handler is passed, always returns `Some`,\n-    /// possibly after reporting non-fatal errors and recovery.\n-    fn from_lit_token(\n-        token::Lit { kind, symbol, suffix }: token::Lit,\n-    ) -> Result<LitKind, LitError> {\n+    /// Converts literal token into a semantic literal.\n+    fn from_lit_token(lit: token::Lit) -> Result<LitKind, LitError> {\n+        let token::Lit { kind, symbol, suffix } = lit;\n         if suffix.is_some() && !kind.may_have_suffix() {\n             return Err(LitError::InvalidSuffix);\n         }\n@@ -102,18 +105,10 @@ impl LitKind {\n                 assert!(symbol == kw::True || symbol == kw::False);\n                 LitKind::Bool(symbol == kw::True)\n             }\n-            token::Byte => {\n-                match unescape_byte(&symbol.as_str()) {\n-                    Ok(c) => LitKind::Byte(c),\n-                    Err(_) => return Err(LitError::LexerError),\n-                }\n-            },\n-            token::Char => {\n-                match unescape_char(&symbol.as_str()) {\n-                    Ok(c) => LitKind::Char(c),\n-                    Err(_) => return Err(LitError::LexerError),\n-                }\n-            },\n+            token::Byte => return unescape_byte(&symbol.as_str())\n+                .map(LitKind::Byte).map_err(|_| LitError::LexerError),\n+            token::Char => return unescape_char(&symbol.as_str())\n+                .map(LitKind::Char).map_err(|_| LitError::LexerError),\n \n             // There are some valid suffixes for integer and float literals,\n             // so all the handling is done internally.\n@@ -125,53 +120,48 @@ impl LitKind {\n                 // reuse the symbol from the token. Otherwise, we must generate a\n                 // new symbol because the string in the LitKind is different to the\n                 // string in the token.\n-                let mut error = None;\n-                let mut sym = symbol;\n-                let s = &sym.as_str();\n-                if s.as_bytes().iter().any(|&c| c == b'\\\\' || c == b'\\r') {\n+                let s = symbol.as_str();\n+                let symbol = if s.contains(&['\\\\', '\\r'][..]) {\n                     let mut buf = String::with_capacity(s.len());\n-                    unescape_str(s, &mut |_, unescaped_char| {\n+                    let mut error = Ok(());\n+                    unescape_str(&s, &mut |_, unescaped_char| {\n                         match unescaped_char {\n                             Ok(c) => buf.push(c),\n-                            Err(_) => error = Some(LitError::LexerError),\n+                            Err(_) => error = Err(LitError::LexerError),\n                         }\n                     });\n-                    if let Some(error) = error {\n-                        return Err(error);\n-                    }\n-                    sym = Symbol::intern(&buf)\n-                }\n-\n-                LitKind::Str(sym, ast::StrStyle::Cooked)\n+                    error?;\n+                    Symbol::intern(&buf)\n+                } else {\n+                    symbol\n+                };\n+                LitKind::Str(symbol, ast::StrStyle::Cooked)\n             }\n             token::StrRaw(n) => {\n                 // Ditto.\n-                let mut sym = symbol;\n-                let s = &sym.as_str();\n-                if s.contains('\\r') {\n-                    sym = Symbol::intern(&raw_str_lit(s));\n-                }\n-                LitKind::Str(sym, ast::StrStyle::Raw(n))\n+                let s = symbol.as_str();\n+                let symbol = if s.contains('\\r') {\n+                    Symbol::intern(&raw_str_lit(&s))\n+                } else {\n+                    symbol\n+                };\n+                LitKind::Str(symbol, ast::StrStyle::Raw(n))\n             }\n             token::ByteStr => {\n-                let s = &symbol.as_str();\n+                let s = symbol.as_str();\n                 let mut buf = Vec::with_capacity(s.len());\n-                let mut error = None;\n-                unescape_byte_str(s, &mut |_, unescaped_byte| {\n+                let mut error = Ok(());\n+                unescape_byte_str(&s, &mut |_, unescaped_byte| {\n                     match unescaped_byte {\n                         Ok(c) => buf.push(c),\n-                        Err(_) => error = Some(LitError::LexerError),\n+                        Err(_) => error = Err(LitError::LexerError),\n                     }\n                 });\n-                if let Some(error) = error {\n-                    return Err(error);\n-                }\n+                error?;\n                 buf.shrink_to_fit();\n                 LitKind::ByteStr(Lrc::new(buf))\n             }\n-            token::ByteStrRaw(_) => {\n-                LitKind::ByteStr(Lrc::new(symbol.to_string().into_bytes()))\n-            }\n+            token::ByteStrRaw(_) => LitKind::ByteStr(Lrc::new(symbol.to_string().into_bytes())),\n             token::Err => LitKind::Err(symbol),\n         })\n     }\n@@ -229,21 +219,13 @@ impl LitKind {\n }\n \n impl Lit {\n-    fn from_lit_token(\n-        token: token::Lit,\n-        span: Span,\n-    ) -> Result<Lit, LitError> {\n+    /// Converts literal token into an AST literal.\n+    fn from_lit_token(token: token::Lit, span: Span) -> Result<Lit, LitError> {\n         Ok(Lit { token, node: LitKind::from_lit_token(token)?, span })\n     }\n \n-    /// Converts literal token with a suffix into an AST literal.\n-    /// Works speculatively and may return `None` if diagnostic handler is not passed.\n-    /// If diagnostic handler is passed, may return `Some`,\n-    /// possibly after reporting non-fatal errors and recovery, or `None` for irrecoverable errors.\n-    crate fn from_token(\n-        token: &token::Token,\n-        span: Span,\n-    ) -> Result<Lit, LitError> {\n+    /// Converts arbitrary token into an AST literal.\n+    crate fn from_token(token: &Token, span: Span) -> Result<Lit, LitError> {\n         let lit = match *token {\n             token::Ident(ident, false) if ident.name == kw::True || ident.name == kw::False =>\n                 token::Lit::new(token::Bool, ident.name, None),\n@@ -298,6 +280,7 @@ impl<'a> Parser<'a> {\n                 None\n             });\n             if let Some((ref token, span)) = recovered {\n+                self.bump();\n                 self.diagnostic()\n                     .struct_span_err(span, \"float literals must have an integer part\")\n                     .span_suggestion(\n@@ -307,7 +290,6 @@ impl<'a> Parser<'a> {\n                         Applicability::MachineApplicable,\n                     )\n                     .emit();\n-                self.bump();\n             }\n         }\n \n@@ -317,64 +299,59 @@ impl<'a> Parser<'a> {\n         match Lit::from_token(token, span) {\n             Ok(lit) => {\n                 self.bump();\n-                return Ok(lit);\n+                Ok(lit)\n             }\n             Err(LitError::NotLiteral) => {\n                 let msg = format!(\"unexpected token: {}\", self.this_token_descr());\n-                return Err(self.span_fatal(span, &msg));\n+                Err(self.span_fatal(span, &msg))\n             }\n             Err(err) => {\n                 let lit = token.expect_lit();\n                 self.bump();\n                 err.report(&self.sess.span_diagnostic, lit, span);\n                 let lit = token::Lit::new(token::Err, lit.symbol, lit.suffix);\n-                return Ok(Lit::from_lit_token(lit, span).ok().unwrap());\n+                Lit::from_lit_token(lit, span).map_err(|_| unreachable!())\n             }\n         }\n     }\n }\n \n-crate fn expect_no_suffix(diag: &Handler, sp: Span, kind: &str, suffix: Option<ast::Name>) {\n-    match suffix {\n-        None => {/* everything ok */}\n-        Some(suf) => {\n-            let text = suf.as_str();\n-            let mut err = if kind == \"a tuple index\" &&\n-                [\"i32\", \"u32\", \"isize\", \"usize\"].contains(&text.to_string().as_str())\n-            {\n-                // #59553: warn instead of reject out of hand to allow the fix to percolate\n-                // through the ecosystem when people fix their macros\n-                let mut err = diag.struct_span_warn(\n-                    sp,\n-                    &format!(\"suffixes on {} are invalid\", kind),\n-                );\n-                err.note(&format!(\n-                    \"`{}` is *temporarily* accepted on tuple index fields as it was \\\n-                        incorrectly accepted on stable for a few releases\",\n-                    text,\n-                ));\n-                err.help(\n-                    \"on proc macros, you'll want to use `syn::Index::from` or \\\n-                        `proc_macro::Literal::*_unsuffixed` for code that will desugar \\\n-                        to tuple field access\",\n-                );\n-                err.note(\n-                    \"for more context, see https://github.com/rust-lang/rust/issues/60210\",\n-                );\n-                err\n-            } else {\n-                diag.struct_span_err(sp, &format!(\"suffixes on {} are invalid\", kind))\n-            };\n-            err.span_label(sp, format!(\"invalid suffix `{}`\", text));\n-            err.emit();\n-        }\n+crate fn expect_no_suffix(diag: &Handler, sp: Span, kind: &str, suffix: Option<Symbol>) {\n+    if let Some(suf) = suffix {\n+        let mut err = if kind == \"a tuple index\" &&\n+                         [sym::i32, sym::u32, sym::isize, sym::usize].contains(&suf) {\n+            // #59553: warn instead of reject out of hand to allow the fix to percolate\n+            // through the ecosystem when people fix their macros\n+            let mut err = diag.struct_span_warn(\n+                sp,\n+                &format!(\"suffixes on {} are invalid\", kind),\n+            );\n+            err.note(&format!(\n+                \"`{}` is *temporarily* accepted on tuple index fields as it was \\\n+                    incorrectly accepted on stable for a few releases\",\n+                suf,\n+            ));\n+            err.help(\n+                \"on proc macros, you'll want to use `syn::Index::from` or \\\n+                    `proc_macro::Literal::*_unsuffixed` for code that will desugar \\\n+                    to tuple field access\",\n+            );\n+            err.note(\n+                \"for more context, see https://github.com/rust-lang/rust/issues/60210\",\n+            );\n+            err\n+        } else {\n+            diag.struct_span_err(sp, &format!(\"suffixes on {} are invalid\", kind))\n+        };\n+        err.span_label(sp, format!(\"invalid suffix `{}`\", suf));\n+        err.emit();\n     }\n }\n \n /// Parses a string representing a raw string literal into its final form. The\n /// only operation this does is convert embedded CRLF into a single LF.\n fn raw_str_lit(lit: &str) -> String {\n-    debug!(\"raw_str_lit: given {}\", lit.escape_default());\n+    debug!(\"raw_str_lit: {:?}\", lit);\n     let mut res = String::with_capacity(lit.len());\n \n     let mut chars = lit.chars().peekable();\n@@ -399,117 +376,82 @@ fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n     s.len() > 1 && s.starts_with(first_chars) && s[1..].chars().all(|c| c.is_ascii_digit())\n }\n \n-fn filtered_float_lit(data: Symbol, suffix: Option<Symbol>) -> Result<LitKind, LitError> {\n-    debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n-    let suffix = match suffix {\n-        Some(suffix) => suffix,\n-        None => return Ok(LitKind::FloatUnsuffixed(data)),\n-    };\n+fn strip_underscores(symbol: Symbol) -> Symbol {\n+    // Do not allocate a new string unless necessary.\n+    let s = symbol.as_str();\n+    if s.contains('_') {\n+        let mut s = s.to_string();\n+        s.retain(|c| c != '_');\n+        return Symbol::intern(&s);\n+    }\n+    symbol\n+}\n \n-    Ok(match &*suffix.as_str() {\n-        \"f32\" => LitKind::Float(data, ast::FloatTy::F32),\n-        \"f64\" => LitKind::Float(data, ast::FloatTy::F64),\n-        _ => return Err(LitError::InvalidFloatSuffix),\n+fn filtered_float_lit(symbol: Symbol, suffix: Option<Symbol>, base: u32)\n+                      -> Result<LitKind, LitError> {\n+    debug!(\"filtered_float_lit: {:?}, {:?}, {:?}\", symbol, suffix, base);\n+    if base != 10 {\n+        return Err(LitError::NonDecimalFloat(base));\n+    }\n+    Ok(match suffix {\n+        Some(suf) => match suf {\n+            sym::f32 => LitKind::Float(symbol, ast::FloatTy::F32),\n+            sym::f64 => LitKind::Float(symbol, ast::FloatTy::F64),\n+            _ => return Err(LitError::InvalidFloatSuffix),\n+        }\n+        None => LitKind::FloatUnsuffixed(symbol)\n     })\n }\n \n-fn float_lit(s: Symbol, suffix: Option<Symbol>) -> Result<LitKind, LitError> {\n-    debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n-    // FIXME #2252: bounds checking float literals is deferred until trans\n-\n-    // Strip underscores without allocating a new String unless necessary.\n-    let s2;\n-    let s = s.as_str();\n-    let s = s.get();\n-    let s = if s.chars().any(|c| c == '_') {\n-        s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n-        &s2\n-    } else {\n-        s\n-    };\n-\n-    filtered_float_lit(Symbol::intern(s), suffix)\n+fn float_lit(symbol: Symbol, suffix: Option<Symbol>) -> Result<LitKind, LitError> {\n+    debug!(\"float_lit: {:?}, {:?}\", symbol, suffix);\n+    filtered_float_lit(strip_underscores(symbol), suffix, 10)\n }\n \n-fn integer_lit(s: Symbol, suffix: Option<Symbol>) -> Result<LitKind, LitError> {\n-    // s can only be ascii, byte indexing is fine\n-\n-    // Strip underscores without allocating a new String unless necessary.\n-    let s2;\n-    let orig = s;\n-    let s = s.as_str();\n-    let s = s.get();\n-    let mut s = if s.chars().any(|c| c == '_') {\n-        s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n-        &s2\n-    } else {\n-        s\n-    };\n-\n-    debug!(\"integer_lit: {}, {:?}\", s, suffix);\n+fn integer_lit(symbol: Symbol, suffix: Option<Symbol>) -> Result<LitKind, LitError> {\n+    debug!(\"integer_lit: {:?}, {:?}\", symbol, suffix);\n+    let symbol = strip_underscores(symbol);\n+    let s = symbol.as_str();\n \n     let mut base = 10;\n-    let mut ty = ast::LitIntType::Unsuffixed;\n-\n-    if s.starts_with('0') && s.len() > 1 {\n+    if s.len() > 1 && s.as_bytes()[0] == b'0' {\n         match s.as_bytes()[1] {\n             b'x' => base = 16,\n             b'o' => base = 8,\n             b'b' => base = 2,\n-            _ => { }\n-        }\n-    }\n-\n-    // 1f64 and 2f32 etc. are valid float literals.\n-    if let Some(suf) = suffix {\n-        if looks_like_width_suffix(&['f'], &suf.as_str()) {\n-            let err = match base {\n-                16 => Some(LitError::NonDecimalFloat(\"hexadecimal\")),\n-                8 => Some(LitError::NonDecimalFloat(\"octal\")),\n-                2 => Some(LitError::NonDecimalFloat(\"binary\")),\n-                _ => None,\n-            };\n-            if let Some(err) = err {\n-                return Err(err);\n-            }\n-            return filtered_float_lit(Symbol::intern(s), Some(suf))\n+            _ => {}\n         }\n     }\n \n-    if base != 10 {\n-        s = &s[2..];\n-    }\n-\n-    if let Some(suf) = suffix {\n-        ty = match &*suf.as_str() {\n-            \"isize\" => ast::LitIntType::Signed(ast::IntTy::Isize),\n-            \"i8\"  => ast::LitIntType::Signed(ast::IntTy::I8),\n-            \"i16\" => ast::LitIntType::Signed(ast::IntTy::I16),\n-            \"i32\" => ast::LitIntType::Signed(ast::IntTy::I32),\n-            \"i64\" => ast::LitIntType::Signed(ast::IntTy::I64),\n-            \"i128\" => ast::LitIntType::Signed(ast::IntTy::I128),\n-            \"usize\" => ast::LitIntType::Unsigned(ast::UintTy::Usize),\n-            \"u8\"  => ast::LitIntType::Unsigned(ast::UintTy::U8),\n-            \"u16\" => ast::LitIntType::Unsigned(ast::UintTy::U16),\n-            \"u32\" => ast::LitIntType::Unsigned(ast::UintTy::U32),\n-            \"u64\" => ast::LitIntType::Unsigned(ast::UintTy::U64),\n-            \"u128\" => ast::LitIntType::Unsigned(ast::UintTy::U128),\n+    let ty = match suffix {\n+        Some(suf) => match suf {\n+            sym::isize => ast::LitIntType::Signed(ast::IntTy::Isize),\n+            sym::i8  => ast::LitIntType::Signed(ast::IntTy::I8),\n+            sym::i16 => ast::LitIntType::Signed(ast::IntTy::I16),\n+            sym::i32 => ast::LitIntType::Signed(ast::IntTy::I32),\n+            sym::i64 => ast::LitIntType::Signed(ast::IntTy::I64),\n+            sym::i128 => ast::LitIntType::Signed(ast::IntTy::I128),\n+            sym::usize => ast::LitIntType::Unsigned(ast::UintTy::Usize),\n+            sym::u8  => ast::LitIntType::Unsigned(ast::UintTy::U8),\n+            sym::u16 => ast::LitIntType::Unsigned(ast::UintTy::U16),\n+            sym::u32 => ast::LitIntType::Unsigned(ast::UintTy::U32),\n+            sym::u64 => ast::LitIntType::Unsigned(ast::UintTy::U64),\n+            sym::u128 => ast::LitIntType::Unsigned(ast::UintTy::U128),\n+            // `1f64` and `2f32` etc. are valid float literals, and\n+            // `fxxx` looks more like an invalid float literal than invalid integer literal.\n+            _ if suf.as_str().starts_with('f') => return filtered_float_lit(symbol, suffix, base),\n             _ => return Err(LitError::InvalidIntSuffix),\n         }\n-    }\n-\n-    debug!(\"integer_lit: the type is {:?}, base {:?}, the new string is {:?}, the original \\\n-           string was {:?}, the original suffix was {:?}\", ty, base, s, orig, suffix);\n+        _ => ast::LitIntType::Unsuffixed\n+    };\n \n-    Ok(match u128::from_str_radix(s, base) {\n-        Ok(r) => LitKind::Int(r, ty),\n-        Err(_) => {\n-            // Small bases are lexed as if they were base 10, e.g, the string\n-            // might be `0b10201`. This will cause the conversion above to fail,\n-            // but these kinds of errors are already reported by the lexer.\n-            let from_lexer =\n-                base < 10 && s.chars().any(|c| c.to_digit(10).map_or(false, |d| d >= base));\n-            return Err(if from_lexer { LitError::LexerError } else { LitError::IntTooLarge });\n-        }\n+    let s = &s[if base != 10 { 2 } else { 0 } ..];\n+    u128::from_str_radix(s, base).map(|i| LitKind::Int(i, ty)).map_err(|_| {\n+        // Small bases are lexed as if they were base 10, e.g, the string\n+        // might be `0b10201`. This will cause the conversion above to fail,\n+        // but these kinds of errors are already reported by the lexer.\n+        let from_lexer =\n+            base < 10 && s.chars().any(|c| c.to_digit(10).map_or(false, |d| d >= base));\n+        if from_lexer { LitError::LexerError } else { LitError::IntTooLarge }\n     })\n }"}, {"sha": "e5361b2db4e9e4b29cb529257c90b2dcea4d6435", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/90d15e770419fb4ae8e120909baafc35ef243947/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d15e770419fb4ae8e120909baafc35ef243947/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=90d15e770419fb4ae8e120909baafc35ef243947", "patch": "@@ -73,6 +73,7 @@ pub enum LitKind {\n     Err,\n }\n \n+/// A literal token.\n #[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n pub struct Lit {\n     pub kind: LitKind,\n@@ -81,6 +82,7 @@ pub struct Lit {\n }\n \n impl LitKind {\n+    /// An English article for the literal token kind.\n     crate fn article(self) -> &'static str {\n         match self {\n             Integer | Err => \"an\",\n@@ -91,13 +93,13 @@ impl LitKind {\n     crate fn descr(self) -> &'static str {\n         match self {\n             Bool => panic!(\"literal token contains `Lit::Bool`\"),\n-            Byte => \"byte literal\",\n-            Char => \"char literal\",\n-            Integer => \"integer literal\",\n-            Float => \"float literal\",\n-            Str | StrRaw(..) => \"string literal\",\n-            ByteStr | ByteStrRaw(..) => \"byte string literal\",\n-            Err => \"invalid literal\",\n+            Byte => \"byte\",\n+            Char => \"char\",\n+            Integer => \"integer\",\n+            Float => \"float\",\n+            Str | StrRaw(..) => \"string\",\n+            ByteStr | ByteStrRaw(..) => \"byte string\",\n+            Err => \"error\",\n         }\n     }\n "}, {"sha": "88a5033f3b55f43d7330d06dc42e9f1b7c7e772d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90d15e770419fb4ae8e120909baafc35ef243947/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d15e770419fb4ae8e120909baafc35ef243947/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=90d15e770419fb4ae8e120909baafc35ef243947", "patch": "@@ -163,7 +163,8 @@ fn binop_to_string(op: BinOpToken) -> &'static str {\n     }\n }\n \n-pub fn literal_to_string(token::Lit { kind, symbol, suffix }: token::Lit) -> String {\n+pub fn literal_to_string(lit: token::Lit) -> String {\n+    let token::Lit { kind, symbol, suffix } = lit;\n     let mut out = match kind {\n         token::Byte          => format!(\"b'{}'\", symbol),\n         token::Char          => format!(\"'{}'\", symbol),"}, {"sha": "beac92894b77ad7b0e803860cf515b6e3bfd21d9", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90d15e770419fb4ae8e120909baafc35ef243947/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d15e770419fb4ae8e120909baafc35ef243947/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=90d15e770419fb4ae8e120909baafc35ef243947", "patch": "@@ -379,7 +379,7 @@ impl<'a> Rustc<'a> {\n         }\n     }\n \n-    pub fn lit(&mut self, kind: token::LitKind, symbol: Symbol, suffix: Option<Symbol>) -> Literal {\n+    fn lit(&mut self, kind: token::LitKind, symbol: Symbol, suffix: Option<Symbol>) -> Literal {\n         Literal {\n             lit: token::Lit::new(kind, symbol, suffix),\n             span: server::Span::call_site(self),"}, {"sha": "b1e1a056db4adaa736f8cd057adc33bc520c8835", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90d15e770419fb4ae8e120909baafc35ef243947/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d15e770419fb4ae8e120909baafc35ef243947/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=90d15e770419fb4ae8e120909baafc35ef243947", "patch": "@@ -246,6 +246,8 @@ symbols! {\n         extern_prelude,\n         extern_types,\n         f16c_target_feature,\n+        f32,\n+        f64,\n         feature,\n         ffi_returns_twice,\n         field_init_shorthand,"}, {"sha": "67134c14cded3688ae0659e6bdd877cba7a37d3f", "filename": "src/test/ui/parser/lex-bad-numeric-literals.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90d15e770419fb4ae8e120909baafc35ef243947/src%2Ftest%2Fui%2Fparser%2Flex-bad-numeric-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d15e770419fb4ae8e120909baafc35ef243947/src%2Ftest%2Fui%2Fparser%2Flex-bad-numeric-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bad-numeric-literals.rs?ref=90d15e770419fb4ae8e120909baafc35ef243947", "patch": "@@ -13,8 +13,10 @@ fn main() {\n     0o; //~ ERROR: no valid digits\n     1e+; //~ ERROR: expected at least one digit in exponent\n     0x539.0; //~ ERROR: hexadecimal float literal is not supported\n-    9900000000000000000000000000999999999999999999999999999999; //~ ERROR: integer literal is too large\n-    9900000000000000000000000000999999999999999999999999999999; //~ ERROR: integer literal is too large\n+    9900000000000000000000000000999999999999999999999999999999;\n+    //~^ ERROR: integer literal is too large\n+    9900000000000000000000000000999999999999999999999999999999;\n+    //~^ ERROR: integer literal is too large\n     0x; //~ ERROR: no valid digits\n     0xu32; //~ ERROR: no valid digits\n     0ou32; //~ ERROR: no valid digits"}, {"sha": "6d6cd3cc17129928db8b97a97233823bb2151ea6", "filename": "src/test/ui/parser/lex-bad-numeric-literals.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/90d15e770419fb4ae8e120909baafc35ef243947/src%2Ftest%2Fui%2Fparser%2Flex-bad-numeric-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90d15e770419fb4ae8e120909baafc35ef243947/src%2Ftest%2Fui%2Fparser%2Flex-bad-numeric-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bad-numeric-literals.stderr?ref=90d15e770419fb4ae8e120909baafc35ef243947", "patch": "@@ -65,43 +65,43 @@ LL |     0x539.0;\n    |     ^^^^^^^\n \n error: no valid digits found for number\n-  --> $DIR/lex-bad-numeric-literals.rs:18:5\n+  --> $DIR/lex-bad-numeric-literals.rs:20:5\n    |\n LL |     0x;\n    |     ^^\n \n error: no valid digits found for number\n-  --> $DIR/lex-bad-numeric-literals.rs:19:5\n+  --> $DIR/lex-bad-numeric-literals.rs:21:5\n    |\n LL |     0xu32;\n    |     ^^\n \n error: no valid digits found for number\n-  --> $DIR/lex-bad-numeric-literals.rs:20:5\n+  --> $DIR/lex-bad-numeric-literals.rs:22:5\n    |\n LL |     0ou32;\n    |     ^^\n \n error: no valid digits found for number\n-  --> $DIR/lex-bad-numeric-literals.rs:21:5\n+  --> $DIR/lex-bad-numeric-literals.rs:23:5\n    |\n LL |     0bu32;\n    |     ^^\n \n error: no valid digits found for number\n-  --> $DIR/lex-bad-numeric-literals.rs:22:5\n+  --> $DIR/lex-bad-numeric-literals.rs:24:5\n    |\n LL |     0b;\n    |     ^^\n \n error: octal float literal is not supported\n-  --> $DIR/lex-bad-numeric-literals.rs:24:5\n+  --> $DIR/lex-bad-numeric-literals.rs:26:5\n    |\n LL |     0o123.456;\n    |     ^^^^^^^^^\n \n error: binary float literal is not supported\n-  --> $DIR/lex-bad-numeric-literals.rs:26:5\n+  --> $DIR/lex-bad-numeric-literals.rs:28:5\n    |\n LL |     0b111.101;\n    |     ^^^^^^^^^\n@@ -119,19 +119,19 @@ LL |     9900000000000000000000000000999999999999999999999999999999;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: integer literal is too large\n-  --> $DIR/lex-bad-numeric-literals.rs:17:5\n+  --> $DIR/lex-bad-numeric-literals.rs:18:5\n    |\n LL |     9900000000000000000000000000999999999999999999999999999999;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: octal float literal is not supported\n-  --> $DIR/lex-bad-numeric-literals.rs:23:5\n+  --> $DIR/lex-bad-numeric-literals.rs:25:5\n    |\n LL |     0o123f64;\n    |     ^^^^^^^^ not supported\n \n error: binary float literal is not supported\n-  --> $DIR/lex-bad-numeric-literals.rs:25:5\n+  --> $DIR/lex-bad-numeric-literals.rs:27:5\n    |\n LL |     0b101f64;\n    |     ^^^^^^^^ not supported"}, {"sha": "bf11dee08338e91184dbdc198b44c48c11417dc5", "filename": "src/test/ui/parser/no-hex-float-literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90d15e770419fb4ae8e120909baafc35ef243947/src%2Ftest%2Fui%2Fparser%2Fno-hex-float-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90d15e770419fb4ae8e120909baafc35ef243947/src%2Ftest%2Fui%2Fparser%2Fno-hex-float-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fno-hex-float-literal.rs?ref=90d15e770419fb4ae8e120909baafc35ef243947", "patch": "@@ -4,6 +4,6 @@ fn main() {\n     0x567.89;\n     //~^ ERROR hexadecimal float literal is not supported\n     0xDEAD.BEEFp-2f;\n-    //~^ ERROR invalid suffix `f` for integer literal\n+    //~^ ERROR invalid suffix `f` for float literal\n     //~| ERROR `{integer}` is a primitive type and therefore doesn't have fields\n }"}, {"sha": "258ab06d5ee2f2940c7ef45405be18782cfbeb49", "filename": "src/test/ui/parser/no-hex-float-literal.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90d15e770419fb4ae8e120909baafc35ef243947/src%2Ftest%2Fui%2Fparser%2Fno-hex-float-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90d15e770419fb4ae8e120909baafc35ef243947/src%2Ftest%2Fui%2Fparser%2Fno-hex-float-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fno-hex-float-literal.stderr?ref=90d15e770419fb4ae8e120909baafc35ef243947", "patch": "@@ -4,13 +4,13 @@ error: hexadecimal float literal is not supported\n LL |     0x567.89;\n    |     ^^^^^^^^\n \n-error: invalid suffix `f` for integer literal\n+error: invalid suffix `f` for float literal\n   --> $DIR/no-hex-float-literal.rs:6:18\n    |\n LL |     0xDEAD.BEEFp-2f;\n    |                  ^^ invalid suffix `f`\n    |\n-   = help: the suffix must be one of the integral types (`u32`, `isize`, etc)\n+   = help: valid suffixes are `f32` and `f64`\n \n error[E0610]: `{integer}` is a primitive type and therefore doesn't have fields\n   --> $DIR/no-hex-float-literal.rs:2:11"}]}