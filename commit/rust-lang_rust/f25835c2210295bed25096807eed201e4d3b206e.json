{"sha": "f25835c2210295bed25096807eed201e4d3b206e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyNTgzNWMyMjEwMjk1YmVkMjUwOTY4MDdlZWQyMDFlNGQzYjIwNmU=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-08-27T07:51:08Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-16T03:10:11Z"}, "message": "path2: Implement WindowsPath", "tree": {"sha": "86959c3ca079908dc1d881a4c5b0ffb27ca15c2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86959c3ca079908dc1d881a4c5b0ffb27ca15c2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f25835c2210295bed25096807eed201e4d3b206e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f25835c2210295bed25096807eed201e4d3b206e", "html_url": "https://github.com/rust-lang/rust/commit/f25835c2210295bed25096807eed201e4d3b206e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f25835c2210295bed25096807eed201e4d3b206e/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d80a2f1f1910fd681b8fd99906da3446dc06a90", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d80a2f1f1910fd681b8fd99906da3446dc06a90", "html_url": "https://github.com/rust-lang/rust/commit/3d80a2f1f1910fd681b8fd99906da3446dc06a90"}], "stats": {"total": 2342, "additions": 2314, "deletions": 28}, "files": [{"sha": "183086a785bea09f3def62ac338771d84180c5e2", "filename": "src/libstd/path2/mod.rs", "status": "modified", "additions": 83, "deletions": 18, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f25835c2210295bed25096807eed201e4d3b206e/src%2Flibstd%2Fpath2%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25835c2210295bed25096807eed201e4d3b206e/src%2Flibstd%2Fpath2%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2%2Fmod.rs?ref=f25835c2210295bed25096807eed201e4d3b206e", "patch": "@@ -28,16 +28,16 @@ pub mod windows;\n /// See `posix::Path` for more info.\n pub type PosixPath = posix::Path;\n \n-// /// Typedef for Windows file paths.\n-// /// See `windows::Path` for more info.\n-// pub type WindowsPath = windows::Path;\n+/// Typedef for Windows file paths.\n+/// See `windows::Path` for more info.\n+pub type WindowsPath = windows::Path;\n \n /// Typedef for the platform-native path type\n #[cfg(unix)]\n pub type Path = PosixPath;\n-// /// Typedef for the platform-native path type\n-//#[cfg(windows)]\n-//pub type Path = WindowsPath;\n+/// Typedef for the platform-native path type\n+#[cfg(windows)]\n+pub type Path = WindowsPath;\n \n /// Typedef for the POSIX path component iterator.\n /// See `posix::ComponentIter` for more info.\n@@ -68,6 +68,8 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// # Failure\n     ///\n     /// Raises the `null_byte` condition if the path contains a NUL.\n+    ///\n+    /// See individual Path impls for additional restrictions.\n     #[inline]\n     fn from_vec(path: &[u8]) -> Self {\n         if contains_nul(path) {\n@@ -87,11 +89,18 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// Raises the `null_byte` condition if the path contains a NUL.\n     #[inline]\n     fn from_str(path: &str) -> Self {\n-        GenericPath::from_vec(path.as_bytes())\n+        let v = path.as_bytes();\n+        if contains_nul(v) {\n+            GenericPath::from_vec(path.as_bytes()) // let from_vec handle the condition\n+        } else {\n+            unsafe { GenericPathUnsafe::from_str_unchecked(path) }\n+        }\n     }\n \n     /// Creates a new Path from a CString.\n     /// The resulting Path will always be normalized.\n+    ///\n+    /// See individual Path impls for potential restrictions.\n     #[inline]\n     fn from_c_str(path: CString) -> Self {\n         // CStrings can't contain NULs\n@@ -186,7 +195,11 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `set_dirname` for details.\n     #[inline]\n     fn set_dirname_str(&mut self, dirname: &str) {\n-        self.set_dirname(dirname.as_bytes())\n+        if contains_nul(dirname.as_bytes()) {\n+            self.set_dirname(dirname.as_bytes()) // triggers null_byte condition\n+        } else {\n+            unsafe { self.set_dirname_str_unchecked(dirname) }\n+        }\n     }\n     /// Replaces the filename portion of the path with the given byte vector.\n     /// If the replacement name is [], this is equivalent to popping the path.\n@@ -208,7 +221,11 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `set_filename` for details.\n     #[inline]\n     fn set_filename_str(&mut self, filename: &str) {\n-        self.set_filename(filename.as_bytes())\n+        if contains_nul(filename.as_bytes()) {\n+            self.set_filename(filename.as_bytes()) // triggers null_byte condition\n+        } else {\n+            unsafe { self.set_filename_str_unchecked(filename) }\n+        }\n     }\n     /// Replaces the filestem with the given byte vector.\n     /// If there is no extension in `self` (or `self` has no filename), this is equivalent\n@@ -340,7 +357,9 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `set_dirname` for details.\n     #[inline]\n     fn with_dirname_str(&self, dirname: &str) -> Self {\n-        self.with_dirname(dirname.as_bytes())\n+        let mut p = self.clone();\n+        p.set_dirname_str(dirname);\n+        p\n     }\n     /// Returns a new Path constructed by replacing the filename with the given byte vector.\n     /// See `set_filename` for details.\n@@ -358,7 +377,9 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `set_filename` for details.\n     #[inline]\n     fn with_filename_str(&self, filename: &str) -> Self {\n-        self.with_filename(filename.as_bytes())\n+        let mut p = self.clone();\n+        p.set_filename_str(filename);\n+        p\n     }\n     /// Returns a new Path constructed by setting the filestem to the given byte vector.\n     /// See `set_filestem` for details.\n@@ -376,7 +397,9 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `set_filestem` for details.\n     #[inline]\n     fn with_filestem_str(&self, filestem: &str) -> Self {\n-        self.with_filestem(filestem.as_bytes())\n+        let mut p = self.clone();\n+        p.set_filestem_str(filestem);\n+        p\n     }\n     /// Returns a new Path constructed by setting the extension to the given byte vector.\n     /// See `set_extension` for details.\n@@ -394,20 +417,24 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `set_extension` for details.\n     #[inline]\n     fn with_extension_str(&self, extension: &str) -> Self {\n-        self.with_extension(extension.as_bytes())\n+        let mut p = self.clone();\n+        p.set_extension_str(extension);\n+        p\n     }\n \n     /// Returns the directory component of `self`, as a Path.\n     /// If `self` represents the root of the filesystem hierarchy, returns `self`.\n     fn dir_path(&self) -> Self {\n-        GenericPath::from_vec(self.dirname())\n+        // self.dirname() returns a NUL-free vector\n+        unsafe { GenericPathUnsafe::from_vec_unchecked(self.dirname()) }\n     }\n     /// Returns the file component of `self`, as a relative Path.\n     /// If `self` represents the root of the filesystem hierarchy, returns None.\n     fn file_path(&self) -> Option<Self> {\n+        // self.filename() returns a NUL-free vector\n         match self.filename() {\n             [] => None,\n-            v => Some(GenericPath::from_vec(v))\n+            v => Some(unsafe { GenericPathUnsafe::from_vec_unchecked(v) })\n         }\n     }\n \n@@ -431,7 +458,11 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `push` for details.\n     #[inline]\n     fn push_str(&mut self, path: &str) {\n-        self.push(path.as_bytes())\n+        if contains_nul(path.as_bytes()) {\n+            self.push(path.as_bytes()) // triggers null_byte condition\n+        } else {\n+            unsafe { self.push_str_unchecked(path) }\n+        }\n     }\n     /// Pushes a Path onto `self`.\n     /// If the argument represents an absolute path, it replaces `self`.\n@@ -466,7 +497,9 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     /// See `join` for details.\n     #[inline]\n     fn join_str(&self, path: &str) -> Self {\n-        self.join(path.as_bytes())\n+        let mut p = self.clone();\n+        p.push_str(path);\n+        p\n     }\n     /// Returns a new Path constructed by joining `self` with the given path.\n     /// If the given path is absolute, the new Path will represent just that.\n@@ -478,6 +511,8 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n     }\n \n     /// Returns whether `self` represents an absolute path.\n+    /// An absolute path is defined as one that, when joined to another path, will\n+    /// yield back the same absolute path.\n     fn is_absolute(&self) -> bool;\n \n     /// Returns whether `self` is equal to, or is an ancestor of, the given path.\n@@ -498,19 +533,49 @@ pub trait GenericPathUnsafe {\n     /// The resulting Path will always be normalized.\n     unsafe fn from_vec_unchecked(path: &[u8]) -> Self;\n \n+    /// Creates a new Path from a str without checking for null bytes.\n+    /// The resulting Path will always be normalized.\n+    #[inline]\n+    unsafe fn from_str_unchecked(path: &str) -> Self {\n+        GenericPathUnsafe::from_vec_unchecked(path.as_bytes())\n+    }\n+\n     /// Replaces the directory portion of the path with the given byte vector without\n     /// checking for null bytes.\n     /// See `set_dirname` for details.\n     unsafe fn set_dirname_unchecked(&mut self, dirname: &[u8]);\n \n+    /// Replaces the directory portion of the path with the given str without\n+    /// checking for null bytes.\n+    /// See `set_dirname_str` for details.\n+    #[inline]\n+    unsafe fn set_dirname_str_unchecked(&mut self, dirname: &str) {\n+        self.set_dirname_unchecked(dirname.as_bytes())\n+    }\n+\n     /// Replaces the filename portion of the path with the given byte vector without\n     /// checking for null bytes.\n     /// See `set_filename` for details.\n     unsafe fn set_filename_unchecked(&mut self, filename: &[u8]);\n \n-    /// Pushes a path onto `self` without checking for null bytes.\n+    /// Replaces the filename portion of the path with the given str without\n+    /// checking for null bytes.\n+    /// See `set_filename_str` for details.\n+    #[inline]\n+    unsafe fn set_filename_str_unchecked(&mut self, filename: &str) {\n+        self.set_filename_unchecked(filename.as_bytes())\n+    }\n+\n+    /// Pushes a byte vector onto `self` without checking for null bytes.\n     /// See `push` for details.\n     unsafe fn push_unchecked(&mut self, path: &[u8]);\n+\n+    /// Pushes a str onto `self` without checking for null bytes.\n+    /// See `push_str` for details.\n+    #[inline]\n+    unsafe fn push_str_unchecked(&mut self, path: &str) {\n+        self.push_unchecked(path.as_bytes())\n+    }\n }\n \n #[inline(always)]"}, {"sha": "e873774b067768187b72c49d98218756cf729263", "filename": "src/libstd/path2/posix.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f25835c2210295bed25096807eed201e4d3b206e/src%2Flibstd%2Fpath2%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25835c2210295bed25096807eed201e4d3b206e/src%2Flibstd%2Fpath2%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2%2Fposix.rs?ref=f25835c2210295bed25096807eed201e4d3b206e", "patch": "@@ -45,6 +45,7 @@ pub fn is_sep(u: &u8) -> bool {\n }\n \n impl Eq for Path {\n+    #[inline]\n     fn eq(&self, other: &Path) -> bool {\n         self.repr == other.repr\n     }\n@@ -134,7 +135,7 @@ impl GenericPathUnsafe for Path {\n                 self.repr = Path::normalize(v);\n             }\n             Some(idx) => {\n-                let mut v = vec::with_capacity(self.repr.len() - idx + filename.len());\n+                let mut v = vec::with_capacity(idx + 1 + filename.len());\n                 v.push_all(self.repr.slice_to(idx+1));\n                 v.push_all(filename);\n                 self.repr = Path::normalize(v);\n@@ -313,7 +314,7 @@ impl Path {\n         let val = {\n             let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == sep;\n             let v_ = if is_abs { v.as_slice().slice_from(1) } else { v.as_slice() };\n-            let comps = normalize_helper(v_, is_abs, is_sep);\n+            let comps = normalize_helper(v_, is_abs);\n             match comps {\n                 None => None,\n                 Some(comps) => {\n@@ -363,15 +364,14 @@ impl Path {\n }\n \n // None result means the byte vector didn't need normalizing\n-// FIXME (#8169): Pull this into parent module once visibility works\n-fn normalize_helper<'a>(v: &'a [u8], is_abs: bool, f: &'a fn(&u8) -> bool) -> Option<~[&'a [u8]]> {\n+fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<~[&'a [u8]]> {\n     if is_abs && v.as_slice().is_empty() {\n         return None;\n     }\n     let mut comps: ~[&'a [u8]] = ~[];\n     let mut n_up = 0u;\n     let mut changed = false;\n-    for comp in v.split_iter(f) {\n+    for comp in v.split_iter(is_sep) {\n         if comp.is_empty() { changed = true }\n         else if comp == bytes!(\".\") { changed = true }\n         else if comp == bytes!(\"..\") {"}, {"sha": "1f51f2962f6b77d9f66da359b5ed8907bb30574f", "filename": "src/libstd/path2/windows.rs", "status": "modified", "additions": 2226, "deletions": 5, "changes": 2231, "blob_url": "https://github.com/rust-lang/rust/blob/f25835c2210295bed25096807eed201e4d3b206e/src%2Flibstd%2Fpath2%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25835c2210295bed25096807eed201e4d3b206e/src%2Flibstd%2Fpath2%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2%2Fwindows.rs?ref=f25835c2210295bed25096807eed201e4d3b206e", "patch": "@@ -10,13 +10,2234 @@\n \n //! Windows file path handling\n \n+use ascii::AsciiCast;\n+use c_str::{CString, ToCStr};\n+use cast;\n+use cmp::Eq;\n+use from_str::FromStr;\n+use iter::{AdditiveIterator, Extendable, Iterator};\n+use option::{Option, Some, None};\n+use str;\n+use str::{OwnedStr, Str, StrVector};\n+use util;\n+use vec::Vector;\n+use super::{GenericPath, GenericPathUnsafe};\n+\n+/// Iterator that yields successive components of a Path\n+pub type ComponentIter<'self> = str::CharSplitIterator<'self, char>;\n+\n+/// Represents a Windows path\n+// Notes for Windows path impl:\n+// The MAX_PATH is 260, but 253 is the practical limit due to some API bugs\n+// See http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247.aspx for good information\n+// about windows paths.\n+// That same page puts a bunch of restrictions on allowed characters in a path.\n+// `\\foo.txt` means \"relative to current drive\", but will not be considered to be absolute here\n+// as `\u2203P | P.join(\"\\foo.txt\") != \"\\foo.txt\"`.\n+// `C:` is interesting, that means \"the current directory on drive C\".\n+// Long absolute paths need to have \\\\?\\ prefix (or, for UNC, \\\\?\\UNC\\). I think that can be\n+// ignored for now, though, and only added in a hypothetical .to_pwstr() function.\n+// However, if a path is parsed that has \\\\?\\, this needs to be preserved as it disables the\n+// processing of \".\" and \"..\" components and / as a separator.\n+// Experimentally, \\\\?\\foo is not the same thing as \\foo.\n+// Also, \\\\foo is not valid either (certainly not equivalent to \\foo).\n+// Similarly, C:\\\\Users is not equivalent to C:\\Users, although C:\\Users\\\\foo is equivalent\n+// to C:\\Users\\foo. In fact the command prompt treats C:\\\\foo\\bar as UNC path. But it might be\n+// best to just ignore that and normalize it to C:\\foo\\bar.\n+//\n+// Based on all this, I think the right approach is to do the following:\n+// * Require valid utf-8 paths. Windows API may use WCHARs, but we don't, and utf-8 is convertible\n+// to UTF-16 anyway (though does Windows use UTF-16 or UCS-2? Not sure).\n+// * Parse the prefixes \\\\?\\UNC\\, \\\\?\\, and \\\\.\\ explicitly.\n+// * If \\\\?\\UNC\\, treat following two path components as server\\share. Don't error for missing\n+//   server\\share.\n+// * If \\\\?\\, parse disk from following component, if present. Don't error for missing disk.\n+// * If \\\\.\\, treat rest of path as just regular components. I don't know how . and .. are handled\n+//   here, they probably aren't, but I'm not going to worry about that.\n+// * Else if starts with \\\\, treat following two components as server\\share. Don't error for missing\n+//   server\\share.\n+// * Otherwise, attempt to parse drive from start of path.\n+//\n+// The only error condition imposed here is valid utf-8. All other invalid paths are simply\n+// preserved by the data structure; let the Windows API error out on them.\n+#[deriving(Clone, DeepClone)]\n+pub struct Path {\n+    priv repr: ~str, // assumed to never be empty\n+    priv prefix: Option<PathPrefix>,\n+    priv sepidx: Option<uint> // index of the final separator in the non-prefix portion of repr\n+}\n+\n+impl Eq for Path {\n+    #[inline]\n+    fn eq(&self, other: &Path) -> bool {\n+        self.repr == other.repr\n+    }\n+}\n+\n+impl FromStr for Path {\n+    fn from_str(s: &str) -> Option<Path> {\n+        if contains_nul(s.as_bytes()) {\n+            None\n+        } else {\n+            Some(unsafe { GenericPathUnsafe::from_str_unchecked(s) })\n+        }\n+    }\n+}\n+\n+impl ToCStr for Path {\n+    #[inline]\n+    fn to_c_str(&self) -> CString {\n+        // The Path impl guarantees no embedded NULs\n+        unsafe { self.as_vec().to_c_str_unchecked() }\n+    }\n+\n+    #[inline]\n+    unsafe fn to_c_str_unchecked(&self) -> CString {\n+        self.as_vec().to_c_str_unchecked()\n+    }\n+}\n+\n+impl GenericPathUnsafe for Path {\n+    /// See `GenericPathUnsafe::from_vec_unchecked`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `str::not_utf8` condition if not valid UTF-8.\n+    #[inline]\n+    unsafe fn from_vec_unchecked(path: &[u8]) -> Path {\n+        if !str::is_utf8(path) {\n+            let path = str::from_utf8(path); // triggers not_utf8 condition\n+            GenericPathUnsafe::from_str_unchecked(path)\n+        } else {\n+            GenericPathUnsafe::from_str_unchecked(cast::transmute(path))\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn from_str_unchecked(path: &str) -> Path {\n+        let (prefix, path) = Path::normalize_(path);\n+        assert!(!path.is_empty());\n+        let mut ret = Path{ repr: path, prefix: prefix, sepidx: None };\n+        ret.update_sepidx();\n+        ret\n+    }\n+\n+    /// See `GenericPathUnsafe::set_dirname_unchecked`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `str::not_utf8` condition if not valid UTF-8.\n+    #[inline]\n+    unsafe fn set_dirname_unchecked(&mut self, dirname: &[u8]) {\n+        if !str::is_utf8(dirname) {\n+            let dirname = str::from_utf8(dirname); // triggers not_utf8 condition\n+            self.set_dirname_str_unchecked(dirname);\n+        } else {\n+            self.set_dirname_str_unchecked(cast::transmute(dirname))\n+        }\n+    }\n+\n+    unsafe fn set_dirname_str_unchecked(&mut self, dirname: &str) {\n+        match self.sepidx_or_prefix_len() {\n+            None if \".\" == self.repr || \"..\" == self.repr => {\n+                self.update_normalized(dirname);\n+            }\n+            None => {\n+                let mut s = str::with_capacity(dirname.len() + self.repr.len() + 1);\n+                s.push_str(dirname);\n+                s.push_char(sep);\n+                s.push_str(self.repr);\n+                self.update_normalized(s);\n+            }\n+            Some((_,idxa,end)) if self.repr.slice(idxa,end) == \"..\" => {\n+                self.update_normalized(dirname);\n+            }\n+            Some((_,idxa,end)) if dirname.is_empty() => {\n+                let (prefix, path) = Path::normalize_(self.repr.slice(idxa,end));\n+                self.repr = path;\n+                self.prefix = prefix;\n+                self.update_sepidx();\n+            }\n+            Some((idxb,idxa,end)) => {\n+                let idx = if dirname.ends_with(\"\\\\\") { idxa }\n+                else {\n+                    let prefix = parse_prefix(dirname);\n+                    if prefix == Some(DiskPrefix) && prefix_len(prefix) == dirname.len() {\n+                        idxa\n+                    } else { idxb }\n+                };\n+                let mut s = str::with_capacity(dirname.len() + end - idx);\n+                s.push_str(dirname);\n+                s.push_str(self.repr.slice(idx,end));\n+                self.update_normalized(s);\n+            }\n+        }\n+    }\n+\n+    /// See `GenericPathUnsafe::set_filename_unchecekd`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `str::not_utf8` condition if not valid UTF-8.\n+    #[inline]\n+    unsafe fn set_filename_unchecked(&mut self, filename: &[u8]) {\n+        if !str::is_utf8(filename) {\n+            let filename = str::from_utf8(filename); // triggers not_utf8 condition\n+            self.set_filename_str_unchecked(filename)\n+        } else {\n+            self.set_filename_str_unchecked(cast::transmute(filename))\n+        }\n+    }\n+\n+    unsafe fn set_filename_str_unchecked(&mut self, filename: &str) {\n+        match self.sepidx_or_prefix_len() {\n+            None if \"..\" == self.repr => {\n+                let mut s = str::with_capacity(3 + filename.len());\n+                s.push_str(\"..\");\n+                s.push_char(sep);\n+                s.push_str(filename);\n+                self.update_normalized(s);\n+            }\n+            None => {\n+                self.update_normalized(filename);\n+            }\n+            Some((_,idxa,end)) if self.repr.slice(idxa,end) == \"..\" => {\n+                let mut s = str::with_capacity(end + 1 + filename.len());\n+                s.push_str(self.repr.slice_to(end));\n+                s.push_char(sep);\n+                s.push_str(filename);\n+                self.update_normalized(s);\n+            }\n+            Some((idxb,idxa,_)) if self.prefix == Some(DiskPrefix) && idxa == self.prefix_len() => {\n+                let mut s = str::with_capacity(idxb + filename.len());\n+                s.push_str(self.repr.slice_to(idxb));\n+                s.push_str(filename);\n+                self.update_normalized(s);\n+            }\n+            Some((idxb,_,_)) => {\n+                let mut s = str::with_capacity(idxb + 1 + filename.len());\n+                s.push_str(self.repr.slice_to(idxb));\n+                s.push_char(sep);\n+                s.push_str(filename);\n+                self.update_normalized(s);\n+            }\n+        }\n+    }\n+\n+    /// See `GenericPathUnsafe::push_unchecked`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `str::not_utf8` condition if not valid UTF-8.\n+    unsafe fn push_unchecked(&mut self, path: &[u8]) {\n+        if !str::is_utf8(path) {\n+            let path = str::from_utf8(path); // triggers not_utf8 condition\n+            self.push_str_unchecked(path);\n+        } else {\n+            self.push_str_unchecked(cast::transmute(path));\n+        }\n+    }\n+\n+    /// See `GenericPathUnsafe::push_str_unchecked`.\n+    ///\n+    /// Concatenating two Windows Paths is rather complicated.\n+    /// For the most part, it will behave as expected, except in the case of\n+    /// pushing a volume-relative path, e.g. `C:foo.txt`. Because we have no\n+    /// concept of per-volume cwds like Windows does, we can't behave exactly\n+    /// like Windows will. Instead, if the receiver is an absolute path on\n+    /// the same volume as the new path, it will be treated as the cwd that\n+    /// the new path is relative to. Otherwise, the new path will be treated\n+    /// as if it were absolute and will replace the receiver outright.\n+    unsafe fn push_str_unchecked(&mut self, path: &str) {\n+        fn is_vol_abs(path: &str, prefix: Option<PathPrefix>) -> bool {\n+            // assume prefix is Some(DiskPrefix)\n+            let rest = path.slice_from(prefix_len(prefix));\n+            !rest.is_empty() && rest[0].is_ascii() && is_sep2(rest[0] as char)\n+        }\n+        fn shares_volume(me: &Path, path: &str) -> bool {\n+            // path is assumed to have a prefix of Some(DiskPrefix)\n+            match me.prefix {\n+                Some(DiskPrefix) => me.repr[0] == path[0].to_ascii().to_upper().to_byte(),\n+                Some(VerbatimDiskPrefix) => me.repr[4] == path[0].to_ascii().to_upper().to_byte(),\n+                _ => false\n+            }\n+        }\n+        fn is_sep_(prefix: Option<PathPrefix>, u: u8) -> bool {\n+            u.is_ascii() && if prefix_is_verbatim(prefix) { is_sep(u as char) }\n+                            else { is_sep2(u as char) }\n+        }\n+\n+        fn replace_path(me: &mut Path, path: &str, prefix: Option<PathPrefix>) {\n+            let newpath = Path::normalize__(path, prefix);\n+            me.repr = match newpath {\n+                Some(p) => p,\n+                None => path.to_owned()\n+            };\n+            me.prefix = prefix;\n+            me.update_sepidx();\n+        }\n+        fn append_path(me: &mut Path, path: &str) {\n+            // appends a path that has no prefix\n+            // if me is verbatim, we need to pre-normalize the new path\n+            let path_ = if me.is_verbatim() { Path::normalize__(path, None) }\n+                        else { None };\n+            let pathlen = path_.map_default(path.len(), |p| p.len());\n+            let mut s = str::with_capacity(me.repr.len() + 1 + pathlen);\n+            s.push_str(me.repr);\n+            let plen = me.prefix_len();\n+            if !(me.repr.len() > plen && me.repr[me.repr.len()-1] == sep as u8) {\n+                s.push_char(sep);\n+            }\n+            match path_ {\n+                None => s.push_str(path),\n+                Some(p) => s.push_str(p)\n+            };\n+            me.update_normalized(s)\n+        }\n+\n+        if !path.is_empty() {\n+            let prefix = parse_prefix(path);\n+            match prefix {\n+                Some(DiskPrefix) if !is_vol_abs(path, prefix) && shares_volume(self, path) => {\n+                    // cwd-relative path, self is on the same volume\n+                    append_path(self, path.slice_from(prefix_len(prefix)));\n+                }\n+                Some(_) => {\n+                    // absolute path, or cwd-relative and self is not same volume\n+                    replace_path(self, path, prefix);\n+                }\n+                None if !path.is_empty() && is_sep_(self.prefix, path[0]) => {\n+                    // volume-relative path\n+                    if self.prefix().is_some() {\n+                        // truncate self down to the prefix, then append\n+                        let n = self.prefix_len();\n+                        self.repr.truncate(n);\n+                        append_path(self, path);\n+                    } else {\n+                        // we have no prefix, so nothing to be relative to\n+                        replace_path(self, path, prefix);\n+                    }\n+                }\n+                None => {\n+                    // relative path\n+                    append_path(self, path);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl GenericPath for Path {\n+    /// See `GenericPath::as_str` for info.\n+    /// Always returns a `Some` value.\n+    #[inline]\n+    fn as_str<'a>(&'a self) -> Option<&'a str> {\n+        Some(self.repr.as_slice())\n+    }\n+\n+    #[inline]\n+    fn as_vec<'a>(&'a self) -> &'a [u8] {\n+        self.repr.as_bytes()\n+    }\n+\n+    #[inline]\n+    fn dirname<'a>(&'a self) -> &'a [u8] {\n+        self.dirname_str().unwrap().as_bytes()\n+    }\n+\n+    /// See `GenericPath::dirname_str` for info.\n+    /// Always returns a `Some` value.\n+    fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n+        Some(match self.sepidx_or_prefix_len() {\n+            None if \"..\" == self.repr => self.repr.as_slice(),\n+            None => \".\",\n+            Some((_,idxa,end)) if self.repr.slice(idxa, end) == \"..\" => {\n+                self.repr.as_slice()\n+            }\n+            Some((idxb,_,end)) if self.repr.slice(idxb, end) == \"\\\\\" => {\n+                self.repr.as_slice()\n+            }\n+            Some((0,idxa,_)) => self.repr.slice_to(idxa),\n+            Some((idxb,idxa,_)) => {\n+                match self.prefix {\n+                    Some(DiskPrefix) | Some(VerbatimDiskPrefix) if idxb == self.prefix_len() => {\n+                        self.repr.slice_to(idxa)\n+                    }\n+                    _ => self.repr.slice_to(idxb)\n+                }\n+            }\n+        })\n+    }\n+\n+    #[inline]\n+    fn filename<'a>(&'a self) -> &'a [u8] {\n+        self.filename_str().unwrap().as_bytes()\n+    }\n+\n+    /// See `GenericPath::filename_str` for info.\n+    /// Always returns a `Some` value.\n+    fn filename_str<'a>(&'a self) -> Option<&'a str> {\n+        Some(match self.sepidx_or_prefix_len() {\n+            None if \".\" == self.repr || \"..\" == self.repr => \"\",\n+            None => self.repr.as_slice(),\n+            Some((_,idxa,end)) if self.repr.slice(idxa, end) == \"..\" => \"\",\n+            Some((_,idxa,end)) => self.repr.slice(idxa, end)\n+        })\n+    }\n+\n+    /// See `GenericPath::filestem_str` for info.\n+    /// Always returns a `Some` value.\n+    #[inline]\n+    fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n+        // filestem() returns a byte vector that's guaranteed valid UTF-8\n+        Some(unsafe { cast::transmute(self.filestem()) })\n+    }\n+\n+    #[inline]\n+    fn extension_str<'a>(&'a self) -> Option<&'a str> {\n+        // extension() returns a byte vector that's guaranteed valid UTF-8\n+        self.extension().map_move(|v| unsafe { cast::transmute(v) })\n+    }\n+\n+    fn dir_path(&self) -> Path {\n+        unsafe { GenericPathUnsafe::from_str_unchecked(self.dirname_str().unwrap()) }\n+    }\n+\n+    fn file_path(&self) -> Option<Path> {\n+        match self.filename_str() {\n+            None | Some(\"\") => None,\n+            Some(s) => Some(unsafe { GenericPathUnsafe::from_str_unchecked(s) })\n+        }\n+    }\n+\n+    #[inline]\n+    fn push_path(&mut self, path: &Path) {\n+        self.push_str(path.as_str().unwrap())\n+    }\n+\n+    #[inline]\n+    fn pop_opt(&mut self) -> Option<~[u8]> {\n+        self.pop_opt_str().map_move(|s| s.into_bytes())\n+    }\n+\n+    fn pop_opt_str(&mut self) -> Option<~str> {\n+        match self.sepidx_or_prefix_len() {\n+            None if \".\" == self.repr => None,\n+            None => {\n+                let mut s = ~\".\";\n+                util::swap(&mut s, &mut self.repr);\n+                self.sepidx = None;\n+                Some(s)\n+            }\n+            Some((idxb,idxa,end)) if idxb == idxa && idxb == end => None,\n+            Some((idxb,_,end)) if self.repr.slice(idxb, end) == \"\\\\\" => None,\n+            Some((idxb,idxa,end)) => {\n+                let s = self.repr.slice(idxa, end).to_owned();\n+                let trunc = match self.prefix {\n+                    Some(DiskPrefix) | Some(VerbatimDiskPrefix) | None => {\n+                        let plen = self.prefix_len();\n+                        if idxb == plen { idxa } else { idxb }\n+                    }\n+                    _ => idxb\n+                };\n+                self.repr.truncate(trunc);\n+                self.update_sepidx();\n+                Some(s)\n+            }\n+        }\n+    }\n+\n+    /// See `GenericPath::is_absolute` for info.\n+    ///\n+    /// A Windows Path is considered absolute only if it has a non-volume prefix,\n+    /// or if it has a volume prefix and the path starts with '\\'.\n+    /// A path of `\\foo` is not considered absolute because it's actually\n+    /// relative to the \"current volume\". A separate method `Path::is_vol_relative`\n+    /// is provided to indicate this case. Similarly a path of `C:foo` is not\n+    /// considered absolute because it's relative to the cwd on volume C:. A\n+    /// separate method `Path::is_cwd_relative` is provided to indicate this case.\n+    #[inline]\n+    fn is_absolute(&self) -> bool {\n+        match self.prefix {\n+            Some(DiskPrefix) => {\n+                let rest = self.repr.slice_from(self.prefix_len());\n+                rest.len() > 0 && rest[0] == sep as u8\n+            }\n+            Some(_) => true,\n+            None => false\n+        }\n+    }\n+\n+    fn is_ancestor_of(&self, other: &Path) -> bool {\n+        if !self.equiv_prefix(other) {\n+            false\n+        } else if self.is_absolute() != other.is_absolute() ||\n+                  self.is_vol_relative() != other.is_vol_relative() {\n+            false\n+        } else {\n+            let mut ita = self.component_iter();\n+            let mut itb = other.component_iter();\n+            if \".\" == self.repr {\n+                return itb.next() != Some(\"..\");\n+            }\n+            loop {\n+                match (ita.next(), itb.next()) {\n+                    (None, _) => break,\n+                    (Some(a), Some(b)) if a == b => { loop },\n+                    (Some(a), _) if a == \"..\" => {\n+                        // if ita contains only .. components, it's an ancestor\n+                        return ita.all(|x| x == \"..\");\n+                    }\n+                    _ => return false\n+                }\n+            }\n+            true\n+        }\n+    }\n+\n+    fn path_relative_from(&self, base: &Path) -> Option<Path> {\n+        fn comp_requires_verbatim(s: &str) -> bool {\n+            s == \".\" || s == \"..\" || s.contains_char(sep2)\n+        }\n+\n+        if !self.equiv_prefix(base) {\n+            // prefixes differ\n+            if self.is_absolute() {\n+                Some(self.clone())\n+            } else if self.prefix == Some(DiskPrefix) && base.prefix == Some(DiskPrefix) {\n+                // both drives, drive letters must differ or they'd be equiv\n+                Some(self.clone())\n+            } else {\n+                None\n+            }\n+        } else if self.is_absolute() != base.is_absolute() {\n+            if self.is_absolute() {\n+                Some(self.clone())\n+            } else {\n+                None\n+            }\n+        } else if self.is_vol_relative() != base.is_vol_relative() {\n+            if self.is_vol_relative() {\n+                Some(self.clone())\n+            } else {\n+                None\n+            }\n+        } else {\n+            let mut ita = self.component_iter();\n+            let mut itb = base.component_iter();\n+            let mut comps = ~[];\n+\n+            let a_verb = self.is_verbatim();\n+            let b_verb = base.is_verbatim();\n+            loop {\n+                match (ita.next(), itb.next()) {\n+                    (None, None) => break,\n+                    (Some(a), None) if a_verb && comp_requires_verbatim(a) => {\n+                        return Some(self.clone())\n+                    }\n+                    (Some(a), None) => {\n+                        comps.push(a);\n+                        if !a_verb {\n+                            comps.extend(&mut ita);\n+                            break;\n+                        }\n+                    }\n+                    (None, _) => comps.push(\"..\"),\n+                    (Some(a), Some(b)) if comps.is_empty() && a == b => (),\n+                    (Some(a), Some(b)) if !b_verb && b == \".\" => {\n+                        if a_verb && comp_requires_verbatim(a) {\n+                            return Some(self.clone())\n+                        } else { comps.push(a) }\n+                    }\n+                    (Some(_), Some(b)) if !b_verb && b == \"..\" => return None,\n+                    (Some(a), Some(_)) if a_verb && comp_requires_verbatim(a) => {\n+                        return Some(self.clone())\n+                    }\n+                    (Some(a), Some(_)) => {\n+                        comps.push(\"..\");\n+                        for _ in itb {\n+                            comps.push(\"..\");\n+                        }\n+                        comps.push(a);\n+                        if !a_verb {\n+                            comps.extend(&mut ita);\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            Some(Path::from_str(comps.connect(\"\\\\\")))\n+        }\n+    }\n+}\n+\n+impl Path {\n+    /// Returns a new Path from a byte vector\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the vector contains a NUL.\n+    /// Raises the `str::not_utf8` condition if invalid UTF-8.\n+    #[inline]\n+    pub fn new(v: &[u8]) -> Path {\n+        GenericPath::from_vec(v)\n+    }\n+\n+    /// Returns a new Path from a string\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the vector contains a NUL.\n+    #[inline]\n+    pub fn from_str(s: &str) -> Path {\n+        GenericPath::from_str(s)\n+    }\n+\n+    /// Converts the Path into an owned byte vector\n+    pub fn into_vec(self) -> ~[u8] {\n+        self.repr.into_bytes()\n+    }\n+\n+    /// Converts the Path into an owned string\n+    /// Returns an Option for compatibility with posix::Path, but the\n+    /// return value will always be Some.\n+    pub fn into_str(self) -> Option<~str> {\n+        Some(self.repr)\n+    }\n+\n+    /// Returns a normalized string representation of a path, by removing all empty\n+    /// components, and unnecessary . and .. components.\n+    pub fn normalize<S: Str>(s: S) -> ~str {\n+        let (_, path) = Path::normalize_(s);\n+        path\n+    }\n+\n+    /// Returns an iterator that yields each component of the path in turn.\n+    /// Does not yield the path prefix (including server/share components in UNC paths).\n+    /// Does not distinguish between volume-relative and relative paths, e.g.\n+    /// \\a\\b\\c and a\\b\\c.\n+    /// Does not distinguish between absolute and cwd-relative paths, e.g.\n+    /// C:\\foo and C:foo.\n+    pub fn component_iter<'a>(&'a self) -> ComponentIter<'a> {\n+        let s = match self.prefix {\n+            Some(_) => {\n+                let plen = self.prefix_len();\n+                if self.repr.len() > plen && self.repr[plen] == sep as u8 {\n+                    self.repr.slice_from(plen+1)\n+                } else { self.repr.slice_from(plen) }\n+            }\n+            None if self.repr[0] == sep as u8 => self.repr.slice_from(1),\n+            None => self.repr.as_slice()\n+        };\n+        let ret = s.split_terminator_iter(sep);\n+        ret\n+    }\n+\n+    /// Returns whether the path is considered \"volume-relative\", which means a path\n+    /// that looks like \"\\foo\". Paths of this form are relative to the current volume,\n+    /// but absolute within that volume.\n+    #[inline]\n+    pub fn is_vol_relative(&self) -> bool {\n+        self.prefix.is_none() && self.repr[0] == sep as u8\n+    }\n+\n+    /// Returns whether the path is considered \"cwd-relative\", which means a path\n+    /// with a volume prefix that is not absolute. This look like \"C:foo.txt\". Paths\n+    /// of this form are relative to the cwd on the given volume.\n+    #[inline]\n+    pub fn is_cwd_relative(&self) -> bool {\n+        self.prefix == Some(DiskPrefix) && !self.is_absolute()\n+    }\n+\n+    /// Returns the PathPrefix for this Path\n+    #[inline]\n+    pub fn prefix(&self) -> Option<PathPrefix> {\n+        self.prefix\n+    }\n+\n+    /// Returns whether the prefix is a verbatim prefix, i.e. \\\\?\\\n+    #[inline]\n+    pub fn is_verbatim(&self) -> bool {\n+        prefix_is_verbatim(self.prefix)\n+    }\n+\n+    fn equiv_prefix(&self, other: &Path) -> bool {\n+        match (self.prefix, other.prefix) {\n+            (Some(DiskPrefix), Some(VerbatimDiskPrefix)) => {\n+                self.is_absolute() &&\n+                    self.repr[0].to_ascii().eq_ignore_case(other.repr[4].to_ascii())\n+            }\n+            (Some(VerbatimDiskPrefix), Some(DiskPrefix)) => {\n+                other.is_absolute() &&\n+                    self.repr[4].to_ascii().eq_ignore_case(other.repr[0].to_ascii())\n+            }\n+            (Some(VerbatimDiskPrefix), Some(VerbatimDiskPrefix)) => {\n+                self.repr[4].to_ascii().eq_ignore_case(other.repr[4].to_ascii())\n+            }\n+            (Some(UNCPrefix(_,_)), Some(VerbatimUNCPrefix(_,_))) => {\n+                self.repr.slice(2, self.prefix_len()) == other.repr.slice(8, other.prefix_len())\n+            }\n+            (Some(VerbatimUNCPrefix(_,_)), Some(UNCPrefix(_,_))) => {\n+                self.repr.slice(8, self.prefix_len()) == other.repr.slice(2, other.prefix_len())\n+            }\n+            (None, None) => true,\n+            (a, b) if a == b => {\n+                self.repr.slice_to(self.prefix_len()) == other.repr.slice_to(other.prefix_len())\n+            }\n+            _ => false\n+        }\n+    }\n+\n+    fn normalize_<S: Str>(s: S) -> (Option<PathPrefix>, ~str) {\n+        // make borrowck happy\n+        let (prefix, val) = {\n+            let prefix = parse_prefix(s.as_slice());\n+            let path = Path::normalize__(s.as_slice(), prefix);\n+            (prefix, path)\n+        };\n+        (prefix, match val {\n+            None => s.into_owned(),\n+            Some(val) => val\n+        })\n+    }\n+\n+    fn normalize__(s: &str, prefix: Option<PathPrefix>) -> Option<~str> {\n+        if prefix_is_verbatim(prefix) {\n+            // don't do any normalization\n+            match prefix {\n+                Some(VerbatimUNCPrefix(x, 0)) if s.len() == 8 + x => {\n+                    // the server component has no trailing '\\'\n+                    let mut s = s.into_owned();\n+                    s.push_char(sep);\n+                    Some(s)\n+                }\n+                _ => None\n+            }\n+        } else {\n+            let (is_abs, comps) = normalize_helper(s, prefix);\n+            let mut comps = comps;\n+            match (comps.is_some(),prefix) {\n+                (false, Some(DiskPrefix)) => {\n+                    if s[0] >= 'a' as u8 && s[0] <= 'z' as u8 {\n+                        comps = Some(~[]);\n+                    }\n+                }\n+                (false, Some(VerbatimDiskPrefix)) => {\n+                    if s[4] >= 'a' as u8 && s[0] <= 'z' as u8 {\n+                        comps = Some(~[]);\n+                    }\n+                }\n+                _ => ()\n+            }\n+            match comps {\n+                None => None,\n+                Some(comps) => {\n+                    if prefix.is_some() && comps.is_empty() {\n+                        match prefix.unwrap() {\n+                            DiskPrefix => {\n+                                let len = prefix_len(prefix) + is_abs as uint;\n+                                let mut s = s.slice_to(len).to_owned();\n+                                s[0] = s[0].to_ascii().to_upper().to_byte();\n+                                if is_abs {\n+                                    s[2] = sep as u8; // normalize C:/ to C:\\\n+                                }\n+                                Some(s)\n+                            }\n+                            VerbatimDiskPrefix => {\n+                                let len = prefix_len(prefix) + is_abs as uint;\n+                                let mut s = s.slice_to(len).to_owned();\n+                                s[4] = s[4].to_ascii().to_upper().to_byte();\n+                                Some(s)\n+                            }\n+                            _ => {\n+                                let plen = prefix_len(prefix);\n+                                if s.len() > plen {\n+                                    Some(s.slice_to(plen).to_owned())\n+                                } else { None }\n+                            }\n+                        }\n+                    } else if is_abs && comps.is_empty() {\n+                        Some(str::from_char(sep))\n+                    } else {\n+                        let prefix_ = s.slice_to(prefix_len(prefix));\n+                        let n = prefix_.len() +\n+                                if is_abs { comps.len() } else { comps.len() - 1} +\n+                                comps.iter().map(|v| v.len()).sum();\n+                        let mut s = str::with_capacity(n);\n+                        match prefix {\n+                            Some(DiskPrefix) => {\n+                                s.push_char(prefix_[0].to_ascii().to_upper().to_char());\n+                                s.push_char(':');\n+                            }\n+                            Some(VerbatimDiskPrefix) => {\n+                                s.push_str(prefix_.slice_to(4));\n+                                s.push_char(prefix_[4].to_ascii().to_upper().to_char());\n+                                s.push_str(prefix_.slice_from(5));\n+                            }\n+                            Some(UNCPrefix(a,b)) => {\n+                                s.push_str(\"\\\\\\\\\");\n+                                s.push_str(prefix_.slice(2, a+2));\n+                                s.push_char(sep);\n+                                s.push_str(prefix_.slice(3+a, 3+a+b));\n+                            }\n+                            Some(_) => s.push_str(prefix_),\n+                            None => ()\n+                        }\n+                        let mut it = comps.move_iter();\n+                        if !is_abs {\n+                            match it.next() {\n+                                None => (),\n+                                Some(comp) => s.push_str(comp)\n+                            }\n+                        }\n+                        for comp in it {\n+                            s.push_char(sep);\n+                            s.push_str(comp);\n+                        }\n+                        Some(s)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn update_sepidx(&mut self) {\n+        let s = if self.has_nonsemantic_trailing_slash() {\n+                    self.repr.slice_to(self.repr.len()-1)\n+                } else { self.repr.as_slice() };\n+        let idx = s.rfind(if !prefix_is_verbatim(self.prefix) { is_sep2 }\n+                          else { is_sep });\n+        let prefixlen = self.prefix_len();\n+        self.sepidx = idx.and_then(|x| if x < prefixlen { None } else { Some(x) });\n+    }\n+\n+    fn prefix_len(&self) -> uint {\n+        prefix_len(self.prefix)\n+    }\n+\n+    // Returns a tuple (before, after, end) where before is the index of the separator\n+    // and after is the index just after the separator.\n+    // end is the length of the string, normally, or the index of the final character if it is\n+    // a non-semantic trailing separator in a verbatim string.\n+    // If the prefix is considered the separator, before and after are the same.\n+    fn sepidx_or_prefix_len(&self) -> Option<(uint,uint,uint)> {\n+        match self.sepidx {\n+            None => match self.prefix_len() { 0 => None, x => Some((x,x,self.repr.len())) },\n+            Some(x) => {\n+                if self.has_nonsemantic_trailing_slash() {\n+                    Some((x,x+1,self.repr.len()-1))\n+                } else { Some((x,x+1,self.repr.len())) }\n+            }\n+        }\n+    }\n+\n+    fn has_nonsemantic_trailing_slash(&self) -> bool {\n+        self.is_verbatim() && self.repr.len() > self.prefix_len()+1 &&\n+            self.repr[self.repr.len()-1] == sep as u8\n+    }\n+\n+    fn update_normalized<S: Str>(&mut self, s: S) {\n+        let (prefix, path) = Path::normalize_(s);\n+        self.repr = path;\n+        self.prefix = prefix;\n+        self.update_sepidx();\n+    }\n+}\n+\n /// The standard path separator character\n-pub static sep: u8 = '\\\\' as u8;\n+pub static sep: char = '\\\\';\n /// The alternative path separator character\n-pub static sep2: u8 = '/' as u8;\n+pub static sep2: char = '/';\n+\n+/// Returns whether the given byte is a path separator.\n+/// Only allows the primary separator '\\'; use is_sep2 to allow '/'.\n+#[inline]\n+pub fn is_sep(c: char) -> bool {\n+    c == sep\n+}\n \n-/// Returns whether the given byte is a path separator\n+/// Returns whether the given byte is a path separator.\n+/// Allows both the primary separator '\\' and the alternative separator '/'.\n #[inline]\n-pub fn is_sep(u: &u8) -> bool {\n-    *u == sep || *u == sep2\n+pub fn is_sep2(c: char) -> bool {\n+    c == sep || c == sep2\n+}\n+\n+/// Prefix types for Path\n+#[deriving(Eq, Clone, DeepClone)]\n+pub enum PathPrefix {\n+    /// Prefix `\\\\?\\`, uint is the length of the following component\n+    VerbatimPrefix(uint),\n+    /// Prefix `\\\\?\\UNC\\`, uints are the lengths of the UNC components\n+    VerbatimUNCPrefix(uint, uint),\n+    /// Prefix `\\\\?\\C:\\` (for any alphabetic character)\n+    VerbatimDiskPrefix,\n+    /// Prefix `\\\\.\\`, uint is the length of the following component\n+    DeviceNSPrefix(uint),\n+    /// UNC prefix `\\\\server\\share`, uints are the lengths of the server/share\n+    UNCPrefix(uint, uint),\n+    /// Prefix `C:` for any alphabetic character\n+    DiskPrefix\n+}\n+\n+/// Internal function; only public for tests. Don't use.\n+// FIXME (#8169): Make private once visibility is fixed\n+pub fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n+    if path.starts_with(\"\\\\\\\\\") {\n+        // \\\\\n+        path = path.slice_from(2);\n+        if path.starts_with(\"?\\\\\") {\n+            // \\\\?\\\n+            path = path.slice_from(2);\n+            if path.starts_with(\"UNC\\\\\") {\n+                // \\\\?\\UNC\\server\\share\n+                path = path.slice_from(4);\n+                let (idx_a, idx_b) = match parse_two_comps(path, is_sep) {\n+                    Some(x) => x,\n+                    None => (path.len(), 0)\n+                };\n+                return Some(VerbatimUNCPrefix(idx_a, idx_b));\n+            } else {\n+                // \\\\?\\path\n+                let idx = path.find('\\\\');\n+                if idx == Some(2) && path[1] == ':' as u8 {\n+                    let c = path[0];\n+                    if c.is_ascii() && ::char::is_alphabetic(c as char) {\n+                        // \\\\?\\C:\\ path\n+                        return Some(VerbatimDiskPrefix);\n+                    }\n+                }\n+                let idx = idx.unwrap_or(path.len());\n+                return Some(VerbatimPrefix(idx));\n+            }\n+        } else if path.starts_with(\".\\\\\") {\n+            // \\\\.\\path\n+            path = path.slice_from(2);\n+            let idx = path.find('\\\\').unwrap_or(path.len());\n+            return Some(DeviceNSPrefix(idx));\n+        }\n+        match parse_two_comps(path, is_sep2) {\n+            Some((idx_a, idx_b)) if idx_a > 0 && idx_b > 0 => {\n+                // \\\\server\\share\n+                return Some(UNCPrefix(idx_a, idx_b));\n+            }\n+            _ => ()\n+        }\n+    } else if path.len() > 1 && path[1] == ':' as u8 {\n+        // C:\n+        let c = path[0];\n+        if c.is_ascii() && ::char::is_alphabetic(c as char) {\n+            return Some(DiskPrefix);\n+        }\n+    }\n+    return None;\n+\n+    fn parse_two_comps<'a>(mut path: &'a str, f: &fn(char)->bool) -> Option<(uint, uint)> {\n+        let idx_a = match path.find(|x| f(x)) {\n+            None => return None,\n+            Some(x) => x\n+        };\n+        path = path.slice_from(idx_a+1);\n+        let idx_b = path.find(f).unwrap_or(path.len());\n+        Some((idx_a, idx_b))\n+    }\n+}\n+\n+// None result means the string didn't need normalizing\n+fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool,Option<~[&'a str]>) {\n+    let f = if !prefix_is_verbatim(prefix) { is_sep2 } else { is_sep };\n+    let is_abs = s.len() > prefix_len(prefix) && f(s.char_at(prefix_len(prefix)));\n+    let s_ = s.slice_from(prefix_len(prefix));\n+    let s_ = if is_abs { s_.slice_from(1) } else { s_ };\n+\n+    if is_abs && s_.is_empty() {\n+        return (is_abs, match prefix {\n+            Some(DiskPrefix) | None => (if is_sep(s.char_at(prefix_len(prefix))) { None }\n+                                        else { Some(~[]) }),\n+            Some(_) => Some(~[]), // need to trim the trailing separator\n+        });\n+    }\n+    let mut comps: ~[&'a str] = ~[];\n+    let mut n_up = 0u;\n+    let mut changed = false;\n+    for comp in s_.split_iter(f) {\n+        if comp.is_empty() { changed = true }\n+        else if comp == \".\" { changed = true }\n+        else if comp == \"..\" {\n+            let has_abs_prefix = match prefix {\n+                Some(DiskPrefix) => false,\n+                Some(_) => true,\n+                None => false\n+            };\n+            if (is_abs || has_abs_prefix) && comps.is_empty() { changed = true }\n+            else if comps.len() == n_up { comps.push(\"..\"); n_up += 1 }\n+            else { comps.pop_opt(); changed = true }\n+        } else { comps.push(comp) }\n+    }\n+    if !changed && !prefix_is_verbatim(prefix) {\n+        changed = s.find(is_sep2).is_some();\n+    }\n+    if changed {\n+        if comps.is_empty() && !is_abs && prefix.is_none() {\n+            if s == \".\" {\n+                return (is_abs, None);\n+            }\n+            comps.push(\".\");\n+        }\n+        (is_abs, Some(comps))\n+    } else {\n+        (is_abs, None)\n+    }\n+}\n+\n+// FIXME (#8169): Pull this into parent module once visibility works\n+#[inline(always)]\n+fn contains_nul(v: &[u8]) -> bool {\n+    v.iter().any(|&x| x == 0)\n+}\n+\n+fn prefix_is_verbatim(p: Option<PathPrefix>) -> bool {\n+    match p {\n+        Some(VerbatimPrefix(_)) | Some(VerbatimUNCPrefix(_,_)) | Some(VerbatimDiskPrefix) => true,\n+        Some(DeviceNSPrefix(_)) => true, // not really sure, but I think so\n+        _ => false\n+    }\n+}\n+\n+fn prefix_len(p: Option<PathPrefix>) -> uint {\n+    match p {\n+        None => 0,\n+        Some(VerbatimPrefix(x)) => 4 + x,\n+        Some(VerbatimUNCPrefix(x,y)) => 8 + x + 1 + y,\n+        Some(VerbatimDiskPrefix) => 6,\n+        Some(UNCPrefix(x,y)) => 2 + x + 1 + y,\n+        Some(DeviceNSPrefix(x)) => 4 + x,\n+        Some(DiskPrefix) => 2\n+    }\n+}\n+\n+fn prefix_is_sep(p: Option<PathPrefix>, c: u8) -> bool {\n+    c.is_ascii() && if !prefix_is_verbatim(p) { is_sep2(c as char) }\n+                    else { is_sep(c as char) }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use option::{Some,None};\n+    use iter::Iterator;\n+    use vec::Vector;\n+\n+    macro_rules! t(\n+        (s: $path:expr, $exp:expr) => (\n+            {\n+                let path = $path;\n+                assert_eq!(path.as_str(), Some($exp));\n+            }\n+        );\n+        (v: $path:expr, $exp:expr) => (\n+            {\n+                let path = $path;\n+                assert_eq!(path.as_vec(), $exp);\n+            }\n+        )\n+    )\n+\n+    macro_rules! b(\n+        ($($arg:expr),+) => (\n+            bytes!($($arg),+)\n+        )\n+    )\n+\n+    #[test]\n+    fn test_parse_prefix() {\n+        macro_rules! t(\n+            ($path:expr, $exp:expr) => (\n+                {\n+                    let path = $path;\n+                    let exp = $exp;\n+                    let res = parse_prefix(path);\n+                    assert!(res == exp,\n+                            \"parse_prefix(\\\"%s\\\"): expected %?, found %?\", path, exp, res);\n+                }\n+            )\n+        )\n+\n+        t!(\"\\\\\\\\SERVER\\\\share\\\\foo\", Some(UNCPrefix(6,5)));\n+        t!(\"\\\\\\\\\", None);\n+        t!(\"\\\\\\\\SERVER\", None);\n+        t!(\"\\\\\\\\SERVER\\\\\", None);\n+        t!(\"\\\\\\\\SERVER\\\\\\\\\", None);\n+        t!(\"\\\\\\\\SERVER\\\\\\\\foo\", None);\n+        t!(\"\\\\\\\\SERVER\\\\share\", Some(UNCPrefix(6,5)));\n+        t!(\"\\\\\\\\SERVER/share/foo\", Some(UNCPrefix(6,5)));\n+        t!(\"\\\\\\\\SERVER\\\\share/foo\", Some(UNCPrefix(6,5)));\n+        t!(\"//SERVER/share/foo\", None);\n+        t!(\"\\\\\\\\\\\\a\\\\b\\\\c\", None);\n+        t!(\"\\\\\\\\?\\\\a\\\\b\\\\c\", Some(VerbatimPrefix(1)));\n+        t!(\"\\\\\\\\?\\\\a/b/c\", Some(VerbatimPrefix(5)));\n+        t!(\"//?/a/b/c\", None);\n+        t!(\"\\\\\\\\.\\\\a\\\\b\", Some(DeviceNSPrefix(1)));\n+        t!(\"\\\\\\\\.\\\\a/b\", Some(DeviceNSPrefix(3)));\n+        t!(\"//./a/b\", None);\n+        t!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\", Some(VerbatimUNCPrefix(6,5)));\n+        t!(\"\\\\\\\\?\\\\UNC\\\\\\\\share\\\\foo\", Some(VerbatimUNCPrefix(0,5)));\n+        t!(\"\\\\\\\\?\\\\UNC\\\\\", Some(VerbatimUNCPrefix(0,0)));\n+        t!(\"\\\\\\\\?\\\\UNC\\\\server/share/foo\", Some(VerbatimUNCPrefix(16,0)));\n+        t!(\"\\\\\\\\?\\\\UNC\\\\server\", Some(VerbatimUNCPrefix(6,0)));\n+        t!(\"\\\\\\\\?\\\\UNC\\\\server\\\\\", Some(VerbatimUNCPrefix(6,0)));\n+        t!(\"\\\\\\\\?\\\\UNC/server/share\", Some(VerbatimPrefix(16)));\n+        t!(\"\\\\\\\\?\\\\UNC\", Some(VerbatimPrefix(3)));\n+        t!(\"\\\\\\\\?\\\\C:\\\\a\\\\b.txt\", Some(VerbatimDiskPrefix));\n+        t!(\"\\\\\\\\?\\\\z:\\\\\", Some(VerbatimDiskPrefix));\n+        t!(\"\\\\\\\\?\\\\C:\", Some(VerbatimPrefix(2)));\n+        t!(\"\\\\\\\\?\\\\C:a.txt\", Some(VerbatimPrefix(7)));\n+        t!(\"\\\\\\\\?\\\\C:a\\\\b.txt\", Some(VerbatimPrefix(3)));\n+        t!(\"\\\\\\\\?\\\\C:/a\", Some(VerbatimPrefix(4)));\n+        t!(\"C:\\\\foo\", Some(DiskPrefix));\n+        t!(\"z:/foo\", Some(DiskPrefix));\n+        t!(\"d:\", Some(DiskPrefix));\n+        t!(\"ab:\", None);\n+        t!(\"\u00fc:\\\\foo\", None);\n+        t!(\"3:\\\\foo\", None);\n+        t!(\" :\\\\foo\", None);\n+        t!(\"::\\\\foo\", None);\n+        t!(\"\\\\\\\\?\\\\C:\", Some(VerbatimPrefix(2)));\n+        t!(\"\\\\\\\\?\\\\z:\\\\\", Some(VerbatimDiskPrefix));\n+        t!(\"\\\\\\\\?\\\\ab:\\\\\", Some(VerbatimPrefix(3)));\n+        t!(\"\\\\\\\\?\\\\C:\\\\a\", Some(VerbatimDiskPrefix));\n+        t!(\"\\\\\\\\?\\\\C:/a\", Some(VerbatimPrefix(4)));\n+        t!(\"\\\\\\\\?\\\\C:\\\\a/b\", Some(VerbatimDiskPrefix));\n+    }\n+\n+    #[test]\n+    fn test_paths() {\n+        t!(v: Path::new([]), b!(\".\"));\n+        t!(v: Path::new(b!(\"\\\\\")), b!(\"\\\\\"));\n+        t!(v: Path::new(b!(\"a\\\\b\\\\c\")), b!(\"a\\\\b\\\\c\"));\n+\n+        t!(s: Path::from_str(\"\"), \".\");\n+        t!(s: Path::from_str(\"\\\\\"), \"\\\\\");\n+        t!(s: Path::from_str(\"hi\"), \"hi\");\n+        t!(s: Path::from_str(\"hi\\\\\"), \"hi\");\n+        t!(s: Path::from_str(\"\\\\lib\"), \"\\\\lib\");\n+        t!(s: Path::from_str(\"\\\\lib\\\\\"), \"\\\\lib\");\n+        t!(s: Path::from_str(\"hi\\\\there\"), \"hi\\\\there\");\n+        t!(s: Path::from_str(\"hi\\\\there.txt\"), \"hi\\\\there.txt\");\n+        t!(s: Path::from_str(\"/\"), \"\\\\\");\n+        t!(s: Path::from_str(\"hi/\"), \"hi\");\n+        t!(s: Path::from_str(\"/lib\"), \"\\\\lib\");\n+        t!(s: Path::from_str(\"/lib/\"), \"\\\\lib\");\n+        t!(s: Path::from_str(\"hi/there\"), \"hi\\\\there\");\n+\n+        t!(s: Path::from_str(\"hi\\\\there\\\\\"), \"hi\\\\there\");\n+        t!(s: Path::from_str(\"hi\\\\..\\\\there\"), \"there\");\n+        t!(s: Path::from_str(\"hi/../there\"), \"there\");\n+        t!(s: Path::from_str(\"..\\\\hi\\\\there\"), \"..\\\\hi\\\\there\");\n+        t!(s: Path::from_str(\"\\\\..\\\\hi\\\\there\"), \"\\\\hi\\\\there\");\n+        t!(s: Path::from_str(\"/../hi/there\"), \"\\\\hi\\\\there\");\n+        t!(s: Path::from_str(\"foo\\\\..\"), \".\");\n+        t!(s: Path::from_str(\"\\\\foo\\\\..\"), \"\\\\\");\n+        t!(s: Path::from_str(\"\\\\foo\\\\..\\\\..\"), \"\\\\\");\n+        t!(s: Path::from_str(\"\\\\foo\\\\..\\\\..\\\\bar\"), \"\\\\bar\");\n+        t!(s: Path::from_str(\"\\\\.\\\\hi\\\\.\\\\there\\\\.\"), \"\\\\hi\\\\there\");\n+        t!(s: Path::from_str(\"\\\\.\\\\hi\\\\.\\\\there\\\\.\\\\..\"), \"\\\\hi\");\n+        t!(s: Path::from_str(\"foo\\\\..\\\\..\"), \"..\");\n+        t!(s: Path::from_str(\"foo\\\\..\\\\..\\\\..\"), \"..\\\\..\");\n+        t!(s: Path::from_str(\"foo\\\\..\\\\..\\\\bar\"), \"..\\\\bar\");\n+\n+        assert_eq!(Path::new(b!(\"foo\\\\bar\")).into_vec(), b!(\"foo\\\\bar\").to_owned());\n+        assert_eq!(Path::new(b!(\"\\\\foo\\\\..\\\\..\\\\bar\")).into_vec(),\n+                   b!(\"\\\\bar\").to_owned());\n+        assert_eq!(Path::from_str(\"foo\\\\bar\").into_str(), Some(~\"foo\\\\bar\"));\n+        assert_eq!(Path::from_str(\"\\\\foo\\\\..\\\\..\\\\bar\").into_str(), Some(~\"\\\\bar\"));\n+\n+        t!(s: Path::from_str(\"\\\\\\\\a\"), \"\\\\a\");\n+        t!(s: Path::from_str(\"\\\\\\\\a\\\\\"), \"\\\\a\");\n+        t!(s: Path::from_str(\"\\\\\\\\a\\\\b\"), \"\\\\\\\\a\\\\b\");\n+        t!(s: Path::from_str(\"\\\\\\\\a\\\\b\\\\\"), \"\\\\\\\\a\\\\b\");\n+        t!(s: Path::from_str(\"\\\\\\\\a\\\\b/\"), \"\\\\\\\\a\\\\b\");\n+        t!(s: Path::from_str(\"\\\\\\\\\\\\b\"), \"\\\\b\");\n+        t!(s: Path::from_str(\"\\\\\\\\a\\\\\\\\b\"), \"\\\\a\\\\b\");\n+        t!(s: Path::from_str(\"\\\\\\\\a\\\\b\\\\c\"), \"\\\\\\\\a\\\\b\\\\c\");\n+        t!(s: Path::from_str(\"\\\\\\\\server\\\\share/path\"), \"\\\\\\\\server\\\\share\\\\path\");\n+        t!(s: Path::from_str(\"\\\\\\\\server/share/path\"), \"\\\\\\\\server\\\\share\\\\path\");\n+        t!(s: Path::from_str(\"C:a\\\\b.txt\"), \"C:a\\\\b.txt\");\n+        t!(s: Path::from_str(\"C:a/b.txt\"), \"C:a\\\\b.txt\");\n+        t!(s: Path::from_str(\"z:\\\\a\\\\b.txt\"), \"Z:\\\\a\\\\b.txt\");\n+        t!(s: Path::from_str(\"z:/a/b.txt\"), \"Z:\\\\a\\\\b.txt\");\n+        t!(s: Path::from_str(\"ab:/a/b.txt\"), \"ab:\\\\a\\\\b.txt\");\n+        t!(s: Path::from_str(\"C:\\\\\"), \"C:\\\\\");\n+        t!(s: Path::from_str(\"C:\"), \"C:\");\n+        t!(s: Path::from_str(\"q:\"), \"Q:\");\n+        t!(s: Path::from_str(\"C:/\"), \"C:\\\\\");\n+        t!(s: Path::from_str(\"C:\\\\foo\\\\..\"), \"C:\\\\\");\n+        t!(s: Path::from_str(\"C:foo\\\\..\"), \"C:\");\n+        t!(s: Path::from_str(\"C:\\\\a\\\\\"), \"C:\\\\a\");\n+        t!(s: Path::from_str(\"C:\\\\a/\"), \"C:\\\\a\");\n+        t!(s: Path::from_str(\"C:\\\\a\\\\b\\\\\"), \"C:\\\\a\\\\b\");\n+        t!(s: Path::from_str(\"C:\\\\a\\\\b/\"), \"C:\\\\a\\\\b\");\n+        t!(s: Path::from_str(\"C:a\\\\\"), \"C:a\");\n+        t!(s: Path::from_str(\"C:a/\"), \"C:a\");\n+        t!(s: Path::from_str(\"C:a\\\\b\\\\\"), \"C:a\\\\b\");\n+        t!(s: Path::from_str(\"C:a\\\\b/\"), \"C:a\\\\b\");\n+        t!(s: Path::from_str(\"\\\\\\\\?\\\\z:\\\\a\\\\b.txt\"), \"\\\\\\\\?\\\\z:\\\\a\\\\b.txt\");\n+        t!(s: Path::from_str(\"\\\\\\\\?\\\\C:/a/b.txt\"), \"\\\\\\\\?\\\\C:/a/b.txt\");\n+        t!(s: Path::from_str(\"\\\\\\\\?\\\\C:\\\\a/b.txt\"), \"\\\\\\\\?\\\\C:\\\\a/b.txt\");\n+        t!(s: Path::from_str(\"\\\\\\\\?\\\\test\\\\a\\\\b.txt\"), \"\\\\\\\\?\\\\test\\\\a\\\\b.txt\");\n+        t!(s: Path::from_str(\"\\\\\\\\?\\\\foo\\\\bar\\\\\"), \"\\\\\\\\?\\\\foo\\\\bar\\\\\");\n+        t!(s: Path::from_str(\"\\\\\\\\.\\\\foo\\\\bar\"), \"\\\\\\\\.\\\\foo\\\\bar\");\n+        t!(s: Path::from_str(\"\\\\\\\\.\\\\\"), \"\\\\\\\\.\\\\\");\n+        t!(s: Path::from_str(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\"), \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\");\n+        t!(s: Path::from_str(\"\\\\\\\\?\\\\UNC\\\\server/share\"), \"\\\\\\\\?\\\\UNC\\\\server/share\\\\\");\n+        t!(s: Path::from_str(\"\\\\\\\\?\\\\UNC\\\\server\"), \"\\\\\\\\?\\\\UNC\\\\server\\\\\");\n+        t!(s: Path::from_str(\"\\\\\\\\?\\\\UNC\\\\\"), \"\\\\\\\\?\\\\UNC\\\\\\\\\");\n+        t!(s: Path::from_str(\"\\\\\\\\?\\\\UNC\"), \"\\\\\\\\?\\\\UNC\");\n+\n+        // I'm not sure whether \\\\.\\foo/bar should normalize to \\\\.\\foo\\bar\n+        // as information is sparse and this isn't really googleable.\n+        // I'm going to err on the side of not normalizing it, as this skips the filesystem\n+        t!(s: Path::from_str(\"\\\\\\\\.\\\\foo/bar\"), \"\\\\\\\\.\\\\foo/bar\");\n+        t!(s: Path::from_str(\"\\\\\\\\.\\\\foo\\\\bar\"), \"\\\\\\\\.\\\\foo\\\\bar\");\n+    }\n+\n+    #[test]\n+    fn test_null_byte() {\n+        use path2::null_byte::cond;\n+\n+        let mut handled = false;\n+        let mut p = do cond.trap(|v| {\n+            handled = true;\n+            assert_eq!(v.as_slice(), b!(\"foo\\\\bar\", 0));\n+            (b!(\"\\\\bar\").to_owned())\n+        }).inside {\n+            Path::new(b!(\"foo\\\\bar\", 0))\n+        };\n+        assert!(handled);\n+        assert_eq!(p.as_vec(), b!(\"\\\\bar\"));\n+\n+        handled = false;\n+        do cond.trap(|v| {\n+            handled = true;\n+            assert_eq!(v.as_slice(), b!(\"f\", 0, \"o\"));\n+            (b!(\"foo\").to_owned())\n+        }).inside {\n+            p.set_filename(b!(\"f\", 0, \"o\"))\n+        };\n+        assert!(handled);\n+        assert_eq!(p.as_vec(), b!(\"\\\\foo\"));\n+\n+        handled = false;\n+        do cond.trap(|v| {\n+            handled = true;\n+            assert_eq!(v.as_slice(), b!(\"null\\\\\", 0, \"\\\\byte\"));\n+            (b!(\"null\\\\byte\").to_owned())\n+        }).inside {\n+            p.set_dirname(b!(\"null\\\\\", 0, \"\\\\byte\"));\n+        };\n+        assert!(handled);\n+        assert_eq!(p.as_vec(), b!(\"null\\\\byte\\\\foo\"));\n+\n+        handled = false;\n+        do cond.trap(|v| {\n+            handled = true;\n+            assert_eq!(v.as_slice(), b!(\"f\", 0, \"o\"));\n+            (b!(\"foo\").to_owned())\n+        }).inside {\n+            p.push(b!(\"f\", 0, \"o\"));\n+        };\n+        assert!(handled);\n+        assert_eq!(p.as_vec(), b!(\"null\\\\byte\\\\foo\\\\foo\"));\n+    }\n+\n+    #[test]\n+    fn test_null_byte_fail() {\n+        use path2::null_byte::cond;\n+        use task;\n+\n+        macro_rules! t(\n+            ($name:expr => $code:block) => (\n+                {\n+                    let mut t = task::task();\n+                    t.supervised();\n+                    t.name($name);\n+                    let res = do t.try $code;\n+                    assert!(res.is_err());\n+                }\n+            )\n+        )\n+\n+        t!(~\"new() w\\\\nul\" => {\n+            do cond.trap(|_| {\n+                (b!(\"null\", 0).to_owned())\n+            }).inside {\n+                Path::new(b!(\"foo\\\\bar\", 0))\n+            };\n+        })\n+\n+        t!(~\"set_filename w\\\\nul\" => {\n+            let mut p = Path::new(b!(\"foo\\\\bar\"));\n+            do cond.trap(|_| {\n+                (b!(\"null\", 0).to_owned())\n+            }).inside {\n+                p.set_filename(b!(\"foo\", 0))\n+            };\n+        })\n+\n+        t!(~\"set_dirname w\\\\nul\" => {\n+            let mut p = Path::new(b!(\"foo\\\\bar\"));\n+            do cond.trap(|_| {\n+                (b!(\"null\", 0).to_owned())\n+            }).inside {\n+                p.set_dirname(b!(\"foo\", 0))\n+            };\n+        })\n+\n+        t!(~\"push w\\\\nul\" => {\n+            let mut p = Path::new(b!(\"foo\\\\bar\"));\n+            do cond.trap(|_| {\n+                (b!(\"null\", 0).to_owned())\n+            }).inside {\n+                p.push(b!(\"foo\", 0))\n+            };\n+        })\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_not_utf8_fail() {\n+        Path::new(b!(\"hello\", 0x80, \".txt\"));\n+    }\n+\n+    #[test]\n+    fn test_components() {\n+        macro_rules! t(\n+            (s: $path:expr, $op:ident, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    assert_eq!(path.$op(), Some($exp));\n+                }\n+            );\n+            (s: $path:expr, $op:ident, $exp:expr, opt) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let left = path.$op();\n+                    assert_eq!(left, $exp);\n+                }\n+            );\n+            (v: $path:expr, $op:ident, $exp:expr) => (\n+                {\n+                    let path = Path::new($path);\n+                    assert_eq!(path.$op(), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(v: b!(\"a\\\\b\\\\c\"), filename, b!(\"c\"));\n+        t!(s: \"a\\\\b\\\\c\", filename_str, \"c\");\n+        t!(s: \"\\\\a\\\\b\\\\c\", filename_str, \"c\");\n+        t!(s: \"a\", filename_str, \"a\");\n+        t!(s: \"\\\\a\", filename_str, \"a\");\n+        t!(s: \".\", filename_str, \"\");\n+        t!(s: \"\\\\\", filename_str, \"\");\n+        t!(s: \"..\", filename_str, \"\");\n+        t!(s: \"..\\\\..\", filename_str, \"\");\n+        t!(s: \"c:\\\\foo.txt\", filename_str, \"foo.txt\");\n+        t!(s: \"C:\\\\\", filename_str, \"\");\n+        t!(s: \"C:\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo.txt\", filename_str, \"foo.txt\");\n+        t!(s: \"\\\\\\\\server\\\\share\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\server\", filename_str, \"server\");\n+        t!(s: \"\\\\\\\\?\\\\bar\\\\foo.txt\", filename_str, \"foo.txt\");\n+        t!(s: \"\\\\\\\\?\\\\bar\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\?\\\\\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo.txt\", filename_str, \"foo.txt\");\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo.txt\", filename_str, \"foo.txt\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\?\\\\C:\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\?\\\\foo/bar\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\?\\\\C:/foo\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", filename_str, \"bar\");\n+        t!(s: \"\\\\\\\\.\\\\foo\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\.\\\\foo/bar\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar/baz\", filename_str, \"bar/baz\");\n+        t!(s: \"\\\\\\\\.\\\\\", filename_str, \"\");\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", filename_str, \"b\");\n+\n+        t!(v: b!(\"a\\\\b\\\\c\"), dirname, b!(\"a\\\\b\"));\n+        t!(s: \"a\\\\b\\\\c\", dirname_str, \"a\\\\b\");\n+        t!(s: \"\\\\a\\\\b\\\\c\", dirname_str, \"\\\\a\\\\b\");\n+        t!(s: \"a\", dirname_str, \".\");\n+        t!(s: \"\\\\a\", dirname_str, \"\\\\\");\n+        t!(s: \".\", dirname_str, \".\");\n+        t!(s: \"\\\\\", dirname_str, \"\\\\\");\n+        t!(s: \"..\", dirname_str, \"..\");\n+        t!(s: \"..\\\\..\", dirname_str, \"..\\\\..\");\n+        t!(s: \"c:\\\\foo.txt\", dirname_str, \"C:\\\\\");\n+        t!(s: \"C:\\\\\", dirname_str, \"C:\\\\\");\n+        t!(s: \"C:\", dirname_str, \"C:\");\n+        t!(s: \"C:foo.txt\", dirname_str, \"C:\");\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo.txt\", dirname_str, \"\\\\\\\\server\\\\share\");\n+        t!(s: \"\\\\\\\\server\\\\share\", dirname_str, \"\\\\\\\\server\\\\share\");\n+        t!(s: \"\\\\\\\\server\", dirname_str, \"\\\\\");\n+        t!(s: \"\\\\\\\\?\\\\bar\\\\foo.txt\", dirname_str, \"\\\\\\\\?\\\\bar\");\n+        t!(s: \"\\\\\\\\?\\\\bar\", dirname_str, \"\\\\\\\\?\\\\bar\");\n+        t!(s: \"\\\\\\\\?\\\\\", dirname_str, \"\\\\\\\\?\\\\\");\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo.txt\", dirname_str, \"\\\\\\\\?\\\\UNC\\\\server\\\\share\");\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\", dirname_str, \"\\\\\\\\?\\\\UNC\\\\server\\\\\");\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\\", dirname_str, \"\\\\\\\\?\\\\UNC\\\\\\\\\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo.txt\", dirname_str, \"\\\\\\\\?\\\\C:\\\\\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\\", dirname_str, \"\\\\\\\\?\\\\C:\\\\\");\n+        t!(s: \"\\\\\\\\?\\\\C:\", dirname_str, \"\\\\\\\\?\\\\C:\");\n+        t!(s: \"\\\\\\\\?\\\\C:/foo/bar\", dirname_str, \"\\\\\\\\?\\\\C:/foo/bar\");\n+        t!(s: \"\\\\\\\\?\\\\foo/bar\", dirname_str, \"\\\\\\\\?\\\\foo/bar\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", dirname_str, \"\\\\\\\\.\\\\foo\");\n+        t!(s: \"\\\\\\\\.\\\\foo\", dirname_str, \"\\\\\\\\.\\\\foo\");\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", dirname_str, \"\\\\\\\\?\\\\a\");\n+\n+        t!(v: b!(\"hi\\\\there.txt\"), filestem, b!(\"there\"));\n+        t!(s: \"hi\\\\there.txt\", filestem_str, \"there\");\n+        t!(s: \"hi\\\\there\", filestem_str, \"there\");\n+        t!(s: \"there.txt\", filestem_str, \"there\");\n+        t!(s: \"there\", filestem_str, \"there\");\n+        t!(s: \".\", filestem_str, \"\");\n+        t!(s: \"\\\\\", filestem_str, \"\");\n+        t!(s: \"foo\\\\.bar\", filestem_str, \".bar\");\n+        t!(s: \".bar\", filestem_str, \".bar\");\n+        t!(s: \"..bar\", filestem_str, \".\");\n+        t!(s: \"hi\\\\there..txt\", filestem_str, \"there.\");\n+        t!(s: \"..\", filestem_str, \"\");\n+        t!(s: \"..\\\\..\", filestem_str, \"\");\n+        // filestem is based on filename, so we don't need the full set of prefix tests\n+\n+        t!(v: b!(\"hi\\\\there.txt\"), extension, Some(b!(\"txt\")));\n+        t!(v: b!(\"hi\\\\there\"), extension, None);\n+        t!(s: \"hi\\\\there.txt\", extension_str, Some(\"txt\"), opt);\n+        t!(s: \"hi\\\\there\", extension_str, None, opt);\n+        t!(s: \"there.txt\", extension_str, Some(\"txt\"), opt);\n+        t!(s: \"there\", extension_str, None, opt);\n+        t!(s: \".\", extension_str, None, opt);\n+        t!(s: \"\\\\\", extension_str, None, opt);\n+        t!(s: \"foo\\\\.bar\", extension_str, None, opt);\n+        t!(s: \".bar\", extension_str, None, opt);\n+        t!(s: \"..bar\", extension_str, Some(\"bar\"), opt);\n+        t!(s: \"hi\\\\there..txt\", extension_str, Some(\"txt\"), opt);\n+        t!(s: \"..\", extension_str, None, opt);\n+        t!(s: \"..\\\\..\", extension_str, None, opt);\n+        // extension is based on filename, so we don't need the full set of prefix tests\n+    }\n+\n+    #[test]\n+    fn test_push() {\n+        macro_rules! t(\n+            (s: $path:expr, $join:expr) => (\n+                {\n+                    let path = ($path);\n+                    let join = ($join);\n+                    let mut p1 = Path::from_str(path);\n+                    let p2 = p1.clone();\n+                    p1.push_str(join);\n+                    assert_eq!(p1, p2.join_str(join));\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a\\\\b\\\\c\", \"..\");\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"d\");\n+        t!(s: \"a\\\\b\", \"c\\\\d\");\n+        t!(s: \"a\\\\b\", \"\\\\c\\\\d\");\n+        // this is just a sanity-check test. push_str and join_str share an implementation,\n+        // so there's no need for the full set of prefix tests\n+\n+        // we do want to check one odd case though to ensure the prefix is re-parsed\n+        let mut p = Path::from_str(\"\\\\\\\\?\\\\C:\");\n+        assert_eq!(p.prefix(), Some(VerbatimPrefix(2)));\n+        p.push_str(\"foo\");\n+        assert_eq!(p.prefix(), Some(VerbatimDiskPrefix));\n+        assert_eq!(p.as_str(), Some(\"\\\\\\\\?\\\\C:\\\\foo\"));\n+\n+        // and another with verbatim non-normalized paths\n+        let mut p = Path::from_str(\"\\\\\\\\?\\\\C:\\\\a\\\\\");\n+        p.push_str(\"foo\");\n+        assert_eq!(p.as_str(), Some(\"\\\\\\\\?\\\\C:\\\\a\\\\foo\"));\n+    }\n+\n+    #[test]\n+    fn test_push_path() {\n+        macro_rules! t(\n+            (s: $path:expr, $push:expr, $exp:expr) => (\n+                {\n+                    let mut p = Path::from_str($path);\n+                    let push = Path::from_str($push);\n+                    p.push_path(&push);\n+                    assert_eq!(p.as_str(), Some($exp));\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a\\\\b\\\\c\", \"d\", \"a\\\\b\\\\c\\\\d\");\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n+        t!(s: \"a\\\\b\", \"c\\\\d\", \"a\\\\b\\\\c\\\\d\");\n+        t!(s: \"a\\\\b\", \"\\\\c\\\\d\", \"\\\\c\\\\d\");\n+        t!(s: \"a\\\\b\", \".\", \"a\\\\b\");\n+        t!(s: \"a\\\\b\", \"..\\\\c\", \"a\\\\c\");\n+        t!(s: \"a\\\\b\", \"C:a.txt\", \"C:a.txt\");\n+        t!(s: \"a\\\\b\", \"..\\\\..\\\\..\\\\c\", \"..\\\\c\");\n+        t!(s: \"a\\\\b\", \"C:\\\\a.txt\", \"C:\\\\a.txt\");\n+        t!(s: \"C:\\\\a\", \"C:\\\\b.txt\", \"C:\\\\b.txt\");\n+        t!(s: \"C:\\\\a\\\\b\\\\c\", \"C:d\", \"C:\\\\a\\\\b\\\\c\\\\d\");\n+        t!(s: \"C:a\\\\b\\\\c\", \"C:d\", \"C:a\\\\b\\\\c\\\\d\");\n+        t!(s: \"C:a\\\\b\", \"..\\\\..\\\\..\\\\c\", \"C:..\\\\c\");\n+        t!(s: \"C:\\\\a\\\\b\", \"..\\\\..\\\\..\\\\c\", \"C:\\\\c\");\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\server\\\\share\\\\foo\\\\bar\");\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", \"..\\\\..\\\\bar\", \"\\\\\\\\server\\\\share\\\\bar\");\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", \"C:baz\", \"C:baz\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:c\\\\d\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\\\\c\\\\d\");\n+        t!(s: \"\\\\\\\\?\\\\C:a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:\\\\c\\\\d\", \"C:\\\\c\\\\d\");\n+        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"..\\\\..\\\\..\\\\c\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\\\\..\\\\..\\\\..\\\\c\");\n+        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", \"..\\\\..\\\\c\", \"\\\\\\\\?\\\\foo\\\\bar\\\\..\\\\..\\\\c\");\n+        t!(s: \"\\\\\\\\?\\\\\", \"foo\", \"\\\\\\\\?\\\\\\\\foo\");\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\\\\bar\");\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:\\\\a\", \"C:\\\\a\");\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:a\", \"C:a\");\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\", \"foo\", \"\\\\\\\\?\\\\UNC\\\\server\\\\\\\\foo\");\n+        t!(s: \"C:\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", \"C:a\", \"C:a\");\n+        // again, not sure about the following, but I'm assuming \\\\.\\ should be verbatim\n+        t!(s: \"\\\\\\\\.\\\\foo\", \"..\\\\bar\", \"\\\\\\\\.\\\\foo\\\\..\\\\bar\");\n+\n+        t!(s: \"\\\\\\\\?\\\\C:\", \"foo\", \"\\\\\\\\?\\\\C:\\\\foo\"); // this is a weird one\n+    }\n+\n+    #[test]\n+    fn test_pop() {\n+        macro_rules! t(\n+            (s: $path:expr, $left:expr, $right:expr) => (\n+                {\n+                    let pstr = $path;\n+                    let mut p = Path::from_str(pstr);\n+                    let file = p.pop_opt_str();\n+                    let left = $left;\n+                    assert!(p.as_str() == Some(left),\n+                        \"`%s`.pop() failed; expected remainder `%s`, found `%s`\",\n+                        pstr, left, p.as_str().unwrap());\n+                    let right = $right;\n+                    let res = file.map(|s| s.as_slice());\n+                    assert!(res == right, \"`%s`.pop() failed; expected `%?`, found `%?`\",\n+                            pstr, right, res);\n+                }\n+            );\n+            (v: [$($path:expr),+], [$($left:expr),+], Some($($right:expr),+)) => (\n+                {\n+                    let mut p = Path::new(b!($($path),+));\n+                    let file = p.pop_opt();\n+                    assert_eq!(p.as_vec(), b!($($left),+));\n+                    assert_eq!(file.map(|v| v.as_slice()), Some(b!($($right),+)));\n+                }\n+            );\n+            (v: [$($path:expr),+], [$($left:expr),+], None) => (\n+                {\n+                    let mut p = Path::new(b!($($path),+));\n+                    let file = p.pop_opt();\n+                    assert_eq!(p.as_vec(), b!($($left),+));\n+                    assert_eq!(file, None);\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", Some(\"c\"));\n+        t!(s: \"a\", \".\", Some(\"a\"));\n+        t!(s: \".\", \".\", None);\n+        t!(s: \"\\\\a\", \"\\\\\", Some(\"a\"));\n+        t!(s: \"\\\\\", \"\\\\\", None);\n+        t!(v: [\"a\\\\b\\\\c\"], [\"a\\\\b\"], Some(\"c\"));\n+        t!(v: [\"a\"], [\".\"], Some(\"a\"));\n+        t!(v: [\".\"], [\".\"], None);\n+        t!(v: [\"\\\\a\"], [\"\\\\\"], Some(\"a\"));\n+        t!(v: [\"\\\\\"], [\"\\\\\"], None);\n+\n+        t!(s: \"C:\\\\a\\\\b\", \"C:\\\\a\", Some(\"b\"));\n+        t!(s: \"C:\\\\a\", \"C:\\\\\", Some(\"a\"));\n+        t!(s: \"C:\\\\\", \"C:\\\\\", None);\n+        t!(s: \"C:a\\\\b\", \"C:a\", Some(\"b\"));\n+        t!(s: \"C:a\", \"C:\", Some(\"a\"));\n+        t!(s: \"C:\", \"C:\", None);\n+        t!(s: \"\\\\\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\server\\\\share\\\\a\", Some(\"b\"));\n+        t!(s: \"\\\\\\\\server\\\\share\\\\a\", \"\\\\\\\\server\\\\share\", Some(\"a\"));\n+        t!(s: \"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\", None);\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\", Some(\"c\"));\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\", Some(\"b\"));\n+        t!(s: \"\\\\\\\\?\\\\a\", \"\\\\\\\\?\\\\a\", None);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", Some(\"b\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\\", Some(\"a\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\\\\\", None);\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", Some(\"b\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", Some(\"a\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", None);\n+        t!(s: \"\\\\\\\\.\\\\a\\\\b\\\\c\", \"\\\\\\\\.\\\\a\\\\b\", Some(\"c\"));\n+        t!(s: \"\\\\\\\\.\\\\a\\\\b\", \"\\\\\\\\.\\\\a\", Some(\"b\"));\n+        t!(s: \"\\\\\\\\.\\\\a\", \"\\\\\\\\.\\\\a\", None);\n+\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\a\", Some(\"b\"));\n+    }\n+\n+    #[test]\n+    fn test_join() {\n+        t!(s: Path::from_str(\"a\\\\b\\\\c\").join_str(\"..\"), \"a\\\\b\");\n+        t!(s: Path::from_str(\"\\\\a\\\\b\\\\c\").join_str(\"d\"), \"\\\\a\\\\b\\\\c\\\\d\");\n+        t!(s: Path::from_str(\"a\\\\b\").join_str(\"c\\\\d\"), \"a\\\\b\\\\c\\\\d\");\n+        t!(s: Path::from_str(\"a\\\\b\").join_str(\"\\\\c\\\\d\"), \"\\\\c\\\\d\");\n+        t!(s: Path::from_str(\".\").join_str(\"a\\\\b\"), \"a\\\\b\");\n+        t!(s: Path::from_str(\"\\\\\").join_str(\"a\\\\b\"), \"\\\\a\\\\b\");\n+        t!(v: Path::new(b!(\"a\\\\b\\\\c\")).join(b!(\"..\")), b!(\"a\\\\b\"));\n+        t!(v: Path::new(b!(\"\\\\a\\\\b\\\\c\")).join(b!(\"d\")), b!(\"\\\\a\\\\b\\\\c\\\\d\"));\n+        // full join testing is covered under test_push_path, so no need for\n+        // the full set of prefix tests\n+    }\n+\n+    #[test]\n+    fn test_join_path() {\n+        macro_rules! t(\n+            (s: $path:expr, $join:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let join = Path::from_str($join);\n+                    let res = path.join_path(&join);\n+                    assert_eq!(res.as_str(), Some($exp));\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a\\\\b\\\\c\", \"..\", \"a\\\\b\");\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n+        t!(s: \"a\\\\b\", \"c\\\\d\", \"a\\\\b\\\\c\\\\d\");\n+        t!(s: \"a\\\\b\", \"\\\\c\\\\d\", \"\\\\c\\\\d\");\n+        t!(s: \".\", \"a\\\\b\", \"a\\\\b\");\n+        t!(s: \"\\\\\", \"a\\\\b\", \"\\\\a\\\\b\");\n+        // join_path is implemented using push_path, so there's no need for\n+        // the full set of prefix tests\n+    }\n+\n+    #[test]\n+    fn test_with_helpers() {\n+        macro_rules! t(\n+            (s: $path:expr, $op:ident, $arg:expr, $res:expr) => (\n+                {\n+                    let pstr = $path;\n+                    let path = Path::from_str(pstr);\n+                    let arg = $arg;\n+                    let res = path.$op(arg);\n+                    let exp = $res;\n+                    assert!(res.as_str() == Some(exp),\n+                            \"`%s`.%s(\\\"%s\\\"): Expected `%s`, found `%s`\",\n+                            pstr, stringify!($op), arg, exp, res.as_str().unwrap());\n+                }\n+            )\n+        )\n+        t!(s: \"a\\\\b\\\\c\", with_dirname_str, \"d\", \"d\\\\c\");\n+        t!(s: \"a\\\\b\\\\c\", with_dirname_str, \"d\\\\e\", \"d\\\\e\\\\c\");\n+        t!(s: \"a\\\\b\\\\c\", with_dirname_str, \"\", \"c\");\n+        t!(s: \"a\\\\b\\\\c\", with_dirname_str, \"\\\\\", \"\\\\c\");\n+        t!(s: \"a\\\\b\\\\c\", with_dirname_str, \"/\", \"\\\\c\");\n+        t!(s: \"a\\\\b\\\\c\", with_dirname_str, \".\", \"c\");\n+        t!(s: \"a\\\\b\\\\c\", with_dirname_str, \"..\", \"..\\\\c\");\n+        t!(s: \"\\\\\", with_dirname_str, \"foo\", \"foo\");\n+        t!(s: \"\\\\\", with_dirname_str, \"\", \".\");\n+        t!(s: \"\\\\foo\", with_dirname_str, \"bar\", \"bar\\\\foo\");\n+        t!(s: \"..\", with_dirname_str, \"foo\", \"foo\");\n+        t!(s: \"..\\\\..\", with_dirname_str, \"foo\", \"foo\");\n+        t!(s: \"..\", with_dirname_str, \"\", \".\");\n+        t!(s: \"..\\\\..\", with_dirname_str, \"\", \".\");\n+        t!(s: \".\", with_dirname_str, \"foo\", \"foo\");\n+        t!(s: \"foo\", with_dirname_str, \"..\", \"..\\\\foo\");\n+        t!(s: \"foo\", with_dirname_str, \"..\\\\..\", \"..\\\\..\\\\foo\");\n+        t!(s: \"C:\\\\a\\\\b\", with_dirname_str, \"foo\", \"foo\\\\b\");\n+        t!(s: \"foo\", with_dirname_str, \"C:\\\\a\\\\b\", \"C:\\\\a\\\\b\\\\foo\");\n+        t!(s: \"C:a\\\\b\", with_dirname_str, \"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\\\\b\");\n+        t!(s: \"a\", with_dirname_str, \"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\\\\a\");\n+        t!(s: \"a\\\\b\", with_dirname_str, \"\\\\\\\\?\\\\\", \"\\\\\\\\?\\\\b\");\n+        t!(s: \"a\\\\b\", with_dirname_str, \"C:\", \"C:b\");\n+        t!(s: \"a\\\\b\", with_dirname_str, \"C:\\\\\", \"C:\\\\b\");\n+        t!(s: \"a\\\\b\", with_dirname_str, \"C:/\", \"C:\\\\b\");\n+        t!(s: \"C:\\\\\", with_dirname_str, \"foo\", \"foo\");\n+        t!(s: \"C:\", with_dirname_str, \"foo\", \"foo\");\n+        t!(s: \".\", with_dirname_str, \"C:\\\\\", \"C:\\\\\");\n+        t!(s: \".\", with_dirname_str, \"C:/\", \"C:\\\\\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\", with_dirname_str, \"C:\\\\\", \"C:\\\\foo\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\\", with_dirname_str, \"bar\", \"bar\");\n+        t!(s: \"foo\\\\bar\", with_dirname_str, \"\\\\\\\\?\\\\C:\\\\baz\", \"\\\\\\\\?\\\\C:\\\\baz\\\\bar\");\n+        t!(s: \"\\\\\\\\?\\\\foo\", with_dirname_str, \"C:\\\\bar\", \"C:\\\\bar\");\n+        t!(s: \"\\\\\\\\?\\\\a\\\\foo\", with_dirname_str, \"C:\\\\bar\", \"C:\\\\bar\\\\foo\");\n+        t!(s: \"\\\\\\\\?\\\\a\\\\foo/bar\", with_dirname_str, \"C:\\\\baz\", \"C:\\\\baz\\\\foo\\\\bar\");\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\baz\", with_dirname_str, \"a\", \"a\\\\baz\");\n+        t!(s: \"foo\\\\bar\", with_dirname_str, \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\baz\",\n+              \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\baz\\\\bar\");\n+        t!(s: \"\\\\\\\\.\\\\foo\", with_dirname_str, \"bar\", \"bar\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_dirname_str, \"baz\", \"baz\\\\bar\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_dirname_str, \"baz\\\\\", \"baz\\\\bar\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_dirname_str, \"baz/\", \"baz\\\\bar\");\n+\n+        t!(s: \"a\\\\b\\\\c\", with_filename_str, \"d\", \"a\\\\b\\\\d\");\n+        t!(s: \".\", with_filename_str, \"foo\", \"foo\");\n+        t!(s: \"\\\\a\\\\b\\\\c\", with_filename_str, \"d\", \"\\\\a\\\\b\\\\d\");\n+        t!(s: \"\\\\\", with_filename_str, \"foo\", \"\\\\foo\");\n+        t!(s: \"\\\\a\", with_filename_str, \"foo\", \"\\\\foo\");\n+        t!(s: \"foo\", with_filename_str, \"bar\", \"bar\");\n+        t!(s: \"\\\\\", with_filename_str, \"foo\\\\\", \"\\\\foo\");\n+        t!(s: \"\\\\a\", with_filename_str, \"foo\\\\\", \"\\\\foo\");\n+        t!(s: \"a\\\\b\\\\c\", with_filename_str, \"\", \"a\\\\b\");\n+        t!(s: \"a\\\\b\\\\c\", with_filename_str, \".\", \"a\\\\b\");\n+        t!(s: \"a\\\\b\\\\c\", with_filename_str, \"..\", \"a\");\n+        t!(s: \"\\\\a\", with_filename_str, \"\", \"\\\\\");\n+        t!(s: \"foo\", with_filename_str, \"\", \".\");\n+        t!(s: \"a\\\\b\\\\c\", with_filename_str, \"d\\\\e\", \"a\\\\b\\\\d\\\\e\");\n+        t!(s: \"a\\\\b\\\\c\", with_filename_str, \"\\\\d\", \"a\\\\b\\\\d\");\n+        t!(s: \"..\", with_filename_str, \"foo\", \"..\\\\foo\");\n+        t!(s: \"..\\\\..\", with_filename_str, \"foo\", \"..\\\\..\\\\foo\");\n+        t!(s: \"..\", with_filename_str, \"\", \"..\");\n+        t!(s: \"..\\\\..\", with_filename_str, \"\", \"..\\\\..\");\n+        t!(s: \"C:\\\\foo\\\\bar\", with_filename_str, \"baz\", \"C:\\\\foo\\\\baz\");\n+        t!(s: \"C:\\\\foo\", with_filename_str, \"bar\", \"C:\\\\bar\");\n+        t!(s: \"C:\\\\\", with_filename_str, \"foo\", \"C:\\\\foo\");\n+        t!(s: \"C:foo\\\\bar\", with_filename_str, \"baz\", \"C:foo\\\\baz\");\n+        t!(s: \"C:foo\", with_filename_str, \"bar\", \"C:bar\");\n+        t!(s: \"C:\", with_filename_str, \"foo\", \"C:foo\");\n+        t!(s: \"C:\\\\foo\", with_filename_str, \"\", \"C:\\\\\");\n+        t!(s: \"C:foo\", with_filename_str, \"\", \"C:\");\n+        t!(s: \"C:\\\\foo\\\\bar\", with_filename_str, \"..\", \"C:\\\\\");\n+        t!(s: \"C:\\\\foo\", with_filename_str, \"..\", \"C:\\\\\");\n+        t!(s: \"C:\\\\\", with_filename_str, \"..\", \"C:\\\\\");\n+        t!(s: \"C:foo\\\\bar\", with_filename_str, \"..\", \"C:\");\n+        t!(s: \"C:foo\", with_filename_str, \"..\", \"C:..\");\n+        t!(s: \"C:\", with_filename_str, \"..\", \"C:..\");\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", with_filename_str, \"bar\", \"\\\\\\\\server\\\\share\\\\bar\");\n+        t!(s: \"\\\\\\\\server\\\\share\", with_filename_str, \"foo\", \"\\\\\\\\server\\\\share\\\\foo\");\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", with_filename_str, \"\", \"\\\\\\\\server\\\\share\");\n+        t!(s: \"\\\\\\\\server\\\\share\", with_filename_str, \"\", \"\\\\\\\\server\\\\share\");\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", with_filename_str, \"..\", \"\\\\\\\\server\\\\share\");\n+        t!(s: \"\\\\\\\\server\\\\share\", with_filename_str, \"..\", \"\\\\\\\\server\\\\share\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\", with_filename_str, \"baz\", \"\\\\\\\\?\\\\C:\\\\foo\\\\baz\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\", with_filename_str, \"bar\", \"\\\\\\\\?\\\\C:\\\\bar\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\\", with_filename_str, \"foo\", \"\\\\\\\\?\\\\C:\\\\foo\");\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\", with_filename_str, \"..\", \"\\\\\\\\?\\\\C:\\\\..\");\n+        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", with_filename_str, \"baz\", \"\\\\\\\\?\\\\foo\\\\baz\");\n+        t!(s: \"\\\\\\\\?\\\\foo\", with_filename_str, \"bar\", \"\\\\\\\\?\\\\foo\\\\bar\");\n+        t!(s: \"\\\\\\\\?\\\\\", with_filename_str, \"foo\", \"\\\\\\\\?\\\\\\\\foo\");\n+        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", with_filename_str, \"..\", \"\\\\\\\\?\\\\foo\\\\..\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_filename_str, \"baz\", \"\\\\\\\\.\\\\foo\\\\baz\");\n+        t!(s: \"\\\\\\\\.\\\\foo\", with_filename_str, \"bar\", \"\\\\\\\\.\\\\foo\\\\bar\");\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", with_filename_str, \"..\", \"\\\\\\\\.\\\\foo\\\\..\");\n+\n+        t!(s: \"hi\\\\there.txt\", with_filestem_str, \"here\", \"hi\\\\here.txt\");\n+        t!(s: \"hi\\\\there.txt\", with_filestem_str, \"\", \"hi\\\\.txt\");\n+        t!(s: \"hi\\\\there.txt\", with_filestem_str, \".\", \"hi\\\\..txt\");\n+        t!(s: \"hi\\\\there.txt\", with_filestem_str, \"..\", \"hi\\\\...txt\");\n+        t!(s: \"hi\\\\there.txt\", with_filestem_str, \"\\\\\", \"hi\\\\.txt\");\n+        t!(s: \"hi\\\\there.txt\", with_filestem_str, \"foo\\\\bar\", \"hi\\\\foo\\\\bar.txt\");\n+        t!(s: \"hi\\\\there.foo.txt\", with_filestem_str, \"here\", \"hi\\\\here.txt\");\n+        t!(s: \"hi\\\\there\", with_filestem_str, \"here\", \"hi\\\\here\");\n+        t!(s: \"hi\\\\there\", with_filestem_str, \"\", \"hi\");\n+        t!(s: \"hi\", with_filestem_str, \"\", \".\");\n+        t!(s: \"\\\\hi\", with_filestem_str, \"\", \"\\\\\");\n+        t!(s: \"hi\\\\there\", with_filestem_str, \"..\", \".\");\n+        t!(s: \"hi\\\\there\", with_filestem_str, \".\", \"hi\");\n+        t!(s: \"hi\\\\there.\", with_filestem_str, \"foo\", \"hi\\\\foo.\");\n+        t!(s: \"hi\\\\there.\", with_filestem_str, \"\", \"hi\");\n+        t!(s: \"hi\\\\there.\", with_filestem_str, \".\", \".\");\n+        t!(s: \"hi\\\\there.\", with_filestem_str, \"..\", \"hi\\\\...\");\n+        t!(s: \"\\\\\", with_filestem_str, \"foo\", \"\\\\foo\");\n+        t!(s: \".\", with_filestem_str, \"foo\", \"foo\");\n+        t!(s: \"hi\\\\there..\", with_filestem_str, \"here\", \"hi\\\\here.\");\n+        t!(s: \"hi\\\\there..\", with_filestem_str, \"\", \"hi\");\n+        // filestem setter calls filename setter internally, no need for extended tests\n+\n+        t!(s: \"hi\\\\there.txt\", with_extension_str, \"exe\", \"hi\\\\there.exe\");\n+        t!(s: \"hi\\\\there.txt\", with_extension_str, \"\", \"hi\\\\there\");\n+        t!(s: \"hi\\\\there.txt\", with_extension_str, \".\", \"hi\\\\there..\");\n+        t!(s: \"hi\\\\there.txt\", with_extension_str, \"..\", \"hi\\\\there...\");\n+        t!(s: \"hi\\\\there\", with_extension_str, \"txt\", \"hi\\\\there.txt\");\n+        t!(s: \"hi\\\\there\", with_extension_str, \".\", \"hi\\\\there..\");\n+        t!(s: \"hi\\\\there\", with_extension_str, \"..\", \"hi\\\\there...\");\n+        t!(s: \"hi\\\\there.\", with_extension_str, \"txt\", \"hi\\\\there.txt\");\n+        t!(s: \"hi\\\\.foo\", with_extension_str, \"txt\", \"hi\\\\.foo.txt\");\n+        t!(s: \"hi\\\\there.txt\", with_extension_str, \".foo\", \"hi\\\\there..foo\");\n+        t!(s: \"\\\\\", with_extension_str, \"txt\", \"\\\\\");\n+        t!(s: \"\\\\\", with_extension_str, \".\", \"\\\\\");\n+        t!(s: \"\\\\\", with_extension_str, \"..\", \"\\\\\");\n+        t!(s: \".\", with_extension_str, \"txt\", \".\");\n+        // extension setter calls filename setter internally, no need for extended tests\n+    }\n+\n+    #[test]\n+    fn test_setters() {\n+        macro_rules! t(\n+            (s: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n+                {\n+                    let path = $path;\n+                    let arg = $arg;\n+                    let mut p1 = Path::from_str(path);\n+                    p1.$set(arg);\n+                    let p2 = Path::from_str(path);\n+                    assert_eq!(p1, p2.$with(arg));\n+                }\n+            );\n+            (v: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n+                {\n+                    let path = $path;\n+                    let arg = $arg;\n+                    let mut p1 = Path::new(path);\n+                    p1.$set(arg);\n+                    let p2 = Path::new(path);\n+                    assert_eq!(p1, p2.$with(arg));\n+                }\n+            )\n+        )\n+\n+        t!(v: b!(\"a\\\\b\\\\c\"), set_dirname, with_dirname, b!(\"d\"));\n+        t!(v: b!(\"a\\\\b\\\\c\"), set_dirname, with_dirname, b!(\"d\\\\e\"));\n+        t!(s: \"a\\\\b\\\\c\", set_dirname_str, with_dirname_str, \"d\");\n+        t!(s: \"a\\\\b\\\\c\", set_dirname_str, with_dirname_str, \"d\\\\e\");\n+        t!(s: \"\\\\\", set_dirname_str, with_dirname_str, \"foo\");\n+        t!(s: \"\\\\foo\", set_dirname_str, with_dirname_str, \"bar\");\n+        t!(s: \"a\\\\b\\\\c\", set_dirname_str, with_dirname_str, \"\");\n+        t!(s: \"..\\\\..\", set_dirname_str, with_dirname_str, \"x\");\n+        t!(s: \"foo\", set_dirname_str, with_dirname_str, \"..\\\\..\");\n+\n+        t!(v: b!(\"a\\\\b\\\\c\"), set_filename, with_filename, b!(\"d\"));\n+        t!(v: b!(\"\\\\\"), set_filename, with_filename, b!(\"foo\"));\n+        t!(s: \"a\\\\b\\\\c\", set_filename_str, with_filename_str, \"d\");\n+        t!(s: \"\\\\\", set_filename_str, with_filename_str, \"foo\");\n+        t!(s: \".\", set_filename_str, with_filename_str, \"foo\");\n+        t!(s: \"a\\\\b\", set_filename_str, with_filename_str, \"\");\n+        t!(s: \"a\", set_filename_str, with_filename_str, \"\");\n+\n+        t!(v: b!(\"hi\\\\there.txt\"), set_filestem, with_filestem, b!(\"here\"));\n+        t!(s: \"hi\\\\there.txt\", set_filestem_str, with_filestem_str, \"here\");\n+        t!(s: \"hi\\\\there.\", set_filestem_str, with_filestem_str, \"here\");\n+        t!(s: \"hi\\\\there\", set_filestem_str, with_filestem_str, \"here\");\n+        t!(s: \"hi\\\\there.txt\", set_filestem_str, with_filestem_str, \"\");\n+        t!(s: \"hi\\\\there\", set_filestem_str, with_filestem_str, \"\");\n+\n+        t!(v: b!(\"hi\\\\there.txt\"), set_extension, with_extension, b!(\"exe\"));\n+        t!(s: \"hi\\\\there.txt\", set_extension_str, with_extension_str, \"exe\");\n+        t!(s: \"hi\\\\there.\", set_extension_str, with_extension_str, \"txt\");\n+        t!(s: \"hi\\\\there\", set_extension_str, with_extension_str, \"txt\");\n+        t!(s: \"hi\\\\there.txt\", set_extension_str, with_extension_str, \"\");\n+        t!(s: \"hi\\\\there\", set_extension_str, with_extension_str, \"\");\n+        t!(s: \".\", set_extension_str, with_extension_str, \"txt\");\n+\n+        // with_ helpers use the setter internally, so the tests for the with_ helpers\n+        // will suffice. No need for the full set of prefix tests.\n+    }\n+\n+    #[test]\n+    fn test_getters() {\n+        macro_rules! t(\n+            (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n+                {\n+                    let path = $path;\n+                    assert_eq!(path.filename_str(), $filename);\n+                    assert_eq!(path.dirname_str(), $dirname);\n+                    assert_eq!(path.filestem_str(), $filestem);\n+                    assert_eq!(path.extension_str(), $ext);\n+                }\n+            );\n+            (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n+                {\n+                    let path = $path;\n+                    assert_eq!(path.filename(), $filename);\n+                    assert_eq!(path.dirname(), $dirname);\n+                    assert_eq!(path.filestem(), $filestem);\n+                    assert_eq!(path.extension(), $ext);\n+                }\n+            )\n+        )\n+\n+        t!(v: Path::new(b!(\"a\\\\b\\\\c\")), b!(\"c\"), b!(\"a\\\\b\"), b!(\"c\"), None);\n+        t!(s: Path::from_str(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n+        t!(s: Path::from_str(\".\"), Some(\"\"), Some(\".\"), Some(\"\"), None);\n+        t!(s: Path::from_str(\"\\\\\"), Some(\"\"), Some(\"\\\\\"), Some(\"\"), None);\n+        t!(s: Path::from_str(\"..\"), Some(\"\"), Some(\"..\"), Some(\"\"), None);\n+        t!(s: Path::from_str(\"..\\\\..\"), Some(\"\"), Some(\"..\\\\..\"), Some(\"\"), None);\n+        t!(s: Path::from_str(\"hi\\\\there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n+              Some(\"there\"), Some(\"txt\"));\n+        t!(s: Path::from_str(\"hi\\\\there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n+        t!(s: Path::from_str(\"hi\\\\there.\"), Some(\"there.\"), Some(\"hi\"),\n+              Some(\"there\"), Some(\"\"));\n+        t!(s: Path::from_str(\"hi\\\\.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n+        t!(s: Path::from_str(\"hi\\\\..there\"), Some(\"..there\"), Some(\"hi\"),\n+              Some(\".\"), Some(\"there\"));\n+\n+        // these are already tested in test_components, so no need for extended tests\n+    }\n+\n+    #[test]\n+    fn test_dir_file_path() {\n+        t!(s: Path::from_str(\"hi\\\\there\").dir_path(), \"hi\");\n+        t!(s: Path::from_str(\"hi\").dir_path(), \".\");\n+        t!(s: Path::from_str(\"\\\\hi\").dir_path(), \"\\\\\");\n+        t!(s: Path::from_str(\"\\\\\").dir_path(), \"\\\\\");\n+        t!(s: Path::from_str(\"..\").dir_path(), \"..\");\n+        t!(s: Path::from_str(\"..\\\\..\").dir_path(), \"..\\\\..\");\n+\n+        macro_rules! t(\n+            ($path:expr, $exp:expr) => (\n+                {\n+                    let path = $path;\n+                    let left = path.and_then_ref(|p| p.as_str());\n+                    assert_eq!(left, $exp);\n+                }\n+            );\n+        )\n+\n+        t!(Path::from_str(\"hi\\\\there\").file_path(), Some(\"there\"));\n+        t!(Path::from_str(\"hi\").file_path(), Some(\"hi\"));\n+        t!(Path::from_str(\".\").file_path(), None);\n+        t!(Path::from_str(\"\\\\\").file_path(), None);\n+        t!(Path::from_str(\"..\").file_path(), None);\n+        t!(Path::from_str(\"..\\\\..\").file_path(), None);\n+\n+        // dir_path and file_path are just dirname and filename interpreted as paths.\n+        // No need for extended tests\n+    }\n+\n+    #[test]\n+    fn test_is_absolute() {\n+        macro_rules! t(\n+            ($path:expr, $abs:expr, $vol:expr, $cwd:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let (abs, vol, cwd) = ($abs, $vol, $cwd);\n+                    let b = path.is_absolute();\n+                    assert!(b == abs, \"Path '%s'.is_absolute(): expected %?, found %?\",\n+                            path.as_str().unwrap(), abs, b);\n+                    let b = path.is_vol_relative();\n+                    assert!(b == vol, \"Path '%s'.is_vol_relative(): expected %?, found %?\",\n+                            path.as_str().unwrap(), vol, b);\n+                    let b = path.is_cwd_relative();\n+                    assert!(b == cwd, \"Path '%s'.is_cwd_relative(): expected %?, found %?\",\n+                            path.as_str().unwrap(), cwd, b);\n+                }\n+            )\n+        )\n+        t!(\"a\\\\b\\\\c\", false, false, false);\n+        t!(\"\\\\a\\\\b\\\\c\", false, true, false);\n+        t!(\"a\", false, false, false);\n+        t!(\"\\\\a\", false, true, false);\n+        t!(\".\", false, false, false);\n+        t!(\"\\\\\", false, true, false);\n+        t!(\"..\", false, false, false);\n+        t!(\"..\\\\..\", false, false, false);\n+        t!(\"C:a\\\\b.txt\", false, false, true);\n+        t!(\"C:\\\\a\\\\b.txt\", true, false, false);\n+        t!(\"\\\\\\\\server\\\\share\\\\a\\\\b.txt\", true, false, false);\n+        t!(\"\\\\\\\\?\\\\a\\\\b\\\\c.txt\", true, false, false);\n+        t!(\"\\\\\\\\?\\\\C:\\\\a\\\\b.txt\", true, false, false);\n+        t!(\"\\\\\\\\?\\\\C:a\\\\b.txt\", true, false, false); // NB: not equivalent to C:a\\b.txt\n+        t!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b.txt\", true, false, false);\n+        t!(\"\\\\\\\\.\\\\a\\\\b\", true, false, false);\n+    }\n+\n+    #[test]\n+    fn test_is_ancestor_of() {\n+        macro_rules! t(\n+            (s: $path:expr, $dest:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let dest = Path::from_str($dest);\n+                    let exp = $exp;\n+                    let res = path.is_ancestor_of(&dest);\n+                    assert!(res == exp,\n+                            \"`%s`.is_ancestor_of(`%s`): Expected %?, found %?\",\n+                            path.as_str().unwrap(), dest.as_str().unwrap(), exp, res);\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\\\\d\", true);\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\", true);\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", false);\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\a\\\\b\\\\c\", true);\n+        t!(s: \"\\\\a\\\\b\", \"\\\\a\\\\b\\\\c\", true);\n+        t!(s: \"\\\\a\\\\b\\\\c\\\\d\", \"\\\\a\\\\b\\\\c\", false);\n+        t!(s: \"\\\\a\\\\b\", \"a\\\\b\\\\c\", false);\n+        t!(s: \"a\\\\b\", \"\\\\a\\\\b\\\\c\", false);\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\d\", false);\n+        t!(s: \"..\\\\a\\\\b\\\\c\", \"a\\\\b\\\\c\", false);\n+        t!(s: \"a\\\\b\\\\c\", \"..\\\\a\\\\b\\\\c\", false);\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\cd\", false);\n+        t!(s: \"a\\\\b\\\\cd\", \"a\\\\b\\\\c\", false);\n+        t!(s: \"..\\\\a\\\\b\", \"..\\\\a\\\\b\\\\c\", true);\n+        t!(s: \".\", \"a\\\\b\", true);\n+        t!(s: \".\", \".\", true);\n+        t!(s: \"\\\\\", \"\\\\\", true);\n+        t!(s: \"\\\\\", \"\\\\a\\\\b\", true);\n+        t!(s: \"..\", \"a\\\\b\", true);\n+        t!(s: \"..\\\\..\", \"a\\\\b\", true);\n+        t!(s: \"foo\\\\bar\", \"foobar\", false);\n+        t!(s: \"foobar\", \"foo\\\\bar\", false);\n+\n+        t!(s: \"foo\", \"C:foo\", false);\n+        t!(s: \"C:foo\", \"foo\", false);\n+        t!(s: \"C:foo\", \"C:foo\\\\bar\", true);\n+        t!(s: \"C:foo\\\\bar\", \"C:foo\", false);\n+        t!(s: \"C:\\\\foo\", \"C:\\\\foo\\\\bar\", true);\n+        t!(s: \"C:\", \"C:\", true);\n+        t!(s: \"C:\", \"C:\\\\\", false);\n+        t!(s: \"C:\\\\\", \"C:\", false);\n+        t!(s: \"C:\\\\\", \"C:\\\\\", true);\n+        t!(s: \"C:\\\\foo\\\\bar\", \"C:\\\\foo\", false);\n+        t!(s: \"C:foo\\\\bar\", \"C:foo\", false);\n+        t!(s: \"C:\\\\foo\", \"\\\\foo\", false);\n+        t!(s: \"\\\\foo\", \"C:\\\\foo\", false);\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", \"\\\\\\\\server\\\\share\\\\foo\\\\bar\", true);\n+        t!(s: \"\\\\\\\\server\\\\share\", \"\\\\\\\\server\\\\share\\\\foo\", true);\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", \"\\\\\\\\server\\\\share\", false);\n+        t!(s: \"C:\\\\foo\", \"\\\\\\\\server\\\\share\\\\foo\", false);\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", \"C:\\\\foo\", false);\n+        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\", true);\n+        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\", \"\\\\\\\\?\\\\foo\\\\bar\", false);\n+        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", \"\\\\foo\\\\bar\\\\baz\", false);\n+        t!(s: \"\\\\foo\\\\bar\", \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\", false);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\", \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\\\\baz\", true);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\\\\baz\", \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\", false);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\\\\foo\", true);\n+        t!(s: \"\\\\\\\\?\\\\C:\", \"\\\\\\\\?\\\\C:\\\\\", false); // this is a weird one\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\", false);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\c:\\\\a\\\\b\", true);\n+        t!(s: \"\\\\\\\\?\\\\c:\\\\a\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\", true);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\D:\\\\a\\\\b\", false);\n+        t!(s: \"\\\\\\\\?\\\\foo\", \"\\\\\\\\?\\\\foobar\", false);\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\\\\b\\\\c\", true);\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\\\\b\\\\\", true);\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\a\\\\b\", true);\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\", false);\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\\\\\", false);\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\\\\d\", true);\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\\\\d\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", false);\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", true);\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\", true);\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\", \"\\\\\\\\.\\\\foo\\\\bar\", false);\n+        t!(s: \"\\\\\\\\.\\\\foo\", \"\\\\\\\\.\\\\foo\\\\bar\", true);\n+        t!(s: \"\\\\\\\\.\\\\foo\", \"\\\\\\\\.\\\\foobar\", false);\n+\n+        t!(s: \"\\\\a\\\\b\", \"\\\\\\\\?\\\\a\\\\b\", false);\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\a\\\\b\", false);\n+        t!(s: \"\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\", false);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\a\\\\b\", false);\n+        t!(s: \"Z:\\\\a\\\\b\", \"\\\\\\\\?\\\\z:\\\\a\\\\b\", true);\n+        t!(s: \"C:\\\\a\\\\b\", \"\\\\\\\\?\\\\D:\\\\a\\\\b\", false);\n+        t!(s: \"a\\\\b\", \"\\\\\\\\?\\\\a\\\\b\", false);\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"a\\\\b\", false);\n+        t!(s: \"C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\", true);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:\\\\a\\\\b\", true);\n+        t!(s: \"C:a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\", false);\n+        t!(s: \"C:a\\\\b\", \"\\\\\\\\?\\\\C:a\\\\b\", false);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:a\\\\b\", false);\n+        t!(s: \"\\\\\\\\?\\\\C:a\\\\b\", \"C:a\\\\b\", false);\n+        t!(s: \"C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\\\\\", true);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\\\\\", \"C:\\\\a\\\\b\", true);\n+        t!(s: \"\\\\\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", true);\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\a\\\\b\\\\c\", true);\n+    }\n+\n+    #[test]\n+    fn test_path_relative_from() {\n+        macro_rules! t(\n+            (s: $path:expr, $other:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let other = Path::from_str($other);\n+                    let res = path.path_relative_from(&other);\n+                    let exp = $exp;\n+                    assert!(res.and_then_ref(|x| x.as_str()) == exp,\n+                            \"`%s`.path_relative_from(`%s`): Expected %?, got %?\",\n+                            path.as_str().unwrap(), other.as_str().unwrap(), exp,\n+                            res.and_then_ref(|x| x.as_str()));\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", Some(\"c\"));\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\d\", Some(\"..\\\\c\"));\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\\\\d\", Some(\"..\"));\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\", Some(\".\"));\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\\\\d\\\\e\", Some(\"..\\\\..\"));\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\d\\\\e\", Some(\"..\\\\..\\\\b\\\\c\"));\n+        t!(s: \"a\\\\b\\\\c\", \"d\\\\e\\\\f\", Some(\"..\\\\..\\\\..\\\\a\\\\b\\\\c\"));\n+        t!(s: \"a\\\\b\\\\c\", \"\\\\a\\\\b\\\\c\", None);\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"a\\\\b\\\\c\", Some(\"\\\\a\\\\b\\\\c\"));\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\a\\\\b\\\\c\\\\d\", Some(\"..\"));\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\a\\\\b\", Some(\"c\"));\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\a\\\\b\\\\c\\\\d\\\\e\", Some(\"..\\\\..\"));\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\a\\\\d\\\\e\", Some(\"..\\\\..\\\\b\\\\c\"));\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\d\\\\e\\\\f\", Some(\"..\\\\..\\\\..\\\\a\\\\b\\\\c\"));\n+        t!(s: \"hi\\\\there.txt\", \"hi\\\\there\", Some(\"..\\\\there.txt\"));\n+        t!(s: \".\", \"a\", Some(\"..\"));\n+        t!(s: \".\", \"a\\\\b\", Some(\"..\\\\..\"));\n+        t!(s: \".\", \".\", Some(\".\"));\n+        t!(s: \"a\", \".\", Some(\"a\"));\n+        t!(s: \"a\\\\b\", \".\", Some(\"a\\\\b\"));\n+        t!(s: \"..\", \".\", Some(\"..\"));\n+        t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\", Some(\".\"));\n+        t!(s: \"\\\\a\\\\b\\\\c\", \"\\\\a\\\\b\\\\c\", Some(\".\"));\n+        t!(s: \"\\\\\", \"\\\\\", Some(\".\"));\n+        t!(s: \"\\\\\", \".\", Some(\"\\\\\"));\n+        t!(s: \"..\\\\..\\\\a\", \"b\", Some(\"..\\\\..\\\\..\\\\a\"));\n+        t!(s: \"a\", \"..\\\\..\\\\b\", None);\n+        t!(s: \"..\\\\..\\\\a\", \"..\\\\..\\\\b\", Some(\"..\\\\a\"));\n+        t!(s: \"..\\\\..\\\\a\", \"..\\\\..\\\\a\\\\b\", Some(\"..\"));\n+        t!(s: \"..\\\\..\\\\a\\\\b\", \"..\\\\..\\\\a\", Some(\"b\"));\n+\n+        t!(s: \"C:a\\\\b\\\\c\", \"C:a\\\\b\", Some(\"c\"));\n+        t!(s: \"C:a\\\\b\", \"C:a\\\\b\\\\c\", Some(\"..\"));\n+        t!(s: \"C:\" ,\"C:a\\\\b\", Some(\"..\\\\..\"));\n+        t!(s: \"C:a\\\\b\", \"C:c\\\\d\", Some(\"..\\\\..\\\\a\\\\b\"));\n+        t!(s: \"C:a\\\\b\", \"D:c\\\\d\", Some(\"C:a\\\\b\"));\n+        t!(s: \"C:a\\\\b\", \"C:..\\\\c\", None);\n+        t!(s: \"C:..\\\\a\", \"C:b\\\\c\", Some(\"..\\\\..\\\\..\\\\a\"));\n+        t!(s: \"C:\\\\a\\\\b\\\\c\", \"C:\\\\a\\\\b\", Some(\"c\"));\n+        t!(s: \"C:\\\\a\\\\b\", \"C:\\\\a\\\\b\\\\c\", Some(\"..\"));\n+        t!(s: \"C:\\\\\", \"C:\\\\a\\\\b\", Some(\"..\\\\..\"));\n+        t!(s: \"C:\\\\a\\\\b\", \"C:\\\\c\\\\d\", Some(\"..\\\\..\\\\a\\\\b\"));\n+        t!(s: \"C:\\\\a\\\\b\", \"C:a\\\\b\", Some(\"C:\\\\a\\\\b\"));\n+        t!(s: \"C:a\\\\b\", \"C:\\\\a\\\\b\", None);\n+        t!(s: \"\\\\a\\\\b\", \"C:\\\\a\\\\b\", None);\n+        t!(s: \"\\\\a\\\\b\", \"C:a\\\\b\", None);\n+        t!(s: \"a\\\\b\", \"C:\\\\a\\\\b\", None);\n+        t!(s: \"a\\\\b\", \"C:a\\\\b\", None);\n+\n+        t!(s: \"\\\\\\\\a\\\\b\\\\c\", \"\\\\\\\\a\\\\b\", Some(\"c\"));\n+        t!(s: \"\\\\\\\\a\\\\b\", \"\\\\\\\\a\\\\b\\\\c\", Some(\"..\"));\n+        t!(s: \"\\\\\\\\a\\\\b\\\\c\\\\e\", \"\\\\\\\\a\\\\b\\\\c\\\\d\", Some(\"..\\\\e\"));\n+        t!(s: \"\\\\\\\\a\\\\c\\\\d\", \"\\\\\\\\a\\\\b\\\\d\", Some(\"\\\\\\\\a\\\\c\\\\d\"));\n+        t!(s: \"\\\\\\\\b\\\\c\\\\d\", \"\\\\\\\\a\\\\c\\\\d\", Some(\"\\\\\\\\b\\\\c\\\\d\"));\n+        t!(s: \"\\\\\\\\a\\\\b\\\\c\", \"\\\\d\\\\e\", Some(\"\\\\\\\\a\\\\b\\\\c\"));\n+        t!(s: \"\\\\d\\\\e\", \"\\\\\\\\a\\\\b\\\\c\", None);\n+        t!(s: \"d\\\\e\", \"\\\\\\\\a\\\\b\\\\c\", None);\n+        t!(s: \"C:\\\\a\\\\b\\\\c\", \"\\\\\\\\a\\\\b\\\\c\", Some(\"C:\\\\a\\\\b\\\\c\"));\n+        t!(s: \"C:\\\\c\", \"\\\\\\\\a\\\\b\\\\c\", Some(\"C:\\\\c\"));\n+\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\a\\\\b\"));\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"a\\\\b\", Some(\"\\\\\\\\?\\\\a\\\\b\"));\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\b\", Some(\"\\\\\\\\?\\\\a\\\\b\"));\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"b\", Some(\"\\\\\\\\?\\\\a\\\\b\"));\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\a\\\\b\\\\c\", Some(\"..\"));\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\", Some(\"c\"));\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\", \"\\\\\\\\?\\\\c\\\\d\", Some(\"\\\\\\\\?\\\\a\\\\b\"));\n+        t!(s: \"\\\\\\\\?\\\\a\", \"\\\\\\\\?\\\\b\", Some(\"\\\\\\\\?\\\\a\"));\n+\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", Some(\"b\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\", Some(\"..\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\b\", Some(\"..\\\\a\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\D:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\c:\\\\a\", Some(\"b\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:\\\\a\", Some(\"b\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"C:\\\\a\\\\b\", Some(\"..\"));\n+        t!(s: \"C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", Some(\"b\"));\n+        t!(s: \"C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\", Some(\"..\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\", \"D:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\"));\n+        t!(s: \"\\\\\\\\?\\\\c:\\\\a\\\\b\", \"C:\\\\a\", Some(\"b\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:a\\\\b\", Some(\"\\\\\\\\?\\\\C:\\\\a\\\\b\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\.\\\\b\", \"C:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\\\\.\\\\b\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b/c\", \"C:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\\\\b/c\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\..\\\\b\", \"C:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\\\\..\\\\b\"));\n+        t!(s: \"C:a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\", None);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\.\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\\\\.\\\\b\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b/c\", \"\\\\\\\\?\\\\C:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\\\\b/c\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\..\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", Some(\"\\\\\\\\?\\\\C:\\\\a\\\\..\\\\b\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\a\\\\b\\\\\", \"\\\\\\\\?\\\\C:\\\\a\", Some(\"b\"));\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\.\\\\b\", \"\\\\\\\\?\\\\C:\\\\.\", Some(\"b\"));\n+        t!(s: \"C:\\\\b\", \"\\\\\\\\?\\\\C:\\\\.\", Some(\"..\\\\b\"));\n+        t!(s: \"\\\\\\\\?\\\\a\\\\.\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\.\\\\b\", Some(\"c\"));\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\.\\\\d\", Some(\"..\\\\..\\\\b\\\\c\"));\n+        t!(s: \"\\\\\\\\?\\\\a\\\\..\\\\b\", \"\\\\\\\\?\\\\a\\\\..\", Some(\"b\"));\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\..\", \"\\\\\\\\?\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\a\\\\b\\\\..\"));\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\..\\\\b\", Some(\"..\\\\..\\\\b\\\\c\"));\n+\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", Some(\"c\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", Some(\"..\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\UNC\\\\a\\\\c\\\\d\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\b\\\\c\\\\d\", \"\\\\\\\\?\\\\UNC\\\\a\\\\c\\\\d\", Some(\"\\\\\\\\?\\\\UNC\\\\b\\\\c\\\\d\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\a\\\\b\\\\c\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\C:\\\\a\\\\b\\\\c\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c/d\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c/d\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\.\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\.\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\..\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\..\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\a\\\\b\", Some(\"c\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", \"\\\\\\\\a\\\\b\\\\c\", Some(\"..\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\", \"\\\\\\\\a\\\\c\\\\d\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\b\\\\c\\\\d\", \"\\\\\\\\a\\\\c\\\\d\", Some(\"\\\\\\\\?\\\\UNC\\\\b\\\\c\\\\d\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\.\", \"\\\\\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\.\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c/d\", \"\\\\\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\c/d\"));\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\..\", \"\\\\\\\\a\\\\b\", Some(\"\\\\\\\\?\\\\UNC\\\\a\\\\b\\\\..\"));\n+        t!(s: \"\\\\\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\UNC\\\\a\\\\b\", Some(\"c\"));\n+        t!(s: \"\\\\\\\\a\\\\b\\\\c\", \"\\\\\\\\?\\\\UNC\\\\a\\\\c\\\\d\", Some(\"\\\\\\\\a\\\\b\\\\c\"));\n+    }\n+\n+    #[test]\n+    fn test_component_iter() {\n+        macro_rules! t(\n+            (s: $path:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let comps = path.component_iter().to_owned_vec();\n+                    let exp: &[&str] = $exp;\n+                    assert_eq!(comps.as_slice(), exp);\n+                }\n+            );\n+            (v: [$($arg:expr),+], $exp:expr) => (\n+                {\n+                    let path = Path::new(b!($($arg),+));\n+                    let comps = path.component_iter().to_owned_vec();\n+                    let exp: &[&str] = $exp;\n+                    assert_eq!(comps.as_slice(), exp);\n+                }\n+            )\n+        )\n+\n+        t!(v: [\"a\\\\b\\\\c\"], [\"a\", \"b\", \"c\"]);\n+        t!(s: \"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n+        t!(s: \"a\\\\b\\\\d\", [\"a\", \"b\", \"d\"]);\n+        t!(s: \"a\\\\b\\\\cd\", [\"a\", \"b\", \"cd\"]);\n+        t!(s: \"\\\\a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n+        t!(s: \"a\", [\"a\"]);\n+        t!(s: \"\\\\a\", [\"a\"]);\n+        t!(s: \"\\\\\", []);\n+        t!(s: \".\", [\".\"]);\n+        t!(s: \"..\", [\"..\"]);\n+        t!(s: \"..\\\\..\", [\"..\", \"..\"]);\n+        t!(s: \"..\\\\..\\\\foo\", [\"..\", \"..\", \"foo\"]);\n+        t!(s: \"C:foo\\\\bar\", [\"foo\", \"bar\"]);\n+        t!(s: \"C:foo\", [\"foo\"]);\n+        t!(s: \"C:\", []);\n+        t!(s: \"C:\\\\foo\\\\bar\", [\"foo\", \"bar\"]);\n+        t!(s: \"C:\\\\foo\", [\"foo\"]);\n+        t!(s: \"C:\\\\\", []);\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo\\\\bar\", [\"foo\", \"bar\"]);\n+        t!(s: \"\\\\\\\\server\\\\share\\\\foo\", [\"foo\"]);\n+        t!(s: \"\\\\\\\\server\\\\share\", []);\n+        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\", [\"bar\", \"baz\"]);\n+        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\", [\"bar\"]);\n+        t!(s: \"\\\\\\\\?\\\\foo\", []);\n+        t!(s: \"\\\\\\\\?\\\\\", []);\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\", [\"b\"]);\n+        t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", [\"b\"]);\n+        t!(s: \"\\\\\\\\?\\\\foo\\\\bar\\\\\\\\baz\", [\"bar\", \"\", \"baz\"]);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\\\\bar\", [\"foo\", \"bar\"]);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\", [\"foo\"]);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\\", []);\n+        t!(s: \"\\\\\\\\?\\\\C:\\\\foo\\\\\", [\"foo\"]);\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\\\\bar\", [\"foo\", \"bar\"]);\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\", [\"foo\"]);\n+        t!(s: \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", []);\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\", [\"bar\", \"baz\"]);\n+        t!(s: \"\\\\\\\\.\\\\foo\\\\bar\", [\"bar\"]);\n+        t!(s: \"\\\\\\\\.\\\\foo\", []);\n+    }\n }"}]}