{"sha": "79d3ceaac0b4a6ca83f0ff7b8b533649fc5165a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZDNjZWFhYzBiNGE2Y2E4M2YwZmY3YjhiNTMzNjQ5ZmM1MTY1YTE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-17T20:20:55Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-17T20:20:55Z"}, "message": "Steps toward implementing iterators.", "tree": {"sha": "cb102047edb55b39921373dae7bbce2c2e8ea72e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb102047edb55b39921373dae7bbce2c2e8ea72e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79d3ceaac0b4a6ca83f0ff7b8b533649fc5165a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79d3ceaac0b4a6ca83f0ff7b8b533649fc5165a1", "html_url": "https://github.com/rust-lang/rust/commit/79d3ceaac0b4a6ca83f0ff7b8b533649fc5165a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79d3ceaac0b4a6ca83f0ff7b8b533649fc5165a1/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e867d8ea993945803d96396bcba9c07d61d7c95d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e867d8ea993945803d96396bcba9c07d61d7c95d", "html_url": "https://github.com/rust-lang/rust/commit/e867d8ea993945803d96396bcba9c07d61d7c95d"}], "stats": {"total": 123, "additions": 116, "deletions": 7}, "files": [{"sha": "62b5a41510c6e2736d1534c4baa9d4303b7c7e56", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 116, "deletions": 7, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/79d3ceaac0b4a6ca83f0ff7b8b533649fc5165a1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79d3ceaac0b4a6ca83f0ff7b8b533649fc5165a1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=79d3ceaac0b4a6ca83f0ff7b8b533649fc5165a1", "patch": "@@ -88,6 +88,7 @@ state type fn_ctxt = rec(ValueRef llfn,\n                          ValueRef llenv,\n                          ValueRef llretptr,\n                          mutable option.t[ValueRef] llself,\n+                         mutable option.t[ValueRef] lliterbody,\n                          hashmap[ast.def_id, ValueRef] llargs,\n                          hashmap[ast.def_id, ValueRef] llobjfields,\n                          hashmap[ast.def_id, ValueRef] lllocals,\n@@ -399,6 +400,8 @@ fn type_of_explicit_args(@crate_ctxt cx,\n //  - trans_args\n \n fn type_of_fn_full(@crate_ctxt cx,\n+                   // FIXME: change bool flag to tag\n+                   bool is_iter,\n                    option.t[TypeRef] obj_self,\n                    vec[ty.arg] inputs,\n                    @ty.t output) -> TypeRef {\n@@ -436,14 +439,26 @@ fn type_of_fn_full(@crate_ctxt cx,\n         }\n     }\n \n+    if (is_iter) {\n+        // If it's an iter, the 'output' type of the iter is actually the\n+        // *input* type of the function we're given as our iter-block\n+        // argument.\n+        atys += T_fn_pair(type_of_fn_full(cx, false, none[TypeRef],\n+                                          vec(rec(mode=ast.val, ty=output)),\n+                                          plain_ty(ty.ty_nil)));\n+    }\n+\n     // ... then explicit args.\n     atys += type_of_explicit_args(cx, inputs);\n \n     ret T_fn(atys, llvm.LLVMVoidType());\n }\n \n-fn type_of_fn(@crate_ctxt cx, vec[ty.arg] inputs, @ty.t output) -> TypeRef {\n-    ret type_of_fn_full(cx, none[TypeRef], inputs, output);\n+fn type_of_fn(@crate_ctxt cx,\n+              // FIXME: change bool flag to tag\n+              bool is_iter,\n+              vec[ty.arg] inputs, @ty.t output) -> TypeRef {\n+    ret type_of_fn_full(cx, is_iter, none[TypeRef], inputs, output);\n }\n \n fn type_of_native_fn(@crate_ctxt cx, vec[ty.arg] inputs,\n@@ -499,7 +514,8 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n             ret T_struct(tys);\n         }\n         case (ty.ty_fn(?args, ?out)) {\n-            ret T_fn_pair(type_of_fn(cx, args, out));\n+            // FIXME: put iter in ty_fn.\n+            ret T_fn_pair(type_of_fn(cx, false, args, out));\n         }\n         case (ty.ty_native_fn(?args, ?out)) {\n             ret T_fn_pair(type_of_native_fn(cx, args, out));\n@@ -512,6 +528,8 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n             for (ty.method m in meths) {\n                 let TypeRef mty =\n                     type_of_fn_full(cx,\n+                                    // FIXME: support method iters\n+                                    false,\n                                     some[TypeRef](self_ty),\n                                     m.inputs, m.output);\n                 mtys += T_ptr(mty);\n@@ -2141,7 +2159,83 @@ fn trans_for_each(@block_ctxt cx,\n                   @ast.decl decl,\n                   @ast.expr seq,\n                   &ast.block body) -> result {\n-    cx.fcx.ccx.sess.unimpl(\"for each loop\");\n+\n+    /*\n+     * The translation is a little .. complex here. Code like:\n+     *\n+     *    let ty1 p = ...;\n+     *\n+     *    let ty1 q = ...;\n+     *\n+     *    foreach (ty v in foo(a,b)) { body(p,q,v) }\n+     *\n+     *\n+     * Turns into a something like so (C/Rust mishmash):\n+     *\n+     *    type env = { *ty1 p, *ty2 q, ... };\n+     *\n+     *    let env e = { &p, &q, ... };\n+     *\n+     *    fn foreach123_body(env* e, ty v) { body(*(e->p),*(e->q),v) }\n+     *\n+     *    foo([foreach123_body, env*], a, b);\n+     *\n+     */\n+\n+    // Step 1: walk body and figure out which references it makes\n+    // escape. This could be determined upstream, and probably ought\n+    // to be so, eventualy. For first cut, skip this. Null env.\n+\n+    auto env_ty = T_struct(vec(T_ptr(T_i8())));\n+\n+\n+    // Step 2: Declare foreach body function.\n+\n+    // FIXME: possibly support alias-mode here?\n+    auto decl_ty = plain_ty(ty.ty_nil);\n+    alt (decl.node) {\n+        case (ast.decl_local(?local)) {\n+            decl_ty = node_ann_type(cx.fcx.ccx, local.ann);\n+        }\n+    }\n+\n+    let str s =\n+        cx.fcx.ccx.names.next(\"_rust_foreach\")\n+        + sep() + cx.fcx.ccx.path;\n+\n+    // The 'env' arg entering the body function is a fake env member (as in\n+    // the env-part of the normal rust calling convention) that actually\n+    // points to a stack allocated env in this frame. We bundle that env\n+    // pointer along with the foreach-body-fn pointer into a 'normal' fn pair\n+    // and pass it in as a first class fn-arg to the iterator.\n+\n+    auto foreach_llty = type_of_fn_full(cx.fcx.ccx, false, none[TypeRef],\n+                                        vec(rec(mode=ast.val, ty=decl_ty)),\n+                                        plain_ty(ty.ty_nil));\n+\n+    let ValueRef llforeach = decl_fastcall_fn(cx.fcx.ccx.llmod,\n+                                              s, foreach_llty);\n+\n+    // FIXME: handle ty params properly.\n+    let vec[ast.ty_param] ty_params = vec();\n+\n+    auto fcx = new_fn_ctxt(cx.fcx.ccx, s, llforeach);\n+    auto bcx = new_top_block_ctxt(fcx);\n+\n+    // FIXME: populate lllocals from llenv here.\n+    auto res = trans_block(bcx, body);\n+    res.bcx.build.RetVoid();\n+\n+\n+    // Step 3: Call iter passing [llforeach, llenv], plus other args.\n+\n+    alt (seq.node) {\n+        case (ast.expr_call(?f, ?args, ?ann)) {\n+            // FIXME_ finish here by transferring to trans_call,\n+            // suitably refactored.\n+            cx.fcx.ccx.sess.unimpl(\"for each loop in trans\");\n+        }\n+    }\n     fail;\n }\n \n@@ -3538,6 +3632,7 @@ fn new_fn_ctxt(@crate_ctxt cx,\n              llenv=llenv,\n              llretptr=llretptr,\n              mutable llself=none[ValueRef],\n+             mutable lliterbody=none[ValueRef],\n              llargs=llargs,\n              llobjfields=llobjfields,\n              lllocals=lllocals,\n@@ -3553,6 +3648,8 @@ fn new_fn_ctxt(@crate_ctxt cx,\n //  - trans_args\n \n fn create_llargs_for_fn_args(&@fn_ctxt cx,\n+                             // FIXME: change bool flag to tag\n+                             bool is_iter,\n                              option.t[TypeRef] ty_self,\n                              @ty.t ret_ty,\n                              &vec[ast.arg] args,\n@@ -3577,6 +3674,12 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n         }\n     }\n \n+    if (is_iter) {\n+        auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n+        check (llarg as int != 0);\n+        cx.lliterbody = some[ValueRef](llarg);\n+        arg_n += 1u;\n+    }\n \n     for (ast.arg arg in args) {\n         auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n@@ -3713,7 +3816,8 @@ fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n     cx.item_names.insert(cx.path, llfndecl);\n \n     auto fcx = new_fn_ctxt(cx, cx.path, llfndecl);\n-    create_llargs_for_fn_args(fcx, ty_self, ret_ty_of_fn(ann),\n+    create_llargs_for_fn_args(fcx, f.is_iter,\n+                              ty_self, ret_ty_of_fn(ann),\n                               f.decl.inputs, ty_params);\n     auto bcx = new_top_block_ctxt(fcx);\n \n@@ -3754,6 +3858,8 @@ fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n         alt (node_ann_type(cx, m.node.ann).struct) {\n             case (ty.ty_fn(?inputs, ?output)) {\n                 llfnty = type_of_fn_full(cx,\n+                                         // FIXME: support method iters.\n+                                         false,\n                                          some[TypeRef](self_ty),\n                                          inputs, output);\n             }\n@@ -3797,7 +3903,8 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n     }\n \n     auto fcx = new_fn_ctxt(cx, cx.path, llctor_decl);\n-    create_llargs_for_fn_args(fcx, none[TypeRef], ret_ty_of_fn(ann),\n+    create_llargs_for_fn_args(fcx, false,\n+                              none[TypeRef], ret_ty_of_fn(ann),\n                               fn_args, ty_params);\n \n     auto bcx = new_top_block_ctxt(fcx);\n@@ -3925,7 +4032,8 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n     let ValueRef llfndecl = cx.item_ids.get(variant.id);\n \n     auto fcx = new_fn_ctxt(cx, cx.path, llfndecl);\n-    create_llargs_for_fn_args(fcx, none[TypeRef], ret_ty_of_fn(variant.ann),\n+    create_llargs_for_fn_args(fcx, false,\n+                              none[TypeRef], ret_ty_of_fn(variant.ann),\n                               fn_args, ty_params);\n \n     auto bcx = new_top_block_ctxt(fcx);\n@@ -4331,6 +4439,7 @@ fn trans_exit_task_glue(@crate_ctxt cx) {\n                     llenv=C_null(T_opaque_closure_ptr()),\n                     llretptr=C_null(T_ptr(T_nil())),\n                     mutable llself=none[ValueRef],\n+                    mutable lliterbody=none[ValueRef],\n                     llargs=new_def_hash[ValueRef](),\n                     llobjfields=new_def_hash[ValueRef](),\n                     lllocals=new_def_hash[ValueRef](),"}]}