{"sha": "ce4d84365632ea379caa6c79580b1e458dde39f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNGQ4NDM2NTYzMmVhMzc5Y2FhNmM3OTU4MGIxZTQ1OGRkZTM5Zjc=", "commit": {"author": {"name": "Geobert Quach", "email": "geobert@protonmail.com", "date": "2019-09-19T21:06:36Z"}, "committer": {"name": "Geobert Quach", "email": "geobert@protonmail.com", "date": "2019-09-19T21:12:28Z"}, "message": "feat(assists): Apply comments", "tree": {"sha": "af64adf8a3d9b0a2e8c7b70368c9e33ced015af0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af64adf8a3d9b0a2e8c7b70368c9e33ced015af0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce4d84365632ea379caa6c79580b1e458dde39f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce4d84365632ea379caa6c79580b1e458dde39f7", "html_url": "https://github.com/rust-lang/rust/commit/ce4d84365632ea379caa6c79580b1e458dde39f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce4d84365632ea379caa6c79580b1e458dde39f7/comments", "author": {"login": "Geobert", "id": 72570, "node_id": "MDQ6VXNlcjcyNTcw", "avatar_url": "https://avatars.githubusercontent.com/u/72570?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Geobert", "html_url": "https://github.com/Geobert", "followers_url": "https://api.github.com/users/Geobert/followers", "following_url": "https://api.github.com/users/Geobert/following{/other_user}", "gists_url": "https://api.github.com/users/Geobert/gists{/gist_id}", "starred_url": "https://api.github.com/users/Geobert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Geobert/subscriptions", "organizations_url": "https://api.github.com/users/Geobert/orgs", "repos_url": "https://api.github.com/users/Geobert/repos", "events_url": "https://api.github.com/users/Geobert/events{/privacy}", "received_events_url": "https://api.github.com/users/Geobert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Geobert", "id": 72570, "node_id": "MDQ6VXNlcjcyNTcw", "avatar_url": "https://avatars.githubusercontent.com/u/72570?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Geobert", "html_url": "https://github.com/Geobert", "followers_url": "https://api.github.com/users/Geobert/followers", "following_url": "https://api.github.com/users/Geobert/following{/other_user}", "gists_url": "https://api.github.com/users/Geobert/gists{/gist_id}", "starred_url": "https://api.github.com/users/Geobert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Geobert/subscriptions", "organizations_url": "https://api.github.com/users/Geobert/orgs", "repos_url": "https://api.github.com/users/Geobert/repos", "events_url": "https://api.github.com/users/Geobert/events{/privacy}", "received_events_url": "https://api.github.com/users/Geobert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3ab80b332d18056f39e945f3d28894f10f66872", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3ab80b332d18056f39e945f3d28894f10f66872", "html_url": "https://github.com/rust-lang/rust/commit/a3ab80b332d18056f39e945f3d28894f10f66872"}], "stats": {"total": 159, "additions": 59, "deletions": 100}, "files": [{"sha": "e0026706012a9dc0e73d0686b6b73ec98117802f", "filename": "crates/ra_assists/src/raw_string.rs", "status": "modified", "additions": 59, "deletions": 100, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/ce4d84365632ea379caa6c79580b1e458dde39f7/crates%2Fra_assists%2Fsrc%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce4d84365632ea379caa6c79580b1e458dde39f7/crates%2Fra_assists%2Fsrc%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fraw_string.rs?ref=ce4d84365632ea379caa6c79580b1e458dde39f7", "patch": "@@ -1,125 +1,84 @@\n use hir::db::HirDatabase;\r\n-use ra_syntax::{ast::AstNode, ast::Literal, SyntaxText, TextRange, TextUnit};\r\n+use ra_syntax::{ast::AstNode, ast::Literal, TextRange, TextUnit};\r\n \r\n-use crate::{assist_ctx::AssistBuilder, Assist, AssistCtx, AssistId};\r\n+use crate::{Assist, AssistCtx, AssistId};\r\n \r\n pub(crate) fn make_raw_string(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\r\n     let literal = ctx.node_at_offset::<Literal>()?;\r\n-    if literal.token().kind() == ra_syntax::SyntaxKind::STRING {\r\n-        ctx.add_action(AssistId(\"make_raw_string\"), \"make raw string\", |edit| {\r\n-            edit.target(literal.syntax().text_range());\r\n-            edit.insert(literal.syntax().text_range().start(), \"r\");\r\n-        });\r\n-        ctx.build()\r\n-    } else {\r\n-        None\r\n+    if literal.token().kind() != ra_syntax::SyntaxKind::STRING {\r\n+        return None;\r\n     }\r\n+    ctx.add_action(AssistId(\"make_raw_string\"), \"make raw string\", |edit| {\r\n+        edit.target(literal.syntax().text_range());\r\n+        edit.insert(literal.syntax().text_range().start(), \"r\");\r\n+    });\r\n+    ctx.build()\r\n+}\r\n+\r\n+fn find_usual_string_range(s: &str) -> Option<TextRange> {\r\n+    Some(TextRange::from_to(\r\n+        TextUnit::from(s.find('\"')? as u32),\r\n+        TextUnit::from(s.rfind('\"')? as u32),\r\n+    ))\r\n }\r\n \r\n pub(crate) fn make_usual_string(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\r\n     let literal = ctx.node_at_offset::<Literal>()?;\r\n-    if literal.token().kind() == ra_syntax::SyntaxKind::RAW_STRING {\r\n-        ctx.add_action(AssistId(\"make_usual_string\"), \"make usual string\", |edit| {\r\n-            let text = literal.syntax().text();\r\n-            let usual_start_pos = text.find_char('\"').unwrap(); // we have a RAW_STRING\r\n-            let end = literal.syntax().text_range().end();\r\n-            let mut i = 0;\r\n-            let mut pos = 0;\r\n-            let mut c = text.char_at(end - TextUnit::from(i));\r\n-            while c != Some('\"') {\r\n-                if c != None {\r\n-                    pos += 1;\r\n-                }\r\n-                i += 1;\r\n-                c = text.char_at(end - TextUnit::from(i));\r\n-            }\r\n-\r\n-            edit.target(literal.syntax().text_range());\r\n-            edit.delete(TextRange::from_to(\r\n-                literal.syntax().text_range().start(),\r\n-                literal.syntax().text_range().start() + usual_start_pos,\r\n-            ));\r\n-            edit.delete(TextRange::from_to(\r\n-                literal.syntax().text_range().end() - TextUnit::from(pos),\r\n-                literal.syntax().text_range().end(),\r\n-            ));\r\n-            // parse inside string to escape `\"`\r\n-            let start_of_inside = usual_start_pos + TextUnit::from(1);\r\n-            let end_of_inside = text.len() - usual_start_pos - TextUnit::from(1);\r\n-            let inside_str = text.slice(TextRange::from_to(start_of_inside, end_of_inside));\r\n-            escape_double_quote(\r\n-                edit,\r\n-                &inside_str,\r\n-                literal.syntax().text_range().start() + start_of_inside,\r\n-            );\r\n-        });\r\n-        ctx.build()\r\n-    } else {\r\n-        None\r\n+    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\r\n+        return None;\r\n     }\r\n+    let token = literal.token();\r\n+    let text = token.text().as_str();\r\n+    let usual_string_range = find_usual_string_range(text)?;\r\n+    ctx.add_action(AssistId(\"make_usual_string\"), \"make usual string\", |edit| {\r\n+        edit.target(literal.syntax().text_range());\r\n+        // parse inside string to escape `\"`\r\n+        let start_of_inside = usual_string_range.start().to_usize() + 1;\r\n+        let end_of_inside = usual_string_range.end().to_usize();\r\n+        let inside_str = &text[start_of_inside..end_of_inside];\r\n+        let escaped = inside_str.escape_default().to_string();\r\n+        edit.replace(literal.syntax().text_range(), format!(\"\\\"{}\\\"\", escaped));\r\n+    });\r\n+    ctx.build()\r\n }\r\n \r\n pub(crate) fn add_hash(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\r\n     let literal = ctx.node_at_offset::<Literal>()?;\r\n-    if literal.token().kind() == ra_syntax::SyntaxKind::RAW_STRING {\r\n-        ctx.add_action(AssistId(\"add_hash\"), \"add hash to raw string\", |edit| {\r\n-            edit.target(literal.syntax().text_range());\r\n-            edit.insert(literal.syntax().text_range().start() + TextUnit::from(1), \"#\");\r\n-            edit.insert(literal.syntax().text_range().end(), \"#\");\r\n-        });\r\n-        ctx.build()\r\n-    } else {\r\n-        None\r\n+    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\r\n+        return None;\r\n     }\r\n-}\r\n-\r\n-fn escape_double_quote(edit: &mut AssistBuilder, inside_str: &SyntaxText, offset: TextUnit) {\r\n-    let mut start = TextUnit::from(0);\r\n-    inside_str.for_each_chunk(|chunk| {\r\n-        let end = start + TextUnit::of_str(chunk);\r\n-        let mut i = 0;\r\n-        for c in chunk.to_string().chars() {\r\n-            if c == '\"' {\r\n-                edit.insert(offset + start + TextUnit::from(i), \"\\\\\");\r\n-            }\r\n-            i += 1;\r\n-        }\r\n-        start = end;\r\n+    ctx.add_action(AssistId(\"add_hash\"), \"add hash to raw string\", |edit| {\r\n+        edit.target(literal.syntax().text_range());\r\n+        edit.insert(literal.syntax().text_range().start() + TextUnit::of_char('r'), \"#\");\r\n+        edit.insert(literal.syntax().text_range().end(), \"#\");\r\n     });\r\n+    ctx.build()\r\n }\r\n \r\n pub(crate) fn remove_hash(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\r\n     let literal = ctx.node_at_offset::<Literal>()?;\r\n-    if literal.token().kind() == ra_syntax::SyntaxKind::RAW_STRING {\r\n-        if !literal.syntax().text().contains_char('#') {\r\n-            return None;\r\n-        }\r\n-        ctx.add_action(AssistId(\"remove_hash\"), \"remove hash from raw string\", |edit| {\r\n-            edit.target(literal.syntax().text_range());\r\n-            edit.delete(TextRange::from_to(\r\n-                literal.syntax().text_range().start() + TextUnit::from(1),\r\n-                literal.syntax().text_range().start() + TextUnit::from(2),\r\n-            ));\r\n-            edit.delete(TextRange::from_to(\r\n-                literal.syntax().text_range().end() - TextUnit::from(1),\r\n-                literal.syntax().text_range().end(),\r\n-            ));\r\n-            let text = literal.syntax().text();\r\n-            if text.char_at(TextUnit::from(2)) == Some('\"') {\r\n-                // no more hash after assist, need to escape any `\"` in the string\r\n-                let inside_str = text\r\n-                    .slice(TextRange::from_to(TextUnit::from(3), text.len() - TextUnit::from(2)));\r\n-                escape_double_quote(\r\n-                    edit,\r\n-                    &inside_str,\r\n-                    literal.syntax().text_range().start() + TextUnit::from(3),\r\n-                );\r\n-            }\r\n-        });\r\n-        ctx.build()\r\n-    } else {\r\n-        None\r\n+    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\r\n+        return None;\r\n+    }\r\n+    let token = literal.token();\r\n+    let text = token.text().as_str();\r\n+    if text.starts_with(\"r\\\"\") {\r\n+        // no hash to remove\r\n+        return None;\r\n     }\r\n+    ctx.add_action(AssistId(\"remove_hash\"), \"remove hash from raw string\", |edit| {\r\n+        edit.target(literal.syntax().text_range());\r\n+        let result = &text[2..text.len() - 1];\r\n+        let result = if result.starts_with(\"\\\"\") {\r\n+            // no more hash, escape\r\n+            let internal_str = &result[1..result.len() - 1];\r\n+            format!(\"\\\"{}\\\"\", internal_str.escape_default().to_string())\r\n+        } else {\r\n+            result.to_owned()\r\n+        };\r\n+        edit.replace(literal.syntax().text_range(), format!(\"r{}\", result));\r\n+    });\r\n+    ctx.build()\r\n }\r\n \r\n #[cfg(test)]\r"}]}