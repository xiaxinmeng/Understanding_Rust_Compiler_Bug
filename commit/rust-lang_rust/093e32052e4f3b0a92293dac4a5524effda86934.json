{"sha": "093e32052e4f3b0a92293dac4a5524effda86934", "node_id": "C_kwDOAAsO6NoAKDA5M2UzMjA1MmU0ZjNiMGE5MjI5M2RhYzRhNTUyNGVmZmRhODY5MzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-06T16:05:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-06T16:05:00Z"}, "message": "Auto merge of #8398 - Jarcho:unordered_transmute, r=llogiq\n\nAdd lint `transmute_undefined_repr`\n\nPartially implements #3999 and #546\n\nThis doesn't consider `enum`s at all right now as those are going to be a pain to deal with. This also allows `#[repr(Rust)]` structs with only one non-zero sized fields. I think those are technically undefined when transmuted.\n\nchangelog: Add lint `transmute_undefined_repr`", "tree": {"sha": "ec9d002c642d298896ddfe9f53c6d6548facab5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec9d002c642d298896ddfe9f53c6d6548facab5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/093e32052e4f3b0a92293dac4a5524effda86934", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/093e32052e4f3b0a92293dac4a5524effda86934", "html_url": "https://github.com/rust-lang/rust/commit/093e32052e4f3b0a92293dac4a5524effda86934", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/093e32052e4f3b0a92293dac4a5524effda86934/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68b44986de6a8c9e844afa55693a24f0d4a0978e", "url": "https://api.github.com/repos/rust-lang/rust/commits/68b44986de6a8c9e844afa55693a24f0d4a0978e", "html_url": "https://github.com/rust-lang/rust/commit/68b44986de6a8c9e844afa55693a24f0d4a0978e"}, {"sha": "68993b1f6cf94701ff420e51aa927c568ae7eef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/68993b1f6cf94701ff420e51aa927c568ae7eef2", "html_url": "https://github.com/rust-lang/rust/commit/68993b1f6cf94701ff420e51aa927c568ae7eef2"}], "stats": {"total": 514, "additions": 463, "deletions": 51}, "files": [{"sha": "c9adf77c0d639a0560073ea4889d32b06bb60344", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -3475,6 +3475,7 @@ Released 2018-09-13\n [`transmute_num_to_bytes`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_num_to_bytes\n [`transmute_ptr_to_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ptr\n [`transmute_ptr_to_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n+[`transmute_undefined_repr`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_undefined_repr\n [`transmutes_expressible_as_ptr_casts`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmutes_expressible_as_ptr_casts\n [`transmuting_null`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmuting_null\n [`trivial_regex`]: https://rust-lang.github.io/rust-clippy/master/index.html#trivial_regex"}, {"sha": "d93e34e76b492bc9320fd4eb6aa6bf8ce4a3a151", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -277,6 +277,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(transmute::TRANSMUTE_INT_TO_FLOAT),\n     LintId::of(transmute::TRANSMUTE_NUM_TO_BYTES),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_REF),\n+    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),"}, {"sha": "d013daa8e082a72eb316681fb421749cf455292c", "filename": "clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -58,6 +58,7 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(swap::ALMOST_SWAPPED),\n     LintId::of(to_string_in_display::TO_STRING_IN_DISPLAY),\n+    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),"}, {"sha": "a80320a578f0e7ba609c90fad800c08ab7c8b456", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -473,6 +473,7 @@ store.register_lints(&[\n     transmute::TRANSMUTE_NUM_TO_BYTES,\n     transmute::TRANSMUTE_PTR_TO_PTR,\n     transmute::TRANSMUTE_PTR_TO_REF,\n+    transmute::TRANSMUTE_UNDEFINED_REPR,\n     transmute::UNSOUND_COLLECTION_TRANSMUTE,\n     transmute::USELESS_TRANSMUTE,\n     transmute::WRONG_TRANSMUTE,"}, {"sha": "0b07726519ecd35db54c71d2d16b35bcc9afb79b", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -5,6 +5,7 @@\n #![feature(control_flow_enum)]\n #![feature(drain_filter)]\n #![feature(iter_intersperse)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(once_cell)]\n #![feature(rustc_private)]"}, {"sha": "4c320deecc28b02b79a19f119be4e49cddb7a5f4", "filename": "clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -7,6 +7,7 @@ mod transmute_num_to_bytes;\n mod transmute_ptr_to_ptr;\n mod transmute_ptr_to_ref;\n mod transmute_ref_to_ref;\n+mod transmute_undefined_repr;\n mod transmutes_expressible_as_ptr_casts;\n mod unsound_collection_transmute;\n mod useless_transmute;\n@@ -355,6 +356,30 @@ declare_clippy_lint! {\n     \"transmute between collections of layout-incompatible types\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for transmutes either to or from a type which does not have a defined representation.\n+    ///\n+    /// ### Why is this bad?\n+    /// The results of such a transmute are not defined.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct Foo<T>(u32, T);\n+    /// let _ = unsafe { core::mem::transmute::<Foo<u32>, Foo<i32>>(Foo(0u32, 0u32)) };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// #[repr(C)]\n+    /// struct Foo<T>(u32, T);\n+    /// let _ = unsafe { core::mem::transmute::<Foo<u32>, Foo<i32>>(Foo(0u32, 0u32)) };\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub TRANSMUTE_UNDEFINED_REPR,\n+    correctness,\n+    \"transmute to or from a type with an undefined representation\"\n+}\n+\n declare_lint_pass!(Transmute => [\n     CROSSPOINTER_TRANSMUTE,\n     TRANSMUTE_PTR_TO_REF,\n@@ -369,13 +394,13 @@ declare_lint_pass!(Transmute => [\n     TRANSMUTE_NUM_TO_BYTES,\n     UNSOUND_COLLECTION_TRANSMUTE,\n     TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n+    TRANSMUTE_UNDEFINED_REPR,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Transmute {\n-    #[allow(clippy::similar_names, clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(path_expr, args) = e.kind;\n+            if let ExprKind::Call(path_expr, [arg]) = e.kind;\n             if let ExprKind::Path(ref qpath) = path_expr.kind;\n             if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n             if cx.tcx.is_diagnostic_item(sym::transmute, def_id);\n@@ -385,28 +410,31 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                 // And see https://github.com/rust-lang/rust/issues/51911 for dereferencing raw pointers.\n                 let const_context = in_constant(cx, e.hir_id);\n \n-                let from_ty = cx.typeck_results().expr_ty(&args[0]);\n+                let from_ty = cx.typeck_results().expr_ty(arg);\n                 let to_ty = cx.typeck_results().expr_ty(e);\n \n                 // If useless_transmute is triggered, the other lints can be skipped.\n-                if useless_transmute::check(cx, e, from_ty, to_ty, args) {\n+                if useless_transmute::check(cx, e, from_ty, to_ty, arg) {\n                     return;\n                 }\n \n-                let mut linted = wrong_transmute::check(cx, e, from_ty, to_ty);\n-                linted |= crosspointer_transmute::check(cx, e, from_ty, to_ty);\n-                linted |= transmute_ptr_to_ref::check(cx, e, from_ty, to_ty, args, qpath);\n-                linted |= transmute_int_to_char::check(cx, e, from_ty, to_ty, args);\n-                linted |= transmute_ref_to_ref::check(cx, e, from_ty, to_ty, args, const_context);\n-                linted |= transmute_ptr_to_ptr::check(cx, e, from_ty, to_ty, args);\n-                linted |= transmute_int_to_bool::check(cx, e, from_ty, to_ty, args);\n-                linted |= transmute_int_to_float::check(cx, e, from_ty, to_ty, args, const_context);\n-                linted |= transmute_float_to_int::check(cx, e, from_ty, to_ty, args, const_context);\n-                linted |= transmute_num_to_bytes::check(cx, e, from_ty, to_ty, args, const_context);\n-                linted |= unsound_collection_transmute::check(cx, e, from_ty, to_ty);\n+                let linted = wrong_transmute::check(cx, e, from_ty, to_ty)\n+                    | crosspointer_transmute::check(cx, e, from_ty, to_ty)\n+                    | transmute_ptr_to_ref::check(cx, e, from_ty, to_ty, arg, qpath)\n+                    | transmute_int_to_char::check(cx, e, from_ty, to_ty, arg)\n+                    | transmute_ref_to_ref::check(cx, e, from_ty, to_ty, arg, const_context)\n+                    | transmute_ptr_to_ptr::check(cx, e, from_ty, to_ty, arg)\n+                    | transmute_int_to_bool::check(cx, e, from_ty, to_ty, arg)\n+                    | transmute_int_to_float::check(cx, e, from_ty, to_ty, arg, const_context)\n+                    | transmute_float_to_int::check(cx, e, from_ty, to_ty, arg, const_context)\n+                    | transmute_num_to_bytes::check(cx, e, from_ty, to_ty, arg, const_context)\n+                    | (\n+                        unsound_collection_transmute::check(cx, e, from_ty, to_ty)\n+                        || transmute_undefined_repr::check(cx, e, from_ty, to_ty)\n+                    );\n \n                 if !linted {\n-                    transmutes_expressible_as_ptr_casts::check(cx, e, from_ty, to_ty, args);\n+                    transmutes_expressible_as_ptr_casts::check(cx, e, from_ty, to_ty, arg);\n                 }\n             }\n         }"}, {"sha": "d5ef86dc4e572703af49941486832c5c9bea462e", "filename": "clippy_lints/src/transmute/transmute_float_to_int.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -15,7 +15,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    mut arg: &'tcx Expr<'_>,\n     const_context: bool,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n@@ -26,37 +26,36 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n                 |diag| {\n-                    let mut expr = &args[0];\n-                    let mut arg = sugg::Sugg::hir(cx, expr, \"..\");\n+                    let mut sugg = sugg::Sugg::hir(cx, arg, \"..\");\n \n-                    if let ExprKind::Unary(UnOp::Neg, inner_expr) = &expr.kind {\n-                        expr = inner_expr;\n+                    if let ExprKind::Unary(UnOp::Neg, inner_expr) = &arg.kind {\n+                        arg = inner_expr;\n                     }\n \n                     if_chain! {\n                         // if the expression is a float literal and it is unsuffixed then\n                         // add a suffix so the suggestion is valid and unambiguous\n-                        if let ExprKind::Lit(lit) = &expr.kind;\n+                        if let ExprKind::Lit(lit) = &arg.kind;\n                         if let ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) = lit.node;\n                         then {\n-                            let op = format!(\"{}{}\", arg, float_ty.name_str()).into();\n-                            match arg {\n-                                sugg::Sugg::MaybeParen(_) => arg = sugg::Sugg::MaybeParen(op),\n-                                _ => arg = sugg::Sugg::NonParen(op)\n+                            let op = format!(\"{}{}\", sugg, float_ty.name_str()).into();\n+                            match sugg {\n+                                sugg::Sugg::MaybeParen(_) => sugg = sugg::Sugg::MaybeParen(op),\n+                                _ => sugg = sugg::Sugg::NonParen(op)\n                             }\n                         }\n                     }\n \n-                    arg = sugg::Sugg::NonParen(format!(\"{}.to_bits()\", arg.maybe_par()).into());\n+                    sugg = sugg::Sugg::NonParen(format!(\"{}.to_bits()\", sugg.maybe_par()).into());\n \n                     // cast the result of `to_bits` if `to_ty` is signed\n-                    arg = if let ty::Int(int_ty) = to_ty.kind() {\n-                        arg.as_ty(int_ty.name_str().to_string())\n+                    sugg = if let ty::Int(int_ty) = to_ty.kind() {\n+                        sugg.as_ty(int_ty.name_str().to_string())\n                     } else {\n-                        arg\n+                        sugg\n                     };\n \n-                    diag.span_suggestion(e.span, \"consider using\", arg.to_string(), Applicability::Unspecified);\n+                    diag.span_suggestion(e.span, \"consider using\", sugg.to_string(), Applicability::Unspecified);\n                 },\n             );\n             true"}, {"sha": "8c50b58ca4b862af20360774f2a4654df4fa1085", "filename": "clippy_lints/src/transmute/transmute_int_to_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -15,7 +15,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n         (ty::Int(ty::IntTy::I8) | ty::Uint(ty::UintTy::U8), ty::Bool) => {\n@@ -25,7 +25,7 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 &format!(\"transmute from a `{}` to a `bool`\", from_ty),\n                 |diag| {\n-                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     let zero = sugg::Sugg::NonParen(Cow::from(\"0\"));\n                     diag.span_suggestion(\n                         e.span,"}, {"sha": "3eb07b68992a89b96ff10c4a40277023c8878536", "filename": "clippy_lints/src/transmute/transmute_int_to_char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n         (ty::Int(ty::IntTy::I32) | ty::Uint(ty::UintTy::U32), &ty::Char) => {\n@@ -24,7 +24,7 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 &format!(\"transmute from a `{}` to a `char`\", from_ty),\n                 |diag| {\n-                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     let arg = if let ty::Int(_) = from_ty.kind() {\n                         arg.as_ty(ast::UintTy::U32.name_str())\n                     } else {"}, {"sha": "b8703052e6c869750a09751579885123c0e1143a", "filename": "clippy_lints/src/transmute/transmute_int_to_float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -13,7 +13,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n     const_context: bool,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n@@ -24,7 +24,7 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n                 |diag| {\n-                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     let arg = if let ty::Int(int_ty) = from_ty.kind() {\n                         arg.as_ty(format!(\n                             \"u{}\","}, {"sha": "52d193d11e1a08dab87adca2de3548d904b3d16f", "filename": "clippy_lints/src/transmute/transmute_num_to_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -13,7 +13,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n     const_context: bool,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n@@ -33,7 +33,7 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n                 |diag| {\n-                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     diag.span_suggestion(\n                         e.span,\n                         \"consider using `to_ne_bytes()`\","}, {"sha": "d712b33de9e1a49ead17804603354e5d09055bcd", "filename": "clippy_lints/src/transmute/transmute_ptr_to_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -13,7 +13,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n         (ty::RawPtr(_), ty::RawPtr(to_ty)) => {\n@@ -23,7 +23,7 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 \"transmute from a pointer to a pointer\",\n                 |diag| {\n-                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                    if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                         let sugg = arg.as_ty(cx.tcx.mk_ptr(*to_ty));\n                         diag.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n                     }"}, {"sha": "5699f8e92cfca82428614d957a7075a249f6e071", "filename": "clippy_lints/src/transmute/transmute_ptr_to_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n     qpath: &'tcx QPath<'_>,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n@@ -28,7 +28,7 @@ pub(super) fn check<'tcx>(\n                     from_ty, to_ty\n                 ),\n                 |diag| {\n-                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     let (deref, cast) = if *mutbl == Mutability::Mut {\n                         (\"&mut *\", \"*mut\")\n                     } else {"}, {"sha": "fdef8bac7f9b093faf73679e13d3c319596b69c9", "filename": "clippy_lints/src/transmute/transmute_ref_to_ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -15,7 +15,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n     const_context: bool,\n ) -> bool {\n     let mut triggered = false;\n@@ -41,7 +41,7 @@ pub(super) fn check<'tcx>(\n                     format!(\n                         \"std::str::from_utf8{}({}).unwrap()\",\n                         postfix,\n-                        snippet(cx, args[0].span, \"..\"),\n+                        snippet(cx, arg.span, \"..\"),\n                     ),\n                     Applicability::Unspecified,\n                 );\n@@ -54,7 +54,7 @@ pub(super) fn check<'tcx>(\n                         TRANSMUTE_PTR_TO_PTR,\n                         e.span,\n                         \"transmute from a reference to a reference\",\n-                        |diag| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                        |diag| if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                             let ty_from_and_mut = ty::TypeAndMut {\n                                 ty: ty_from,\n                                 mutbl: *from_mutbl"}, {"sha": "4b7c493278f21918e081a16f25db4acf9ef95fab", "filename": "clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -0,0 +1,291 @@\n+use super::TRANSMUTE_UNDEFINED_REPR;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::subst::{GenericArg, Subst};\n+use rustc_middle::ty::{self, Ty, TyS, TypeAndMut};\n+use rustc_span::Span;\n+\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty_orig: Ty<'tcx>,\n+    to_ty_orig: Ty<'tcx>,\n+) -> bool {\n+    let mut from_ty = cx.tcx.erase_regions(from_ty_orig);\n+    let mut to_ty = cx.tcx.erase_regions(to_ty_orig);\n+\n+    while !TyS::same_type(from_ty, to_ty) {\n+        match reduce_refs(cx, e.span, from_ty, to_ty) {\n+            ReducedTys::FromFatPtr { unsized_ty, .. } => {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                    |diag| {\n+                        if !TyS::same_type(from_ty_orig.peel_refs(), unsized_ty) {\n+                            diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+            ReducedTys::ToFatPtr { unsized_ty, .. } => {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n+                    |diag| {\n+                        if !TyS::same_type(to_ty_orig.peel_refs(), unsized_ty) {\n+                            diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+            ReducedTys::ToPtr {\n+                from_ty: from_sub_ty,\n+                to_ty: to_sub_ty,\n+            } => match reduce_ty(cx, from_sub_ty) {\n+                ReducedTy::UnorderedFields(from_ty) => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                        |diag| {\n+                            if !TyS::same_type(from_ty_orig.peel_refs(), from_ty) {\n+                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                ReducedTy::Ref(from_sub_ty) => {\n+                    from_ty = from_sub_ty;\n+                    to_ty = to_sub_ty;\n+                    continue;\n+                },\n+                _ => break,\n+            },\n+            ReducedTys::FromPtr {\n+                from_ty: from_sub_ty,\n+                to_ty: to_sub_ty,\n+            } => match reduce_ty(cx, to_sub_ty) {\n+                ReducedTy::UnorderedFields(to_ty) => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n+                        |diag| {\n+                            if !TyS::same_type(to_ty_orig.peel_refs(), to_ty) {\n+                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                ReducedTy::Ref(to_sub_ty) => {\n+                    from_ty = from_sub_ty;\n+                    to_ty = to_sub_ty;\n+                    continue;\n+                },\n+                _ => break,\n+            },\n+            ReducedTys::Other {\n+                from_ty: from_sub_ty,\n+                to_ty: to_sub_ty,\n+            } => match (reduce_ty(cx, from_sub_ty), reduce_ty(cx, to_sub_ty)) {\n+                (ReducedTy::IntArray, _) | (_, ReducedTy::IntArray) => return false,\n+                (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty))\n+                    if !TyS::same_type(from_ty, to_ty) =>\n+                {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\n+                            \"transmute from `{}` to `{}`, both of which have an undefined layout\",\n+                            from_ty_orig, to_ty_orig\n+                        ),\n+                        |diag| {\n+                            if let (Some(from_def), Some(to_def)) = (from_ty.ty_adt_def(), to_ty.ty_adt_def())\n+                                && from_def == to_def\n+                            {\n+                                diag.note(&format!(\n+                                    \"two instances of the same generic type (`{}`) may have different layouts\",\n+                                    cx.tcx.item_name(from_def.did)\n+                                ));\n+                            } else {\n+                                if !TyS::same_type(from_ty_orig.peel_refs(), from_ty) {\n+                                    diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                                }\n+                                if !TyS::same_type(to_ty_orig.peel_refs(), to_ty) {\n+                                    diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                                }\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                (\n+                    ReducedTy::UnorderedFields(from_ty),\n+                    ReducedTy::Other(_) | ReducedTy::OrderedFields(_) | ReducedTy::Ref(_),\n+                ) => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                        |diag| {\n+                            if !TyS::same_type(from_ty_orig.peel_refs(), from_ty) {\n+                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                (\n+                    ReducedTy::Other(_) | ReducedTy::OrderedFields(_) | ReducedTy::Ref(_),\n+                    ReducedTy::UnorderedFields(to_ty),\n+                ) => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute into `{}` which has an undefined layout\", to_ty_orig),\n+                        |diag| {\n+                            if !TyS::same_type(to_ty_orig.peel_refs(), to_ty) {\n+                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                (ReducedTy::Ref(from_sub_ty), ReducedTy::Ref(to_sub_ty)) => {\n+                    from_ty = from_sub_ty;\n+                    to_ty = to_sub_ty;\n+                    continue;\n+                },\n+                (\n+                    ReducedTy::OrderedFields(_) | ReducedTy::Ref(_) | ReducedTy::Other(_),\n+                    ReducedTy::OrderedFields(_) | ReducedTy::Ref(_) | ReducedTy::Other(_),\n+                )\n+                | (ReducedTy::UnorderedFields(_), ReducedTy::UnorderedFields(_)) => break,\n+            },\n+        }\n+    }\n+\n+    false\n+}\n+\n+enum ReducedTys<'tcx> {\n+    FromFatPtr { unsized_ty: Ty<'tcx> },\n+    ToFatPtr { unsized_ty: Ty<'tcx> },\n+    ToPtr { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n+    FromPtr { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n+    Other { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n+}\n+\n+fn reduce_refs<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    span: Span,\n+    mut from_ty: Ty<'tcx>,\n+    mut to_ty: Ty<'tcx>,\n+) -> ReducedTys<'tcx> {\n+    loop {\n+        return match (from_ty.kind(), to_ty.kind()) {\n+            (\n+                ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. }),\n+                ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. }),\n+            ) => {\n+                from_ty = from_sub_ty;\n+                to_ty = to_sub_ty;\n+                continue;\n+            },\n+            (ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }), _)\n+                if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n+            {\n+                ReducedTys::FromFatPtr { unsized_ty }\n+            },\n+            (_, ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }))\n+                if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n+            {\n+                ReducedTys::ToFatPtr { unsized_ty }\n+            },\n+            (ty::Ref(_, from_ty, _) | ty::RawPtr(TypeAndMut { ty: from_ty, .. }), _) => {\n+                ReducedTys::FromPtr { from_ty, to_ty }\n+            },\n+            (_, ty::Ref(_, to_ty, _) | ty::RawPtr(TypeAndMut { ty: to_ty, .. })) => {\n+                ReducedTys::ToPtr { from_ty, to_ty }\n+            },\n+            _ => ReducedTys::Other { from_ty, to_ty },\n+        };\n+    }\n+}\n+\n+enum ReducedTy<'tcx> {\n+    OrderedFields(Ty<'tcx>),\n+    UnorderedFields(Ty<'tcx>),\n+    Ref(Ty<'tcx>),\n+    Other(Ty<'tcx>),\n+    IntArray,\n+}\n+\n+fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx> {\n+    loop {\n+        ty = cx.tcx.try_normalize_erasing_regions(cx.param_env, ty).unwrap_or(ty);\n+        return match *ty.kind() {\n+            ty::Array(sub_ty, _) if matches!(sub_ty.kind(), ty::Int(_) | ty::Uint(_)) => ReducedTy::IntArray,\n+            ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n+                ty = sub_ty;\n+                continue;\n+            },\n+            ty::Tuple(args) => {\n+                let mut iter = args.iter().map(GenericArg::expect_ty);\n+                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n+                    return ReducedTy::OrderedFields(ty);\n+                };\n+                if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n+                    ty = sized_ty;\n+                    continue;\n+                }\n+                ReducedTy::UnorderedFields(ty)\n+            },\n+            ty::Adt(def, substs) if def.is_struct() => {\n+                if def.repr.inhibit_struct_field_reordering_opt() {\n+                    return ReducedTy::OrderedFields(ty);\n+                }\n+                let mut iter = def\n+                    .non_enum_variant()\n+                    .fields\n+                    .iter()\n+                    .map(|f| cx.tcx.type_of(f.did).subst(cx.tcx, substs));\n+                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n+                    return ReducedTy::OrderedFields(ty);\n+                };\n+                if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n+                    ty = sized_ty;\n+                    continue;\n+                }\n+                ReducedTy::UnorderedFields(ty)\n+            },\n+            ty::Ref(..) | ty::RawPtr(_) => ReducedTy::Ref(ty),\n+            _ => ReducedTy::Other(ty),\n+        };\n+    }\n+}\n+\n+fn is_zero_sized_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    if let Ok(ty) = cx.tcx.try_normalize_erasing_regions(cx.param_env, ty)\n+        && let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty))\n+    {\n+        layout.layout.size.bytes() == 0\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "626d7cd46fc43c1383717d3b670780df06bc6201", "filename": "clippy_lints/src/transmute/transmutes_expressible_as_ptr_casts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n ) -> bool {\n     if can_be_expressed_as_pointer_cast(cx, e, from_ty, to_ty) {\n         span_lint_and_then(\n@@ -26,7 +26,7 @@ pub(super) fn check<'tcx>(\n                 from_ty, to_ty\n             ),\n             |diag| {\n-                if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                     let sugg = arg.as_ty(&to_ty.to_string()).to_string();\n                     diag.span_suggestion(e.span, \"try\", sugg, Applicability::MachineApplicable);\n                 }"}, {"sha": "998f97eb5d8c65990e2f7348a256a16c6b8072ec", "filename": "clippy_lints/src/transmute/useless_transmute.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -13,7 +13,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n         _ if from_ty == to_ty => {\n@@ -32,7 +32,7 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 \"transmute from a reference to a pointer\",\n                 |diag| {\n-                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                    if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                         let rty_and_mut = ty::TypeAndMut {\n                             ty: rty,\n                             mutbl: *rty_mutbl,\n@@ -57,7 +57,7 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 \"transmute from an integer to a pointer\",\n                 |diag| {\n-                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                    if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                         diag.span_suggestion(\n                             e.span,\n                             \"try\","}, {"sha": "e0510d942c200843abd0432b756f60ab9002d265", "filename": "tests/ui/crashes/ice-4968.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/tests%2Fui%2Fcrashes%2Fice-4968.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/tests%2Fui%2Fcrashes%2Fice-4968.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-4968.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -3,6 +3,7 @@\n // Test for https://github.com/rust-lang/rust-clippy/issues/4968\n \n #![warn(clippy::unsound_collection_transmute)]\n+#![allow(clippy::transmute_undefined_repr)]\n \n trait Trait {\n     type Assoc;"}, {"sha": "71539940fbf270e23d043b52d792f2e505c67906", "filename": "tests/ui/transmute_undefined_repr.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/tests%2Fui%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/tests%2Fui%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_undefined_repr.rs?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -0,0 +1,44 @@\n+#![warn(clippy::transmute_undefined_repr)]\n+#![allow(clippy::unit_arg)]\n+\n+fn value<T>() -> T {\n+    unimplemented!()\n+}\n+\n+struct Empty;\n+struct Ty<T>(T);\n+struct Ty2<T, U>(T, U);\n+\n+#[repr(C)]\n+struct Ty2C<T, U>(T, U);\n+\n+fn main() {\n+    unsafe {\n+        let _: () = core::mem::transmute(value::<Empty>());\n+        let _: Empty = core::mem::transmute(value::<()>());\n+\n+        let _: Ty<u32> = core::mem::transmute(value::<u32>());\n+        let _: Ty<u32> = core::mem::transmute(value::<u32>());\n+\n+        let _: Ty2C<u32, i32> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n+        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n+\n+        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Ok, Ty2 types are the same\n+        let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Ok, Ty2 types are the same\n+\n+        let _: Ty2<u32, f32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+        let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+\n+        let _: Ty<&()> = core::mem::transmute(value::<&()>());\n+        let _: &() = core::mem::transmute(value::<Ty<&()>>());\n+\n+        let _: &Ty2<u32, f32> = core::mem::transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+        let _: Ty<&Ty2<u32, i32>> = core::mem::transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+\n+        let _: Ty<usize> = core::mem::transmute(value::<&Ty2<u32, i32>>()); // Ok, pointer to usize conversion\n+        let _: &Ty2<u32, i32> = core::mem::transmute(value::<Ty<usize>>()); // Ok, pointer to usize conversion\n+\n+        let _: Ty<[u8; 8]> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Ok, transmute to byte array\n+        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty<[u8; 8]>>()); // Ok, transmute from byte array\n+    }\n+}"}, {"sha": "040c63c7afa625202d558097aec418e11a13a1b2", "filename": "tests/ui/transmute_undefined_repr.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/093e32052e4f3b0a92293dac4a5524effda86934/tests%2Fui%2Ftransmute_undefined_repr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/093e32052e4f3b0a92293dac4a5524effda86934/tests%2Fui%2Ftransmute_undefined_repr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_undefined_repr.stderr?ref=093e32052e4f3b0a92293dac4a5524effda86934", "patch": "@@ -0,0 +1,44 @@\n+error: transmute from `Ty2<u32, i32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:23:33\n+   |\n+LL |         let _: Ty2C<u32, i32> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::transmute-undefined-repr` implied by `-D warnings`\n+\n+error: transmute into `Ty2<u32, i32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:24:32\n+   |\n+LL |         let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `Ty<Ty2<u32, i32>>` to `Ty2<u32, f32>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:29:32\n+   |\n+LL |         let _: Ty2<u32, f32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Ty2`) may have different layouts\n+\n+error: transmute from `Ty2<u32, f32>` to `Ty<Ty2<u32, i32>>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:30:36\n+   |\n+LL |         let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Ty2`) may have different layouts\n+\n+error: transmute to `&Ty2<u32, f32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:35:33\n+   |\n+LL |         let _: &Ty2<u32, f32> = core::mem::transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `&Ty2<u32, f32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:36:37\n+   |\n+LL |         let _: Ty<&Ty2<u32, i32>> = core::mem::transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}]}