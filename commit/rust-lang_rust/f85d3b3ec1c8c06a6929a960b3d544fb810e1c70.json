{"sha": "f85d3b3ec1c8c06a6929a960b3d544fb810e1c70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NWQzYjNlYzFjOGMwNmE2OTI5YTk2MGIzZDU0NGZiODEwZTFjNzA=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T06:09:39Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T23:31:58Z"}, "message": "std: reform fn sigs of FileDescriptor methods (better result signalling)", "tree": {"sha": "0e31d5780779e908b22455d58b388c7c4f49b02c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e31d5780779e908b22455d58b388c7c4f49b02c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f85d3b3ec1c8c06a6929a960b3d544fb810e1c70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f85d3b3ec1c8c06a6929a960b3d544fb810e1c70", "html_url": "https://github.com/rust-lang/rust/commit/f85d3b3ec1c8c06a6929a960b3d544fb810e1c70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f85d3b3ec1c8c06a6929a960b3d544fb810e1c70/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "429b5f88f91e5f23f1ad04f6f9938fd1fa6c39a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/429b5f88f91e5f23f1ad04f6f9938fd1fa6c39a1", "html_url": "https://github.com/rust-lang/rust/commit/429b5f88f91e5f23f1ad04f6f9938fd1fa6c39a1"}], "stats": {"total": 88, "additions": 46, "deletions": 42}, "files": [{"sha": "eb1b12f3eb21a557b78a21ebaa0c2657a67e092b", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 46, "deletions": 42, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f85d3b3ec1c8c06a6929a960b3d544fb810e1c70/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85d3b3ec1c8c06a6929a960b3d544fb810e1c70/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=f85d3b3ec1c8c06a6929a960b3d544fb810e1c70", "patch": "@@ -12,7 +12,7 @@ use prelude::*;\n use ptr::null;\n use libc::c_void;\n use rt::uv::{Request, NativeHandle, Loop, FsCallback, Buf,\n-             status_to_maybe_uv_error_with_loop};\n+             status_to_maybe_uv_error_with_loop, UvError};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n use super::super::io::support::PathLike;\n@@ -86,13 +86,21 @@ impl NativeHandle<*uvll::uv_fs_t> for FsRequest {\n         match self { &FsRequest(ptr) => ptr }\n     }\n }\n+    fn sync_cleanup(loop_: &Loop, result: int)\n+          -> Result<int, UvError> {\n+        match status_to_maybe_uv_error_with_loop(loop_.native_handle(), result as i32) {\n+            Some(err) => Err(err),\n+            None => Ok(result)\n+        }\n+    }\n \n pub struct FileDescriptor(c_int);\n impl FileDescriptor {\n     fn new(fd: c_int) -> FileDescriptor {\n         FileDescriptor(fd)\n     }\n \n+\n     pub fn from_open_req(req: &mut FsRequest) -> FileDescriptor {\n         FileDescriptor::new(req.get_result())\n     }\n@@ -115,12 +123,13 @@ impl FileDescriptor {\n         result\n     }\n     pub fn open<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int,\n-               cb: FsCallback) -> int {\n-        FileDescriptor::open_common(loop_, path, flags, mode, Some(cb))\n+               cb: FsCallback) {\n+        FileDescriptor::open_common(loop_, path, flags, mode, Some(cb));\n     }\n \n-    pub fn open_sync<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int) -> int {\n-        FileDescriptor::open_common(loop_, path, flags, mode, None)\n+    pub fn open_sync<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int) -> Result<int, UvError> {\n+        let result = FileDescriptor::open_common(loop_, path, flags, mode, None);\n+        sync_cleanup(&loop_, result)\n     }\n \n     fn unlink_common<P: PathLike>(loop_: Loop, path: &P, cb: Option<FsCallback>) -> int {\n@@ -139,11 +148,13 @@ impl FileDescriptor {\n         if is_sync { req.cleanup_and_delete(); }\n         result\n     }\n-    pub fn unlink<P: PathLike>(loop_: Loop, path: &P, cb: FsCallback) -> int {\n-        FileDescriptor::unlink_common(loop_, path, Some(cb))\n+    pub fn unlink<P: PathLike>(loop_: Loop, path: &P, cb: FsCallback) {\n+        let result = FileDescriptor::unlink_common(loop_, path, Some(cb));\n+        sync_cleanup(&loop_, result);\n     }\n-    pub fn unlink_sync<P: PathLike>(loop_: Loop, path: &P) -> int {\n-        FileDescriptor::unlink_common(loop_, path, None)\n+    pub fn unlink_sync<P: PathLike>(loop_: Loop, path: &P) -> Result<int, UvError> {\n+        let result = FileDescriptor::unlink_common(loop_, path, None);\n+        sync_cleanup(&loop_, result)\n     }\n \n     // as per bnoordhuis in #libuv: offset >= 0 uses prwrite instead of write\n@@ -166,13 +177,13 @@ impl FileDescriptor {\n         if is_sync { req.cleanup_and_delete(); }\n         result\n     }\n-    pub fn write(&mut self, loop_: Loop, buf: Buf, offset: i64, cb: FsCallback)\n-          -> int {\n-        self.write_common(loop_, buf, offset, Some(cb))\n+    pub fn write(&mut self, loop_: Loop, buf: Buf, offset: i64, cb: FsCallback) {\n+        self.write_common(loop_, buf, offset, Some(cb));\n     }\n     pub fn write_sync(&mut self, loop_: Loop, buf: Buf, offset: i64)\n-          -> int {\n-        self.write_common(loop_, buf, offset, None)\n+          -> Result<int, UvError> {\n+        let result = self.write_common(loop_, buf, offset, None);\n+        sync_cleanup(&loop_, result)\n     }\n \n     fn read_common(&mut self, loop_: Loop, buf: Buf,\n@@ -194,13 +205,13 @@ impl FileDescriptor {\n         if is_sync { req.cleanup_and_delete(); }\n         result\n     }\n-    pub fn read(&mut self, loop_: Loop, buf: Buf, offset: i64, cb: FsCallback)\n-          -> int {\n-        self.read_common(loop_, buf, offset, Some(cb))\n+    pub fn read(&mut self, loop_: Loop, buf: Buf, offset: i64, cb: FsCallback) {\n+        self.read_common(loop_, buf, offset, Some(cb));\n     }\n     pub fn read_sync(&mut self, loop_: Loop, buf: Buf, offset: i64)\n-          -> int {\n-        self.read_common(loop_, buf, offset, None)\n+          -> Result<int, UvError> {\n+        let result = self.read_common(loop_, buf, offset, None);\n+        sync_cleanup(&loop_, result)\n     }\n \n     fn close_common(self, loop_: Loop, cb: Option<FsCallback>) -> int {\n@@ -217,11 +228,12 @@ impl FileDescriptor {\n         if is_sync { req.cleanup_and_delete(); }\n         result\n     }\n-    pub fn close(self, loop_: Loop, cb: FsCallback) -> int {\n-        self.close_common(loop_, Some(cb))\n+    pub fn close(self, loop_: Loop, cb: FsCallback) {\n+        self.close_common(loop_, Some(cb));\n     }\n-    pub fn close_sync(self, loop_: Loop) -> int {\n-        self.close_common(loop_, None)\n+    pub fn close_sync(self, loop_: Loop) -> Result<int, UvError> {\n+        let result = self.close_common(loop_, None);\n+        sync_cleanup(&loop_, result)\n     }\n }\n extern fn compl_cb(req: *uv_fs_t) {\n@@ -265,8 +277,7 @@ mod test {\n     use str;\n     use unstable::run_in_bare_thread;\n     use path::Path;\n-    use rt::uv::{Loop, Buf, slice_to_uv_buf,\n-                 status_to_maybe_uv_error_with_loop};\n+    use rt::uv::{Loop, Buf, slice_to_uv_buf};\n     use libc::{O_CREAT, O_RDWR, O_RDONLY,\n                S_IWUSR, S_IRUSR}; //NOTE: need defs for S_**GRP|S_**OTH in libc:: ...\n                //S_IRGRP, S_IROTH};\n@@ -358,31 +369,26 @@ mod test {\n             // open/create\n             let result = FileDescriptor::open_sync(loop_, &Path(path_str),\n                                                    create_flags as int, mode as int);\n-            assert!(status_to_maybe_uv_error_with_loop(\n-                loop_.native_handle(), result as i32).is_none());\n-            let mut fd = FileDescriptor(result as i32);\n+            assert!(result.is_ok());\n+            let mut fd = FileDescriptor(result.unwrap() as i32);\n             // write\n             let result = fd.write_sync(loop_, write_buf, -1);\n-            assert!(status_to_maybe_uv_error_with_loop(\n-                loop_.native_handle(), result as i32).is_none());\n+            assert!(result.is_ok());\n             // close\n             let result = fd.close_sync(loop_);\n-            assert!(status_to_maybe_uv_error_with_loop(\n-                loop_.native_handle(), result as i32).is_none());\n+            assert!(result.is_ok());\n             // re-open\n             let result = FileDescriptor::open_sync(loop_, &Path(path_str),\n                                                    read_flags as int,0);\n-            assert!(status_to_maybe_uv_error_with_loop(\n-                loop_.native_handle(), result as i32).is_none());\n+            assert!(result.is_ok());\n             let len = 1028;\n-            let mut fd = FileDescriptor(result as i32);\n+            let mut fd = FileDescriptor(result.unwrap() as i32);\n             // read\n             let read_mem: ~[u8] = vec::from_elem(len, 0u8);\n             let buf = slice_to_uv_buf(read_mem);\n             let result = fd.read_sync(loop_, buf, 0);\n-            assert!(status_to_maybe_uv_error_with_loop(\n-                loop_.native_handle(), result as i32).is_none());\n-            let nread = result;\n+            assert!(result.is_ok());\n+            let nread = result.unwrap();\n             // nread == 0 would be EOF.. we know it's >= zero because otherwise\n             // the above assert would fail\n             if nread > 0 {\n@@ -391,12 +397,10 @@ mod test {\n                 assert!(read_str == ~\"hello\");\n                 // close\n                 let result = fd.close_sync(loop_);\n-                assert!(status_to_maybe_uv_error_with_loop(\n-                    loop_.native_handle(), result as i32).is_none());\n+                assert!(result.is_ok());\n                 // unlink\n                 let result = FileDescriptor::unlink_sync(loop_, &Path(path_str));\n-                assert!(status_to_maybe_uv_error_with_loop(\n-                    loop_.native_handle(), result as i32).is_none());\n+                assert!(result.is_ok());\n             } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }\n             loop_.close();\n         }"}]}