{"sha": "fa83c10e96bc7eecf2c01a87fa802ee70b42344c", "node_id": "C_kwDOAAsO6NoAKGZhODNjMTBlOTZiYzdlZWNmMmMwMWE4N2ZhODAyZWU3MGI0MjM0NGM", "commit": {"author": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-02-10T14:54:50Z"}, "committer": {"name": "Boxy", "email": "supbscripter@gmail.com", "date": "2023-02-10T14:56:28Z"}, "message": "implement `compute_alias_eq_goal`", "tree": {"sha": "2eddd45286e5305402abd575a876b90f3e732285", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2eddd45286e5305402abd575a876b90f3e732285"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa83c10e96bc7eecf2c01a87fa802ee70b42344c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa83c10e96bc7eecf2c01a87fa802ee70b42344c", "html_url": "https://github.com/rust-lang/rust/commit/fa83c10e96bc7eecf2c01a87fa802ee70b42344c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa83c10e96bc7eecf2c01a87fa802ee70b42344c/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f89e2aef272e1222adc4bf95de2baf802c92a2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f89e2aef272e1222adc4bf95de2baf802c92a2d", "html_url": "https://github.com/rust-lang/rust/commit/1f89e2aef272e1222adc4bf95de2baf802c92a2d"}], "stats": {"total": 177, "additions": 163, "deletions": 14}, "files": [{"sha": "f795047709e4033088ed6c65df34a12fe622e24f", "filename": "compiler/rustc_infer/src/infer/projection.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fa83c10e96bc7eecf2c01a87fa802ee70b42344c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa83c10e96bc7eecf2c01a87fa802ee70b42344c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs?ref=fa83c10e96bc7eecf2c01a87fa802ee70b42344c", "patch": "@@ -21,16 +21,28 @@ impl<'tcx> InferCtxt<'tcx> {\n         recursion_depth: usize,\n         obligations: &mut Vec<PredicateObligation<'tcx>>,\n     ) -> Ty<'tcx> {\n-        let def_id = projection_ty.def_id;\n-        let ty_var = self.next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::NormalizeProjectionType,\n-            span: self.tcx.def_span(def_id),\n-        });\n-        let projection =\n-            ty::Binder::dummy(ty::ProjectionPredicate { projection_ty, term: ty_var.into() });\n-        let obligation =\n-            Obligation::with_depth(self.tcx, cause, recursion_depth, param_env, projection);\n-        obligations.push(obligation);\n-        ty_var\n+        if self.tcx.trait_solver_next() {\n+            // FIXME(-Ztrait-solver=next): Instead of branching here,\n+            // completely change the normalization routine with the new solver.\n+            //\n+            // The new solver correctly handles projection equality so this hack\n+            // is not necessary. if re-enabled it should emit `PredicateKind::AliasEq`\n+            // not `PredicateKind::Clause(Clause::Projection(..))` as in the new solver\n+            // `Projection` is used as `normalizes-to` which will fail for `<T as Trait>::Assoc eq ?0`.\n+            return projection_ty.to_ty(self.tcx);\n+        } else {\n+            let def_id = projection_ty.def_id;\n+            let ty_var = self.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::NormalizeProjectionType,\n+                span: self.tcx.def_span(def_id),\n+            });\n+            let projection = ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::Projection(\n+                ty::ProjectionPredicate { projection_ty, term: ty_var.into() },\n+            )));\n+            let obligation =\n+                Obligation::with_depth(self.tcx, cause, recursion_depth, param_env, projection);\n+            obligations.push(obligation);\n+            ty_var\n+        }\n     }\n }"}, {"sha": "0e86b2666b2d6c4c1ac58d9febaeb4637038ab98", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fa83c10e96bc7eecf2c01a87fa802ee70b42344c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa83c10e96bc7eecf2c01a87fa802ee70b42344c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=fa83c10e96bc7eecf2c01a87fa802ee70b42344c", "patch": "@@ -970,6 +970,33 @@ impl<'tcx> Term<'tcx> {\n             TermKind::Const(c) => c.into(),\n         }\n     }\n+\n+    /// This function returns `None` for `AliasKind::Opaque`.\n+    ///\n+    /// FIXME: rename `AliasTy` to `AliasTerm` and make sure we correctly\n+    /// deal with constants.\n+    pub fn to_alias_term_no_opaque(&self, tcx: TyCtxt<'tcx>) -> Option<AliasTy<'tcx>> {\n+        match self.unpack() {\n+            TermKind::Ty(ty) => match ty.kind() {\n+                ty::Alias(kind, alias_ty) => match kind {\n+                    AliasKind::Projection => Some(*alias_ty),\n+                    AliasKind::Opaque => None,\n+                },\n+                _ => None,\n+            },\n+            TermKind::Const(ct) => match ct.kind() {\n+                ConstKind::Unevaluated(uv) => Some(tcx.mk_alias_ty(uv.def.did, uv.substs)),\n+                _ => None,\n+            },\n+        }\n+    }\n+\n+    pub fn is_infer(&self) -> bool {\n+        match self.unpack() {\n+            TermKind::Ty(ty) => ty.is_ty_or_numeric_infer(),\n+            TermKind::Const(ct) => ct.is_ct_infer(),\n+        }\n+    }\n }\n \n const TAG_MASK: usize = 0b11;"}, {"sha": "e56588c58bd05eb78a639df4d70f67e860109222", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 113, "deletions": 3, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/fa83c10e96bc7eecf2c01a87fa802ee70b42344c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa83c10e96bc7eecf2c01a87fa802ee70b42344c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=fa83c10e96bc7eecf2c01a87fa802ee70b42344c", "patch": "@@ -42,6 +42,8 @@ mod trait_goals;\n \n pub use fulfill::FulfillmentCtxt;\n \n+use self::infcx_ext::InferCtxtExt;\n+\n /// A goal is a statement, i.e. `predicate`, we want to prove\n /// given some assumptions, i.e. `param_env`.\n ///\n@@ -81,6 +83,21 @@ pub struct Response<'tcx> {\n     pub certainty: Certainty,\n }\n \n+trait CanonicalResponseExt {\n+    fn has_no_inference_or_external_constraints(&self) -> bool;\n+}\n+\n+impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n+    fn has_no_inference_or_external_constraints(&self) -> bool {\n+        // so that we get a compile error when regions are supported\n+        // so this code can be checked for being correct\n+        let _: () = self.value.external_constraints.regions;\n+\n+        self.value.var_values.is_identity()\n+            && self.value.external_constraints.opaque_types.is_empty()\n+    }\n+}\n+\n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n pub enum Certainty {\n     Yes,\n@@ -302,9 +319,8 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n-                ty::PredicateKind::AliasEq(..) => {\n-                    // FIXME(deferred_projection_equality)\n-                    todo!()\n+                ty::PredicateKind::AliasEq(lhs, rhs) => {\n+                    self.compute_alias_eq_goal(Goal { param_env, predicate: (lhs, rhs) })\n                 }\n             }\n         } else {\n@@ -402,6 +418,63 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             None => self.make_canonical_response(Certainty::AMBIGUOUS),\n         }\n     }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn compute_alias_eq_goal(\n+        &mut self,\n+        goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>)>,\n+    ) -> QueryResult<'tcx> {\n+        let tcx = self.tcx();\n+\n+        let evaluate_normalizes_to = |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other| {\n+            debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n+            let r = ecx.infcx.probe(|_| {\n+                let (_, certainty) = ecx.evaluate_goal(goal.with(\n+                    tcx,\n+                    ty::Binder::dummy(ty::ProjectionPredicate {\n+                        projection_ty: alias,\n+                        term: other,\n+                    }),\n+                ))?;\n+                ecx.make_canonical_response(certainty)\n+            });\n+            debug!(\"evaluate_normalizes_to(..) -> {:?}\", r);\n+            r\n+        };\n+\n+        if goal.predicate.0.is_infer() || goal.predicate.1.is_infer() {\n+            bug!(\n+                \"`AliasEq` goal with an infer var on lhs or rhs which should have been instantiated\"\n+            );\n+        }\n+\n+        match (\n+            goal.predicate.0.to_alias_term_no_opaque(tcx),\n+            goal.predicate.1.to_alias_term_no_opaque(tcx),\n+        ) {\n+            (None, None) => bug!(\"`AliasEq` goal without an alias on either lhs or rhs\"),\n+            (Some(alias), None) => evaluate_normalizes_to(self, alias, goal.predicate.1),\n+            (None, Some(alias)) => evaluate_normalizes_to(self, alias, goal.predicate.0),\n+            (Some(alias_lhs), Some(alias_rhs)) => {\n+                debug!(\"compute_alias_eq_goal: both sides are aliases\");\n+\n+                let mut candidates = Vec::with_capacity(3);\n+\n+                // Evaluate all 3 potential candidates for the alias' being equal\n+                candidates.push(evaluate_normalizes_to(self, alias_lhs, goal.predicate.1));\n+                candidates.push(evaluate_normalizes_to(self, alias_rhs, goal.predicate.0));\n+                candidates.push(self.infcx.probe(|_| {\n+                    debug!(\"compute_alias_eq_goal: alias defids are equal, equating substs\");\n+                    let nested_goals = self.infcx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n+                    self.evaluate_all_and_make_canonical_response(nested_goals)\n+                }));\n+\n+                debug!(?candidates);\n+\n+                self.try_merge_responses(candidates.into_iter())\n+            }\n+        }\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n@@ -453,6 +526,43 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     ) -> QueryResult<'tcx> {\n         self.evaluate_all(goals).and_then(|certainty| self.make_canonical_response(certainty))\n     }\n+\n+    fn try_merge_responses(\n+        &mut self,\n+        responses: impl Iterator<Item = QueryResult<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        let candidates = responses.into_iter().flatten().collect::<Box<[_]>>();\n+\n+        if candidates.is_empty() {\n+            return Err(NoSolution);\n+        }\n+\n+        // FIXME(-Ztreat-solver=next): We should instead try to find a `Certainty::Yes` response with\n+        // a subset of the constraints that all the other responses have.\n+        let one = candidates[0];\n+        if candidates[1..].iter().all(|resp| resp == &one) {\n+            return Ok(one);\n+        }\n+\n+        if let Some(response) = candidates.iter().find(|response| {\n+            response.value.certainty == Certainty::Yes\n+                && response.has_no_inference_or_external_constraints()\n+        }) {\n+            return Ok(response.clone());\n+        }\n+\n+        let certainty = candidates.iter().fold(Certainty::AMBIGUOUS, |certainty, response| {\n+            certainty.unify_and(response.value.certainty)\n+        });\n+        // FIXME(-Ztrait-solver=next): We should take the intersection of the constraints on all the\n+        // responses and use that for the constraints of this ambiguous response.\n+        let response = self.make_canonical_response(certainty);\n+        if let Ok(response) = &response {\n+            assert!(response.has_no_inference_or_external_constraints());\n+        }\n+\n+        response\n+    }\n }\n \n #[instrument(level = \"debug\", skip(infcx), ret)]"}]}