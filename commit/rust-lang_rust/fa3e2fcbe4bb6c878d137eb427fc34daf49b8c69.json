{"sha": "fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhM2UyZmNiZTRiYjZjODc4ZDEzN2ViNDI3ZmMzNGRhZjQ5YjhjNjk=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-16T13:23:31Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-10-04T11:54:01Z"}, "message": "Defer creating drop trees in MIR lowering until leaving that scope", "tree": {"sha": "bc88bfa53c74fb287b3b5d513cfbcf1a6b278434", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc88bfa53c74fb287b3b5d513cfbcf1a6b278434"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl95t9kACgkQtAh+UQ6Y\nsWQccw//QQWy8nX8XSOjbtV0CF9D0YRq5v6CoChObl3LxgrDyGrm28pmNXreiFBy\n+hfCzd4+FTd4axsjKCvRmSebJjxNj09UcOIdGiX9oRO7k5D4PJW6t+H5pxXXQ9Z0\nbRfk6fcBdIw3sb6XOFssyiH2HBUINCH9DaGOgoQ42kc2/7lCUqIY23u3Ok+9IKQf\nbSjkA+37T8Gczdci3wedUcfVmkUfJxUAfo5iDabRR4cj9UyDYB9CLm3VJZLUiYPo\nW2igMTPW02hhWPOCi/1fX5KTsZtvd6m1sM6bPIVJYC5uCceHHzBK0jkVoVrgWkDT\nzgbg6AjzFhXLg3lQ6OUnQBAzpllKFiaAQ5mJUrqB7MeJntf9bPZ8IgNVE5oka26D\n64v8MpnkleAcFKumCvH2aoenxpak8viWAO14wuh5b9qQGFY41ZfeOHwXFeilcKE6\nfuKLgGe3SVW+cKcOVvMIxtFzyuFuT4aEO8hvVgQga2/0CvktGMN0ufmHaTKvVaev\nZaHrh7ilyvMEzdC/k3jhFZ8HVR32AV4kGKUP0UZDGHpcuKllUUNn+o+Eb1Kz/MdQ\nlRGsgkvf2XyWPaeIKG/k6f3ckrmx+za3Y3n7YO60arGZG7qPIxiqL2U5loK+V4rU\nkrwe61gOU35pq3sKa+yxxxnjbhPXF+RCUhSP2pmBHRFaKnWD0H4=\n=4MtT\n-----END PGP SIGNATURE-----", "payload": "tree bc88bfa53c74fb287b3b5d513cfbcf1a6b278434\nparent 0d37dca25a51fb900a402c94c8818ad1c2789e30\nauthor Matthew Jasper <mjjasper1@gmail.com> 1573910611 +0000\ncommitter Aaron Hill <aa1ronham@gmail.com> 1601812441 -0400\n\nDefer creating drop trees in MIR lowering until leaving that scope\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69", "html_url": "https://github.com/rust-lang/rust/commit/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d37dca25a51fb900a402c94c8818ad1c2789e30", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d37dca25a51fb900a402c94c8818ad1c2789e30", "html_url": "https://github.com/rust-lang/rust/commit/0d37dca25a51fb900a402c94c8818ad1c2789e30"}], "stats": {"total": 1498, "additions": 768, "deletions": 730}, "files": [{"sha": "cdabc70d72ebc20bf7040b6816eaa32b8d770ff5", "filename": "compiler/rustc_mir/src/util/graphviz.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgraphviz.rs?ref=fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69", "patch": "@@ -111,13 +111,24 @@ where\n     write!(w, r#\"<table border=\"0\" cellborder=\"1\" cellspacing=\"0\">\"#)?;\n \n     // Basic block number at the top.\n+    let (blk, bgcolor) = if data.is_cleanup {\n+        (format!(\"{} (cleanup)\", block.index()), \"lightblue\")\n+    } else {\n+        let color = if dark_mode {\n+            \"dimgray\"\n+        } else {\n+            \"gray\"\n+        };\n+        (format!(\"{}\", block.index()), \"gray\")\n+    };\n     write!(\n         w,\n         r#\"<tr><td bgcolor=\"{bgcolor}\" {attrs} colspan=\"{colspan}\">{blk}</td></tr>\"#,\n         bgcolor = if dark_mode { \"dimgray\" } else { \"gray\" },\n         attrs = r#\"align=\"center\"\"#,\n         colspan = num_cols,\n-        blk = block.index()\n+        blk = blk,\n+        color = color\n     )?;\n \n     init(w)?;"}, {"sha": "d5f72e6f22dfa29af8a3c5870d9ab593a17428b7", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69", "patch": "@@ -28,14 +28,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.in_opt_scope(opt_destruction_scope.map(|de| (de, source_info)), move |this| {\n             this.in_scope((region_scope, source_info), LintLevel::Inherited, move |this| {\n                 if targeted_by_break {\n-                    // This is a `break`-able block\n-                    let exit_block = this.cfg.start_new_block();\n-                    let block_exit =\n-                        this.in_breakable_scope(None, exit_block, destination, |this| {\n-                            this.ast_block_stmts(destination, block, span, stmts, expr, safety_mode)\n-                        });\n-                    this.cfg.goto(unpack!(block_exit), source_info, exit_block);\n-                    exit_block.unit()\n+                    this.in_breakable_scope(None, destination, span, |this| {\n+                        Some(this.ast_block_stmts(\n+                            destination,\n+                            block,\n+                            span,\n+                            stmts,\n+                            expr,\n+                            safety_mode,\n+                        ))\n+                    })\n                 } else {\n                     this.ast_block_stmts(destination, block, span, stmts, expr, safety_mode)\n                 }"}, {"sha": "a12c22fb850e4aa726d4b1f935198265925611c6", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69", "patch": "@@ -140,32 +140,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // body, even when the exact code in the body cannot unwind\n \n                 let loop_block = this.cfg.start_new_block();\n-                let exit_block = this.cfg.start_new_block();\n \n                 // Start the loop.\n                 this.cfg.goto(block, source_info, loop_block);\n \n-                this.in_breakable_scope(Some(loop_block), exit_block, destination, move |this| {\n+                this.in_breakable_scope(Some(loop_block), destination, expr_span, move |this| {\n                     // conduct the test, if necessary\n                     let body_block = this.cfg.start_new_block();\n-                    let diverge_cleanup = this.diverge_cleanup();\n                     this.cfg.terminate(\n                         loop_block,\n                         source_info,\n-                        TerminatorKind::FalseUnwind {\n-                            real_target: body_block,\n-                            unwind: Some(diverge_cleanup),\n-                        },\n+                        TerminatorKind::FalseUnwind { real_target: body_block, unwind: None },\n                     );\n+                    this.diverge_from(loop_block);\n \n                     // The \u201creturn\u201d value of the loop body must always be an unit. We therefore\n                     // introduce a unit temporary as the destination for the loop body.\n                     let tmp = this.get_unit_temp();\n                     // Execute the body, branching back to the test.\n                     let body_block_end = unpack!(this.into(tmp, body_block, body));\n                     this.cfg.goto(body_block_end, source_info, loop_block);\n-                });\n-                exit_block.unit()\n+\n+                    // Loops are only exited by `break` expressions.\n+                    None\n+                })\n             }\n             ExprKind::Call { ty, fun, args, from_hir_call, fn_span } => {\n                 let intrinsic = match *ty.kind() {\n@@ -206,7 +204,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         .collect();\n \n                     let success = this.cfg.start_new_block();\n-                    let cleanup = this.diverge_cleanup();\n \n                     this.record_operands_moved(&args);\n \n@@ -218,7 +215,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         TerminatorKind::Call {\n                             func: fun,\n                             args,\n-                            cleanup: Some(cleanup),\n+                            cleanup: None,\n                             // FIXME(varkor): replace this with an uninhabitedness-based check.\n                             // This requires getting access to the current module to call\n                             // `tcx.is_ty_uninhabited_from`, which is currently tricky to do.\n@@ -231,6 +228,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             fn_span,\n                         },\n                     );\n+                    this.diverge_from(block);\n                     success.unit()\n                 }\n             }\n@@ -437,12 +435,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let scope = this.local_scope();\n                 let value = unpack!(block = this.as_operand(block, scope, value));\n                 let resume = this.cfg.start_new_block();\n-                let cleanup = this.generator_drop_cleanup();\n                 this.cfg.terminate(\n                     block,\n                     source_info,\n-                    TerminatorKind::Yield { value, resume, resume_arg: destination, drop: cleanup },\n+                    TerminatorKind::Yield { value, resume, resume_arg: destination, drop: None },\n                 );\n+                this.generator_drop_cleanup(block);\n                 resume.unit()\n             }\n "}, {"sha": "b7bd67fea0679a30b4d130ba5af9584d2d496ac7", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69", "patch": "@@ -228,8 +228,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         outer_source_info: SourceInfo,\n         fake_borrow_temps: Vec<(Place<'tcx>, Local)>,\n     ) -> BlockAnd<()> {\n-        let match_scope = self.scopes.topmost();\n-\n         let arm_end_blocks: Vec<_> = arm_candidates\n             .into_iter()\n             .map(|(arm, candidate)| {\n@@ -250,7 +248,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let arm_block = this.bind_pattern(\n                         outer_source_info,\n                         candidate,\n-                        arm.guard.as_ref().map(|g| (g, match_scope)),\n+                        arm.guard.as_ref(),\n                         &fake_borrow_temps,\n                         scrutinee_span,\n                         Some(arm.scope),\n@@ -287,7 +285,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         outer_source_info: SourceInfo,\n         candidate: Candidate<'_, 'tcx>,\n-        guard: Option<(&Guard<'tcx>, region::Scope)>,\n+        guard: Option<&Guard<'tcx>>,\n         fake_borrow_temps: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n         arm_scope: Option<region::Scope>,\n@@ -1592,7 +1590,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         &mut self,\n         candidate: Candidate<'pat, 'tcx>,\n         parent_bindings: &[(Vec<Binding<'tcx>>, Vec<Ascription<'tcx>>)],\n-        guard: Option<(&Guard<'tcx>, region::Scope)>,\n+        guard: Option<&Guard<'tcx>>,\n         fake_borrows: &Vec<(Place<'tcx>, Local)>,\n         scrutinee_span: Span,\n         schedule_drops: bool,\n@@ -1704,7 +1702,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         //      the reference that we create for the arm.\n         //    * So we eagerly create the reference for the arm and then take a\n         //      reference to that.\n-        if let Some((guard, region_scope)) = guard {\n+        if let Some(guard) = guard {\n             let tcx = self.hir.tcx();\n             let bindings = parent_bindings\n                 .iter()\n@@ -1748,12 +1746,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 unreachable\n             });\n             let outside_scope = self.cfg.start_new_block();\n-            self.exit_scope(\n-                source_info.span,\n-                region_scope,\n-                otherwise_post_guard_block,\n-                outside_scope,\n-            );\n+            self.exit_top_scope(otherwise_post_guard_block, outside_scope, source_info);\n             self.false_edges(\n                 outside_scope,\n                 otherwise_block,"}, {"sha": "1700426d87f4836a05b583edb4131d19cf33cf11", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69", "patch": "@@ -418,7 +418,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let bool_ty = self.hir.bool_ty();\n         let eq_result = self.temp(bool_ty, source_info.span);\n         let eq_block = self.cfg.start_new_block();\n-        let cleanup = self.diverge_cleanup();\n         self.cfg.terminate(\n             block,\n             source_info,\n@@ -435,12 +434,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     literal: method,\n                 }),\n                 args: vec![val, expect],\n-                destination: Some((eq_result, eq_block)),\n-                cleanup: Some(cleanup),\n+                destination: Some((eq_result.clone(), eq_block)),\n+                cleanup: None,\n                 from_hir_call: false,\n                 fn_span: source_info.span,\n             },\n         );\n+        self.diverge_from(block);\n \n         if let [success_block, fail_block] = *make_target_blocks(self) {\n             // check the result"}, {"sha": "ae186eac40d59107e01871b72fef330717d86eef", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 28, "deletions": 63, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69", "patch": "@@ -345,11 +345,6 @@ struct Builder<'a, 'tcx> {\n \n     var_debug_info: Vec<VarDebugInfo<'tcx>>,\n \n-    /// Cached block with the `RESUME` terminator; this is created\n-    /// when first set of cleanups are built.\n-    cached_resume_block: Option<BasicBlock>,\n-    /// Cached block with the `RETURN` terminator.\n-    cached_return_block: Option<BasicBlock>,\n     /// Cached block with the `UNREACHABLE` terminator.\n     cached_unreachable_block: Option<BasicBlock>,\n }\n@@ -609,50 +604,34 @@ where\n         region::Scope { id: body.value.hir_id.local_id, data: region::ScopeData::CallSite };\n     let arg_scope =\n         region::Scope { id: body.value.hir_id.local_id, data: region::ScopeData::Arguments };\n-    let mut block = START_BLOCK;\n     let source_info = builder.source_info(span);\n     let call_site_s = (call_site_scope, source_info);\n-    unpack!(\n-        block = builder.in_scope(call_site_s, LintLevel::Inherited, |builder| {\n-            if should_abort_on_panic(tcx, fn_def_id, abi) {\n-                builder.schedule_abort();\n-            }\n-\n-            let arg_scope_s = (arg_scope, source_info);\n-            // `return_block` is called when we evaluate a `return` expression, so\n-            // we just use `START_BLOCK` here.\n-            unpack!(\n-                block = builder.in_breakable_scope(\n-                    None,\n-                    START_BLOCK,\n-                    Place::return_place(),\n-                    |builder| {\n-                        builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n-                            builder.args_and_body(\n-                                block,\n-                                fn_def_id.to_def_id(),\n-                                &arguments,\n-                                arg_scope,\n-                                &body.value,\n-                            )\n-                        })\n-                    },\n-                )\n-            );\n-            // Attribute epilogue to function's closing brace\n-            let fn_end = span_with_body.shrink_to_hi();\n-            let source_info = builder.source_info(fn_end);\n-            let return_block = builder.return_block();\n-            builder.cfg.goto(block, source_info, return_block);\n-            builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n-            // Attribute any unreachable codepaths to the function's closing brace\n-            if let Some(unreachable_block) = builder.cached_unreachable_block {\n-                builder.cfg.terminate(unreachable_block, source_info, TerminatorKind::Unreachable);\n-            }\n-            return_block.unit()\n-        })\n-    );\n-    assert_eq!(block, builder.return_block());\n+    unpack!(builder.in_scope(call_site_s, LintLevel::Inherited, |builder| {\n+        let arg_scope_s = (arg_scope, source_info);\n+        // Attribute epilogue to function's closing brace\n+        let fn_end = span_with_body.shrink_to_hi();\n+        let return_block =\n+            unpack!(builder.in_breakable_scope(None, Place::return_place(), fn_end, |builder| {\n+                Some(builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n+                    builder.args_and_body(\n+                        START_BLOCK,\n+                        fn_def_id.to_def_id(),\n+                        &arguments,\n+                        arg_scope,\n+                        &body.value,\n+                    )\n+                }))\n+            }));\n+        let source_info = builder.source_info(fn_end);\n+        builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n+        let should_abort = should_abort_on_panic(tcx, fn_def_id, abi);\n+        builder.build_drop_trees(should_abort);\n+        // Attribute any unreachable codepaths to the function's closing brace\n+        if let Some(unreachable_block) = builder.cached_unreachable_block {\n+            builder.cfg.terminate(unreachable_block, source_info, TerminatorKind::Unreachable);\n+        }\n+        return_block.unit()\n+    }));\n \n     let spread_arg = if abi == Abi::RustCall {\n         // RustCall pseudo-ABI untuples the last argument.\n@@ -686,8 +665,7 @@ fn construct_const<'a, 'tcx>(\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n \n-    // Constants can't `return` so a return block should not be created.\n-    assert_eq!(builder.cached_return_block, None);\n+    builder.build_drop_trees(false);\n \n     // Constants may be match expressions in which case an unreachable block may\n     // be created, so terminate it properly.\n@@ -754,7 +732,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             fn_span: span,\n             arg_count,\n             generator_kind,\n-            scopes: Default::default(),\n+            scopes: scope::Scopes::new(),\n             block_context: BlockContext::new(),\n             source_scopes: IndexVec::new(),\n             source_scope: OUTERMOST_SOURCE_SCOPE,\n@@ -767,8 +745,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             var_indices: Default::default(),\n             unit_temp: None,\n             var_debug_info: vec![],\n-            cached_resume_block: None,\n-            cached_return_block: None,\n             cached_unreachable_block: None,\n         };\n \n@@ -1003,17 +979,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    fn return_block(&mut self) -> BasicBlock {\n-        match self.cached_return_block {\n-            Some(rb) => rb,\n-            None => {\n-                let rb = self.cfg.start_new_block();\n-                self.cached_return_block = Some(rb);\n-                rb\n-            }\n-        }\n-    }\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "fcaee9e00cb3bf59993abe134d9ed045dd9b427b", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 696, "deletions": 627, "changes": 1323, "blob_url": "https://github.com/rust-lang/rust/blob/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69", "patch": "@@ -6,30 +6,31 @@ contents, and then pop it off. Every scope is named by a\n \n ### SEME Regions\n \n-When pushing a new scope, we record the current point in the graph (a\n+When pushing a new [Scope], we record the current point in the graph (a\n basic block); this marks the entry to the scope. We then generate more\n stuff in the control-flow graph. Whenever the scope is exited, either\n via a `break` or `return` or just by fallthrough, that marks an exit\n from the scope. Each lexical scope thus corresponds to a single-entry,\n multiple-exit (SEME) region in the control-flow graph.\n \n-For now, we keep a mapping from each `region::Scope` to its\n-corresponding SEME region for later reference (see caveat in next\n-paragraph). This is because region scopes are tied to\n-them. Eventually, when we shift to non-lexical lifetimes, there should\n-be no need to remember this mapping.\n+For now, we record the `region::Scope` to each SEME region for later reference\n+(see caveat in next paragraph). This is because destruction scopes are tied to\n+them. This may change in the future so that MIR lowering determines its own\n+destruction scopes.\n \n ### Not so SEME Regions\n \n In the course of building matches, it sometimes happens that certain code\n (namely guards) gets executed multiple times. This means that the scope lexical\n scope may in fact correspond to multiple, disjoint SEME regions. So in fact our\n-mapping is from one scope to a vector of SEME regions.\n+mapping is from one scope to a vector of SEME regions. Since the SEME regions\n+are disjoint, the mapping is still one-to-one for the set of SEME regions that\n+we're currently in.\n \n-Also in matches, the scopes assigned to arms are not even SEME regions! Each\n-arm has a single region with one entry for each pattern. We manually\n+Also in matches, the scopes assigned to arms are not always even SEME regions!\n+Each arm has a single region with one entry for each pattern. We manually\n manipulate the scheduled drops in this scope to avoid dropping things multiple\n-times, although drop elaboration would clean this up for value drops.\n+times.\n \n ### Drops\n \n@@ -60,25 +61,23 @@ that for now); any later drops would also drop `y`.\n \n There are numerous \"normal\" ways to early exit a scope: `break`,\n `continue`, `return` (panics are handled separately). Whenever an\n-early exit occurs, the method `exit_scope` is called. It is given the\n+early exit occurs, the method `break_scope` is called. It is given the\n current point in execution where the early exit occurs, as well as the\n scope you want to branch to (note that all early exits from to some\n-other enclosing scope). `exit_scope` will record this exit point and\n-also add all drops.\n+other enclosing scope). `break_scope` will record the set of drops currently\n+scheduled in a [DropTree]. Later, before `in_breakable_scope` exits, the drops\n+will be added to the CFG.\n \n-Panics are handled in a similar fashion, except that a panic always\n-returns out to the `DIVERGE_BLOCK`. To trigger a panic, simply call\n-`panic(p)` with the current point `p`. Or else you can call\n-`diverge_cleanup`, which will produce a block that you can branch to\n-which does the appropriate cleanup and then diverges. `panic(p)`\n-simply calls `diverge_cleanup()` and adds an edge from `p` to the\n-result.\n+Panics are handled in a similar fashion, except that the drops are added to the\n+mir once the rest of the function has finished being lowered. If a terminator\n+can panic, call `diverge_from(block)` with the block containing the terminator\n+`block`.\n \n-### Loop scopes\n+### Breakable scopes\n \n In addition to the normal scope stack, we track a loop scope stack\n-that contains only loops. It tracks where a `break` and `continue`\n-should go to.\n+that contains only loops and breakable blocks. It tracks where a `break`,\n+`continue` or `return` should go to.\n \n */\n \n@@ -87,11 +86,24 @@ use crate::thir::{Expr, ExprRef, LintLevel};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::GeneratorKind;\n+use rustc_index::vec::IndexVec;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_span::{Span, DUMMY_SP};\n-use std::collections::hash_map::Entry;\n-use std::mem;\n+\n+#[derive(Debug)]\n+pub struct Scopes<'tcx> {\n+    scopes: Vec<Scope>,\n+    /// The current set of breakable scopes. See module comment for more details.\n+    breakable_scopes: Vec<BreakableScope<'tcx>>,\n+\n+    /// Drops that need to be done on unwind paths. See the comment on\n+    /// [DropTree] for more details.\n+    unwind_drops: DropTree,\n+\n+    /// Drops that need to be done on paths to the `GeneratorDrop` terminator.\n+    generator_drops: DropTree,\n+}\n \n #[derive(Debug)]\n struct Scope {\n@@ -112,73 +124,45 @@ struct Scope {\n \n     moved_locals: Vec<Local>,\n \n-    /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n-    cached_exits: FxHashMap<(BasicBlock, region::Scope), BasicBlock>,\n+    /// The drop index that will drop everything in and below this scope on an\n+    /// unwind path.\n+    cached_unwind_block: Option<DropIdx>,\n \n-    /// The cache for drop chain on \"generator drop\" exit.\n-    cached_generator_drop: Option<BasicBlock>,\n-\n-    /// The cache for drop chain on \"unwind\" exit.\n-    cached_unwind: CachedBlock,\n+    /// The drop index that will drop everything in and below this scope on a\n+    /// generator drop path.\n+    cached_generator_drop_block: Option<DropIdx>,\n }\n \n-#[derive(Debug, Default)]\n-crate struct Scopes<'tcx> {\n-    scopes: Vec<Scope>,\n-    /// The current set of breakable scopes. See module comment for more details.\n-    breakable_scopes: Vec<BreakableScope<'tcx>>,\n-}\n-\n-#[derive(Debug)]\n+#[derive(Clone, Copy, Debug)]\n struct DropData {\n-    /// span where drop obligation was incurred (typically where place was declared)\n-    span: Span,\n+    /// The `Span` where drop obligation was incurred (typically where place was\n+    /// declared)\n+    source_info: SourceInfo,\n \n     /// local to drop\n     local: Local,\n \n     /// Whether this is a value Drop or a StorageDead.\n     kind: DropKind,\n-\n-    /// The cached blocks for unwinds.\n-    cached_block: CachedBlock,\n-}\n-\n-#[derive(Debug, Default, Clone, Copy)]\n-struct CachedBlock {\n-    /// The cached block for the cleanups-on-diverge path. This block\n-    /// contains code to run the current drop and all the preceding\n-    /// drops (i.e., those having lower index in Drop\u2019s Scope drop\n-    /// array)\n-    unwind: Option<BasicBlock>,\n-\n-    /// The cached block for unwinds during cleanups-on-generator-drop path\n-    ///\n-    /// This is split from the standard unwind path here to prevent drop\n-    /// elaboration from creating drop flags that would have to be captured\n-    /// by the generator. I'm not sure how important this optimization is,\n-    /// but it is here.\n-    generator_drop: Option<BasicBlock>,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub(crate) enum DropKind {\n     Value,\n     Storage,\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n struct BreakableScope<'tcx> {\n     /// Region scope of the loop\n     region_scope: region::Scope,\n-    /// Where the body of the loop begins. `None` if block\n-    continue_block: Option<BasicBlock>,\n-    /// Block to branch into when the loop or block terminates (either by being\n-    /// `break`-en out from, or by having its condition to become false)\n-    break_block: BasicBlock,\n     /// The destination of the loop/block expression itself (i.e., where to put\n-    /// the result of a `break` expression)\n+    /// the result of a `break` or `return` expression)\n     break_destination: Place<'tcx>,\n+    /// Drops that happen on the `break`/`return` path.\n+    break_drops: DropTree,\n+    /// Drops that happen on the `continue` path.\n+    continue_drops: Option<DropTree>,\n }\n \n /// The target of an expression that breaks out of a scope\n@@ -189,61 +173,33 @@ crate enum BreakableTarget {\n     Return,\n }\n \n-impl CachedBlock {\n-    fn invalidate(&mut self) {\n-        *self = CachedBlock::default();\n-    }\n+rustc_index::newtype_index! {\n+    struct DropIdx { .. }\n+}\n \n-    fn get(&self, generator_drop: bool) -> Option<BasicBlock> {\n-        if generator_drop { self.generator_drop } else { self.unwind }\n-    }\n+const ROOT_NODE: DropIdx = DropIdx::from_u32(0);\n \n-    fn ref_mut(&mut self, generator_drop: bool) -> &mut Option<BasicBlock> {\n-        if generator_drop { &mut self.generator_drop } else { &mut self.unwind }\n-    }\n+/// A tree of drops that we have deferred lowering. It's used for:\n+///\n+/// * Drops on unwind paths\n+/// * Drops on generator drop paths (when a suspended generator is dropped)\n+/// * Drops on return and loop exit paths\n+///\n+/// Once no more nodes could be added to the tree, we lower it to MIR in one go\n+/// in `build_drop_tree`.\n+#[derive(Debug)]\n+struct DropTree {\n+    /// Drops in the tree.\n+    drops: IndexVec<DropIdx, (DropData, DropIdx)>,\n+    /// Map for finding the inverse of the `next_drop` relation:\n+    ///\n+    /// `previous_drops[(drops[i].1, drops[i].0.local, drops[i].0.kind] == i`\n+    previous_drops: FxHashMap<(DropIdx, Local, DropKind), DropIdx>,\n+    /// Edges into the `DropTree` that need to be added once it's lowered.\n+    entry_points: Vec<(DropIdx, BasicBlock)>,\n }\n \n impl Scope {\n-    /// Invalidates all the cached blocks in the scope.\n-    ///\n-    /// Should always be run for all inner scopes when a drop is pushed into some scope enclosing a\n-    /// larger extent of code.\n-    ///\n-    /// `storage_only` controls whether to invalidate only drop paths that run `StorageDead`.\n-    /// `this_scope_only` controls whether to invalidate only drop paths that refer to the current\n-    /// top-of-scope (as opposed to dependent scopes).\n-    fn invalidate_cache(\n-        &mut self,\n-        storage_only: bool,\n-        generator_kind: Option<GeneratorKind>,\n-        this_scope_only: bool,\n-    ) {\n-        // FIXME: maybe do shared caching of `cached_exits` etc. to handle functions\n-        // with lots of `try!`?\n-\n-        // cached exits drop storage and refer to the top-of-scope\n-        self.cached_exits.clear();\n-\n-        // the current generator drop and unwind refer to top-of-scope\n-        self.cached_generator_drop = None;\n-\n-        let ignore_unwinds = storage_only && generator_kind.is_none();\n-        if !ignore_unwinds {\n-            self.cached_unwind.invalidate();\n-        }\n-\n-        if !ignore_unwinds && !this_scope_only {\n-            for drop_data in &mut self.drops {\n-                drop_data.cached_block.invalidate();\n-            }\n-        }\n-    }\n-\n-    /// Given a span and this scope's source scope, make a SourceInfo.\n-    fn source_info(&self, span: Span) -> SourceInfo {\n-        SourceInfo { span, scope: self.source_scope }\n-    }\n-\n     /// Whether there's anything to do for the cleanup path, that is,\n     /// when unwinding through this scope. This includes destructors,\n     /// but not StorageDead statements, which don't get emitted at all\n@@ -261,138 +217,266 @@ impl Scope {\n             DropKind::Storage => false,\n         })\n     }\n+\n+    fn invalidate_cache(&mut self) {\n+        self.cached_unwind_block = None;\n+        self.cached_generator_drop_block = None;\n+    }\n }\n \n-impl<'tcx> Scopes<'tcx> {\n-    fn len(&self) -> usize {\n-        self.scopes.len()\n+/// A trait that determined how [DropTree::lower_to_mir] creates its blocks and\n+/// links to any entry nodes.\n+trait DropTreeBuilder<'tcx> {\n+    /// Create a new block for the tree. This should call either\n+    /// `cfg.start_new_block()` or `cfg.start_new_cleanup_block()`.\n+    fn make_block(cfg: &mut CFG<'tcx>) -> BasicBlock;\n+\n+    /// Links a block outside the drop tree, `from`, to the block `to` inside\n+    /// the drop tree.\n+    fn add_entry(cfg: &mut CFG<'tcx>, from: BasicBlock, to: BasicBlock);\n+}\n+\n+impl DropTree {\n+    fn new() -> Self {\n+        let fake_source_info = SourceInfo::outermost(DUMMY_SP);\n+        let fake_data =\n+            DropData { source_info: fake_source_info, local: Local::MAX, kind: DropKind::Storage };\n+        let drop_idx = DropIdx::MAX;\n+        let drops = IndexVec::from_elem_n((fake_data, drop_idx), 1);\n+        Self { drops, entry_points: Vec::new(), previous_drops: FxHashMap::default() }\n     }\n \n-    fn push_scope(&mut self, region_scope: (region::Scope, SourceInfo), vis_scope: SourceScope) {\n-        debug!(\"push_scope({:?})\", region_scope);\n-        self.scopes.push(Scope {\n-            source_scope: vis_scope,\n-            region_scope: region_scope.0,\n-            region_scope_span: region_scope.1.span,\n-            drops: vec![],\n-            moved_locals: vec![],\n-            cached_generator_drop: None,\n-            cached_exits: Default::default(),\n-            cached_unwind: CachedBlock::default(),\n-        });\n+    fn add_drop(&mut self, drop: DropData, next: DropIdx) -> DropIdx {\n+        let drops = &mut self.drops;\n+        *self\n+            .previous_drops\n+            .entry((next, drop.local, drop.kind))\n+            .or_insert_with(|| drops.push((drop, next)))\n     }\n \n-    fn pop_scope(\n-        &mut self,\n-        region_scope: (region::Scope, SourceInfo),\n-    ) -> (Scope, Option<BasicBlock>) {\n-        let scope = self.scopes.pop().unwrap();\n-        assert_eq!(scope.region_scope, region_scope.0);\n-        let unwind_to =\n-            self.scopes.last().and_then(|next_scope| next_scope.cached_unwind.get(false));\n-        (scope, unwind_to)\n+    fn add_entry(&mut self, from: BasicBlock, to: DropIdx) {\n+        debug_assert!(to < self.drops.next_index());\n+        self.entry_points.push((to, from));\n     }\n \n-    fn may_panic(&self, scope_count: usize) -> bool {\n-        let len = self.len();\n-        self.scopes[(len - scope_count)..].iter().any(|s| s.needs_cleanup())\n+    fn build_mir<'tcx, T: DropTreeBuilder<'tcx>>(\n+        &mut self,\n+        cfg: &mut CFG<'tcx>,\n+        blocks: &mut IndexVec<DropIdx, Option<BasicBlock>>,\n+    ) {\n+        debug!(\"DropTree::build_mir(drops = {:#?})\", self);\n+        assert_eq!(blocks.len(), self.drops.len());\n+\n+        self.assign_blocks::<T>(cfg, blocks);\n+        self.link_blocks(cfg, blocks)\n     }\n \n-    /// Finds the breakable scope for a given label. This is used for\n-    /// resolving `return`, `break` and `continue`.\n-    fn find_breakable_scope(\n-        &self,\n-        span: Span,\n-        target: BreakableTarget,\n-    ) -> (BasicBlock, region::Scope, Option<Place<'tcx>>) {\n-        let get_scope = |scope: region::Scope| {\n-            // find the loop-scope by its `region::Scope`.\n-            self.breakable_scopes\n-                .iter()\n-                .rfind(|breakable_scope| breakable_scope.region_scope == scope)\n-                .unwrap_or_else(|| span_bug!(span, \"no enclosing breakable scope found\"))\n-        };\n-        match target {\n-            BreakableTarget::Return => {\n-                let scope = &self.breakable_scopes[0];\n-                if scope.break_destination != Place::return_place() {\n-                    span_bug!(span, \"`return` in item with no return scope\");\n+    /// Assign blocks for all of the drops in the drop tree that need them.\n+    fn assign_blocks<'tcx, T: DropTreeBuilder<'tcx>>(\n+        &mut self,\n+        cfg: &mut CFG<'tcx>,\n+        blocks: &mut IndexVec<DropIdx, Option<BasicBlock>>,\n+    ) {\n+        // StorageDead statements can share blocks with each other and also with\n+        // a Drop terminator. We iterate through the blocks to find which blocks\n+        // need\n+        #[derive(Clone, Copy)]\n+        enum Block {\n+            // This drop is unreachable\n+            None,\n+            // This drop is only reachable through the `StorageDead` with the\n+            // specified index.\n+            Shares(DropIdx),\n+            // This drop has more than one way of being reached, or it is\n+            // branched to from outside the tree, or it's predecessor is a\n+            // `Value` drop.\n+            Own,\n+        }\n+\n+        let mut needs_block = IndexVec::from_elem(Block::None, &self.drops);\n+        if blocks[ROOT_NODE].is_some() {\n+            // In some cases (such as drops for `continue`) the root node\n+            // already has a block. In this case, make sure that we don't\n+            // override it.\n+            needs_block[ROOT_NODE] = Block::Own;\n+        }\n+\n+        // Sort so that we only need to check the last\n+        let entry_points = &mut self.entry_points;\n+        entry_points.sort();\n+\n+        for (drop_idx, drop_data) in self.drops.iter_enumerated().rev() {\n+            if entry_points.last().map_or(false, |entry_point| entry_point.0 == drop_idx) {\n+                let block = *blocks[drop_idx].get_or_insert_with(|| T::make_block(cfg));\n+                needs_block[drop_idx] = Block::Own;\n+                while entry_points.last().map_or(false, |entry_point| entry_point.0 == drop_idx) {\n+                    let entry_block = entry_points.pop().unwrap().1;\n+                    T::add_entry(cfg, entry_block, block);\n                 }\n-                (scope.break_block, scope.region_scope, Some(scope.break_destination))\n             }\n-            BreakableTarget::Break(scope) => {\n-                let scope = get_scope(scope);\n-                (scope.break_block, scope.region_scope, Some(scope.break_destination))\n+            match needs_block[drop_idx] {\n+                Block::None => continue,\n+                Block::Own => {\n+                    blocks[drop_idx].get_or_insert_with(|| T::make_block(cfg));\n+                }\n+                Block::Shares(pred) => {\n+                    blocks[drop_idx] = blocks[pred];\n+                }\n             }\n-            BreakableTarget::Continue(scope) => {\n-                let scope = get_scope(scope);\n-                let continue_block = scope\n-                    .continue_block\n-                    .unwrap_or_else(|| span_bug!(span, \"missing `continue` block\"));\n-                (continue_block, scope.region_scope, None)\n+            if let DropKind::Value = drop_data.0.kind {\n+                needs_block[drop_data.1] = Block::Own;\n+            } else {\n+                if drop_idx != ROOT_NODE {\n+                    match &mut needs_block[drop_data.1] {\n+                        pred @ Block::None => *pred = Block::Shares(drop_idx),\n+                        pred @ Block::Shares(_) => *pred = Block::Own,\n+                        Block::Own => (),\n+                    }\n+                }\n             }\n         }\n+\n+        debug!(\"assign_blocks: blocks = {:#?}\", blocks);\n+        assert!(entry_points.is_empty());\n     }\n \n-    fn num_scopes_above(&self, region_scope: region::Scope, span: Span) -> usize {\n-        let scope_count = self\n-            .scopes\n-            .iter()\n-            .rev()\n-            .position(|scope| scope.region_scope == region_scope)\n-            .unwrap_or_else(|| span_bug!(span, \"region_scope {:?} does not enclose\", region_scope));\n-        let len = self.len();\n-        assert!(scope_count < len, \"should not use `exit_scope` to pop ALL scopes\");\n-        scope_count\n+    fn link_blocks<'tcx>(\n+        &self,\n+        cfg: &mut CFG<'tcx>,\n+        blocks: &IndexVec<DropIdx, Option<BasicBlock>>,\n+    ) {\n+        for (drop_idx, drop_data) in self.drops.iter_enumerated().rev() {\n+            let block = if let Some(block) = blocks[drop_idx] {\n+                block\n+            } else {\n+                continue;\n+            };\n+            match drop_data.0.kind {\n+                DropKind::Value => {\n+                    let terminator = TerminatorKind::Drop {\n+                        target: blocks[drop_data.1].unwrap(),\n+                        // The caller will handle this if needed.\n+                        unwind: None,\n+                        location: drop_data.0.local.into(),\n+                    };\n+                    cfg.terminate(block, drop_data.0.source_info, terminator);\n+                }\n+                // Root nodes don't correspond to a drop.\n+                DropKind::Storage if drop_idx == ROOT_NODE => {}\n+                DropKind::Storage => {\n+                    let stmt = Statement {\n+                        source_info: drop_data.0.source_info,\n+                        kind: StatementKind::StorageDead(drop_data.0.local),\n+                    };\n+                    cfg.push(block, stmt);\n+                    let target = blocks[drop_data.1].unwrap();\n+                    if target != block {\n+                        // Diagnostics don't use this `Span` but debuginfo\n+                        // might. Since we don't want breakpoints to be placed\n+                        // here, especially when this is on an unwind path, we\n+                        // use `DUMMY_SP`.\n+                        let source_info = SourceInfo { span: DUMMY_SP, ..drop_data.0.source_info };\n+                        let terminator = TerminatorKind::Goto { target };\n+                        cfg.terminate(block, source_info, terminator);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> Scopes<'tcx> {\n+    pub(crate) fn new() -> Self {\n+        Self {\n+            scopes: Vec::new(),\n+            breakable_scopes: Vec::new(),\n+            unwind_drops: DropTree::new(),\n+            generator_drops: DropTree::new(),\n+        }\n+    }\n+\n+    fn push_scope(&mut self, region_scope: (region::Scope, SourceInfo), vis_scope: SourceScope) {\n+        debug!(\"push_scope({:?})\", region_scope);\n+        self.scopes.push(Scope {\n+            source_scope: vis_scope,\n+            region_scope: region_scope.0,\n+            region_scope_span: region_scope.1.span,\n+            drops: vec![],\n+            moved_locals: vec![],\n+            cached_unwind_block: None,\n+            cached_generator_drop_block: None,\n+        });\n     }\n \n-    fn iter_mut(&mut self) -> impl DoubleEndedIterator<Item = &mut Scope> + '_ {\n-        self.scopes.iter_mut().rev()\n+    fn pop_scope(&mut self, region_scope: (region::Scope, SourceInfo)) -> Scope {\n+        let scope = self.scopes.pop().unwrap();\n+        assert_eq!(scope.region_scope, region_scope.0);\n+        scope\n     }\n \n-    fn top_scopes(&mut self, count: usize) -> impl DoubleEndedIterator<Item = &mut Scope> + '_ {\n-        let len = self.len();\n-        self.scopes[len - count..].iter_mut()\n+    fn scope_index(&self, region_scope: region::Scope, span: Span) -> usize {\n+        self.scopes\n+            .iter()\n+            .rposition(|scope| scope.region_scope == region_scope)\n+            .unwrap_or_else(|| span_bug!(span, \"region_scope {:?} does not enclose\", region_scope))\n     }\n \n     /// Returns the topmost active scope, which is known to be alive until\n     /// the next scope expression.\n-    pub(super) fn topmost(&self) -> region::Scope {\n+    fn topmost(&self) -> region::Scope {\n         self.scopes.last().expect(\"topmost_scope: no scopes present\").region_scope\n     }\n-\n-    fn source_info(&self, index: usize, span: Span) -> SourceInfo {\n-        self.scopes[self.len() - index].source_info(span)\n-    }\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // Adding and removing scopes\n     // ==========================\n     //  Start a breakable scope, which tracks where `continue`, `break` and\n     //  `return` should branch to.\n-    crate fn in_breakable_scope<F, R>(\n+    crate fn in_breakable_scope<F>(\n         &mut self,\n         loop_block: Option<BasicBlock>,\n-        break_block: BasicBlock,\n         break_destination: Place<'tcx>,\n+        span: Span,\n         f: F,\n-    ) -> R\n+    ) -> BlockAnd<()>\n     where\n-        F: FnOnce(&mut Builder<'a, 'tcx>) -> R,\n+        F: FnOnce(&mut Builder<'a, 'tcx>) -> Option<BlockAnd<()>>,\n     {\n         let region_scope = self.scopes.topmost();\n         let scope = BreakableScope {\n             region_scope,\n-            continue_block: loop_block,\n-            break_block,\n             break_destination,\n+            break_drops: DropTree::new(),\n+            continue_drops: loop_block.map(|_| DropTree::new()),\n         };\n         self.scopes.breakable_scopes.push(scope);\n-        let res = f(self);\n+        let normal_exit_block = f(self);\n         let breakable_scope = self.scopes.breakable_scopes.pop().unwrap();\n         assert!(breakable_scope.region_scope == region_scope);\n-        res\n+        let break_block = self.build_exit_tree(breakable_scope.break_drops, None);\n+        breakable_scope.continue_drops.map(|drops| {\n+            self.build_exit_tree(drops, loop_block);\n+        });\n+        match (normal_exit_block, break_block) {\n+            (Some(block), None) | (None, Some(block)) => block,\n+            (None, None) => self.cfg.start_new_block().unit(),\n+            (Some(normal_block), Some(exit_block)) => {\n+                let target = self.cfg.start_new_block();\n+                let source_info = self.source_info(span);\n+                self.cfg.terminate(\n+                    unpack!(normal_block),\n+                    source_info,\n+                    TerminatorKind::Goto { target },\n+                );\n+                self.cfg.terminate(\n+                    unpack!(exit_block),\n+                    source_info,\n+                    TerminatorKind::Goto { target },\n+                );\n+                target.unit()\n+            }\n+        }\n     }\n \n     crate fn in_opt_scope<F, R>(\n@@ -476,46 +560,51 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         mut block: BasicBlock,\n     ) -> BlockAnd<()> {\n         debug!(\"pop_scope({:?}, {:?})\", region_scope, block);\n-        // If we are emitting a `drop` statement, we need to have the cached\n-        // diverge cleanup pads ready in case that drop panics.\n-        if self.scopes.may_panic(1) {\n-            self.diverge_cleanup();\n-        }\n-        let (scope, unwind_to) = self.scopes.pop_scope(region_scope);\n-        let unwind_to = unwind_to.unwrap_or_else(|| self.resume_block());\n \n-        unpack!(\n-            block = build_scope_drops(\n-                &mut self.cfg,\n-                self.generator_kind,\n-                &scope,\n-                block,\n-                unwind_to,\n-                self.arg_count,\n-                false, // not generator\n-                false, // not unwind path\n-            )\n-        );\n+        block = self.leave_top_scope(block);\n+\n+        self.scopes.pop_scope(region_scope);\n \n         block.unit()\n     }\n \n+    /// Sets up the drops for breaking from `block` to `target`.\n     crate fn break_scope(\n         &mut self,\n         mut block: BasicBlock,\n         value: Option<ExprRef<'tcx>>,\n-        scope: BreakableTarget,\n+        target: BreakableTarget,\n         source_info: SourceInfo,\n     ) -> BlockAnd<()> {\n-        let (mut target_block, region_scope, destination) =\n-            self.scopes.find_breakable_scope(source_info.span, scope);\n-        if let BreakableTarget::Return = scope {\n-            // We call this now, rather than when we start lowering the\n-            // function so that the return block doesn't precede the entire\n-            // rest of the CFG. Some passes and LLVM prefer blocks to be in\n-            // approximately CFG order.\n-            target_block = self.return_block();\n-        }\n+        let span = source_info.span;\n+\n+        let get_scope_index = |scope: region::Scope| {\n+            // find the loop-scope by its `region::Scope`.\n+            self.scopes\n+                .breakable_scopes\n+                .iter()\n+                .rposition(|breakable_scope| breakable_scope.region_scope == scope)\n+                .unwrap_or_else(|| span_bug!(span, \"no enclosing breakable scope found\"))\n+        };\n+        let (break_index, destination) = match target {\n+            BreakableTarget::Return => {\n+                let scope = &self.scopes.breakable_scopes[0];\n+                if scope.break_destination != Place::return_place() {\n+                    span_bug!(span, \"`return` in item with no return scope\");\n+                }\n+                (0, Some(scope.break_destination))\n+            }\n+            BreakableTarget::Break(scope) => {\n+                let break_index = get_scope_index(scope);\n+                let scope = &self.scopes.breakable_scopes[break_index];\n+                (break_index, Some(scope.break_destination))\n+            }\n+            BreakableTarget::Continue(scope) => {\n+                let break_index = get_scope_index(scope);\n+                (break_index, None)\n+            }\n+        };\n+\n         if let Some(destination) = destination {\n             if let Some(value) = value {\n                 debug!(\"stmt_expr Break val block_context.push(SubExpr)\");\n@@ -528,131 +617,57 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         } else {\n             assert!(value.is_none(), \"`return` and `break` should have a destination\");\n         }\n-        self.exit_scope(source_info.span, region_scope, block, target_block);\n+\n+        let region_scope = self.scopes.breakable_scopes[break_index].region_scope;\n+        let scope_index = self.scopes.scope_index(region_scope, span);\n+        let drops = if destination.is_some() {\n+            &mut self.scopes.breakable_scopes[break_index].break_drops\n+        } else {\n+            self.scopes.breakable_scopes[break_index].continue_drops.as_mut().unwrap()\n+        };\n+        let mut drop_idx = ROOT_NODE;\n+        for scope in &self.scopes.scopes[scope_index + 1..] {\n+            for drop in &scope.drops {\n+                drop_idx = drops.add_drop(*drop, drop_idx);\n+            }\n+        }\n+        drops.add_entry(block, drop_idx);\n+\n+        // `build_drop_tree` doesn't have access to our source_info, so we\n+        // create a dummy terminator now. `TerminatorKind::Resume` is used\n+        // because MIR type checking will panic if it hasn't been overwritten.\n+        self.cfg.terminate(block, source_info, TerminatorKind::Resume);\n+\n         self.cfg.start_new_block().unit()\n     }\n \n-    /// Branch out of `block` to `target`, exiting all scopes up to\n-    /// and including `region_scope`. This will insert whatever drops are\n-    /// needed. See module comment for details.\n-    crate fn exit_scope(\n+    crate fn exit_top_scope(\n         &mut self,\n-        span: Span,\n-        region_scope: region::Scope,\n         mut block: BasicBlock,\n         target: BasicBlock,\n+        source_info: SourceInfo,\n     ) {\n-        debug!(\n-            \"exit_scope(region_scope={:?}, block={:?}, target={:?})\",\n-            region_scope, block, target\n-        );\n-        let scope_count = self.scopes.num_scopes_above(region_scope, span);\n+        block = self.leave_top_scope(block);\n+        self.cfg.terminate(block, source_info, TerminatorKind::Goto { target });\n+    }\n \n+    fn leave_top_scope(&mut self, block: BasicBlock) -> BasicBlock {\n         // If we are emitting a `drop` statement, we need to have the cached\n         // diverge cleanup pads ready in case that drop panics.\n-        let may_panic = self.scopes.may_panic(scope_count);\n-        if may_panic {\n-            self.diverge_cleanup();\n-        }\n-\n-        let mut scopes = self.scopes.top_scopes(scope_count + 1).rev();\n-        let mut scope = scopes.next().unwrap();\n-        for next_scope in scopes {\n-            if scope.drops.is_empty() {\n-                scope = next_scope;\n-                continue;\n-            }\n-            let source_info = scope.source_info(span);\n-            block = match scope.cached_exits.entry((target, region_scope)) {\n-                Entry::Occupied(e) => {\n-                    self.cfg.goto(block, source_info, *e.get());\n-                    return;\n-                }\n-                Entry::Vacant(v) => {\n-                    let b = self.cfg.start_new_block();\n-                    self.cfg.goto(block, source_info, b);\n-                    v.insert(b);\n-                    b\n-                }\n-            };\n-\n-            let unwind_to = next_scope.cached_unwind.get(false).unwrap_or_else(|| {\n-                debug_assert!(!may_panic, \"cached block not present?\");\n-                START_BLOCK\n-            });\n-\n-            unpack!(\n-                block = build_scope_drops(\n-                    &mut self.cfg,\n-                    self.generator_kind,\n-                    scope,\n-                    block,\n-                    unwind_to,\n-                    self.arg_count,\n-                    false, // not generator\n-                    false, // not unwind path\n-                )\n-            );\n-\n-            scope = next_scope;\n-        }\n-\n-        self.cfg.goto(block, self.scopes.source_info(scope_count, span), target);\n-    }\n-\n-    /// Creates a path that performs all required cleanup for dropping a generator.\n-    ///\n-    /// This path terminates in GeneratorDrop. Returns the start of the path.\n-    /// None indicates there\u2019s no cleanup to do at this point.\n-    crate fn generator_drop_cleanup(&mut self) -> Option<BasicBlock> {\n-        // Fill in the cache for unwinds\n-        self.diverge_cleanup_gen(true);\n-\n-        let src_info = self.scopes.source_info(self.scopes.len(), self.fn_span);\n-        let resume_block = self.resume_block();\n-        let mut scopes = self.scopes.iter_mut().peekable();\n-        let mut block = self.cfg.start_new_block();\n-        let result = block;\n-\n-        while let Some(scope) = scopes.next() {\n-            block = if let Some(b) = scope.cached_generator_drop {\n-                self.cfg.goto(block, src_info, b);\n-                return Some(result);\n-            } else {\n-                let b = self.cfg.start_new_block();\n-                scope.cached_generator_drop = Some(b);\n-                self.cfg.goto(block, src_info, b);\n-                b\n-            };\n-\n-            let unwind_to = scopes\n-                .peek()\n-                .as_ref()\n-                .map(|scope| {\n-                    scope\n-                        .cached_unwind\n-                        .get(true)\n-                        .unwrap_or_else(|| span_bug!(src_info.span, \"cached block not present?\"))\n-                })\n-                .unwrap_or(resume_block);\n-\n-            unpack!(\n-                block = build_scope_drops(\n-                    &mut self.cfg,\n-                    self.generator_kind,\n-                    scope,\n-                    block,\n-                    unwind_to,\n-                    self.arg_count,\n-                    true, // is generator\n-                    true, // is cached path\n-                )\n-            );\n-        }\n-\n-        self.cfg.terminate(block, src_info, TerminatorKind::GeneratorDrop);\n-\n-        Some(result)\n+        let needs_cleanup = self.scopes.scopes.last().map_or(false, |scope| scope.needs_cleanup());\n+        let is_generator = self.generator_kind.is_some();\n+        let unwind_to = if needs_cleanup { self.diverge_cleanup() } else { DropIdx::MAX };\n+\n+        let scope = self.scopes.scopes.last().expect(\"leave_top_scope called with no scopes\");\n+        unpack!(build_scope_drops(\n+            &mut self.cfg,\n+            &mut self.scopes.unwind_drops,\n+            scope,\n+            block,\n+            unwind_to,\n+            is_generator && needs_cleanup,\n+            self.arg_count,\n+        ))\n     }\n \n     /// Creates a new source scope, nested in the current one.\n@@ -728,15 +743,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    // Schedule an abort block - this is used for some ABIs that cannot unwind\n-    crate fn schedule_abort(&mut self) -> BasicBlock {\n-        let source_info = self.scopes.source_info(self.scopes.len(), self.fn_span);\n-        let abortblk = self.cfg.start_new_cleanup_block();\n-        self.cfg.terminate(abortblk, source_info, TerminatorKind::Abort);\n-        self.cached_resume_block = Some(abortblk);\n-        abortblk\n-    }\n-\n     // Scheduling drops\n     // ================\n     crate fn schedule_drop_storage_and_value(\n@@ -749,11 +755,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.schedule_drop(span, region_scope, local, DropKind::Value);\n     }\n \n-    /// Indicates that `place` should be dropped on exit from\n-    /// `region_scope`.\n+    /// Indicates that `place` should be dropped on exit from `region_scope`.\n     ///\n-    /// When called with `DropKind::Storage`, `place` should be a local\n-    /// with an index higher than the current `self.arg_count`.\n+    /// When called with `DropKind::Storage`, `place` shouldn't be the return\n+    /// place, or a function parameter.\n     crate fn schedule_drop(\n         &mut self,\n         span: Span,\n@@ -781,70 +786,74 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         };\n \n-        for scope in self.scopes.iter_mut() {\n-            let this_scope = scope.region_scope == region_scope;\n-            // When building drops, we try to cache chains of drops in such a way so these drops\n-            // could be reused by the drops which would branch into the cached (already built)\n-            // blocks.  This, however, means that whenever we add a drop into a scope which already\n-            // had some blocks built (and thus, cached) for it, we must invalidate all caches which\n-            // might branch into the scope which had a drop just added to it. This is necessary,\n-            // because otherwise some other code might use the cache to branch into already built\n-            // chain of drops, essentially ignoring the newly added drop.\n-            //\n-            // For example consider there\u2019s two scopes with a drop in each. These are built and\n-            // thus the caches are filled:\n-            //\n-            // +--------------------------------------------------------+\n-            // | +---------------------------------+                    |\n-            // | | +--------+     +-------------+  |  +---------------+ |\n-            // | | | return | <-+ | drop(outer) | <-+ |  drop(middle) | |\n-            // | | +--------+     +-------------+  |  +---------------+ |\n-            // | +------------|outer_scope cache|--+                    |\n-            // +------------------------------|middle_scope cache|------+\n-            //\n-            // Now, a new, inner-most scope is added along with a new drop into both inner-most and\n-            // outer-most scopes:\n-            //\n-            // +------------------------------------------------------------+\n-            // | +----------------------------------+                       |\n-            // | | +--------+      +-------------+  |   +---------------+   | +-------------+\n-            // | | | return | <+   | drop(new)   | <-+  |  drop(middle) | <--+| drop(inner) |\n-            // | | +--------+  |   | drop(outer) |  |   +---------------+   | +-------------+\n-            // | |             +-+ +-------------+  |                       |\n-            // | +---|invalid outer_scope cache|----+                       |\n-            // +----=----------------|invalid middle_scope cache|-----------+\n-            //\n-            // If, when adding `drop(new)` we do not invalidate the cached blocks for both\n-            // outer_scope and middle_scope, then, when building drops for the inner (right-most)\n-            // scope, the old, cached blocks, without `drop(new)` will get used, producing the\n-            // wrong results.\n-            //\n-            // The cache and its invalidation for unwind branch is somewhat special. The cache is\n-            // per-drop, rather than per scope, which has a several different implications. Adding\n-            // a new drop into a scope will not invalidate cached blocks of the prior drops in the\n-            // scope. That is true, because none of the already existing drops will have an edge\n-            // into a block with the newly added drop.\n-            //\n-            // Note that this code iterates scopes from the inner-most to the outer-most,\n-            // invalidating caches of each scope visited. This way bare minimum of the\n-            // caches gets invalidated. i.e., if a new drop is added into the middle scope, the\n-            // cache of outer scope stays intact.\n-            scope.invalidate_cache(!needs_drop, self.generator_kind, this_scope);\n-            if this_scope {\n+        // When building drops, we try to cache chains of drops to reduce the\n+        // number of `DropTree::add_drop` calls. This, however, means that\n+        // whenever we add a drop into a scope which already had some entries\n+        // in the drop tree built (and thus, cached) for it, we must invalidate\n+        // all caches which might branch into the scope which had a drop just\n+        // added to it. This is necessary, because otherwise some other code\n+        // might use the cache to branch into already built chain of drops,\n+        // essentially ignoring the newly added drop.\n+        //\n+        // For example consider there\u2019s two scopes with a drop in each. These\n+        // are built and thus the caches are filled:\n+        //\n+        // +--------------------------------------------------------+\n+        // | +---------------------------------+                    |\n+        // | | +--------+     +-------------+  |  +---------------+ |\n+        // | | | return | <-+ | drop(outer) | <-+ |  drop(middle) | |\n+        // | | +--------+     +-------------+  |  +---------------+ |\n+        // | +------------|outer_scope cache|--+                    |\n+        // +------------------------------|middle_scope cache|------+\n+        //\n+        // Now, a new, inner-most scope is added along with a new drop into\n+        // both inner-most and outer-most scopes:\n+        //\n+        // +------------------------------------------------------------+\n+        // | +----------------------------------+                       |\n+        // | | +--------+      +-------------+  |   +---------------+   | +-------------+\n+        // | | | return | <+   | drop(new)   | <-+  |  drop(middle) | <--+| drop(inner) |\n+        // | | +--------+  |   | drop(outer) |  |   +---------------+   | +-------------+\n+        // | |             +-+ +-------------+  |                       |\n+        // | +---|invalid outer_scope cache|----+                       |\n+        // +----=----------------|invalid middle_scope cache|-----------+\n+        //\n+        // If, when adding `drop(new)` we do not invalidate the cached blocks for both\n+        // outer_scope and middle_scope, then, when building drops for the inner (right-most)\n+        // scope, the old, cached blocks, without `drop(new)` will get used, producing the\n+        // wrong results.\n+        //\n+        // Note that this code iterates scopes from the inner-most to the outer-most,\n+        // invalidating caches of each scope visited. This way bare minimum of the\n+        // caches gets invalidated. i.e., if a new drop is added into the middle scope, the\n+        // cache of outer scope stays intact.\n+        //\n+        // Since we only cache drops for the unwind path and the generator drop\n+        // path, we only need to invalidate the cache for drops that happen on\n+        // the unwind or generator drop paths. This means that for\n+        // non-generators we don't need to invalidate caches for `DropKind::Storage`.\n+        let invalidate_caches = needs_drop || self.generator_kind.is_some();\n+        for scope in self.scopes.scopes.iter_mut().rev() {\n+            if invalidate_caches {\n+                scope.invalidate_cache();\n+            }\n+\n+            if scope.region_scope == region_scope {\n                 let region_scope_span =\n                     region_scope.span(self.hir.tcx(), &self.hir.region_scope_tree);\n                 // Attribute scope exit drops to scope's closing brace.\n                 let scope_end = self.hir.tcx().sess.source_map().end_point(region_scope_span);\n \n                 scope.drops.push(DropData {\n-                    span: scope_end,\n+                    source_info: SourceInfo { span: scope_end, scope: scope.source_scope },\n                     local,\n                     kind: drop_kind,\n-                    cached_block: CachedBlock::default(),\n                 });\n+\n                 return;\n             }\n         }\n+\n         span_bug!(span, \"region scope {:?} not in scope to drop {:?}\", region_scope, local);\n     }\n \n@@ -892,9 +901,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             Some(local_scope) => self\n+                .scopes\n                 .scopes\n                 .iter_mut()\n-                .find(|scope| scope.region_scope == local_scope)\n+                .rfind(|scope| scope.region_scope == local_scope)\n                 .unwrap_or_else(|| bug!(\"scope {:?} not found in scope list!\", local_scope)),\n         };\n \n@@ -944,13 +954,16 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // Manually drop the condition on both branches.\n                     let top_scope = self.scopes.scopes.last_mut().unwrap();\n                     let top_drop_data = top_scope.drops.pop().unwrap();\n+                    if self.generator_kind.is_some() {\n+                        top_scope.invalidate_cache();\n+                    }\n \n                     match top_drop_data.kind {\n                         DropKind::Value { .. } => {\n                             bug!(\"Drop scheduled on top of condition variable\")\n                         }\n                         DropKind::Storage => {\n-                            let source_info = top_scope.source_info(top_drop_data.span);\n+                            let source_info = top_drop_data.source_info;\n                             let local = top_drop_data.local;\n                             assert_eq!(local, cond_temp, \"Drop scheduled on top of condition\");\n                             self.cfg.push(\n@@ -963,8 +976,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             );\n                         }\n                     }\n-\n-                    top_scope.invalidate_cache(true, self.generator_kind, true);\n                 } else {\n                     bug!(\"Expected as_local_operand to produce a temporary\");\n                 }\n@@ -974,62 +985,86 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         (true_block, false_block)\n     }\n \n-    /// Creates a path that performs all required cleanup for unwinding.\n-    ///\n-    /// This path terminates in Resume. Returns the start of the path.\n-    /// See module comment for more details.\n-    crate fn diverge_cleanup(&mut self) -> BasicBlock {\n-        self.diverge_cleanup_gen(false)\n-    }\n-\n-    fn resume_block(&mut self) -> BasicBlock {\n-        if let Some(target) = self.cached_resume_block {\n-            target\n-        } else {\n-            let resumeblk = self.cfg.start_new_cleanup_block();\n-            self.cfg.terminate(\n-                resumeblk,\n-                SourceInfo::outermost(self.fn_span),\n-                TerminatorKind::Resume,\n-            );\n-            self.cached_resume_block = Some(resumeblk);\n-            resumeblk\n+    /// Returns the [DropIdx] for the innermost drop if the function unwound at\n+    /// this point. The `DropIdx` will be created if it doesn't already exist.\n+    fn diverge_cleanup(&mut self) -> DropIdx {\n+        let is_generator = self.generator_kind.is_some();\n+        let (uncached_scope, mut cached_drop) = self\n+            .scopes\n+            .scopes\n+            .iter()\n+            .enumerate()\n+            .rev()\n+            .find_map(|(scope_idx, scope)| {\n+                scope.cached_unwind_block.map(|cached_block| (scope_idx + 1, cached_block))\n+            })\n+            .unwrap_or((0, ROOT_NODE));\n+\n+        for scope in &mut self.scopes.scopes[uncached_scope..] {\n+            for drop in &scope.drops {\n+                if is_generator || drop.kind == DropKind::Value {\n+                    cached_drop = self.scopes.unwind_drops.add_drop(*drop, cached_drop);\n+                }\n+            }\n+            scope.cached_unwind_block = Some(cached_drop);\n         }\n+\n+        cached_drop\n     }\n \n-    fn diverge_cleanup_gen(&mut self, generator_drop: bool) -> BasicBlock {\n-        // Build up the drops in **reverse** order. The end result will\n-        // look like:\n-        //\n-        //    scopes[n] -> scopes[n-1] -> ... -> scopes[0]\n-        //\n-        // However, we build this in **reverse order**. That is, we\n-        // process scopes[0], then scopes[1], etc, pointing each one at\n-        // the result generates from the one before. Along the way, we\n-        // store caches. If everything is cached, we'll just walk right\n-        // to left reading the cached results but never created anything.\n-\n-        // Find the last cached block\n-        debug!(\"diverge_cleanup_gen(self.scopes = {:?})\", self.scopes);\n-        let cached_cleanup = self.scopes.iter_mut().enumerate().find_map(|(idx, ref scope)| {\n-            let cached_block = scope.cached_unwind.get(generator_drop)?;\n-            Some((cached_block, idx))\n-        });\n-        let (mut target, first_uncached) =\n-            cached_cleanup.unwrap_or_else(|| (self.resume_block(), self.scopes.len()));\n+    /// Prepares to create a path that performs all required cleanup for a\n+    /// terminator that can unwind at the given basic block.\n+    ///\n+    /// This path terminates in Resume. The path isn't created until after all\n+    /// of the non-unwind paths in this item have been lowered.\n+    crate fn diverge_from(&mut self, start: BasicBlock) {\n+        debug_assert!(\n+            matches!(\n+                self.cfg.block_data(start).terminator().kind,\n+                TerminatorKind::Assert { .. }\n+                | TerminatorKind::Call {..}\n+                | TerminatorKind::DropAndReplace { .. }\n+                | TerminatorKind::FalseUnwind { .. }\n+            ),\n+            \"diverge_from called on block with terminator that cannot unwind.\"\n+        );\n \n-        for scope in self.scopes.top_scopes(first_uncached) {\n-            target = build_diverge_scope(\n-                &mut self.cfg,\n-                scope.region_scope_span,\n-                scope,\n-                target,\n-                generator_drop,\n-                self.generator_kind,\n-            );\n+        let next_drop = self.diverge_cleanup();\n+        self.scopes.unwind_drops.add_entry(start, next_drop);\n+    }\n+\n+    /// Sets up a path that performs all required cleanup for dropping a\n+    /// generator, starting from the given block that ends in\n+    /// [TerminatorKind::Yield].\n+    ///\n+    /// This path terminates in GeneratorDrop.\n+    crate fn generator_drop_cleanup(&mut self, yield_block: BasicBlock) {\n+        debug_assert!(\n+            matches!(\n+                self.cfg.block_data(yield_block).terminator().kind,\n+                TerminatorKind::Yield { .. }\n+            ),\n+            \"generator_drop_cleanup called on block with non-yield terminator.\"\n+        );\n+        let (uncached_scope, mut cached_drop) = self\n+            .scopes\n+            .scopes\n+            .iter()\n+            .enumerate()\n+            .rev()\n+            .find_map(|(scope_idx, scope)| {\n+                scope.cached_generator_drop_block.map(|cached_block| (scope_idx + 1, cached_block))\n+            })\n+            .unwrap_or((0, ROOT_NODE));\n+\n+        for scope in &mut self.scopes.scopes[uncached_scope..] {\n+            for drop in &scope.drops {\n+                cached_drop = self.scopes.generator_drops.add_drop(*drop, cached_drop);\n+            }\n+            scope.cached_generator_drop_block = Some(cached_drop);\n         }\n \n-        target\n+        self.scopes.generator_drops.add_entry(yield_block, cached_drop);\n     }\n \n     /// Utility function for *non*-scope code to build their own drops\n@@ -1042,21 +1077,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) -> BlockAnd<()> {\n         let source_info = self.source_info(span);\n         let next_target = self.cfg.start_new_block();\n-        let diverge_target = self.diverge_cleanup();\n+\n         self.cfg.terminate(\n             block,\n             source_info,\n-            TerminatorKind::DropAndReplace {\n-                place,\n-                value,\n-                target: next_target,\n-                unwind: Some(diverge_target),\n-            },\n+            TerminatorKind::DropAndReplace { place, value, target: next_target, unwind: None },\n         );\n+        self.diverge_from(block);\n+\n         next_target.unit()\n     }\n \n-    /// Creates an Assert terminator and return the success block.\n+    /// Creates an `Assert` terminator and return the success block.\n     /// If the boolean condition operand is not the expected value,\n     /// a runtime panic will be caused with the given message.\n     crate fn assert(\n@@ -1068,51 +1100,41 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         span: Span,\n     ) -> BasicBlock {\n         let source_info = self.source_info(span);\n-\n         let success_block = self.cfg.start_new_block();\n-        let cleanup = self.diverge_cleanup();\n \n         self.cfg.terminate(\n             block,\n             source_info,\n-            TerminatorKind::Assert {\n-                cond,\n-                expected,\n-                msg,\n-                target: success_block,\n-                cleanup: Some(cleanup),\n-            },\n+            TerminatorKind::Assert { cond, expected, msg, target: success_block, cleanup: None },\n         );\n+        self.diverge_from(block);\n \n         success_block\n     }\n \n-    // `match` arm scopes\n-    // ==================\n     /// Unschedules any drops in the top scope.\n     ///\n     /// This is only needed for `match` arm scopes, because they have one\n     /// entrance per pattern, but only one exit.\n-    pub(crate) fn clear_top_scope(&mut self, region_scope: region::Scope) {\n+    crate fn clear_top_scope(&mut self, region_scope: region::Scope) {\n         let top_scope = self.scopes.scopes.last_mut().unwrap();\n \n         assert_eq!(top_scope.region_scope, region_scope);\n \n         top_scope.drops.clear();\n-        top_scope.invalidate_cache(false, self.generator_kind, true);\n+        top_scope.invalidate_cache();\n     }\n }\n \n-/// Builds drops for pop_scope and exit_scope.\n+/// Builds drops for `pop_scope` and `leave_top_scope`.\n fn build_scope_drops<'tcx>(\n     cfg: &mut CFG<'tcx>,\n-    generator_kind: Option<GeneratorKind>,\n+    unwind_drops: &mut DropTree,\n     scope: &Scope,\n     mut block: BasicBlock,\n-    last_unwind_to: BasicBlock,\n+    mut unwind_to: DropIdx,\n+    storage_dead_on_unwind: bool,\n     arg_count: usize,\n-    generator_drop: bool,\n-    is_cached_path: bool,\n ) -> BlockAnd<()> {\n     debug!(\"build_scope_drops({:?} -> {:?})\", block, scope);\n \n@@ -1135,37 +1157,43 @@ fn build_scope_drops<'tcx>(\n     // drops for the unwind path should have already been generated by\n     // `diverge_cleanup_gen`.\n \n-    for drop_idx in (0..scope.drops.len()).rev() {\n-        let drop_data = &scope.drops[drop_idx];\n-        let source_info = scope.source_info(drop_data.span);\n+    for drop_data in scope.drops.iter().rev() {\n+        let source_info = drop_data.source_info;\n         let local = drop_data.local;\n \n         match drop_data.kind {\n             DropKind::Value => {\n+                // `unwind_to` should drop the value that we're about to\n+                // schedule. If dropping this value panics, then we continue\n+                // with the *next* value on the unwind path.\n+                debug_assert_eq!(unwind_drops.drops[unwind_to].0.local, drop_data.local);\n+                debug_assert_eq!(unwind_drops.drops[unwind_to].0.kind, drop_data.kind);\n+                unwind_to = unwind_drops.drops[unwind_to].1;\n+\n                 // If the operand has been moved, and we are not on an unwind\n                 // path, then don't generate the drop. (We only take this into\n                 // account for non-unwind paths so as not to disturb the\n                 // caching mechanism.)\n-                if !is_cached_path && scope.moved_locals.iter().any(|&o| o == local) {\n+                if scope.moved_locals.iter().any(|&o| o == local) {\n                     continue;\n                 }\n \n-                let unwind_to = get_unwind_to(scope, generator_kind, drop_idx, generator_drop)\n-                    .unwrap_or(last_unwind_to);\n+                unwind_drops.add_entry(block, unwind_to);\n \n                 let next = cfg.start_new_block();\n                 cfg.terminate(\n                     block,\n                     source_info,\n-                    TerminatorKind::Drop {\n-                        place: local.into(),\n-                        target: next,\n-                        unwind: Some(unwind_to),\n-                    },\n+                    TerminatorKind::Drop { place: local.into(), target: next, unwind: None },\n                 );\n                 block = next;\n             }\n             DropKind::Storage => {\n+                if storage_dead_on_unwind {\n+                    debug_assert_eq!(unwind_drops.drops[unwind_to].0.local, drop_data.local);\n+                    debug_assert_eq!(unwind_drops.drops[unwind_to].0.kind, drop_data.kind);\n+                    unwind_to = unwind_drops.drops[unwind_to].1;\n+                }\n                 // Only temps and vars need their storage dead.\n                 assert!(local.index() > arg_count);\n                 cfg.push(block, Statement { source_info, kind: StatementKind::StorageDead(local) });\n@@ -1175,139 +1203,180 @@ fn build_scope_drops<'tcx>(\n     block.unit()\n }\n \n-fn get_unwind_to(\n-    scope: &Scope,\n-    generator_kind: Option<GeneratorKind>,\n-    unwind_from: usize,\n-    generator_drop: bool,\n-) -> Option<BasicBlock> {\n-    for drop_idx in (0..unwind_from).rev() {\n-        let drop_data = &scope.drops[drop_idx];\n-        match (generator_kind, &drop_data.kind) {\n-            (Some(_), DropKind::Storage) => {\n-                return Some(drop_data.cached_block.get(generator_drop).unwrap_or_else(|| {\n-                    span_bug!(drop_data.span, \"cached block not present for {:?}\", drop_data)\n-                }));\n-            }\n-            (None, DropKind::Value) => {\n-                return Some(drop_data.cached_block.get(generator_drop).unwrap_or_else(|| {\n-                    span_bug!(drop_data.span, \"cached block not present for {:?}\", drop_data)\n-                }));\n+impl<'a, 'tcx: 'a> Builder<'a, 'tcx> {\n+    /// Build a drop tree for a breakable scope.\n+    ///\n+    /// If `continue_block` is `Some`, then the tree is for `continue` inside a\n+    /// loop. Otherwise this is for `break` or `return`.\n+    fn build_exit_tree(\n+        &mut self,\n+        mut drops: DropTree,\n+        continue_block: Option<BasicBlock>,\n+    ) -> Option<BlockAnd<()>> {\n+        let mut blocks = IndexVec::from_elem(None, &drops.drops);\n+        blocks[ROOT_NODE] = continue_block;\n+\n+        drops.build_mir::<ExitScopes>(&mut self.cfg, &mut blocks);\n+\n+        // Link the exit drop tree to unwind drop tree.\n+        if drops.drops.iter().any(|(drop, _)| drop.kind == DropKind::Value) {\n+            let unwind_target = self.diverge_cleanup();\n+            let mut unwind_indices = IndexVec::from_elem_n(unwind_target, 1);\n+            for (drop_idx, drop_data) in drops.drops.iter_enumerated().skip(1) {\n+                match drop_data.0.kind {\n+                    DropKind::Storage => {\n+                        if self.generator_kind.is_some() {\n+                            let unwind_drop = self\n+                                .scopes\n+                                .unwind_drops\n+                                .add_drop(drop_data.0, unwind_indices[drop_data.1]);\n+                            unwind_indices.push(unwind_drop);\n+                        } else {\n+                            unwind_indices.push(unwind_indices[drop_data.1]);\n+                        }\n+                    }\n+                    DropKind::Value => {\n+                        let unwind_drop = self\n+                            .scopes\n+                            .unwind_drops\n+                            .add_drop(drop_data.0, unwind_indices[drop_data.1]);\n+                        self.scopes\n+                            .unwind_drops\n+                            .add_entry(blocks[drop_idx].unwrap(), unwind_indices[drop_data.1]);\n+                        unwind_indices.push(unwind_drop);\n+                    }\n+                }\n             }\n-            _ => (),\n         }\n+        blocks[ROOT_NODE].map(BasicBlock::unit)\n     }\n-    None\n-}\n \n-fn build_diverge_scope<'tcx>(\n-    cfg: &mut CFG<'tcx>,\n-    span: Span,\n-    scope: &mut Scope,\n-    mut target: BasicBlock,\n-    generator_drop: bool,\n-    generator_kind: Option<GeneratorKind>,\n-) -> BasicBlock {\n-    // Build up the drops in **reverse** order. The end result will\n-    // look like:\n-    //\n-    //    [drops[n]] -...-> [drops[0]] -> [target]\n-    //\n-    // The code in this function reads from right to left. At each\n-    // point, we check for cached blocks representing the\n-    // remainder. If everything is cached, we'll just walk right to\n-    // left reading the cached results but never create anything.\n-\n-    let source_scope = scope.source_scope;\n-    let source_info = |span| SourceInfo { span, scope: source_scope };\n-\n-    // We keep track of StorageDead statements to prepend to our current block\n-    // and store them here, in reverse order.\n-    let mut storage_deads = vec![];\n-\n-    let mut target_built_by_us = false;\n-\n-    // Build up the drops. Here we iterate the vector in\n-    // *forward* order, so that we generate drops[0] first (right to\n-    // left in diagram above).\n-    debug!(\"build_diverge_scope({:?})\", scope.drops);\n-    for (j, drop_data) in scope.drops.iter_mut().enumerate() {\n-        debug!(\"build_diverge_scope drop_data[{}]: {:?}\", j, drop_data);\n-        // Only full value drops are emitted in the diverging path,\n-        // not StorageDead, except in the case of generators.\n+    /// Build the unwind and generator drop trees.\n+    crate fn build_drop_trees(&mut self, should_abort: bool) {\n+        if self.generator_kind.is_some() {\n+            self.build_generator_drop_trees(should_abort);\n+        } else {\n+            Self::build_unwind_tree(\n+                &mut self.cfg,\n+                &mut self.scopes.unwind_drops,\n+                self.fn_span,\n+                should_abort,\n+                &mut None,\n+            );\n+        }\n+    }\n+\n+    fn build_generator_drop_trees(&mut self, should_abort: bool) {\n+        // Build the drop tree for dropping the generator while it's suspended.\n+        let drops = &mut self.scopes.generator_drops;\n+        let cfg = &mut self.cfg;\n+        let fn_span = self.fn_span;\n+        let mut blocks = IndexVec::from_elem(None, &drops.drops);\n+        drops.build_mir::<GeneratorDrop>(cfg, &mut blocks);\n+        if let Some(root_block) = blocks[ROOT_NODE] {\n+            cfg.terminate(\n+                root_block,\n+                SourceInfo::outermost(fn_span),\n+                TerminatorKind::GeneratorDrop,\n+            );\n+        }\n+\n+        // Build the drop tree for unwinding in the normal control flow paths.\n+        let resume_block = &mut None;\n+        let unwind_drops = &mut self.scopes.unwind_drops;\n+        Self::build_unwind_tree(cfg, unwind_drops, fn_span, should_abort, resume_block);\n+\n+        // Build the drop tree for unwinding when dropping a suspended\n+        // generator.\n         //\n-        // Note: This may not actually be what we desire (are we\n-        // \"freeing\" stack storage as we unwind, or merely observing a\n-        // frozen stack)? In particular, the intent may have been to\n-        // match the behavior of clang, but on inspection eddyb says\n-        // this is not what clang does.\n-        match drop_data.kind {\n-            DropKind::Storage if generator_kind.is_some() => {\n-                storage_deads.push(Statement {\n-                    source_info: source_info(drop_data.span),\n-                    kind: StatementKind::StorageDead(drop_data.local),\n-                });\n-                if !target_built_by_us {\n-                    // We cannot add statements to an existing block, so we create a new\n-                    // block for our StorageDead statements.\n-                    let block = cfg.start_new_cleanup_block();\n-                    let source_info = SourceInfo { span: DUMMY_SP, scope: source_scope };\n-                    cfg.goto(block, source_info, target);\n-                    target = block;\n-                    target_built_by_us = true;\n-                }\n-                *drop_data.cached_block.ref_mut(generator_drop) = Some(target);\n+        // This is a different tree to the standard unwind paths here to\n+        // prevent drop elaboration from creating drop flags that would have\n+        // to be captured by the generator. I'm not sure how important this\n+        // optimization is, but it is here.\n+        for (drop_idx, drop_data) in drops.drops.iter_enumerated() {\n+            if let DropKind::Value = drop_data.0.kind {\n+                debug_assert!(drop_data.1 < drops.drops.next_index());\n+                drops.entry_points.push((drop_data.1, blocks[drop_idx].unwrap()));\n             }\n-            DropKind::Storage => {}\n-            DropKind::Value => {\n-                let cached_block = drop_data.cached_block.ref_mut(generator_drop);\n-                target = if let Some(cached_block) = *cached_block {\n-                    storage_deads.clear();\n-                    target_built_by_us = false;\n-                    cached_block\n-                } else {\n-                    push_storage_deads(cfg, target, &mut storage_deads);\n-                    let block = cfg.start_new_cleanup_block();\n-                    cfg.terminate(\n-                        block,\n-                        source_info(drop_data.span),\n-                        TerminatorKind::Drop {\n-                            place: drop_data.local.into(),\n-                            target,\n-                            unwind: None,\n-                        },\n-                    );\n-                    *cached_block = Some(block);\n-                    target_built_by_us = true;\n-                    block\n-                };\n-            }\n-        };\n+        }\n+        Self::build_unwind_tree(cfg, drops, fn_span, should_abort, resume_block);\n     }\n-    push_storage_deads(cfg, target, &mut storage_deads);\n-    *scope.cached_unwind.ref_mut(generator_drop) = Some(target);\n \n-    assert!(storage_deads.is_empty());\n-    debug!(\"build_diverge_scope({:?}, {:?}) = {:?}\", scope, span, target);\n+    fn build_unwind_tree(\n+        cfg: &mut CFG<'tcx>,\n+        drops: &mut DropTree,\n+        fn_span: Span,\n+        should_abort: bool,\n+        resume_block: &mut Option<BasicBlock>,\n+    ) {\n+        let mut blocks = IndexVec::from_elem(None, &drops.drops);\n+        blocks[ROOT_NODE] = *resume_block;\n+        drops.build_mir::<Unwind>(cfg, &mut blocks);\n+        if let (None, Some(resume)) = (*resume_block, blocks[ROOT_NODE]) {\n+            // `TerminatorKind::Abort` is used for `#[unwind(aborts)]`\n+            // functions.\n+            let terminator =\n+                if should_abort { TerminatorKind::Abort } else { TerminatorKind::Resume };\n+\n+            cfg.terminate(resume, SourceInfo::outermost(fn_span), terminator);\n+\n+            *resume_block = blocks[ROOT_NODE];\n+        }\n+    }\n+}\n+\n+// DropTreeBuilder implementations.\n+\n+struct ExitScopes;\n \n-    target\n+impl<'tcx> DropTreeBuilder<'tcx> for ExitScopes {\n+    fn make_block(cfg: &mut CFG<'tcx>) -> BasicBlock {\n+        cfg.start_new_block()\n+    }\n+    fn add_entry(cfg: &mut CFG<'tcx>, from: BasicBlock, to: BasicBlock) {\n+        cfg.block_data_mut(from).terminator_mut().kind = TerminatorKind::Goto { target: to };\n+    }\n }\n \n-fn push_storage_deads<'tcx>(\n-    cfg: &mut CFG<'tcx>,\n-    target: BasicBlock,\n-    storage_deads: &mut Vec<Statement<'tcx>>,\n-) {\n-    if storage_deads.is_empty() {\n-        return;\n+struct GeneratorDrop;\n+\n+impl<'tcx> DropTreeBuilder<'tcx> for GeneratorDrop {\n+    fn make_block(cfg: &mut CFG<'tcx>) -> BasicBlock {\n+        cfg.start_new_block()\n+    }\n+    fn add_entry(cfg: &mut CFG<'tcx>, from: BasicBlock, to: BasicBlock) {\n+        let kind = &mut cfg.block_data_mut(from).terminator_mut().kind;\n+        if let TerminatorKind::Yield { drop, .. } = kind {\n+            *drop = Some(to);\n+        };\n+    }\n+}\n+\n+struct Unwind;\n+\n+impl<'tcx> DropTreeBuilder<'tcx> for Unwind {\n+    fn make_block(cfg: &mut CFG<'tcx>) -> BasicBlock {\n+        cfg.start_new_cleanup_block()\n+    }\n+    fn add_entry(cfg: &mut CFG<'tcx>, from: BasicBlock, to: BasicBlock) {\n+        let term = &mut cfg.block_data_mut(from).terminator_mut().kind;\n+        match term {\n+            TerminatorKind::Drop { unwind, .. }\n+            | TerminatorKind::DropAndReplace { unwind, .. }\n+            | TerminatorKind::FalseUnwind { unwind, .. }\n+            | TerminatorKind::Call { cleanup: unwind, .. }\n+            | TerminatorKind::Assert { cleanup: unwind, .. } => {\n+                *unwind = Some(to);\n+            }\n+            TerminatorKind::Goto { .. }\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Return\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Yield { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::FalseEdges { .. } => bug!(\"cannot unwind from {:?}\", term),\n+        }\n     }\n-    let statements = &mut cfg.block_data_mut(target).statements;\n-    storage_deads.reverse();\n-    debug!(\n-        \"push_storage_deads({:?}), storage_deads={:?}, statements={:?}\",\n-        target, storage_deads, statements\n-    );\n-    storage_deads.append(statements);\n-    mem::swap(statements, storage_deads);\n-    assert!(storage_deads.is_empty());\n }"}, {"sha": "99a791464ab89c3d475a57ce1d6031aa94bd1e61", "filename": "src/test/codegen/drop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/src%2Ftest%2Fcodegen%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69/src%2Ftest%2Fcodegen%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdrop.rs?ref=fa3e2fcbe4bb6c878d137eb427fc34daf49b8c69", "patch": "@@ -23,13 +23,13 @@ pub fn droppy() {\n // FIXME(eddyb) the `void @` forces a match on the instruction, instead of the\n // comment, that's `; call core::intrinsics::drop_in_place::<drop::SomeUniqueName>`\n // for the `v0` mangling, should switch to matching on that once `legacy` is gone.\n+// CHECK-NOT: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n // CHECK-NOT: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n // CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n // CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK-NOT: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n // CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n // CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n // CHECK-NOT: {{(call|invoke) void @.*}}drop_in_place{{.*}}SomeUniqueName\n // The next line checks for the } that ends the function definition"}]}