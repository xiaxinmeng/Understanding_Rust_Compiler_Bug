{"sha": "b2fe254c989b053c4320c023b101b8736a50866c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZmUyNTRjOTg5YjA1M2M0MzIwYzAyM2IxMDFiODczNmE1MDg2NmM=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-11-06T17:00:46Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2019-12-02T13:40:56Z"}, "message": "Remove HasLocalDecls impl from BodyCache's, properly reborrow to Body, rename all body_cache back to body", "tree": {"sha": "bf1a9ed35d9e8577d972e0a7d31f2e03ee4cf071", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf1a9ed35d9e8577d972e0a7d31f2e03ee4cf071"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2fe254c989b053c4320c023b101b8736a50866c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2fe254c989b053c4320c023b101b8736a50866c", "html_url": "https://github.com/rust-lang/rust/commit/b2fe254c989b053c4320c023b101b8736a50866c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2fe254c989b053c4320c023b101b8736a50866c/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "595d161d36b5126e75840c29ce0413a07feebd02", "url": "https://api.github.com/repos/rust-lang/rust/commits/595d161d36b5126e75840c29ce0413a07feebd02", "html_url": "https://github.com/rust-lang/rust/commit/595d161d36b5126e75840c29ce0413a07feebd02"}], "stats": {"total": 1248, "additions": 618, "deletions": 630}, "files": [{"sha": "09c18d714f2c71dd0864db293c3a757fda64f59e", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -2,7 +2,7 @@ use rustc_index::vec::IndexVec;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n use crate::ich::StableHashingContext;\n-use crate::mir::{BasicBlock, BasicBlockData, Body, HasLocalDecls, LocalDecls, Location, Successors};\n+use crate::mir::{BasicBlock, BasicBlockData, Body, LocalDecls, Location, Successors};\n use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use std::iter;\n@@ -160,10 +160,10 @@ impl BodyCache<'tcx> {\n \n #[macro_export]\n macro_rules! read_only {\n-    ($body_cache:expr) => {\n+    ($body:expr) => {\n         {\n-            $body_cache.ensure_predecessors();\n-            $body_cache.unwrap_read_only()\n+            $body.ensure_predecessors();\n+            $body.unwrap_read_only()\n         }\n     };\n }\n@@ -223,12 +223,6 @@ impl<'tcx> DerefMut for BodyCache<'tcx> {\n     }\n }\n \n-impl<'tcx> HasLocalDecls<'tcx> for BodyCache<'tcx> {\n-    fn local_decls(&self) -> &LocalDecls<'tcx> {\n-        &self.body.local_decls\n-    }\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct ReadOnlyBodyCache<'a, 'tcx> {\n     cache: &'a Cache,\n@@ -347,12 +341,6 @@ impl Index<BasicBlock> for ReadOnlyBodyCache<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> HasLocalDecls<'tcx> for ReadOnlyBodyCache<'a, 'tcx> {\n-    fn local_decls(&self) -> &LocalDecls<'tcx> {\n-        &self.body.local_decls\n-    }\n-}\n-\n CloneTypeFoldableAndLiftImpls! {\n     Cache,\n }"}, {"sha": "ea858c80db79b1a7834cc54c92b99fc4d70b389d", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -2602,7 +2602,7 @@ impl Location {\n     pub fn is_predecessor_of<'tcx>(\n         &self,\n         other: Location,\n-        body_cache: ReadOnlyBodyCache<'_, 'tcx>\n+        body: ReadOnlyBodyCache<'_, 'tcx>\n     ) -> bool {\n         // If we are in the same block as the other location and are an earlier statement\n         // then we are a predecessor of `other`.\n@@ -2611,13 +2611,13 @@ impl Location {\n         }\n \n         // If we're in another block, then we want to check that block is a predecessor of `other`.\n-        let mut queue: Vec<BasicBlock> = body_cache.predecessors_for(other.block).to_vec();\n+        let mut queue: Vec<BasicBlock> = body.predecessors_for(other.block).to_vec();\n         let mut visited = FxHashSet::default();\n \n         while let Some(block) = queue.pop() {\n             // If we haven't visited this block before, then make sure we visit it's predecessors.\n             if visited.insert(block) {\n-                queue.extend(body_cache.predecessors_for(block).iter().cloned());\n+                queue.extend(body.predecessors_for(block).iter().cloned());\n             } else {\n                 continue;\n             }"}, {"sha": "47a1d67d5d6dbea8305db373f2b359d4807a43a5", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -82,9 +82,9 @@ macro_rules! make_mir_visitor {\n \n             fn visit_body(\n                 &mut self,\n-                body_cache: body_cache_type!($($mutability)? '_, 'tcx)\n+                body: body_cache_type!($($mutability)? '_, 'tcx)\n             ) {\n-                self.super_body(body_cache);\n+                self.super_body(body);\n             }\n \n             fn visit_basic_block_data(&mut self,\n@@ -254,10 +254,10 @@ macro_rules! make_mir_visitor {\n \n             fn super_body(\n                 &mut self,\n-                $($mutability)? body_cache: body_cache_type!($($mutability)? '_, 'tcx)\n+                $($mutability)? body: body_cache_type!($($mutability)? '_, 'tcx)\n             ) {\n-                let span = body_cache.span;\n-                if let Some(yield_ty) = &$($mutability)? body_cache.yield_ty {\n+                let span = body.span;\n+                if let Some(yield_ty) = &$($mutability)? body.yield_ty {\n                     self.visit_ty(yield_ty, TyContext::YieldTy(SourceInfo {\n                         span,\n                         scope: OUTERMOST_SOURCE_SCOPE,\n@@ -268,14 +268,14 @@ macro_rules! make_mir_visitor {\n                 // than a for-loop, to avoid calling `body::Body::invalidate` for\n                 // each basic block.\n                 macro_rules! basic_blocks {\n-                    (mut) => (body_cache.basic_blocks_mut().iter_enumerated_mut());\n-                    () => (body_cache.basic_blocks().iter_enumerated());\n+                    (mut) => (body.basic_blocks_mut().iter_enumerated_mut());\n+                    () => (body.basic_blocks().iter_enumerated());\n                 };\n                 for (bb, data) in basic_blocks!($($mutability)?) {\n                     self.visit_basic_block_data(bb, data);\n                 }\n \n-                let body: & $($mutability)? Body<'_> = & $($mutability)? body_cache;\n+                let body: & $($mutability)? Body<'_> = & $($mutability)? body;\n                 for scope in &$($mutability)? body.source_scopes {\n                     self.visit_source_scope_data(scope);\n                 }\n@@ -808,10 +808,10 @@ macro_rules! make_mir_visitor {\n \n             fn visit_location(\n                 &mut self,\n-                body_cache: body_cache_type!($($mutability)? '_, 'tcx),\n+                body: body_cache_type!($($mutability)? '_, 'tcx),\n                 location: Location\n             ) {\n-                let basic_block = & $($mutability)? body_cache[location.block];\n+                let basic_block = & $($mutability)? body[location.block];\n                 if basic_block.statements.len() == location.statement_index {\n                     if let Some(ref $($mutability)? terminator) = basic_block.terminator {\n                         self.visit_terminator(terminator, location)"}, {"sha": "a6d7e5c9291dcc48037e3fc351468ff424d74359", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -149,8 +149,8 @@ rustc_queries! {\n                     >> = tcx.queries.on_disk_cache.try_load_query_result(tcx, id);\n                 promoted.map(|p| {\n                     let cache = tcx.arena.alloc(p);\n-                    for body_cache in cache.iter_mut() {\n-                        body_cache.ensure_predecessors();\n+                    for body in cache.iter_mut() {\n+                        body.ensure_predecessors();\n                     }\n                     &*cache\n                 })"}, {"sha": "6a0002cd80fd040428f11ba69538f08a559a305d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -1083,8 +1083,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         &self.hir_map\n     }\n \n-    pub fn alloc_steal_mir(self, mir_cache: BodyCache<'tcx>) -> &'tcx Steal<BodyCache<'tcx>> {\n-        self.arena.alloc(Steal::new(mir_cache))\n+    pub fn alloc_steal_mir(self, mir: BodyCache<'tcx>) -> &'tcx Steal<BodyCache<'tcx>> {\n+        self.arena.alloc(Steal::new(mir))\n     }\n \n     pub fn alloc_steal_promoted(self, promoted: IndexVec<Promoted, BodyCache<'tcx>>) ->"}, {"sha": "f15456e0ff841033c732f8eda6d22ab5bfe39d77", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -131,7 +131,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n             if is_consume {\n                 let base_ty =\n-                    mir::Place::ty_from(place_ref.base, proj_base, &self.fx.mir, cx.tcx());\n+                    mir::Place::ty_from(place_ref.base, proj_base, &*self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access."}, {"sha": "ce59bf1d61d8be1273e6990eb0eb9f32473c52f4", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -324,7 +324,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n     ) {\n-        let ty = location.ty(&self.mir, bx.tcx()).ty;\n+        let ty = location.ty(&*self.mir, bx.tcx()).ty;\n         let ty = self.monomorphize(&ty);\n         let drop_fn = Instance::resolve_drop_in_place(bx.tcx(), ty);\n \n@@ -510,7 +510,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let extra_args = &args[sig.inputs().len()..];\n         let extra_args = extra_args.iter().map(|op_arg| {\n-            let op_ty = op_arg.ty(&self.mir, bx.tcx());\n+            let op_ty = op_arg.ty(&*self.mir, bx.tcx());\n             self.monomorphize(&op_ty)\n         }).collect::<Vec<_>>();\n "}, {"sha": "9dd4d0ec22f233ca7753dcaeedf9ad12c77a7b20", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -594,7 +594,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let place_ty = mir::Place::ty_from(\n             place_ref.base,\n             place_ref.projection,\n-            &self.mir,\n+            &*self.mir,\n             tcx,\n         );\n         self.monomorphize(&place_ty.ty)"}, {"sha": "3bae027e7634db9f40afac41fe1eeb1721959731", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -460,7 +460,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Rvalue::Discriminant(ref place) => {\n-                let discr_ty = rvalue.ty(&self.mir, bx.tcx());\n+                let discr_ty = rvalue.ty(&*self.mir, bx.tcx());\n                 let discr =  self.codegen_place(&mut bx, &place.as_ref())\n                     .codegen_get_discr(&mut bx, discr_ty);\n                 (bx, OperandRef {\n@@ -513,7 +513,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n-                let ty = rvalue.ty(&self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(&*self.mir, self.cx.tcx());\n                 let operand = OperandRef::new_zst(\n                     &mut bx,\n                     self.cx.layout_of(self.monomorphize(&ty)),\n@@ -710,7 +710,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 true,\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                let ty = rvalue.ty(&self.mir, self.cx.tcx());\n+                let ty = rvalue.ty(&*self.mir, self.cx.tcx());\n                 let ty = self.monomorphize(&ty);\n                 self.cx.spanned_layout_of(ty, span).is_zst()\n             }"}, {"sha": "42db642cd4ddb1f4461167fe78bad30b353a16e5", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -1101,8 +1101,8 @@ impl<'a, 'tcx> CrateMetadata {\n                 bug!(\"get_promoted_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n             })\n             .decode((self, tcx));\n-        for body_cache in cache.iter_mut() {\n-            body_cache.ensure_predecessors();\n+        for body in cache.iter_mut() {\n+            body.ensure_predecessors();\n         }\n         cache\n     }"}, {"sha": "802464ce86b8641ae6e2bde4f044120c2be8e263", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -90,7 +90,7 @@ crate enum LocalsStateAtExit {\n impl LocalsStateAtExit {\n     fn build(\n         locals_are_invalidated_at_exit: bool,\n-        body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n+        body: ReadOnlyBodyCache<'_, 'tcx>,\n         move_data: &MoveData<'tcx>\n     ) -> Self {\n         struct HasStorageDead(BitSet<Local>);\n@@ -107,8 +107,8 @@ impl LocalsStateAtExit {\n             LocalsStateAtExit::AllAreInvalidated\n         } else {\n             let mut has_storage_dead\n-                = HasStorageDead(BitSet::new_empty(body_cache.local_decls.len()));\n-            has_storage_dead.visit_body(body_cache);\n+                = HasStorageDead(BitSet::new_empty(body.local_decls.len()));\n+            has_storage_dead.visit_body(body);\n             let mut has_storage_dead_or_moved = has_storage_dead.0;\n             for move_out in &move_data.moves {\n                 if let Some(index) = move_data.base_local(move_out.path) {\n@@ -124,23 +124,23 @@ impl LocalsStateAtExit {\n impl<'tcx> BorrowSet<'tcx> {\n     pub fn build(\n         tcx: TyCtxt<'tcx>,\n-        body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n+        body: ReadOnlyBodyCache<'_, 'tcx>,\n         locals_are_invalidated_at_exit: bool,\n         move_data: &MoveData<'tcx>,\n     ) -> Self {\n         let mut visitor = GatherBorrows {\n             tcx,\n-            body: &body_cache,\n+            body: &body,\n             idx_vec: IndexVec::new(),\n             location_map: Default::default(),\n             activation_map: Default::default(),\n             local_map: Default::default(),\n             pending_activations: Default::default(),\n             locals_state_at_exit:\n-                LocalsStateAtExit::build(locals_are_invalidated_at_exit, body_cache, move_data),\n+                LocalsStateAtExit::build(locals_are_invalidated_at_exit, body, move_data),\n         };\n \n-        for (block, block_data) in traversal::preorder(&body_cache) {\n+        for (block, block_data) in traversal::preorder(&body) {\n             visitor.visit_basic_block_data(block, block_data);\n         }\n "}, {"sha": "2170bd7e7a44cd902a2a150ba1a93d932f6550dd", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -208,7 +208,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty = Place::ty_from(\n                 used_place.base,\n                 used_place.projection,\n-                &self.body_cache,\n+                &*self.body,\n                 self.infcx.tcx\n             ).ty;\n             let needs_note = match ty.kind {\n@@ -225,7 +225,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let mpi = self.move_data.moves[move_out_indices[0]].path;\n                 let place = &self.move_data.move_paths[mpi].place;\n \n-                let ty = place.ty(&self.body_cache, self.infcx.tcx).ty;\n+                let ty = place.ty(&*self.body, self.infcx.tcx).ty;\n                 let opt_name =\n                     self.describe_place_with_options(place.as_ref(), IncludingDowncast(true));\n                 let note_msg = match opt_name {\n@@ -247,7 +247,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     );\n                 }\n                 let span = if let Some(local) = place.as_local() {\n-                    let decl = &self.body_cache.local_decls[local];\n+                    let decl = &self.body.local_decls[local];\n                     Some(decl.source_info.span)\n                 } else {\n                     None\n@@ -317,7 +317,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             None,\n         ).add_explanation_to_diagnostic(\n             self.infcx.tcx,\n-            &self.body_cache,\n+            &self.body,\n             &self.local_names,\n             &mut err,\n             \"\",\n@@ -359,7 +359,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         self.explain_why_borrow_contains_point(location, borrow, None)\n             .add_explanation_to_diagnostic(\n                 self.infcx.tcx,\n-                &self.body_cache,\n+                &self.body,\n                 &self.local_names,\n                 &mut err,\n                 \"\",\n@@ -581,7 +581,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         explanation.add_explanation_to_diagnostic(\n             self.infcx.tcx,\n-            &self.body_cache,\n+            &self.body,\n             &self.local_names,\n             &mut err,\n             first_borrow_desc,\n@@ -625,7 +625,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty = Place::ty_from(\n                 place_base,\n                 place_projection,\n-                &self.body_cache,\n+                &*self.body,\n                 self.infcx.tcx\n             ).ty;\n             ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n@@ -746,7 +746,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         assert!(root_place.projection.is_empty());\n         let proper_span = match root_place.base {\n-            PlaceBase::Local(local) => self.body_cache.local_decls[*local].source_info.span,\n+            PlaceBase::Local(local) => self.body.local_decls[*local].source_info.span,\n             _ => drop_span,\n         };\n \n@@ -973,7 +973,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } else {\n                 explanation.add_explanation_to_diagnostic(\n                     self.infcx.tcx,\n-                    &self.body_cache,\n+                    &self.body,\n                     &self.local_names,\n                     &mut err,\n                     \"\",\n@@ -999,7 +999,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             );\n \n             explanation.add_explanation_to_diagnostic(\n-                self.infcx.tcx, &self.body_cache, &self.local_names, &mut err, \"\", None);\n+                self.infcx.tcx, &self.body, &self.local_names, &mut err, \"\", None);\n         }\n \n         err\n@@ -1059,7 +1059,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         explanation.add_explanation_to_diagnostic(\n             self.infcx.tcx,\n-            &self.body_cache,\n+            &self.body,\n             &self.local_names,\n             &mut err,\n             \"\",\n@@ -1146,7 +1146,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n         explanation.add_explanation_to_diagnostic(\n             self.infcx.tcx,\n-            &self.body_cache,\n+            &self.body,\n             &self.local_names,\n             &mut err,\n             \"\",\n@@ -1183,15 +1183,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // FIXME use a better heuristic than Spans\n         let reference_desc\n-            = if return_span == self.body_cache.source_info(borrow.reserve_location).span {\n+            = if return_span == self.body.source_info(borrow.reserve_location).span {\n                 \"reference to\"\n             } else {\n                 \"value referencing\"\n             };\n \n         let (place_desc, note) = if let Some(place_desc) = opt_place_desc {\n             let local_kind = if let Some(local) = borrow.borrowed_place.as_local() {\n-                match self.body_cache.local_kind(local) {\n+                match self.body.local_kind(local) {\n                     LocalKind::ReturnPointer\n                     | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n                     LocalKind::Var => \"local variable \",\n@@ -1224,7 +1224,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } else {\n                 bug!(\"try_report_cannot_return_reference_to_local: not a local\")\n             };\n-            match self.body_cache.local_kind(*local) {\n+            match self.body.local_kind(*local) {\n                 LocalKind::ReturnPointer | LocalKind::Temp => (\n                     \"temporary value\".to_string(),\n                     \"temporary value created here\".to_string(),\n@@ -1382,7 +1382,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     fn get_moved_indexes(&mut self, location: Location, mpi: MovePathIndex) -> Vec<MoveSite> {\n         let mut stack = Vec::new();\n-        stack.extend(self.body_cache.predecessor_locations(location).map(|predecessor| {\n+        stack.extend(self.body.predecessor_locations(location).map(|predecessor| {\n             let is_back_edge = location.dominates(predecessor, &self.dominators);\n             (predecessor, is_back_edge)\n         }));\n@@ -1401,7 +1401,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             // check for moves\n-            let stmt_kind = self.body_cache[location.block]\n+            let stmt_kind = self.body[location.block]\n                 .statements\n                 .get(location.statement_index)\n                 .map(|s| &s.kind);\n@@ -1456,7 +1456,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let mut any_match = false;\n             drop_flag_effects::for_location_inits(\n                 self.infcx.tcx,\n-                &self.body_cache,\n+                &self.body,\n                 self.move_data,\n                 location,\n                 |m| {\n@@ -1469,7 +1469,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 continue 'dfs;\n             }\n \n-            stack.extend(self.body_cache.predecessor_locations(location).map(|predecessor| {\n+            stack.extend(self.body.predecessor_locations(location).map(|predecessor| {\n                 let back_edge = location.dominates(predecessor, &self.dominators);\n                 (predecessor, is_back_edge || back_edge)\n             }));\n@@ -1521,7 +1521,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         self.explain_why_borrow_contains_point(location, loan, None)\n             .add_explanation_to_diagnostic(\n                 self.infcx.tcx,\n-                &self.body_cache,\n+                &self.body,\n                 &self.local_names,\n                 &mut err,\n                 \"\",\n@@ -1546,8 +1546,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) {\n         let (from_arg, local_decl, local_name) = match err_place.as_local() {\n             Some(local) => (\n-                self.body_cache.local_kind(local) == LocalKind::Arg,\n-                Some(&self.body_cache.local_decls[local]),\n+                self.body.local_kind(local) == LocalKind::Arg,\n+                Some(&self.body.local_decls[local]),\n                 self.local_names[local],\n             ),\n             None => (false, None, None),\n@@ -1635,7 +1635,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 Place::ty_from(\n                                     &place.base,\n                                     proj_base,\n-                                    &self.body_cache,\n+                                    &*self.body,\n                                     tcx\n                                 ).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n@@ -1648,7 +1648,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         let base_ty = Place::ty_from(\n                             &place.base,\n                             proj_base,\n-                            &self.body_cache,\n+                            &*self.body,\n                             tcx\n                         ).ty;\n                         match base_ty.kind {\n@@ -1738,22 +1738,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             location\n         );\n         if let Some(&Statement { kind: StatementKind::Assign(box(ref reservation, _)), ..})\n-             = &self.body_cache[location.block].statements.get(location.statement_index)\n+             = &self.body[location.block].statements.get(location.statement_index)\n         {\n             debug!(\n                 \"annotate_argument_and_return_for_borrow: reservation={:?}\",\n                 reservation\n             );\n             // Check that the initial assignment of the reserve location is into a temporary.\n             let mut target = match reservation.as_local() {\n-                Some(local) if self.body_cache.local_kind(local) == LocalKind::Temp => local,\n+                Some(local) if self.body.local_kind(local) == LocalKind::Temp => local,\n                 _ => return None,\n             };\n \n             // Next, look through the rest of the block, checking if we are assigning the\n             // `target` (that is, the place that contains our borrow) to anything.\n             let mut annotated_closure = None;\n-            for stmt in &self.body_cache[location.block].statements[location.statement_index + 1..]\n+            for stmt in &self.body[location.block].statements[location.statement_index + 1..]\n             {\n                 debug!(\n                     \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n@@ -1879,7 +1879,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             // Check the terminator if we didn't find anything in the statements.\n-            let terminator = &self.body_cache[location.block].terminator();\n+            let terminator = &self.body[location.block].terminator();\n             debug!(\n                 \"annotate_argument_and_return_for_borrow: target={:?} terminator={:?}\",\n                 target, terminator"}, {"sha": "cc15d236b2325865fb90702ee5e8173430189659", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -39,7 +39,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) {\n         debug!(\"add_moved_or_invoked_closure_note: location={:?} place={:?}\", location, place);\n         let mut target = place.local_or_deref_local();\n-        for stmt in &self.body_cache[location.block].statements[location.statement_index..] {\n+        for stmt in &self.body[location.block].statements[location.statement_index..] {\n             debug!(\"add_moved_or_invoked_closure_note: stmt={:?} target={:?}\", stmt, target);\n             if let StatementKind::Assign(box(into, Rvalue::Use(from))) = &stmt.kind {\n                 debug!(\"add_fnonce_closure_note: into={:?} from={:?}\", into, from);\n@@ -53,7 +53,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         // Check if we are attempting to call a closure after it has been invoked.\n-        let terminator = self.body_cache[location.block].terminator();\n+        let terminator = self.body[location.block].terminator();\n         debug!(\"add_moved_or_invoked_closure_note: terminator={:?}\", terminator);\n         if let TerminatorKind::Call {\n             func: Operand::Constant(box Constant {\n@@ -76,7 +76,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 };\n \n                 debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n-                if let ty::Closure(did, _) = self.body_cache.local_decls[closure].ty.kind {\n+                if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind {\n                     let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n \n                     if let Some((span, name)) = self.infcx.tcx.typeck_tables_of(did)\n@@ -99,7 +99,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         // Check if we are just moving a closure after it has been invoked.\n         if let Some(target) = target {\n-            if let ty::Closure(did, _) = self.body_cache.local_decls[target].ty.kind {\n+            if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind {\n                 let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n \n                 if let Some((span, name)) = self.infcx.tcx.typeck_tables_of(did)\n@@ -332,7 +332,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have\n     /// a name, or its name was generated by the compiler, then `Err` is returned\n     fn append_local_to_string(&self, local: Local, buf: &mut String) -> Result<(), ()> {\n-        let decl = &self.body_cache.local_decls[local];\n+        let decl = &self.body.local_decls[local];\n         match self.local_names[local] {\n             Some(name) if !decl.from_compiler_desugaring() => {\n                 buf.push_str(&name.as_str());\n@@ -350,7 +350,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 base: PlaceBase::Local(local),\n                 projection: [],\n             } => {\n-                let local = &self.body_cache.local_decls[*local];\n+                let local = &self.body.local_decls[*local];\n                 self.describe_field_from_ty(&local.ty, field, None)\n             }\n             PlaceRef {\n@@ -372,7 +372,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let base_ty = Place::ty_from(\n                         place.base,\n                         place.projection,\n-                        &self.body_cache,\n+                        &*self.body,\n                         self.infcx.tcx).ty;\n                     self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n                 }\n@@ -484,7 +484,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         _ => continue,\n                     };\n \n-                    let bbd = &self.body_cache[loc.block];\n+                    let bbd = &self.body[loc.block];\n                     let is_terminator = bbd.statements.len() == loc.statement_index;\n                     debug!(\n                         \"borrowed_content_source: loc={:?} is_terminator={:?}\",\n@@ -502,7 +502,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         ..\n                     }) = bbd.terminator {\n                         if let Some(source) = BorrowedContentSource::from_call(\n-                            func.ty(&self.body_cache, tcx),\n+                            func.ty(&*self.body, tcx),\n                             tcx\n                         ) {\n                             return source;\n@@ -519,7 +519,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let base_ty = Place::ty_from(\n             deref_base.base,\n             deref_base.projection,\n-            &self.body_cache,\n+            &*self.body,\n             tcx\n         ).ty;\n         if base_ty.is_unsafe_ptr() {\n@@ -776,9 +776,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> UseSpans {\n         use self::UseSpans::*;\n \n-        let stmt = match self.body_cache[location.block].statements.get(location.statement_index) {\n+        let stmt = match self.body[location.block].statements.get(location.statement_index) {\n             Some(stmt) => stmt,\n-            None => return OtherUse(self.body_cache.source_info(location).span),\n+            None => return OtherUse(self.body.source_info(location).span),\n         };\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n@@ -816,7 +816,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         use self::UseSpans::*;\n         debug!(\"borrow_spans: use_span={:?} location={:?}\", use_span, location);\n \n-        let target = match self.body_cache[location.block]\n+        let target = match self.body[location.block]\n             .statements\n             .get(location.statement_index)\n         {\n@@ -833,12 +833,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             _ => return OtherUse(use_span),\n         };\n \n-        if self.body_cache.local_kind(target) != LocalKind::Temp {\n+        if self.body.local_kind(target) != LocalKind::Temp {\n             // operands are always temporaries.\n             return OtherUse(use_span);\n         }\n \n-        for stmt in &self.body_cache[location.block].statements[location.statement_index + 1..] {\n+        for stmt in &self.body[location.block].statements[location.statement_index + 1..] {\n             if let StatementKind::Assign(\n                 box(_, Rvalue::Aggregate(ref kind, ref places))\n             ) = stmt.kind {\n@@ -910,7 +910,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Helper to retrieve span(s) of given borrow from the current MIR\n     /// representation\n     pub(super) fn retrieve_borrow_spans(&self, borrow: &BorrowData<'_>) -> UseSpans {\n-        let span = self.body_cache.source_info(borrow.reserve_location).span;\n+        let span = self.body.source_info(borrow.reserve_location).span;\n         self.borrow_spans(span, borrow.reserve_location)\n     }\n }"}, {"sha": "da08de7690ab22043472a446912af1686bc832f9", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -162,22 +162,22 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // requires first making our own copy of the MIR. This copy will\n     // be modified (in place) to contain non-lexical lifetimes. It\n     // will have a lifetime tied to the inference context.\n-    let body: Body<'tcx> = input_body.clone();\n+    let body_clone: Body<'tcx> = input_body.clone();\n     let mut promoted = input_promoted.clone();\n-    let mut body_cache = BodyCache::new(body);\n+    let mut body = BodyCache::new(body_clone);\n     let free_regions =\n-        nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body_cache, &mut promoted);\n-    let body_cache = read_only!(body_cache); // no further changes\n+        nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body, &mut promoted);\n+    let body = read_only!(body); // no further changes\n     let promoted: IndexVec<_, _> = promoted\n         .iter_mut()\n-        .map(|body_cache| read_only!(body_cache))\n+        .map(|body| read_only!(body))\n         .collect();\n \n-    let location_table = &LocationTable::new(&body_cache);\n+    let location_table = &LocationTable::new(&body);\n \n     let mut errors_buffer = Vec::new();\n     let (move_data, move_errors): (MoveData<'tcx>, Option<Vec<(Place<'tcx>, MoveError<'tcx>)>>) =\n-        match MoveData::gather_moves(&body_cache, tcx) {\n+        match MoveData::gather_moves(&body, tcx) {\n             Ok(move_data) => (move_data, None),\n             Err((move_data, move_errors)) => (move_data, Some(move_errors)),\n         };\n@@ -187,27 +187,27 @@ fn do_mir_borrowck<'a, 'tcx>(\n         param_env,\n     };\n \n-    let dead_unwinds = BitSet::new_empty(body_cache.basic_blocks().len());\n+    let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n     let mut flow_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        &body_cache,\n+        &body,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        MaybeInitializedPlaces::new(tcx, &body_cache, &mdpe),\n+        MaybeInitializedPlaces::new(tcx, &body, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n \n     let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(id).is_fn_or_closure();\n     let borrow_set = Rc::new(BorrowSet::build(\n-            tcx, body_cache, locals_are_invalidated_at_exit, &mdpe.move_data));\n+        tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n     // If we are in non-lexical mode, compute the non-lexical lifetimes.\n     let (regioncx, polonius_output, opt_closure_req) = nll::compute_regions(\n         infcx,\n         def_id,\n         free_regions,\n-        body_cache,\n+        body,\n         &promoted,\n         &local_names,\n         &upvars,\n@@ -228,29 +228,29 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let flow_borrows = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        &body_cache,\n+        &body,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        Borrows::new(tcx, &body_cache, param_env, regioncx.clone(), &borrow_set),\n+        Borrows::new(tcx, &body, param_env, regioncx.clone(), &borrow_set),\n         |rs, i| DebugFormatted::new(&rs.location(i)),\n     ));\n     let flow_uninits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        &body_cache,\n+        &body,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        MaybeUninitializedPlaces::new(tcx, &body_cache, &mdpe),\n+        MaybeUninitializedPlaces::new(tcx, &body, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n     let flow_ever_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        &body_cache,\n+        &body,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        EverInitializedPlaces::new(tcx, &body_cache, &mdpe),\n+        EverInitializedPlaces::new(tcx, &body, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n     ));\n \n@@ -262,11 +262,11 @@ fn do_mir_borrowck<'a, 'tcx>(\n         _ => true,\n     };\n \n-    let dominators = body_cache.dominators();\n+    let dominators = body.dominators();\n \n     let mut mbcx = MirBorrowckCtxt {\n         infcx,\n-        body_cache,\n+        body,\n         mir_def_id: def_id,\n         param_env,\n         move_data: &mdpe.move_data,\n@@ -306,8 +306,8 @@ fn do_mir_borrowck<'a, 'tcx>(\n         let mut initial_diag =\n             mbcx.report_conflicting_borrow(location, (&place, span), bk, &borrow);\n \n-        let scope = mbcx.body_cache.source_info(location).scope;\n-        let lint_root = match &mbcx.body_cache.source_scopes[scope].local_data {\n+        let scope = mbcx.body.source_info(location).scope;\n+        let lint_root = match &mbcx.body.source_scopes[scope].local_data {\n             ClearCrossCrate::Set(data) => data.lint_root,\n             _ => id,\n         };\n@@ -329,22 +329,22 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // would have a chance of erroneously adding non-user-defined mutable vars\n     // to the set.\n     let temporary_used_locals: FxHashSet<Local> = mbcx.used_mut.iter()\n-        .filter(|&local| !mbcx.body_cache.local_decls[*local].is_user_variable())\n+        .filter(|&local| !mbcx.body.local_decls[*local].is_user_variable())\n         .cloned()\n         .collect();\n     // For the remaining unused locals that are marked as mutable, we avoid linting any that\n     // were never initialized. These locals may have been removed as unreachable code; or will be\n     // linted as unused variables.\n-    let unused_mut_locals = mbcx.body_cache.mut_vars_iter()\n+    let unused_mut_locals = mbcx.body.mut_vars_iter()\n         .filter(|local| !mbcx.used_mut.contains(local))\n         .collect();\n     mbcx.gather_used_muts(temporary_used_locals, unused_mut_locals);\n \n     debug!(\"mbcx.used_mut: {:?}\", mbcx.used_mut);\n     let used_mut = mbcx.used_mut;\n-    for local in mbcx.body_cache.mut_vars_and_args_iter().filter(|local| !used_mut.contains(local))\n+    for local in mbcx.body.mut_vars_and_args_iter().filter(|local| !used_mut.contains(local))\n     {\n-        let local_decl = &mbcx.body_cache.local_decls[local];\n+        let local_decl = &mbcx.body.local_decls[local];\n         let lint_root = match &mbcx.body.source_scopes[local_decl.source_info.scope].local_data {\n             ClearCrossCrate::Set(data) => data.lint_root,\n             _ => continue,\n@@ -405,7 +405,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     crate infcx: &'cx InferCtxt<'cx, 'tcx>,\n-    body_cache: ReadOnlyBodyCache<'cx, 'tcx>,\n+    body: ReadOnlyBodyCache<'cx, 'tcx>,\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n     move_data: &'cx MoveData<'tcx>,\n@@ -496,7 +496,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n     type FlowState = Flows<'cx, 'tcx>;\n \n     fn body(&self) -> &'cx Body<'tcx> {\n-        self.body_cache.body()\n+        self.body.body()\n     }\n \n     fn visit_block_entry(&mut self, bb: BasicBlock, flow_state: &Self::FlowState) {\n@@ -646,7 +646,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 let tcx = self.infcx.tcx;\n \n                 // Compute the type with accurate region information.\n-                let drop_place_ty = drop_place.ty(&self.body_cache, self.infcx.tcx);\n+                let drop_place_ty = drop_place.ty(&*self.body, self.infcx.tcx);\n \n                 // Erase the regions.\n                 let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;\n@@ -990,8 +990,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         let mut error_reported = false;\n         let tcx = self.infcx.tcx;\n-        let body_cache = self.body_cache;\n-        let body: &Body<'_> = &body_cache;\n+        let body = self.body;\n+        let body: &Body<'_> = &body;\n         let param_env = self.param_env;\n         let location_table = self.location_table.start_index(location);\n         let borrow_set = self.borrow_set.clone();\n@@ -1157,7 +1157,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // (e.g., `x = ...`) so long as it has never been initialized\n         // before (at this point in the flow).\n         if let Some(local) = place_span.0.as_local() {\n-            if let Mutability::Not = self.body_cache.local_decls[local].mutability {\n+            if let Mutability::Not = self.body.local_decls[local].mutability {\n                 // check for reassignments to immutable local variables\n                 self.check_if_reassignment_to_immutable_state(\n                     location,\n@@ -1310,8 +1310,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match *operand {\n             Operand::Move(ref place) | Operand::Copy(ref place) => {\n                 match place.as_local() {\n-                    Some(local) if !self.body_cache.local_decls[local].is_user_variable() => {\n-                        if self.body_cache.local_decls[local].ty.is_mutable_ptr() {\n+                    Some(local) if !self.body.local_decls[local].is_user_variable() => {\n+                        if self.body.local_decls[local].ty.is_mutable_ptr() {\n                             // The variable will be marked as mutable by the borrow.\n                             return;\n                         }\n@@ -1342,8 +1342,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             _ => bug!(\"temporary initialized in arguments\"),\n                         };\n \n-                        let body_cache = self.body_cache;\n-                        let bbd = &body_cache[loc.block];\n+                        let body = self.body;\n+                        let bbd = &body[loc.block];\n                         let stmt = &bbd.statements[loc.statement_index];\n                         debug!(\"temporary assigned in: stmt={:?}\", stmt);\n \n@@ -1462,7 +1462,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if places_conflict::borrow_conflicts_with_place(\n             self.infcx.tcx,\n             self.param_env,\n-            &self.body_cache,\n+            &self.body,\n             place,\n             borrow.kind,\n             root_place,\n@@ -1542,7 +1542,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let Some(init_index) = self.is_local_ever_initialized(local, flow_state) {\n             // And, if so, report an error.\n             let init = &self.move_data.inits[init_index];\n-            let span = init.span(&self.body_cache);\n+            let span = init.span(&self.body);\n             self.report_illegal_reassignment(\n                 location, place_span, span, place_span.0\n             );\n@@ -1865,7 +1865,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n                             this.move_data.moves[*moi].source.is_predecessor_of(\n-                                location, this.body_cache,\n+                                location, this.body,\n                             )\n                         }) {\n                             return;\n@@ -2069,7 +2069,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 base: PlaceBase::Local(local),\n                 projection: [],\n             } => {\n-                let local = &self.body_cache.local_decls[*local];\n+                let local = &self.body.local_decls[*local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes => Ok(RootPlace {"}, {"sha": "388a8abd5fc1ff582db9919f05486cfb9bd62785", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -90,13 +90,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 // flow could be used.\n                 if let Some(StatementKind::Assign(\n                     box(place, Rvalue::Use(Operand::Move(move_from)))\n-                )) = self.body_cache.basic_blocks()[location.block]\n+                )) = self.body.basic_blocks()[location.block]\n                     .statements\n                     .get(location.statement_index)\n                     .map(|stmt| &stmt.kind)\n                 {\n                     if let Some(local) = place.as_local() {\n-                        let local_decl = &self.body_cache.local_decls[local];\n+                        let local_decl = &self.body.local_decls[local];\n                         // opt_match_place is the\n                         // match_span is the span of the expression being matched on\n                         // match *x.y { ... }        match_place is Some(*x.y)\n@@ -112,7 +112,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 pat_span: _,\n                             },\n                         ))) = local_decl.local_info {\n-                            let stmt_source_info = self.body_cache.source_info(location);\n+                            let stmt_source_info = self.body.source_info(location);\n                             self.append_binding_error(\n                                 grouped_errors,\n                                 kind,\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this\n         // was a move rather than a copy.\n-        let ty = deref_target_place.ty(&self.body_cache, self.infcx.tcx).ty;\n+        let ty = deref_target_place.ty(&*self.body, self.infcx.tcx).ty;\n         let upvar_field = self.prefixes(move_place.as_ref(), PrefixSet::All)\n             .find_map(|p| self.is_upvar_field_projection(p));\n \n@@ -318,7 +318,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             base: PlaceBase::Local(local),\n             projection: [],\n         } = deref_base {\n-            let decl = &self.body_cache.local_decls[*local];\n+            let decl = &self.body.local_decls[*local];\n             if decl.is_ref_for_guard() {\n                 let mut err = self.cannot_move_out_of(\n                     span,\n@@ -411,7 +411,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n         let move_ty = format!(\n             \"{:?}\",\n-            move_place.ty(&self.body_cache, self.infcx.tcx).ty,\n+            move_place.ty(&*self.body, self.infcx.tcx).ty,\n         );\n         if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n             let is_option = move_ty.starts_with(\"std::option::Option\");\n@@ -454,7 +454,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n \n                 if binds_to.is_empty() {\n-                    let place_ty = move_from.ty(&self.body_cache, self.infcx.tcx).ty;\n+                    let place_ty = move_from.ty(&*self.body, self.infcx.tcx).ty;\n                     let place_desc = match self.describe_place(move_from.as_ref()) {\n                         Some(desc) => format!(\"`{}`\", desc),\n                         None => format!(\"value\"),\n@@ -482,7 +482,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // No binding. Nothing to suggest.\n             GroupedMoveError::OtherIllegalMove { ref original_path, use_spans, .. } => {\n                 let span = use_spans.var_or_use();\n-                let place_ty = original_path.ty(&self.body_cache, self.infcx.tcx).ty;\n+                let place_ty = original_path.ty(&*self.body, self.infcx.tcx).ty;\n                 let place_desc = match self.describe_place(original_path.as_ref()) {\n                     Some(desc) => format!(\"`{}`\", desc),\n                     None => format!(\"value\"),\n@@ -510,7 +510,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ) {\n         let mut suggestions: Vec<(Span, &str, String)> = Vec::new();\n         for local in binds_to {\n-            let bind_to = &self.body_cache.local_decls[*local];\n+            let bind_to = &self.body.local_decls[*local];\n             if let LocalInfo::User(\n                 ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                     pat_span,\n@@ -559,7 +559,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         binds_to: &[Local],\n     ) {\n         for (j, local) in binds_to.into_iter().enumerate() {\n-            let bind_to = &self.body_cache.local_decls[*local];\n+            let bind_to = &self.body.local_decls[*local];\n             let binding_span = bind_to.source_info.span;\n \n             if j == 0 {"}, {"sha": "348c788eb33ae8cbcd8feb444ebea675cd5d7149", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Place::ty_from(\n                         &the_place_err.base,\n                         proj_base,\n-                        &self.body_cache,\n+                        &*self.body,\n                         self.infcx.tcx\n                     ).ty));\n \n@@ -110,12 +110,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     proj_base.is_empty() &&\n                     !self.upvars.is_empty() {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    debug_assert!(self.body_cache.local_decls[Local::new(1)].ty.is_region_ptr());\n+                    debug_assert!(self.body.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n                         Place::ty_from(\n                             the_place_err.base,\n                             the_place_err.projection,\n-                            &self.body_cache,\n+                            &*self.body,\n                             self.infcx.tcx\n                         )\n                         .ty\n@@ -229,7 +229,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    Place::ty_from(base, proj_base, &self.body_cache, self.infcx.tcx).ty,\n+                    Place::ty_from(base, proj_base, &*self.body, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -246,7 +246,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 base: PlaceBase::Local(local),\n                 projection: [],\n             } if {\n-                self.body_cache.local_decls.get(*local).map(|local_decl| {\n+                self.body.local_decls.get(*local).map(|local_decl| {\n                     if let LocalInfo::User(ClearCrossCrate::Set(\n                         mir::BindingForm::ImplicitSelf(kind)\n                     )) = local_decl.local_info {\n@@ -281,12 +281,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [],\n-            } if self.body_cache.local_decls[*local].can_be_made_mutable() => {\n+            } if self.body.local_decls[*local].can_be_made_mutable() => {\n                 // ... but it doesn't make sense to suggest it on\n                 // variables that are `ref x`, `ref mut x`, `&self`,\n                 // or `&mut self` (such variables are simply not\n                 // mutable).\n-                let local_decl = &self.body_cache.local_decls[*local];\n+                let local_decl = &self.body.local_decls[*local];\n                 assert_eq!(local_decl.mutability, Mutability::Not);\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -304,7 +304,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(base, proj_base, &self.body_cache, self.infcx.tcx).ty\n+                    Place::ty_from(base, proj_base, &*self.body, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -350,7 +350,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [ProjectionElem::Deref],\n-            } if self.body_cache.local_decls[*local].is_ref_for_guard() => {\n+            } if self.body.local_decls[*local].is_ref_for_guard() => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.note(\n                     \"variables bound in patterns are immutable until the end of the pattern guard\",\n@@ -365,9 +365,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [ProjectionElem::Deref],\n-            } if self.body.local_decls[*local].is_user_variable() =>\n+            } if self.body_cache.local_decls[*local].is_user_variable.is_some() =>\n             {\n-                let local_decl = &self.body_cache.local_decls[*local];\n+                let local_decl = &self.body.local_decls[*local];\n                 let suggestion = match local_decl.local_info {\n                     LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(_))) => {\n                         Some(suggest_ampmut_self(self.infcx.tcx, local_decl))\n@@ -381,7 +381,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         },\n                     ))) => Some(suggest_ampmut(\n                         self.infcx.tcx,\n-                        self.body_cache,\n+                        self.body,\n                         *local,\n                         local_decl,\n                         opt_ty_info,\n@@ -455,7 +455,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_help(\n-                    self.body_cache.span,\n+                    self.body.span,\n                     \"consider changing this to accept closures that implement `FnMut`\"\n                 );\n             }\n@@ -533,14 +533,14 @@ fn suggest_ampmut_self<'tcx>(\n // by trying (3.), then (2.) and finally falling back on (1.).\n fn suggest_ampmut<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     local: Local,\n     local_decl: &mir::LocalDecl<'tcx>,\n     opt_ty_info: Option<Span>,\n ) -> (Span, String) {\n-    let locations = body_cache.find_assignments(local);\n+    let locations = body.find_assignments(local);\n     if !locations.is_empty() {\n-        let assignment_rhs_span = body_cache.source_info(locations[0]).span;\n+        let assignment_rhs_span = body.source_info(locations[0]).span;\n         if let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span) {\n             if let (true, Some(ws_pos)) = (\n                 src.starts_with(\"&'\"),"}, {"sha": "43aabac00bcfad9582625c5562c7219921772840", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -237,7 +237,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n \n         let regioncx = &self.nonlexical_regioncx;\n-        let body: &Body<'_> = &self.body_cache;\n+        let body: &Body<'_> = &self.body;\n         let tcx = self.infcx.tcx;\n \n         let borrow_region_vid = borrow.region;\n@@ -297,7 +297,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 if let Some(region) = regioncx.to_error_region_vid(borrow_region_vid) {\n                     let (category, from_closure, span, region_name) =\n                         self.nonlexical_regioncx.free_region_constraint_info(\n-                            &self.body_cache,\n+                            &self.body,\n                             &self.local_names,\n                             &self.upvars,\n                             self.mir_def_id,\n@@ -365,7 +365,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 return outmost_back_edge;\n             }\n \n-            let block = &self.body_cache.basic_blocks()[location.block];\n+            let block = &self.body.basic_blocks()[location.block];\n \n             if location.statement_index < block.statements.len() {\n                 let successor = location.successor_within_block();\n@@ -427,7 +427,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         if loop_head.dominates(from, &self.dominators) {\n-            let block = &self.body_cache.basic_blocks()[from.block];\n+            let block = &self.body.basic_blocks()[from.block];\n \n             if from.statement_index < block.statements.len() {\n                 let successor = from.successor_within_block();\n@@ -475,7 +475,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 (LaterUseKind::ClosureCapture, var_span)\n             }\n             UseSpans::OtherUse(span) => {\n-                let block = &self.body_cache.basic_blocks()[location.block];\n+                let block = &self.body.basic_blocks()[location.block];\n \n                 let kind = if let Some(&Statement {\n                     kind: StatementKind::FakeRead(FakeReadCause::ForLet, _),\n@@ -498,7 +498,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             Operand::Copy(place) |\n                             Operand::Move(place) => {\n                                 if let Some(l) = place.as_local() {\n-                                    let local_decl = &self.body_cache.local_decls[l];\n+                                    let local_decl = &self.body.local_decls[l];\n                                     if self.local_names[l].is_none() {\n                                         local_decl.source_info.span\n                                     } else {\n@@ -528,7 +528,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn was_captured_by_trait_object(&self, borrow: &BorrowData<'tcx>) -> bool {\n         // Start at the reserve location, find the place that we want to see cast to a trait object.\n         let location = borrow.reserve_location;\n-        let block = &self.body_cache[location.block];\n+        let block = &self.body[location.block];\n         let stmt = block.statements.get(location.statement_index);\n         debug!(\n             \"was_captured_by_trait_object: location={:?} stmt={:?}\",\n@@ -558,7 +558,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n         while let Some(current_location) = queue.pop() {\n             debug!(\"was_captured_by_trait: target={:?}\", target);\n-            let block = &self.body_cache[current_location.block];\n+            let block = &self.body[current_location.block];\n             // We need to check the current location to find out if it is a terminator.\n             let is_terminator = current_location.statement_index == block.statements.len();\n             if !is_terminator {"}, {"sha": "98679f236db50142a4bc2a2acaa1319cd3b11078", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -22,7 +22,7 @@ pub(super) fn generate_invalidates<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n-    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n ) {\n     if all_facts.is_none() {\n@@ -31,17 +31,17 @@ pub(super) fn generate_invalidates<'tcx>(\n     }\n \n     if let Some(all_facts) = all_facts {\n-        let dominators = body_cache.dominators();\n+        let dominators = body.dominators();\n         let mut ig = InvalidationGenerator {\n             all_facts,\n             borrow_set,\n             param_env,\n             tcx,\n             location_table,\n-            body: &body_cache,\n+            body: &body,\n             dominators,\n         };\n-        ig.visit_body(body_cache);\n+        ig.visit_body(body);\n     }\n }\n "}, {"sha": "16182fe24fa4f171f2487da2502800bea44d39ad", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -55,7 +55,7 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_cache: &mut BodyCache<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     promoted: &mut IndexVec<Promoted, BodyCache<'tcx>>,\n ) -> UniversalRegions<'tcx> {\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n@@ -64,10 +64,10 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n \n     // Replace all remaining regions with fresh inference variables.\n-    renumber::renumber_mir(infcx, body_cache, promoted);\n+    renumber::renumber_mir(infcx, body, promoted);\n \n     let source = MirSource::item(def_id);\n-    mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, body_cache, |_, _| Ok(()));\n+    mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, body, |_, _| Ok(()));\n \n     universal_regions\n }\n@@ -158,8 +158,8 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n-    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n-    promoted_cache: &IndexVec<Promoted, ReadOnlyBodyCache<'_, 'tcx>>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n+    promoted: &IndexVec<Promoted, ReadOnlyBodyCache<'_, 'tcx>>,\n     local_names: &IndexVec<Local, Option<Symbol>>,\n     upvars: &[Upvar],\n     location_table: &LocationTable,\n@@ -182,7 +182,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     let universal_regions = Rc::new(universal_regions);\n \n     let elements\n-        = &Rc::new(RegionValueElements::new(&body_cache));\n+        = &Rc::new(RegionValueElements::new(&body));\n \n     // Run the MIR type-checker.\n     let MirTypeckResults {\n@@ -191,8 +191,8 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     } = type_check::type_check(\n         infcx,\n         param_env,\n-        body_cache,\n-        promoted_cache,\n+        body,\n+        promoted,\n         def_id,\n         &universal_regions,\n         location_table,\n@@ -207,7 +207,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         all_facts\n             .universal_region\n             .extend(universal_regions.universal_regions());\n-        populate_polonius_move_facts(all_facts, move_data, location_table, &body_cache);\n+        populate_polonius_move_facts(all_facts, move_data, location_table, &body);\n     }\n \n     // Create the region inference context, taking ownership of the\n@@ -231,7 +231,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         &mut liveness_constraints,\n         &mut all_facts,\n         location_table,\n-        &body_cache,\n+        &body,\n         borrow_set,\n     );\n \n@@ -254,7 +254,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         param_env,\n         &mut all_facts,\n         location_table,\n-        body_cache,\n+        body,\n         borrow_set,\n     );\n \n@@ -284,14 +284,14 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n     // Solve the region constraints.\n     let closure_region_requirements =\n-        regioncx.solve(infcx, &body_cache, local_names, upvars, def_id, errors_buffer);\n+        regioncx.solve(infcx, &body, local_names, upvars, def_id, errors_buffer);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n     dump_mir_results(\n         infcx,\n         MirSource::item(def_id),\n-        &body_cache,\n+        &body,\n         &regioncx,\n         &closure_region_requirements,\n     );\n@@ -300,7 +300,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     // information\n     dump_annotation(\n         infcx,\n-        &body_cache,\n+        &body,\n         def_id,\n         &regioncx,\n         &closure_region_requirements,"}, {"sha": "b4414c514c5325d81d6e22af4f3a0cc24bb51e0b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -92,7 +92,7 @@ impl RegionValueElements {\n     /// Pushes all predecessors of `index` onto `stack`.\n     crate fn push_predecessors(\n         &self,\n-        body_cache: ReadOnlyBodyCache<'_, '_>,\n+        body: ReadOnlyBodyCache<'_, '_>,\n         index: PointIndex,\n         stack: &mut Vec<PointIndex>,\n     ) {\n@@ -104,9 +104,9 @@ impl RegionValueElements {\n             // If this is a basic block head, then the predecessors are\n             // the terminators of other basic blocks\n             stack.extend(\n-                body_cache.predecessors_for(block)\n+                body.predecessors_for(block)\n                     .iter()\n-                    .map(|&pred_bb| body_cache.terminator_loc(pred_bb))\n+                    .map(|&pred_bb| body.terminator_loc(pred_bb))\n                     .map(|pred_loc| self.point_from_location(pred_loc)),\n             );\n         } else {"}, {"sha": "db15d2c54fdbcf94bca0a26846853e2ec5c5b298", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -9,19 +9,19 @@ use rustc_index::vec::IndexVec;\n /// inference variables, returning the number of variables created.\n pub fn renumber_mir<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n-    body_cache: &mut BodyCache<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     promoted: &mut IndexVec<Promoted, BodyCache<'tcx>>,\n ) {\n     debug!(\"renumber_mir()\");\n-    debug!(\"renumber_mir: body.arg_count={:?}\", body_cache.arg_count);\n+    debug!(\"renumber_mir: body.arg_count={:?}\", body.arg_count);\n \n     let mut visitor = NLLVisitor { infcx };\n \n     for body in promoted.iter_mut() {\n         visitor.visit_body(body);\n     }\n \n-    visitor.visit_body(body_cache);\n+    visitor.visit_body(body);\n }\n \n /// Replaces all regions appearing in `value` with fresh inference"}, {"sha": "d6aa31449daa72d7c68f9ce57311807753b7bd6c", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -60,9 +60,9 @@ impl LocalUseMap {\n     crate fn build(\n         live_locals: &Vec<Local>,\n         elements: &RegionValueElements,\n-        body_cache: ReadOnlyBodyCache<'_, '_>,\n+        body: ReadOnlyBodyCache<'_, '_>,\n     ) -> Self {\n-        let nones = IndexVec::from_elem_n(None, body_cache.local_decls.len());\n+        let nones = IndexVec::from_elem_n(None, body.local_decls.len());\n         let mut local_use_map = LocalUseMap {\n             first_def_at: nones.clone(),\n             first_use_at: nones.clone(),\n@@ -75,11 +75,11 @@ impl LocalUseMap {\n         }\n \n         let mut locals_with_use_data: IndexVec<Local, bool> =\n-            IndexVec::from_elem_n(false, body_cache.local_decls.len());\n+            IndexVec::from_elem_n(false, body.local_decls.len());\n         live_locals.iter().for_each(|&local| locals_with_use_data[local] = true);\n \n         LocalUseMapBuild { local_use_map: &mut local_use_map, elements, locals_with_use_data }\n-            .visit_body(body_cache);\n+            .visit_body(body);\n \n         local_use_map\n     }"}, {"sha": "dfd505f6b613a72d00ab16907add8a8f39c79ca3", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -28,7 +28,7 @@ mod trace;\n /// performed before\n pub(super) fn generate<'tcx>(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n-    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n@@ -41,14 +41,14 @@ pub(super) fn generate<'tcx>(\n         &typeck.borrowck_context.universal_regions,\n         &typeck.borrowck_context.constraints.outlives_constraints,\n     );\n-    let live_locals = compute_live_locals(typeck.tcx(), &free_regions, &body_cache);\n+    let live_locals = compute_live_locals(typeck.tcx(), &free_regions, &body);\n     let facts_enabled = AllFacts::enabled(typeck.tcx());\n \n     let polonius_drop_used = if facts_enabled {\n         let mut drop_used = Vec::new();\n         polonius::populate_access_facts(\n             typeck,\n-            body_cache,\n+            body,\n             location_table,\n             move_data,\n             &mut drop_used,\n@@ -61,7 +61,7 @@ pub(super) fn generate<'tcx>(\n     if !live_locals.is_empty() || facts_enabled {\n         trace::trace(\n             typeck,\n-            body_cache,\n+            body,\n             elements,\n             flow_inits,\n             move_data,"}, {"sha": "e67de6c99f026b400621bf92332e32756ed59ca6", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/polonius.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -97,7 +97,7 @@ fn add_var_uses_regions(typeck: &mut TypeChecker<'_, 'tcx>, local: Local, ty: Ty\n \n pub(super) fn populate_access_facts(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n-    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     location_table: &LocationTable,\n     move_data: &MoveData<'_>,\n     drop_used: &mut Vec<(Local, Location)>,\n@@ -113,14 +113,14 @@ pub(super) fn populate_access_facts(\n             location_table,\n             move_data,\n         }\n-        .visit_body(body_cache);\n+        .visit_body(body);\n \n         facts.var_drop_used.extend(drop_used.iter().map(|&(local, location)| {\n             (local, location_table.mid_index(location))\n         }));\n     }\n \n-    for (local, local_decl) in body_cache.local_decls.iter_enumerated() {\n+    for (local, local_decl) in body.local_decls.iter_enumerated() {\n         add_var_uses_regions(typeck, local, local_decl.ty);\n     }\n }"}, {"sha": "229cbed64c27225d5bcff0e4810ebd16ed14e4c5", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -32,7 +32,7 @@ use std::rc::Rc;\n /// this respects `#[may_dangle]` annotations).\n pub(super) fn trace(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n-    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n@@ -41,11 +41,11 @@ pub(super) fn trace(\n ) {\n     debug!(\"trace()\");\n \n-    let local_use_map = &LocalUseMap::build(&live_locals, elements, body_cache);\n+    let local_use_map = &LocalUseMap::build(&live_locals, elements, body);\n \n     let cx = LivenessContext {\n         typeck,\n-        body_cache,\n+        body,\n         flow_inits,\n         elements,\n         local_use_map,\n@@ -71,7 +71,7 @@ struct LivenessContext<'me, 'typeck, 'flow, 'tcx> {\n     elements: &'me RegionValueElements,\n \n     /// MIR we are analyzing.\n-    body_cache: ReadOnlyBodyCache<'me, 'tcx>,\n+    body: ReadOnlyBodyCache<'me, 'tcx>,\n \n     /// Mapping to/from the various indices used for initialization tracking.\n     move_data: &'me MoveData<'tcx>,\n@@ -135,7 +135,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n             self.compute_use_live_points_for(local);\n             self.compute_drop_live_points_for(local);\n \n-            let local_ty = self.cx.body_cache.local_decls[local].ty;\n+            let local_ty = self.cx.body.local_decls[local].ty;\n \n             if !self.use_live_at.is_empty() {\n                 self.cx.add_use_live_facts_for(local_ty, &self.use_live_at);\n@@ -165,7 +165,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n \n         for (local, location) in drop_used {\n             if !live_locals.contains(&local) {\n-                let local_ty = self.cx.body_cache.local_decls[local].ty;\n+                let local_ty = self.cx.body.local_decls[local].ty;\n                 if local_ty.has_free_regions() {\n                     self.cx.add_drop_live_facts_for(\n                         local,\n@@ -211,7 +211,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n             }\n \n             if self.use_live_at.insert(p) {\n-                self.cx.elements.push_predecessors(self.cx.body_cache, p, &mut self.stack)\n+                self.cx.elements.push_predecessors(self.cx.body, p, &mut self.stack)\n             }\n         }\n     }\n@@ -234,7 +234,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         // Find the drops where `local` is initialized.\n         for drop_point in self.cx.local_use_map.drops(local) {\n             let location = self.cx.elements.to_location(drop_point);\n-            debug_assert_eq!(self.cx.body_cache.terminator_loc(location.block), location,);\n+            debug_assert_eq!(self.cx.body.terminator_loc(location.block), location,);\n \n             if self.cx.initialized_at_terminator(location.block, mpi) {\n                 if self.drop_live_at.insert(drop_point) {\n@@ -280,7 +280,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         // block.  One of them may be either a definition or use\n         // live point.\n         let term_location = self.cx.elements.to_location(term_point);\n-        debug_assert_eq!(self.cx.body_cache.terminator_loc(term_location.block), term_location,);\n+        debug_assert_eq!(self.cx.body.terminator_loc(term_location.block), term_location,);\n         let block = term_location.block;\n         let entry_point = self.cx.elements.entry_point(term_location.block);\n         for p in (entry_point..term_point).rev() {\n@@ -302,8 +302,8 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n             }\n         }\n \n-        let body_cache = self.cx.body_cache;\n-        for &pred_block in body_cache.predecessors_for(block).iter() {\n+        let body = self.cx.body;\n+        for &pred_block in body.predecessors_for(block).iter() {\n             debug!(\"compute_drop_live_points_for_block: pred_block = {:?}\", pred_block,);\n \n             // Check whether the variable is (at least partially)\n@@ -329,7 +329,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n                 continue;\n             }\n \n-            let pred_term_loc = self.cx.body_cache.terminator_loc(pred_block);\n+            let pred_term_loc = self.cx.body.terminator_loc(pred_block);\n             let pred_term_point = self.cx.elements.point_from_location(pred_term_loc);\n \n             // If the terminator of this predecessor either *assigns*\n@@ -400,7 +400,7 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n         // the effects of all statements. This is the only way to get\n         // \"just ahead\" of a terminator.\n         self.flow_inits.reset_to_entry_of(block);\n-        for statement_index in 0..self.body_cache[block].statements.len() {\n+        for statement_index in 0..self.body[block].statements.len() {\n             let location = Location { block, statement_index };\n             self.flow_inits.reconstruct_statement_effect(location);\n             self.flow_inits.apply_local_effect(location);\n@@ -472,7 +472,7 @@ impl LivenessContext<'_, '_, '_, 'tcx> {\n \n         drop_data.dropck_result.report_overflows(\n             self.typeck.infcx.tcx,\n-            self.body_cache.source_info(*drop_locations.first().unwrap()).span,\n+            self.body.source_info(*drop_locations.first().unwrap()).span,\n             dropped_ty,\n         );\n "}, {"sha": "5a8fd3f707d6dbb6fcc6858bfbab1010afe1cdef", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -115,8 +115,8 @@ mod relate_tys;\n pub(crate) fn type_check<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n-    promoted_cache: &IndexVec<Promoted, ReadOnlyBodyCache<'_, 'tcx>>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n+    promoted: &IndexVec<Promoted, ReadOnlyBodyCache<'_, 'tcx>>,\n     mir_def_id: DefId,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n     location_table: &LocationTable,\n@@ -161,20 +161,20 @@ pub(crate) fn type_check<'tcx>(\n         infcx,\n         mir_def_id,\n         param_env,\n-        body_cache,\n-        promoted_cache,\n+        body,\n+        promoted,\n         &region_bound_pairs,\n         implicit_region_bound,\n         &mut borrowck_context,\n         &universal_region_relations,\n         |mut cx| {\n             cx.equate_inputs_and_outputs(\n-                &body_cache,\n+                &body,\n                 universal_regions,\n                 &normalized_inputs_and_output);\n             liveness::generate(\n                 &mut cx,\n-                body_cache,\n+                body,\n                 elements,\n                 flow_inits,\n                 move_data,\n@@ -194,8 +194,8 @@ fn type_check_internal<'a, 'tcx, R>(\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_cache: ReadOnlyBodyCache<'a, 'tcx>,\n-    promoted_cache: &'a IndexVec<Promoted, ReadOnlyBodyCache<'_, 'tcx>>,\n+    body: ReadOnlyBodyCache<'a, 'tcx>,\n+    promoted: &'a IndexVec<Promoted, ReadOnlyBodyCache<'_, 'tcx>>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n@@ -204,7 +204,7 @@ fn type_check_internal<'a, 'tcx, R>(\n ) -> R {\n     let mut checker = TypeChecker::new(\n         infcx,\n-        body_cache.body(),\n+        body.body(),\n         mir_def_id,\n         param_env,\n         region_bound_pairs,\n@@ -213,14 +213,14 @@ fn type_check_internal<'a, 'tcx, R>(\n         universal_region_relations,\n     );\n     let errors_reported = {\n-        let mut verifier = TypeVerifier::new(&mut checker, body_cache.body(), promoted_cache);\n-        verifier.visit_body(body_cache);\n+        let mut verifier = TypeVerifier::new(&mut checker, body.body(), promoted);\n+        verifier.visit_body(body);\n         verifier.errors_reported\n     };\n \n     if !errors_reported {\n         // if verifier failed, don't do further checks to avoid ICEs\n-        checker.typeck_mir(&body_cache);\n+        checker.typeck_mir(&body);\n     }\n \n     extra(&mut checker)\n@@ -270,7 +270,7 @@ enum FieldAccessError {\n struct TypeVerifier<'a, 'b, 'tcx> {\n     cx: &'a mut TypeChecker<'b, 'tcx>,\n     body: &'b Body<'tcx>,\n-    promoted_cache: &'b IndexVec<Promoted, ReadOnlyBodyCache<'b, 'tcx>>,\n+    promoted: &'b IndexVec<Promoted, ReadOnlyBodyCache<'b, 'tcx>>,\n     last_span: Span,\n     mir_def_id: DefId,\n     errors_reported: bool,\n@@ -394,27 +394,27 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn visit_body(&mut self, body_cache: ReadOnlyBodyCache<'_, 'tcx>) {\n-        self.sanitize_type(&\"return type\", body_cache.return_ty());\n-        for local_decl in &body_cache.local_decls {\n+    fn visit_body(&mut self, body: ReadOnlyBodyCache<'_, 'tcx>) {\n+        self.sanitize_type(&\"return type\", body.return_ty());\n+        for local_decl in &body.local_decls {\n             self.sanitize_type(local_decl, local_decl.ty);\n         }\n         if self.errors_reported {\n             return;\n         }\n-        self.super_body(body_cache);\n+        self.super_body(body);\n     }\n }\n \n impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     fn new(\n         cx: &'a mut TypeChecker<'b, 'tcx>,\n         body: &'b Body<'tcx>,\n-        promoted_cache: &'b IndexVec<Promoted, ReadOnlyBodyCache<'b, 'tcx>>,\n+        promoted: &'b IndexVec<Promoted, ReadOnlyBodyCache<'b, 'tcx>>,\n     ) -> Self {\n         TypeVerifier {\n             body,\n-            promoted_cache,\n+            promoted,\n             mir_def_id: cx.mir_def_id,\n             cx,\n             last_span: body.span,\n@@ -473,7 +473,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 match kind {\n                     StaticKind::Promoted(promoted, _) => {\n                         if !self.errors_reported {\n-                            let promoted_body_cache = self.promoted_cache[*promoted];\n+                            let promoted_body_cache = self.promoted[*promoted];\n                             self.sanitize_promoted(promoted_body_cache, location);\n \n                             let promoted_ty = promoted_body_cache.return_ty();\n@@ -546,22 +546,22 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n     fn sanitize_promoted(\n         &mut self,\n-        promoted_body_cache: ReadOnlyBodyCache<'b, 'tcx>,\n+        promoted_body: ReadOnlyBodyCache<'b, 'tcx>,\n         location: Location\n     ) {\n         // Determine the constraints from the promoted MIR by running the type\n         // checker on the promoted MIR, then transfer the constraints back to\n         // the main MIR, changing the locations to the provided location.\n \n-        let parent_body = mem::replace(&mut self.body, promoted_body_cache.body());\n+        let parent_body = mem::replace(&mut self.body, promoted_body.body());\n \n         // Use new sets of constraints and closure bounds so that we can\n         // modify their locations.\n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n         let mut closure_bounds = Default::default();\n         let mut liveness_constraints = LivenessValues::new(\n-            Rc::new(RegionValueElements::new(&promoted_body_cache)),\n+            Rc::new(RegionValueElements::new(&promoted_body)),\n         );\n         // Don't try to add borrow_region facts for the promoted MIR\n \n@@ -583,12 +583,12 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         swap_constraints(self);\n \n-        self.visit_body(promoted_body_cache);\n+        self.visit_body(promoted_body);\n \n \n         if !self.errors_reported {\n             // if verifier failed, don't do further checks to avoid ICEs\n-            self.cx.typeck_mir(&promoted_body_cache);\n+            self.cx.typeck_mir(&promoted_body);\n         }\n \n         self.body = parent_body;"}, {"sha": "06b9d4dbde00345f499b3632b1efe33bb8e09faa", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -26,7 +26,7 @@ impl<'cx, 'tcx> IsPrefixOf<'cx, 'tcx> for PlaceRef<'cx, 'tcx> {\n }\n \n pub(super) struct Prefixes<'cx, 'tcx> {\n-    body_cache: ReadOnlyBodyCache<'cx, 'tcx>,\n+    body: ReadOnlyBodyCache<'cx, 'tcx>,\n     tcx: TyCtxt<'tcx>,\n     kind: PrefixSet,\n     next: Option<PlaceRef<'cx, 'tcx>>,\n@@ -56,7 +56,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         Prefixes {\n             next: Some(place_ref),\n             kind,\n-            body_cache: self.body_cache,\n+            body: self.body,\n             tcx: self.infcx.tcx,\n         }\n     }\n@@ -143,7 +143,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     // derefs, except we stop at the deref of a shared\n                     // reference.\n \n-                    let ty = Place::ty_from(cursor.base, proj_base, &self.body_cache, self.tcx).ty;\n+                    let ty = Place::ty_from(cursor.base, proj_base, &*self.body, self.tcx).ty;\n                     match ty.kind {\n                         ty::RawPtr(_) |\n                         ty::Ref("}, {"sha": "95471afb7884f74d06c8cb67450b01b5b22086ba", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -32,7 +32,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 never_initialized_mut_locals: &mut never_initialized_mut_locals,\n                 mbcx: self,\n             };\n-            visitor.visit_body(visitor.mbcx.body_cache);\n+            visitor.visit_body(visitor.mbcx.body);\n         }\n \n         // Take the union of the existed `used_mut` set with those variables we've found were"}, {"sha": "2a4f1c89b3a1f70add9fddcdfe7bdc97f1599f74", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -354,7 +354,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         }\n         // This is a const fn. Call it.\n         Ok(Some(match ecx.load_mir(instance.def, None) {\n-            Ok(body_cache) => body_cache.body(),\n+            Ok(body) => body.body(),\n             Err(err) => {\n                 if let err_unsup!(NoMirFor(ref path)) = err.kind {\n                     return Err(\n@@ -697,7 +697,7 @@ pub fn const_eval_raw_provider<'tcx>(\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n     res.and_then(\n-        |body_cache| eval_body_using_ecx(&mut ecx, cid, body_cache.body())\n+        |body| eval_body_using_ecx(&mut ecx, cid, body.body())\n     ).and_then(|place| {\n         Ok(RawConst {\n             alloc_id: place.ptr.assert_ptr().alloc_id,"}, {"sha": "7e7652cdab5ce099f8ca03781bbff250da481b58", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -153,8 +153,8 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         }\n \n         Borrows {\n-            tcx: tcx,\n-            body: body,\n+            tcx,\n+            body,\n             param_env,\n             borrow_set: borrow_set.clone(),\n             borrows_out_of_scope_at_location,"}, {"sha": "0fb912b5fcbd8f5a9323575ed7034a6a8647502e", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -71,7 +71,7 @@ pub struct MaybeInitializedPlaces<'a, 'tcx> {\n \n impl<'a, 'tcx> MaybeInitializedPlaces<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n-        MaybeInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n+        MaybeInitializedPlaces { tcx, body, mdpe }\n     }\n }\n \n@@ -122,7 +122,7 @@ pub struct MaybeUninitializedPlaces<'a, 'tcx> {\n \n impl<'a, 'tcx> MaybeUninitializedPlaces<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n-        MaybeUninitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n+        MaybeUninitializedPlaces { tcx, body, mdpe }\n     }\n }\n \n@@ -172,7 +172,7 @@ pub struct DefinitelyInitializedPlaces<'a, 'tcx> {\n \n impl<'a, 'tcx> DefinitelyInitializedPlaces<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n-        DefinitelyInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n+        DefinitelyInitializedPlaces { tcx, body, mdpe }\n     }\n }\n \n@@ -217,7 +217,7 @@ pub struct EverInitializedPlaces<'a, 'tcx> {\n \n impl<'a, 'tcx> EverInitializedPlaces<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, mdpe: &'a MoveDataParamEnv<'tcx>) -> Self {\n-        EverInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n+        EverInitializedPlaces { tcx, body, mdpe }\n     }\n }\n "}, {"sha": "c4b97d12e6270730b17183f051026104bd4b07cf", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -75,48 +75,48 @@ impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n /// Dataflow analysis that determines whether each local requires storage at a\n /// given location; i.e. whether its storage can go away without being observed.\n pub struct RequiresStorage<'mir, 'tcx> {\n-    body_cache: ReadOnlyBodyCache<'mir, 'tcx>,\n+    body: ReadOnlyBodyCache<'mir, 'tcx>,\n     borrowed_locals:\n         RefCell<DataflowResultsRefCursor<'mir, 'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>>,\n }\n \n impl<'mir, 'tcx: 'mir> RequiresStorage<'mir, 'tcx> {\n     pub fn new(\n-        body_cache: ReadOnlyBodyCache<'mir, 'tcx>,\n+        body: ReadOnlyBodyCache<'mir, 'tcx>,\n         borrowed_locals: &'mir DataflowResults<'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>,\n     ) -> Self {\n         RequiresStorage {\n-            body_cache,\n+            body,\n             borrowed_locals: RefCell::new(\n-                DataflowResultsCursor::new(borrowed_locals, body_cache.body())\n+                DataflowResultsCursor::new(borrowed_locals, body.body())\n             ),\n         }\n     }\n \n     pub fn body(&self) -> &Body<'tcx> {\n-        &self.body_cache\n+        &self.body\n     }\n }\n \n impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n     type Idx = Local;\n     fn name() -> &'static str { \"requires_storage\" }\n     fn bits_per_block(&self) -> usize {\n-        self.body_cache.local_decls.len()\n+        self.body.local_decls.len()\n     }\n \n     fn start_block_effect(&self, _sets: &mut BitSet<Local>) {\n         // Nothing is live on function entry (generators only have a self\n         // argument, and we don't care about that)\n-        assert_eq!(1, self.body_cache.arg_count);\n+        assert_eq!(1, self.body.arg_count);\n     }\n \n     fn before_statement_effect(&self, sets: &mut GenKillSet<Self::Idx>, loc: Location) {\n         // If we borrow or assign to a place then it needs storage for that\n         // statement.\n         self.check_for_borrow(sets, loc);\n \n-        let stmt = &self.body_cache[loc.block].statements[loc.statement_index];\n+        let stmt = &self.body[loc.block].statements[loc.statement_index];\n         match stmt.kind {\n             StatementKind::StorageDead(l) => sets.kill(l),\n             StatementKind::Assign(box(ref place, _))\n@@ -148,7 +148,7 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         if let TerminatorKind::Call {\n             destination: Some((Place { base: PlaceBase::Local(local), .. }, _)),\n             ..\n-        } = self.body_cache[loc.block].terminator().kind {\n+        } = self.body[loc.block].terminator().kind {\n             sets.gen(local);\n         }\n     }\n@@ -161,7 +161,7 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         if let TerminatorKind::Call {\n             destination: Some((ref place, _)),\n             ..\n-        } = self.body_cache[loc.block].terminator().kind {\n+        } = self.body[loc.block].terminator().kind {\n             if let Some(local) = place.as_local() {\n                 sets.kill(local);\n             }\n@@ -189,7 +189,7 @@ impl<'mir, 'tcx> RequiresStorage<'mir, 'tcx> {\n             sets,\n             borrowed_locals: &self.borrowed_locals,\n         };\n-        visitor.visit_location(self.body_cache, loc);\n+        visitor.visit_location(self.body, loc);\n     }\n \n     /// Gen locals that are newly borrowed. This includes borrowing any part of"}, {"sha": "4fe53cf35e5113b957cf2f952c7faf9a1678c13a", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -1248,14 +1248,14 @@ fn collect_neighbours<'tcx>(\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n     debug!(\"collect_neighbours: {:?}\", instance.def_id());\n-    let body_cache = tcx.instance_mir(instance.def);\n+    let body = tcx.instance_mir(instance.def);\n \n     MirNeighborCollector {\n         tcx,\n-        body: &body_cache,\n+        body: &body,\n         output,\n         param_substs: instance.substs,\n-    }.visit_body(body_cache);\n+    }.visit_body(body);\n }\n \n fn def_id_to_string(tcx: TyCtxt<'_>, def_id: DefId) -> String {"}, {"sha": "0636d254c2f398340db28272244e0e83860a2aa0", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -205,23 +205,23 @@ fn build_drop_shim<'tcx>(\n         sig.inputs().len(),\n         span);\n \n-    let mut body_cache = BodyCache::new(body);\n+    let mut body = BodyCache::new(body);\n \n     if let Some(..) = ty {\n         // The first argument (index 0), but add 1 for the return value.\n         let dropee_ptr = Place::from(Local::new(1+0));\n         if tcx.sess.opts.debugging_opts.mir_emit_retag {\n             // Function arguments should be retagged, and we make this one raw.\n-            body_cache.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n+            body.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n                 source_info,\n                 kind: StatementKind::Retag(RetagKind::Raw, box(dropee_ptr.clone())),\n             });\n         }\n         let patch = {\n             let param_env = tcx.param_env(def_id).with_reveal_all();\n             let mut elaborator = DropShimElaborator {\n-                body: &body_cache,\n-                patch: MirPatch::new(&body_cache),\n+                body: &body,\n+                patch: MirPatch::new(&body),\n                 tcx,\n                 param_env\n             };\n@@ -238,10 +238,10 @@ fn build_drop_shim<'tcx>(\n             );\n             elaborator.patch\n         };\n-        patch.apply(&mut body_cache);\n+        patch.apply(&mut body);\n     }\n \n-    body_cache\n+    body\n }\n \n fn new_body<'tcx>(\n@@ -931,7 +931,7 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &BodyCache<'_> {\n         |_, _| Ok(()),\n     );\n \n-    let mut body_cache = BodyCache::new(body);\n-    body_cache.ensure_predecessors();\n-    tcx.arena.alloc(body_cache)\n+    let mut body = BodyCache::new(body);\n+    body.ensure_predecessors();\n+    tcx.arena.alloc(body)\n }"}, {"sha": "35238e2d08a2e4a2547d4a2026bc4409738d05d3", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -32,23 +32,22 @@ pub use self::AddCallGuards::*;\n \n impl<'tcx> MirPass<'tcx> for AddCallGuards {\n     fn run_pass(\n-        &self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>\n+        &self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n     ) {\n-        self.add_call_guards(body_cache);\n+        self.add_call_guards(body);\n     }\n }\n \n impl AddCallGuards {\n-    pub fn add_call_guards(&self, body_cache: &mut BodyCache<'_>) {\n-        let pred_count: IndexVec<_, _> =\n-            body_cache.predecessors().iter().map(|ps| ps.len()).collect();\n+    pub fn add_call_guards(&self, body: &mut BodyCache<'_>) {\n+        let pred_count: IndexVec<_, _> = body.predecessors().iter().map(|ps| ps.len()).collect();\n \n         // We need a place to store the new blocks generated\n         let mut new_blocks = Vec::new();\n \n-        let cur_len = body_cache.basic_blocks().len();\n+        let cur_len = body.basic_blocks().len();\n \n-        for block in body_cache.basic_blocks_mut() {\n+        for block in body.basic_blocks_mut() {\n             match block.terminator {\n                 Some(Terminator {\n                     kind: TerminatorKind::Call {\n@@ -80,6 +79,6 @@ impl AddCallGuards {\n \n         debug!(\"Broke {} N edges\", new_blocks.len());\n \n-        body_cache.basic_blocks_mut().extend(new_blocks);\n+        body.basic_blocks_mut().extend(new_blocks);\n     }\n }"}, {"sha": "98c6a5ed07780d0d27de277b16ed54757ec43078", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -40,17 +40,17 @@ use crate::util;\n pub struct AddMovesForPackedDrops;\n \n impl<'tcx> MirPass<'tcx> for AddMovesForPackedDrops {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n-        debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, body_cache.span);\n-        add_moves_for_packed_drops(tcx, body_cache, src.def_id());\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n+        debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, body.span);\n+        add_moves_for_packed_drops(tcx, body, src.def_id());\n     }\n }\n \n pub fn add_moves_for_packed_drops<'tcx>(\n-    tcx: TyCtxt<'tcx>, body_cache: &mut BodyCache<'tcx>, def_id: DefId\n+    tcx: TyCtxt<'tcx>, body: &mut BodyCache<'tcx>, def_id: DefId\n ) {\n-    let patch = add_moves_for_packed_drops_patch(tcx, body_cache, def_id);\n-    patch.apply(body_cache);\n+    let patch = add_moves_for_packed_drops_patch(tcx, body, def_id);\n+    patch.apply(body);\n }\n \n fn add_moves_for_packed_drops_patch<'tcx>("}, {"sha": "e6ad37ae11362481903beec44a2d16385ca97d9f", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -59,12 +59,12 @@ fn may_be_reference<'tcx>(ty: Ty<'tcx>) -> bool {\n }\n \n impl<'tcx> MirPass<'tcx> for AddRetag {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         if !tcx.sess.opts.debugging_opts.mir_emit_retag {\n             return;\n         }\n-        let (span, arg_count) = (body_cache.span, body_cache.arg_count);\n-        let (basic_blocks, local_decls) = body_cache.basic_blocks_and_local_decls_mut();\n+        let (span, arg_count) = (body.span, body.arg_count);\n+        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         let needs_retag = |place: &Place<'tcx>| {\n             // FIXME: Instead of giving up for unstable places, we should introduce\n             // a temporary and retag on that."}, {"sha": "85932bc5e5bc17ab6d3aa085982a57a94a3f7acc", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -516,7 +516,7 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n \n     // N.B., this borrow is valid because all the consumers of\n     // `mir_built` force this.\n-    let body_cache = &tcx.mir_built(def_id).borrow();\n+    let body = &tcx.mir_built(def_id).borrow();\n \n     let param_env = tcx.param_env(def_id);\n \n@@ -527,9 +527,9 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n         hir::BodyOwnerKind::Const |\n         hir::BodyOwnerKind::Static(_) => (true, false),\n     };\n-    let mut checker = UnsafetyChecker::new(const_context, min_const_fn, body_cache, tcx, param_env);\n-    let mut cache = body_cache.cache().clone();\n-    let read_only_cache = ReadOnlyBodyCache::from_external_cache(&mut cache, body_cache);\n+    let mut checker = UnsafetyChecker::new(const_context, min_const_fn, body, tcx, param_env);\n+    let mut cache = body.cache().clone();\n+    let read_only_cache = ReadOnlyBodyCache::from_external_cache(&mut cache, body);\n     checker.visit_body(read_only_cache);\n \n     check_unused_unsafe(tcx, def_id, &checker.used_unsafe, &mut checker.inherited_blocks);"}, {"sha": "d9dd7c9d847760f634b6209895d6452302b0b864", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -30,10 +30,10 @@ pub struct DeleteNonCodegenStatements<'tcx> {\n \n impl<'tcx> MirPass<'tcx> for CleanupNonCodegenStatements {\n     fn run_pass(\n-        &self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>\n+        &self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n     ) {\n         let mut delete = DeleteNonCodegenStatements { tcx };\n-        delete.visit_body(body_cache);\n+        delete.visit_body(body);\n     }\n }\n "}, {"sha": "7c1318da7b01da7d81b4f162d258c92e7381ea6b", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -43,7 +43,7 @@ pub struct ConstProp;\n \n impl<'tcx> MirPass<'tcx> for ConstProp {\n     fn run_pass(\n-        &self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>\n+        &self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n     ) {\n         // will be evaluated by miri and produce its errors there\n         if source.promoted.is_some() {\n@@ -79,28 +79,28 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n \n         let dummy_body =\n             &Body::new(\n-                body_cache.basic_blocks().clone(),\n-                body_cache.source_scopes.clone(),\n-                body_cache.local_decls.clone(),\n+                body.basic_blocks().clone(),\n+                body.source_scopes.clone(),\n+                body.local_decls.clone(),\n                 Default::default(),\n-                body_cache.arg_count,\n+                body.arg_count,\n                 Default::default(),\n                 tcx.def_span(source.def_id()),\n                 Default::default(),\n-                body_cache.generator_kind,\n+                body.generator_kind,\n             );\n \n         // FIXME(oli-obk, eddyb) Optimize locals (or even local paths) to hold\n         // constants, instead of just checking for const-folding succeeding.\n         // That would require an uniform one-def no-mutation analysis\n         // and RPO (or recursing when needing the value of a local).\n         let mut optimization_finder = ConstPropagator::new(\n-            read_only!(body_cache),\n+            read_only!(body),\n             dummy_body,\n             tcx,\n             source\n         );\n-        optimization_finder.visit_body(body_cache);\n+        optimization_finder.visit_body(body);\n \n         trace!(\"ConstProp done for {:?}\", source.def_id());\n     }\n@@ -287,7 +287,7 @@ impl<'mir, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'mir, 'tcx> {\n \n impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn new(\n-        body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n+        body: ReadOnlyBodyCache<'_, 'tcx>,\n         dummy_body: &'mir Body<'tcx>,\n         tcx: TyCtxt<'tcx>,\n         source: MirSource<'tcx>,\n@@ -296,7 +296,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env(def_id);\n         let span = tcx.def_span(def_id);\n         let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine, ());\n-        let can_const_prop = CanConstProp::check(body_cache);\n+        let can_const_prop = CanConstProp::check(body);\n \n         let substs = &InternalSubsts::identity_for_item(tcx, def_id);\n \n@@ -328,9 +328,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             can_const_prop,\n             // FIXME(eddyb) avoid cloning these two fields more than once,\n             // by accessing them through `ecx` instead.\n-            source_scopes: body_cache.source_scopes.clone(),\n+            source_scopes: body.source_scopes.clone(),\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n-            local_decls: body_cache.local_decls.clone(),\n+            local_decls: body.local_decls.clone(),\n             ret: ret.map(Into::into),\n         }\n     }\n@@ -681,25 +681,25 @@ struct CanConstProp {\n \n impl CanConstProp {\n     /// returns true if `local` can be propagated\n-    fn check(body_cache: ReadOnlyBodyCache<'_, '_>) -> IndexVec<Local, bool> {\n+    fn check(body: ReadOnlyBodyCache<'_, '_>) -> IndexVec<Local, bool> {\n         let mut cpv = CanConstProp {\n-            can_const_prop: IndexVec::from_elem(true, &body_cache.local_decls),\n-            found_assignment: IndexVec::from_elem(false, &body_cache.local_decls),\n+            can_const_prop: IndexVec::from_elem(true, &body.local_decls),\n+            found_assignment: IndexVec::from_elem(false, &body.local_decls),\n         };\n         for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n             // cannot use args at all\n             // cannot use locals because if x < y { y - x } else { x - y } would\n             //        lint for x != y\n             // FIXME(oli-obk): lint variables until they are used in a condition\n             // FIXME(oli-obk): lint if return value is constant\n-            let local_kind = body_cache.local_kind(local);\n+            let local_kind = body.local_kind(local);\n             *val = local_kind == LocalKind::Temp || local_kind == LocalKind::ReturnPointer;\n \n             if !*val {\n                 trace!(\"local {:?} can't be propagated because it's not a temporary\", local);\n             }\n         }\n-        cpv.visit_body(body_cache);\n+        cpv.visit_body(body);\n         cpv.can_const_prop\n     }\n }"}, {"sha": "5e4caf2f36d2d6de17dc99d38d2ebef4b8ea8eb3", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -32,24 +32,24 @@ pub struct CopyPropagation;\n \n impl<'tcx> MirPass<'tcx> for CopyPropagation {\n     fn run_pass(\n-        &self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>\n+        &self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n     ) {\n         // We only run when the MIR optimization level is > 1.\n         // This avoids a slow pass, and messing up debug info.\n         if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {\n             return;\n         }\n \n-        let mut def_use_analysis = DefUseAnalysis::new(body_cache);\n+        let mut def_use_analysis = DefUseAnalysis::new(body);\n         loop {\n-            def_use_analysis.analyze(read_only!(body_cache));\n+            def_use_analysis.analyze(read_only!(body));\n \n-            if eliminate_self_assignments(body_cache, &def_use_analysis) {\n-                def_use_analysis.analyze(read_only!(body_cache));\n+            if eliminate_self_assignments(body, &def_use_analysis) {\n+                def_use_analysis.analyze(read_only!(body));\n             }\n \n             let mut changed = false;\n-            for dest_local in body_cache.local_decls.indices() {\n+            for dest_local in body.local_decls.indices() {\n                 debug!(\"considering destination local: {:?}\", dest_local);\n \n                 let action;\n@@ -76,15 +76,15 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                     }\n                     // Conservatively gives up if the dest is an argument,\n                     // because there may be uses of the original argument value.\n-                    if body_cache.local_kind(dest_local) == LocalKind::Arg {\n+                    if body.local_kind(dest_local) == LocalKind::Arg {\n                         debug!(\"  Can't copy-propagate local: dest {:?} (argument)\",\n                             dest_local);\n                         continue;\n                     }\n                     let dest_place_def = dest_use_info.defs_not_including_drop().next().unwrap();\n                     location = dest_place_def.location;\n \n-                    let basic_block = &body_cache[location.block];\n+                    let basic_block = &body[location.block];\n                     let statement_index = location.statement_index;\n                     let statement = match basic_block.statements.get(statement_index) {\n                         Some(statement) => statement,\n@@ -103,7 +103,7 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                                         Operand::Copy(ref src_place) |\n                                         Operand::Move(ref src_place) => {\n                                             Action::local_copy(\n-                                                &body_cache,\n+                                                &body,\n                                                 &def_use_analysis,\n                                                 src_place)\n                                         }\n@@ -134,7 +134,7 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                     }\n                 }\n \n-                changed = action.perform(body_cache, &def_use_analysis, dest_local, location, tcx)\n+                changed = action.perform(body, &def_use_analysis, dest_local, location, tcx)\n                     || changed;\n                 // FIXME(pcwalton): Update the use-def chains to delete the instructions instead of\n                 // regenerating the chains.\n@@ -250,7 +250,7 @@ impl<'tcx> Action<'tcx> {\n     }\n \n     fn perform(self,\n-               body_cache: &mut BodyCache<'tcx>,\n+               body: &mut BodyCache<'tcx>,\n                def_use_analysis: &DefUseAnalysis,\n                dest_local: Local,\n                location: Location,\n@@ -268,22 +268,22 @@ impl<'tcx> Action<'tcx> {\n                        src_local);\n                 for place_use in &def_use_analysis.local_info(dest_local).defs_and_uses {\n                     if place_use.context.is_storage_marker() {\n-                        body_cache.make_statement_nop(place_use.location)\n+                        body.make_statement_nop(place_use.location)\n                     }\n                 }\n                 for place_use in &def_use_analysis.local_info(src_local).defs_and_uses {\n                     if place_use.context.is_storage_marker() {\n-                        body_cache.make_statement_nop(place_use.location)\n+                        body.make_statement_nop(place_use.location)\n                     }\n                 }\n \n                 // Replace all uses of the destination local with the source local.\n                 def_use_analysis\n-                    .replace_all_defs_and_uses_with(dest_local, body_cache, src_local, tcx);\n+                    .replace_all_defs_and_uses_with(dest_local, body, src_local, tcx);\n \n                 // Finally, zap the now-useless assignment instruction.\n                 debug!(\"  Deleting assignment\");\n-                body_cache.make_statement_nop(location);\n+                body.make_statement_nop(location);\n \n                 true\n             }\n@@ -297,7 +297,7 @@ impl<'tcx> Action<'tcx> {\n                 let dest_local_info = def_use_analysis.local_info(dest_local);\n                 for place_use in &dest_local_info.defs_and_uses {\n                     if place_use.context.is_storage_marker() {\n-                        body_cache.make_statement_nop(place_use.location)\n+                        body.make_statement_nop(place_use.location)\n                     }\n                 }\n \n@@ -306,7 +306,7 @@ impl<'tcx> Action<'tcx> {\n                                                                   src_constant,\n                                                                   tcx);\n                 for dest_place_use in &dest_local_info.defs_and_uses {\n-                    visitor.visit_location(body_cache, dest_place_use.location)\n+                    visitor.visit_location(body, dest_place_use.location)\n                 }\n \n                 // Zap the assignment instruction if we eliminated all the uses. We won't have been\n@@ -317,7 +317,7 @@ impl<'tcx> Action<'tcx> {\n                     debug!(\"  {} of {} use(s) replaced; deleting assignment\",\n                            visitor.uses_replaced,\n                            use_count);\n-                    body_cache.make_statement_nop(location);\n+                    body.make_statement_nop(location);\n                     true\n                 } else if visitor.uses_replaced == 0 {\n                     debug!(\"  No uses replaced; not deleting assignment\");"}, {"sha": "933936e7efff73d64f67f415d24b221b23765dfd", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -7,9 +7,9 @@ pub struct Deaggregator;\n \n impl<'tcx> MirPass<'tcx> for Deaggregator {\n     fn run_pass(\n-        &self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>\n+        &self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n     ) {\n-        let (basic_blocks, local_decls) = body_cache.basic_blocks_and_local_decls_mut();\n+        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;\n         for bb in basic_blocks {\n             bb.expand_statements(|stmt| {"}, {"sha": "13b3bb6da4ef99b588748afda3de6a0aa1b0482a", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -19,7 +19,7 @@ impl<'tcx> MirPass<'tcx> for Marker {\n     }\n \n     fn run_pass(\n-        &self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, _body_cache: &mut BodyCache<'tcx>\n+        &self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, _body: &mut BodyCache<'tcx>\n     ) {}\n }\n "}, {"sha": "42daba93bd293059a98fc0d9117fa8642949b631", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -21,17 +21,17 @@ use syntax_pos::Span;\n pub struct ElaborateDrops;\n \n impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n-        debug!(\"elaborate_drops({:?} @ {:?})\", src, body_cache.span);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n+        debug!(\"elaborate_drops({:?} @ {:?})\", src, body.span);\n \n         let def_id = src.def_id();\n         let param_env = tcx.param_env(src.def_id()).with_reveal_all();\n-        let move_data = match MoveData::gather_moves(body_cache, tcx) {\n+        let move_data = match MoveData::gather_moves(body, tcx) {\n             Ok(move_data) => move_data,\n             Err(_) => bug!(\"No `move_errors` should be allowed in MIR borrowck\"),\n         };\n         let elaborate_patch = {\n-            let body = &*body_cache;\n+            let body = &*body;\n             let env = MoveDataParamEnv {\n                 move_data,\n                 param_env,\n@@ -56,7 +56,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n                 patch: MirPatch::new(body),\n             }.elaborate()\n         };\n-        elaborate_patch.apply(body_cache);\n+        elaborate_patch.apply(body);\n     }\n }\n "}, {"sha": "882e67432a5ed4b00c712a3110e25385decf6f78", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -62,7 +62,7 @@ impl MutVisitor<'tcx> for EraseRegionsVisitor<'tcx> {\n pub struct EraseRegions;\n \n impl<'tcx> MirPass<'tcx> for EraseRegions {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n-        EraseRegionsVisitor::new(tcx).visit_body(body_cache);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n+        EraseRegionsVisitor::new(tcx).visit_body(body);\n     }\n }"}, {"sha": "e55737e8859eff230f70e8c8a485fe710214bace", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 113, "deletions": 112, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -378,9 +378,9 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n fn make_generator_state_argument_indirect<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-    body_cache: &mut BodyCache<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n ) {\n-    let gen_ty = body_cache.local_decls.raw[1].ty;\n+    let gen_ty = body.local_decls.raw[1].ty;\n \n     let region = ty::ReFree(ty::FreeRegion {\n         scope: def_id,\n@@ -395,33 +395,33 @@ fn make_generator_state_argument_indirect<'tcx>(\n     });\n \n     // Replace the by value generator argument\n-    body_cache.local_decls.raw[1].ty = ref_gen_ty;\n+    body.local_decls.raw[1].ty = ref_gen_ty;\n \n     // Add a deref to accesses of the generator state\n-    DerefArgVisitor { tcx }.visit_body(body_cache);\n+    DerefArgVisitor { tcx }.visit_body(body);\n }\n \n-fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n-    let ref_gen_ty = body_cache.local_decls.raw[1].ty;\n+fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut BodyCache<'tcx>) {\n+    let ref_gen_ty = body.local_decls.raw[1].ty;\n \n     let pin_did = tcx.lang_items().pin_type().unwrap();\n     let pin_adt_ref = tcx.adt_def(pin_did);\n     let substs = tcx.intern_substs(&[ref_gen_ty.into()]);\n     let pin_ref_gen_ty = tcx.mk_adt(pin_adt_ref, substs);\n \n     // Replace the by ref generator argument\n-    body_cache.local_decls.raw[1].ty = pin_ref_gen_ty;\n+    body.local_decls.raw[1].ty = pin_ref_gen_ty;\n \n     // Add the Pin field access to accesses of the generator state\n-    PinArgVisitor { ref_gen_ty, tcx }.visit_body(body_cache);\n+    PinArgVisitor { ref_gen_ty, tcx }.visit_body(body);\n }\n \n fn replace_result_variable<'tcx>(\n     ret_ty: Ty<'tcx>,\n-    body_cache: &mut BodyCache<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     tcx: TyCtxt<'tcx>,\n ) -> Local {\n-    let source_info = source_info(body_cache);\n+    let source_info = source_info(body);\n     let new_ret = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: ret_ty,\n@@ -431,15 +431,15 @@ fn replace_result_variable<'tcx>(\n         is_block_tail: None,\n         local_info: LocalInfo::Other\n     };\n-    let new_ret_local = Local::new(body_cache.local_decls.len());\n-    body_cache.local_decls.push(new_ret);\n-    body_cache.local_decls.swap(RETURN_PLACE, new_ret_local);\n+    let new_ret_local = Local::new(body.local_decls.len());\n+    body.local_decls.push(new_ret);\n+    body.local_decls.swap(RETURN_PLACE, new_ret_local);\n \n     RenameLocalVisitor {\n         from: RETURN_PLACE,\n         to: new_ret_local,\n         tcx,\n-    }.visit_body(body_cache);\n+    }.visit_body(body);\n \n     new_ret_local\n }\n@@ -481,60 +481,61 @@ struct LivenessInfo {\n \n fn locals_live_across_suspend_points(\n     tcx: TyCtxt<'tcx>,\n-    body_cache: ReadOnlyBodyCache<'_, 'tcx>,\n+    body: ReadOnlyBodyCache<'_, 'tcx>,\n     source: MirSource<'tcx>,\n     movable: bool,\n ) -> LivenessInfo {\n-    let dead_unwinds = BitSet::new_empty(body_cache.basic_blocks().len());\n+    let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n     let def_id = source.def_id();\n-    let body: &Body<'_> = &body_cache;\n+    let body_ref: &Body<'_> = &body;\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n-    let storage_live_analysis = MaybeStorageLive::new(body);\n+    let storage_live_analysis = MaybeStorageLive::new(body_ref);\n     let storage_live_results =\n-        do_dataflow(tcx, body, def_id, &[], &dead_unwinds, storage_live_analysis,\n+        do_dataflow(tcx, body_ref, def_id, &[], &dead_unwinds, storage_live_analysis,\n                     |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n-    let mut storage_live_cursor = DataflowResultsCursor::new(&storage_live_results, body);\n+    let mut storage_live_cursor = DataflowResultsCursor::new(&storage_live_results, body_ref);\n \n     // Find the MIR locals which do not use StorageLive/StorageDead statements.\n     // The storage of these locals are always live.\n-    let mut ignored = StorageIgnored(BitSet::new_filled(body_cache.local_decls.len()));\n-    ignored.visit_body(body_cache);\n+    let mut ignored = StorageIgnored(BitSet::new_filled(body.local_decls.len()));\n+    ignored.visit_body(body);\n \n     // Calculate the MIR locals which have been previously\n     // borrowed (even if they are still active).\n-    let borrowed_locals_analysis = HaveBeenBorrowedLocals::new(body);\n+    let borrowed_locals_analysis = HaveBeenBorrowedLocals::new(body_ref);\n     let borrowed_locals_results =\n-        do_dataflow(tcx, body, def_id, &[], &dead_unwinds, borrowed_locals_analysis,\n+        do_dataflow(tcx, body_ref, def_id, &[], &dead_unwinds, borrowed_locals_analysis,\n                     |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n-    let mut borrowed_locals_cursor = DataflowResultsCursor::new(&borrowed_locals_results, body);\n+    let mut borrowed_locals_cursor = DataflowResultsCursor::new(&borrowed_locals_results, body_ref);\n \n     // Calculate the MIR locals that we actually need to keep storage around\n     // for.\n-    let requires_storage_analysis = RequiresStorage::new(body_cache, &borrowed_locals_results);\n+    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_results);\n     let requires_storage_results =\n-        do_dataflow(tcx, body, def_id, &[], &dead_unwinds, requires_storage_analysis,\n+        do_dataflow(tcx, body_ref, def_id, &[], &dead_unwinds, requires_storage_analysis,\n                     |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n-    let mut requires_storage_cursor = DataflowResultsCursor::new(&requires_storage_results, body);\n+    let mut requires_storage_cursor\n+        = DataflowResultsCursor::new(&requires_storage_results, body_ref);\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n-    let mut live_locals = liveness::LiveVarSet::new_empty(body_cache.local_decls.len());\n+    let mut live_locals = liveness::LiveVarSet::new_empty(body.local_decls.len());\n     let mut liveness = liveness::liveness_of_locals(\n-        body_cache,\n+        body,\n     );\n     liveness::dump_mir(\n         tcx,\n         \"generator_liveness\",\n         source,\n-        body,\n+        body_ref,\n         &liveness,\n     );\n \n     let mut storage_liveness_map = FxHashMap::default();\n     let mut live_locals_at_suspension_points = Vec::new();\n \n-    for (block, data) in body_cache.basic_blocks().iter_enumerated() {\n+    for (block, data) in body.basic_blocks().iter_enumerated() {\n         if let TerminatorKind::Yield { .. } = data.terminator().kind {\n             let loc = Location {\n                 block: block,\n@@ -594,7 +595,7 @@ fn locals_live_across_suspend_points(\n         .collect();\n \n     let storage_conflicts = compute_storage_conflicts(\n-        body,\n+        body_ref,\n         &live_locals,\n         &ignored,\n         requires_storage_results);\n@@ -750,7 +751,7 @@ fn compute_layout<'tcx>(\n     upvars: &Vec<Ty<'tcx>>,\n     interior: Ty<'tcx>,\n     movable: bool,\n-    body_cache: &mut BodyCache<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n ) -> (\n     FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n     GeneratorLayout<'tcx>,\n@@ -759,7 +760,7 @@ fn compute_layout<'tcx>(\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let LivenessInfo {\n         live_locals, live_locals_at_suspension_points, storage_conflicts, storage_liveness\n-    } = locals_live_across_suspend_points(tcx, read_only!(body_cache), source, movable);\n+    } = locals_live_across_suspend_points(tcx, read_only!(body), source, movable);\n \n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n@@ -769,7 +770,7 @@ fn compute_layout<'tcx>(\n         _ => bug!(),\n     };\n \n-    for (local, decl) in body_cache.local_decls.iter_enumerated() {\n+    for (local, decl) in body.local_decls.iter_enumerated() {\n         // Ignore locals which are internal or not live\n         if !live_locals.contains(local) || decl.internal {\n             continue;\n@@ -778,7 +779,7 @@ fn compute_layout<'tcx>(\n         // Sanity check that typeck knows about the type of locals which are\n         // live across a suspension point\n         if !allowed.contains(&decl.ty) && !allowed_upvars.contains(&decl.ty) {\n-            span_bug!(body_cache.span,\n+            span_bug!(body.span,\n                       \"Broken MIR: generator contains type {} in MIR, \\\n                        but typeck only knows about {}\",\n                       decl.ty,\n@@ -791,7 +792,7 @@ fn compute_layout<'tcx>(\n     let mut tys = IndexVec::<GeneratorSavedLocal, _>::new();\n     for (idx, local) in live_locals.iter().enumerate() {\n         locals.push(local);\n-        tys.push(body_cache.local_decls[local].ty);\n+        tys.push(body.local_decls[local].ty);\n         debug!(\"generator saved local {:?} => {:?}\", GeneratorSavedLocal::from(idx), local);\n     }\n \n@@ -829,22 +830,22 @@ fn compute_layout<'tcx>(\n }\n \n fn insert_switch<'tcx>(\n-    body_cache: &mut BodyCache<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     cases: Vec<(usize, BasicBlock)>,\n     transform: &TransformVisitor<'tcx>,\n     default: TerminatorKind<'tcx>,\n ) {\n-    let default_block = insert_term_block(body_cache, default);\n-    let (assign, discr) = transform.get_discr(body_cache);\n+    let default_block = insert_term_block(body, default);\n+    let (assign, discr) = transform.get_discr(body);\n     let switch = TerminatorKind::SwitchInt {\n         discr: Operand::Move(discr),\n         switch_ty: transform.discr_ty,\n         values: Cow::from(cases.iter().map(|&(i, _)| i as u128).collect::<Vec<_>>()),\n         targets: cases.iter().map(|&(_, d)| d).chain(iter::once(default_block)).collect(),\n     };\n \n-    let source_info = source_info(body_cache);\n-    body_cache.basic_blocks_mut().raw.insert(0, BasicBlockData {\n+    let source_info = source_info(body);\n+    body.basic_blocks_mut().raw.insert(0, BasicBlockData {\n         statements: vec![assign],\n         terminator: Some(Terminator {\n             source_info,\n@@ -853,15 +854,15 @@ fn insert_switch<'tcx>(\n         is_cleanup: false,\n     });\n \n-    let blocks = body_cache.basic_blocks_mut().iter_mut();\n+    let blocks = body.basic_blocks_mut().iter_mut();\n \n     for target in blocks.flat_map(|b| b.terminator_mut().successors_mut()) {\n         *target = BasicBlock::new(target.index() + 1);\n     }\n }\n \n fn elaborate_generator_drops<'tcx>(\n-    tcx: TyCtxt<'tcx>, def_id: DefId, body_cache: &mut BodyCache<'tcx>\n+    tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut BodyCache<'tcx>\n ) {\n     use crate::util::elaborate_drops::{elaborate_drop, Unwind};\n     use crate::util::patch::MirPatch;\n@@ -875,13 +876,13 @@ fn elaborate_generator_drops<'tcx>(\n     let gen = self_arg();\n \n     let mut elaborator = DropShimElaborator {\n-        body: body_cache,\n-        patch: MirPatch::new(body_cache),\n+        body,\n+        patch: MirPatch::new(body),\n         tcx,\n         param_env\n     };\n \n-    for (block, block_data) in body_cache.basic_blocks().iter_enumerated() {\n+    for (block, block_data) in body.basic_blocks().iter_enumerated() {\n         let (target, unwind, source_info) = match block_data.terminator() {\n             Terminator {\n                 source_info,\n@@ -918,7 +919,7 @@ fn elaborate_generator_drops<'tcx>(\n             block,\n         );\n     }\n-    elaborator.patch.apply(body_cache);\n+    elaborator.patch.apply(body);\n }\n \n fn create_generator_drop_shim<'tcx>(\n@@ -927,31 +928,31 @@ fn create_generator_drop_shim<'tcx>(\n     def_id: DefId,\n     source: MirSource<'tcx>,\n     gen_ty: Ty<'tcx>,\n-    body_cache: &mut BodyCache<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     drop_clean: BasicBlock,\n ) -> BodyCache<'tcx> {\n-    let mut body_cache = body_cache.clone();\n+    let mut body = body.clone();\n \n-    let source_info = source_info(&body_cache);\n+    let source_info = source_info(&body);\n \n-    let mut cases = create_cases(&mut body_cache, transform, |point| point.drop);\n+    let mut cases = create_cases(&mut body, transform, |point| point.drop);\n \n     cases.insert(0, (UNRESUMED, drop_clean));\n \n     // The returned state and the poisoned state fall through to the default\n     // case which is just to return\n \n-    insert_switch(&mut body_cache, cases, &transform, TerminatorKind::Return);\n+    insert_switch(&mut body, cases, &transform, TerminatorKind::Return);\n \n-    for block in body_cache.basic_blocks_mut() {\n+    for block in body.basic_blocks_mut() {\n         let kind = &mut block.terminator_mut().kind;\n         if let TerminatorKind::GeneratorDrop = *kind {\n             *kind = TerminatorKind::Return;\n         }\n     }\n \n     // Replace the return variable\n-    body_cache.local_decls[RETURN_PLACE] = LocalDecl {\n+    body.local_decls[RETURN_PLACE] = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: tcx.mk_unit(),\n         user_ty: UserTypeProjections::none(),\n@@ -961,10 +962,10 @@ fn create_generator_drop_shim<'tcx>(\n         local_info: LocalInfo::Other\n     };\n \n-    make_generator_state_argument_indirect(tcx, def_id, &mut body_cache);\n+    make_generator_state_argument_indirect(tcx, def_id, &mut body);\n \n     // Change the generator argument from &mut to *mut\n-    body_cache.local_decls[self_arg()] = LocalDecl {\n+    body.local_decls[self_arg()] = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: tcx.mk_ptr(ty::TypeAndMut {\n             ty: gen_ty,\n@@ -978,29 +979,29 @@ fn create_generator_drop_shim<'tcx>(\n     };\n     if tcx.sess.opts.debugging_opts.mir_emit_retag {\n         // Alias tracking must know we changed the type\n-        body_cache.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n+        body.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n             source_info,\n             kind: StatementKind::Retag(RetagKind::Raw, box Place::from(self_arg())),\n         })\n     }\n \n-    no_landing_pads(tcx, &mut body_cache);\n+    no_landing_pads(tcx, &mut body);\n \n     // Make sure we remove dead blocks to remove\n     // unrelated code from the resume part of the function\n-    simplify::remove_dead_blocks(&mut body_cache);\n+    simplify::remove_dead_blocks(&mut body);\n \n-    dump_mir(tcx, None, \"generator_drop\", &0, source, &mut body_cache, |_, _| Ok(()) );\n+    dump_mir(tcx, None, \"generator_drop\", &0, source, &mut body, |_, _| Ok(()) );\n \n-    body_cache\n+    body\n }\n \n fn insert_term_block<'tcx>(\n-    body_cache: &mut BodyCache<'tcx>, kind: TerminatorKind<'tcx>\n+    body: &mut BodyCache<'tcx>, kind: TerminatorKind<'tcx>\n ) -> BasicBlock {\n-    let term_block = BasicBlock::new(body_cache.basic_blocks().len());\n-    let source_info = source_info(body_cache);\n-    body_cache.basic_blocks_mut().push(BasicBlockData {\n+    let term_block = BasicBlock::new(body.basic_blocks().len());\n+    let source_info = source_info(body);\n+    body.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator {\n             source_info,\n@@ -1013,13 +1014,13 @@ fn insert_term_block<'tcx>(\n \n fn insert_panic_block<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    body_cache: &mut BodyCache<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     message: AssertMessage<'tcx>,\n ) -> BasicBlock {\n-    let assert_block = BasicBlock::new(body_cache.basic_blocks().len());\n+    let assert_block = BasicBlock::new(body.basic_blocks().len());\n     let term = TerminatorKind::Assert {\n         cond: Operand::Constant(box Constant {\n-            span: body_cache.span,\n+            span: body.span,\n             user_ty: None,\n             literal: ty::Const::from_bool(tcx, false),\n         }),\n@@ -1029,8 +1030,8 @@ fn insert_panic_block<'tcx>(\n         cleanup: None,\n     };\n \n-    let source_info = source_info(body_cache);\n-    body_cache.basic_blocks_mut().push(BasicBlockData {\n+    let source_info = source_info(body);\n+    body.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator {\n             source_info,\n@@ -1047,18 +1048,18 @@ fn create_generator_resume_function<'tcx>(\n     transform: TransformVisitor<'tcx>,\n     def_id: DefId,\n     source: MirSource<'tcx>,\n-    body_cache: &mut BodyCache<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n ) {\n     // Poison the generator when it unwinds\n-    for block in body_cache.basic_blocks_mut() {\n+    for block in body.basic_blocks_mut() {\n         let source_info = block.terminator().source_info;\n         if let &TerminatorKind::Resume = &block.terminator().kind {\n             block.statements.push(\n                 transform.set_discr(VariantIdx::new(POISONED), source_info));\n         }\n     }\n \n-    let mut cases = create_cases(body_cache, &transform, |point| Some(point.resume));\n+    let mut cases = create_cases(body, &transform, |point| Some(point.resume));\n \n     use rustc::mir::interpret::PanicInfo::{\n         ResumedAfterPanic,\n@@ -1072,25 +1073,25 @@ fn create_generator_resume_function<'tcx>(\n     let generator_kind = body.generator_kind.unwrap();\n     cases.insert(1, (RETURNED, insert_panic_block(\n         tcx,\n-        body_cache,\n+        body,\n         ResumedAfterReturn(generator_kind))));\n     cases.insert(2, (POISONED, insert_panic_block(\n         tcx,\n-        body_cache,\n+        body,\n         ResumedAfterPanic(generator_kind))));\n \n-    insert_switch(body_cache, cases, &transform, TerminatorKind::Unreachable);\n+    insert_switch(body, cases, &transform, TerminatorKind::Unreachable);\n \n-    make_generator_state_argument_indirect(tcx, def_id, body_cache);\n-    make_generator_state_argument_pinned(tcx, body_cache);\n+    make_generator_state_argument_indirect(tcx, def_id, body);\n+    make_generator_state_argument_pinned(tcx, body);\n \n-    no_landing_pads(tcx, body_cache);\n+    no_landing_pads(tcx, body);\n \n     // Make sure we remove dead blocks to remove\n     // unrelated code from the drop part of the function\n-    simplify::remove_dead_blocks(body_cache);\n+    simplify::remove_dead_blocks(body);\n \n-    dump_mir(tcx, None, \"generator_resume\", &0, source, body_cache, |_, _| Ok(()) );\n+    dump_mir(tcx, None, \"generator_resume\", &0, source, body, |_, _| Ok(()) );\n }\n \n fn source_info(body: &Body<'_>) -> SourceInfo {\n@@ -1100,18 +1101,18 @@ fn source_info(body: &Body<'_>) -> SourceInfo {\n     }\n }\n \n-fn insert_clean_drop(body_cache: &mut BodyCache<'_>) -> BasicBlock {\n-    let return_block = insert_term_block(body_cache, TerminatorKind::Return);\n+fn insert_clean_drop(body: &mut BodyCache<'_>) -> BasicBlock {\n+    let return_block = insert_term_block(body, TerminatorKind::Return);\n \n     // Create a block to destroy an unresumed generators. This can only destroy upvars.\n-    let drop_clean = BasicBlock::new(body_cache.basic_blocks().len());\n+    let drop_clean = BasicBlock::new(body.basic_blocks().len());\n     let term = TerminatorKind::Drop {\n         location: Place::from(self_arg()),\n         target: return_block,\n         unwind: None,\n     };\n-    let source_info = source_info(body_cache);\n-    body_cache.basic_blocks_mut().push(BasicBlockData {\n+    let source_info = source_info(body);\n+    body.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator {\n             source_info,\n@@ -1124,23 +1125,23 @@ fn insert_clean_drop(body_cache: &mut BodyCache<'_>) -> BasicBlock {\n }\n \n fn create_cases<'tcx, F>(\n-    body_cache: &mut BodyCache<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     transform: &TransformVisitor<'tcx>,\n     target: F,\n ) -> Vec<(usize, BasicBlock)>\n where\n     F: Fn(&SuspensionPoint) -> Option<BasicBlock>,\n {\n-    let source_info = source_info(body_cache);\n+    let source_info = source_info(body);\n \n     transform.suspension_points.iter().filter_map(|point| {\n         // Find the target for this suspension point, if applicable\n         target(point).map(|target| {\n-            let block = BasicBlock::new(body_cache.basic_blocks().len());\n+            let block = BasicBlock::new(body.basic_blocks().len());\n             let mut statements = Vec::new();\n \n             // Create StorageLive instructions for locals with live storage\n-            for i in 0..(body_cache.local_decls.len()) {\n+            for i in 0..(body.local_decls.len()) {\n                 let l = Local::new(i);\n                 if point.storage_liveness.contains(l) && !transform.remap.contains_key(&l) {\n                     statements.push(Statement {\n@@ -1151,7 +1152,7 @@ where\n             }\n \n             // Then jump to the real target\n-            body_cache.basic_blocks_mut().push(BasicBlockData {\n+            body.basic_blocks_mut().push(BasicBlockData {\n                 statements,\n                 terminator: Some(Terminator {\n                     source_info,\n@@ -1169,21 +1170,21 @@ where\n \n impl<'tcx> MirPass<'tcx> for StateTransform {\n     fn run_pass(\n-        &self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>\n+        &self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n     ) {\n-        let yield_ty = if let Some(yield_ty) = body_cache.yield_ty {\n+        let yield_ty = if let Some(yield_ty) = body.yield_ty {\n             yield_ty\n         } else {\n             // This only applies to generators\n             return\n         };\n \n-        assert!(body_cache.generator_drop.is_none());\n+        assert!(body.generator_drop.is_none());\n \n         let def_id = source.def_id();\n \n         // The first argument is the generator type passed by value\n-        let gen_ty = body_cache.local_decls.raw[1].ty;\n+        let gen_ty = body.local_decls.raw[1].ty;\n \n         // Get the interior types and substs which typeck computed\n         let (upvars, interior, discr_ty, movable) = match gen_ty.kind {\n@@ -1202,13 +1203,13 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         let state_adt_ref = tcx.adt_def(state_did);\n         let state_substs = tcx.intern_substs(&[\n             yield_ty.into(),\n-            body_cache.return_ty().into(),\n+            body.return_ty().into(),\n         ]);\n         let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n \n         // We rename RETURN_PLACE which has type mir.return_ty to new_ret_local\n         // RETURN_PLACE then is a fresh unused local with type ret_ty.\n-        let new_ret_local = replace_result_variable(ret_ty, body_cache, tcx);\n+        let new_ret_local = replace_result_variable(ret_ty, body, tcx);\n \n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices\n@@ -1219,7 +1220,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n             &upvars,\n             interior,\n             movable,\n-            body_cache);\n+            body);\n \n         // Run the transformation which converts Places from Local to generator struct\n         // accesses for locals in `remap`.\n@@ -1235,40 +1236,40 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n             new_ret_local,\n             discr_ty,\n         };\n-        transform.visit_body(body_cache);\n+        transform.visit_body(body);\n \n         // Update our MIR struct to reflect the changed we've made\n-        body_cache.yield_ty = None;\n-        body_cache.arg_count = 1;\n-        body_cache.spread_arg = None;\n-        body_cache.generator_layout = Some(layout);\n+        body.yield_ty = None;\n+        body.arg_count = 1;\n+        body.spread_arg = None;\n+        body.generator_layout = Some(layout);\n \n         // Insert `drop(generator_struct)` which is used to drop upvars for generators in\n         // the unresumed state.\n         // This is expanded to a drop ladder in `elaborate_generator_drops`.\n-        let drop_clean = insert_clean_drop(body_cache);\n+        let drop_clean = insert_clean_drop(body);\n \n-        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, body_cache, |_, _| Ok(()) );\n+        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, body, |_, _| Ok(()) );\n \n         // Expand `drop(generator_struct)` to a drop ladder which destroys upvars.\n         // If any upvars are moved out of, drop elaboration will handle upvar destruction.\n         // However we need to also elaborate the code generated by `insert_clean_drop`.\n-        elaborate_generator_drops(tcx, def_id, body_cache);\n+        elaborate_generator_drops(tcx, def_id, body);\n \n-        dump_mir(tcx, None, \"generator_post-transform\", &0, source, body_cache, |_, _| Ok(()) );\n+        dump_mir(tcx, None, \"generator_post-transform\", &0, source, body, |_, _| Ok(()) );\n \n         // Create a copy of our MIR and use it to create the drop shim for the generator\n         let drop_shim = create_generator_drop_shim(tcx,\n                                                    &transform,\n                                                    def_id,\n                                                    source,\n                                                    gen_ty,\n-                                                   body_cache,\n+                                                   body,\n                                                    drop_clean);\n \n-        body_cache.generator_drop = Some(box drop_shim);\n+        body.generator_drop = Some(box drop_shim);\n \n         // Create the Generator::resume function\n-        create_generator_resume_function(tcx, transform, def_id, source, body_cache);\n+        create_generator_resume_function(tcx, transform, def_id, source, body);\n     }\n }"}, {"sha": "79cb7fb0b7692b3fabc63158834a8cee39e5280a", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -39,10 +39,10 @@ struct CallSite<'tcx> {\n \n impl<'tcx> MirPass<'tcx> for Inline {\n     fn run_pass(\n-        &self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>\n+        &self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n     ) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n-            Inliner { tcx, source }.run_pass(body_cache);\n+            Inliner { tcx, source }.run_pass(body);\n         }\n     }\n }\n@@ -53,7 +53,7 @@ struct Inliner<'tcx> {\n }\n \n impl Inliner<'tcx> {\n-    fn run_pass(&self, caller_body_cache: &mut BodyCache<'tcx>) {\n+    fn run_pass(&self, caller_body: &mut BodyCache<'tcx>) {\n         // Keep a queue of callsites to try inlining on. We take\n         // advantage of the fact that queries detect cycles here to\n         // allow us to try and fetch the fully optimized MIR of a\n@@ -75,10 +75,10 @@ impl Inliner<'tcx> {\n         if self.tcx.hir().body_owner_kind(id).is_fn_or_closure()\n             && self.source.promoted.is_none()\n         {\n-            for (bb, bb_data) in caller_body_cache.basic_blocks().iter_enumerated() {\n+            for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated() {\n                 if let Some(callsite) = self.get_valid_function_call(bb,\n                                                                      bb_data,\n-                                                                     caller_body_cache,\n+                                                                     caller_body,\n                                                                      param_env) {\n                     callsites.push_back(callsite);\n                 }\n@@ -129,20 +129,20 @@ impl Inliner<'tcx> {\n                     continue;\n                 };\n \n-                let start = caller_body_cache.basic_blocks().len();\n+                let start = caller_body.basic_blocks().len();\n                 debug!(\"attempting to inline callsite {:?} - body={:?}\", callsite, callee_body);\n-                if !self.inline_call(callsite, caller_body_cache, callee_body) {\n+                if !self.inline_call(callsite, caller_body, callee_body) {\n                     debug!(\"attempting to inline callsite {:?} - failure\", callsite);\n                     continue;\n                 }\n                 debug!(\"attempting to inline callsite {:?} - success\", callsite);\n \n                 // Add callsites from inlined function\n-                for (bb, bb_data) in caller_body_cache.basic_blocks().iter_enumerated().skip(start)\n+                for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated().skip(start)\n                 {\n                     if let Some(new_callsite) = self.get_valid_function_call(bb,\n                                                                              bb_data,\n-                                                                             caller_body_cache,\n+                                                                             caller_body,\n                                                                              param_env) {\n                         // Don't inline the same function multiple times.\n                         if callsite.callee != new_callsite.callee {\n@@ -163,8 +163,8 @@ impl Inliner<'tcx> {\n         // Simplify if we inlined anything.\n         if changed {\n             debug!(\"running simplify cfg on {:?}\", self.source);\n-            CfgSimplifier::new(caller_body_cache).simplify();\n-            remove_dead_blocks(caller_body_cache);\n+            CfgSimplifier::new(caller_body).simplify();\n+            remove_dead_blocks(caller_body);\n         }\n     }\n \n@@ -381,22 +381,22 @@ impl Inliner<'tcx> {\n     fn inline_call(&self,\n                    callsite: CallSite<'tcx>,\n                    caller_body: &mut BodyCache<'tcx>,\n-                   mut callee_body_cache: BodyCache<'tcx>) -> bool {\n+                   mut callee_body: BodyCache<'tcx>) -> bool {\n         let terminator = caller_body[callsite.bb].terminator.take().unwrap();\n         match terminator.kind {\n             // FIXME: Handle inlining of diverging calls\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n                 debug!(\"inlined {:?} into {:?}\", callsite.callee, self.source);\n \n-                let mut local_map = IndexVec::with_capacity(callee_body_cache.local_decls.len());\n-                let mut scope_map = IndexVec::with_capacity(callee_body_cache.source_scopes.len());\n+                let mut local_map = IndexVec::with_capacity(callee_body.local_decls.len());\n+                let mut scope_map = IndexVec::with_capacity(callee_body.source_scopes.len());\n \n-                for mut scope in callee_body_cache.source_scopes.iter().cloned() {\n+                for mut scope in callee_body.source_scopes.iter().cloned() {\n                     if scope.parent_scope.is_none() {\n                         scope.parent_scope = Some(callsite.location.scope);\n                         // FIXME(eddyb) is this really needed?\n                         // (also note that it's always overwritten below)\n-                        scope.span = callee_body_cache.span;\n+                        scope.span = callee_body.span;\n                     }\n \n                     // FIXME(eddyb) this doesn't seem right at all.\n@@ -408,8 +408,8 @@ impl Inliner<'tcx> {\n                     scope_map.push(idx);\n                 }\n \n-                for loc in callee_body_cache.vars_and_temps_iter() {\n-                    let mut local = callee_body_cache.local_decls[loc].clone();\n+                for loc in callee_body.vars_and_temps_iter() {\n+                    let mut local = callee_body.local_decls[loc].clone();\n \n                     local.source_info.scope =\n                         scope_map[local.source_info.scope];\n@@ -448,7 +448,7 @@ impl Inliner<'tcx> {\n                         BorrowKind::Mut { allow_two_phase_borrow: false },\n                         destination.0);\n \n-                    let ty = dest.ty(caller_body, self.tcx);\n+                    let ty = dest.ty(&**caller_body, self.tcx);\n \n                     let temp = LocalDecl::new_temp(ty, callsite.location.span);\n \n@@ -489,7 +489,7 @@ impl Inliner<'tcx> {\n                     caller_body.var_debug_info.push(var_debug_info);\n                 }\n \n-                for (bb, mut block) in callee_body_cache.basic_blocks_mut().drain_enumerated(..) {\n+                for (bb, mut block) in callee_body.basic_blocks_mut().drain_enumerated(..) {\n                     integrator.visit_basic_block_data(bb, &mut block);\n                     caller_body.basic_blocks_mut().push(block);\n                 }\n@@ -517,7 +517,7 @@ impl Inliner<'tcx> {\n         &self,\n         args: Vec<Operand<'tcx>>,\n         callsite: &CallSite<'tcx>,\n-        caller_body_cache: &mut BodyCache<'tcx>,\n+        caller_body: &mut BodyCache<'tcx>,\n     ) -> Vec<Local> {\n         let tcx = self.tcx;\n \n@@ -547,13 +547,13 @@ impl Inliner<'tcx> {\n         if tcx.is_closure(callsite.callee) {\n             let mut args = args.into_iter();\n             let self_\n-                = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body_cache);\n+                = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);\n             let tuple\n-                = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body_cache);\n+                = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);\n             assert!(args.next().is_none());\n \n             let tuple = Place::from(tuple);\n-            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_body_cache, tcx).ty.kind {\n+            let tuple_tys = if let ty::Tuple(s) = tuple.ty(&**caller_body, tcx).ty.kind {\n                 s\n             } else {\n                 bug!(\"Closure arguments are not passed as a tuple\");\n@@ -573,13 +573,13 @@ impl Inliner<'tcx> {\n                     ));\n \n                     // Spill to a local to make e.g., `tmp0`.\n-                    self.create_temp_if_necessary(tuple_field, callsite, caller_body_cache)\n+                    self.create_temp_if_necessary(tuple_field, callsite, caller_body)\n                 });\n \n             closure_ref_arg.chain(tuple_tmp_args).collect()\n         } else {\n             args.into_iter()\n-                .map(|a| self.create_temp_if_necessary(a, callsite, caller_body_cache))\n+                .map(|a| self.create_temp_if_necessary(a, callsite, caller_body))\n                 .collect()\n         }\n     }\n@@ -590,14 +590,14 @@ impl Inliner<'tcx> {\n         &self,\n         arg: Operand<'tcx>,\n         callsite: &CallSite<'tcx>,\n-        caller_body_cache: &mut BodyCache<'tcx>,\n+        caller_body: &mut BodyCache<'tcx>,\n     ) -> Local {\n         // FIXME: Analysis of the usage of the arguments to avoid\n         // unnecessary temporaries.\n \n         if let Operand::Move(place) = &arg {\n             if let Some(local) = place.as_local() {\n-                if caller_body_cache.local_kind(local) == LocalKind::Temp {\n+                if caller_body.local_kind(local) == LocalKind::Temp {\n                     // Reuse the operand if it's a temporary already\n                     return local;\n                 }\n@@ -608,16 +608,16 @@ impl Inliner<'tcx> {\n         // Otherwise, create a temporary for the arg\n         let arg = Rvalue::Use(arg);\n \n-        let ty = arg.ty(caller_body_cache, self.tcx);\n+        let ty = arg.ty(&**caller_body, self.tcx);\n \n         let arg_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n-        let arg_tmp = caller_body_cache.local_decls.push(arg_tmp);\n+        let arg_tmp = caller_body.local_decls.push(arg_tmp);\n \n         let stmt = Statement {\n             source_info: callsite.location,\n             kind: StatementKind::Assign(box(Place::from(arg_tmp), arg)),\n         };\n-        caller_body_cache[callsite.bb].statements.push(stmt);\n+        caller_body[callsite.bb].statements.push(stmt);\n         arg_tmp\n     }\n }"}, {"sha": "bd237b58132989287281eeed4b70640a6d53dc50", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -14,7 +14,7 @@ use crate::transform::{MirPass, MirSource};\n pub struct InstCombine;\n \n impl<'tcx> MirPass<'tcx> for InstCombine {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         // We only run when optimizing MIR (at any level).\n         if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n             return\n@@ -24,14 +24,14 @@ impl<'tcx> MirPass<'tcx> for InstCombine {\n         // read-only so that we can do global analyses on the MIR in the process (e.g.\n         // `Place::ty()`).\n         let optimizations = {\n-            let read_only_cache = read_only!(body_cache);\n-            let mut optimization_finder = OptimizationFinder::new(body_cache, tcx);\n+            let read_only_cache = read_only!(body);\n+            let mut optimization_finder = OptimizationFinder::new(body, tcx);\n             optimization_finder.visit_body(read_only_cache);\n             optimization_finder.optimizations\n         };\n \n         // Then carry out those optimizations.\n-        MutVisitor::visit_body(&mut InstCombineVisitor { optimizations, tcx }, body_cache);\n+        MutVisitor::visit_body(&mut InstCombineVisitor { optimizations, tcx }, body);\n     }\n }\n "}, {"sha": "05d9787531b2a511ad523eb97f8aeeb9493124ee", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -224,14 +224,14 @@ fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<BodyCache<'_>> {\n     // Unsafety check uses the raw mir, so make sure it is run\n     let _ = tcx.unsafety_check_result(def_id);\n \n-    let mut body_cache = tcx.mir_built(def_id).steal();\n-    run_passes(tcx, &mut body_cache, InstanceDef::Item(def_id), None, MirPhase::Const, &[\n+    let mut body = tcx.mir_built(def_id).steal();\n+    run_passes(tcx, &mut body, InstanceDef::Item(def_id), None, MirPhase::Const, &[\n         // What we need to do constant evaluation.\n         &simplify::SimplifyCfg::new(\"initial\"),\n         &rustc_peek::SanityCheck,\n         &uniform_array_move_out::UniformArrayMoveOut,\n     ]);\n-    tcx.alloc_steal_mir(body_cache)\n+    tcx.alloc_steal_mir(body)\n }\n \n fn mir_validated(\n@@ -242,25 +242,25 @@ fn mir_validated(\n     // this point, before we steal the mir-const result.\n     let _ = tcx.mir_const_qualif(def_id);\n \n-    let mut body_cache = tcx.mir_const(def_id).steal();\n+    let mut body = tcx.mir_const(def_id).steal();\n     let promote_pass = promote_consts::PromoteTemps::default();\n-    run_passes(tcx, &mut body_cache, InstanceDef::Item(def_id), None, MirPhase::Validated, &[\n+    run_passes(tcx, &mut body, InstanceDef::Item(def_id), None, MirPhase::Validated, &[\n         // What we need to run borrowck etc.\n         &promote_pass,\n         &simplify::SimplifyCfg::new(\"qualify-consts\"),\n     ]);\n \n     let promoted = promote_pass.promoted_fragments.into_inner();\n-    (tcx.alloc_steal_mir(body_cache), tcx.alloc_steal_promoted(promoted))\n+    (tcx.alloc_steal_mir(body), tcx.alloc_steal_promoted(promoted))\n }\n \n fn run_optimization_passes<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    body_cache: &mut BodyCache<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     def_id: DefId,\n     promoted: Option<Promoted>,\n ) {\n-    run_passes(tcx, body_cache, InstanceDef::Item(def_id), promoted, MirPhase::Optimized, &[\n+    run_passes(tcx, body, InstanceDef::Item(def_id), promoted, MirPhase::Optimized, &[\n         // Remove all things only needed by analysis\n         &no_landing_pads::NoLandingPads::new(tcx),\n         &simplify_branches::SimplifyBranches::new(\"initial\"),\n@@ -332,10 +332,10 @@ fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &BodyCache<'_> {\n     tcx.ensure().mir_borrowck(def_id);\n \n     let (body, _) = tcx.mir_validated(def_id);\n-    let mut body_cache = body.steal();\n-    run_optimization_passes(tcx, &mut body_cache, def_id, None);\n-    body_cache.ensure_predecessors();\n-    tcx.arena.alloc(body_cache)\n+    let mut body = body.steal();\n+    run_optimization_passes(tcx, &mut body, def_id, None);\n+    body.ensure_predecessors();\n+    tcx.arena.alloc(body)\n }\n \n fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &IndexVec<Promoted, BodyCache<'_>> {\n@@ -347,9 +347,9 @@ fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &IndexVec<Promoted, BodyCache\n     let (_, promoted) = tcx.mir_validated(def_id);\n     let mut promoted = promoted.steal();\n \n-    for (p, mut body_cache) in promoted.iter_enumerated_mut() {\n-        run_optimization_passes(tcx, &mut body_cache, def_id, Some(p));\n-        body_cache.ensure_predecessors();\n+    for (p, mut body) in promoted.iter_enumerated_mut() {\n+        run_optimization_passes(tcx, &mut body, def_id, Some(p));\n+        body.ensure_predecessors();\n     }\n \n     tcx.intern_promoted(promoted)"}, {"sha": "5e1d29d47ade9090605ff1a156df719262beb996", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -17,14 +17,14 @@ impl<'tcx> NoLandingPads<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for NoLandingPads<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n-        no_landing_pads(tcx, body_cache)\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n+        no_landing_pads(tcx, body)\n     }\n }\n \n-pub fn no_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+pub fn no_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut BodyCache<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n-        NoLandingPads::new(tcx).visit_body(body_cache);\n+        NoLandingPads::new(tcx).visit_body(body);\n     }\n }\n "}, {"sha": "3a24f4a9fb1a43e4225077df47213f7dabf3019a", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -770,8 +770,8 @@ pub fn validate_candidates(\n \n struct Promoter<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    source_cache: &'a mut BodyCache<'tcx>,\n-    promoted_cache: BodyCache<'tcx>,\n+    source: &'a mut BodyCache<'tcx>,\n+    promoted: BodyCache<'tcx>,\n     temps: &'a mut IndexVec<Local, TempState>,\n \n     /// If true, all nested temps are also kept in the\n@@ -781,8 +781,8 @@ struct Promoter<'a, 'tcx> {\n \n impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     fn new_block(&mut self) -> BasicBlock {\n-        let span = self.promoted_cache.span;\n-        self.promoted_cache.basic_blocks_mut().push(BasicBlockData {\n+        let span = self.promoted.span;\n+        self.promoted.basic_blocks_mut().push(BasicBlockData {\n             statements: vec![],\n             terminator: Some(Terminator {\n                 source_info: SourceInfo {\n@@ -796,8 +796,8 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn assign(&mut self, dest: Local, rvalue: Rvalue<'tcx>, span: Span) {\n-        let last = self.promoted_cache.basic_blocks().last().unwrap();\n-        let data = &mut self.promoted_cache[last];\n+        let last = self.promoted.basic_blocks().last().unwrap();\n+        let data = &mut self.promoted[last];\n         data.statements.push(Statement {\n             source_info: SourceInfo {\n                 span,\n@@ -808,7 +808,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn is_temp_kind(&self, local: Local) -> bool {\n-        self.source_cache.local_kind(local) == LocalKind::Temp\n+        self.source.local_kind(local) == LocalKind::Temp\n     }\n \n     /// Copies the initialization of this temp to the\n@@ -823,18 +823,18 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 location\n             }\n             state =>  {\n-                span_bug!(self.promoted_cache.span, \"{:?} not promotable: {:?}\",\n+                span_bug!(self.promoted.span, \"{:?} not promotable: {:?}\",\n                           temp, state);\n             }\n         };\n         if !self.keep_original {\n             self.temps[temp] = TempState::PromotedOut;\n         }\n \n-        let num_stmts = self.source_cache[loc.block].statements.len();\n-        let new_temp = self.promoted_cache.local_decls.push(\n-            LocalDecl::new_temp(self.source_cache.local_decls[temp].ty,\n-                                self.source_cache.local_decls[temp].source_info.span));\n+        let num_stmts = self.source[loc.block].statements.len();\n+        let new_temp = self.promoted.local_decls.push(\n+            LocalDecl::new_temp(self.source.local_decls[temp].ty,\n+                                self.source.local_decls[temp].source_info.span));\n \n         debug!(\"promote({:?} @ {:?}/{:?}, {:?})\",\n                temp, loc, num_stmts, self.keep_original);\n@@ -843,7 +843,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         // or duplicate it, depending on keep_original.\n         if loc.statement_index < num_stmts {\n             let (mut rvalue, source_info) = {\n-                let statement = &mut self.source_cache[loc.block].statements[loc.statement_index];\n+                let statement = &mut self.source[loc.block].statements[loc.statement_index];\n                 let rhs = match statement.kind {\n                     StatementKind::Assign(box(_, ref mut rhs)) => rhs,\n                     _ => {\n@@ -864,9 +864,9 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             self.assign(new_temp, rvalue, source_info.span);\n         } else {\n             let terminator = if self.keep_original {\n-                self.source_cache[loc.block].terminator().clone()\n+                self.source[loc.block].terminator().clone()\n             } else {\n-                let terminator = self.source_cache[loc.block].terminator_mut();\n+                let terminator = self.source[loc.block].terminator_mut();\n                 let target = match terminator.kind {\n                     TerminatorKind::Call { destination: Some((_, target)), .. } => target,\n                     ref kind => {\n@@ -888,10 +888,10 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         self.visit_operand(arg, loc);\n                     }\n \n-                    let last = self.promoted_cache.basic_blocks().last().unwrap();\n+                    let last = self.promoted.basic_blocks().last().unwrap();\n                     let new_target = self.new_block();\n \n-                    *self.promoted_cache[last].terminator_mut() = Terminator {\n+                    *self.promoted[last].terminator_mut() = Terminator {\n                         kind: TerminatorKind::Call {\n                             func,\n                             args,\n@@ -921,7 +921,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         next_promoted_id: usize,\n     ) -> Option<BodyCache<'tcx>> {\n         let mut operand = {\n-            let promoted = &mut self.promoted_cache;\n+            let promoted = &mut self.promoted;\n             let promoted_id = Promoted::new(next_promoted_id);\n             let tcx = self.tcx;\n             let mut promoted_place = |ty, span| {\n@@ -940,7 +940,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                     projection: List::empty(),\n                 }\n             };\n-            let (blocks, local_decls) = self.source_cache.basic_blocks_and_local_decls_mut();\n+            let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n             match candidate {\n                 Candidate::Ref(loc) => {\n                     let ref mut statement = blocks[loc.block].statements[loc.statement_index];\n@@ -1004,9 +1004,9 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             statement_index: usize::MAX\n         });\n \n-        let span = self.promoted_cache.span;\n+        let span = self.promoted.span;\n         self.assign(RETURN_PLACE, Rvalue::Use(operand), span);\n-        Some(self.promoted_cache)\n+        Some(self.promoted)\n     }\n }\n \n@@ -1040,7 +1040,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n \n pub fn promote_candidates<'tcx>(\n     def_id: DefId,\n-    body_cache: &mut BodyCache<'tcx>,\n+    body: &mut BodyCache<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     mut temps: IndexVec<Local, TempState>,\n     candidates: Vec<Candidate>,\n@@ -1054,7 +1054,7 @@ pub fn promote_candidates<'tcx>(\n         match candidate {\n             Candidate::Repeat(Location { block, statement_index }) |\n             Candidate::Ref(Location { block, statement_index }) => {\n-                match &body_cache[block].statements[statement_index].kind {\n+                match &body[block].statements[statement_index].kind {\n                     StatementKind::Assign(box(place, _)) => {\n                         if let Some(local) = place.as_local() {\n                             if temps[local] == TempState::PromotedOut {\n@@ -1072,26 +1072,26 @@ pub fn promote_candidates<'tcx>(\n \n         // Declare return place local so that `mir::Body::new` doesn't complain.\n         let initial_locals = iter::once(\n-            LocalDecl::new_return_place(tcx.types.never, body_cache.span)\n+            LocalDecl::new_return_place(tcx.types.never, body.span)\n         ).collect();\n \n         let promoter = Promoter {\n-            promoted_cache: BodyCache::new(Body::new(\n+            promoted: BodyCache::new(Body::new(\n                 IndexVec::new(),\n                 // FIXME: maybe try to filter this to avoid blowing up\n                 // memory usage?\n-                body_cache.source_scopes.clone(),\n-                body_cache.source_scope_local_data.clone(),\n+                body.source_scopes.clone(),\n+                body.source_scope_local_data.clone(),\n                 initial_locals,\n                 IndexVec::new(),\n                 0,\n                 vec![],\n-                body_cache.span,\n+                body.span,\n                 vec![],\n-                body_cache.generator_kind,\n+                body.generator_kind,\n             )),\n             tcx,\n-            source_cache: body_cache,\n+            source: body,\n             temps: &mut temps,\n             keep_original: false\n         };\n@@ -1104,7 +1104,7 @@ pub fn promote_candidates<'tcx>(\n \n     // Eliminate assignments to, and drops of promoted temps.\n     let promoted = |index: Local| temps[index] == TempState::PromotedOut;\n-    for block in body_cache.basic_blocks_mut() {\n+    for block in body.basic_blocks_mut() {\n         block.statements.retain(|statement| {\n             match &statement.kind {\n                 StatementKind::Assign(box(place, _)) => {"}, {"sha": "c636aba9fc607fd4b6bf405deec4065341e6cf2e", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -9,18 +9,18 @@ use crate::util::patch::MirPatch;\n /// code for these.\n pub struct RemoveNoopLandingPads;\n \n-pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+pub fn remove_noop_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut BodyCache<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n         return\n     }\n-    debug!(\"remove_noop_landing_pads({:?})\", body_cache);\n+    debug!(\"remove_noop_landing_pads({:?})\", body);\n \n-    RemoveNoopLandingPads.remove_nop_landing_pads(body_cache)\n+    RemoveNoopLandingPads.remove_nop_landing_pads(body)\n }\n \n impl<'tcx> MirPass<'tcx> for RemoveNoopLandingPads {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n-        remove_noop_landing_pads(tcx, body_cache);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n+        remove_noop_landing_pads(tcx, body);\n     }\n }\n \n@@ -84,34 +84,34 @@ impl RemoveNoopLandingPads {\n         }\n     }\n \n-    fn remove_nop_landing_pads(&self, body_cache: &mut BodyCache<'_>) {\n+    fn remove_nop_landing_pads(&self, body: &mut BodyCache<'_>) {\n         // make sure there's a single resume block\n         let resume_block = {\n-            let patch = MirPatch::new(body_cache);\n+            let patch = MirPatch::new(body);\n             let resume_block = patch.resume_block();\n-            patch.apply(body_cache);\n+            patch.apply(body);\n             resume_block\n         };\n         debug!(\"remove_noop_landing_pads: resume block is {:?}\", resume_block);\n \n         let mut jumps_folded = 0;\n         let mut landing_pads_removed = 0;\n-        let mut nop_landing_pads = BitSet::new_empty(body_cache.basic_blocks().len());\n+        let mut nop_landing_pads = BitSet::new_empty(body.basic_blocks().len());\n \n         // This is a post-order traversal, so that if A post-dominates B\n         // then A will be visited before B.\n-        let postorder: Vec<_> = traversal::postorder(body_cache).map(|(bb, _)| bb).collect();\n+        let postorder: Vec<_> = traversal::postorder(body).map(|(bb, _)| bb).collect();\n         for bb in postorder {\n             debug!(\"  processing {:?}\", bb);\n-            for target in body_cache[bb].terminator_mut().successors_mut() {\n+            for target in body[bb].terminator_mut().successors_mut() {\n                 if *target != resume_block && nop_landing_pads.contains(*target) {\n                     debug!(\"    folding noop jump to {:?} to resume block\", target);\n                     *target = resume_block;\n                     jumps_folded += 1;\n                 }\n             }\n \n-            match body_cache[bb].terminator_mut().unwind_mut() {\n+            match body[bb].terminator_mut().unwind_mut() {\n                 Some(unwind) => {\n                     if *unwind == Some(resume_block) {\n                         debug!(\"    removing noop landing pad\");\n@@ -123,7 +123,7 @@ impl RemoveNoopLandingPads {\n                 _ => {}\n             }\n \n-            let is_nop_landing_pad = self.is_nop_landing_pad(bb, body_cache, &nop_landing_pads);\n+            let is_nop_landing_pad = self.is_nop_landing_pad(bb, body, &nop_landing_pads);\n             if is_nop_landing_pad {\n                 nop_landing_pads.insert(bb);\n             }"}, {"sha": "794ced1cb0ef54e2debf353c1f5f8dabdb92890d", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -26,7 +26,7 @@ use crate::dataflow::has_rustc_mir_with;\n pub struct SanityCheck;\n \n impl<'tcx> MirPass<'tcx> for SanityCheck {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         let def_id = src.def_id();\n         if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n@@ -37,44 +37,44 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n \n         let attributes = tcx.get_attrs(def_id);\n         let param_env = tcx.param_env(def_id);\n-        let move_data = MoveData::gather_moves(body_cache, tcx).unwrap();\n+        let move_data = MoveData::gather_moves(body, tcx).unwrap();\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n-        let dead_unwinds = BitSet::new_empty(body_cache.basic_blocks().len());\n+        let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n         let flow_inits =\n-            do_dataflow(tcx, body_cache, def_id, &attributes, &dead_unwinds,\n-                        MaybeInitializedPlaces::new(tcx, body_cache, &mdpe),\n+            do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n+                        MaybeInitializedPlaces::new(tcx, body, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n         let flow_uninits =\n-            do_dataflow(tcx, body_cache, def_id, &attributes, &dead_unwinds,\n-                        MaybeUninitializedPlaces::new(tcx, body_cache, &mdpe),\n+            do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n+                        MaybeUninitializedPlaces::new(tcx, body, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n         let flow_def_inits =\n-            do_dataflow(tcx, body_cache, def_id, &attributes, &dead_unwinds,\n-                        DefinitelyInitializedPlaces::new(tcx, body_cache, &mdpe),\n+            do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n+                        DefinitelyInitializedPlaces::new(tcx, body, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n         let flow_indirectly_mut =\n-            do_dataflow(tcx, body_cache, def_id, &attributes, &dead_unwinds,\n-                        IndirectlyMutableLocals::new(tcx, body_cache, param_env),\n+            do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n+                        IndirectlyMutableLocals::new(tcx, body, param_env),\n                         |_, i| DebugFormatted::new(&i));\n \n         if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_init).is_some() {\n-            sanity_check_via_rustc_peek(tcx, body_cache, def_id, &attributes, &flow_inits);\n+            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_inits);\n         }\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_uninit).is_some() {\n-            sanity_check_via_rustc_peek(tcx, body_cache, def_id, &attributes, &flow_uninits);\n+            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_uninits);\n         }\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_definite_init).is_some() {\n             sanity_check_via_rustc_peek(\n                 tcx,\n-                body_cache,\n+                body,\n                 def_id,\n                 &attributes,\n                 &flow_def_inits);\n         }\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n             sanity_check_via_rustc_peek(\n                 tcx,\n-                body_cache,\n+                body,\n                 def_id,\n                 &attributes,\n                 &flow_indirectly_mut);"}, {"sha": "900752d3ce06c2068bbcb526c140644e4c72afdd", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -43,12 +43,12 @@ impl SimplifyCfg {\n     }\n }\n \n-pub fn simplify_cfg(body_cache: &mut BodyCache<'_>) {\n-    CfgSimplifier::new(body_cache).simplify();\n-    remove_dead_blocks(body_cache);\n+pub fn simplify_cfg(body: &mut BodyCache<'_>) {\n+    CfgSimplifier::new(body).simplify();\n+    remove_dead_blocks(body);\n \n     // FIXME: Should probably be moved into some kind of pass manager\n-    body_cache.basic_blocks_mut().raw.shrink_to_fit();\n+    body.basic_blocks_mut().raw.shrink_to_fit();\n }\n \n impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n@@ -57,10 +57,10 @@ impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n     }\n \n     fn run_pass(\n-        &self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>\n+        &self, _tcx: TyCtxt<'tcx>, _src: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n     ) {\n-        debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body_cache);\n-        simplify_cfg(body_cache);\n+        debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body);\n+        simplify_cfg(body);\n     }\n }\n \n@@ -70,22 +70,22 @@ pub struct CfgSimplifier<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n-    pub fn new(body_cache: &'a mut BodyCache<'tcx>) -> Self {\n-        let mut pred_count = IndexVec::from_elem(0u32, body_cache.basic_blocks());\n+    pub fn new(body: &'a mut BodyCache<'tcx>) -> Self {\n+        let mut pred_count = IndexVec::from_elem(0u32, body.basic_blocks());\n \n         // we can't use mir.predecessors() here because that counts\n         // dead blocks, which we don't want to.\n         pred_count[START_BLOCK] = 1;\n \n-        for (_, data) in traversal::preorder(body_cache) {\n+        for (_, data) in traversal::preorder(body) {\n             if let Some(ref term) = data.terminator {\n                 for &tgt in term.successors() {\n                     pred_count[tgt] += 1;\n                 }\n             }\n         }\n \n-        let basic_blocks = body_cache.basic_blocks_mut();\n+        let basic_blocks = body.basic_blocks_mut();\n \n         CfgSimplifier {\n             basic_blocks,\n@@ -262,13 +262,13 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n     }\n }\n \n-pub fn remove_dead_blocks(body_cache: &mut BodyCache<'_>) {\n-    let mut seen = BitSet::new_empty(body_cache.basic_blocks().len());\n-    for (bb, _) in traversal::preorder(body_cache) {\n+pub fn remove_dead_blocks(body: &mut BodyCache<'_>) {\n+    let mut seen = BitSet::new_empty(body.basic_blocks().len());\n+    for (bb, _) in traversal::preorder(body) {\n         seen.insert(bb.index());\n     }\n \n-    let basic_blocks = body_cache.basic_blocks_mut();\n+    let basic_blocks = body.basic_blocks_mut();\n \n     let num_blocks = basic_blocks.len();\n     let mut replacements : Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n@@ -296,29 +296,29 @@ pub struct SimplifyLocals;\n \n impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n     fn run_pass(\n-        &self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>\n+        &self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyCache<'tcx>\n     ) {\n         trace!(\"running SimplifyLocals on {:?}\", source);\n         let locals = {\n-            let read_only_cache = read_only!(body_cache);\n+            let read_only_cache = read_only!(body);\n             let mut marker = DeclMarker {\n-                locals: BitSet::new_empty(body_cache.local_decls.len()),\n-                body: body_cache,\n+                locals: BitSet::new_empty(body.local_decls.len()),\n+                body,\n             };\n             marker.visit_body(read_only_cache);\n             // Return pointer and arguments are always live\n             marker.locals.insert(RETURN_PLACE);\n-            for arg in body_cache.args_iter() {\n+            for arg in body.args_iter() {\n                 marker.locals.insert(arg);\n             }\n \n             marker.locals\n         };\n \n-        let map = make_local_map(&mut body_cache.local_decls, locals);\n+        let map = make_local_map(&mut body.local_decls, locals);\n         // Update references to all vars and tmps now\n-        LocalUpdater { map, tcx }.visit_body(body_cache);\n-        body_cache.local_decls.shrink_to_fit();\n+        LocalUpdater { map, tcx }.visit_body(body);\n+        body.local_decls.shrink_to_fit();\n     }\n }\n "}, {"sha": "c8d0f37f9a509cbe105df7aea37007d09bb2afbf", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -19,9 +19,9 @@ impl<'tcx> MirPass<'tcx> for SimplifyBranches {\n         Cow::Borrowed(&self.label)\n     }\n \n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n         let param_env = tcx.param_env(src.def_id());\n-        for block in body_cache.basic_blocks_mut() {\n+        for block in body.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {\n                 TerminatorKind::SwitchInt {"}, {"sha": "3fc76ef6b00e000a548ccbaf80329951fb6551ce", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -37,16 +37,16 @@ use crate::util::patch::MirPatch;\n pub struct UniformArrayMoveOut;\n \n impl<'tcx> MirPass<'tcx> for UniformArrayMoveOut {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n-        let mut patch = MirPatch::new(body_cache);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n+        let mut patch = MirPatch::new(body);\n         let param_env = tcx.param_env(src.def_id());\n         {\n-            let read_only_cache = read_only!(body_cache);\n+            let read_only_cache = read_only!(body);\n             let mut visitor\n-                = UniformArrayMoveOutVisitor{ body: body_cache, patch: &mut patch, tcx, param_env};\n+                = UniformArrayMoveOutVisitor{ body, patch: &mut patch, tcx, param_env};\n             visitor.visit_body(read_only_cache);\n         }\n-        patch.apply(body_cache);\n+        patch.apply(body);\n     }\n }\n \n@@ -186,27 +186,27 @@ pub struct RestoreSubsliceArrayMoveOut<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut<'tcx> {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body_cache: &mut BodyCache<'tcx>) {\n-        let mut patch = MirPatch::new(body_cache);\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut BodyCache<'tcx>) {\n+        let mut patch = MirPatch::new(body);\n         let param_env = tcx.param_env(src.def_id());\n         {\n-            let read_only_cache = read_only!(body_cache);\n+            let read_only_cache = read_only!(body);\n             let mut visitor = RestoreDataCollector {\n-                locals_use: IndexVec::from_elem(LocalUse::new(), &body_cache.local_decls),\n+                locals_use: IndexVec::from_elem(LocalUse::new(), &body.local_decls),\n                 candidates: vec![],\n             };\n             visitor.visit_body(read_only_cache);\n \n             for candidate in &visitor.candidates {\n-                let statement = &body_cache[candidate.block].statements[candidate.statement_index];\n+                let statement = &body[candidate.block].statements[candidate.statement_index];\n                 if let StatementKind::Assign(box(ref dst_place, ref rval)) = statement.kind {\n                     if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = *rval {\n                         let items : Vec<_> = items.iter().map(|item| {\n                             if let Operand::Move(place) = item {\n                                 if let Some(local) = place.as_local() {\n                                     let local_use = &visitor.locals_use[local];\n                                     let opt_index_and_place =\n-                                        Self::try_get_item_source(local_use, body_cache);\n+                                        Self::try_get_item_source(local_use, body);\n                                     // each local should be used twice:\n                                     //  in assign and in aggregate statements\n                                     if local_use.use_count == 2 && opt_index_and_place.is_some() {\n@@ -223,7 +223,7 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut<'tcx> {\n                             let src_ty = Place::ty_from(\n                                 src_place.base,\n                                 src_place.projection,\n-                                body_cache,\n+                                &**body,\n                                 tcx\n                             ).ty;\n                             if let ty::Array(_, ref size_o) = src_ty.kind {\n@@ -239,7 +239,7 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut<'tcx> {\n                 }\n             }\n         }\n-        patch.apply(body_cache);\n+        patch.apply(body);\n     }\n }\n "}, {"sha": "632e92d67200acf30f340bfe4bd53cab7389889d", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -30,15 +30,15 @@ impl DefUseAnalysis {\n         }\n     }\n \n-    pub fn analyze(&mut self, body_cache: ReadOnlyBodyCache<'_, '_>) {\n+    pub fn analyze(&mut self, body: ReadOnlyBodyCache<'_, '_>) {\n         self.clear();\n \n         let mut finder = DefUseFinder {\n             info: mem::take(&mut self.info),\n             var_debug_info_index: 0,\n             in_var_debug_info: false,\n         };\n-        finder.visit_body(body_cache);\n+        finder.visit_body(body);\n         self.info = finder.info\n     }\n \n@@ -55,7 +55,7 @@ impl DefUseAnalysis {\n     fn mutate_defs_and_uses(\n         &self,\n         local: Local,\n-        body_cache: &mut BodyCache<'tcx>,\n+        body: &mut BodyCache<'tcx>,\n         new_local: Local,\n         tcx: TyCtxt<'tcx>,\n     ) {\n@@ -66,17 +66,17 @@ impl DefUseAnalysis {\n         }\n         // Update debuginfo as well, alongside defs/uses.\n         for &i in &info.var_debug_info_indices {\n-            visitor.visit_var_debug_info(&mut body_cache.var_debug_info[i]);\n+            visitor.visit_var_debug_info(&mut body.var_debug_info[i]);\n         }\n     }\n \n     // FIXME(pcwalton): this should update the def-use chains.\n     pub fn replace_all_defs_and_uses_with(&self,\n                                           local: Local,\n-                                          body_cache: &mut BodyCache<'tcx>,\n+                                          body: &mut BodyCache<'tcx>,\n                                           new_local: Local,\n                                           tcx: TyCtxt<'tcx>) {\n-        self.mutate_defs_and_uses(local, body_cache, new_local, tcx)\n+        self.mutate_defs_and_uses(local, body, new_local, tcx)\n     }\n }\n "}, {"sha": "334975373e5f35f65d08ef7b9775b0e4a223f13f", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -57,17 +57,17 @@ pub struct LivenessResult {\n /// Computes which local variables are live within the given function\n /// `mir`, including drops.\n pub fn liveness_of_locals(\n-    body_cache: ReadOnlyBodyCache<'_, '_>,\n+    body: ReadOnlyBodyCache<'_, '_>,\n ) -> LivenessResult {\n-    let num_live_vars = body_cache.local_decls.len();\n+    let num_live_vars = body.local_decls.len();\n \n-    let def_use: IndexVec<_, DefsUses> = body_cache\n+    let def_use: IndexVec<_, DefsUses> = body\n         .basic_blocks()\n         .iter()\n         .map(|b| block(b, num_live_vars))\n         .collect();\n \n-    let mut outs: IndexVec<_, LiveVarSet> = body_cache\n+    let mut outs: IndexVec<_, LiveVarSet> = body\n         .basic_blocks()\n         .indices()\n         .map(|_| LiveVarSet::new_empty(num_live_vars))\n@@ -84,18 +84,18 @@ pub fn liveness_of_locals(\n     // order when cycles are present, but the overhead of computing the reverse CFG may outweigh\n     // any benefits. Benchmark this and find out.\n     let mut dirty_queue: WorkQueue<BasicBlock>\n-        = WorkQueue::with_none(body_cache.basic_blocks().len());\n-    for (bb, _) in traversal::postorder(&body_cache) {\n+        = WorkQueue::with_none(body.basic_blocks().len());\n+    for (bb, _) in traversal::postorder(&body) {\n         dirty_queue.insert(bb);\n     }\n \n     // Add blocks which are not reachable from START_BLOCK to the work queue. These blocks will\n     // be processed after the ones added above.\n-    for bb in body_cache.basic_blocks().indices() {\n+    for bb in body.basic_blocks().indices() {\n         dirty_queue.insert(bb);\n     }\n \n-    let predecessors = body_cache.predecessors();\n+    let predecessors = body.predecessors();\n \n     while let Some(bb) = dirty_queue.pop() {\n         // bits = use \u222a (bits - def)"}, {"sha": "47bb0b699c048537e8fd4fb6b578c916202c256d", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2fe254c989b053c4320c023b101b8736a50866c/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=b2fe254c989b053c4320c023b101b8736a50866c", "patch": "@@ -127,21 +127,21 @@ impl<'tcx> MirPatch<'tcx> {\n         self.make_nop.push(loc);\n     }\n \n-    pub fn apply(self, body_cache: &mut BodyCache<'tcx>) {\n+    pub fn apply(self, body: &mut BodyCache<'tcx>) {\n         debug!(\"MirPatch: make nops at: {:?}\", self.make_nop);\n         for loc in self.make_nop {\n-            body_cache.make_statement_nop(loc);\n+            body.make_statement_nop(loc);\n         }\n         debug!(\"MirPatch: {:?} new temps, starting from index {}: {:?}\",\n-               self.new_locals.len(), body_cache.local_decls.len(), self.new_locals);\n+               self.new_locals.len(), body.local_decls.len(), self.new_locals);\n         debug!(\"MirPatch: {} new blocks, starting from index {}\",\n-               self.new_blocks.len(), body_cache.basic_blocks().len());\n-        body_cache.basic_blocks_mut().extend(self.new_blocks);\n-        body_cache.local_decls.extend(self.new_locals);\n+               self.new_blocks.len(), body.basic_blocks().len());\n+        body.basic_blocks_mut().extend(self.new_blocks);\n+        body.local_decls.extend(self.new_locals);\n         for (src, patch) in self.patch_map.into_iter_enumerated() {\n             if let Some(patch) = patch {\n                 debug!(\"MirPatch: patching block {:?}\", src);\n-                body_cache[src].terminator_mut().kind = patch;\n+                body[src].terminator_mut().kind = patch;\n             }\n         }\n \n@@ -159,9 +159,9 @@ impl<'tcx> MirPatch<'tcx> {\n                    stmt, loc, delta);\n             loc.statement_index += delta;\n             let source_info = Self::source_info_for_index(\n-                &body_cache[loc.block], loc\n+                &body[loc.block], loc\n             );\n-            body_cache[loc.block].statements.insert(\n+            body[loc.block].statements.insert(\n                 loc.statement_index, Statement {\n                     source_info,\n                     kind: stmt"}]}