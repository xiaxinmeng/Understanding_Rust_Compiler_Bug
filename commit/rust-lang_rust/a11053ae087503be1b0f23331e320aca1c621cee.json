{"sha": "a11053ae087503be1b0f23331e320aca1c621cee", "node_id": "C_kwDOAAsO6NoAKGExMTA1M2FlMDg3NTAzYmUxYjBmMjMzMzFlMzIwYWNhMWM2MjFjZWU", "commit": {"author": {"name": "nils", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-04-11T12:14:02Z"}, "committer": {"name": "nils", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-04-11T12:23:31Z"}, "message": "Remove orphaned remove_dir_all implementation from rust-installer\n\nI have no idea why it's here, but it's not used at all.", "tree": {"sha": "c2b5297f1dd9bd95ec38139d37e4bf396d00cbc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2b5297f1dd9bd95ec38139d37e4bf396d00cbc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a11053ae087503be1b0f23331e320aca1c621cee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a11053ae087503be1b0f23331e320aca1c621cee", "html_url": "https://github.com/rust-lang/rust/commit/a11053ae087503be1b0f23331e320aca1c621cee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a11053ae087503be1b0f23331e320aca1c621cee/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "932c173ca1b7a79c1005e2d72ddfa505a7bf2cfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/932c173ca1b7a79c1005e2d72ddfa505a7bf2cfa", "html_url": "https://github.com/rust-lang/rust/commit/932c173ca1b7a79c1005e2d72ddfa505a7bf2cfa"}], "stats": {"total": 866, "additions": 0, "deletions": 866}, "files": [{"sha": "ae12bbd8789e74858898f801ef99ecf9f38529c5", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a11053ae087503be1b0f23331e320aca1c621cee/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a11053ae087503be1b0f23331e320aca1c621cee/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a11053ae087503be1b0f23331e320aca1c621cee", "patch": "@@ -2774,13 +2774,11 @@ dependencies = [\n  \"anyhow\",\n  \"clap 3.2.20\",\n  \"flate2\",\n- \"lazy_static\",\n  \"num_cpus\",\n  \"rayon\",\n  \"remove_dir_all\",\n  \"tar\",\n  \"walkdir\",\n- \"winapi\",\n  \"xz2\",\n ]\n "}, {"sha": "97734f048ab33174492d2303bcebfc8d679032c6", "filename": "src/tools/rust-installer/Cargo.toml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a11053ae087503be1b0f23331e320aca1c621cee/src%2Ftools%2Frust-installer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a11053ae087503be1b0f23331e320aca1c621cee/src%2Ftools%2Frust-installer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2FCargo.toml?ref=a11053ae087503be1b0f23331e320aca1c621cee", "patch": "@@ -22,7 +22,3 @@ remove_dir_all = \"0.5\"\n [dependencies.clap]\n features = [\"derive\"]\n version = \"3.1\"\n-\n-[target.\"cfg(windows)\".dependencies]\n-lazy_static = \"1\"\n-winapi = { version = \"0.3\", features = [\"errhandlingapi\", \"handleapi\", \"ioapiset\", \"winerror\", \"winioctl\", \"winnt\"] }"}, {"sha": "11097652865c4221bbddffce70c35744c29fee0a", "filename": "src/tools/rust-installer/src/remove_dir_all.rs", "status": "removed", "additions": 0, "deletions": 860, "changes": 860, "blob_url": "https://github.com/rust-lang/rust/blob/932c173ca1b7a79c1005e2d72ddfa505a7bf2cfa/src%2Ftools%2Frust-installer%2Fsrc%2Fremove_dir_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932c173ca1b7a79c1005e2d72ddfa505a7bf2cfa/src%2Ftools%2Frust-installer%2Fsrc%2Fremove_dir_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer%2Fsrc%2Fremove_dir_all.rs?ref=932c173ca1b7a79c1005e2d72ddfa505a7bf2cfa", "patch": "@@ -1,860 +0,0 @@\n-#![allow(non_snake_case)]\n-\n-use std::io;\n-use std::path::Path;\n-\n-#[cfg(not(windows))]\n-pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-    ::std::fs::remove_dir_all(path)\n-}\n-\n-#[cfg(windows)]\n-pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-    win::remove_dir_all(path)\n-}\n-\n-#[cfg(windows)]\n-mod win {\n-    use winapi::ctypes::{c_uint, c_ushort};\n-    use winapi::shared::minwindef::{BOOL, DWORD, FALSE, FILETIME, LPVOID};\n-    use winapi::shared::winerror::{\n-        ERROR_CALL_NOT_IMPLEMENTED, ERROR_INSUFFICIENT_BUFFER, ERROR_NO_MORE_FILES,\n-    };\n-    use winapi::um::errhandlingapi::{GetLastError, SetLastError};\n-    use winapi::um::fileapi::{\n-        CreateFileW, FindFirstFileW, FindNextFileW, GetFileInformationByHandle,\n-    };\n-    use winapi::um::fileapi::{BY_HANDLE_FILE_INFORMATION, CREATE_ALWAYS, CREATE_NEW};\n-    use winapi::um::fileapi::{FILE_BASIC_INFO, FILE_RENAME_INFO, TRUNCATE_EXISTING};\n-    use winapi::um::fileapi::{OPEN_ALWAYS, OPEN_EXISTING};\n-    use winapi::um::handleapi::{CloseHandle, INVALID_HANDLE_VALUE};\n-    use winapi::um::ioapiset::DeviceIoControl;\n-    use winapi::um::libloaderapi::{GetModuleHandleW, GetProcAddress};\n-    use winapi::um::minwinbase::{\n-        FileBasicInfo, FileRenameInfo, FILE_INFO_BY_HANDLE_CLASS, WIN32_FIND_DATAW,\n-    };\n-    use winapi::um::winbase::SECURITY_SQOS_PRESENT;\n-    use winapi::um::winbase::{\n-        FILE_FLAG_BACKUP_SEMANTICS, FILE_FLAG_DELETE_ON_CLOSE, FILE_FLAG_OPEN_REPARSE_POINT,\n-    };\n-    use winapi::um::winioctl::FSCTL_GET_REPARSE_POINT;\n-    use winapi::um::winnt::{DELETE, FILE_ATTRIBUTE_DIRECTORY, HANDLE, LPCWSTR};\n-    use winapi::um::winnt::{FILE_ATTRIBUTE_READONLY, FILE_ATTRIBUTE_REPARSE_POINT};\n-    use winapi::um::winnt::{FILE_GENERIC_WRITE, FILE_WRITE_DATA, GENERIC_READ, GENERIC_WRITE};\n-    use winapi::um::winnt::{FILE_READ_ATTRIBUTES, FILE_WRITE_ATTRIBUTES};\n-    use winapi::um::winnt::{FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE};\n-    use winapi::um::winnt::{IO_REPARSE_TAG_MOUNT_POINT, IO_REPARSE_TAG_SYMLINK, LARGE_INTEGER};\n-\n-    use std::ffi::{OsStr, OsString};\n-    use std::io;\n-    use std::mem;\n-    use std::os::windows::ffi::{OsStrExt, OsStringExt};\n-    use std::path::{Path, PathBuf};\n-    use std::ptr;\n-    use std::sync::Arc;\n-\n-    pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-        // On Windows it is not enough to just recursively remove the contents of a\n-        // directory and then the directory itself. Deleting does not happen\n-        // instantaneously, but is scheduled.\n-        // To work around this, we move the file or directory to some `base_dir`\n-        // right before deletion to avoid races.\n-        //\n-        // As `base_dir` we choose the parent dir of the directory we want to\n-        // remove. We very probably have permission to create files here, as we\n-        // already need write permission in this dir to delete the directory. And it\n-        // should be on the same volume.\n-        //\n-        // To handle files with names like `CON` and `morse .. .`, and when a\n-        // directory structure is so deep it needs long path names the path is first\n-        // converted to a `//?/`-path with `get_path()`.\n-        //\n-        // To make sure we don't leave a moved file laying around if the process\n-        // crashes before we can delete the file, we do all operations on an file\n-        // handle. By opening a file with `FILE_FLAG_DELETE_ON_CLOSE` Windows will\n-        // always delete the file when the handle closes.\n-        //\n-        // All files are renamed to be in the `base_dir`, and have their name\n-        // changed to \"rm-<counter>\". After every rename the counter is increased.\n-        // Rename should not overwrite possibly existing files in the base dir. So\n-        // if it fails with `AlreadyExists`, we just increase the counter and try\n-        // again.\n-        //\n-        // For read-only files and directories we first have to remove the read-only\n-        // attribute before we can move or delete them. This also removes the\n-        // attribute from possible hardlinks to the file, so just before closing we\n-        // restore the read-only attribute.\n-        //\n-        // If 'path' points to a directory symlink or junction we should not\n-        // recursively remove the target of the link, but only the link itself.\n-        //\n-        // Moving and deleting is guaranteed to succeed if we are able to open the\n-        // file with `DELETE` permission. If others have the file open we only have\n-        // `DELETE` permission if they have specified `FILE_SHARE_DELETE`. We can\n-        // also delete the file now, but it will not disappear until all others have\n-        // closed the file. But no-one can open the file after we have flagged it\n-        // for deletion.\n-\n-        // Open the path once to get the canonical path, file type and attributes.\n-        let (path, metadata) = {\n-            let mut opts = OpenOptions::new();\n-            opts.access_mode(FILE_READ_ATTRIBUTES);\n-            opts.custom_flags(FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT);\n-            let file = File::open(path, &opts)?;\n-            (get_path(&file)?, file.file_attr()?)\n-        };\n-\n-        let mut ctx = RmdirContext {\n-            base_dir: match path.parent() {\n-                Some(dir) => dir,\n-                None => {\n-                    return Err(io::Error::new(\n-                        io::ErrorKind::PermissionDenied,\n-                        \"can't delete root directory\",\n-                    ))\n-                }\n-            },\n-            readonly: metadata.perm().readonly(),\n-            counter: 0,\n-        };\n-\n-        let filetype = metadata.file_type();\n-        if filetype.is_dir() {\n-            remove_dir_all_recursive(path.as_ref(), &mut ctx)\n-        } else if filetype.is_symlink_dir() {\n-            remove_item(path.as_ref(), &mut ctx)\n-        } else {\n-            Err(io::Error::new(\n-                io::ErrorKind::PermissionDenied,\n-                \"Not a directory\",\n-            ))\n-        }\n-    }\n-\n-    fn readdir(p: &Path) -> io::Result<ReadDir> {\n-        let root = p.to_path_buf();\n-        let star = p.join(\"*\");\n-        let path = to_u16s(&star)?;\n-\n-        unsafe {\n-            let mut wfd = mem::zeroed();\n-            let find_handle = FindFirstFileW(path.as_ptr(), &mut wfd);\n-            if find_handle != INVALID_HANDLE_VALUE {\n-                Ok(ReadDir {\n-                    handle: FindNextFileHandle(find_handle),\n-                    root: Arc::new(root),\n-                    first: Some(wfd),\n-                })\n-            } else {\n-                Err(io::Error::last_os_error())\n-            }\n-        }\n-    }\n-\n-    struct RmdirContext<'a> {\n-        base_dir: &'a Path,\n-        readonly: bool,\n-        counter: u64,\n-    }\n-\n-    fn remove_dir_all_recursive(path: &Path, ctx: &mut RmdirContext) -> io::Result<()> {\n-        let dir_readonly = ctx.readonly;\n-        for child in readdir(path)? {\n-            let child = child?;\n-            let child_type = child.file_type()?;\n-            ctx.readonly = child.metadata()?.perm().readonly();\n-            if child_type.is_dir() {\n-                remove_dir_all_recursive(&child.path(), ctx)?;\n-            } else {\n-                remove_item(&child.path().as_ref(), ctx)?;\n-            }\n-        }\n-        ctx.readonly = dir_readonly;\n-        remove_item(path, ctx)\n-    }\n-\n-    fn remove_item(path: &Path, ctx: &mut RmdirContext) -> io::Result<()> {\n-        if !ctx.readonly {\n-            let mut opts = OpenOptions::new();\n-            opts.access_mode(DELETE);\n-            opts.custom_flags(\n-                FILE_FLAG_BACKUP_SEMANTICS | // delete directory\n-                              FILE_FLAG_OPEN_REPARSE_POINT | // delete symlink\n-                              FILE_FLAG_DELETE_ON_CLOSE,\n-            );\n-            let file = File::open(path, &opts)?;\n-            move_item(&file, ctx)\n-        } else {\n-            // remove read-only permision\n-            set_perm(&path, FilePermissions::new())?;\n-            // move and delete file, similar to !readonly.\n-            // only the access mode is different.\n-            let mut opts = OpenOptions::new();\n-            opts.access_mode(DELETE | FILE_WRITE_ATTRIBUTES);\n-            opts.custom_flags(\n-                FILE_FLAG_BACKUP_SEMANTICS\n-                    | FILE_FLAG_OPEN_REPARSE_POINT\n-                    | FILE_FLAG_DELETE_ON_CLOSE,\n-            );\n-            let file = File::open(path, &opts)?;\n-            move_item(&file, ctx)?;\n-            // restore read-only flag just in case there are other hard links\n-            let mut perm = FilePermissions::new();\n-            perm.set_readonly(true);\n-            let _ = file.set_perm(perm); // ignore if this fails\n-            Ok(())\n-        }\n-    }\n-\n-    macro_rules! compat_fn {\n-        ($module:ident: $(\n-            fn $symbol:ident($($argname:ident: $argtype:ty),*)\n-                             -> $rettype:ty {\n-                $($body:expr);*\n-            }\n-        )*) => ($(\n-            #[allow(unused_variables)]\n-            unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n-                use std::sync::atomic::{AtomicUsize, Ordering};\n-                use std::mem;\n-                use std::ffi::CString;\n-                type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n-\n-                lazy_static! { static ref PTR: AtomicUsize = AtomicUsize::new(0);}\n-\n-                fn lookup(module: &str, symbol: &str) -> Option<usize> {\n-                    let mut module: Vec<u16> = module.encode_utf16().collect();\n-                    module.push(0);\n-                    let symbol = CString::new(symbol).unwrap();\n-                    unsafe {\n-                        let handle = GetModuleHandleW(module.as_ptr());\n-                        match GetProcAddress(handle, symbol.as_ptr()) as usize {\n-                            0 => None,\n-                            n => Some(n),\n-                        }\n-                    }\n-                }\n-\n-                fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,\n-                              fallback: usize) -> usize {\n-                    let value = lookup(module, symbol).unwrap_or(fallback);\n-                    ptr.store(value, Ordering::SeqCst);\n-                    value\n-                }\n-\n-                fn load() -> usize {\n-                    store_func(&PTR, stringify!($module), stringify!($symbol), fallback as usize)\n-                }\n-                unsafe extern \"system\" fn fallback($($argname: $argtype),*)\n-                                                   -> $rettype {\n-                    $($body);*\n-                }\n-\n-                let addr = match PTR.load(Ordering::SeqCst) {\n-                    0 => load(),\n-                    n => n,\n-                };\n-                mem::transmute::<usize, F>(addr)($($argname),*)\n-            }\n-        )*)\n-    }\n-\n-    compat_fn! {\n-        kernel32:\n-        fn GetFinalPathNameByHandleW(_hFile: HANDLE,\n-                                     _lpszFilePath: LPCWSTR,\n-                                     _cchFilePath: DWORD,\n-                                     _dwFlags: DWORD) -> DWORD {\n-            SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n-        }\n-        fn SetFileInformationByHandle(_hFile: HANDLE,\n-                                      _FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n-                                      _lpFileInformation: LPVOID,\n-                                      _dwBufferSize: DWORD) -> BOOL {\n-            SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n-        }\n-    }\n-\n-    fn cvt(i: i32) -> io::Result<i32> {\n-        if i == 0 {\n-            Err(io::Error::last_os_error())\n-        } else {\n-            Ok(i)\n-        }\n-    }\n-\n-    fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n-        fn inner(s: &OsStr) -> io::Result<Vec<u16>> {\n-            let mut maybe_result: Vec<u16> = s.encode_wide().collect();\n-            if maybe_result.iter().any(|&u| u == 0) {\n-                return Err(io::Error::new(\n-                    io::ErrorKind::InvalidInput,\n-                    \"strings passed to WinAPI cannot contain NULs\",\n-                ));\n-            }\n-            maybe_result.push(0);\n-            Ok(maybe_result)\n-        }\n-        inner(s.as_ref())\n-    }\n-\n-    fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n-        match v.iter().position(|c| *c == 0) {\n-            // don't include the 0\n-            Some(i) => &v[..i],\n-            None => v,\n-        }\n-    }\n-\n-    fn fill_utf16_buf<F1, F2, T>(mut f1: F1, f2: F2) -> io::Result<T>\n-    where\n-        F1: FnMut(*mut u16, DWORD) -> DWORD,\n-        F2: FnOnce(&[u16]) -> T,\n-    {\n-        // Start off with a stack buf but then spill over to the heap if we end up\n-        // needing more space.\n-        let mut stack_buf = [0u16; 512];\n-        let mut heap_buf = Vec::new();\n-        unsafe {\n-            let mut n = stack_buf.len();\n-            loop {\n-                let buf = if n <= stack_buf.len() {\n-                    &mut stack_buf[..]\n-                } else {\n-                    let extra = n - heap_buf.len();\n-                    heap_buf.reserve(extra);\n-                    heap_buf.set_len(n);\n-                    &mut heap_buf[..]\n-                };\n-\n-                // This function is typically called on windows API functions which\n-                // will return the correct length of the string, but these functions\n-                // also return the `0` on error. In some cases, however, the\n-                // returned \"correct length\" may actually be 0!\n-                //\n-                // To handle this case we call `SetLastError` to reset it to 0 and\n-                // then check it again if we get the \"0 error value\". If the \"last\n-                // error\" is still 0 then we interpret it as a 0 length buffer and\n-                // not an actual error.\n-                SetLastError(0);\n-                let k = match f1(buf.as_mut_ptr(), n as DWORD) {\n-                    0 if GetLastError() == 0 => 0,\n-                    0 => return Err(io::Error::last_os_error()),\n-                    n => n,\n-                } as usize;\n-                if k == n && GetLastError() == ERROR_INSUFFICIENT_BUFFER {\n-                    n *= 2;\n-                } else if k >= n {\n-                    n = k;\n-                } else {\n-                    return Ok(f2(&buf[..k]));\n-                }\n-            }\n-        }\n-    }\n-\n-    #[derive(Clone, PartialEq, Eq, Debug, Default)]\n-    struct FilePermissions {\n-        readonly: bool,\n-    }\n-\n-    impl FilePermissions {\n-        fn new() -> FilePermissions {\n-            Default::default()\n-        }\n-        fn readonly(&self) -> bool {\n-            self.readonly\n-        }\n-        fn set_readonly(&mut self, readonly: bool) {\n-            self.readonly = readonly\n-        }\n-    }\n-\n-    #[derive(Clone)]\n-    struct OpenOptions {\n-        // generic\n-        read: bool,\n-        write: bool,\n-        append: bool,\n-        truncate: bool,\n-        create: bool,\n-        create_new: bool,\n-        // system-specific\n-        custom_flags: u32,\n-        access_mode: Option<DWORD>,\n-        attributes: DWORD,\n-        share_mode: DWORD,\n-        security_qos_flags: DWORD,\n-        security_attributes: usize, // FIXME: should be a reference\n-    }\n-\n-    impl OpenOptions {\n-        fn new() -> OpenOptions {\n-            OpenOptions {\n-                // generic\n-                read: false,\n-                write: false,\n-                append: false,\n-                truncate: false,\n-                create: false,\n-                create_new: false,\n-                // system-specific\n-                custom_flags: 0,\n-                access_mode: None,\n-                share_mode: FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n-                attributes: 0,\n-                security_qos_flags: 0,\n-                security_attributes: 0,\n-            }\n-        }\n-        fn custom_flags(&mut self, flags: u32) {\n-            self.custom_flags = flags;\n-        }\n-        fn access_mode(&mut self, access_mode: u32) {\n-            self.access_mode = Some(access_mode);\n-        }\n-\n-        fn get_access_mode(&self) -> io::Result<DWORD> {\n-            const ERROR_INVALID_PARAMETER: i32 = 87;\n-\n-            match (self.read, self.write, self.append, self.access_mode) {\n-                (_, _, _, Some(mode)) => Ok(mode),\n-                (true, false, false, None) => Ok(GENERIC_READ),\n-                (false, true, false, None) => Ok(GENERIC_WRITE),\n-                (true, true, false, None) => Ok(GENERIC_READ | GENERIC_WRITE),\n-                (false, _, true, None) => Ok(FILE_GENERIC_WRITE & !FILE_WRITE_DATA),\n-                (true, _, true, None) => Ok(GENERIC_READ | (FILE_GENERIC_WRITE & !FILE_WRITE_DATA)),\n-                (false, false, false, None) => {\n-                    Err(io::Error::from_raw_os_error(ERROR_INVALID_PARAMETER))\n-                }\n-            }\n-        }\n-\n-        fn get_creation_mode(&self) -> io::Result<DWORD> {\n-            const ERROR_INVALID_PARAMETER: i32 = 87;\n-\n-            match (self.write, self.append) {\n-                (true, false) => {}\n-                (false, false) => {\n-                    if self.truncate || self.create || self.create_new {\n-                        return Err(io::Error::from_raw_os_error(ERROR_INVALID_PARAMETER));\n-                    }\n-                }\n-                (_, true) => {\n-                    if self.truncate && !self.create_new {\n-                        return Err(io::Error::from_raw_os_error(ERROR_INVALID_PARAMETER));\n-                    }\n-                }\n-            }\n-\n-            Ok(match (self.create, self.truncate, self.create_new) {\n-                (false, false, false) => OPEN_EXISTING,\n-                (true, false, false) => OPEN_ALWAYS,\n-                (false, true, false) => TRUNCATE_EXISTING,\n-                (true, true, false) => CREATE_ALWAYS,\n-                (_, _, true) => CREATE_NEW,\n-            })\n-        }\n-\n-        fn get_flags_and_attributes(&self) -> DWORD {\n-            self.custom_flags\n-                | self.attributes\n-                | self.security_qos_flags\n-                | if self.security_qos_flags != 0 {\n-                    SECURITY_SQOS_PRESENT\n-                } else {\n-                    0\n-                }\n-                | if self.create_new {\n-                    FILE_FLAG_OPEN_REPARSE_POINT\n-                } else {\n-                    0\n-                }\n-        }\n-    }\n-\n-    struct File {\n-        handle: Handle,\n-    }\n-\n-    impl File {\n-        fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-            let path = to_u16s(path)?;\n-            let handle = unsafe {\n-                CreateFileW(\n-                    path.as_ptr(),\n-                    opts.get_access_mode()?,\n-                    opts.share_mode,\n-                    opts.security_attributes as *mut _,\n-                    opts.get_creation_mode()?,\n-                    opts.get_flags_and_attributes(),\n-                    ptr::null_mut(),\n-                )\n-            };\n-            if handle == INVALID_HANDLE_VALUE {\n-                Err(io::Error::last_os_error())\n-            } else {\n-                Ok(File {\n-                    handle: Handle::new(handle),\n-                })\n-            }\n-        }\n-\n-        fn file_attr(&self) -> io::Result<FileAttr> {\n-            unsafe {\n-                let mut info: BY_HANDLE_FILE_INFORMATION = mem::zeroed();\n-                cvt(GetFileInformationByHandle(self.handle.raw(), &mut info))?;\n-                let mut attr = FileAttr {\n-                    attributes: info.dwFileAttributes,\n-                    creation_time: info.ftCreationTime,\n-                    last_access_time: info.ftLastAccessTime,\n-                    last_write_time: info.ftLastWriteTime,\n-                    file_size: ((info.nFileSizeHigh as u64) << 32) | (info.nFileSizeLow as u64),\n-                    reparse_tag: 0,\n-                };\n-                if attr.is_reparse_point() {\n-                    let mut b = [0; MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-                    if let Ok((_, buf)) = self.reparse_point(&mut b) {\n-                        attr.reparse_tag = buf.ReparseTag;\n-                    }\n-                }\n-                Ok(attr)\n-            }\n-        }\n-\n-        fn set_attributes(&self, attr: DWORD) -> io::Result<()> {\n-            let zero: LARGE_INTEGER = unsafe { mem::zeroed() };\n-\n-            let mut info = FILE_BASIC_INFO {\n-                CreationTime: zero,   // do not change\n-                LastAccessTime: zero, // do not change\n-                LastWriteTime: zero,  // do not change\n-                ChangeTime: zero,     // do not change\n-                FileAttributes: attr,\n-            };\n-            let size = mem::size_of_val(&info);\n-            cvt(unsafe {\n-                SetFileInformationByHandle(\n-                    self.handle.raw(),\n-                    FileBasicInfo,\n-                    &mut info as *mut _ as *mut _,\n-                    size as DWORD,\n-                )\n-            })?;\n-            Ok(())\n-        }\n-\n-        fn rename(&self, new: &Path, replace: bool) -> io::Result<()> {\n-            // &self must be opened with DELETE permission\n-            use std::iter;\n-            #[cfg(target_arch = \"x86\")]\n-            const STRUCT_SIZE: usize = 12;\n-            #[cfg(target_arch = \"x86_64\")]\n-            const STRUCT_SIZE: usize = 20;\n-\n-            // FIXME: check for internal NULs in 'new'\n-            let mut data: Vec<u16> = iter::repeat(0u16)\n-                .take(STRUCT_SIZE / 2)\n-                .chain(new.as_os_str().encode_wide())\n-                .collect();\n-            data.push(0);\n-            let size = data.len() * 2;\n-\n-            unsafe {\n-                // Thanks to alignment guarantees on Windows this works\n-                // (8 for 32-bit and 16 for 64-bit)\n-                let info = data.as_mut_ptr() as *mut FILE_RENAME_INFO;\n-                // The type of ReplaceIfExists is BOOL, but it actually expects a\n-                // BOOLEAN. This means true is -1, not c::TRUE.\n-                (*info).ReplaceIfExists = if replace { -1 } else { FALSE };\n-                (*info).RootDirectory = ptr::null_mut();\n-                (*info).FileNameLength = (size - STRUCT_SIZE) as DWORD;\n-                cvt(SetFileInformationByHandle(\n-                    self.handle().raw(),\n-                    FileRenameInfo,\n-                    data.as_mut_ptr() as *mut _ as *mut _,\n-                    size as DWORD,\n-                ))?;\n-                Ok(())\n-            }\n-        }\n-        fn set_perm(&self, perm: FilePermissions) -> io::Result<()> {\n-            let attr = self.file_attr()?.attributes;\n-            if perm.readonly == (attr & FILE_ATTRIBUTE_READONLY != 0) {\n-                Ok(())\n-            } else if perm.readonly {\n-                self.set_attributes(attr | FILE_ATTRIBUTE_READONLY)\n-            } else {\n-                self.set_attributes(attr & !FILE_ATTRIBUTE_READONLY)\n-            }\n-        }\n-\n-        fn handle(&self) -> &Handle {\n-            &self.handle\n-        }\n-\n-        fn reparse_point<'a>(\n-            &self,\n-            space: &'a mut [u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE],\n-        ) -> io::Result<(DWORD, &'a REPARSE_DATA_BUFFER)> {\n-            unsafe {\n-                let mut bytes = 0;\n-                cvt({\n-                    DeviceIoControl(\n-                        self.handle.raw(),\n-                        FSCTL_GET_REPARSE_POINT,\n-                        ptr::null_mut(),\n-                        0,\n-                        space.as_mut_ptr() as *mut _,\n-                        space.len() as DWORD,\n-                        &mut bytes,\n-                        ptr::null_mut(),\n-                    )\n-                })?;\n-                Ok((bytes, &*(space.as_ptr() as *const REPARSE_DATA_BUFFER)))\n-            }\n-        }\n-    }\n-\n-    #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-    enum FileType {\n-        Dir,\n-        File,\n-        SymlinkFile,\n-        SymlinkDir,\n-        ReparsePoint,\n-        MountPoint,\n-    }\n-\n-    impl FileType {\n-        fn new(attrs: DWORD, reparse_tag: DWORD) -> FileType {\n-            match (\n-                attrs & FILE_ATTRIBUTE_DIRECTORY != 0,\n-                attrs & FILE_ATTRIBUTE_REPARSE_POINT != 0,\n-                reparse_tag,\n-            ) {\n-                (false, false, _) => FileType::File,\n-                (true, false, _) => FileType::Dir,\n-                (false, true, IO_REPARSE_TAG_SYMLINK) => FileType::SymlinkFile,\n-                (true, true, IO_REPARSE_TAG_SYMLINK) => FileType::SymlinkDir,\n-                (true, true, IO_REPARSE_TAG_MOUNT_POINT) => FileType::MountPoint,\n-                (_, true, _) => FileType::ReparsePoint,\n-                // Note: if a _file_ has a reparse tag of the type IO_REPARSE_TAG_MOUNT_POINT it is\n-                // invalid, as junctions always have to be dirs. We set the filetype to ReparsePoint\n-                // to indicate it is something symlink-like, but not something you can follow.\n-            }\n-        }\n-\n-        fn is_dir(&self) -> bool {\n-            *self == FileType::Dir\n-        }\n-        fn is_symlink_dir(&self) -> bool {\n-            *self == FileType::SymlinkDir || *self == FileType::MountPoint\n-        }\n-    }\n-\n-    impl DirEntry {\n-        fn new(root: &Arc<PathBuf>, wfd: &WIN32_FIND_DATAW) -> Option<DirEntry> {\n-            let first_bytes = &wfd.cFileName[0..3];\n-            if first_bytes.starts_with(&[46, 0]) || first_bytes.starts_with(&[46, 46, 0]) {\n-                None\n-            } else {\n-                Some(DirEntry {\n-                    root: root.clone(),\n-                    data: *wfd,\n-                })\n-            }\n-        }\n-\n-        fn path(&self) -> PathBuf {\n-            self.root.join(&self.file_name())\n-        }\n-\n-        fn file_name(&self) -> OsString {\n-            let filename = truncate_utf16_at_nul(&self.data.cFileName);\n-            OsString::from_wide(filename)\n-        }\n-\n-        fn file_type(&self) -> io::Result<FileType> {\n-            Ok(FileType::new(\n-                self.data.dwFileAttributes,\n-                /* reparse_tag = */ self.data.dwReserved0,\n-            ))\n-        }\n-\n-        fn metadata(&self) -> io::Result<FileAttr> {\n-            Ok(FileAttr {\n-                attributes: self.data.dwFileAttributes,\n-                creation_time: self.data.ftCreationTime,\n-                last_access_time: self.data.ftLastAccessTime,\n-                last_write_time: self.data.ftLastWriteTime,\n-                file_size: ((self.data.nFileSizeHigh as u64) << 32)\n-                    | (self.data.nFileSizeLow as u64),\n-                reparse_tag: if self.data.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n-                    // reserved unless this is a reparse point\n-                    self.data.dwReserved0\n-                } else {\n-                    0\n-                },\n-            })\n-        }\n-    }\n-\n-    struct DirEntry {\n-        root: Arc<PathBuf>,\n-        data: WIN32_FIND_DATAW,\n-    }\n-\n-    struct ReadDir {\n-        handle: FindNextFileHandle,\n-        root: Arc<PathBuf>,\n-        first: Option<WIN32_FIND_DATAW>,\n-    }\n-\n-    impl Iterator for ReadDir {\n-        type Item = io::Result<DirEntry>;\n-        fn next(&mut self) -> Option<io::Result<DirEntry>> {\n-            if let Some(first) = self.first.take() {\n-                if let Some(e) = DirEntry::new(&self.root, &first) {\n-                    return Some(Ok(e));\n-                }\n-            }\n-            unsafe {\n-                let mut wfd = mem::zeroed();\n-                loop {\n-                    if FindNextFileW(self.handle.0, &mut wfd) == 0 {\n-                        if GetLastError() == ERROR_NO_MORE_FILES {\n-                            return None;\n-                        } else {\n-                            return Some(Err(io::Error::last_os_error()));\n-                        }\n-                    }\n-                    if let Some(e) = DirEntry::new(&self.root, &wfd) {\n-                        return Some(Ok(e));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[derive(Clone)]\n-    struct FileAttr {\n-        attributes: DWORD,\n-        creation_time: FILETIME,\n-        last_access_time: FILETIME,\n-        last_write_time: FILETIME,\n-        file_size: u64,\n-        reparse_tag: DWORD,\n-    }\n-\n-    impl FileAttr {\n-        fn perm(&self) -> FilePermissions {\n-            FilePermissions {\n-                readonly: self.attributes & FILE_ATTRIBUTE_READONLY != 0,\n-            }\n-        }\n-\n-        fn file_type(&self) -> FileType {\n-            FileType::new(self.attributes, self.reparse_tag)\n-        }\n-\n-        fn is_reparse_point(&self) -> bool {\n-            self.attributes & FILE_ATTRIBUTE_REPARSE_POINT != 0\n-        }\n-    }\n-\n-    #[repr(C)]\n-    struct REPARSE_DATA_BUFFER {\n-        ReparseTag: c_uint,\n-        ReparseDataLength: c_ushort,\n-        Reserved: c_ushort,\n-        rest: (),\n-    }\n-\n-    const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\n-\n-    /// An owned container for `HANDLE` object, closing them on Drop.\n-    ///\n-    /// All methods are inherited through a `Deref` impl to `RawHandle`\n-    struct Handle(RawHandle);\n-\n-    use std::ops::Deref;\n-\n-    /// A wrapper type for `HANDLE` objects to give them proper Send/Sync inference\n-    /// as well as Rust-y methods.\n-    ///\n-    /// This does **not** drop the handle when it goes out of scope, use `Handle`\n-    /// instead for that.\n-    #[derive(Copy, Clone)]\n-    struct RawHandle(HANDLE);\n-\n-    unsafe impl Send for RawHandle {}\n-    unsafe impl Sync for RawHandle {}\n-\n-    impl Handle {\n-        fn new(handle: HANDLE) -> Handle {\n-            Handle(RawHandle::new(handle))\n-        }\n-    }\n-\n-    impl Deref for Handle {\n-        type Target = RawHandle;\n-        fn deref(&self) -> &RawHandle {\n-            &self.0\n-        }\n-    }\n-\n-    impl Drop for Handle {\n-        fn drop(&mut self) {\n-            unsafe {\n-                let _ = CloseHandle(self.raw());\n-            }\n-        }\n-    }\n-\n-    impl RawHandle {\n-        fn new(handle: HANDLE) -> RawHandle {\n-            RawHandle(handle)\n-        }\n-\n-        fn raw(&self) -> HANDLE {\n-            self.0\n-        }\n-    }\n-\n-    struct FindNextFileHandle(HANDLE);\n-\n-    fn get_path(f: &File) -> io::Result<PathBuf> {\n-        fill_utf16_buf(\n-            |buf, sz| unsafe {\n-                GetFinalPathNameByHandleW(f.handle.raw(), buf, sz, VOLUME_NAME_DOS)\n-            },\n-            |buf| PathBuf::from(OsString::from_wide(buf)),\n-        )\n-    }\n-\n-    fn move_item(file: &File, ctx: &mut RmdirContext) -> io::Result<()> {\n-        let mut tmpname = ctx.base_dir.join(format! {\"rm-{}\", ctx.counter});\n-        ctx.counter += 1;\n-        // Try to rename the file. If it already exists, just retry with an other\n-        // filename.\n-        while let Err(err) = file.rename(tmpname.as_ref(), false) {\n-            if err.kind() != io::ErrorKind::AlreadyExists {\n-                return Err(err);\n-            };\n-            tmpname = ctx.base_dir.join(format!(\"rm-{}\", ctx.counter));\n-            ctx.counter += 1;\n-        }\n-        Ok(())\n-    }\n-\n-    fn set_perm(path: &Path, perm: FilePermissions) -> io::Result<()> {\n-        let mut opts = OpenOptions::new();\n-        opts.access_mode(FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES);\n-        opts.custom_flags(FILE_FLAG_BACKUP_SEMANTICS);\n-        let file = File::open(path, &opts)?;\n-        file.set_perm(perm)\n-    }\n-\n-    const VOLUME_NAME_DOS: DWORD = 0x0;\n-}"}]}