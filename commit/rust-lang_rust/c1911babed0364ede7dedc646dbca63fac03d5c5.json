{"sha": "c1911babed0364ede7dedc646dbca63fac03d5c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxOTExYmFiZWQwMzY0ZWRlN2RlZGM2NDZkYmNhNjNmYWMwM2Q1YzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-25T03:48:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-25T03:48:12Z"}, "message": "Auto merge of #58714 - Centril:rollup, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #58370 (Relax some Hash bounds on HashMap<K, V, S> and HashSet<T, S>)\n - #58421 (Relax some Ord bounds on BinaryHeap<T>)\n - #58686 (replace deprecated rustfmt_skip with rustfmt::skip)\n - #58697 (Use ? in some macros)\n - #58704 (Remove some unnecessary 'extern crate')\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "a7f6a7d6a44bcafa523052938587718261c4da15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7f6a7d6a44bcafa523052938587718261c4da15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1911babed0364ede7dedc646dbca63fac03d5c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1911babed0364ede7dedc646dbca63fac03d5c5", "html_url": "https://github.com/rust-lang/rust/commit/c1911babed0364ede7dedc646dbca63fac03d5c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1911babed0364ede7dedc646dbca63fac03d5c5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb1df8c8a7b368c31c3bf58074327c7ae7f54710", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb1df8c8a7b368c31c3bf58074327c7ae7f54710", "html_url": "https://github.com/rust-lang/rust/commit/eb1df8c8a7b368c31c3bf58074327c7ae7f54710"}, {"sha": "6806d0cf692edf9aa308cc841c81afbfc83c03bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/6806d0cf692edf9aa308cc841c81afbfc83c03bf", "html_url": "https://github.com/rust-lang/rust/commit/6806d0cf692edf9aa308cc841c81afbfc83c03bf"}], "stats": {"total": 1303, "additions": 634, "deletions": 669}, "files": [{"sha": "0732cb83f39c63ea3dd7f0ad61d1f28186d73f6d", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -7,8 +7,6 @@\n \n #![deny(warnings)]\n \n-extern crate bootstrap;\n-\n use std::env;\n \n use bootstrap::{Config, Build};"}, {"sha": "b6afe317a07b03cf874c84225b7924ba30f92ea4", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -17,8 +17,6 @@\n \n #![deny(warnings)]\n \n-extern crate bootstrap;\n-\n use std::env;\n use std::ffi::OsString;\n use std::io;"}, {"sha": "36beec3a944a0e5299c9191e9d4ccb067fec48a0", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -4,8 +4,6 @@\n \n #![deny(warnings)]\n \n-extern crate bootstrap;\n-\n use std::env;\n use std::process::Command;\n use std::path::PathBuf;"}, {"sha": "f40eec83ddf3218584e48d0efdad2a09789236c6", "filename": "src/bootstrap/bin/sccache-plus-cl.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -1,5 +1,3 @@\n-extern crate cc;\n-\n use std::env;\n use std::process::{self, Command};\n "}, {"sha": "c94d6cb4c1f5ab1541811a47230150751b05220d", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -326,7 +326,7 @@ pub enum Kind {\n impl<'a> Builder<'a> {\n     fn get_step_descriptions(kind: Kind) -> Vec<StepDescription> {\n         macro_rules! describe {\n-            ($($rule:ty),+ $(,)*) => {{\n+            ($($rule:ty),+ $(,)?) => {{\n                 vec![$(StepDescription::from::<$rule>()),+]\n             }};\n         }"}, {"sha": "2dceb30c4ad7d048b4e2e4c259f511699f16be0c", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -114,23 +114,11 @@ extern crate build_helper;\n extern crate serde_derive;\n #[macro_use]\n extern crate lazy_static;\n-extern crate serde_json;\n-extern crate cmake;\n-extern crate filetime;\n-extern crate cc;\n-extern crate getopts;\n-extern crate num_cpus;\n-extern crate toml;\n-extern crate time;\n-extern crate petgraph;\n \n #[cfg(test)]\n #[macro_use]\n extern crate pretty_assertions;\n \n-#[cfg(unix)]\n-extern crate libc;\n-\n use std::cell::{RefCell, Cell};\n use std::collections::{HashSet, HashMap};\n use std::env;"}, {"sha": "4bf5ec10c41e7e5ab1aee33352b9dae0e9f85a71", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -1,8 +1,6 @@\n #![feature(repr_simd)]\n #![feature(test)]\n \n-extern crate rand;\n-extern crate rand_xorshift;\n extern crate test;\n \n mod btree;"}, {"sha": "74325a69e15ef0f57db4d60376ff0a89dfc02162", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -326,7 +326,7 @@ impl<T: Clone> Clone for Box<T> {\n     /// let x = Box::new(5);\n     /// let y = x.clone();\n     /// ```\n-    #[rustfmt_skip]\n+    #[rustfmt::skip]\n     #[inline]\n     fn clone(&self) -> Box<T> {\n         box { (**self).clone() }"}, {"sha": "a171f128c24d60cba4a7257e7127a34591535de4", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 244, "deletions": 244, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -294,7 +294,7 @@ impl<T: Ord> Default for BinaryHeap<T> {\n }\n \n #[stable(feature = \"binaryheap_debug\", since = \"1.4.0\")]\n-impl<T: fmt::Debug + Ord> fmt::Debug for BinaryHeap<T> {\n+impl<T: fmt::Debug> fmt::Debug for BinaryHeap<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.iter()).finish()\n     }\n@@ -336,49 +336,6 @@ impl<T: Ord> BinaryHeap<T> {\n         BinaryHeap { data: Vec::with_capacity(capacity) }\n     }\n \n-    /// Returns an iterator visiting all values in the underlying vector, in\n-    /// arbitrary order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4]);\n-    ///\n-    /// // Print 1, 2, 3, 4 in arbitrary order\n-    /// for x in heap.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<'_, T> {\n-        Iter { iter: self.data.iter() }\n-    }\n-\n-    /// Returns the greatest item in the binary heap, or `None` if it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::new();\n-    /// assert_eq!(heap.peek(), None);\n-    ///\n-    /// heap.push(1);\n-    /// heap.push(5);\n-    /// heap.push(2);\n-    /// assert_eq!(heap.peek(), Some(&5));\n-    ///\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn peek(&self) -> Option<&T> {\n-        self.data.get(0)\n-    }\n-\n     /// Returns a mutable reference to the greatest item in the binary heap, or\n     /// `None` if it is empty.\n     ///\n@@ -415,119 +372,6 @@ impl<T: Ord> BinaryHeap<T> {\n         }\n     }\n \n-    /// Returns the number of elements the binary heap can hold without reallocating.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::with_capacity(100);\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.data.capacity()\n-    }\n-\n-    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n-    /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n-    ///\n-    /// Note that the allocator may give the collection more space than it requests. Therefore\n-    /// capacity can not be relied upon to be precisely minimal. Prefer [`reserve`] if future\n-    /// insertions are expected.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new capacity overflows `usize`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::new();\n-    /// heap.reserve_exact(100);\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4);\n-    /// ```\n-    ///\n-    /// [`reserve`]: #method.reserve\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve_exact(&mut self, additional: usize) {\n-        self.data.reserve_exact(additional);\n-    }\n-\n-    /// Reserves capacity for at least `additional` more elements to be inserted in the\n-    /// `BinaryHeap`. The collection may reserve more space to avoid frequent reallocations.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the new capacity overflows `usize`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap = BinaryHeap::new();\n-    /// heap.reserve(100);\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.push(4);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn reserve(&mut self, additional: usize) {\n-        self.data.reserve(additional);\n-    }\n-\n-    /// Discards as much additional capacity as possible.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n-    ///\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.shrink_to_fit();\n-    /// assert!(heap.capacity() == 0);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn shrink_to_fit(&mut self) {\n-        self.data.shrink_to_fit();\n-    }\n-\n-    /// Discards capacity with a lower bound.\n-    ///\n-    /// The capacity will remain at least as large as both the length\n-    /// and the supplied value.\n-    ///\n-    /// Panics if the current capacity is smaller than the supplied\n-    /// minimum capacity.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(shrink_to)]\n-    /// use std::collections::BinaryHeap;\n-    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n-    ///\n-    /// assert!(heap.capacity() >= 100);\n-    /// heap.shrink_to(10);\n-    /// assert!(heap.capacity() >= 10);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"56431\")]\n-    pub fn shrink_to(&mut self, min_capacity: usize) {\n-        self.data.shrink_to(min_capacity)\n-    }\n-\n     /// Removes the greatest item from the binary heap and returns it, or `None` if it\n     /// is empty.\n     ///\n@@ -577,28 +421,6 @@ impl<T: Ord> BinaryHeap<T> {\n         self.sift_up(0, old_len);\n     }\n \n-    /// Consumes the `BinaryHeap` and returns the underlying vector\n-    /// in arbitrary order.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);\n-    /// let vec = heap.into_vec();\n-    ///\n-    /// // Will print in some order\n-    /// for x in vec {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n-    pub fn into_vec(self) -> Vec<T> {\n-        self.into()\n-    }\n-\n     /// Consumes the `BinaryHeap` and returns a vector in sorted\n     /// (ascending) order.\n     ///\n@@ -703,6 +525,247 @@ impl<T: Ord> BinaryHeap<T> {\n         self.sift_up(start, pos);\n     }\n \n+    fn rebuild(&mut self) {\n+        let mut n = self.len() / 2;\n+        while n > 0 {\n+            n -= 1;\n+            self.sift_down(n);\n+        }\n+    }\n+\n+    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    ///\n+    /// let v = vec![-10, 1, 2, 3, 3];\n+    /// let mut a = BinaryHeap::from(v);\n+    ///\n+    /// let v = vec![-20, 5, 43];\n+    /// let mut b = BinaryHeap::from(v);\n+    ///\n+    /// a.append(&mut b);\n+    ///\n+    /// assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n+    /// assert!(b.is_empty());\n+    /// ```\n+    #[stable(feature = \"binary_heap_append\", since = \"1.11.0\")]\n+    pub fn append(&mut self, other: &mut Self) {\n+        if self.len() < other.len() {\n+            swap(self, other);\n+        }\n+\n+        if other.is_empty() {\n+            return;\n+        }\n+\n+        #[inline(always)]\n+        fn log2_fast(x: usize) -> usize {\n+            8 * size_of::<usize>() - (x.leading_zeros() as usize) - 1\n+        }\n+\n+        // `rebuild` takes O(len1 + len2) operations\n+        // and about 2 * (len1 + len2) comparisons in the worst case\n+        // while `extend` takes O(len2 * log_2(len1)) operations\n+        // and about 1 * len2 * log_2(len1) comparisons in the worst case,\n+        // assuming len1 >= len2.\n+        #[inline]\n+        fn better_to_rebuild(len1: usize, len2: usize) -> bool {\n+            2 * (len1 + len2) < len2 * log2_fast(len1)\n+        }\n+\n+        if better_to_rebuild(self.len(), other.len()) {\n+            self.data.append(&mut other.data);\n+            self.rebuild();\n+        } else {\n+            self.extend(other.drain());\n+        }\n+    }\n+}\n+\n+impl<T> BinaryHeap<T> {\n+    /// Returns an iterator visiting all values in the underlying vector, in\n+    /// arbitrary order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4]);\n+    ///\n+    /// // Print 1, 2, 3, 4 in arbitrary order\n+    /// for x in heap.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn iter(&self) -> Iter<'_, T> {\n+        Iter { iter: self.data.iter() }\n+    }\n+\n+    /// Returns the greatest item in the binary heap, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::new();\n+    /// assert_eq!(heap.peek(), None);\n+    ///\n+    /// heap.push(1);\n+    /// heap.push(5);\n+    /// heap.push(2);\n+    /// assert_eq!(heap.peek(), Some(&5));\n+    ///\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn peek(&self) -> Option<&T> {\n+        self.data.get(0)\n+    }\n+\n+    /// Returns the number of elements the binary heap can hold without reallocating.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::with_capacity(100);\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.push(4);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn capacity(&self) -> usize {\n+        self.data.capacity()\n+    }\n+\n+    /// Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\n+    /// given `BinaryHeap`. Does nothing if the capacity is already sufficient.\n+    ///\n+    /// Note that the allocator may give the collection more space than it requests. Therefore\n+    /// capacity can not be relied upon to be precisely minimal. Prefer [`reserve`] if future\n+    /// insertions are expected.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `usize`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.reserve_exact(100);\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.push(4);\n+    /// ```\n+    ///\n+    /// [`reserve`]: #method.reserve\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn reserve_exact(&mut self, additional: usize) {\n+        self.data.reserve_exact(additional);\n+    }\n+\n+    /// Reserves capacity for at least `additional` more elements to be inserted in the\n+    /// `BinaryHeap`. The collection may reserve more space to avoid frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new capacity overflows `usize`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap = BinaryHeap::new();\n+    /// heap.reserve(100);\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.push(4);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.data.reserve(additional);\n+    }\n+\n+    /// Discards as much additional capacity as possible.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n+    ///\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.shrink_to_fit();\n+    /// assert!(heap.capacity() == 0);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn shrink_to_fit(&mut self) {\n+        self.data.shrink_to_fit();\n+    }\n+\n+    /// Discards capacity with a lower bound.\n+    ///\n+    /// The capacity will remain at least as large as both the length\n+    /// and the supplied value.\n+    ///\n+    /// Panics if the current capacity is smaller than the supplied\n+    /// minimum capacity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(shrink_to)]\n+    /// use std::collections::BinaryHeap;\n+    /// let mut heap: BinaryHeap<i32> = BinaryHeap::with_capacity(100);\n+    ///\n+    /// assert!(heap.capacity() >= 100);\n+    /// heap.shrink_to(10);\n+    /// assert!(heap.capacity() >= 10);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"shrink_to\", reason = \"new API\", issue=\"56431\")]\n+    pub fn shrink_to(&mut self, min_capacity: usize) {\n+        self.data.shrink_to(min_capacity)\n+    }\n+\n+    /// Consumes the `BinaryHeap` and returns the underlying vector\n+    /// in arbitrary order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::collections::BinaryHeap;\n+    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5, 6, 7]);\n+    /// let vec = heap.into_vec();\n+    ///\n+    /// // Will print in some order\n+    /// for x in vec {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n+    pub fn into_vec(self) -> Vec<T> {\n+        self.into()\n+    }\n+\n     /// Returns the length of the binary heap.\n     ///\n     /// # Examples\n@@ -789,67 +852,6 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn clear(&mut self) {\n         self.drain();\n     }\n-\n-    fn rebuild(&mut self) {\n-        let mut n = self.len() / 2;\n-        while n > 0 {\n-            n -= 1;\n-            self.sift_down(n);\n-        }\n-    }\n-\n-    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// use std::collections::BinaryHeap;\n-    ///\n-    /// let v = vec![-10, 1, 2, 3, 3];\n-    /// let mut a = BinaryHeap::from(v);\n-    ///\n-    /// let v = vec![-20, 5, 43];\n-    /// let mut b = BinaryHeap::from(v);\n-    ///\n-    /// a.append(&mut b);\n-    ///\n-    /// assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n-    /// assert!(b.is_empty());\n-    /// ```\n-    #[stable(feature = \"binary_heap_append\", since = \"1.11.0\")]\n-    pub fn append(&mut self, other: &mut Self) {\n-        if self.len() < other.len() {\n-            swap(self, other);\n-        }\n-\n-        if other.is_empty() {\n-            return;\n-        }\n-\n-        #[inline(always)]\n-        fn log2_fast(x: usize) -> usize {\n-            8 * size_of::<usize>() - (x.leading_zeros() as usize) - 1\n-        }\n-\n-        // `rebuild` takes O(len1 + len2) operations\n-        // and about 2 * (len1 + len2) comparisons in the worst case\n-        // while `extend` takes O(len2 * log_2(len1)) operations\n-        // and about 1 * len2 * log_2(len1) comparisons in the worst case,\n-        // assuming len1 >= len2.\n-        #[inline]\n-        fn better_to_rebuild(len1: usize, len2: usize) -> bool {\n-            2 * (len1 + len2) < len2 * log2_fast(len1)\n-        }\n-\n-        if better_to_rebuild(self.len(), other.len()) {\n-            self.data.append(&mut other.data);\n-            self.rebuild();\n-        } else {\n-            self.extend(other.drain());\n-        }\n-    }\n }\n \n /// Hole represents a hole in a slice i.e., an index without valid value\n@@ -1111,7 +1113,7 @@ impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord> IntoIterator for BinaryHeap<T> {\n+impl<T> IntoIterator for BinaryHeap<T> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n \n@@ -1139,9 +1141,7 @@ impl<T: Ord> IntoIterator for BinaryHeap<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a BinaryHeap<T>\n-    where T: Ord\n-{\n+impl<'a, T> IntoIterator for &'a BinaryHeap<T> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n "}, {"sha": "90921b6af9f34c233e4f0eb2c15dfa4c02fd94c0", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -8,9 +8,6 @@\n #![feature(unboxed_closures)]\n #![feature(vecdeque_rotate)]\n \n-extern crate core;\n-extern crate rand;\n-\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n "}, {"sha": "6052b4a4d43f402f39b91b55efbc82985c2674e9", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -222,8 +222,8 @@ impl fmt::Debug for Span {\n \n macro_rules! define_client_side {\n     ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)*) $(-> $ret_ty:ty)*;)*\n-    }),* $(,)*) => {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)*;)*\n+    }),* $(,)?) => {\n         $(impl $name {\n             $(pub(crate) fn $method($($arg: $arg_ty),*) $(-> $ret_ty)* {\n                 Bridge::with(|bridge| {"}, {"sha": "276edb7300986a278beab3bdb79114e1cf43af7e", "filename": "src/libproc_macro/bridge/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fmod.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -225,8 +225,8 @@ mod api_tags {\n \n     macro_rules! declare_tags {\n         ($($name:ident {\n-            $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)*) $(-> $ret_ty:ty)*;)*\n-        }),* $(,)*) => {\n+            $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)*;)*\n+        }),* $(,)?) => {\n             $(\n                 pub(super) enum $name {\n                     $($method),*\n@@ -307,7 +307,7 @@ impl<T: Unmark> Unmark for Option<T> {\n }\n \n macro_rules! mark_noop {\n-    ($($ty:ty),* $(,)*) => {\n+    ($($ty:ty),* $(,)?) => {\n         $(\n             impl Mark for $ty {\n                 type Unmarked = Self;"}, {"sha": "4289f33ffd5ebf2105acc21f5f3787b6bf48e8d9", "filename": "src/libproc_macro/bridge/rpc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Frpc.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -53,7 +53,7 @@ macro_rules! rpc_encode_decode {\n             }\n         }\n     };\n-    (struct $name:ident { $($field:ident),* $(,)* }) => {\n+    (struct $name:ident { $($field:ident),* $(,)? }) => {\n         impl<S> Encode<S> for $name {\n             fn encode(self, w: &mut Writer, s: &mut S) {\n                 $(self.$field.encode(w, s);)*\n@@ -68,8 +68,8 @@ macro_rules! rpc_encode_decode {\n             }\n         }\n     };\n-    (enum $name:ident $(<$($T:ident),+>)* { $($variant:ident $(($field:ident))*),* $(,)* }) => {\n-        impl<S, $($($T: Encode<S>),+)*> Encode<S> for $name $(<$($T),+>)* {\n+    (enum $name:ident $(<$($T:ident),+>)? { $($variant:ident $(($field:ident))*),* $(,)? }) => {\n+        impl<S, $($($T: Encode<S>),+)?> Encode<S> for $name $(<$($T),+>)* {\n             fn encode(self, w: &mut Writer, s: &mut S) {\n                 // HACK(eddyb): `Tag` enum duplicated between the\n                 // two impls as there's no other place to stash it."}, {"sha": "f303e3e828834189ff9a773e63f7fdeccf86fb11", "filename": "src/libproc_macro/bridge/server.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibproc_macro%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibproc_macro%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fserver.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -39,14 +39,14 @@ macro_rules! associated_item {\n \n macro_rules! declare_server_traits {\n     ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)*) $(-> $ret_ty:ty)*;)*\n-    }),* $(,)*) => {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n+    }),* $(,)?) => {\n         pub trait Types {\n             $(associated_item!(type $name);)*\n         }\n \n         $(pub trait $name: Types {\n-            $(associated_item!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)*);)*\n+            $(associated_item!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n         })*\n \n         pub trait Server: Types $(+ $name)* {}\n@@ -59,14 +59,14 @@ pub(super) struct MarkedTypes<S: Types>(S);\n \n macro_rules! define_mark_types_impls {\n     ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)*) $(-> $ret_ty:ty)*;)*\n-    }),* $(,)*) => {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n+    }),* $(,)?) => {\n         impl<S: Types> Types for MarkedTypes<S> {\n             $(type $name = Marked<S::$name, client::$name>;)*\n         }\n \n         $(impl<S: $name> $name for MarkedTypes<S> {\n-            $(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)* {\n+            $(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)? {\n                 <_>::mark($name::$method(&mut self.0, $($arg.unmark()),*))\n             })*\n         })*\n@@ -81,8 +81,8 @@ struct Dispatcher<S: Types> {\n \n macro_rules! define_dispatcher_impl {\n     ($($name:ident {\n-        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)*) $(-> $ret_ty:ty)*;)*\n-    }),* $(,)*) => {\n+        $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n+    }),* $(,)?) => {\n         // FIXME(eddyb) `pub` only for `ExecutionStrategy` below.\n         pub trait DispatcherTrait {\n             // HACK(eddyb) these are here to allow `Self::$name` to work below."}, {"sha": "2f91da4f62e3dc159168fbf87444becadc0cd60e", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -111,7 +111,7 @@ macro_rules! define_dep_nodes {\n     (<$tcx:tt>\n     $(\n         [$($attr:ident),* ]\n-        $variant:ident $(( $tuple_arg_ty:ty $(,)* ))*\n+        $variant:ident $(( $tuple_arg_ty:ty $(,)? ))*\n                        $({ $($struct_arg_name:ident : $struct_arg_ty:ty),* })*\n       ,)*\n     ) => ("}, {"sha": "8d9d1db5756b8fe0c32e6ca49d576d86cfd11b33", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -257,7 +257,7 @@ macro_rules! CloneTypeFoldableAndLiftImpls {\n macro_rules! BraceStructLiftImpl {\n     (impl<$($p:tt),*> Lift<$tcx:tt> for $s:path {\n         type Lifted = $lifted:ty;\n-        $($field:ident),* $(,)*\n+        $($field:ident),* $(,)?\n     } $(where $($wc:tt)*)*) => {\n         impl<$($p),*> $crate::ty::Lift<$tcx> for $s\n             $(where $($wc)*)*\n@@ -327,7 +327,7 @@ macro_rules! EnumLiftImpl {\n #[macro_export]\n macro_rules! BraceStructTypeFoldableImpl {\n     (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n-        $($field:ident),* $(,)*\n+        $($field:ident),* $(,)?\n     } $(where $($wc:tt)*)*) => {\n         impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n             $(where $($wc)*)*\n@@ -354,7 +354,7 @@ macro_rules! BraceStructTypeFoldableImpl {\n #[macro_export]\n macro_rules! TupleStructTypeFoldableImpl {\n     (impl<$($p:tt),*> TypeFoldable<$tcx:tt> for $s:path {\n-        $($field:ident),* $(,)*\n+        $($field:ident),* $(,)?\n     } $(where $($wc:tt)*)*) => {\n         impl<$($p),*> $crate::ty::fold::TypeFoldable<$tcx> for $s\n             $(where $($wc)*)*\n@@ -426,7 +426,7 @@ macro_rules! EnumTypeFoldableImpl {\n     };\n \n     (@FoldVariants($this:expr, $folder:expr)\n-     input( ($variant:path) { $($variant_arg:ident),* $(,)* } , $($input:tt)*)\n+     input( ($variant:path) { $($variant_arg:ident),* $(,)? } , $($input:tt)*)\n      output( $($output:tt)*) ) => {\n         EnumTypeFoldableImpl!(\n             @FoldVariants($this, $folder)\n@@ -480,7 +480,7 @@ macro_rules! EnumTypeFoldableImpl {\n     };\n \n     (@VisitVariants($this:expr, $visitor:expr)\n-     input( ($variant:path) { $($variant_arg:ident),* $(,)* } , $($input:tt)*)\n+     input( ($variant:path) { $($variant_arg:ident),* $(,)? } , $($input:tt)*)\n      output( $($output:tt)*) ) => {\n         EnumTypeFoldableImpl!(\n             @VisitVariants($this, $visitor)"}, {"sha": "0c808a07f9bac95f27a074b89399bb3926366bde", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -36,7 +36,7 @@ macro_rules! forward {\n     // Forward pattern for &self -> &Self\n     (\n         $(#[$attrs:meta])*\n-        pub fn $n:ident(&self, $($name:ident: $ty:ty),* $(,)*) -> &Self\n+        pub fn $n:ident(&self, $($name:ident: $ty:ty),* $(,)?) -> &Self\n     ) => {\n         $(#[$attrs])*\n         pub fn $n(&self, $($name: $ty),*) -> &Self {\n@@ -48,7 +48,7 @@ macro_rules! forward {\n     // Forward pattern for &mut self -> &mut Self\n     (\n         $(#[$attrs:meta])*\n-        pub fn $n:ident(&mut self, $($name:ident: $ty:ty),* $(,)*) -> &mut Self\n+        pub fn $n:ident(&mut self, $($name:ident: $ty:ty),* $(,)?) -> &mut Self\n     ) => {\n         $(#[$attrs])*\n         pub fn $n(&mut self, $($name: $ty),*) -> &mut Self {\n@@ -64,7 +64,7 @@ macro_rules! forward {\n         pub fn $n:ident<S: Into<MultiSpan>>(\n             &mut self,\n             $($name:ident: $ty:ty),*\n-            $(,)*\n+            $(,)?\n         ) -> &mut Self\n     ) => {\n         $(#[$attrs])*"}, {"sha": "45e1ea2d3a39d294d3ddde311fa5e46b85959c2e", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -431,7 +431,7 @@ mod test {\n     }\n \n     macro_rules! dummy_meta_item_list {\n-        ($name:ident, [$($list:ident),* $(,)*]) => {\n+        ($name:ident, [$($list:ident),* $(,)?]) => {\n             MetaItem {\n                 ident: Path::from_ident(Ident::from_str(stringify!($name))),\n                 node: MetaItemKind::List(vec![\n@@ -445,7 +445,7 @@ mod test {\n             }\n         };\n \n-        ($name:ident, [$($list:expr),* $(,)*]) => {\n+        ($name:ident, [$($list:expr),* $(,)?]) => {\n             MetaItem {\n                 ident: Path::from_ident(Ident::from_str(stringify!($name))),\n                 node: MetaItemKind::List(vec!["}, {"sha": "4fb0235539c484001fd84683c48be4973e26f987", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 229, "deletions": 236, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -716,6 +716,232 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n     }\n }\n \n+impl<K, V, S> HashMap<K, V, S> {\n+    /// Returns the number of elements the map can hold without reallocating.\n+    ///\n+    /// This number is a lower bound; the `HashMap<K, V>` might be able to hold\n+    /// more, but is guaranteed to be able to hold at least this many.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// let map: HashMap<i32, i32> = HashMap::with_capacity(100);\n+    /// assert!(map.capacity() >= 100);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn capacity(&self) -> usize {\n+        self.resize_policy.capacity(self.raw_capacity())\n+    }\n+\n+    /// Returns the hash map's raw capacity.\n+    #[inline]\n+    fn raw_capacity(&self) -> usize {\n+        self.table.capacity()\n+    }\n+\n+    /// An iterator visiting all keys in arbitrary order.\n+    /// The iterator element type is `&'a K`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// for key in map.keys() {\n+    ///     println!(\"{}\", key);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn keys(&self) -> Keys<K, V> {\n+        Keys { inner: self.iter() }\n+    }\n+\n+    /// An iterator visiting all values in arbitrary order.\n+    /// The iterator element type is `&'a V`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// for val in map.values() {\n+    ///     println!(\"{}\", val);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn values(&self) -> Values<K, V> {\n+        Values { inner: self.iter() }\n+    }\n+\n+    /// An iterator visiting all values mutably in arbitrary order.\n+    /// The iterator element type is `&'a mut V`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    ///\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// for val in map.values_mut() {\n+    ///     *val = *val + 10;\n+    /// }\n+    ///\n+    /// for val in map.values() {\n+    ///     println!(\"{}\", val);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n+    pub fn values_mut(&mut self) -> ValuesMut<K, V> {\n+        ValuesMut { inner: self.iter_mut() }\n+    }\n+\n+    /// An iterator visiting all key-value pairs in arbitrary order.\n+    /// The iterator element type is `(&'a K, &'a V)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// for (key, val) in map.iter() {\n+    ///     println!(\"key: {} val: {}\", key, val);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn iter(&self) -> Iter<K, V> {\n+        Iter { inner: self.table.iter() }\n+    }\n+\n+    /// An iterator visiting all key-value pairs in arbitrary order,\n+    /// with mutable references to the values.\n+    /// The iterator element type is `(&'a K, &'a mut V)`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// // Update all values\n+    /// for (_, val) in map.iter_mut() {\n+    ///     *val *= 2;\n+    /// }\n+    ///\n+    /// for (key, val) in &map {\n+    ///     println!(\"key: {} val: {}\", key, val);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn iter_mut(&mut self) -> IterMut<K, V> {\n+        IterMut { inner: self.table.iter_mut() }\n+    }\n+\n+    /// Returns the number of elements in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// assert_eq!(a.len(), 0);\n+    /// a.insert(1, \"a\");\n+    /// assert_eq!(a.len(), 1);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn len(&self) -> usize {\n+        self.table.size()\n+    }\n+\n+    /// Returns `true` if the map contains no elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// assert!(a.is_empty());\n+    /// a.insert(1, \"a\");\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+\n+    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n+    /// allocated memory for reuse.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    ///\n+    /// for (k, v) in a.drain().take(1) {\n+    ///     assert!(k == 1 || k == 2);\n+    ///     assert!(v == \"a\" || v == \"b\");\n+    /// }\n+    ///\n+    /// assert!(a.is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"drain\", since = \"1.6.0\")]\n+    pub fn drain(&mut self) -> Drain<K, V> {\n+        Drain { inner: self.table.drain() }\n+    }\n+\n+    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n+    /// for reuse.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.clear();\n+    /// assert!(a.is_empty());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.drain();\n+    }\n+}\n+\n impl<K, V, S> HashMap<K, V, S>\n     where K: Eq + Hash,\n           S: BuildHasher\n@@ -802,30 +1028,6 @@ impl<K, V, S> HashMap<K, V, S>\n         &self.hash_builder\n     }\n \n-    /// Returns the number of elements the map can hold without reallocating.\n-    ///\n-    /// This number is a lower bound; the `HashMap<K, V>` might be able to hold\n-    /// more, but is guaranteed to be able to hold at least this many.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// let map: HashMap<i32, i32> = HashMap::with_capacity(100);\n-    /// assert!(map.capacity() >= 100);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.resize_policy.capacity(self.raw_capacity())\n-    }\n-\n-    /// Returns the hash map's raw capacity.\n-    #[inline]\n-    fn raw_capacity(&self) -> usize {\n-        self.table.capacity()\n-    }\n-\n     /// Reserves capacity for at least `additional` more elements to be inserted\n     /// in the `HashMap`. The collection may reserve more space to avoid\n     /// frequent reallocations.\n@@ -1048,127 +1250,6 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n     }\n \n-    /// An iterator visiting all keys in arbitrary order.\n-    /// The iterator element type is `&'a K`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// for key in map.keys() {\n-    ///     println!(\"{}\", key);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn keys(&self) -> Keys<K, V> {\n-        Keys { inner: self.iter() }\n-    }\n-\n-    /// An iterator visiting all values in arbitrary order.\n-    /// The iterator element type is `&'a V`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// for val in map.values() {\n-    ///     println!(\"{}\", val);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn values(&self) -> Values<K, V> {\n-        Values { inner: self.iter() }\n-    }\n-\n-    /// An iterator visiting all values mutably in arbitrary order.\n-    /// The iterator element type is `&'a mut V`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// for val in map.values_mut() {\n-    ///     *val = *val + 10;\n-    /// }\n-    ///\n-    /// for val in map.values() {\n-    ///     println!(\"{}\", val);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n-    pub fn values_mut(&mut self) -> ValuesMut<K, V> {\n-        ValuesMut { inner: self.iter_mut() }\n-    }\n-\n-    /// An iterator visiting all key-value pairs in arbitrary order.\n-    /// The iterator element type is `(&'a K, &'a V)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// for (key, val) in map.iter() {\n-    ///     println!(\"key: {} val: {}\", key, val);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<K, V> {\n-        Iter { inner: self.table.iter() }\n-    }\n-\n-    /// An iterator visiting all key-value pairs in arbitrary order,\n-    /// with mutable references to the values.\n-    /// The iterator element type is `(&'a K, &'a mut V)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1);\n-    /// map.insert(\"b\", 2);\n-    /// map.insert(\"c\", 3);\n-    ///\n-    /// // Update all values\n-    /// for (_, val) in map.iter_mut() {\n-    ///     *val *= 2;\n-    /// }\n-    ///\n-    /// for (key, val) in &map {\n-    ///     println!(\"key: {} val: {}\", key, val);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter_mut(&mut self) -> IterMut<K, V> {\n-        IterMut { inner: self.table.iter_mut() }\n-    }\n-\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n     ///\n     /// # Examples\n@@ -1197,85 +1278,6 @@ impl<K, V, S> HashMap<K, V, S>\n             .into_entry(key).expect(\"unreachable\")\n     }\n \n-    /// Returns the number of elements in the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// assert_eq!(a.len(), 0);\n-    /// a.insert(1, \"a\");\n-    /// assert_eq!(a.len(), 1);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize {\n-        self.table.size()\n-    }\n-\n-    /// Returns `true` if the map contains no elements.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// assert!(a.is_empty());\n-    /// a.insert(1, \"a\");\n-    /// assert!(!a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool {\n-        self.len() == 0\n-    }\n-\n-    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n-    /// allocated memory for reuse.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// a.insert(1, \"a\");\n-    /// a.insert(2, \"b\");\n-    ///\n-    /// for (k, v) in a.drain().take(1) {\n-    ///     assert!(k == 1 || k == 2);\n-    ///     assert!(v == \"a\" || v == \"b\");\n-    /// }\n-    ///\n-    /// assert!(a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"drain\", since = \"1.6.0\")]\n-    pub fn drain(&mut self) -> Drain<K, V> {\n-        Drain { inner: self.table.drain() }\n-    }\n-\n-    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n-    /// for reuse.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut a = HashMap::new();\n-    /// a.insert(1, \"a\");\n-    /// a.clear();\n-    /// assert!(a.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    pub fn clear(&mut self) {\n-        self.drain();\n-    }\n-\n     /// Returns a reference to the value corresponding to the key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but\n@@ -2379,10 +2381,7 @@ enum VacantEntryState<K, V, M> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          S: BuildHasher\n-{\n+impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S> {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n \n@@ -2392,10 +2391,7 @@ impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          S: BuildHasher\n-{\n+impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S> {\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;\n \n@@ -2405,10 +2401,7 @@ impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S> IntoIterator for HashMap<K, V, S>\n-    where K: Eq + Hash,\n-          S: BuildHasher\n-{\n+impl<K, V, S> IntoIterator for HashMap<K, V, S> {\n     type Item = (K, V);\n     type IntoIter = IntoIter<K, V>;\n "}, {"sha": "46a5f26df635185e5c9e1e1f4eb0c0f4ce95fff6", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 114, "deletions": 118, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -149,6 +149,118 @@ impl<T: Hash + Eq> HashSet<T, RandomState> {\n     }\n }\n \n+impl<T, S> HashSet<T, S> {\n+    /// Returns the number of elements the set can hold without reallocating.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let set: HashSet<i32> = HashSet::with_capacity(100);\n+    /// assert!(set.capacity() >= 100);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn capacity(&self) -> usize {\n+        self.map.capacity()\n+    }\n+\n+    /// An iterator visiting all elements in arbitrary order.\n+    /// The iterator element type is `&'a T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let mut set = HashSet::new();\n+    /// set.insert(\"a\");\n+    /// set.insert(\"b\");\n+    ///\n+    /// // Will print in an arbitrary order.\n+    /// for x in set.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter { iter: self.map.keys() }\n+    }\n+\n+    /// Returns the number of elements in the set.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut v = HashSet::new();\n+    /// assert_eq!(v.len(), 0);\n+    /// v.insert(1);\n+    /// assert_eq!(v.len(), 1);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn len(&self) -> usize {\n+        self.map.len()\n+    }\n+\n+    /// Returns `true` if the set contains no elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut v = HashSet::new();\n+    /// assert!(v.is_empty());\n+    /// v.insert(1);\n+    /// assert!(!v.is_empty());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_empty(&self) -> bool {\n+        self.map.is_empty()\n+    }\n+\n+    /// Clears the set, returning all elements in an iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// assert!(!set.is_empty());\n+    ///\n+    /// // print 1, 2, 3 in an arbitrary order\n+    /// for i in set.drain() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    ///\n+    /// assert!(set.is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"drain\", since = \"1.6.0\")]\n+    pub fn drain(&mut self) -> Drain<T> {\n+        Drain { iter: self.map.drain() }\n+    }\n+\n+    /// Clears the set, removing all values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut v = HashSet::new();\n+    /// v.insert(1);\n+    /// v.clear();\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn clear(&mut self) {\n+        self.map.clear()\n+    }\n+}\n+\n impl<T, S> HashSet<T, S>\n     where T: Eq + Hash,\n           S: BuildHasher\n@@ -225,21 +337,6 @@ impl<T, S> HashSet<T, S>\n         self.map.hasher()\n     }\n \n-    /// Returns the number of elements the set can hold without reallocating.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let set: HashSet<i32> = HashSet::with_capacity(100);\n-    /// assert!(set.capacity() >= 100);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn capacity(&self) -> usize {\n-        self.map.capacity()\n-    }\n-\n     /// Reserves capacity for at least `additional` more elements to be inserted\n     /// in the `HashSet`. The collection may reserve more space to avoid\n     /// frequent reallocations.\n@@ -310,27 +407,6 @@ impl<T, S> HashSet<T, S>\n         self.map.shrink_to(min_capacity)\n     }\n \n-    /// An iterator visiting all elements in arbitrary order.\n-    /// The iterator element type is `&'a T`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    /// let mut set = HashSet::new();\n-    /// set.insert(\"a\");\n-    /// set.insert(\"b\");\n-    ///\n-    /// // Will print in an arbitrary order.\n-    /// for x in set.iter() {\n-    ///     println!(\"{}\", x);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<T> {\n-        Iter { iter: self.map.keys() }\n-    }\n-\n     /// Visits the values representing the difference,\n     /// i.e., the values that are in `self` but not in `other`.\n     ///\n@@ -454,80 +530,6 @@ impl<T, S> HashSet<T, S>\n         }\n     }\n \n-    /// Returns the number of elements in the set.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut v = HashSet::new();\n-    /// assert_eq!(v.len(), 0);\n-    /// v.insert(1);\n-    /// assert_eq!(v.len(), 1);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize {\n-        self.map.len()\n-    }\n-\n-    /// Returns `true` if the set contains no elements.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut v = HashSet::new();\n-    /// assert!(v.is_empty());\n-    /// v.insert(1);\n-    /// assert!(!v.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool {\n-        self.map.is_empty()\n-    }\n-\n-    /// Clears the set, returning all elements in an iterator.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n-    /// assert!(!set.is_empty());\n-    ///\n-    /// // print 1, 2, 3 in an arbitrary order\n-    /// for i in set.drain() {\n-    ///     println!(\"{}\", i);\n-    /// }\n-    ///\n-    /// assert!(set.is_empty());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"drain\", since = \"1.6.0\")]\n-    pub fn drain(&mut self) -> Drain<T> {\n-        Drain { iter: self.map.drain() }\n-    }\n-\n-    /// Clears the set, removing all values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashSet;\n-    ///\n-    /// let mut v = HashSet::new();\n-    /// v.insert(1);\n-    /// v.clear();\n-    /// assert!(v.is_empty());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) {\n-        self.map.clear()\n-    }\n-\n     /// Returns `true` if the set contains a value.\n     ///\n     /// The value may be any borrowed form of the set's value type, but\n@@ -1066,10 +1068,7 @@ pub struct Union<'a, T: 'a, S: 'a> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S> IntoIterator for &'a HashSet<T, S>\n-    where T: Eq + Hash,\n-          S: BuildHasher\n-{\n+impl<'a, T, S> IntoIterator for &'a HashSet<T, S> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n@@ -1079,10 +1078,7 @@ impl<'a, T, S> IntoIterator for &'a HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S> IntoIterator for HashSet<T, S>\n-    where T: Eq + Hash,\n-          S: BuildHasher\n-{\n+impl<T, S> IntoIterator for HashSet<T, S> {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n "}, {"sha": "4c4b33c04422b08abfec7cba104a38b739b0623a", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -69,7 +69,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n         };\n \n         macro_rules! tt {\n-            ($ty:ident { $($field:ident $(: $value:expr)*),+ $(,)* }) => (\n+            ($ty:ident { $($field:ident $(: $value:expr)*),+ $(,)? }) => (\n                 TokenTree::$ty(self::$ty {\n                     $($field $(: $value)*,)*\n                     span,"}, {"sha": "05a8c9420ed942e489588b2c7ce72e52b621dd94", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -9,7 +9,7 @@ use super::super::TermInfo;\n \n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n \n-#[rustfmt_skip]\n+#[rustfmt::skip]\n pub static boolfnames: &[&str] = &[\"auto_left_margin\", \"auto_right_margin\",\n     \"no_esc_ctlc\", \"ceol_standout_glitch\", \"eat_newline_glitch\", \"erase_overstrike\", \"generic_type\",\n     \"hard_copy\", \"has_meta_key\", \"has_status_line\", \"insert_null_glitch\", \"memory_above\",\n@@ -22,13 +22,13 @@ pub static boolfnames: &[&str] = &[\"auto_left_margin\", \"auto_right_margin\",\n     \"no_correctly_working_cr\", \"gnu_has_meta_key\", \"linefeed_is_newline\", \"has_hardware_tabs\",\n     \"return_does_clr_eol\"];\n \n-#[rustfmt_skip]\n+#[rustfmt::skip]\n pub static boolnames: &[&str] = &[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\",\n     \"gn\", \"hc\", \"km\", \"hs\", \"in\", \"db\", \"da\", \"mir\", \"msgr\", \"os\", \"eslok\", \"xt\", \"hz\", \"ul\", \"xon\",\n     \"nxon\", \"mc5i\", \"chts\", \"nrrmc\", \"npc\", \"ndscr\", \"ccc\", \"bce\", \"hls\", \"xhpa\", \"crxm\", \"daisy\",\n     \"xvpa\", \"sam\", \"cpix\", \"lpix\", \"OTbs\", \"OTns\", \"OTnc\", \"OTMT\", \"OTNL\", \"OTpt\", \"OTxr\"];\n \n-#[rustfmt_skip]\n+#[rustfmt::skip]\n pub static numfnames: &[&str] = &[ \"columns\", \"init_tabs\", \"lines\",\n     \"lines_of_memory\", \"magic_cookie_glitch\", \"padding_baud_rate\", \"virtual_terminal\",\n     \"width_status_line\", \"num_labels\", \"label_height\", \"label_width\", \"max_attributes\",\n@@ -39,13 +39,13 @@ pub static numfnames: &[&str] = &[ \"columns\", \"init_tabs\", \"lines\",\n     \"bit_image_entwining\", \"bit_image_type\", \"magic_cookie_glitch_ul\", \"carriage_return_delay\",\n     \"new_line_delay\", \"backspace_delay\", \"horizontal_tab_delay\", \"number_of_function_keys\"];\n \n-#[rustfmt_skip]\n+#[rustfmt::skip]\n pub static numnames: &[&str] = &[ \"cols\", \"it\", \"lines\", \"lm\", \"xmc\", \"pb\",\n     \"vt\", \"wsl\", \"nlab\", \"lh\", \"lw\", \"ma\", \"wnum\", \"colors\", \"pairs\", \"ncv\", \"bufsz\", \"spinv\",\n     \"spinh\", \"maddr\", \"mjump\", \"mcs\", \"mls\", \"npins\", \"orc\", \"orl\", \"orhi\", \"orvi\", \"cps\", \"widcs\",\n     \"btns\", \"bitwin\", \"bitype\", \"UTug\", \"OTdC\", \"OTdN\", \"OTdB\", \"OTdT\", \"OTkn\"];\n \n-#[rustfmt_skip]\n+#[rustfmt::skip]\n pub static stringfnames: &[&str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n     \"change_scroll_region\", \"clear_all_tabs\", \"clear_screen\", \"clr_eol\", \"clr_eos\",\n     \"column_address\", \"command_character\", \"cursor_address\", \"cursor_down\", \"cursor_home\",\n@@ -119,7 +119,7 @@ pub static stringfnames: &[&str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n     \"acs_lrcorner\", \"acs_ltee\", \"acs_rtee\", \"acs_btee\", \"acs_ttee\", \"acs_hline\", \"acs_vline\",\n     \"acs_plus\", \"memory_lock\", \"memory_unlock\", \"box_chars_1\"];\n \n-#[rustfmt_skip]\n+#[rustfmt::skip]\n pub static stringnames: &[&str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tbc\", \"clear\",\n     \"_\", \"_\", \"hpa\", \"cmdch\", \"cup\", \"cud1\", \"home\", \"civis\", \"cub1\", \"mrcup\", \"cnorm\", \"cuf1\",\n     \"ll\", \"cuu1\", \"cvvis\", \"dch1\", \"dl1\", \"dsl\", \"hd\", \"smacs\", \"blink\", \"bold\", \"smcup\", \"smdc\","}, {"sha": "ba2d503d7fcf1269659b6d8d47b6f7f8e2a7c0d9", "filename": "src/test/ui/issues/issue-35677.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Ftest%2Fui%2Fissues%2Fissue-35677.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Ftest%2Fui%2Fissues%2Fissue-35677.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35677.rs?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -1,6 +1,7 @@\n-use std::collections::HashMap;\n-fn intersect_map<K, V>(this: &mut HashMap<K, V>, other: HashMap<K, V>) -> bool {\n-    this.drain()\n+use std::collections::HashSet;\n+\n+fn is_subset<T>(this: &HashSet<T>, other: &HashSet<T>) -> bool {\n+    this.is_subset(other)\n     //~^ ERROR no method named\n }\n "}, {"sha": "99d99db93f3e3f3db027c0f4b4dfa8e86c33608b", "filename": "src/test/ui/issues/issue-35677.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Ftest%2Fui%2Fissues%2Fissue-35677.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c1911babed0364ede7dedc646dbca63fac03d5c5/src%2Ftest%2Fui%2Fissues%2Fissue-35677.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35677.stderr?ref=c1911babed0364ede7dedc646dbca63fac03d5c5", "patch": "@@ -1,12 +1,12 @@\n-error[E0599]: no method named `drain` found for type `&mut std::collections::HashMap<K, V>` in the current scope\n-  --> $DIR/issue-35677.rs:3:10\n+error[E0599]: no method named `is_subset` found for type `&std::collections::HashSet<T>` in the current scope\n+  --> $DIR/issue-35677.rs:4:10\n    |\n-LL |     this.drain()\n-   |          ^^^^^\n+LL |     this.is_subset(other)\n+   |          ^^^^^^^^^\n    |\n-   = note: the method `drain` exists but the following trait bounds were not satisfied:\n-           `K : std::cmp::Eq`\n-           `K : std::hash::Hash`\n+   = note: the method `is_subset` exists but the following trait bounds were not satisfied:\n+           `T : std::cmp::Eq`\n+           `T : std::hash::Hash`\n \n error: aborting due to previous error\n "}]}