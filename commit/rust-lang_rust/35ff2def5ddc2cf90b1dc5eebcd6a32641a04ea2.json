{"sha": "35ff2def5ddc2cf90b1dc5eebcd6a32641a04ea2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZmYyZGVmNWRkYzJjZjkwYjFkYzVlZWJjZDZhMzI2NDFhMDRlYTI=", "commit": {"author": {"name": "P1start", "email": "rewi-github@whanau.org", "date": "2014-09-15T09:20:05Z"}, "committer": {"name": "P1start", "email": "rewi-github@whanau.org", "date": "2014-10-01T22:21:59Z"}, "message": "Clarify some borrowck errors\n\nCloses #17263.", "tree": {"sha": "9b3e3dfc76fbf4932377d04f18c9c3da79712681", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b3e3dfc76fbf4932377d04f18c9c3da79712681"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35ff2def5ddc2cf90b1dc5eebcd6a32641a04ea2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35ff2def5ddc2cf90b1dc5eebcd6a32641a04ea2", "html_url": "https://github.com/rust-lang/rust/commit/35ff2def5ddc2cf90b1dc5eebcd6a32641a04ea2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35ff2def5ddc2cf90b1dc5eebcd6a32641a04ea2/comments", "author": {"login": "ftxqxd", "id": 2055302, "node_id": "MDQ6VXNlcjIwNTUzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftxqxd", "html_url": "https://github.com/ftxqxd", "followers_url": "https://api.github.com/users/ftxqxd/followers", "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}", "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions", "organizations_url": "https://api.github.com/users/ftxqxd/orgs", "repos_url": "https://api.github.com/users/ftxqxd/repos", "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}", "received_events_url": "https://api.github.com/users/ftxqxd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ftxqxd", "id": 2055302, "node_id": "MDQ6VXNlcjIwNTUzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftxqxd", "html_url": "https://github.com/ftxqxd", "followers_url": "https://api.github.com/users/ftxqxd/followers", "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}", "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions", "organizations_url": "https://api.github.com/users/ftxqxd/orgs", "repos_url": "https://api.github.com/users/ftxqxd/repos", "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}", "received_events_url": "https://api.github.com/users/ftxqxd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36b85025df8a8045428e2f9917c75e0639a210a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/36b85025df8a8045428e2f9917c75e0639a210a6", "html_url": "https://github.com/rust-lang/rust/commit/36b85025df8a8045428e2f9917c75e0639a210a6"}], "stats": {"total": 152, "additions": 125, "deletions": 27}, "files": [{"sha": "a5111cdf7c8f52acc464b0087d753a0559c5a025", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 57, "deletions": 27, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/35ff2def5ddc2cf90b1dc5eebcd6a32641a04ea2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35ff2def5ddc2cf90b1dc5eebcd6a32641a04ea2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=35ff2def5ddc2cf90b1dc5eebcd6a32641a04ea2", "patch": "@@ -400,50 +400,82 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         for restr_path in loan1.restricted_paths.iter() {\n             if *restr_path != loan2_base_path { continue; }\n \n-            let old_pronoun = if new_loan.loan_path == old_loan.loan_path {\n+            // If new_loan is something like `x.a`, and old_loan is something like `x.b`, we would\n+            // normally generate a rather confusing message (in this case, for multiple mutable\n+            // borrows):\n+            //\n+            //     error: cannot borrow `x.b` as mutable more than once at a time\n+            //     note: previous borrow of `x.a` occurs here; the mutable borrow prevents\n+            //     subsequent moves, borrows, or modification of `x.a` until the borrow ends\n+            //\n+            // What we want to do instead is get the 'common ancestor' of the two borrow paths and\n+            // use that for most of the message instead, giving is something like this:\n+            //\n+            //     error: cannot borrow `x` as mutable more than once at a time\n+            //     note: previous borrow of `x` occurs here (through borrowing `x.a`); the mutable\n+            //     borrow prevents subsequent moves, borrows, or modification of `x` until the\n+            //     borrow ends\n+\n+            let common = new_loan.loan_path.common(&*old_loan.loan_path);\n+            let (nl, ol, new_loan_msg, old_loan_msg) =\n+                if new_loan.loan_path.has_fork(&*old_loan.loan_path) && common.is_some() {\n+                    let nl = self.bccx.loan_path_to_string(&common.unwrap());\n+                    let ol = nl.clone();\n+                    let new_loan_msg = format!(\" (here through borrowing `{}`)\",\n+                                               self.bccx.loan_path_to_string(\n+                                                   &*new_loan.loan_path));\n+                    let old_loan_msg = format!(\" (through borrowing `{}`)\",\n+                                               self.bccx.loan_path_to_string(\n+                                                   &*old_loan.loan_path));\n+                    (nl, ol, new_loan_msg, old_loan_msg)\n+                } else {\n+                    (self.bccx.loan_path_to_string(&*new_loan.loan_path),\n+                     self.bccx.loan_path_to_string(&*old_loan.loan_path),\n+                     String::new(), String::new())\n+                };\n+\n+            let ol_pronoun = if new_loan.loan_path == old_loan.loan_path {\n                 \"it\".to_string()\n             } else {\n-                format!(\"`{}`\",\n-                        self.bccx.loan_path_to_string(&*old_loan.loan_path))\n+                format!(\"`{}`\", ol)\n             };\n \n             match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}` as mutable \\\n+                        format!(\"cannot borrow `{}`{} as mutable \\\n                                 more than once at a time\",\n-                                self.bccx.loan_path_to_string(\n-                                    &*new_loan.loan_path)).as_slice());\n+                                nl, new_loan_msg).as_slice())\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"closure requires unique access to `{}` \\\n-                                but {} is already borrowed\",\n-                                self.bccx.loan_path_to_string(&*new_loan.loan_path),\n-                                old_pronoun).as_slice());\n+                                but {} is already borrowed{}\",\n+                                nl, ol_pronoun, old_loan_msg).as_slice());\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}` as {} because \\\n+                        format!(\"cannot borrow `{}`{} as {} because \\\n                                 previous closure requires unique access\",\n-                                self.bccx.loan_path_to_string(&*new_loan.loan_path),\n-                                new_loan.kind.to_user_str()).as_slice());\n+                                nl, new_loan_msg, new_loan.kind.to_user_str()).as_slice());\n                 }\n \n                 (_, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}` as {} because \\\n-                                {} is also borrowed as {}\",\n-                                self.bccx.loan_path_to_string(&*new_loan.loan_path),\n+                        format!(\"cannot borrow `{}`{} as {} because \\\n+                                {} is also borrowed as {}{}\",\n+                                nl,\n+                                new_loan_msg,\n                                 new_loan.kind.to_user_str(),\n-                                old_pronoun,\n-                                old_loan.kind.to_user_str()).as_slice());\n+                                ol_pronoun,\n+                                old_loan.kind.to_user_str(),\n+                                old_loan_msg).as_slice());\n                 }\n             }\n \n@@ -452,8 +484,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.span_note(\n                         span,\n                         format!(\"borrow occurs due to use of `{}` in closure\",\n-                                self.bccx.loan_path_to_string(\n-                                    &*new_loan.loan_path)).as_slice());\n+                                nl).as_slice());\n                 }\n                 _ => { }\n             }\n@@ -463,30 +494,29 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     format!(\"the mutable borrow prevents subsequent \\\n                             moves, borrows, or modification of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_string(\n-                                &*old_loan.loan_path))\n+                            ol)\n                 }\n \n                 ty::ImmBorrow => {\n                     format!(\"the immutable borrow prevents subsequent \\\n                             moves or mutable borrows of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_string(&*old_loan.loan_path))\n+                            ol)\n                 }\n \n                 ty::UniqueImmBorrow => {\n                     format!(\"the unique capture prevents subsequent \\\n                             moves or borrows of `{0}` \\\n                             until the borrow ends\",\n-                            self.bccx.loan_path_to_string(&*old_loan.loan_path))\n+                            ol)\n                 }\n             };\n \n             let borrow_summary = match old_loan.cause {\n                 euv::ClosureCapture(_) => {\n-                    format!(\"previous borrow of `{}` occurs here due to \\\n+                    format!(\"previous borrow of `{}` occurs here{} due to \\\n                             use in closure\",\n-                            self.bccx.loan_path_to_string(&*old_loan.loan_path))\n+                            ol, old_loan_msg)\n                 }\n \n                 euv::OverloadedOperator(..) |\n@@ -496,8 +526,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 euv::ForLoop(..) |\n                 euv::RefBinding(..) |\n                 euv::MatchDiscriminant(..) => {\n-                    format!(\"previous borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_string(&*old_loan.loan_path))\n+                    format!(\"previous borrow of `{}` occurs here{}\",\n+                            ol, old_loan_msg)\n                 }\n             };\n "}, {"sha": "734108d035af4277b33edd7e4d071a9e3333ba42", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/35ff2def5ddc2cf90b1dc5eebcd6a32641a04ea2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35ff2def5ddc2cf90b1dc5eebcd6a32641a04ea2/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=35ff2def5ddc2cf90b1dc5eebcd6a32641a04ea2", "patch": "@@ -298,6 +298,51 @@ impl LoanPath {\n             LpExtend(ref base, _, _) => base.kill_scope(tcx),\n         }\n     }\n+\n+    fn has_fork(&self, other: &LoanPath) -> bool {\n+        match (self, other) {\n+            (&LpExtend(ref base, _, LpInterior(id)), &LpExtend(ref base2, _, LpInterior(id2))) =>\n+                if id == id2 {\n+                    base.has_fork(&**base2)\n+                } else {\n+                    true\n+                },\n+            (&LpExtend(ref base, _, LpDeref(_)), _) => base.has_fork(other),\n+            (_, &LpExtend(ref base, _, LpDeref(_))) => self.has_fork(&**base),\n+            _ => false,\n+        }\n+    }\n+\n+    fn depth(&self) -> uint {\n+        match *self {\n+            LpExtend(ref base, _, LpDeref(_)) => base.depth(),\n+            LpExtend(ref base, _, LpInterior(_)) => base.depth() + 1,\n+            _ => 0,\n+        }\n+    }\n+\n+    fn common(&self, other: &LoanPath) -> Option<LoanPath> {\n+        match (self, other) {\n+            (&LpExtend(ref base, a, LpInterior(id)), &LpExtend(ref base2, _, LpInterior(id2))) =>\n+                if id == id2 {\n+                    base.common(&**base2).map(|x| {\n+                        let xd = x.depth();\n+                        if base.depth() == xd && base2.depth() == xd {\n+                            LpExtend(Rc::new(x), a, LpInterior(id))\n+                        } else {\n+                            x\n+                        }\n+                    })\n+                } else {\n+                    base.common(&**base2)\n+                },\n+            (&LpExtend(ref base, _, LpDeref(_)), _) => base.common(other),\n+            (_, &LpExtend(ref other, _, LpDeref(_))) => self.common(&**other),\n+            (&LpVar(id), &LpVar(id2)) => if id == id2 { Some(LpVar(id)) } else { None },\n+            (&LpUpvar(id), &LpUpvar(id2)) => if id == id2 { Some(LpUpvar(id)) } else { None },\n+            _ => None,\n+        }\n+    }\n }\n \n pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {"}, {"sha": "b610a2b0c91d668a3d2b35543db5bd4a12291b98", "filename": "src/test/compile-fail/issue-17263.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/35ff2def5ddc2cf90b1dc5eebcd6a32641a04ea2/src%2Ftest%2Fcompile-fail%2Fissue-17263.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35ff2def5ddc2cf90b1dc5eebcd6a32641a04ea2/src%2Ftest%2Fcompile-fail%2Fissue-17263.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17263.rs?ref=35ff2def5ddc2cf90b1dc5eebcd6a32641a04ea2", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo { a: int, b: int }\n+\n+fn main() {\n+    let mut x = box Foo { a: 1, b: 2 };\n+    let (a, b) = (&mut x.a, &mut x.b);\n+    //~^ ERROR cannot borrow `x` (here through borrowing `x.b`) as mutable more than once at a time\n+    //~^^ NOTE previous borrow of `x` occurs here (through borrowing `x.a`)\n+\n+    let mut foo = box Foo { a: 1, b: 2 };\n+    let (c, d) = (&mut foo.a, &foo.b);\n+    //~^ ERROR cannot borrow `foo` (here through borrowing `foo.b`) as immutable\n+    //~^^ NOTE previous borrow of `foo` occurs here (through borrowing `foo.a`)\n+}"}]}