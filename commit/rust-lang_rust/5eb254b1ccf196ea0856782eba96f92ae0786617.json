{"sha": "5eb254b1ccf196ea0856782eba96f92ae0786617", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlYjI1NGIxY2NmMTk2ZWEwODU2NzgyZWJhOTZmOTJhZTA3ODY2MTc=", "commit": {"author": {"name": "Sebastian Gesemann", "email": "s.gesemann@gmail.com", "date": "2015-01-16T04:44:19Z"}, "committer": {"name": "Sebastian Gesemann", "email": "s.gesemann@gmail.com", "date": "2015-01-16T04:44:19Z"}, "message": "libcore: implement many operators for references as well", "tree": {"sha": "05da4ed99b50c8d27ba1ea7ac978e59494560ee7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05da4ed99b50c8d27ba1ea7ac978e59494560ee7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eb254b1ccf196ea0856782eba96f92ae0786617", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eb254b1ccf196ea0856782eba96f92ae0786617", "html_url": "https://github.com/rust-lang/rust/commit/5eb254b1ccf196ea0856782eba96f92ae0786617", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eb254b1ccf196ea0856782eba96f92ae0786617/comments", "author": {"login": "sellibitze", "id": 290865, "node_id": "MDQ6VXNlcjI5MDg2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/290865?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sellibitze", "html_url": "https://github.com/sellibitze", "followers_url": "https://api.github.com/users/sellibitze/followers", "following_url": "https://api.github.com/users/sellibitze/following{/other_user}", "gists_url": "https://api.github.com/users/sellibitze/gists{/gist_id}", "starred_url": "https://api.github.com/users/sellibitze/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sellibitze/subscriptions", "organizations_url": "https://api.github.com/users/sellibitze/orgs", "repos_url": "https://api.github.com/users/sellibitze/repos", "events_url": "https://api.github.com/users/sellibitze/events{/privacy}", "received_events_url": "https://api.github.com/users/sellibitze/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sellibitze", "id": 290865, "node_id": "MDQ6VXNlcjI5MDg2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/290865?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sellibitze", "html_url": "https://github.com/sellibitze", "followers_url": "https://api.github.com/users/sellibitze/followers", "following_url": "https://api.github.com/users/sellibitze/following{/other_user}", "gists_url": "https://api.github.com/users/sellibitze/gists{/gist_id}", "starred_url": "https://api.github.com/users/sellibitze/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sellibitze/subscriptions", "organizations_url": "https://api.github.com/users/sellibitze/orgs", "repos_url": "https://api.github.com/users/sellibitze/repos", "events_url": "https://api.github.com/users/sellibitze/events{/privacy}", "received_events_url": "https://api.github.com/users/sellibitze/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8903c21d618fd25dca61d9bb668c5299d21feac9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8903c21d618fd25dca61d9bb668c5299d21feac9", "html_url": "https://github.com/rust-lang/rust/commit/8903c21d618fd25dca61d9bb668c5299d21feac9"}], "stats": {"total": 102, "additions": 102, "deletions": 0}, "files": [{"sha": "144019147af7e1cd105c861fefd67459d6affb64", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5eb254b1ccf196ea0856782eba96f92ae0786617/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eb254b1ccf196ea0856782eba96f92ae0786617/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=5eb254b1ccf196ea0856782eba96f92ae0786617", "patch": "@@ -96,6 +96,80 @@ pub trait Drop {\n     fn drop(&mut self);\n }\n \n+// implements the unary operator \"op &T\"\n+// based on \"op T\" where T is expected to be `Copy`able\n+macro_rules! forward_ref_unop {\n+    (impl $imp:ident, $method:ident for $t:ty) => {\n+        #[unstable]\n+        impl<'a> $imp for &'a $t {\n+            type Output = <$t as $imp>::Output;\n+\n+            #[inline]\n+            fn $method(self) -> <$t as $imp>::Output {\n+                $imp::$method(*self)\n+            }\n+        }\n+    }\n+}\n+\n+// implements the binary operator \"&T op U\"\n+// based on \"T + U\" where T and U are expected `Copy`able\n+macro_rules! forward_ref_val_binop {\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n+        #[unstable]\n+        impl<'a> $imp<$u> for &'a $t {\n+            type Output = <$t as $imp<$u>>::Output;\n+\n+            #[inline]\n+            fn $method(self, other: $u) -> <$t as $imp<$u>>::Output {\n+                $imp::$method(*self, other)\n+            }\n+        }\n+    }\n+}\n+\n+// implements the binary operator \"T op &U\"\n+// based on \"T + U\" where T and U are expected `Copy`able\n+macro_rules! forward_val_ref_binop {\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n+        #[unstable]\n+        impl<'a> $imp<&'a $u> for $t {\n+            type Output = <$t as $imp<$u>>::Output;\n+\n+            #[inline]\n+            fn $method(self, other: &'a $u) -> <$t as $imp<$u>>::Output {\n+                $imp::$method(self, *other)\n+            }\n+        }\n+    }\n+}\n+\n+// implements the binary operator \"&T op &U\"\n+// based on \"T + U\" where T and U are expected `Copy`able\n+macro_rules! forward_ref_ref_binop {\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n+        #[unstable]\n+        impl<'a, 'b> $imp<&'a $u> for &'b $t {\n+            type Output = <$t as $imp<$u>>::Output;\n+\n+            #[inline]\n+            fn $method(self, other: &'a $u) -> <$t as $imp<$u>>::Output {\n+                $imp::$method(*self, *other)\n+            }\n+        }\n+    }\n+}\n+\n+// implements binary operators \"&T op U\", \"T op &U\", \"&T op &U\"\n+// based on \"T + U\" where T and U are expected `Copy`able\n+macro_rules! forward_ref_binop {\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n+        forward_ref_val_binop! { impl $imp, $method for $t, $u }\n+        forward_val_ref_binop! { impl $imp, $method for $t, $u }\n+        forward_ref_ref_binop! { impl $imp, $method for $t, $u }\n+    }\n+}\n+\n /// The `Add` trait is used to specify the functionality of `+`.\n ///\n /// # Example\n@@ -144,6 +218,8 @@ macro_rules! add_impl {\n             #[inline]\n             fn add(self, other: $t) -> $t { self + other }\n         }\n+\n+        forward_ref_binop! { impl Add, add for $t, $t }\n     )*)\n }\n \n@@ -197,6 +273,8 @@ macro_rules! sub_impl {\n             #[inline]\n             fn sub(self, other: $t) -> $t { self - other }\n         }\n+\n+        forward_ref_binop! { impl Sub, sub for $t, $t }\n     )*)\n }\n \n@@ -250,6 +328,8 @@ macro_rules! mul_impl {\n             #[inline]\n             fn mul(self, other: $t) -> $t { self * other }\n         }\n+\n+        forward_ref_binop! { impl Mul, mul for $t, $t }\n     )*)\n }\n \n@@ -303,6 +383,8 @@ macro_rules! div_impl {\n             #[inline]\n             fn div(self, other: $t) -> $t { self / other }\n         }\n+\n+        forward_ref_binop! { impl Div, div for $t, $t }\n     )*)\n }\n \n@@ -356,6 +438,8 @@ macro_rules! rem_impl {\n             #[inline]\n             fn rem(self, other: $t) -> $t { self % other }\n         }\n+\n+        forward_ref_binop! { impl Rem, rem for $t, $t }\n     )*)\n }\n \n@@ -371,6 +455,8 @@ macro_rules! rem_float_impl {\n                 unsafe { $fmod(self, other) }\n             }\n         }\n+\n+        forward_ref_binop! { impl Rem, rem for $t, $t }\n     }\n }\n \n@@ -429,6 +515,8 @@ macro_rules! neg_impl {\n             #[stable]\n             fn neg(self) -> $t { -self }\n         }\n+\n+        forward_ref_unop! { impl Neg, neg for $t }\n     )*)\n }\n \n@@ -441,6 +529,8 @@ macro_rules! neg_uint_impl {\n             #[inline]\n             fn neg(self) -> $t { -(self as $t_signed) as $t }\n         }\n+\n+        forward_ref_unop! { impl Neg, neg for $t }\n     }\n }\n \n@@ -502,6 +592,8 @@ macro_rules! not_impl {\n             #[inline]\n             fn not(self) -> $t { !self }\n         }\n+\n+        forward_ref_unop! { impl Not, not for $t }\n     )*)\n }\n \n@@ -555,6 +647,8 @@ macro_rules! bitand_impl {\n             #[inline]\n             fn bitand(self, rhs: $t) -> $t { self & rhs }\n         }\n+\n+        forward_ref_binop! { impl BitAnd, bitand for $t, $t }\n     )*)\n }\n \n@@ -608,6 +702,8 @@ macro_rules! bitor_impl {\n             #[inline]\n             fn bitor(self, rhs: $t) -> $t { self | rhs }\n         }\n+\n+        forward_ref_binop! { impl BitOr, bitor for $t, $t }\n     )*)\n }\n \n@@ -661,6 +757,8 @@ macro_rules! bitxor_impl {\n             #[inline]\n             fn bitxor(self, other: $t) -> $t { self ^ other }\n         }\n+\n+        forward_ref_binop! { impl BitXor, bitxor for $t, $t }\n     )*)\n }\n \n@@ -716,6 +814,8 @@ macro_rules! shl_impl {\n                 self << other\n             }\n         }\n+\n+        forward_ref_binop! { impl Shl, shl for $t, $f }\n     )\n }\n \n@@ -795,6 +895,8 @@ macro_rules! shr_impl {\n                 self >> other\n             }\n         }\n+\n+        forward_ref_binop! { impl Shr, shr for $t, $f }\n     )\n }\n "}]}