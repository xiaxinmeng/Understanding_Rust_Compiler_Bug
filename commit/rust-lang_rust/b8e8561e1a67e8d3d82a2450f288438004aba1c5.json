{"sha": "b8e8561e1a67e8d3d82a2450f288438004aba1c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ZTg1NjFlMWE2N2U4ZDNkODJhMjQ1MGYyODg0MzgwMDRhYmExYzU=", "commit": {"author": {"name": "Cristi Cobzarenco", "email": "cristi.cobzarenco@gmail.com", "date": "2015-10-13T20:55:34Z"}, "committer": {"name": "Cristi Cobzarenco", "email": "cristi.cobzarenco@gmail.com", "date": "2015-10-15T17:05:54Z"}, "message": "std: add into_inner and get_mut to mutex", "tree": {"sha": "680f7cacffbfad95c1b50d1af2fdbac89617c255", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/680f7cacffbfad95c1b50d1af2fdbac89617c255"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8e8561e1a67e8d3d82a2450f288438004aba1c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8e8561e1a67e8d3d82a2450f288438004aba1c5", "html_url": "https://github.com/rust-lang/rust/commit/b8e8561e1a67e8d3d82a2450f288438004aba1c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8e8561e1a67e8d3d82a2450f288438004aba1c5/comments", "author": {"login": "cristicbz", "id": 801328, "node_id": "MDQ6VXNlcjgwMTMyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/801328?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cristicbz", "html_url": "https://github.com/cristicbz", "followers_url": "https://api.github.com/users/cristicbz/followers", "following_url": "https://api.github.com/users/cristicbz/following{/other_user}", "gists_url": "https://api.github.com/users/cristicbz/gists{/gist_id}", "starred_url": "https://api.github.com/users/cristicbz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cristicbz/subscriptions", "organizations_url": "https://api.github.com/users/cristicbz/orgs", "repos_url": "https://api.github.com/users/cristicbz/repos", "events_url": "https://api.github.com/users/cristicbz/events{/privacy}", "received_events_url": "https://api.github.com/users/cristicbz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cristicbz", "id": 801328, "node_id": "MDQ6VXNlcjgwMTMyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/801328?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cristicbz", "html_url": "https://github.com/cristicbz", "followers_url": "https://api.github.com/users/cristicbz/followers", "following_url": "https://api.github.com/users/cristicbz/following{/other_user}", "gists_url": "https://api.github.com/users/cristicbz/gists{/gist_id}", "starred_url": "https://api.github.com/users/cristicbz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cristicbz/subscriptions", "organizations_url": "https://api.github.com/users/cristicbz/orgs", "repos_url": "https://api.github.com/users/cristicbz/repos", "events_url": "https://api.github.com/users/cristicbz/events{/privacy}", "received_events_url": "https://api.github.com/users/cristicbz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec4362da562a4b591a7d120c6677e14ea713481a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec4362da562a4b591a7d120c6677e14ea713481a", "html_url": "https://github.com/rust-lang/rust/commit/ec4362da562a4b591a7d120c6677e14ea713481a"}], "stats": {"total": 115, "additions": 115, "deletions": 0}, "files": [{"sha": "aabc06b1986f5d1de6d822030f9f3d8c55528863", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/b8e8561e1a67e8d3d82a2450f288438004aba1c5/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8e8561e1a67e8d3d82a2450f288438004aba1c5/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=b8e8561e1a67e8d3d82a2450f288438004aba1c5", "patch": "@@ -13,7 +13,9 @@ use prelude::v1::*;\n use cell::UnsafeCell;\n use fmt;\n use marker;\n+use mem;\n use ops::{Deref, DerefMut};\n+use ptr;\n use sys_common::mutex as sys;\n use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n \n@@ -243,6 +245,50 @@ impl<T: ?Sized> Mutex<T> {\n     pub fn is_poisoned(&self) -> bool {\n         self.inner.poison.get()\n     }\n+\n+    /// Consumes this mutex, returning the underlying data.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If another user of this mutex panicked while holding the mutex, then\n+    /// this call will return an error instead.\n+    #[unstable(feature = \"mutex_into_inner\", reason = \"recently added\", issue = \"28968\")]\n+    pub fn into_inner(self) -> LockResult<T> where T: Sized {\n+        // We know statically that there are no outstanding references to\n+        // `self` so there's no need to lock the inner StaticMutex.\n+        //\n+        // To get the inner value, we'd like to call `data.into_inner()`,\n+        // but because `Mutex` impl-s `Drop`, we can't move out of it, so\n+        // we'll have to destructure it manually instead.\n+        unsafe {\n+            // Like `let Mutex { inner, data } = self`.\n+            let (inner, data) = {\n+                let Mutex { ref inner, ref data } = self;\n+                (ptr::read(inner), ptr::read(data))\n+            };\n+            mem::forget(self);\n+            inner.lock.destroy();  // Keep in sync with the `Drop` impl.\n+\n+            poison::map_result(inner.poison.borrow(), |_| data.into_inner())\n+        }\n+    }\n+\n+    /// Returns a mutable reference to the underlying data.\n+    ///\n+    /// Since this call borrows the `Mutex` mutably, no actual locking needs to\n+    /// take place---the mutable borrow statically guarantees no locks exist.\n+    ///\n+    /// # Failure\n+    ///\n+    /// If another user of this mutex panicked while holding the mutex, then\n+    /// this call will return an error instead.\n+    #[unstable(feature = \"mutex_get_mut\", reason = \"recently added\", issue = \"28968\")]\n+    pub fn get_mut(&mut self) -> LockResult<&mut T> {\n+        // We know statically that there are no other references to `self`, so\n+        // there's no need to lock the inner StaticMutex.\n+        let data = unsafe { &mut *self.data.get() };\n+        poison::map_result(self.inner.poison.borrow(), |_| data )\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -251,6 +297,8 @@ impl<T: ?Sized> Drop for Mutex<T> {\n         // This is actually safe b/c we know that there is no further usage of\n         // this mutex (it's up to the user to arrange for a mutex to get\n         // dropped, that's not our job)\n+        //\n+        // IMPORTANT: This code must be kept in sync with `Mutex::into_inner`.\n         unsafe { self.inner.lock.destroy() }\n     }\n }\n@@ -371,10 +419,14 @@ mod tests {\n \n     use sync::mpsc::channel;\n     use sync::{Arc, Mutex, StaticMutex, Condvar};\n+    use sync::atomic::{AtomicUsize, Ordering};\n     use thread;\n \n     struct Packet<T>(Arc<(Mutex<T>, Condvar)>);\n \n+    #[derive(Eq, PartialEq, Debug)]\n+    struct NonCopy(i32);\n+\n     unsafe impl<T: Send> Send for Packet<T> {}\n     unsafe impl<T> Sync for Packet<T> {}\n \n@@ -435,6 +487,69 @@ mod tests {\n         *m.try_lock().unwrap() = ();\n     }\n \n+    #[test]\n+    fn test_into_inner() {\n+        let m = Mutex::new(NonCopy(10));\n+        assert_eq!(m.into_inner().unwrap(), NonCopy(10));\n+    }\n+\n+    #[test]\n+    fn test_into_inner_drop() {\n+        struct Foo(Arc<AtomicUsize>);\n+        impl Drop for Foo {\n+            fn drop(&mut self) {\n+                self.0.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+        let num_drops = Arc::new(AtomicUsize::new(0));\n+        let m = Mutex::new(Foo(num_drops.clone()));\n+        assert_eq!(num_drops.load(Ordering::SeqCst), 0);\n+        {\n+            let _inner = m.into_inner().unwrap();\n+            assert_eq!(num_drops.load(Ordering::SeqCst), 0);\n+        }\n+        assert_eq!(num_drops.load(Ordering::SeqCst), 1);\n+    }\n+\n+    #[test]\n+    fn test_into_inner_poison() {\n+        let m = Arc::new(Mutex::new(NonCopy(10)));\n+        let m2 = m.clone();\n+        let _ = thread::spawn(move || {\n+            let _lock = m2.lock().unwrap();\n+            panic!(\"test panic in inner thread to poison mutex\");\n+        }).join();\n+\n+        assert!(m.is_poisoned());\n+        match Arc::try_unwrap(m).unwrap().into_inner() {\n+            Err(e) => assert_eq!(e.into_inner(), NonCopy(10)),\n+            Ok(x) => panic!(\"into_inner of poisoned Mutex is Ok: {:?}\", x),\n+        }\n+    }\n+\n+    #[test]\n+    fn test_get_mut() {\n+        let mut m = Mutex::new(NonCopy(10));\n+        *m.get_mut().unwrap() = NonCopy(20);\n+        assert_eq!(m.into_inner().unwrap(), NonCopy(20));\n+    }\n+\n+    #[test]\n+    fn test_get_mut_poison() {\n+        let m = Arc::new(Mutex::new(NonCopy(10)));\n+        let m2 = m.clone();\n+        let _ = thread::spawn(move || {\n+            let _lock = m2.lock().unwrap();\n+            panic!(\"test panic in inner thread to poison mutex\");\n+        }).join();\n+\n+        assert!(m.is_poisoned());\n+        match Arc::try_unwrap(m).unwrap().get_mut() {\n+            Err(e) => assert_eq!(*e.into_inner(), NonCopy(10)),\n+            Ok(x) => panic!(\"get_mut of poisoned Mutex is Ok: {:?}\", x),\n+        }\n+    }\n+\n     #[test]\n     fn test_mutex_arc_condvar() {\n         let packet = Packet(Arc::new((Mutex::new(false), Condvar::new())));"}]}