{"sha": "e60aa62ffe7462d48cb44ab33f2551b466745e83", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MGFhNjJmZmU3NDYyZDQ4Y2I0NGFiMzNmMjU1MWI0NjY3NDVlODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-24T21:14:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-24T21:14:17Z"}, "message": "Auto merge of #38594 - steveklabnik:rollup, r=steveklabnik\n\nRollup of 14 pull requests\n\n- Successful merges: #37956, #38013, #38297, #38480, #38497, #38502, #38505, #38513, #38521, #38549, #38554, #38557, #38568, #38572\n- Failed merges:", "tree": {"sha": "97d19ca2d9cedb110340266922ae30aab94347b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97d19ca2d9cedb110340266922ae30aab94347b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e60aa62ffe7462d48cb44ab33f2551b466745e83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e60aa62ffe7462d48cb44ab33f2551b466745e83", "html_url": "https://github.com/rust-lang/rust/commit/e60aa62ffe7462d48cb44ab33f2551b466745e83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e60aa62ffe7462d48cb44ab33f2551b466745e83/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00e61d41859514c906b8b630ea10ececa4f0c2cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/00e61d41859514c906b8b630ea10ececa4f0c2cd", "html_url": "https://github.com/rust-lang/rust/commit/00e61d41859514c906b8b630ea10ececa4f0c2cd"}, {"sha": "df63b0ce720a846e8c7983b1b26ed3e3d36ba972", "url": "https://api.github.com/repos/rust-lang/rust/commits/df63b0ce720a846e8c7983b1b26ed3e3d36ba972", "html_url": "https://github.com/rust-lang/rust/commit/df63b0ce720a846e8c7983b1b26ed3e3d36ba972"}], "stats": {"total": 896, "additions": 848, "deletions": 48}, "files": [{"sha": "ac84edb4038470445bdc7e56b93ade654fa4c18b", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -142,7 +142,7 @@ incremental builds:\n ```\n \n The `--incremental` flag will store incremental compilation artifacts\n-in `build/stage0-incremental`. Note that we only use incremental\n+in `build/<host>/stage0-incremental`. Note that we only use incremental\n compilation for the stage0 -> stage1 compilation -- this is because\n the stage1 compiler is changing, and we don't try to cache and reuse\n incremental artifacts across different versions of the compiler. For"}, {"sha": "a8f8224c58b81e3ca43c6b83bccfb2aa8715e712", "filename": "src/doc/book/casting-between-types.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Fdoc%2Fbook%2Fcasting-between-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Fdoc%2Fbook%2Fcasting-between-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcasting-between-types.md?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -16,18 +16,18 @@ function result.\n \n The most common case of coercion is removing mutability from a reference:\n \n- * `&mut T` to `&T`\n+* `&mut T` to `&T`\n \n An analogous conversion is to remove mutability from a\n [raw pointer](raw-pointers.md):\n \n- * `*mut T` to `*const T`\n+* `*mut T` to `*const T`\n \n References can also be coerced to raw pointers:\n \n- * `&T` to `*const T`\n+* `&T` to `*const T`\n \n- * `&mut T` to `*mut T`\n+* `&mut T` to `*mut T`\n \n Custom coercions may be defined using [`Deref`](deref-coercions.md).\n \n@@ -59,11 +59,11 @@ A cast `e as U` is valid if `e` has type `T` and `T` *coerces* to `U`.\n \n A cast `e as U` is also valid in any of the following cases:\n \n- * `e` has type `T` and `T` and `U` are any numeric types; *numeric-cast*\n- * `e` is a C-like enum (with no data attached to the variants),\n-    and `U` is an integer type; *enum-cast*\n- * `e` has type `bool` or `char` and `U` is an integer type; *prim-int-cast*\n- * `e` has type `u8` and `U` is `char`; *u8-char-cast*\n+* `e` has type `T` and `T` and `U` are any numeric types; *numeric-cast*\n+* `e` is a C-like enum (with no data attached to the variants),\n+   and `U` is an integer type; *enum-cast*\n+* `e` has type `bool` or `char` and `U` is an integer type; *prim-int-cast*\n+* `e` has type `u8` and `U` is `char`; *u8-char-cast*\n \n For example\n "}, {"sha": "dafcffc39c802b0ff992fb4be06d8b9e5f86fcf2", "filename": "src/doc/book/documentation.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Fdoc%2Fbook%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Fdoc%2Fbook%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fdocumentation.md?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -460,8 +460,9 @@ not actually pass as a test.\n ```\n \n The `no_run` attribute will compile your code, but not run it. This is\n-important for examples such as \"Here's how to start up a network service,\"\n-which you would want to make sure compile, but might run in an infinite loop!\n+important for examples such as \"Here's how to retrieve a web page,\"\n+which you would want to ensure compiles, but might be run in a test\n+environment that has no network access.\n \n ### Documenting modules\n "}, {"sha": "96cec7295aa9d11abfcd6d4598543137194da9ed", "filename": "src/doc/book/testing.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Fdoc%2Fbook%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Fdoc%2Fbook%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftesting.md?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -589,11 +589,10 @@ please see the [Documentation chapter](documentation.html).\n \n # Testing and concurrency\n \n-One thing that is important to note when writing tests is that they may be run\n-concurrently using threads. For this reason you should take care that your tests\n-are written in such a way as to not depend on each-other, or on any shared\n-state. \"Shared state\" can also include the environment, such as the current\n-working directory, or environment variables.\n+It is important to note that tests are run concurrently using threads. For this\n+reason, care should be taken to ensure your tests do not depend on each-other,\n+or on any shared state. \"Shared state\" can also include the environment, such\n+as the current working directory, or environment variables.\n \n If this is an issue it is possible to control this concurrency, either by\n setting the environment variable `RUST_TEST_THREADS`, or by passing the argument"}, {"sha": "310855090885caf3ecf48100cfe6490d36f39cd1", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -10,8 +10,15 @@\n \n //! A doubly-linked list with owned nodes.\n //!\n-//! The `LinkedList` allows pushing and popping elements at either end and is thus\n-//! efficiently usable as a double-ended queue.\n+//! The `LinkedList` allows pushing and popping elements at either end\n+//! in constant time.\n+//!\n+//! Almost always it is better to use `Vec` or [`VecDeque`] instead of\n+//! [`LinkedList`]. In general, array-based containers are faster,\n+//! more memory efficient and make better use of CPU cache.\n+//!\n+//! [`LinkedList`]: ../linked_list/struct.LinkedList.html\n+//! [`VecDeque`]: ../vec_deque/struct.VecDeque.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -27,7 +34,14 @@ use core::ptr::{self, Shared};\n \n use super::SpecExtend;\n \n-/// A doubly-linked list.\n+/// A doubly-linked list with owned nodes.\n+///\n+/// The `LinkedList` allows pushing and popping elements at either end\n+/// in constant time.\n+///\n+/// Almost always it is better to use `Vec` or `VecDeque` instead of\n+/// `LinkedList`. In general, array-based containers are faster,\n+/// more memory efficient and make better use of CPU cache.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LinkedList<T> {\n     head: Option<Shared<Node<T>>>,"}, {"sha": "ccae5f3b003662a08cca8ac62fe3173bef9259c4", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -28,7 +28,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit as visit;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv;\n-use std::hash::Hash;\n+use std::hash::{Hash, Hasher};\n \n use super::def_path_hash::DefPathHashes;\n use super::caching_codemap_view::CachingCodemapView;\n@@ -264,7 +264,7 @@ enum SawExprComponent<'a> {\n     SawExprPath,\n     SawExprAddrOf(hir::Mutability),\n     SawExprRet,\n-    SawExprInlineAsm(&'a hir::InlineAsm),\n+    SawExprInlineAsm(StableInlineAsm<'a>),\n     SawExprStruct,\n     SawExprRepeat,\n }\n@@ -340,7 +340,7 @@ fn saw_expr<'a>(node: &'a Expr_,\n         ExprBreak(label, _)      => (SawExprBreak(label.map(|l| l.name.as_str())), false),\n         ExprAgain(label)         => (SawExprAgain(label.map(|l| l.name.as_str())), false),\n         ExprRet(..)              => (SawExprRet, false),\n-        ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(a), false),\n+        ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(StableInlineAsm(a)), false),\n         ExprStruct(..)           => (SawExprStruct, false),\n         ExprRepeat(..)           => (SawExprRepeat, false),\n     }\n@@ -491,6 +491,46 @@ enum SawSpanExpnKind {\n     SomeExpansion,\n }\n \n+/// A wrapper that provides a stable Hash implementation.\n+struct StableInlineAsm<'a>(&'a InlineAsm);\n+\n+impl<'a> Hash for StableInlineAsm<'a> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        let InlineAsm {\n+            asm,\n+            asm_str_style,\n+            ref outputs,\n+            ref inputs,\n+            ref clobbers,\n+            volatile,\n+            alignstack,\n+            dialect,\n+            expn_id: _, // This is used for error reporting\n+        } = *self.0;\n+\n+        asm.as_str().hash(state);\n+        asm_str_style.hash(state);\n+        outputs.len().hash(state);\n+        for output in outputs {\n+            let InlineAsmOutput { constraint, is_rw, is_indirect } = *output;\n+            constraint.as_str().hash(state);\n+            is_rw.hash(state);\n+            is_indirect.hash(state);\n+        }\n+        inputs.len().hash(state);\n+        for input in inputs {\n+            input.as_str().hash(state);\n+        }\n+        clobbers.len().hash(state);\n+        for clobber in clobbers {\n+            clobber.as_str().hash(state);\n+        }\n+        volatile.hash(state);\n+        alignstack.hash(state);\n+        dialect.hash(state);\n+    }\n+}\n+\n macro_rules! hash_attrs {\n     ($visitor:expr, $attrs:expr) => ({\n         let attrs = $attrs;"}, {"sha": "d3a2b6f1683e228994ae2c66d84836edac885b6e", "filename": "src/librustc_metadata/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -57,9 +57,9 @@ An unknown \"kind\" was specified for a link attribute. Erroneous code example:\n \n Please specify a valid \"kind\" value, from one of the following:\n \n- * static\n- * dylib\n- * framework\n+* static\n+* dylib\n+* framework\n \n \"##,\n "}, {"sha": "cd43cbd7052825ab92e083b97ea395f0106316fe", "filename": "src/librustc_trans/README.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibrustc_trans%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibrustc_trans%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FREADME.md?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -0,0 +1 @@\n+See [librustc/README.md](../librustc/README.md)."}, {"sha": "1f416d5404d2778d0fdea4768371232068e2bae8", "filename": "src/librustc_trans/README.txt", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/00e61d41859514c906b8b630ea10ececa4f0c2cd/src%2Flibrustc_trans%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/00e61d41859514c906b8b630ea10ececa4f0c2cd/src%2Flibrustc_trans%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FREADME.txt?ref=00e61d41859514c906b8b630ea10ececa4f0c2cd", "patch": "@@ -1 +0,0 @@\n-See the README.md in ../librustc."}, {"sha": "2b17ac94b2238fea3bc93fdb2278658b9713b1df", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -1378,8 +1378,8 @@ let x = |_| {}; // error: cannot determine a type for this expression\n \n You have two possibilities to solve this situation:\n \n- * Give an explicit definition of the expression\n- * Infer the expression\n+* Give an explicit definition of the expression\n+* Infer the expression\n \n Examples:\n "}, {"sha": "796a3a93068c8a5d8886a39b83057594ffdce949", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -207,7 +207,7 @@ impl<'a> fmt::Display for WhereClause<'a> {\n         if !f.alternate() {\n             clause.push_str(\"</span>\");\n             let plain = format!(\"{:#}\", self);\n-            if plain.len() > 80 {\n+            if plain.len() + pad > 80 {\n                 //break it onto its own line regardless, but make sure method impls and trait\n                 //blocks keep their fixed padding (2 and 9, respectively)\n                 let padding = if pad > 10 {"}, {"sha": "06a816412969bfc7eff9475db1fa481cf7688aff", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -46,6 +46,7 @@ r##\"<!DOCTYPE html>\n \n     <title>{title}</title>\n \n+    <link rel=\"stylesheet\" type=\"text/css\" href=\"{root_path}normalize.css\">\n     <link rel=\"stylesheet\" type=\"text/css\" href=\"{root_path}rustdoc.css\">\n     <link rel=\"stylesheet\" type=\"text/css\" href=\"{root_path}main.css\">\n     {css_extension}"}, {"sha": "ce7c6acdf47f921b5ca34d39583962075b43fb76", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -1,5 +1,3 @@\n-@import \"normalize.css\";\n-\n /**\n  * Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n  * file at the top-level directory of this distribution and at"}, {"sha": "5450a10c9bd9f1111763c171d7781d7e55dc415f", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -1425,6 +1425,12 @@ pub trait BufRead: Read {\n     ///     println!(\"{}\", line.unwrap());\n     /// }\n     /// ```\n+    ///\n+    /// # Errors\n+    ///\n+    /// Each line of the iterator has the same error semantics as [`BufRead::read_line()`].\n+    ///\n+    /// [`BufRead::read_line()`]: trait.BufRead.html#method.read_line\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(self) -> Lines<Self> where Self: Sized {\n         Lines { buf: self }"}, {"sha": "2bb005be4ec93421675a9ab2d5189e7bc0a8e1d0", "filename": "src/libstd/sys/unix/process/magenta.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -23,7 +23,6 @@ pub type mx_rights_t = u32;\n pub type mx_status_t = i32;\n \n pub type mx_size_t = usize;\n-pub type mx_ssize_t = isize;\n \n pub const MX_HANDLE_INVALID: mx_handle_t = 0;\n "}, {"sha": "6d8b3cc93d9de47cd0d5d507ba384a0e312c15aa", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 83, "deletions": 14, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -318,20 +318,38 @@ impl Builder {\n // Free functions\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// Spawns a new thread, returning a `JoinHandle` for it.\n+/// Spawns a new thread, returning a [`JoinHandle`] for it.\n ///\n /// The join handle will implicitly *detach* the child thread upon being\n /// dropped. In this case, the child thread may outlive the parent (unless\n /// the parent thread is the main thread; the whole process is terminated when\n-/// the main thread finishes.) Additionally, the join handle provides a `join`\n+/// the main thread finishes). Additionally, the join handle provides a [`join`]\n /// method that can be used to join the child thread. If the child thread\n-/// panics, `join` will return an `Err` containing the argument given to\n-/// `panic`.\n+/// panics, [`join`] will return an [`Err`] containing the argument given to\n+/// [`panic`].\n ///\n /// # Panics\n ///\n-/// Panics if the OS fails to create a thread; use `Builder::spawn`\n+/// Panics if the OS fails to create a thread; use [`Builder::spawn`]\n /// to recover from such errors.\n+///\n+/// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n+/// [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n+/// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+/// [`panic!`]: ../../std/macro.panic.html\n+/// [`Builder::spawn`]: ../../std/thread/struct.Builder.html#method.spawn\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::thread;\n+///\n+/// let handler = thread::spawn(|| {\n+///     // thread code\n+/// });\n+///\n+/// handler.join().unwrap();\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn spawn<F, T>(f: F) -> JoinHandle<T> where\n     F: FnOnce() -> T, F: Send + 'static, T: Send + 'static\n@@ -341,7 +359,7 @@ pub fn spawn<F, T>(f: F) -> JoinHandle<T> where\n \n /// Gets a handle to the thread that invokes it.\n ///\n-/// #Examples\n+/// # Examples\n ///\n /// Getting a handle to the current thread with `thread::current()`:\n ///\n@@ -366,6 +384,14 @@ pub fn current() -> Thread {\n }\n \n /// Cooperatively gives up a timeslice to the OS scheduler.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::thread;\n+///\n+/// thread::yield_now();\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn yield_now() {\n     imp::Thread::yield_now()\n@@ -375,7 +401,7 @@ pub fn yield_now() {\n ///\n /// # Examples\n ///\n-/// ```rust,should_panic\n+/// ```should_panic\n /// use std::thread;\n ///\n /// struct SomeStruct;\n@@ -413,6 +439,15 @@ pub fn panicking() -> bool {\n /// specifics or platform-dependent functionality. Note that on unix platforms\n /// this function will not return early due to a signal being received or a\n /// spurious wakeup.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::thread;\n+///\n+/// // Let's sleep for 2 seconds:\n+/// thread::sleep_ms(2000);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::thread::sleep`\")]\n pub fn sleep_ms(ms: u32) {\n@@ -433,7 +468,7 @@ pub fn sleep_ms(ms: u32) {\n ///\n /// # Examples\n ///\n-/// ```rust,no_run\n+/// ```no_run\n /// use std::{thread, time};\n ///\n /// let ten_millis = time::Duration::from_millis(10);\n@@ -749,7 +784,7 @@ impl<T> JoinInner<T> {\n ///\n /// A `JoinHandle` *detaches* the child thread when it is dropped.\n ///\n-/// Due to platform restrictions, it is not possible to `Clone` this\n+/// Due to platform restrictions, it is not possible to [`Clone`] this\n /// handle: the ability to join a child thread is a uniquely-owned\n /// permission.\n ///\n@@ -760,7 +795,7 @@ impl<T> JoinInner<T> {\n ///\n /// Creation from [`thread::spawn`]:\n ///\n-/// ```rust\n+/// ```\n /// use std::thread;\n ///\n /// let join_handle: thread::JoinHandle<_> = thread::spawn(|| {\n@@ -770,7 +805,7 @@ impl<T> JoinInner<T> {\n ///\n /// Creation from [`thread::Builder::spawn`]:\n ///\n-/// ```rust\n+/// ```\n /// use std::thread;\n ///\n /// let builder = thread::Builder::new();\n@@ -780,22 +815,56 @@ impl<T> JoinInner<T> {\n /// }).unwrap();\n /// ```\n ///\n+/// [`Clone`]: ../../std/clone/trait.Clone.html\n /// [`thread::spawn`]: fn.spawn.html\n /// [`thread::Builder::spawn`]: struct.Builder.html#method.spawn\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct JoinHandle<T>(JoinInner<T>);\n \n impl<T> JoinHandle<T> {\n-    /// Extracts a handle to the underlying thread\n+    /// Extracts a handle to the underlying thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(thread_id)]\n+    ///\n+    /// use std::thread;\n+    ///\n+    /// let builder = thread::Builder::new();\n+    ///\n+    /// let join_handle: thread::JoinHandle<_> = builder.spawn(|| {\n+    ///     // some work here\n+    /// }).unwrap();\n+    ///\n+    /// let thread = join_handle.thread();\n+    /// println!(\"thread id: {:?}\", thread.id());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn thread(&self) -> &Thread {\n         &self.0.thread\n     }\n \n     /// Waits for the associated thread to finish.\n     ///\n-    /// If the child thread panics, `Err` is returned with the parameter given\n-    /// to `panic`.\n+    /// If the child thread panics, [`Err`] is returned with the parameter given\n+    /// to [`panic`].\n+    ///\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+    /// [`panic!`]: ../../std/macro.panic.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::thread;\n+    ///\n+    /// let builder = thread::Builder::new();\n+    ///\n+    /// let join_handle: thread::JoinHandle<_> = builder.spawn(|| {\n+    ///     // some work here\n+    /// }).unwrap();\n+    /// join_handle.join().expect(\"Couldn't join on the associated thread\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn join(mut self) -> Result<T> {\n         self.0.join()"}, {"sha": "5c37bc133596dd02cf8e369c396a50aee8a7eb55", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 409, "deletions": 1, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -107,7 +107,7 @@ impl Foo {\n     pub fn method_selfness(&self) { }\n }\n \n-// Change Method Selfmutness -----------------------------------------------------------\n+// Change Method Selfmutness ---------------------------------------------------\n #[cfg(cfail1)]\n impl Foo {\n     pub fn method_selfmutness(&self) { }\n@@ -126,3 +126,411 @@ impl Foo {\n     pub fn method_selfmutness(&mut self) { }\n }\n \n+\n+\n+// Add Method To Impl ----------------------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn add_method_to_impl1(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn add_method_to_impl1(&self) { }\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn add_method_to_impl2(&self) { }\n+}\n+\n+\n+\n+// Add Method Parameter --------------------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn add_method_parameter(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn add_method_parameter(&self, _: i32) { }\n+}\n+\n+\n+\n+// Change Method Parameter Name ------------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn change_method_parameter_name(&self, a: i64) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn change_method_parameter_name(&self, b: i64) { }\n+}\n+\n+\n+\n+// Change Method Return Type ---------------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn change_method_return_type(&self) -> u16 { 0 }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn change_method_return_type(&self) -> u8 { 0 }\n+}\n+\n+\n+\n+// Make Method #[inline] -------------------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn make_method_inline(&self) -> u8 { 0 }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    #[inline]\n+    pub fn make_method_inline(&self) -> u8 { 0 }\n+}\n+\n+\n+\n+//  Change order of parameters -------------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn change_method_parameter_order(&self, a: i64, b: i64) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn change_method_parameter_order(&self, b: i64, a: i64) { }\n+}\n+\n+\n+\n+// Make method unsafe ----------------------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn make_method_unsafe(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub unsafe fn make_method_unsafe(&self) { }\n+}\n+\n+\n+\n+// Make method extern ----------------------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn make_method_extern(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub extern fn make_method_extern(&self) { }\n+}\n+\n+\n+\n+// Change method calling convention --------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub extern \"C\" fn change_method_calling_convention(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub extern \"system\" fn change_method_calling_convention(&self) { }\n+}\n+\n+\n+\n+// Add Lifetime Parameter to Method --------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn add_lifetime_parameter_to_method(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn add_lifetime_parameter_to_method<'a>(&self) { }\n+}\n+\n+\n+\n+// Add Type Parameter To Method ------------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn add_type_parameter_to_method(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn add_type_parameter_to_method<T>(&self) { }\n+}\n+\n+\n+\n+// Add Lifetime Bound to Lifetime Parameter of Method --------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn add_lifetime_bound_to_lifetime_param_of_method<'a, 'b>(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn add_lifetime_bound_to_lifetime_param_of_method<'a, 'b: 'a>(&self) { }\n+}\n+\n+\n+\n+// Add Lifetime Bound to Type Parameter of Method ------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn add_lifetime_bound_to_type_param_of_method<'a, T>(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn add_lifetime_bound_to_type_param_of_method<'a, T: 'a>(&self) { }\n+}\n+\n+\n+\n+// Add Trait Bound to Type Parameter of Method ------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn add_trait_bound_to_type_param_of_method<T>(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn add_trait_bound_to_type_param_of_method<T: Clone>(&self) { }\n+}\n+\n+\n+\n+// Add #[no_mangle] to Method --------------------------------------------------\n+#[cfg(cfail1)]\n+impl Foo {\n+    pub fn add_no_mangle_to_method(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    #[no_mangle]\n+    pub fn add_no_mangle_to_method(&self) { }\n+}\n+\n+\n+\n+struct Bar<T>(T);\n+\n+// Add Type Parameter To Impl --------------------------------------------------\n+#[cfg(cfail1)]\n+impl Bar<u32> {\n+    pub fn add_type_parameter_to_impl(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl<T> Bar<T> {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn add_type_parameter_to_impl(&self) { }\n+}\n+\n+\n+\n+// Change Self Type of Impl ----------------------------------------------------\n+#[cfg(cfail1)]\n+impl Bar<u32> {\n+    pub fn change_impl_self_type(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl Bar<u64> {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn change_impl_self_type(&self) { }\n+}\n+\n+\n+\n+// Add Lifetime Bound to Impl --------------------------------------------------\n+#[cfg(cfail1)]\n+impl<T> Bar<T> {\n+    pub fn add_lifetime_bound_to_impl_parameter(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl<T: 'static> Bar<T> {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn add_lifetime_bound_to_impl_parameter(&self) { }\n+}\n+\n+\n+\n+// Add Trait Bound to Impl Parameter -------------------------------------------\n+#[cfg(cfail1)]\n+impl<T> Bar<T> {\n+    pub fn add_trait_bound_to_impl_parameter(&self) { }\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+impl<T: Clone> Bar<T> {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub fn add_trait_bound_to_impl_parameter(&self) { }\n+}"}, {"sha": "a1057c036d6c4f771ffeb63ef270b3bd92b6b69b", "filename": "src/test/incremental/hashes/inline_asm.rs", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Ftest%2Fincremental%2Fhashes%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e60aa62ffe7462d48cb44ab33f2551b466745e83/src%2Ftest%2Fincremental%2Fhashes%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finline_asm.rs?ref=e60aa62ffe7462d48cb44ab33f2551b466745e83", "patch": "@@ -0,0 +1,265 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for inline asm.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![feature(asm)]\n+#![crate_type=\"rlib\"]\n+\n+\n+\n+// Change template -------------------------------------------------------------\n+#[cfg(cfail1)]\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn change_template(a: i32) -> i32 {\n+    let c: i32;\n+    unsafe {\n+        asm!(\"add 1, $0\"\n+             : \"=r\"(c)\n+             : \"0\"(a)\n+             :\n+             :\n+             );\n+    }\n+    c\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn change_template(a: i32) -> i32 {\n+    let c: i32;\n+    unsafe {\n+        asm!(\"add 2, $0\"\n+             : \"=r\"(c)\n+             : \"0\"(a)\n+             :\n+             :\n+             );\n+    }\n+    c\n+}\n+\n+\n+\n+// Change output -------------------------------------------------------------\n+#[cfg(cfail1)]\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn change_output(a: i32) -> i32 {\n+    let mut _out1: i32 = 0;\n+    let mut _out2: i32 = 0;\n+    unsafe {\n+        asm!(\"add 1, $0\"\n+             : \"=r\"(_out1)\n+             : \"0\"(a)\n+             :\n+             :\n+             );\n+    }\n+    _out1\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn change_output(a: i32) -> i32 {\n+    let mut _out1: i32 = 0;\n+    let mut _out2: i32 = 0;\n+    unsafe {\n+        asm!(\"add 1, $0\"\n+             : \"=r\"(_out2)\n+             : \"0\"(a)\n+             :\n+             :\n+             );\n+    }\n+    _out1\n+}\n+\n+\n+\n+// Change input -------------------------------------------------------------\n+#[cfg(cfail1)]\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn change_input(_a: i32, _b: i32) -> i32 {\n+    let _out;\n+    unsafe {\n+        asm!(\"add 1, $0\"\n+             : \"=r\"(_out)\n+             : \"0\"(_a)\n+             :\n+             :\n+             );\n+    }\n+    _out\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn change_input(_a: i32, _b: i32) -> i32 {\n+    let _out;\n+    unsafe {\n+        asm!(\"add 1, $0\"\n+             : \"=r\"(_out)\n+             : \"0\"(_b)\n+             :\n+             :\n+             );\n+    }\n+    _out\n+}\n+\n+\n+\n+// Change input constraint -----------------------------------------------------\n+#[cfg(cfail1)]\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn change_input_constraint(_a: i32, _b: i32) -> i32 {\n+    let _out;\n+    unsafe {\n+        asm!(\"add 1, $0\"\n+             : \"=r\"(_out)\n+             : \"0\"(_a), \"r\"(_b)\n+             :\n+             :\n+             );\n+    }\n+    _out\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn change_input_constraint(_a: i32, _b: i32) -> i32 {\n+    let _out;\n+    unsafe {\n+        asm!(\"add 1, $0\"\n+             : \"=r\"(_out)\n+             : \"r\"(_a), \"0\"(_b)\n+             :\n+             :\n+             );\n+    }\n+    _out\n+}\n+\n+\n+\n+// Change clobber --------------------------------------------------------------\n+#[cfg(cfail1)]\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn change_clobber(_a: i32) -> i32 {\n+    let _out;\n+    unsafe {\n+        asm!(\"add 1, $0\"\n+             : \"=r\"(_out)\n+             : \"0\"(_a)\n+             :\n+             :\n+             );\n+    }\n+    _out\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn change_clobber(_a: i32) -> i32 {\n+    let _out;\n+    unsafe {\n+        asm!(\"add 1, $0\"\n+             : \"=r\"(_out)\n+             : \"0\"(_a)\n+             : \"eax\"\n+             :\n+             );\n+    }\n+    _out\n+}\n+\n+\n+\n+// Change options --------------------------------------------------------------\n+#[cfg(cfail1)]\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn change_options(_a: i32) -> i32 {\n+    let _out;\n+    unsafe {\n+        asm!(\"add 1, $0\"\n+             : \"=r\"(_out)\n+             : \"0\"(_a)\n+             :\n+             :\n+             );\n+    }\n+    _out\n+}\n+\n+#[cfg(not(cfail1))]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn change_options(_a: i32) -> i32 {\n+    let _out;\n+    unsafe {\n+        asm!(\"add 1, $0\"\n+             : \"=r\"(_out)\n+             : \"0\"(_a)\n+             :\n+             : \"volatile\"\n+             );\n+    }\n+    _out\n+}\n+\n+\n+"}]}