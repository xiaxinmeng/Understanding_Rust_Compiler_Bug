{"sha": "01b35d82e51458870f61cf850b73479f253fcb54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxYjM1ZDgyZTUxNDU4ODcwZjYxY2Y4NTBiNzM0NzlmMjUzZmNiNTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-03T11:40:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-03T11:40:38Z"}, "message": "Auto merge of #36072 - arthurprs:binary_heap_opt, r=Aatch\n\nOptimize BinaryHeap bounds checking\n\nI was experimenting with d-ary binary heaps during the weekend (dead end) and I found that we could get some good improvements by removing bounds checking. Specially due to the panic-safe additional code, llvm can't really optimize them out.\n\n```\n name                         d_ary_heap:: ns/iter  std___heap:: ns/iter  diff ns/iter  diff %\n bench_build_insert           148,610               236,960                     88,350  59.45%\n bench_from_vec               243,846               299,719                     55,873  22.91%\n bench_insert_2000_empty      4,512                 7,517                        3,005  66.60%\n bench_insert_2000_prefilled  28,665                32,605                       3,940  13.74%\n bench_pop_2000               111,515               128,005                     16,490  14.79%\n bench_pop_all                2,759,945             3,317,626                  557,681  20.21%\n peek_mut                     23,186                23,635                         449   1.94%\n pop_modify_push              41,573                43,822                       2,249   5.41%\n\ntest d_ary_heap::bench_build_insert          ... bench:     148,610 ns/iter (+/- 10,687)\ntest d_ary_heap::bench_from_vec              ... bench:     243,846 ns/iter (+/- 16,500)\ntest d_ary_heap::bench_insert_2000_empty     ... bench:       4,512 ns/iter (+/- 136)\ntest d_ary_heap::bench_insert_2000_prefilled ... bench:      28,665 ns/iter (+/- 1,347)\ntest d_ary_heap::bench_pop_2000              ... bench:     111,515 ns/iter (+/- 104,677)\ntest d_ary_heap::bench_pop_all               ... bench:   2,759,945 ns/iter (+/- 173,838)\ntest d_ary_heap::peek_mut                    ... bench:      23,186 ns/iter (+/- 106,254)\ntest d_ary_heap::pop_modify_push             ... bench:      41,573 ns/iter (+/- 3,313)\ntest std___heap::bench_build_insert          ... bench:     236,960 ns/iter (+/- 16,955)\ntest std___heap::bench_from_vec              ... bench:     299,719 ns/iter (+/- 6,354)\ntest std___heap::bench_insert_2000_empty     ... bench:       7,517 ns/iter (+/- 372)\ntest std___heap::bench_insert_2000_prefilled ... bench:      32,605 ns/iter (+/- 2,433)\ntest std___heap::bench_pop_2000              ... bench:     128,005 ns/iter (+/- 11,787)\ntest std___heap::bench_pop_all               ... bench:   3,317,626 ns/iter (+/- 238,968)\ntest std___heap::peek_mut                    ... bench:      23,635 ns/iter (+/- 1,420)\ntest std___heap::pop_modify_push             ... bench:      43,822 ns/iter (+/- 3,788)\n```\n\nTest code: https://github.com/arthurprs/heap-experiments", "tree": {"sha": "55560818c489cafd30402aa46eb0a6fbdf1aa8f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55560818c489cafd30402aa46eb0a6fbdf1aa8f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01b35d82e51458870f61cf850b73479f253fcb54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01b35d82e51458870f61cf850b73479f253fcb54", "html_url": "https://github.com/rust-lang/rust/commit/01b35d82e51458870f61cf850b73479f253fcb54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01b35d82e51458870f61cf850b73479f253fcb54/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a029ea343fe5c9b7cf550902b5a507cd8c22a833", "url": "https://api.github.com/repos/rust-lang/rust/commits/a029ea343fe5c9b7cf550902b5a507cd8c22a833", "html_url": "https://github.com/rust-lang/rust/commit/a029ea343fe5c9b7cf550902b5a507cd8c22a833"}, {"sha": "175d434c99a29de6bb9293a2fa3b7c94ef51c3da", "url": "https://api.github.com/repos/rust-lang/rust/commits/175d434c99a29de6bb9293a2fa3b7c94ef51c3da", "html_url": "https://github.com/rust-lang/rust/commit/175d434c99a29de6bb9293a2fa3b7c94ef51c3da"}], "stats": {"total": 43, "additions": 23, "deletions": 20}, "files": [{"sha": "0b923468c7416164611e935c4d579ccfed4b61ea", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/01b35d82e51458870f61cf850b73479f253fcb54/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01b35d82e51458870f61cf850b73479f253fcb54/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=01b35d82e51458870f61cf850b73479f253fcb54", "patch": "@@ -884,58 +884,61 @@ struct Hole<'a, T: 'a> {\n \n impl<'a, T> Hole<'a, T> {\n     /// Create a new Hole at index `pos`.\n-    fn new(data: &'a mut [T], pos: usize) -> Self {\n-        unsafe {\n-            let elt = ptr::read(&data[pos]);\n-            Hole {\n-                data: data,\n-                elt: Some(elt),\n-                pos: pos,\n-            }\n+    ///\n+    /// Unsafe because pos must be within the data slice.\n+    #[inline]\n+    unsafe fn new(data: &'a mut [T], pos: usize) -> Self {\n+        debug_assert!(pos < data.len());\n+        let elt = ptr::read(&data[pos]);\n+        Hole {\n+            data: data,\n+            elt: Some(elt),\n+            pos: pos,\n         }\n     }\n \n-    #[inline(always)]\n+    #[inline]\n     fn pos(&self) -> usize {\n         self.pos\n     }\n \n     /// Return a reference to the element removed\n-    #[inline(always)]\n+    #[inline]\n     fn element(&self) -> &T {\n         self.elt.as_ref().unwrap()\n     }\n \n     /// Return a reference to the element at `index`.\n     ///\n-    /// Panics if the index is out of bounds.\n-    ///\n-    /// Unsafe because index must not equal pos.\n-    #[inline(always)]\n+    /// Unsafe because index must be within the data slice and not equal to pos.\n+    #[inline]\n     unsafe fn get(&self, index: usize) -> &T {\n         debug_assert!(index != self.pos);\n-        &self.data[index]\n+        debug_assert!(index < self.data.len());\n+        self.data.get_unchecked(index)\n     }\n \n     /// Move hole to new location\n     ///\n-    /// Unsafe because index must not equal pos.\n-    #[inline(always)]\n+    /// Unsafe because index must be within the data slice and not equal to pos.\n+    #[inline]\n     unsafe fn move_to(&mut self, index: usize) {\n         debug_assert!(index != self.pos);\n-        let index_ptr: *const _ = &self.data[index];\n-        let hole_ptr = &mut self.data[self.pos];\n+        debug_assert!(index < self.data.len());\n+        let index_ptr: *const _ = self.data.get_unchecked(index);\n+        let hole_ptr = self.data.get_unchecked_mut(self.pos);\n         ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n         self.pos = index;\n     }\n }\n \n impl<'a, T> Drop for Hole<'a, T> {\n+    #[inline]\n     fn drop(&mut self) {\n         // fill the hole again\n         unsafe {\n             let pos = self.pos;\n-            ptr::write(&mut self.data[pos], self.elt.take().unwrap());\n+            ptr::write(self.data.get_unchecked_mut(pos), self.elt.take().unwrap());\n         }\n     }\n }"}]}