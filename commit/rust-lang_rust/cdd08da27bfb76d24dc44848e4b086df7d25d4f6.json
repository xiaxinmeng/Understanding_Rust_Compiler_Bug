{"sha": "cdd08da27bfb76d24dc44848e4b086df7d25d4f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkZDA4ZGEyN2JmYjc2ZDI0ZGM0NDg0OGU0YjA4NmRmN2QyNWQ0ZjY=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2019-03-19T09:19:45Z"}, "committer": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2019-03-19T09:19:45Z"}, "message": "fix line numbering in missed spans and handle file_lines in edge cases\n\n- a leading/trailing newline character in missed spans was throwing off the\n  start/end of ranges used to compare against file_lines\n- fix handling of file_lines when closing a block\n\nClose #3442", "tree": {"sha": "82f6ba6b29f058116f6a4caec8c8e4847a1c4634", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82f6ba6b29f058116f6a4caec8c8e4847a1c4634"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdd08da27bfb76d24dc44848e4b086df7d25d4f6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCgAdFiEEipi5pnt+pUplKNfibVYg2QghATMFAlyQ7HEACgkQbVYg2Qgh\nATMQMQgAitYE5oki5Fr8a3YN2ysJyMJb/rB9QMZvbkW5/iE4mU72vvPZWVCpKhi1\nZtvHaJSvG8JiGN09BRaVjaefH7kh0pUHrFJ6iKNYxJSoMJnkhAd2LN2fHzfGdyAP\ntkPlKr8O5+P+OFkUmUQermxnDQ7iYAYac4bBZG4M3gaaJ8djkD9N0MMU2rro1RXR\nADDZPsrRIYxAkwxD2by0XNyZihSL5PwoWhkjpxulgfi78bT7Ybg8SAMV9DELcA9Z\nylrG5zUxli8uKffCgsiyo77d62roSDt2yPUbRr68FhkS4n34peTgKwe0gINPWvi2\nFXeBfDe9hokh4OU9lercUlUcgdydFg==\n=n7pf\n-----END PGP SIGNATURE-----", "payload": "tree 82f6ba6b29f058116f6a4caec8c8e4847a1c4634\nparent 1427e4c20ba5cdc80a338347585c9de71a0dea4d\nauthor St\u00e9phane Campinas <stephane.campinas@gmail.com> 1552987185 +0100\ncommitter St\u00e9phane Campinas <stephane.campinas@gmail.com> 1552987185 +0100\n\nfix line numbering in missed spans and handle file_lines in edge cases\n\n- a leading/trailing newline character in missed spans was throwing off the\n  start/end of ranges used to compare against file_lines\n- fix handling of file_lines when closing a block\n\nClose #3442\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdd08da27bfb76d24dc44848e4b086df7d25d4f6", "html_url": "https://github.com/rust-lang/rust/commit/cdd08da27bfb76d24dc44848e4b086df7d25d4f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdd08da27bfb76d24dc44848e4b086df7d25d4f6/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1427e4c20ba5cdc80a338347585c9de71a0dea4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1427e4c20ba5cdc80a338347585c9de71a0dea4d", "html_url": "https://github.com/rust-lang/rust/commit/1427e4c20ba5cdc80a338347585c9de71a0dea4d"}], "stats": {"total": 127, "additions": 91, "deletions": 36}, "files": [{"sha": "70ca898f2af0600654b59798dc491a9d9b8d5a6d", "filename": "src/missed_spans.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cdd08da27bfb76d24dc44848e4b086df7d25d4f6/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd08da27bfb76d24dc44848e4b086df7d25d4f6/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=cdd08da27bfb76d24dc44848e4b086df7d25d4f6", "patch": "@@ -3,6 +3,7 @@ use std::borrow::Cow;\n use syntax::source_map::{BytePos, Pos, Span};\n \n use crate::comment::{rewrite_comment, CodeCharKind, CommentCodeSlices};\n+use crate::config::file_lines::FileLines;\n use crate::config::{EmitMode, FileName};\n use crate::shape::{Indent, Shape};\n use crate::source_map::LineRangeUtils;\n@@ -156,7 +157,7 @@ impl<'a> FmtVisitor<'a> {\n     fn write_snippet_inner<F>(\n         &mut self,\n         big_snippet: &str,\n-        big_diff: usize,\n+        mut big_diff: usize,\n         old_snippet: &str,\n         span: Span,\n         process_last_snippet: F,\n@@ -175,16 +176,36 @@ impl<'a> FmtVisitor<'a> {\n             _ => Cow::from(old_snippet),\n         };\n \n-        for (kind, offset, subslice) in CommentCodeSlices::new(snippet) {\n-            debug!(\"{:?}: {:?}\", kind, subslice);\n+        // if the snippet starts with a new line, then information about the lines needs to be\n+        // adjusted since it is off by 1.\n+        let snippet = if snippet.starts_with('\\n') {\n+            // this takes into account the blank_lines_* options\n+            self.push_vertical_spaces(1);\n+            // include the newline character into the big_diff\n+            big_diff += 1;\n+            status.cur_line += 1;\n+            &snippet[1..]\n+        } else {\n+            snippet\n+        };\n \n-            let newline_count = count_newlines(subslice);\n-            let within_file_lines_range = self.config.file_lines().contains_range(\n+        let slice_within_file_lines_range = |file_lines: FileLines, cur_line, s| -> (usize, bool) {\n+            let newline_count = count_newlines(s);\n+            let within_file_lines_range = file_lines.contains_range(\n                 file_name,\n-                status.cur_line,\n-                status.cur_line + newline_count,\n+                cur_line,\n+                // if a newline character is at the end of the slice, then the number of newlines\n+                // needs to be decreased by 1 so that the range checked against the file_lines is\n+                // the visual range one would expect.\n+                cur_line + newline_count - if s.ends_with('\\n') { 1 } else { 0 },\n             );\n+            (newline_count, within_file_lines_range)\n+        };\n+        for (kind, offset, subslice) in CommentCodeSlices::new(snippet) {\n+            debug!(\"{:?}: {:?}\", kind, subslice);\n \n+            let (newline_count, within_file_lines_range) =\n+                slice_within_file_lines_range(self.config.file_lines(), status.cur_line, subslice);\n             if CodeCharKind::Comment == kind && within_file_lines_range {\n                 // 1: comment.\n                 self.process_comment(\n@@ -205,7 +226,15 @@ impl<'a> FmtVisitor<'a> {\n             }\n         }\n \n-        process_last_snippet(self, &snippet[status.line_start..], snippet);\n+        let last_snippet = &snippet[status.line_start..];\n+        let (_, within_file_lines_range) =\n+            slice_within_file_lines_range(self.config.file_lines(), status.cur_line, last_snippet);\n+        if within_file_lines_range {\n+            process_last_snippet(self, last_snippet, snippet);\n+        } else {\n+            // just append what's left\n+            self.push_str(last_snippet);\n+        }\n     }\n \n     fn process_comment("}, {"sha": "096a7ce57131ae14226fb7885fb11b5c839536c8", "filename": "src/source_map.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdd08da27bfb76d24dc44848e4b086df7d25d4f6/src%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd08da27bfb76d24dc44848e4b086df7d25d4f6/src%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsource_map.rs?ref=cdd08da27bfb76d24dc44848e4b086df7d25d4f6", "patch": "@@ -71,6 +71,7 @@ impl<'a> SpanUtils for SnippetProvider<'a> {\n \n impl LineRangeUtils for SourceMap {\n     fn lookup_line_range(&self, span: Span) -> LineRange {\n+        let snippet = self.span_to_snippet(span).unwrap_or(String::new());\n         let lo = self.lookup_line(span.lo()).unwrap();\n         let hi = self.lookup_line(span.hi()).unwrap();\n \n@@ -80,11 +81,14 @@ impl LineRangeUtils for SourceMap {\n             lo, hi\n         );\n \n+        // in case the span starts with a newline, the line range is off by 1 without the\n+        // adjustment below\n+        let offset = 1 + if snippet.starts_with('\\n') { 1 } else { 0 };\n         // Line numbers start at 1\n         LineRange {\n             file: lo.sf.clone(),\n-            lo: lo.line + 1,\n-            hi: hi.line + 1,\n+            lo: lo.line + offset,\n+            hi: hi.line + offset,\n         }\n     }\n }"}, {"sha": "2c603fbebf7484787a8f81d8ce0ad39555a21b82", "filename": "src/visitor.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cdd08da27bfb76d24dc44848e4b086df7d25d4f6/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd08da27bfb76d24dc44848e4b086df7d25d4f6/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=cdd08da27bfb76d24dc44848e4b086df7d25d4f6", "patch": "@@ -6,6 +6,7 @@ use syntax::{ast, visit};\n \n use crate::attr::*;\n use crate::comment::{CodeCharKind, CommentCodeSlices, FindUncommented};\n+use crate::config::file_lines::FileName;\n use crate::config::{BraceStyle, Config, Version};\n use crate::expr::{format_expr, ExprType};\n use crate::items::{\n@@ -170,7 +171,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n         if skip_rewrite {\n             self.push_rewrite(b.span, None);\n-            self.close_block(false);\n+            self.close_block(false, b.span);\n             self.last_pos = source!(self, b.span).hi();\n             return;\n         }\n@@ -187,21 +188,25 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n         let mut remove_len = BytePos(0);\n         if let Some(stmt) = b.stmts.last() {\n-            let snippet = self.snippet(mk_sp(\n+            let span_after_last_stmt = mk_sp(\n                 stmt.span.hi(),\n                 source!(self, b.span).hi() - brace_compensation,\n-            ));\n-            let len = CommentCodeSlices::new(snippet)\n-                .last()\n-                .and_then(|(kind, _, s)| {\n-                    if kind == CodeCharKind::Normal && s.trim().is_empty() {\n-                        Some(s.len())\n-                    } else {\n-                        None\n-                    }\n-                });\n-            if let Some(len) = len {\n-                remove_len = BytePos::from_usize(len);\n+            );\n+            // if the span is outside of a file_lines range, then do not try to remove anything\n+            if !out_of_file_lines_range!(self, span_after_last_stmt) {\n+                let snippet = self.snippet(span_after_last_stmt);\n+                let len = CommentCodeSlices::new(snippet)\n+                    .last()\n+                    .and_then(|(kind, _, s)| {\n+                        if kind == CodeCharKind::Normal && s.trim().is_empty() {\n+                            Some(s.len())\n+                        } else {\n+                            None\n+                        }\n+                    });\n+                if let Some(len) = len {\n+                    remove_len = BytePos::from_usize(len);\n+                }\n             }\n         }\n \n@@ -220,24 +225,31 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         if unindent_comment {\n             self.block_indent = self.block_indent.block_indent(self.config);\n         }\n-        self.close_block(unindent_comment);\n+        self.close_block(unindent_comment, b.span);\n         self.last_pos = source!(self, b.span).hi();\n     }\n \n     // FIXME: this is a terrible hack to indent the comments between the last\n     // item in the block and the closing brace to the block's level.\n     // The closing brace itself, however, should be indented at a shallower\n     // level.\n-    fn close_block(&mut self, unindent_comment: bool) {\n-        let total_len = self.buffer.len();\n-        let chars_too_many = if unindent_comment {\n-            0\n-        } else if self.config.hard_tabs() {\n-            1\n-        } else {\n-            self.config.tab_spaces()\n-        };\n-        self.buffer.truncate(total_len - chars_too_many);\n+    fn close_block(&mut self, unindent_comment: bool, span: Span) {\n+        let file_name: FileName = self.source_map.span_to_filename(span).into();\n+        let skip_this_line = !self\n+            .config\n+            .file_lines()\n+            .contains_line(&file_name, self.line_number);\n+        if !skip_this_line {\n+            let total_len = self.buffer.len();\n+            let chars_too_many = if unindent_comment {\n+                0\n+            } else if self.config.hard_tabs() {\n+                1\n+            } else {\n+                self.config.tab_spaces()\n+            };\n+            self.buffer.truncate(total_len - chars_too_many);\n+        }\n         self.push_str(\"}\");\n         self.block_indent = self.block_indent.block_unindent(self.config);\n     }\n@@ -759,7 +771,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 self.visit_attrs(attrs, ast::AttrStyle::Inner);\n                 self.walk_mod_items(m);\n                 self.format_missing_with_indent(source!(self, m.inner).hi() - BytePos(1));\n-                self.close_block(false);\n+                self.close_block(false, m.inner);\n             }\n             self.last_pos = source!(self, m.inner).hi();\n         } else {"}, {"sha": "3664c50ee7a8b90c9cd3c7154e5d14f34237a8b0", "filename": "tests/target/issue-3442.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cdd08da27bfb76d24dc44848e4b086df7d25d4f6/tests%2Ftarget%2Fissue-3442.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdd08da27bfb76d24dc44848e4b086df7d25d4f6/tests%2Ftarget%2Fissue-3442.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3442.rs?ref=cdd08da27bfb76d24dc44848e4b086df7d25d4f6", "patch": "@@ -0,0 +1,10 @@\n+// rustfmt-file_lines: [{\"file\":\"tests/target/issue-3442.rs\",\"range\":[5,5]},{\"file\":\"tests/target/issue-3442.rs\",\"range\":[8,8]}]\n+\n+extern crate alpha; // comment 1\n+extern crate beta; // comment 2\n+#[allow(aaa)] // comment 3\n+#[macro_use]\n+extern crate gamma;\n+#[allow(bbb)] // comment 4\n+#[macro_use]\n+extern crate lazy_static;"}]}