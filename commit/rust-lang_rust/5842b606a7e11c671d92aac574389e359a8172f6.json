{"sha": "5842b606a7e11c671d92aac574389e359a8172f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NDJiNjA2YTdlMTFjNjcxZDkyYWFjNTc0Mzg5ZTM1OWE4MTcyZjY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-05T06:52:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:10Z"}, "message": "Migrate uv getaddrinfo away from ~fn()", "tree": {"sha": "3859b5535aee8bf5378d7bae6471ce6e8246fb15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3859b5535aee8bf5378d7bae6471ce6e8246fb15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5842b606a7e11c671d92aac574389e359a8172f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5842b606a7e11c671d92aac574389e359a8172f6", "html_url": "https://github.com/rust-lang/rust/commit/5842b606a7e11c671d92aac574389e359a8172f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5842b606a7e11c671d92aac574389e359a8172f6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be896288a366cbd165e0eac9c08fef4a019ee99d", "url": "https://api.github.com/repos/rust-lang/rust/commits/be896288a366cbd165e0eac9c08fef4a019ee99d", "html_url": "https://github.com/rust-lang/rust/commit/be896288a366cbd165e0eac9c08fef4a019ee99d"}], "stats": {"total": 212, "additions": 70, "deletions": 142}, "files": [{"sha": "36c4defdee9292e658d7562871d379ab2ac19b23", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 67, "deletions": 110, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/5842b606a7e11c671d92aac574389e359a8172f6/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5842b606a7e11c671d92aac574389e359a8172f6/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=5842b606a7e11c671d92aac574389e359a8172f6", "patch": "@@ -8,41 +8,44 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast::transmute;\n-use std::cell::Cell;\n-use std::libc::{c_int, c_void};\n-use std::ptr::null;\n use ai = std::rt::io::net::addrinfo;\n+use std::cast;\n+use std::libc::c_int;\n+use std::ptr::null;\n+use std::rt::BlockedTask;\n+use std::rt::local::Local;\n+use std::rt::sched::Scheduler;\n \n-use uvll;\n-use uvll::UV_GETADDRINFO;\n-use super::{Loop, UvError, NativeHandle, status_to_maybe_uv_error};\n use net;\n+use super::{Loop, UvError, NativeHandle};\n+use uvll::UV_GETADDRINFO;\n+use uvll;\n \n-type GetAddrInfoCallback = ~fn(GetAddrInfoRequest, &net::UvAddrInfo, Option<UvError>);\n+struct GetAddrInfoRequest {\n+    handle: *uvll::uv_getaddrinfo_t,\n+}\n \n-pub struct GetAddrInfoRequest(*uvll::uv_getaddrinfo_t);\n+struct Addrinfo {\n+    handle: *uvll::addrinfo,\n+}\n \n-pub struct RequestData {\n-    priv getaddrinfo_cb: Option<GetAddrInfoCallback>,\n+struct Ctx {\n+    slot: Option<BlockedTask>,\n+    status: c_int,\n+    addrinfo: Option<Addrinfo>,\n }\n \n impl GetAddrInfoRequest {\n     pub fn new() -> GetAddrInfoRequest {\n-        let req = unsafe { uvll::malloc_req(UV_GETADDRINFO) };\n-        assert!(req.is_not_null());\n-        let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);\n-        req.install_req_data();\n-        return req;\n+        GetAddrInfoRequest {\n+            handle: unsafe { uvll::malloc_req(uvll::UV_GETADDRINFO) },\n+        }\n     }\n \n-    pub fn getaddrinfo(&mut self, loop_: &Loop, node: Option<&str>,\n-                       service: Option<&str>, hints: Option<ai::Hint>,\n-                       cb: GetAddrInfoCallback) {\n-\n+    pub fn run(loop_: &Loop, node: Option<&str>, service: Option<&str>,\n+               hints: Option<ai::Hint>) -> Result<~[ai::Info], UvError> {\n         assert!(node.is_some() || service.is_some());\n-\n-        let (c_node, c_node_ptr) = match node {\n+        let (_c_node, c_node_ptr) = match node {\n             Some(n) => {\n                 let c_node = n.to_c_str();\n                 let c_node_ptr = c_node.with_ref(|r| r);\n@@ -51,7 +54,7 @@ impl GetAddrInfoRequest {\n             None => (None, null())\n         };\n \n-        let (c_service, c_service_ptr) = match service {\n+        let (_c_service, c_service_ptr) = match service {\n             Some(s) => {\n                 let c_service = s.to_c_str();\n                 let c_service_ptr = c_service.with_ref(|r| r);\n@@ -60,37 +63,13 @@ impl GetAddrInfoRequest {\n             None => (None, null())\n         };\n \n-        let cb = Cell::new(cb);\n-        let wrapper_cb: GetAddrInfoCallback = |req, addrinfo, err| {\n-            // Capture some heap values that need to stay alive for the\n-            // getaddrinfo call\n-            let _ = &c_node;\n-            let _ = &c_service;\n-\n-            let cb = cb.take();\n-            cb(req, addrinfo, err)\n-        };\n-\n         let hint = hints.map(|hint| {\n             let mut flags = 0;\n             do each_ai_flag |cval, aival| {\n                 if hint.flags & (aival as uint) != 0 {\n                     flags |= cval as i32;\n                 }\n             }\n-            /* XXX: do we really want to support these?\n-            let socktype = match hint.socktype {\n-                Some(ai::Stream) => uvll::rust_SOCK_STREAM(),\n-                Some(ai::Datagram) => uvll::rust_SOCK_DGRAM(),\n-                Some(ai::Raw) => uvll::rust_SOCK_RAW(),\n-                None => 0,\n-            };\n-            let protocol = match hint.protocol {\n-                Some(ai::UDP) => uvll::rust_IPPROTO_UDP(),\n-                Some(ai::TCP) => uvll::rust_IPPROTO_TCP(),\n-                _ => 0,\n-            };\n-            */\n             let socktype = 0;\n             let protocol = 0;\n \n@@ -106,66 +85,54 @@ impl GetAddrInfoRequest {\n             }\n         });\n         let hint_ptr = hint.as_ref().map_default(null(), |x| x as *uvll::addrinfo);\n+        let req = GetAddrInfoRequest::new();\n+\n+        return match unsafe {\n+            uvll::uv_getaddrinfo(loop_.native_handle(), req.handle,\n+                                 getaddrinfo_cb, c_node_ptr, c_service_ptr,\n+                                 hint_ptr)\n+        } {\n+            0 => {\n+                let mut cx = Ctx { slot: None, status: 0, addrinfo: None };\n+                unsafe { uvll::set_data_for_req(req.handle, &cx) }\n+                let scheduler: ~Scheduler = Local::take();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    cx.slot = Some(task);\n+                }\n \n-        self.get_req_data().getaddrinfo_cb = Some(wrapper_cb);\n-\n-        unsafe {\n-            assert!(0 == uvll::uv_getaddrinfo(loop_.native_handle(),\n-                                              self.native_handle(),\n-                                              getaddrinfo_cb,\n-                                              c_node_ptr,\n-                                              c_service_ptr,\n-                                              hint_ptr));\n-        }\n-\n-        extern \"C\" fn getaddrinfo_cb(req: *uvll::uv_getaddrinfo_t,\n-                                     status: c_int,\n-                                     res: *uvll::addrinfo) {\n-            let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);\n-            let err = status_to_maybe_uv_error(status);\n-            let addrinfo = net::UvAddrInfo(res);\n-            let data = req.get_req_data();\n-            (*data.getaddrinfo_cb.get_ref())(req, &addrinfo, err);\n-            unsafe {\n-                uvll::uv_freeaddrinfo(res);\n+                match cx.status {\n+                    0 => Ok(accum_addrinfo(cx.addrinfo.get_ref())),\n+                    n => Err(UvError(n))\n+                }\n             }\n-        }\n-    }\n+            n => Err(UvError(n))\n+        };\n \n-    fn get_loop(&self) -> Loop {\n-        unsafe {\n-            Loop {\n-                handle: uvll::get_loop_from_fs_req(self.native_handle())\n-            }\n-        }\n-    }\n \n-    fn install_req_data(&mut self) {\n-        let req = self.native_handle() as *uvll::uv_getaddrinfo_t;\n-        let data = ~RequestData {\n-            getaddrinfo_cb: None\n-        };\n-        unsafe {\n-            let data = transmute::<~RequestData, *c_void>(data);\n-            uvll::set_data_for_req(req, data);\n+        extern fn getaddrinfo_cb(req: *uvll::uv_getaddrinfo_t,\n+                                 status: c_int,\n+                                 res: *uvll::addrinfo) {\n+            let cx: &mut Ctx = unsafe {\n+                cast::transmute(uvll::get_data_for_req(req))\n+            };\n+            cx.status = status;\n+            cx.addrinfo = Some(Addrinfo { handle: res });\n+\n+            let sched: ~Scheduler = Local::take();\n+            sched.resume_blocked_task_immediately(cx.slot.take_unwrap());\n         }\n     }\n+}\n \n-    fn get_req_data<'r>(&'r mut self) -> &'r mut RequestData {\n-        unsafe {\n-            let data = uvll::get_data_for_req(self.native_handle());\n-            let data = transmute::<&*c_void, &mut ~RequestData>(&data);\n-            return &mut **data;\n-        }\n+impl Drop for GetAddrInfoRequest {\n+    fn drop(&mut self) {\n+        unsafe { uvll::free_req(self.handle) }\n     }\n+}\n \n-    fn delete(self) {\n-        unsafe {\n-            let data = uvll::get_data_for_req(self.native_handle());\n-            let _data = transmute::<*c_void, ~RequestData>(data);\n-            uvll::set_data_for_req(self.native_handle(), null::<()>());\n-            uvll::free_req(self.native_handle());\n-        }\n+impl Drop for Addrinfo {\n+    fn drop(&mut self) {\n+        unsafe { uvll::uv_freeaddrinfo(self.handle) }\n     }\n }\n \n@@ -184,10 +151,9 @@ fn each_ai_flag(_f: &fn(c_int, ai::Flag)) {\n }\n \n // Traverse the addrinfo linked list, producing a vector of Rust socket addresses\n-pub fn accum_addrinfo(addr: &net::UvAddrInfo) -> ~[ai::Info] {\n+pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n     unsafe {\n-        let &net::UvAddrInfo(addr) = addr;\n-        let mut addr = addr;\n+        let mut addr = addr.handle;\n \n         let mut addrs = ~[];\n         loop {\n@@ -235,15 +201,6 @@ pub fn accum_addrinfo(addr: &net::UvAddrInfo) -> ~[ai::Info] {\n     }\n }\n \n-impl NativeHandle<*uvll::uv_getaddrinfo_t> for GetAddrInfoRequest {\n-    fn from_native_handle(handle: *uvll::uv_getaddrinfo_t) -> GetAddrInfoRequest {\n-        GetAddrInfoRequest(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_getaddrinfo_t {\n-        match self { &GetAddrInfoRequest(ptr) => ptr }\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     use Loop;"}, {"sha": "1c6e59d9f2eacbda35b60571c482145dd67c1c5f", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5842b606a7e11c671d92aac574389e359a8172f6/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5842b606a7e11c671d92aac574389e359a8172f6/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=5842b606a7e11c671d92aac574389e359a8172f6", "patch": "@@ -46,7 +46,7 @@ use ai = std::rt::io::net::addrinfo;\n use super::*;\n use idle::IdleWatcher;\n use net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n-use addrinfo::{GetAddrInfoRequest, accum_addrinfo};\n+use addrinfo::GetAddrInfoRequest;\n use pipe::PipeListener;\n \n // XXX we should not be calling uvll functions in here.\n@@ -351,37 +351,8 @@ impl IoFactory for UvIoFactory {\n \n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~[ai::Info], IoError>> = &result_cell;\n-        let host_ptr: *Option<&str> = &host;\n-        let servname_ptr: *Option<&str> = &servname;\n-        let hint_ptr: *Option<ai::Hint> = &hint;\n-        let addrinfo_req = GetAddrInfoRequest::new();\n-        let addrinfo_req_cell = Cell::new(addrinfo_req);\n-\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let mut addrinfo_req = addrinfo_req_cell.take();\n-                unsafe {\n-                    do addrinfo_req.getaddrinfo(self.uv_loop(),\n-                                                *host_ptr, *servname_ptr,\n-                                                *hint_ptr) |_, addrinfo, err| {\n-                        let res = match err {\n-                            None => Ok(accum_addrinfo(addrinfo)),\n-                            Some(err) => Err(uv_error_to_io_error(err))\n-                        };\n-                        (*result_cell_ptr).put_back(res);\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    }\n-                }\n-            }\n-        }\n-        addrinfo_req.delete();\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+        let r = GetAddrInfoRequest::run(self.uv_loop(), host, servname, hint);\n+        r.map_err(uv_error_to_io_error)\n     }\n \n     fn fs_from_raw_fd(&mut self, fd: c_int,"}]}