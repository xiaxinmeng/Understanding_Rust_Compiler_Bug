{"sha": "56b5ec83f2ade19fc601ad44a7366d3e5215401a", "node_id": "C_kwDOAAsO6NoAKDU2YjVlYzgzZjJhZGUxOWZjNjAxYWQ0NGE3MzY2ZDNlNTIxNTQwMWE", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-04-07T09:28:31Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-08-19T14:41:48Z"}, "message": "move `type_check_internal` into `type_check`", "tree": {"sha": "82cbd58bccd1798ef21d5713fd909046097275ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82cbd58bccd1798ef21d5713fd909046097275ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56b5ec83f2ade19fc601ad44a7366d3e5215401a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56b5ec83f2ade19fc601ad44a7366d3e5215401a", "html_url": "https://github.com/rust-lang/rust/commit/56b5ec83f2ade19fc601ad44a7366d3e5215401a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56b5ec83f2ade19fc601ad44a7366d3e5215401a/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d2083c58ea9208c456b0bef177d87665e8c8a4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d2083c58ea9208c456b0bef177d87665e8c8a4f", "html_url": "https://github.com/rust-lang/rust/commit/7d2083c58ea9208c456b0bef177d87665e8c8a4f"}], "stats": {"total": 137, "additions": 52, "deletions": 85}, "files": [{"sha": "293d847ec9ab7aafdc3be14fae88a2b6c286ee01", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 52, "deletions": 85, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/56b5ec83f2ade19fc601ad44a7366d3e5215401a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56b5ec83f2ade19fc601ad44a7366d3e5215401a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=56b5ec83f2ade19fc601ad44a7366d3e5215401a", "patch": "@@ -178,97 +178,15 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         upvars,\n     };\n \n-    let opaque_type_values = type_check_internal(\n+    let mut checker = TypeChecker::new(\n         infcx,\n-        param_env,\n         body,\n-        promoted,\n+        param_env,\n         &region_bound_pairs,\n         implicit_region_bound,\n         &mut borrowck_context,\n-        |mut cx| {\n-            debug!(\"inside extra closure of type_check_internal\");\n-            cx.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n-            liveness::generate(\n-                &mut cx,\n-                body,\n-                elements,\n-                flow_inits,\n-                move_data,\n-                location_table,\n-                use_polonius,\n-            );\n-\n-            translate_outlives_facts(&mut cx);\n-            let opaque_type_values =\n-                infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-\n-            opaque_type_values\n-                .into_iter()\n-                .map(|(opaque_type_key, decl)| {\n-                    cx.fully_perform_op(\n-                        Locations::All(body.span),\n-                        ConstraintCategory::OpaqueType,\n-                        CustomTypeOp::new(\n-                            |infcx| {\n-                                infcx.register_member_constraints(\n-                                    param_env,\n-                                    opaque_type_key,\n-                                    decl.hidden_type.ty,\n-                                    decl.hidden_type.span,\n-                                );\n-                                Ok(InferOk { value: (), obligations: vec![] })\n-                            },\n-                            || \"opaque_type_map\".to_string(),\n-                        ),\n-                    )\n-                    .unwrap();\n-                    let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n-                    trace!(\n-                        \"finalized opaque type {:?} to {:#?}\",\n-                        opaque_type_key,\n-                        hidden_type.ty.kind()\n-                    );\n-                    if hidden_type.has_infer_types_or_consts() {\n-                        infcx.tcx.sess.delay_span_bug(\n-                            decl.hidden_type.span,\n-                            &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n-                        );\n-                        hidden_type.ty = infcx.tcx.ty_error();\n-                    }\n-\n-                    (opaque_type_key, (hidden_type, decl.origin))\n-                })\n-                .collect()\n-        },\n     );\n \n-    MirTypeckResults { constraints, universal_region_relations, opaque_type_values }\n-}\n-\n-#[instrument(\n-    skip(infcx, body, promoted, region_bound_pairs, borrowck_context, extra),\n-    level = \"debug\"\n-)]\n-fn type_check_internal<'a, 'tcx, R>(\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    body: &'a Body<'tcx>,\n-    promoted: &'a IndexVec<Promoted, Body<'tcx>>,\n-    region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n-    implicit_region_bound: ty::Region<'tcx>,\n-    borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n-    extra: impl FnOnce(TypeChecker<'a, 'tcx>) -> R,\n-) -> R {\n-    debug!(\"body: {:#?}\", body);\n-    let mut checker = TypeChecker::new(\n-        infcx,\n-        body,\n-        param_env,\n-        region_bound_pairs,\n-        implicit_region_bound,\n-        borrowck_context,\n-    );\n     let errors_reported = {\n         let mut verifier = TypeVerifier::new(&mut checker, promoted);\n         verifier.visit_body(&body);\n@@ -280,7 +198,56 @@ fn type_check_internal<'a, 'tcx, R>(\n         checker.typeck_mir(body);\n     }\n \n-    extra(checker)\n+    checker.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n+    liveness::generate(\n+        &mut checker,\n+        body,\n+        elements,\n+        flow_inits,\n+        move_data,\n+        location_table,\n+        use_polonius,\n+    );\n+\n+    translate_outlives_facts(&mut checker);\n+    let opaque_type_values = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+\n+    let opaque_type_values = opaque_type_values\n+        .into_iter()\n+        .map(|(opaque_type_key, decl)| {\n+            checker\n+                .fully_perform_op(\n+                    Locations::All(body.span),\n+                    ConstraintCategory::OpaqueType,\n+                    CustomTypeOp::new(\n+                        |infcx| {\n+                            infcx.register_member_constraints(\n+                                param_env,\n+                                opaque_type_key,\n+                                decl.hidden_type.ty,\n+                                decl.hidden_type.span,\n+                            );\n+                            Ok(InferOk { value: (), obligations: vec![] })\n+                        },\n+                        || \"opaque_type_map\".to_string(),\n+                    ),\n+                )\n+                .unwrap();\n+            let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n+            trace!(\"finalized opaque type {:?} to {:#?}\", opaque_type_key, hidden_type.ty.kind());\n+            if hidden_type.has_infer_types_or_consts() {\n+                infcx.tcx.sess.delay_span_bug(\n+                    decl.hidden_type.span,\n+                    &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n+                );\n+                hidden_type.ty = infcx.tcx.ty_error();\n+            }\n+\n+            (opaque_type_key, (hidden_type, decl.origin))\n+        })\n+        .collect();\n+\n+    MirTypeckResults { constraints, universal_region_relations, opaque_type_values }\n }\n \n fn translate_outlives_facts(typeck: &mut TypeChecker<'_, '_>) {"}]}