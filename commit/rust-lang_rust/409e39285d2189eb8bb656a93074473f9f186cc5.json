{"sha": "409e39285d2189eb8bb656a93074473f9f186cc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwOWUzOTI4NWQyMTg5ZWI4YmI2NTZhOTMwNzQ0NzNmOWYxODZjYzU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-22T12:41:27Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-12-01T12:48:19Z"}, "message": "incr.comp.: Properly hash and encode macro expansion information.", "tree": {"sha": "10e756d650ef39b7d25b66bf0026a528faee7b67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10e756d650ef39b7d25b66bf0026a528faee7b67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/409e39285d2189eb8bb656a93074473f9f186cc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/409e39285d2189eb8bb656a93074473f9f186cc5", "html_url": "https://github.com/rust-lang/rust/commit/409e39285d2189eb8bb656a93074473f9f186cc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/409e39285d2189eb8bb656a93074473f9f186cc5/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "315fbf7518dbcace5b92eabab746ba0a2c5531fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/315fbf7518dbcace5b92eabab746ba0a2c5531fa", "html_url": "https://github.com/rust-lang/rust/commit/315fbf7518dbcace5b92eabab746ba0a2c5531fa"}], "stats": {"total": 145, "additions": 138, "deletions": 7}, "files": [{"sha": "6d7322fdafd2b04938e2a7e21be23afe05ce5162", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/409e39285d2189eb8bb656a93074473f9f186cc5/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/409e39285d2189eb8bb656a93074473f9f186cc5/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=409e39285d2189eb8bb656a93074473f9f186cc5", "patch": "@@ -419,7 +419,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n             0u8.hash_stable(hcx, hasher);\n         } else {\n             1u8.hash_stable(hcx, hasher);\n-            self.source_callsite().hash_stable(hcx, hasher);\n+            span.ctxt.outer().expn_info().hash_stable(hcx, hasher);\n         }\n     }\n }"}, {"sha": "c414349c8ffd620970f47bde358b80dc4809302d", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/409e39285d2189eb8bb656a93074473f9f186cc5/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/409e39285d2189eb8bb656a93074473f9f186cc5/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=409e39285d2189eb8bb656a93074473f9f186cc5", "patch": "@@ -347,6 +347,30 @@ impl_stable_hash_for!(enum ::syntax::ast::MetaItemKind {\n     NameValue(lit)\n });\n \n+impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnInfo {\n+    call_site,\n+    callee\n+});\n+\n+impl_stable_hash_for!(struct ::syntax_pos::hygiene::NameAndSpan {\n+    format,\n+    allow_internal_unstable,\n+    allow_internal_unsafe,\n+    span\n+});\n+\n+impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnFormat {\n+    MacroAttribute(sym),\n+    MacroBang(sym),\n+    CompilerDesugaring(kind)\n+});\n+\n+impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n+    BackArrow,\n+    DotFill,\n+    QuestionMark\n+});\n+\n impl<'gcx> HashStable<StableHashingContext<'gcx>> for FileMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,"}, {"sha": "6ca787ad19e71b66de4ba6d3a965db660e25c920", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 84, "deletions": 2, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/409e39285d2189eb8bb656a93074473f9f186cc5/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/409e39285d2189eb8bb656a93074473f9f186cc5/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=409e39285d2189eb8bb656a93074473f9f186cc5", "patch": "@@ -27,7 +27,8 @@ use std::collections::BTreeMap;\n use std::mem;\n use syntax::ast::NodeId;\n use syntax::codemap::{CodeMap, StableFilemapId};\n-use syntax_pos::{BytePos, Span, NO_EXPANSION, DUMMY_SP};\n+use syntax_pos::{BytePos, Span, DUMMY_SP};\n+use syntax_pos::hygiene::{Mark, SyntaxContext, ExpnInfo};\n use ty;\n use ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n use ty::context::TyCtxt;\n@@ -40,6 +41,10 @@ const QUERY_RESULT_INDEX_TAG: u64 = 0x1234_5678_C3C3_C3C3;\n const TAG_CLEAR_CROSS_CRATE_CLEAR: u8 = 0;\n const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n \n+const TAG_NO_EXPANSION_INFO: u8 = 0;\n+const TAG_EXPANSION_INFO_SHORTHAND: u8 = 1;\n+const TAG_EXPANSION_INFO_INLINE: u8 = 2;\n+\n /// `OnDiskCache` provides an interface to incr. comp. data cached from the\n /// previous compilation session. This data will eventually include the results\n /// of a few selected queries (like `typeck_tables_of` and `mir_optimized`) and\n@@ -61,6 +66,7 @@ pub struct OnDiskCache<'sess> {\n \n     prev_filemap_starts: BTreeMap<BytePos, StableFilemapId>,\n     codemap: &'sess CodeMap,\n+    synthetic_expansion_infos: RefCell<FxHashMap<usize, SyntaxContext>>,\n \n     // A map from dep-node to the position of the cached query result in\n     // `serialized_data`.\n@@ -90,13 +96,16 @@ impl<'sess> OnDiskCache<'sess> {\n             (header, decoder.position())\n         };\n \n+        let mut synthetic_expansion_infos = FxHashMap();\n+\n         let (prev_diagnostics, query_result_index) = {\n             let mut decoder = CacheDecoder {\n                 tcx: None,\n                 opaque: opaque::Decoder::new(&data[..], post_header_pos),\n                 codemap: sess.codemap(),\n                 prev_filemap_starts: &header.prev_filemap_starts,\n                 cnum_map: &IndexVec::new(),\n+                synthetic_expansion_infos: &mut synthetic_expansion_infos,\n             };\n \n             // Decode Diagnostics\n@@ -135,6 +144,7 @@ impl<'sess> OnDiskCache<'sess> {\n             codemap: sess.codemap(),\n             current_diagnostics: RefCell::new(FxHashMap()),\n             query_result_index: query_result_index.into_iter().collect(),\n+            synthetic_expansion_infos: RefCell::new(synthetic_expansion_infos),\n         }\n     }\n \n@@ -148,6 +158,7 @@ impl<'sess> OnDiskCache<'sess> {\n             codemap,\n             current_diagnostics: RefCell::new(FxHashMap()),\n             query_result_index: FxHashMap(),\n+            synthetic_expansion_infos: RefCell::new(FxHashMap()),\n         }\n     }\n \n@@ -166,6 +177,7 @@ impl<'sess> OnDiskCache<'sess> {\n             encoder,\n             type_shorthands: FxHashMap(),\n             predicate_shorthands: FxHashMap(),\n+            expn_info_shorthands: FxHashMap(),\n         };\n \n \n@@ -269,12 +281,15 @@ impl<'sess> OnDiskCache<'sess> {\n             *cnum_map = Some(Self::compute_cnum_map(tcx, &self.prev_cnums[..]));\n         }\n \n+        let mut synthetic_expansion_infos = self.synthetic_expansion_infos.borrow_mut();\n+\n         let mut decoder = CacheDecoder {\n             tcx: Some(tcx),\n             opaque: opaque::Decoder::new(&self.serialized_data[..], pos),\n             codemap: self.codemap,\n             prev_filemap_starts: &self.prev_filemap_starts,\n             cnum_map: cnum_map.as_ref().unwrap(),\n+            synthetic_expansion_infos: &mut *synthetic_expansion_infos,\n         };\n \n         match decode_tagged(&mut decoder, dep_node_index) {\n@@ -350,6 +365,7 @@ struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     codemap: &'x CodeMap,\n     prev_filemap_starts: &'x BTreeMap<BytePos, StableFilemapId>,\n     cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n+    synthetic_expansion_infos: &'x mut FxHashMap<usize, SyntaxContext>,\n }\n \n impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n@@ -457,7 +473,39 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n             if let Some(current_filemap) = self.codemap.filemap_by_stable_id(filemap_id) {\n                 let lo = (lo + current_filemap.start_pos) - prev_filemap_start;\n                 let hi = (hi + current_filemap.start_pos) - prev_filemap_start;\n-                return Ok(Span::new(lo, hi, NO_EXPANSION));\n+\n+                let expn_info_tag = u8::decode(self)?;\n+\n+                let ctxt = match expn_info_tag {\n+                    TAG_NO_EXPANSION_INFO => {\n+                        SyntaxContext::empty()\n+                    }\n+                    TAG_EXPANSION_INFO_INLINE => {\n+                        let pos = self.position();\n+                        let expn_info: ExpnInfo = Decodable::decode(self)?;\n+                        let ctxt = SyntaxContext::allocate_directly(expn_info);\n+                        self.synthetic_expansion_infos.insert(pos, ctxt);\n+                        ctxt\n+                    }\n+                    TAG_EXPANSION_INFO_SHORTHAND => {\n+                        let pos = usize::decode(self)?;\n+                        if let Some(ctxt) = self.synthetic_expansion_infos.get(&pos).cloned() {\n+                            ctxt\n+                        } else {\n+                            let expn_info = self.with_position(pos, |this| {\n+                                 ExpnInfo::decode(this)\n+                            })?;\n+                            let ctxt = SyntaxContext::allocate_directly(expn_info);\n+                            self.synthetic_expansion_infos.insert(pos, ctxt);\n+                            ctxt\n+                        }\n+                    }\n+                    _ => {\n+                        unreachable!()\n+                    }\n+                };\n+\n+                return Ok(Span::new(lo, hi, ctxt));\n             }\n         }\n \n@@ -479,6 +527,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx, 'x> {\n // compilation sessions. We use the DefPathHash, which is stable across\n // sessions, to map the old DefId to the new one.\n impl<'a, 'tcx, 'x> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx, 'x> {\n+    #[inline]\n     fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n         // Load the DefPathHash which is was we encoded the DefId as.\n         let def_path_hash = DefPathHash::decode(self)?;\n@@ -489,6 +538,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx, 'x> {\n }\n \n impl<'a, 'tcx, 'x> SpecializedDecoder<LocalDefId> for CacheDecoder<'a, 'tcx, 'x> {\n+    #[inline]\n     fn specialized_decode(&mut self) -> Result<LocalDefId, Self::Error> {\n         Ok(LocalDefId::from_def_id(DefId::decode(self)?))\n     }\n@@ -558,6 +608,7 @@ struct CacheEncoder<'enc, 'a, 'tcx, E>\n     encoder: &'enc mut E,\n     type_shorthands: FxHashMap<ty::Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n+    expn_info_shorthands: FxHashMap<Mark, usize>,\n }\n \n impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n@@ -584,6 +635,37 @@ impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n     }\n }\n \n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n+        let span_data = span.data();\n+\n+        span_data.lo.encode(self)?;\n+        span_data.hi.encode(self)?;\n+\n+        if span_data.ctxt == SyntaxContext::empty() {\n+            TAG_NO_EXPANSION_INFO.encode(self)\n+        } else {\n+            let mark = span_data.ctxt.outer();\n+\n+            if let Some(expn_info) = mark.expn_info() {\n+                if let Some(pos) = self.expn_info_shorthands.get(&mark).cloned() {\n+                    TAG_EXPANSION_INFO_SHORTHAND.encode(self)?;\n+                    pos.encode(self)\n+                } else {\n+                    TAG_EXPANSION_INFO_INLINE.encode(self)?;\n+                    let pos = self.position();\n+                    self.expn_info_shorthands.insert(mark, pos);\n+                    expn_info.encode(self)\n+                }\n+            } else {\n+                TAG_NO_EXPANSION_INFO.encode(self)\n+            }\n+        }\n+    }\n+}\n+\n impl<'enc, 'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {"}, {"sha": "9358e654a9fc8f2604961f81a7992c2bc518ff3e", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/409e39285d2189eb8bb656a93074473f9f186cc5/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/409e39285d2189eb8bb656a93074473f9f186cc5/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=409e39285d2189eb8bb656a93074473f9f186cc5", "patch": "@@ -140,6 +140,31 @@ impl SyntaxContext {\n         SyntaxContext(0)\n     }\n \n+    // Allocate a new SyntaxContext with the given ExpnInfo. This is used when\n+    // deserializing Spans from the incr. comp. cache.\n+    // FIXME(mw): This method does not restore MarkData::parent or\n+    // SyntaxContextData::prev_ctxt or SyntaxContextData::modern. These things\n+    // don't seem to be used after HIR lowering, so everything should be fine\n+    // as long as incremental compilation does not kick in before that.\n+    pub fn allocate_directly(expansion_info: ExpnInfo) -> Self {\n+        HygieneData::with(|data| {\n+            data.marks.push(MarkData {\n+                parent: Mark::root(),\n+                modern: false,\n+                expn_info: Some(expansion_info)\n+            });\n+\n+            let mark = Mark(data.marks.len() as u32 - 1);\n+\n+            data.syntax_contexts.push(SyntaxContextData {\n+                outer_mark: mark,\n+                prev_ctxt: SyntaxContext::empty(),\n+                modern: SyntaxContext::empty(),\n+            });\n+            SyntaxContext(data.syntax_contexts.len() as u32 - 1)\n+        })\n+    }\n+\n     /// Extend a syntax context with a given mark\n     pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n         HygieneData::with(|data| {\n@@ -286,7 +311,7 @@ impl fmt::Debug for SyntaxContext {\n }\n \n /// Extra information for tracking spans of macro and syntax sugar expansion\n-#[derive(Clone, Hash, Debug)]\n+#[derive(Clone, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ExpnInfo {\n     /// The location of the actual macro invocation or syntax sugar , e.g.\n     /// `let x = foo!();` or `if let Some(y) = x {}`\n@@ -302,7 +327,7 @@ pub struct ExpnInfo {\n     pub callee: NameAndSpan\n }\n \n-#[derive(Clone, Hash, Debug)]\n+#[derive(Clone, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct NameAndSpan {\n     /// The format with which the macro was invoked.\n     pub format: ExpnFormat,\n@@ -330,7 +355,7 @@ impl NameAndSpan {\n }\n \n /// The source of expansion.\n-#[derive(Clone, Hash, Debug, PartialEq, Eq)]\n+#[derive(Clone, Hash, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum ExpnFormat {\n     /// e.g. #[derive(...)] <item>\n     MacroAttribute(Symbol),\n@@ -341,7 +366,7 @@ pub enum ExpnFormat {\n }\n \n /// The kind of compiler desugaring.\n-#[derive(Clone, Hash, Debug, PartialEq, Eq)]\n+#[derive(Clone, Hash, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum CompilerDesugaringKind {\n     BackArrow,\n     DotFill,"}]}