{"sha": "33533712c77865acbb2dbf7a8d2784c02d5f2b86", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzNTMzNzEyYzc3ODY1YWNiYjJkYmY3YThkMjc4NGMwMmQ1ZjJiODY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:37:24Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T02:37:24Z"}, "message": "rollup merge of #20517: nikomatsakis/safety-issue-19997\n\nFixes various safety issues.\n\nr? @aturon", "tree": {"sha": "d7bd6f924ae55ff1571f6a200a226f6fefbbcac6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7bd6f924ae55ff1571f6a200a226f6fefbbcac6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33533712c77865acbb2dbf7a8d2784c02d5f2b86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33533712c77865acbb2dbf7a8d2784c02d5f2b86", "html_url": "https://github.com/rust-lang/rust/commit/33533712c77865acbb2dbf7a8d2784c02d5f2b86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33533712c77865acbb2dbf7a8d2784c02d5f2b86/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc0697ec9efd776a819984fe2022ca2be70bd690", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc0697ec9efd776a819984fe2022ca2be70bd690", "html_url": "https://github.com/rust-lang/rust/commit/cc0697ec9efd776a819984fe2022ca2be70bd690"}, {"sha": "dbfa05411bad5d31cb594a02ddbf5333dcb0ad5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbfa05411bad5d31cb594a02ddbf5333dcb0ad5a", "html_url": "https://github.com/rust-lang/rust/commit/dbfa05411bad5d31cb594a02ddbf5333dcb0ad5a"}], "stats": {"total": 312, "additions": 285, "deletions": 27}, "files": [{"sha": "291bb4c982058df82cb96ae044c97de0b73d20ae", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=33533712c77865acbb2dbf7a8d2784c02d5f2b86", "patch": "@@ -1776,6 +1776,10 @@ impl<'tcx> Generics<'tcx> {\n         !self.regions.is_empty_in(space)\n     }\n \n+    pub fn is_empty(&self) -> bool {\n+        self.types.is_empty() && self.regions.is_empty()\n+    }\n+\n     pub fn to_bounds(&self, tcx: &ty::ctxt<'tcx>, substs: &Substs<'tcx>)\n                      -> GenericBounds<'tcx> {\n         GenericBounds {"}, {"sha": "aef856b2b2bfcd0262af44d0012e3316bee0c718", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 122, "deletions": 19, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=33533712c77865acbb2dbf7a8d2784c02d5f2b86", "patch": "@@ -30,7 +30,9 @@ use syntax::print::pprust;\n use syntax::ptr::P;\n \n pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n-                           pat: &ast::Pat, expected: Ty<'tcx>) {\n+                           pat: &ast::Pat,\n+                           expected: Ty<'tcx>)\n+{\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n@@ -46,6 +48,19 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             check_expr(fcx, &**lt);\n             let expr_ty = fcx.expr_ty(&**lt);\n             fcx.write_ty(pat.id, expr_ty);\n+\n+            // somewhat surprising: in this case, the subtyping\n+            // relation goes the opposite way as the other\n+            // cases. Actually what we really want is not a subtyping\n+            // relation at all but rather that there exists a LUB (so\n+            // that they can be compared). However, in practice,\n+            // constants are always scalars or strings.  For scalars\n+            // subtyping is irrelevant, and for strings `expr_ty` is\n+            // type is `&'static str`, so if we say that\n+            //\n+            //     &'static str <: expected\n+            //\n+            // that's equivalent to there existing a LUB.\n             demand::suptype(fcx, pat.span, expected, expr_ty);\n         }\n         ast::PatRange(ref begin, ref end) => {\n@@ -54,10 +69,16 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             let lhs_ty = fcx.expr_ty(&**begin);\n             let rhs_ty = fcx.expr_ty(&**end);\n-            if require_same_types(\n-                tcx, Some(fcx.infcx()), false, pat.span, lhs_ty, rhs_ty,\n-                || \"mismatched types in range\".to_string())\n-                && (ty::type_is_numeric(lhs_ty) || ty::type_is_char(rhs_ty)) {\n+\n+            let lhs_eq_rhs =\n+                require_same_types(\n+                    tcx, Some(fcx.infcx()), false, pat.span, lhs_ty, rhs_ty,\n+                    || \"mismatched types in range\".to_string());\n+\n+            let numeric_or_char =\n+                lhs_eq_rhs && (ty::type_is_numeric(lhs_ty) || ty::type_is_char(lhs_ty));\n+\n+            if numeric_or_char {\n                 match valid_range_bounds(fcx.ccx, &**begin, &**end) {\n                     Some(false) => {\n                         span_err!(tcx.sess, begin.span, E0030,\n@@ -71,38 +92,59 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 }\n             } else {\n                 span_err!(tcx.sess, begin.span, E0029,\n-                    \"only char and numeric types are allowed in range\");\n+                          \"only char and numeric types are allowed in range\");\n             }\n \n             fcx.write_ty(pat.id, lhs_ty);\n+\n+            // subtyping doens't matter here, as the value is some kind of scalar\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n             let const_did = tcx.def_map.borrow()[pat.id].clone().def_id();\n             let const_scheme = ty::lookup_item_type(tcx, const_did);\n-            fcx.write_ty(pat.id, const_scheme.ty);\n-            demand::suptype(fcx, pat.span, expected, const_scheme.ty);\n+            assert!(const_scheme.generics.is_empty());\n+            let const_ty = pcx.fcx.instantiate_type_scheme(pat.span,\n+                                                           &Substs::empty(),\n+                                                           &const_scheme.ty);\n+            fcx.write_ty(pat.id, const_ty);\n+\n+            // FIXME(#20489) -- we should limit the types here to scalars or something!\n+\n+            // As with PatLit, what we really want here is that there\n+            // exist a LUB, but for the cases that can occur, subtype\n+            // is good enough.\n+            demand::suptype(fcx, pat.span, expected, const_ty);\n         }\n         ast::PatIdent(bm, ref path, ref sub) if pat_is_binding(&tcx.def_map, pat) => {\n             let typ = fcx.local_ty(pat.span, pat.id);\n             match bm {\n                 ast::BindByRef(mutbl) => {\n                     // if the binding is like\n                     //    ref x | ref const x | ref mut x\n-                    // then the type of x is &M T where M is the mutability\n-                    // and T is the expected type\n+                    // then `x` is assigned a value of type `&M T` where M is the mutability\n+                    // and T is the expected type.\n                     let region_var = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n                     let mt = ty::mt { ty: expected, mutbl: mutbl };\n                     let region_ty = ty::mk_rptr(tcx, tcx.mk_region(region_var), mt);\n+\n+                    // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n+                    // required. However, we use equality, which is stronger. See (*) for\n+                    // an explanation.\n                     demand::eqtype(fcx, pat.span, region_ty, typ);\n                 }\n                 // otherwise the type of x is the expected type T\n                 ast::BindByValue(_) => {\n+                    // As above, `T <: typeof(x)` is required but we\n+                    // use equality, see (*) below.\n                     demand::eqtype(fcx, pat.span, expected, typ);\n                 }\n             }\n+\n             fcx.write_ty(pat.id, typ);\n \n+            // if there are multiple arms, make sure they all agree on\n+            // what the type of the binding `x` ought to be\n             let canon_id = pcx.map[path.node];\n             if canon_id != pat.id {\n                 let ct = fcx.local_ty(pat.span, canon_id);\n@@ -124,8 +166,9 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             check_pat_struct(pcx, pat, path, fields.as_slice(), etc, expected);\n         }\n         ast::PatTup(ref elements) => {\n-            let element_tys: Vec<_> = range(0, elements.len()).map(|_| fcx.infcx()\n-                .next_ty_var()).collect();\n+            let element_tys: Vec<_> =\n+                range(0, elements.len()).map(|_| fcx.infcx().next_ty_var())\n+                                        .collect();\n             let pat_ty = ty::mk_tup(tcx, element_tys.clone());\n             fcx.write_ty(pat.id, pat_ty);\n             demand::eqtype(fcx, pat.span, expected, pat_ty);\n@@ -138,7 +181,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let uniq_ty = ty::mk_uniq(tcx, inner_ty);\n \n             if check_dereferencable(pcx, pat.span, expected, &**inner) {\n-                demand::suptype(fcx, pat.span, expected, uniq_ty);\n+                // Here, `demand::subtype` is good enough, but I don't\n+                // think any errors can be introduced by using\n+                // `demand::eqtype`.\n+                demand::eqtype(fcx, pat.span, expected, uniq_ty);\n                 fcx.write_ty(pat.id, uniq_ty);\n                 check_pat(pcx, &**inner, inner_ty);\n             } else {\n@@ -150,15 +196,18 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let inner_ty = fcx.infcx().next_ty_var();\n \n             let mutbl =\n-                ty::deref(fcx.infcx().shallow_resolve(expected), true)\n-                .map_or(ast::MutImmutable, |mt| mt.mutbl);\n+                ty::deref(fcx.infcx().shallow_resolve(expected), true).map(|mt| mt.mutbl)\n+                                                                      .unwrap_or(ast::MutImmutable);\n \n             let mt = ty::mt { ty: inner_ty, mutbl: mutbl };\n             let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n             let rptr_ty = ty::mk_rptr(tcx, tcx.mk_region(region), mt);\n \n             if check_dereferencable(pcx, pat.span, expected, &**inner) {\n-                demand::suptype(fcx, pat.span, expected, rptr_ty);\n+                // `demand::subtype` would be good enough, but using\n+                // `eqtype` turns out to be equally general. See (*)\n+                // below for details.\n+                demand::eqtype(fcx, pat.span, expected, rptr_ty);\n                 fcx.write_ty(pat.id, rptr_ty);\n                 check_pat(pcx, &**inner, inner_ty);\n             } else {\n@@ -181,14 +230,18 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n                     ty::mk_slice(tcx, tcx.mk_region(region), ty::mt {\n                         ty: inner_ty,\n-                        mutbl: ty::deref(expected_ty, true)\n-                            .map_or(ast::MutImmutable, |mt| mt.mutbl)\n+                        mutbl: ty::deref(expected_ty, true).map(|mt| mt.mutbl)\n+                                                           .unwrap_or(ast::MutImmutable)\n                     })\n                 }\n             };\n \n             fcx.write_ty(pat.id, pat_ty);\n-            demand::suptype(fcx, pat.span, expected, pat_ty);\n+\n+            // `demand::subtype` would be good enough, but using\n+            // `eqtype` turns out to be equally general. See (*)\n+            // below for details.\n+            demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n             for elt in before.iter() {\n                 check_pat(pcx, &**elt, inner_ty);\n@@ -210,6 +263,56 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         }\n         ast::PatMac(_) => tcx.sess.bug(\"unexpanded macro\")\n     }\n+\n+\n+    // (*) In most of the cases above (literals and constants being\n+    // the exception), we relate types using strict equality, evewn\n+    // though subtyping would be sufficient. There are a few reasons\n+    // for this, some of which are fairly subtle and which cost me\n+    // (nmatsakis) an hour or two debugging to remember, so I thought\n+    // I'd write them down this time.\n+    //\n+    // 1. Most importantly, there is no loss of expressiveness\n+    // here. What we are saying is that the type of `x`\n+    // becomes *exactly* what is expected. This might seem\n+    // like it will cause errors in a case like this:\n+    //\n+    // ```\n+    // fn foo<'x>(x: &'x int) {\n+    //    let a = 1;\n+    //    let mut z = x;\n+    //    z = &a;\n+    // }\n+    // ```\n+    //\n+    // The reason we might get an error is that `z` might be\n+    // assigned a type like `&'x int`, and then we would have\n+    // a problem when we try to assign `&a` to `z`, because\n+    // the lifetime of `&a` (i.e., the enclosing block) is\n+    // shorter than `'x`.\n+    //\n+    // HOWEVER, this code works fine. The reason is that the\n+    // expected type here is whatever type the user wrote, not\n+    // the initializer's type. In this case the user wrote\n+    // nothing, so we are going to create a type variable `Z`.\n+    // Then we will assign the type of the initializer (`&'x\n+    // int`) as a subtype of `Z`: `&'x int <: Z`. And hence we\n+    // will instantiate `Z` as a type `&'0 int` where `'0` is\n+    // a fresh region variable, with the constraint that `'x :\n+    // '0`.  So basically we're all set.\n+    //\n+    // Note that there are two tests to check that this remains true\n+    // (`regions-reassign-{match,let}-bound-pointer.rs`).\n+    //\n+    // 2. Things go horribly wrong if we use subtype. The reason for\n+    // THIS is a fairly subtle case involving bound regions. See the\n+    // `givens` field in `region_inference`, as well as the test\n+    // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n+    // for details. Short version is that we must sometimes detect\n+    // relationships between specific region variables and regions\n+    // bound in a closure signature, and that detection gets thrown\n+    // off when we substitute fresh region variables here to enable\n+    // subtyping.\n }\n \n pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,"}, {"sha": "a51e89c1669de7cd6d4fa0d8972ab5f17c68c528", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=33533712c77865acbb2dbf7a8d2784c02d5f2b86", "patch": "@@ -18,14 +18,15 @@ use syntax::ast;\n use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n-// Requires that the two types unify, and prints an error message if they\n-// don't.\n+// Requires that the two types unify, and prints an error message if\n+// they don't.\n pub fn suptype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-    suptype_with_fn(fcx, sp, false, expected, actual,\n+                         ty_expected: Ty<'tcx>, ty_actual: Ty<'tcx>) {\n+    suptype_with_fn(fcx, sp, false, ty_expected, ty_actual,\n         |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n+/// As `suptype`, but call `handle_err` if unification for subtyping fails.\n pub fn suptype_with_fn<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                     sp: Span,\n                                     b_is_expected: bool,\n@@ -48,9 +49,7 @@ pub fn eqtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n                         expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     match infer::mk_eqty(fcx.infcx(), false, infer::Misc(sp), actual, expected) {\n         Ok(()) => { /* ok */ }\n-        Err(ref err) => {\n-            fcx.report_mismatched_types(sp, expected, actual, err);\n-        }\n+        Err(ref err) => { fcx.report_mismatched_types(sp, expected, actual, err); }\n     }\n }\n "}, {"sha": "1b51434a58cc130c5f20b9a73810ee4ba797b0c9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=33533712c77865acbb2dbf7a8d2784c02d5f2b86", "patch": "@@ -4554,7 +4554,7 @@ impl<'tcx> Repr<'tcx> for Expectation<'tcx> {\n pub fn check_decl_initializer(fcx: &FnCtxt,\n                               nid: ast::NodeId,\n                               init: &ast::Expr)\n-                            {\n+{\n     let local_ty = fcx.local_ty(init.span, nid);\n     check_expr_coercable_to_type(fcx, init, local_ty)\n }"}, {"sha": "3f722c9433bb263a0ec5ef38312a08d132ecfaaf", "filename": "src/test/compile-fail/regions-pattern-typing-issue-19552.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19552.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19552.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19552.rs?ref=33533712c77865acbb2dbf7a8d2784c02d5f2b86", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn assert_send<T: Send>(_t: T) {}\n+\n+fn main() {\n+    let line = String::new();\n+    match [line.as_slice()] { //~ ERROR `line` does not live long enough\n+        [ word ] => { assert_send(word); }\n+    }\n+}"}, {"sha": "da839d72172619e19ecf7be11edc97235752b54e", "filename": "src/test/compile-fail/regions-pattern-typing-issue-19997.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19997.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19997.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-pattern-typing-issue-19997.rs?ref=33533712c77865acbb2dbf7a8d2784c02d5f2b86", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let a0 = 0u8;\n+    let f = 1u8;\n+    let mut a1 = &a0;\n+    match (&a1,) {\n+        (&ref b0,) => {\n+            a1 = &f; //~ ERROR cannot assign\n+        }\n+    }\n+}"}, {"sha": "ecf79de6222225dae29db4ff1f68bf3968cb2abd", "filename": "src/test/run-pass/regions-reassign-let-bound-pointer.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Ftest%2Frun-pass%2Fregions-reassign-let-bound-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Ftest%2Frun-pass%2Fregions-reassign-let-bound-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-reassign-let-bound-pointer.rs?ref=33533712c77865acbb2dbf7a8d2784c02d5f2b86", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the type checker permits us to reassign `z` which\n+// started out with a longer lifetime and was reassigned to a shorter\n+// one (it should infer to be the intersection).\n+\n+fn foo(x: &int) {\n+    let a = 1;\n+    let mut z = x;\n+    z = &a;\n+}\n+\n+pub fn main() {\n+    foo(&1);\n+}"}, {"sha": "18312b17339ce3ab29a7dfa983637530bc75c8bf", "filename": "src/test/run-pass/regions-reassign-match-bound-pointer.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Ftest%2Frun-pass%2Fregions-reassign-match-bound-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Ftest%2Frun-pass%2Fregions-reassign-match-bound-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-reassign-match-bound-pointer.rs?ref=33533712c77865acbb2dbf7a8d2784c02d5f2b86", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the type checker permits us to reassign `z` which\n+// started out with a longer lifetime and was reassigned to a shorter\n+// one (it should infer to be the intersection).\n+\n+fn foo(x: &int) {\n+    let a = 1;\n+    match x {\n+        mut z => {\n+            z = &a;\n+        }\n+    }\n+}\n+\n+pub fn main() {\n+    foo(&1);\n+}"}, {"sha": "aa0ed023da3e2170cd34614fa07192321c44fc0d", "filename": "src/test/run-pass/regions-relate-bound-regions-on-closures-to-inference-variables.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Ftest%2Frun-pass%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33533712c77865acbb2dbf7a8d2784c02d5f2b86/src%2Ftest%2Frun-pass%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-relate-bound-regions-on-closures-to-inference-variables.rs?ref=33533712c77865acbb2dbf7a8d2784c02d5f2b86", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that this fairly specialized, but also reasonable, pattern\n+// typechecks. The pattern involves regions bound in closures that\n+// wind up related to inference variables.\n+//\n+// NB. Changes to the region implementatiosn have broken this pattern\n+// a few times, but it happens to be used in the compiler so those\n+// changes were caught. However, those uses in the compiler could\n+// easily get changed or refactored away in the future.\n+\n+struct Ctxt<'tcx> {\n+    x: &'tcx Vec<int>\n+}\n+\n+struct Foo<'a,'tcx:'a> {\n+    cx: &'a Ctxt<'tcx>,\n+}\n+\n+impl<'a,'tcx> Foo<'a,'tcx> {\n+    fn bother(&mut self) -> int {\n+        self.elaborate_bounds(|this| {\n+            // (*) Here: type of `this` is `&'f0 Foo<&'f1, '_2>`,\n+            // where `'f0` and `'f1` are fresh, free regions that\n+            // result from the bound regions on the closure, and `'2`\n+            // is a region inference variable created by the call. Due\n+            // to the constraints on the type, we find that `'_2 : 'f1\n+            // + 'f2` must hold (and can be assumed by the callee).\n+            // Region inference has to do some clever stuff to avoid\n+            // inferring `'_2` to be `'static` in this case, because\n+            // it is created outside the closure but then related to\n+            // regions bound by the closure itself. See the\n+            // `region_inference.rs` file (and the `givens` field, in\n+            // particular) for more details.\n+            this.foo()\n+        })\n+    }\n+\n+    fn foo(&mut self) -> int {\n+        22\n+    }\n+\n+    fn elaborate_bounds(\n+        &mut self,\n+        mk_cand: for<'b>|this: &mut Foo<'b, 'tcx>| -> int)\n+        -> int\n+    {\n+        mk_cand(self)\n+    }\n+}\n+\n+fn main() {\n+    let v = vec!();\n+    let cx = Ctxt { x: &v };\n+    let mut foo = Foo { cx: &cx };\n+    assert_eq!(foo.bother(), 22); // just so the code is not dead, basically\n+}"}]}