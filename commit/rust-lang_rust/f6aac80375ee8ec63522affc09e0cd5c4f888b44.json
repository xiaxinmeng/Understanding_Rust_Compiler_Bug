{"sha": "f6aac80375ee8ec63522affc09e0cd5c4f888b44", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2YWFjODAzNzVlZThlYzYzNTIyYWZmYzA5ZTBjZDVjNGY4ODhiNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-06T23:24:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-06T23:24:11Z"}, "message": "Auto merge of #28270 - arielb1:raw-fat-ops, r=nrc\n\nr? @nrc \r\n\r\nFixes #17736\r\nFixes #18829\r\nFixes #23888\r\nFixes #28236", "tree": {"sha": "8cca7dcdc683fb919f8ac7bd1332c70e8ba9d0c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cca7dcdc683fb919f8ac7bd1332c70e8ba9d0c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6aac80375ee8ec63522affc09e0cd5c4f888b44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6aac80375ee8ec63522affc09e0cd5c4f888b44", "html_url": "https://github.com/rust-lang/rust/commit/f6aac80375ee8ec63522affc09e0cd5c4f888b44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6aac80375ee8ec63522affc09e0cd5c4f888b44/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f", "html_url": "https://github.com/rust-lang/rust/commit/3dd1a48f3f7ac0eeffb2aa5d79bc09daf827fc3f"}, {"sha": "34bc99f8600da0149996815387c9b4261106654a", "url": "https://api.github.com/repos/rust-lang/rust/commits/34bc99f8600da0149996815387c9b4261106654a", "html_url": "https://github.com/rust-lang/rust/commit/34bc99f8600da0149996815387c9b4261106654a"}], "stats": {"total": 274, "additions": 234, "deletions": 40}, "files": [{"sha": "3a7fa040e4f8cb7a8ebeb318a0e60c64fd86beff", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 93, "deletions": 40, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/f6aac80375ee8ec63522affc09e0cd5c4f888b44/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6aac80375ee8ec63522affc09e0cd5c4f888b44/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=f6aac80375ee8ec63522affc09e0cd5c4f888b44", "patch": "@@ -1682,20 +1682,70 @@ fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-// Important to get types for both lhs and rhs, because one might be _|_\n-// and the other not.\n-fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 binop_expr: &hir::Expr,\n-                                 binop_ty: Ty<'tcx>,\n-                                 op: hir::BinOp,\n-                                 lhs_t: Ty<'tcx>,\n-                                 lhs: ValueRef,\n-                                 rhs_t: Ty<'tcx>,\n-                                 rhs: ValueRef)\n-                                 -> DatumBlock<'blk, 'tcx, Expr> {\n-    let _icx = push_ctxt(\"trans_eager_binop\");\n+fn trans_fat_ptr_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   binop_expr: &hir::Expr,\n+                                   binop_ty: Ty<'tcx>,\n+                                   op: hir::BinOp,\n+                                   lhs: Datum<'tcx, Rvalue>,\n+                                   rhs: Datum<'tcx, Rvalue>)\n+                                   -> DatumBlock<'blk, 'tcx, Expr>\n+{\n+    let debug_loc = binop_expr.debug_loc();\n+\n+    let lhs_addr = Load(bcx, GEPi(bcx, lhs.val, &[0, abi::FAT_PTR_ADDR]));\n+    let lhs_extra = Load(bcx, GEPi(bcx, lhs.val, &[0, abi::FAT_PTR_EXTRA]));\n+\n+    let rhs_addr = Load(bcx, GEPi(bcx, rhs.val, &[0, abi::FAT_PTR_ADDR]));\n+    let rhs_extra = Load(bcx, GEPi(bcx, rhs.val, &[0, abi::FAT_PTR_EXTRA]));\n+\n+    let val = match op.node {\n+        hir::BiEq => {\n+            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n+            let extra_eq = ICmp(bcx, llvm::IntEQ, lhs_extra, rhs_extra, debug_loc);\n+            And(bcx, addr_eq, extra_eq, debug_loc)\n+        }\n+        hir::BiNe => {\n+            let addr_eq = ICmp(bcx, llvm::IntNE, lhs_addr, rhs_addr, debug_loc);\n+            let extra_eq = ICmp(bcx, llvm::IntNE, lhs_extra, rhs_extra, debug_loc);\n+            Or(bcx, addr_eq, extra_eq, debug_loc)\n+        }\n+        hir::BiLe | hir::BiLt | hir::BiGe | hir::BiGt => {\n+            // a OP b ~ a.0 STRICT(OP) b.0 | (a.0 == b.0 && a.1 OP a.1)\n+            let (op, strict_op) = match op.node {\n+                hir::BiLt => (llvm::IntULT, llvm::IntULT),\n+                hir::BiLe => (llvm::IntULE, llvm::IntULT),\n+                hir::BiGt => (llvm::IntUGT, llvm::IntUGT),\n+                hir::BiGe => (llvm::IntUGE, llvm::IntUGT),\n+                _ => unreachable!()\n+            };\n+\n+            let addr_eq = ICmp(bcx, llvm::IntEQ, lhs_addr, rhs_addr, debug_loc);\n+            let extra_op = ICmp(bcx, op, lhs_extra, rhs_extra, debug_loc);\n+            let addr_eq_extra_op = And(bcx, addr_eq, extra_op, debug_loc);\n+\n+            let addr_strict = ICmp(bcx, strict_op, lhs_addr, rhs_addr, debug_loc);\n+            Or(bcx, addr_strict, addr_eq_extra_op, debug_loc)\n+        }\n+        _ => {\n+            bcx.tcx().sess.span_bug(binop_expr.span, \"unexpected binop\");\n+        }\n+    };\n+\n+    immediate_rvalue_bcx(bcx, val, binop_ty).to_expr_datumblock()\n+}\n+\n+fn trans_scalar_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                  binop_expr: &hir::Expr,\n+                                  binop_ty: Ty<'tcx>,\n+                                  op: hir::BinOp,\n+                                  lhs: Datum<'tcx, Rvalue>,\n+                                  rhs: Datum<'tcx, Rvalue>)\n+                                  -> DatumBlock<'blk, 'tcx, Expr>\n+{\n+    let _icx = push_ctxt(\"trans_scalar_binop\");\n \n     let tcx = bcx.tcx();\n+    let lhs_t = lhs.ty;\n     assert!(!lhs_t.is_simd());\n     let is_float = lhs_t.is_fp();\n     let is_signed = lhs_t.is_signed();\n@@ -1704,6 +1754,8 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let binop_debug_loc = binop_expr.debug_loc();\n \n     let mut bcx = bcx;\n+    let lhs = lhs.to_llscalarish(bcx);\n+    let rhs = rhs.to_llscalarish(bcx);\n     let val = match op.node {\n       hir::BiAdd => {\n         if is_float {\n@@ -1745,7 +1797,7 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                   op,\n                                                   lhs,\n                                                   rhs,\n-                                                  rhs_t);\n+                                                  lhs_t);\n             if is_signed {\n                 SDiv(bcx, lhs, rhs, binop_debug_loc)\n             } else {\n@@ -1796,7 +1848,7 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // Only zero-check integers; fp %0 is NaN\n             bcx = base::fail_if_zero_or_overflows(bcx,\n                                                   expr_info(binop_expr),\n-                                                  op, lhs, rhs, rhs_t);\n+                                                  op, lhs, rhs, lhs_t);\n             if is_signed {\n                 SRem(bcx, lhs, rhs, binop_debug_loc)\n             } else {\n@@ -1896,23 +1948,26 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         _ => {\n             let mut bcx = bcx;\n-            let lhs_datum = unpack_datum!(bcx, trans(bcx, lhs));\n-            let rhs_datum = unpack_datum!(bcx, trans(bcx, rhs));\n             let binop_ty = expr_ty(bcx, expr);\n \n-            debug!(\"trans_binary (expr {}): lhs_datum={}\",\n-                   expr.id,\n-                   lhs_datum.to_string(ccx));\n-            let lhs_ty = lhs_datum.ty;\n-            let lhs = lhs_datum.to_llscalarish(bcx);\n-\n-            debug!(\"trans_binary (expr {}): rhs_datum={}\",\n-                   expr.id,\n-                   rhs_datum.to_string(ccx));\n-            let rhs_ty = rhs_datum.ty;\n-            let rhs = rhs_datum.to_llscalarish(bcx);\n-            trans_eager_binop(bcx, expr, binop_ty, op,\n-                              lhs_ty, lhs, rhs_ty, rhs)\n+            let lhs = unpack_datum!(bcx, trans(bcx, lhs));\n+            let lhs = unpack_datum!(bcx, lhs.to_rvalue_datum(bcx, \"binop_lhs\"));\n+            debug!(\"trans_binary (expr {}): lhs={}\",\n+                   expr.id, lhs.to_string(ccx));\n+            let rhs = unpack_datum!(bcx, trans(bcx, rhs));\n+            let rhs = unpack_datum!(bcx, rhs.to_rvalue_datum(bcx, \"binop_rhs\"));\n+            debug!(\"trans_binary (expr {}): rhs={}\",\n+                   expr.id, rhs.to_string(ccx));\n+\n+            if type_is_fat_ptr(ccx.tcx(), lhs.ty) {\n+                assert!(type_is_fat_ptr(ccx.tcx(), rhs.ty),\n+                        \"built-in binary operators on fat pointers are homogeneous\");\n+                trans_fat_ptr_binop(bcx, expr, binop_ty, op, lhs, rhs)\n+            } else {\n+                assert!(!type_is_fat_ptr(ccx.tcx(), rhs.ty),\n+                        \"built-in binary operators on fat pointers are homogeneous\");\n+                trans_scalar_binop(bcx, expr, binop_ty, op, lhs, rhs)\n+            }\n         }\n     }\n }\n@@ -2123,21 +2178,19 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     assert!(!bcx.tcx().is_method_call(expr.id));\n \n     // Evaluate LHS (destination), which should be an lvalue\n-    let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n-    assert!(!bcx.fcx.type_needs_drop(dst_datum.ty));\n-    let dst_ty = dst_datum.ty;\n-    let dst = load_ty(bcx, dst_datum.val, dst_datum.ty);\n+    let dst = unpack_datum!(bcx, trans_to_lvalue(bcx, dst, \"assign_op\"));\n+    assert!(!bcx.fcx.type_needs_drop(dst.ty));\n+    let lhs = load_ty(bcx, dst.val, dst.ty);\n+    let lhs = immediate_rvalue(lhs, dst.ty);\n \n-    // Evaluate RHS\n-    let rhs_datum = unpack_datum!(bcx, trans(bcx, &*src));\n-    let rhs_ty = rhs_datum.ty;\n-    let rhs = rhs_datum.to_llscalarish(bcx);\n+    // Evaluate RHS - FIXME(#28160) this sucks\n+    let rhs = unpack_datum!(bcx, trans(bcx, &*src));\n+    let rhs = unpack_datum!(bcx, rhs.to_rvalue_datum(bcx, \"assign_op_rhs\"));\n \n     // Perform computation and store the result\n     let result_datum = unpack_datum!(\n-        bcx, trans_eager_binop(bcx, expr, dst_datum.ty, op,\n-                               dst_ty, dst, rhs_ty, rhs));\n-    return result_datum.store_to(bcx, dst_datum.val);\n+        bcx, trans_scalar_binop(bcx, expr, dst.ty, op, lhs, rhs));\n+    return result_datum.store_to(bcx, dst.val);\n }\n \n fn auto_ref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,"}, {"sha": "a97a49a1a4a00e1bb80fb689d6bd8196ac2e119b", "filename": "src/test/run-pass/issue-27054-primitive-binary-ops.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f6aac80375ee8ec63522affc09e0cd5c4f888b44/src%2Ftest%2Frun-pass%2Fissue-27054-primitive-binary-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6aac80375ee8ec63522affc09e0cd5c4f888b44/src%2Ftest%2Frun-pass%2Fissue-27054-primitive-binary-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-27054-primitive-binary-ops.rs?ref=f6aac80375ee8ec63522affc09e0cd5c4f888b44", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = &mut 1;\n+    assert_eq!(*x + { *x=2; 1 }, 2);\n+}"}, {"sha": "b4572f4577133eaad9e4365129e6706668497d1f", "filename": "src/test/run-pass/raw-fat-ptr.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/f6aac80375ee8ec63522affc09e0cd5c4f888b44/src%2Ftest%2Frun-pass%2Fraw-fat-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6aac80375ee8ec63522affc09e0cd5c4f888b44/src%2Ftest%2Frun-pass%2Fraw-fat-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fraw-fat-ptr.rs?ref=f6aac80375ee8ec63522affc09e0cd5c4f888b44", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check raw fat pointer ops\n+\n+use std::mem;\n+\n+fn assert_inorder<T: PartialEq + PartialOrd>(a: &[T]) {\n+    for i in 0..a.len() {\n+        for j in 0..a.len() {\n+            if i < j {\n+                assert!(a[i] < a[j]);\n+                assert!(a[i] <= a[j]);\n+                assert!(!(a[i] == a[j]));\n+                assert!(a[i] != a[j]);\n+                assert!(!(a[i] >= a[j]));\n+                assert!(!(a[i] > a[j]));\n+            } else if i == j {\n+                assert!(!(a[i] < a[j]));\n+                assert!(a[i] <= a[j]);\n+                assert!(a[i] == a[j]);\n+                assert!(!(a[i] != a[j]));\n+                assert!(a[i] >= a[j]);\n+                assert!(!(a[i] > a[j]));\n+            } else {\n+                assert!(!(a[i] < a[j]));\n+                assert!(!(a[i] <= a[j]));\n+                assert!(!(a[i] == a[j]));\n+                assert!(a[i] != a[j]);\n+                assert!(a[i] >= a[j]);\n+                assert!(a[i] > a[j]);\n+            }\n+        }\n+    }\n+}\n+\n+trait Foo { fn foo(&self) -> usize; }\n+impl<T> Foo for T {\n+    fn foo(&self) -> usize {\n+        mem::size_of::<T>()\n+    }\n+}\n+\n+struct S<T:?Sized>(u32, T);\n+\n+fn main() {\n+    let mut array = [0,1,2,3,4];\n+    let mut array2 = [5,6,7,8,9];\n+\n+    // fat ptr comparison: addr then extra\n+\n+    // check ordering for arrays\n+    let mut ptrs: Vec<*const [u8]> = vec![\n+        &array[0..0], &array[0..1], &array, &array[1..]\n+    ];\n+\n+    let array_addr = &array as *const [u8] as *const u8 as usize;\n+    let array2_addr = &array2 as *const [u8] as *const u8 as usize;\n+    if array2_addr < array_addr {\n+        ptrs.insert(0, &array2);\n+    } else {\n+        ptrs.push(&array2);\n+    }\n+    assert_inorder(&ptrs);\n+\n+    // check ordering for mut arrays\n+    let mut ptrs: Vec<*mut [u8]> = vec![\n+        &mut array[0..0], &mut array[0..1], &mut array, &mut array[1..]\n+    ];\n+\n+    let array_addr = &mut array as *mut [u8] as *mut u8 as usize;\n+    let array2_addr = &mut array2 as *mut [u8] as *mut u8 as usize;\n+    if array2_addr < array_addr {\n+        ptrs.insert(0, &mut array2);\n+    } else {\n+        ptrs.push(&mut array2);\n+    }\n+    assert_inorder(&ptrs);\n+\n+    let mut u8_ = (0u8, 1u8);\n+    let mut u32_ = (4u32, 5u32);\n+\n+    // check ordering for ptrs\n+    let buf: &mut [*const Foo] = &mut [\n+        &u8_, &u8_.0,\n+        &u32_, &u32_.0,\n+    ];\n+    buf.sort_by(|u,v| {\n+        let u : [*const (); 2] = unsafe { mem::transmute(*u) };\n+        let v : [*const (); 2] = unsafe { mem::transmute(*v) };\n+        u.cmp(&v)\n+    });\n+    assert_inorder(buf);\n+\n+    // check ordering for mut ptrs\n+    let buf: &mut [*mut Foo] = &mut [\n+        &mut u8_, &mut u8_.0,\n+        &mut u32_, &mut u32_.0,\n+    ];\n+    buf.sort_by(|u,v| {\n+        let u : [*const (); 2] = unsafe { mem::transmute(*u) };\n+        let v : [*const (); 2] = unsafe { mem::transmute(*v) };\n+        u.cmp(&v)\n+    });\n+    assert_inorder(buf);\n+\n+    // check ordering for structs containing arrays\n+    let ss: (S<[u8; 2]>,\n+             S<[u8; 3]>,\n+             S<[u8; 2]>) = (\n+        S(7, [8, 9]),\n+        S(10, [11, 12, 13]),\n+        S(4, [5, 6])\n+    );\n+    assert_inorder(&[\n+        &ss.0 as *const S<[u8]>,\n+        &ss.1 as *const S<[u8]>,\n+        &ss.2 as *const S<[u8]>\n+    ]);\n+}"}]}