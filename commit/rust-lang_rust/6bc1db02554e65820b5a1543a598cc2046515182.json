{"sha": "6bc1db02554e65820b5a1543a598cc2046515182", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYzFkYjAyNTU0ZTY1ODIwYjVhMTU0M2E1OThjYzIwNDY1MTUxODI=", "commit": {"author": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-05-08T18:42:53Z"}, "committer": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-05-14T16:03:22Z"}, "message": "replace error/warning println with structured diag", "tree": {"sha": "f30a1e8e5fbd6790797ee35fdbe886da5aa6151d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f30a1e8e5fbd6790797ee35fdbe886da5aa6151d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bc1db02554e65820b5a1543a598cc2046515182", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bc1db02554e65820b5a1543a598cc2046515182", "html_url": "https://github.com/rust-lang/rust/commit/6bc1db02554e65820b5a1543a598cc2046515182", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bc1db02554e65820b5a1543a598cc2046515182/comments", "author": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3566ea853af5ed8219903050139994d3551d61e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3566ea853af5ed8219903050139994d3551d61e4", "html_url": "https://github.com/rust-lang/rust/commit/3566ea853af5ed8219903050139994d3551d61e4"}], "stats": {"total": 180, "additions": 90, "deletions": 90}, "files": [{"sha": "10b6c9850ae7773dc99d20972ce918c9f42570cc", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6bc1db02554e65820b5a1543a598cc2046515182/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc1db02554e65820b5a1543a598cc2046515182/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=6bc1db02554e65820b5a1543a598cc2046515182", "patch": "@@ -11,6 +11,7 @@\n use std::fs;\n use std::path::Path;\n use std::str;\n+use errors;\n use html::markdown::Markdown;\n \n #[derive(Clone)]\n@@ -28,23 +29,23 @@ pub struct ExternalHtml {\n \n impl ExternalHtml {\n     pub fn load(in_header: &[String], before_content: &[String], after_content: &[String],\n-                md_before_content: &[String], md_after_content: &[String])\n+                md_before_content: &[String], md_after_content: &[String], diag: &errors::Handler)\n             -> Option<ExternalHtml> {\n-        load_external_files(in_header)\n+        load_external_files(in_header, diag)\n             .and_then(|ih|\n-                load_external_files(before_content)\n+                load_external_files(before_content, diag)\n                     .map(|bc| (ih, bc))\n             )\n             .and_then(|(ih, bc)|\n-                load_external_files(md_before_content)\n+                load_external_files(md_before_content, diag)\n                     .map(|m_bc| (ih, format!(\"{}{}\", bc, Markdown(&m_bc, &[]))))\n             )\n             .and_then(|(ih, bc)|\n-                load_external_files(after_content)\n+                load_external_files(after_content, diag)\n                     .map(|ac| (ih, bc, ac))\n             )\n             .and_then(|(ih, bc, ac)|\n-                load_external_files(md_after_content)\n+                load_external_files(md_after_content, diag)\n                     .map(|m_ac| (ih, bc, format!(\"{}{}\", ac, Markdown(&m_ac, &[]))))\n             )\n             .map(|(ih, bc, ac)|\n@@ -62,28 +63,30 @@ pub enum LoadStringError {\n     BadUtf8,\n }\n \n-pub fn load_string<P: AsRef<Path>>(file_path: P) -> Result<String, LoadStringError> {\n+pub fn load_string<P: AsRef<Path>>(file_path: P, diag: &errors::Handler)\n+    -> Result<String, LoadStringError>\n+{\n     let file_path = file_path.as_ref();\n     let contents = match fs::read(file_path) {\n         Ok(bytes) => bytes,\n         Err(e) => {\n-            eprintln!(\"error reading `{}`: {}\", file_path.display(), e);\n+            diag.struct_err(&format!(\"error reading `{}`: {}\", file_path.display(), e)).emit();\n             return Err(LoadStringError::ReadFail);\n         }\n     };\n     match str::from_utf8(&contents) {\n         Ok(s) => Ok(s.to_string()),\n         Err(_) => {\n-            eprintln!(\"error reading `{}`: not UTF-8\", file_path.display());\n+            diag.struct_err(&format!(\"error reading `{}`: not UTF-8\", file_path.display())).emit();\n             Err(LoadStringError::BadUtf8)\n         }\n     }\n }\n \n-fn load_external_files(names: &[String]) -> Option<String> {\n+fn load_external_files(names: &[String], diag: &errors::Handler) -> Option<String> {\n     let mut out = String::new();\n     for name in names {\n-        let s = match load_string(name) {\n+        let s = match load_string(name, diag) {\n             Ok(s) => s,\n             Err(_) => return None,\n         };"}, {"sha": "0acf28a890f2ea549b156fc7ddbe1bcfa98433c4", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 59, "deletions": 67, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/6bc1db02554e65820b5a1543a598cc2046515182/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc1db02554e65820b5a1543a598cc2046515182/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6bc1db02554e65820b5a1543a598cc2046515182", "patch": "@@ -56,15 +56,13 @@ use errors::ColorConfig;\n use std::collections::{BTreeMap, BTreeSet};\n use std::default::Default;\n use std::env;\n-use std::fmt::Display;\n-use std::io;\n-use std::io::Write;\n use std::path::{Path, PathBuf};\n use std::process;\n use std::sync::mpsc::channel;\n \n use syntax::edition::Edition;\n use externalfiles::ExternalHtml;\n+use rustc::session::{early_warn, early_error};\n use rustc::session::search_paths::SearchPaths;\n use rustc::session::config::{ErrorOutputType, RustcOptGroup, Externs, CodegenOptions};\n use rustc::session::config::{nightly_options, build_codegen_options};\n@@ -118,7 +116,8 @@ pub fn main() {\n fn get_args() -> Option<Vec<String>> {\n     env::args_os().enumerate()\n         .map(|(i, arg)| arg.into_string().map_err(|arg| {\n-             print_error(format!(\"Argument {} is not valid Unicode: {:?}\", i, arg));\n+             early_warn(ErrorOutputType::default(),\n+                        &format!(\"Argument {} is not valid Unicode: {:?}\", i, arg));\n         }).ok())\n         .collect()\n }\n@@ -318,16 +317,12 @@ pub fn main_args(args: &[String]) -> isize {\n     let matches = match options.parse(&args[1..]) {\n         Ok(m) => m,\n         Err(err) => {\n-            print_error(err);\n-            return 1;\n+            early_error(ErrorOutputType::default(), &err.to_string());\n         }\n     };\n     // Check for unstable options.\n     nightly_options::check_nightly_options(&matches, &opts());\n \n-    // check for deprecated options\n-    check_deprecated_options(&matches);\n-\n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         usage(\"rustdoc\");\n         return 0;\n@@ -348,6 +343,35 @@ pub fn main_args(args: &[String]) -> isize {\n         return 0;\n     }\n \n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n+        Some(\"auto\") => ColorConfig::Auto,\n+        Some(\"always\") => ColorConfig::Always,\n+        Some(\"never\") => ColorConfig::Never,\n+        None => ColorConfig::Auto,\n+        Some(arg) => {\n+            early_error(ErrorOutputType::default(),\n+                        &format!(\"argument for --color must be `auto`, `always` or `never` \\\n+                                  (instead was `{}`)\", arg));\n+        }\n+    };\n+    let error_format = match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n+        Some(\"human\") => ErrorOutputType::HumanReadable(color),\n+        Some(\"json\") => ErrorOutputType::Json(false),\n+        Some(\"pretty-json\") => ErrorOutputType::Json(true),\n+        Some(\"short\") => ErrorOutputType::Short(color),\n+        None => ErrorOutputType::HumanReadable(color),\n+        Some(arg) => {\n+            early_error(ErrorOutputType::default(),\n+                        &format!(\"argument for --error-format must be `human`, `json` or \\\n+                                  `short` (instead was `{}`)\", arg));\n+        }\n+    };\n+\n+    let diag = core::new_handler(error_format, None);\n+\n+    // check for deprecated options\n+    check_deprecated_options(&matches, &diag);\n+\n     let to_check = matches.opt_strs(\"theme-checker\");\n     if !to_check.is_empty() {\n         let paths = theme::load_css_paths(include_bytes!(\"html/static/themes/light.css\"));\n@@ -356,7 +380,7 @@ pub fn main_args(args: &[String]) -> isize {\n         println!(\"rustdoc: [theme-checker] Starting tests!\");\n         for theme_file in to_check.iter() {\n             print!(\" - Checking \\\"{}\\\"...\", theme_file);\n-            let (success, differences) = theme::test_theme_against(theme_file, &paths);\n+            let (success, differences) = theme::test_theme_against(theme_file, &paths, &diag);\n             if !differences.is_empty() || !success {\n                 println!(\" FAILED\");\n                 errors += 1;\n@@ -374,47 +398,23 @@ pub fn main_args(args: &[String]) -> isize {\n     }\n \n     if matches.free.is_empty() {\n-        print_error(\"missing file operand\");\n+        diag.struct_err(\"missing file operand\").emit();\n         return 1;\n     }\n     if matches.free.len() > 1 {\n-        print_error(\"too many file operands\");\n+        diag.struct_err(\"too many file operands\").emit();\n         return 1;\n     }\n     let input = &matches.free[0];\n \n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n-        Some(\"auto\") => ColorConfig::Auto,\n-        Some(\"always\") => ColorConfig::Always,\n-        Some(\"never\") => ColorConfig::Never,\n-        None => ColorConfig::Auto,\n-        Some(arg) => {\n-            print_error(&format!(\"argument for --color must be `auto`, `always` or `never` \\\n-                                  (instead was `{}`)\", arg));\n-            return 1;\n-        }\n-    };\n-    let error_format = match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n-        Some(\"human\") => ErrorOutputType::HumanReadable(color),\n-        Some(\"json\") => ErrorOutputType::Json(false),\n-        Some(\"pretty-json\") => ErrorOutputType::Json(true),\n-        Some(\"short\") => ErrorOutputType::Short(color),\n-        None => ErrorOutputType::HumanReadable(color),\n-        Some(arg) => {\n-            print_error(&format!(\"argument for --error-format must be `human`, `json` or \\\n-                                  `short` (instead was `{}`)\", arg));\n-            return 1;\n-        }\n-    };\n-\n     let mut libs = SearchPaths::new();\n     for s in &matches.opt_strs(\"L\") {\n         libs.add_path(s, error_format);\n     }\n     let externs = match parse_externs(&matches) {\n         Ok(ex) => ex,\n         Err(err) => {\n-            print_error(err);\n+            diag.struct_err(&err.to_string()).emit();\n             return 1;\n         }\n     };\n@@ -435,10 +435,7 @@ pub fn main_args(args: &[String]) -> isize {\n \n     if let Some(ref p) = css_file_extension {\n         if !p.is_file() {\n-            writeln!(\n-                &mut io::stderr(),\n-                \"rustdoc: option --extend-css argument must be a file.\"\n-            ).unwrap();\n+            diag.struct_err(\"option --extend-css argument must be a file\").emit();\n             return 1;\n         }\n     }\n@@ -451,13 +448,14 @@ pub fn main_args(args: &[String]) -> isize {\n                                             .iter()\n                                             .map(|s| (PathBuf::from(&s), s.to_owned())) {\n             if !theme_file.is_file() {\n-                println!(\"rustdoc: option --themes arguments must all be files\");\n+                diag.struct_err(\"option --themes arguments must all be files\").emit();\n                 return 1;\n             }\n-            let (success, ret) = theme::test_theme_against(&theme_file, &paths);\n+            let (success, ret) = theme::test_theme_against(&theme_file, &paths, &diag);\n             if !success || !ret.is_empty() {\n-                println!(\"rustdoc: invalid theme: \\\"{}\\\"\", theme_s);\n-                println!(\"         Check what's wrong with the \\\"theme-checker\\\" option\");\n+                diag.struct_err(&format!(\"invalid theme: \\\"{}\\\"\", theme_s))\n+                    .help(\"check what's wrong with the --theme-checker option\")\n+                    .emit();\n                 return 1;\n             }\n             themes.push(theme_file);\n@@ -469,7 +467,7 @@ pub fn main_args(args: &[String]) -> isize {\n             &matches.opt_strs(\"html-before-content\"),\n             &matches.opt_strs(\"html-after-content\"),\n             &matches.opt_strs(\"markdown-before-content\"),\n-            &matches.opt_strs(\"markdown-after-content\")) {\n+            &matches.opt_strs(\"markdown-after-content\"), &diag) {\n         Some(eh) => eh,\n         None => return 3,\n     };\n@@ -485,7 +483,7 @@ pub fn main_args(args: &[String]) -> isize {\n     let edition = match edition.parse() {\n         Ok(e) => e,\n         Err(_) => {\n-            print_error(\"could not parse edition\");\n+            diag.struct_err(\"could not parse edition\").emit();\n             return 1;\n         }\n     };\n@@ -495,7 +493,7 @@ pub fn main_args(args: &[String]) -> isize {\n     match (should_test, markdown_input) {\n         (true, true) => {\n             return markdown::test(input, cfgs, libs, externs, test_args, maybe_sysroot,\n-                                  display_warnings, linker, edition, cg)\n+                                  display_warnings, linker, edition, cg, &diag)\n         }\n         (true, false) => {\n             return test::run(Path::new(input), cfgs, libs, externs, test_args, crate_name,\n@@ -504,7 +502,7 @@ pub fn main_args(args: &[String]) -> isize {\n         (false, true) => return markdown::render(Path::new(input),\n                                                  output.unwrap_or(PathBuf::from(\"doc\")),\n                                                  &matches, &external_html,\n-                                                 !matches.opt_present(\"markdown-no-toc\")),\n+                                                 !matches.opt_present(\"markdown-no-toc\"), &diag),\n         (false, false) => {}\n     }\n \n@@ -513,6 +511,7 @@ pub fn main_args(args: &[String]) -> isize {\n     let res = acquire_input(PathBuf::from(input), externs, edition, cg, &matches, error_format,\n                             move |out| {\n         let Output { krate, passes, renderinfo } = out;\n+        let diag = core::new_handler(error_format, None);\n         info!(\"going to format\");\n         match output_format.as_ref().map(|s| &**s) {\n             Some(\"html\") | None => {\n@@ -528,26 +527,17 @@ pub fn main_args(args: &[String]) -> isize {\n                 0\n             }\n             Some(s) => {\n-                print_error(format!(\"unknown output format: {}\", s));\n+                diag.struct_err(&format!(\"unknown output format: {}\", s)).emit();\n                 1\n             }\n         }\n     });\n     res.unwrap_or_else(|s| {\n-        print_error(format!(\"input error: {}\", s));\n+        diag.struct_err(&format!(\"input error: {}\", s)).emit();\n         1\n     })\n }\n \n-/// Prints an uniformized error message on the standard error output\n-fn print_error<T>(error_message: T) where T: Display {\n-    writeln!(\n-        &mut io::stderr(),\n-        \"rustdoc: {}\\nTry 'rustdoc --help' for more information.\",\n-        error_message\n-    ).unwrap();\n-}\n-\n /// Looks inside the command line arguments to extract the relevant input format\n /// and files and then generates the necessary rustdoc output for formatting.\n fn acquire_input<R, F>(input: PathBuf,\n@@ -714,7 +704,7 @@ where R: 'static + Send,\n }\n \n /// Prints deprecation warnings for deprecated options\n-fn check_deprecated_options(matches: &getopts::Matches) {\n+fn check_deprecated_options(matches: &getopts::Matches, diag: &errors::Handler) {\n     let deprecated_flags = [\n        \"input-format\",\n        \"output-format\",\n@@ -726,12 +716,14 @@ fn check_deprecated_options(matches: &getopts::Matches) {\n \n     for flag in deprecated_flags.into_iter() {\n         if matches.opt_present(flag) {\n-            eprintln!(\"WARNING: the '{}' flag is considered deprecated\", flag);\n-            eprintln!(\"WARNING: please see https://github.com/rust-lang/rust/issues/44136\");\n-        }\n-    }\n+            let mut err = diag.struct_warn(&format!(\"the '{}' flag is considered deprecated\", flag));\n+            err.warn(\"please see https://github.com/rust-lang/rust/issues/44136\");\n \n-    if matches.opt_present(\"no-defaults\") {\n-        eprintln!(\"WARNING: (you may want to use --document-private-items)\");\n+            if *flag == \"no-defaults\" {\n+                err.help(\"you may want to use --document-private-items\");\n+            }\n+\n+            err.emit();\n+        }\n     }\n }"}, {"sha": "bf7b025884d5ab858628b5b18b320e7d98935f0e", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6bc1db02554e65820b5a1543a598cc2046515182/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc1db02554e65820b5a1543a598cc2046515182/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=6bc1db02554e65820b5a1543a598cc2046515182", "patch": "@@ -13,6 +13,7 @@ use std::fs::File;\n use std::io::prelude::*;\n use std::path::{PathBuf, Path};\n \n+use errors;\n use getopts;\n use testing;\n use rustc::session::search_paths::SearchPaths;\n@@ -50,7 +51,7 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n /// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n /// (e.g. output = \"bar\" => \"bar/foo.html\").\n pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n-              external_html: &ExternalHtml, include_toc: bool) -> isize {\n+              external_html: &ExternalHtml, include_toc: bool, diag: &errors::Handler) -> isize {\n     output.push(input.file_stem().unwrap());\n     output.set_extension(\"html\");\n \n@@ -60,7 +61,7 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n         css.push_str(&s)\n     }\n \n-    let input_str = match load_string(input) {\n+    let input_str = match load_string(input, diag) {\n         Ok(s) => s,\n         Err(LoadStringError::ReadFail) => return 1,\n         Err(LoadStringError::BadUtf8) => return 2,\n@@ -72,15 +73,15 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n \n     let mut out = match File::create(&output) {\n         Err(e) => {\n-            eprintln!(\"rustdoc: {}: {}\", output.display(), e);\n+            diag.struct_err(&format!(\"{}: {}\", output.display(), e)).emit();\n             return 4;\n         }\n         Ok(f) => f\n     };\n \n     let (metadata, text) = extract_leading_metadata(&input_str);\n     if metadata.is_empty() {\n-        eprintln!(\"rustdoc: invalid markdown file: no initial lines starting with `# ` or `%`\");\n+        diag.struct_err(\"invalid markdown file: no initial lines starting with `# ` or `%`\").emit();\n         return 5;\n     }\n     let title = metadata[0];\n@@ -130,7 +131,7 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n \n     match err {\n         Err(e) => {\n-            eprintln!(\"rustdoc: cannot write to `{}`: {}\", output.display(), e);\n+            diag.struct_err(&format!(\"cannot write to `{}`: {}\", output.display(), e)).emit();\n             6\n         }\n         Ok(_) => 0,\n@@ -141,8 +142,8 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n             mut test_args: Vec<String>, maybe_sysroot: Option<PathBuf>,\n             display_warnings: bool, linker: Option<PathBuf>, edition: Edition,\n-            cg: CodegenOptions) -> isize {\n-    let input_str = match load_string(input) {\n+            cg: CodegenOptions, diag: &errors::Handler) -> isize {\n+    let input_str = match load_string(input, diag) {\n         Ok(s) => s,\n         Err(LoadStringError::ReadFail) => return 1,\n         Err(LoadStringError::BadUtf8) => return 2,"}, {"sha": "96a67e078875800bbc06e84183ee88a242a4b7d5", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6bc1db02554e65820b5a1543a598cc2046515182/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bc1db02554e65820b5a1543a598cc2046515182/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=6bc1db02554e65820b5a1543a598cc2046515182", "patch": "@@ -14,12 +14,14 @@ use std::hash::{Hash, Hasher};\n use std::io::Read;\n use std::path::Path;\n \n+use errors::Handler;\n+\n macro_rules! try_something {\n-    ($e:expr, $out:expr) => ({\n+    ($e:expr, $diag:expr, $out:expr) => ({\n         match $e {\n             Ok(c) => c,\n             Err(e) => {\n-                eprintln!(\"rustdoc: got an error: {}\", e);\n+                $diag.struct_err(&e.to_string()).emit();\n                 return $out;\n             }\n         }\n@@ -273,11 +275,13 @@ pub fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>)\n     }\n }\n \n-pub fn test_theme_against<P: AsRef<Path>>(f: &P, against: &CssPath) -> (bool, Vec<String>) {\n-    let mut file = try_something!(File::open(f), (false, Vec::new()));\n+pub fn test_theme_against<P: AsRef<Path>>(f: &P, against: &CssPath, diag: &Handler)\n+    -> (bool, Vec<String>)\n+{\n+    let mut file = try_something!(File::open(f), diag, (false, Vec::new()));\n     let mut data = Vec::with_capacity(1000);\n \n-    try_something!(file.read_to_end(&mut data), (false, Vec::new()));\n+    try_something!(file.read_to_end(&mut data), diag, (false, Vec::new()));\n     let paths = load_css_paths(&data);\n     let mut ret = Vec::new();\n     get_differences(against, &paths, &mut ret);"}]}