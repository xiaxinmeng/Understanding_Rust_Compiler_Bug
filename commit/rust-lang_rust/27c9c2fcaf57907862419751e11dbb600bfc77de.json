{"sha": "27c9c2fcaf57907862419751e11dbb600bfc77de", "node_id": "C_kwDOAAsO6NoAKDI3YzljMmZjYWY1NzkwNzg2MjQxOTc1MWUxMWRiYjYwMGJmYzc3ZGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-16T12:56:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-16T12:56:35Z"}, "message": "Auto merge of #13961 - lowr:fix/impl-missing-members-type-neq, r=Veykril\n\nfix: don't generate `PartialEq`/`PartialOrd` methods body for types don't match\n\nFixes #12985\n\nThis PR changes the implementation of well-known trait methods body generation so that it takes generic arguments of traits into account and does not generate `PartialEq`/`PartialOrd` methods body when the self type and rhs type don't match.\n\nI took this opportunity to add `hir::TraitRef`, which has been suggested by a FIXME note. I didn't change the signature of the existing method `hir::Impl::trait_(self, db) -> Option<Trait>` as suggested by FIXME but added a new method because you quite often only want to know the trait rather than `TraitRef`s.", "tree": {"sha": "99a498b74b28d6d129790f7a210c304e311a8c25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99a498b74b28d6d129790f7a210c304e311a8c25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27c9c2fcaf57907862419751e11dbb600bfc77de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27c9c2fcaf57907862419751e11dbb600bfc77de", "html_url": "https://github.com/rust-lang/rust/commit/27c9c2fcaf57907862419751e11dbb600bfc77de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27c9c2fcaf57907862419751e11dbb600bfc77de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff4d55e480470fd6e3c3c003703612294fd09d15", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff4d55e480470fd6e3c3c003703612294fd09d15", "html_url": "https://github.com/rust-lang/rust/commit/ff4d55e480470fd6e3c3c003703612294fd09d15"}, {"sha": "fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66", "html_url": "https://github.com/rust-lang/rust/commit/fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66"}], "stats": {"total": 153, "additions": 131, "deletions": 22}, "files": [{"sha": "54342f1b7c44f660aa5fdf1e7778621ec40a2811", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/27c9c2fcaf57907862419751e11dbb600bfc77de/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c9c2fcaf57907862419751e11dbb600bfc77de/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=27c9c2fcaf57907862419751e11dbb600bfc77de", "patch": "@@ -2791,14 +2791,19 @@ impl Impl {\n         all\n     }\n \n-    // FIXME: the return type is wrong. This should be a hir version of\n-    // `TraitRef` (to account for parameters and qualifiers)\n     pub fn trait_(self, db: &dyn HirDatabase) -> Option<Trait> {\n-        let trait_ref = db.impl_trait(self.id)?.skip_binders().clone();\n-        let id = hir_ty::from_chalk_trait_id(trait_ref.trait_id);\n+        let trait_ref = db.impl_trait(self.id)?;\n+        let id = trait_ref.skip_binders().hir_trait_id();\n         Some(Trait { id })\n     }\n \n+    pub fn trait_ref(self, db: &dyn HirDatabase) -> Option<TraitRef> {\n+        let substs = TyBuilder::placeholder_subst(db, self.id);\n+        let trait_ref = db.impl_trait(self.id)?.substitute(Interner, &substs);\n+        let resolver = self.id.resolver(db.upcast());\n+        Some(TraitRef::new_with_resolver(db, &resolver, trait_ref))\n+    }\n+\n     pub fn self_ty(self, db: &dyn HirDatabase) -> Type {\n         let resolver = self.id.resolver(db.upcast());\n         let substs = TyBuilder::placeholder_subst(db, self.id);\n@@ -2824,6 +2829,48 @@ impl Impl {\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct TraitRef {\n+    env: Arc<TraitEnvironment>,\n+    trait_ref: hir_ty::TraitRef,\n+}\n+\n+impl TraitRef {\n+    pub(crate) fn new_with_resolver(\n+        db: &dyn HirDatabase,\n+        resolver: &Resolver,\n+        trait_ref: hir_ty::TraitRef,\n+    ) -> TraitRef {\n+        let env = resolver.generic_def().map_or_else(\n+            || Arc::new(TraitEnvironment::empty(resolver.krate())),\n+            |d| db.trait_environment(d),\n+        );\n+        TraitRef { env, trait_ref }\n+    }\n+\n+    pub fn trait_(&self) -> Trait {\n+        let id = self.trait_ref.hir_trait_id();\n+        Trait { id }\n+    }\n+\n+    pub fn self_ty(&self) -> Type {\n+        let ty = self.trait_ref.self_type_parameter(Interner);\n+        Type { env: self.env.clone(), ty }\n+    }\n+\n+    /// Returns `idx`-th argument of this trait reference if it is a type argument. Note that the\n+    /// first argument is the `Self` type.\n+    pub fn get_type_argument(&self, idx: usize) -> Option<Type> {\n+        self.trait_ref\n+            .substitution\n+            .as_slice(Interner)\n+            .get(idx)\n+            .and_then(|arg| arg.ty(Interner))\n+            .cloned()\n+            .map(|ty| Type { env: self.env.clone(), ty })\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct Type {\n     env: Arc<TraitEnvironment>,"}, {"sha": "627a9852fc8b8f0a3de7144ac99b9647b2d33550", "filename": "crates/ide-assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/27c9c2fcaf57907862419751e11dbb600bfc77de/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c9c2fcaf57907862419751e11dbb600bfc77de/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=27c9c2fcaf57907862419751e11dbb600bfc77de", "patch": "@@ -1,7 +1,5 @@\n use hir::HasSource;\n-use ide_db::{\n-    syntax_helpers::insert_whitespace_into_node::insert_ws_into, traits::resolve_target_trait,\n-};\n+use ide_db::syntax_helpers::insert_whitespace_into_node::insert_ws_into;\n use syntax::ast::{self, make, AstNode};\n \n use crate::{\n@@ -107,6 +105,7 @@ fn add_missing_impl_members_inner(\n ) -> Option<()> {\n     let _p = profile::span(\"add_missing_impl_members_inner\");\n     let impl_def = ctx.find_node_at_offset::<ast::Impl>()?;\n+    let impl_ = ctx.sema.to_def(&impl_def)?;\n \n     if ctx.token_at_offset().all(|t| {\n         t.parent_ancestors()\n@@ -116,7 +115,8 @@ fn add_missing_impl_members_inner(\n     }\n \n     let target_scope = ctx.sema.scope(impl_def.syntax())?;\n-    let trait_ = resolve_target_trait(&ctx.sema, &impl_def)?;\n+    let trait_ref = impl_.trait_ref(ctx.db())?;\n+    let trait_ = trait_ref.trait_();\n \n     let missing_items = filter_assoc_items(\n         &ctx.sema,\n@@ -155,7 +155,7 @@ fn add_missing_impl_members_inner(\n                 let placeholder;\n                 if let DefaultMethods::No = mode {\n                     if let ast::AssocItem::Fn(func) = &first_new_item {\n-                        if try_gen_trait_body(ctx, func, &trait_, &impl_def).is_none() {\n+                        if try_gen_trait_body(ctx, func, trait_ref, &impl_def).is_none() {\n                             if let Some(m) =\n                                 func.syntax().descendants().find_map(ast::MacroCall::cast)\n                             {\n@@ -180,13 +180,13 @@ fn add_missing_impl_members_inner(\n fn try_gen_trait_body(\n     ctx: &AssistContext<'_>,\n     func: &ast::Fn,\n-    trait_: &hir::Trait,\n+    trait_ref: hir::TraitRef,\n     impl_def: &ast::Impl,\n ) -> Option<()> {\n-    let trait_path = make::ext::ident_path(&trait_.name(ctx.db()).to_string());\n+    let trait_path = make::ext::ident_path(&trait_ref.trait_().name(ctx.db()).to_string());\n     let hir_ty = ctx.sema.resolve_type(&impl_def.self_ty()?)?;\n     let adt = hir_ty.as_adt()?.source(ctx.db())?;\n-    gen_trait_fn_body(func, &trait_path, &adt.value)\n+    gen_trait_fn_body(func, &trait_path, &adt.value, Some(trait_ref))\n }\n \n #[cfg(test)]\n@@ -1352,6 +1352,50 @@ impl PartialEq for SomeStruct {\n         );\n     }\n \n+    #[test]\n+    fn test_partial_eq_body_when_types_semantically_match() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+//- minicore: eq\n+struct S<T, U>(T, U);\n+type Alias<T> = S<T, T>;\n+impl<T> PartialEq<Alias<T>> for S<T, T> {$0}\n+\"#,\n+            r#\"\n+struct S<T, U>(T, U);\n+type Alias<T> = S<T, T>;\n+impl<T> PartialEq<Alias<T>> for S<T, T> {\n+    $0fn eq(&self, other: &Alias<T>) -> bool {\n+        self.0 == other.0 && self.1 == other.1\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_partial_eq_body_when_types_dont_match() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+//- minicore: eq\n+struct S<T, U>(T, U);\n+type Alias<T> = S<T, T>;\n+impl<T> PartialEq<Alias<T>> for S<T, i32> {$0}\n+\"#,\n+            r#\"\n+struct S<T, U>(T, U);\n+type Alias<T> = S<T, T>;\n+impl<T> PartialEq<Alias<T>> for S<T, i32> {\n+    fn eq(&self, other: &Alias<T>) -> bool {\n+        ${0:todo!()}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_ignore_function_body() {\n         check_assist_not_applicable("}, {"sha": "4cfae0c7212c2c2c48d00f343bf06b6364c5a9f5", "filename": "crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27c9c2fcaf57907862419751e11dbb600bfc77de/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c9c2fcaf57907862419751e11dbb600bfc77de/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=27c9c2fcaf57907862419751e11dbb600bfc77de", "patch": "@@ -214,7 +214,7 @@ fn impl_def_from_trait(\n \n     // Generate a default `impl` function body for the derived trait.\n     if let ast::AssocItem::Fn(ref func) = first_assoc_item {\n-        let _ = gen_trait_fn_body(func, trait_path, adt);\n+        let _ = gen_trait_fn_body(func, trait_path, adt, None);\n     };\n \n     Some((impl_def, first_assoc_item))"}, {"sha": "808b23405951c6f0910087ada1081123e2e615b8", "filename": "crates/ide-assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/27c9c2fcaf57907862419751e11dbb600bfc77de/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27c9c2fcaf57907862419751e11dbb600bfc77de/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=27c9c2fcaf57907862419751e11dbb600bfc77de", "patch": "@@ -1,27 +1,31 @@\n //! This module contains functions to generate default trait impl function bodies where possible.\n \n+use hir::TraitRef;\n use syntax::{\n     ast::{self, edit::AstNodeEdit, make, AstNode, BinaryOp, CmpOp, HasName, LogicOp},\n     ted,\n };\n \n /// Generate custom trait bodies without default implementation where possible.\n ///\n+/// If `func` is defined within an existing impl block, pass [`TraitRef`]. Otherwise pass `None`.\n+///\n /// Returns `Option` so that we can use `?` rather than `if let Some`. Returning\n /// `None` means that generating a custom trait body failed, and the body will remain\n /// as `todo!` instead.\n pub(crate) fn gen_trait_fn_body(\n     func: &ast::Fn,\n     trait_path: &ast::Path,\n     adt: &ast::Adt,\n+    trait_ref: Option<TraitRef>,\n ) -> Option<()> {\n     match trait_path.segment()?.name_ref()?.text().as_str() {\n         \"Clone\" => gen_clone_impl(adt, func),\n         \"Debug\" => gen_debug_impl(adt, func),\n         \"Default\" => gen_default_impl(adt, func),\n         \"Hash\" => gen_hash_impl(adt, func),\n-        \"PartialEq\" => gen_partial_eq(adt, func),\n-        \"PartialOrd\" => gen_partial_ord(adt, func),\n+        \"PartialEq\" => gen_partial_eq(adt, func, trait_ref),\n+        \"PartialOrd\" => gen_partial_ord(adt, func, trait_ref),\n         _ => None,\n     }\n }\n@@ -395,7 +399,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n }\n \n /// Generate a `PartialEq` impl based on the fields and members of the target type.\n-fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn, trait_ref: Option<TraitRef>) -> Option<()> {\n     stdx::always!(func.name().map_or(false, |name| name.text() == \"eq\"));\n     fn gen_eq_chain(expr: Option<ast::Expr>, cmp: ast::Expr) -> Option<ast::Expr> {\n         match expr {\n@@ -423,8 +427,15 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n         ast::Pat::IdentPat(make::ident_pat(false, false, make::name(field_name)))\n     }\n \n-    // FIXME: return `None` if the trait carries a generic type; we can only\n-    // generate this code `Self` for the time being.\n+    // Check that self type and rhs type match. We don't know how to implement the method\n+    // automatically otherwise.\n+    if let Some(trait_ref) = trait_ref {\n+        let self_ty = trait_ref.self_ty();\n+        let rhs_ty = trait_ref.get_type_argument(1)?;\n+        if self_ty != rhs_ty {\n+            return None;\n+        }\n+    }\n \n     let body = match adt {\n         // `PartialEq` cannot be derived for unions, so no default impl can be provided.\n@@ -568,7 +579,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 make::block_expr(None, expr).indent(ast::edit::IndentLevel(1))\n             }\n \n-            // No fields in the body means there's nothing to hash.\n+            // No fields in the body means there's nothing to compare.\n             None => {\n                 let expr = make::expr_literal(\"true\").into();\n                 make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))\n@@ -580,7 +591,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n     Some(())\n }\n \n-fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn, trait_ref: Option<TraitRef>) -> Option<()> {\n     stdx::always!(func.name().map_or(false, |name| name.text() == \"partial_cmp\"));\n     fn gen_partial_eq_match(match_target: ast::Expr) -> Option<ast::Stmt> {\n         let mut arms = vec![];\n@@ -605,8 +616,15 @@ fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n         make::expr_method_call(lhs, method, make::arg_list(Some(rhs)))\n     }\n \n-    // FIXME: return `None` if the trait carries a generic type; we can only\n-    // generate this code `Self` for the time being.\n+    // Check that self type and rhs type match. We don't know how to implement the method\n+    // automatically otherwise.\n+    if let Some(trait_ref) = trait_ref {\n+        let self_ty = trait_ref.self_ty();\n+        let rhs_ty = trait_ref.get_type_argument(1)?;\n+        if self_ty != rhs_ty {\n+            return None;\n+        }\n+    }\n \n     let body = match adt {\n         // `PartialOrd` cannot be derived for unions, so no default impl can be provided."}]}