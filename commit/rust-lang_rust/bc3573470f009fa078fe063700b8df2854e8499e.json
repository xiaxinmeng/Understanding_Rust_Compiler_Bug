{"sha": "bc3573470f009fa078fe063700b8df2854e8499e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMzU3MzQ3MGYwMDlmYTA3OGZlMDYzNzAwYjhkZjI4NTRlODQ5OWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-24T22:13:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-24T22:13:45Z"}, "message": "Auto merge of #27943 - arielb1:fast-region, r=nikomatsakis\n\nThis increases regionck performance greatly - type-checking on\r\nlibrustc decreased from 9.1s to 8.1s. Because of Amdahl's law,\r\ntotal performance is improved only by about 1.5% (LLVM wizards,\r\nthis is your opportunity to shine!).\r\n\r\nbefore:\r\n576.91user 4.26system 7:42.36elapsed 125%CPU (0avgtext+0avgdata 1142192maxresident)k\r\nafter:\r\n566.50user 4.84system 7:36.84elapsed 125%CPU (0avgtext+0avgdata 1124304maxresident)k\r\n\r\nI am somewhat worried really need to find out why we have this Red Queen's\r\nRace going on here. Originally I suspected it may be a problem from RFC1214's\r\nwarnings, but it seems to be an effect from other changes.\r\n\r\nHowever, the increase seems to be mostly in LLVM's time, so I guess\r\nit's the LLVM wizards' problem.\r\n\r\nr? @nikomatsakis", "tree": {"sha": "78d30092c3dc81e1ec55a0130f49281ed6a89d57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78d30092c3dc81e1ec55a0130f49281ed6a89d57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc3573470f009fa078fe063700b8df2854e8499e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc3573470f009fa078fe063700b8df2854e8499e", "html_url": "https://github.com/rust-lang/rust/commit/bc3573470f009fa078fe063700b8df2854e8499e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc3573470f009fa078fe063700b8df2854e8499e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c996499a1bcf747b12f8290eeff3024e59da529", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c996499a1bcf747b12f8290eeff3024e59da529", "html_url": "https://github.com/rust-lang/rust/commit/4c996499a1bcf747b12f8290eeff3024e59da529"}, {"sha": "06563fe0b7d64b7552d65a7ab00aa360820f05c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/06563fe0b7d64b7552d65a7ab00aa360820f05c5", "html_url": "https://github.com/rust-lang/rust/commit/06563fe0b7d64b7552d65a7ab00aa360820f05c5"}], "stats": {"total": 1328, "additions": 664, "deletions": 664}, "files": [{"sha": "0c802356af10d8ac3b1fcb585a8495cbb29381f3", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -207,6 +207,10 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             'B' => {\n                 assert_eq!(self.next(), '[');\n+                // this is the wrong NodeId, but `param_id` is only accessed\n+                // by the receiver-matching code in collect, which won't\n+                // be going down this code path, and anyway I will kill it\n+                // the moment wfcheck becomes the standard.\n                 let node_id = self.parse_uint() as ast::NodeId;\n                 assert_eq!(self.next(), '|');\n                 let space = self.parse_param_space();\n@@ -223,7 +227,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             'f' => {\n                 assert_eq!(self.next(), '[');\n-                let scope = self.parse_destruction_scope_data();\n+                let scope = self.parse_scope();\n                 assert_eq!(self.next(), '|');\n                 let br = self.parse_bound_region();\n                 assert_eq!(self.next(), ']');\n@@ -246,43 +250,44 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     }\n \n     fn parse_scope(&mut self) -> region::CodeExtent {\n-        match self.next() {\n+        self.tcx.region_maps.bogus_code_extent(match self.next() {\n+            // This creates scopes with the wrong NodeId. This isn't\n+            // actually a problem because scopes only exist *within*\n+            // functions, and functions aren't loaded until trans which\n+            // doesn't care about regions.\n+            //\n+            // May still be worth fixing though.\n             'P' => {\n                 assert_eq!(self.next(), '[');\n                 let fn_id = self.parse_uint() as ast::NodeId;\n                 assert_eq!(self.next(), '|');\n                 let body_id = self.parse_uint() as ast::NodeId;\n                 assert_eq!(self.next(), ']');\n-                region::CodeExtent::ParameterScope {\n+                region::CodeExtentData::ParameterScope {\n                     fn_id: fn_id, body_id: body_id\n                 }\n             }\n             'M' => {\n                 let node_id = self.parse_uint() as ast::NodeId;\n-                region::CodeExtent::Misc(node_id)\n+                region::CodeExtentData::Misc(node_id)\n             }\n             'D' => {\n                 let node_id = self.parse_uint() as ast::NodeId;\n-                region::CodeExtent::DestructionScope(node_id)\n+                region::CodeExtentData::DestructionScope(node_id)\n             }\n             'B' => {\n                 assert_eq!(self.next(), '[');\n                 let node_id = self.parse_uint() as ast::NodeId;\n                 assert_eq!(self.next(), '|');\n-                let first_stmt_index = self.parse_uint();\n+                let first_stmt_index = self.parse_u32();\n                 assert_eq!(self.next(), ']');\n                 let block_remainder = region::BlockRemainder {\n                     block: node_id, first_statement_index: first_stmt_index,\n                 };\n-                region::CodeExtent::Remainder(block_remainder)\n+                region::CodeExtentData::Remainder(block_remainder)\n             }\n             _ => panic!(\"parse_scope: bad input\")\n-        }\n-    }\n-\n-    fn parse_destruction_scope_data(&mut self) -> region::DestructionScopeData {\n-        let node_id = self.parse_uint() as ast::NodeId;\n-        region::DestructionScopeData::new(node_id)\n+        })\n     }\n \n     fn parse_opt<T, F>(&mut self, f: F) -> Option<T>\n@@ -619,6 +624,33 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n+    pub fn parse_region_param_def(&mut self) -> ty::RegionParameterDef {\n+        let name = self.parse_name(':');\n+        let def_id = self.parse_def(NominalType);\n+        let space = self.parse_param_space();\n+        assert_eq!(self.next(), '|');\n+        let index = self.parse_u32();\n+        assert_eq!(self.next(), '|');\n+        let mut bounds = vec![];\n+        loop {\n+            match self.next() {\n+                'R' => bounds.push(self.parse_region()),\n+                '.' => { break; }\n+                c => {\n+                    panic!(\"parse_region_param_def: bad bounds ('{}')\", c)\n+                }\n+            }\n+        }\n+        ty::RegionParameterDef {\n+            name: name,\n+            def_id: def_id,\n+            space: space,\n+            index: index,\n+            bounds: bounds\n+        }\n+    }\n+\n+\n     fn parse_object_lifetime_default(&mut self) -> ty::ObjectLifetimeDefault {\n         match self.next() {\n             'a' => ty::ObjectLifetimeDefault::Ambiguous,\n@@ -717,4 +749,3 @@ fn parse_unsafety(c: char) -> ast::Unsafety {\n         _ => panic!(\"parse_unsafety: bad unsafety {}\", c)\n     }\n }\n-"}, {"sha": "70345dc8bad11ee2ac0fcad65868009bb26ced3a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -255,7 +255,7 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n         }\n         ty::ReFree(ref fr) => {\n             mywrite!(w, \"f[\");\n-            enc_destruction_scope_data(w, fr.scope);\n+            enc_scope(w, cx, fr.scope);\n             mywrite!(w, \"|\");\n             enc_bound_region(w, cx, fr.bound_region);\n             mywrite!(w, \"]\");\n@@ -271,29 +271,24 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n         ty::ReEmpty => {\n             mywrite!(w, \"e\");\n         }\n-        ty::ReInfer(_) => {\n+        ty::ReVar(_) | ty::ReSkolemized(..) => {\n             // these should not crop up after typeck\n             cx.diag.handler().bug(\"cannot encode region variables\");\n         }\n     }\n }\n \n-fn enc_scope(w: &mut Encoder, _cx: &ctxt, scope: region::CodeExtent) {\n-    match scope {\n-        region::CodeExtent::ParameterScope {\n+fn enc_scope(w: &mut Encoder, cx: &ctxt, scope: region::CodeExtent) {\n+    match cx.tcx.region_maps.code_extent_data(scope) {\n+        region::CodeExtentData::ParameterScope {\n             fn_id, body_id } => mywrite!(w, \"P[{}|{}]\", fn_id, body_id),\n-        region::CodeExtent::Misc(node_id) => mywrite!(w, \"M{}\", node_id),\n-        region::CodeExtent::Remainder(region::BlockRemainder {\n+        region::CodeExtentData::Misc(node_id) => mywrite!(w, \"M{}\", node_id),\n+        region::CodeExtentData::Remainder(region::BlockRemainder {\n             block: b, first_statement_index: i }) => mywrite!(w, \"B[{}|{}]\", b, i),\n-        region::CodeExtent::DestructionScope(node_id) => mywrite!(w, \"D{}\", node_id),\n+        region::CodeExtentData::DestructionScope(node_id) => mywrite!(w, \"D{}\", node_id),\n     }\n }\n \n-fn enc_destruction_scope_data(w: &mut Encoder,\n-                              d: region::DestructionScopeData) {\n-    mywrite!(w, \"{}\", d.node_id);\n-}\n-\n fn enc_bound_region(w: &mut Encoder, cx: &ctxt, br: ty::BoundRegion) {\n     match br {\n         ty::BrAnon(idx) => {\n@@ -396,17 +391,6 @@ pub fn enc_existential_bounds<'a,'tcx>(w: &mut Encoder,\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_region_bounds<'a, 'tcx>(w: &mut Encoder,\n-                            cx: &ctxt<'a, 'tcx>,\n-                            rs: &[ty::Region]) {\n-    for &r in rs {\n-        mywrite!(w, \"R\");\n-        enc_region(w, cx, r);\n-    }\n-\n-    mywrite!(w, \".\");\n-}\n-\n pub fn enc_type_param_def<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n                                     v: &ty::TypeParameterDef<'tcx>) {\n     mywrite!(w, \"{}:{}|{}|{}|{}|\",\n@@ -416,6 +400,18 @@ pub fn enc_type_param_def<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n     enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n }\n \n+pub fn enc_region_param_def(w: &mut Encoder, cx: &ctxt,\n+                            v: &ty::RegionParameterDef) {\n+    mywrite!(w, \"{}:{}|{}|{}|\",\n+             v.name, (cx.ds)(v.def_id),\n+             v.space.to_uint(), v.index);\n+    for &r in &v.bounds {\n+        mywrite!(w, \"R\");\n+        enc_region(w, cx, r);\n+    }\n+    mywrite!(w, \".\");\n+}\n+\n fn enc_object_lifetime_default<'a, 'tcx>(w: &mut Encoder,\n                                          cx: &ctxt<'a, 'tcx>,\n                                          default: ty::ObjectLifetimeDefault)"}, {"sha": "4ea55d2d4e42cbe93f7751a58160aa6247b3a2b6", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 89, "deletions": 98, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -478,67 +478,6 @@ impl tr for def::Def {\n     }\n }\n \n-// ______________________________________________________________________\n-// Encoding and decoding of ancillary information\n-\n-impl tr for ty::Region {\n-    fn tr(&self, dcx: &DecodeContext) -> ty::Region {\n-        match *self {\n-            ty::ReLateBound(debruijn, br) => {\n-                ty::ReLateBound(debruijn, br.tr(dcx))\n-            }\n-            ty::ReEarlyBound(data) => {\n-                ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                    param_id: dcx.tr_id(data.param_id),\n-                    space: data.space,\n-                    index: data.index,\n-                    name: data.name,\n-                })\n-            }\n-            ty::ReScope(scope) => {\n-                ty::ReScope(scope.tr(dcx))\n-            }\n-            ty::ReEmpty | ty::ReStatic | ty::ReInfer(..) => {\n-                *self\n-            }\n-            ty::ReFree(ref fr) => {\n-                ty::ReFree(fr.tr(dcx))\n-            }\n-        }\n-    }\n-}\n-\n-impl tr for ty::FreeRegion {\n-    fn tr(&self, dcx: &DecodeContext) -> ty::FreeRegion {\n-        ty::FreeRegion { scope: self.scope.tr(dcx),\n-                         bound_region: self.bound_region.tr(dcx) }\n-    }\n-}\n-\n-impl tr for region::CodeExtent {\n-    fn tr(&self, dcx: &DecodeContext) -> region::CodeExtent {\n-        self.map_id(|id| dcx.tr_id(id))\n-    }\n-}\n-\n-impl tr for region::DestructionScopeData {\n-    fn tr(&self, dcx: &DecodeContext) -> region::DestructionScopeData {\n-        region::DestructionScopeData { node_id: dcx.tr_id(self.node_id) }\n-    }\n-}\n-\n-impl tr for ty::BoundRegion {\n-    fn tr(&self, dcx: &DecodeContext) -> ty::BoundRegion {\n-        match *self {\n-            ty::BrAnon(_) |\n-            ty::BrFresh(_) |\n-            ty::BrEnv => *self,\n-            ty::BrNamed(id, ident) => ty::BrNamed(dcx.tr_def_id(id),\n-                                                    ident),\n-        }\n-    }\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n@@ -574,24 +513,6 @@ impl tr for ty::Freevar {\n     }\n }\n \n-impl tr for ty::UpvarBorrow {\n-    fn tr(&self, dcx: &DecodeContext) -> ty::UpvarBorrow {\n-        ty::UpvarBorrow {\n-            kind: self.kind,\n-            region: self.region.tr(dcx)\n-        }\n-    }\n-}\n-\n-impl tr for ty::UpvarCapture {\n-    fn tr(&self, dcx: &DecodeContext) -> ty::UpvarCapture {\n-        match *self {\n-            ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n-            ty::UpvarCapture::ByRef(ref data) => ty::UpvarCapture::ByRef(data.tr(dcx)),\n-        }\n-    }\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding of MethodCallee\n \n@@ -703,10 +624,13 @@ impl<'a, 'tcx> get_ty_str_ctxt<'tcx> for e::EncodeContext<'a, 'tcx> {\n trait rbml_writer_helpers<'tcx> {\n     fn emit_closure_type<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                              closure_type: &ty::ClosureTy<'tcx>);\n+    fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region);\n     fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n     fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]);\n     fn emit_type_param_def<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                type_param_def: &ty::TypeParameterDef<'tcx>);\n+    fn emit_region_param_def(&mut self, ecx: &e::EncodeContext,\n+                             region_param_def: &ty::RegionParameterDef);\n     fn emit_predicate<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                           predicate: &ty::Predicate<'tcx>);\n     fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n@@ -718,9 +642,11 @@ trait rbml_writer_helpers<'tcx> {\n     fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n                                    bounds: &ty::ExistentialBounds<'tcx>);\n     fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds);\n+    fn emit_upvar_capture(&mut self, ecx: &e::EncodeContext, capture: &ty::UpvarCapture);\n     fn emit_auto_adjustment<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                 adj: &ty::AutoAdjustment<'tcx>);\n-    fn emit_autoref<'a>(&mut self, autoref: &ty::AutoRef<'tcx>);\n+    fn emit_autoref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n+                        autoref: &ty::AutoRef<'tcx>);\n     fn emit_auto_deref_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                                auto_deref_ref: &ty::AutoDerefRef<'tcx>);\n }\n@@ -734,6 +660,10 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n+    fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region) {\n+        self.emit_opaque(|this| Ok(e::write_region(ecx, this, r)));\n+    }\n+\n     fn emit_ty<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>, ty: Ty<'tcx>) {\n         self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n     }\n@@ -755,7 +685,14 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                                          type_param_def))\n         });\n     }\n-\n+    fn emit_region_param_def(&mut self, ecx: &e::EncodeContext,\n+                             region_param_def: &ty::RegionParameterDef) {\n+        self.emit_opaque(|this| {\n+            Ok(tyencode::enc_region_param_def(this,\n+                                              &ecx.ty_str_ctxt(),\n+                                              region_param_def))\n+        });\n+    }\n     fn emit_predicate<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                           predicate: &ty::Predicate<'tcx>) {\n         self.emit_opaque(|this| {\n@@ -781,7 +718,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_struct_field(\"regions\", 1, |this| {\n                         Ok(encode_vec_per_param_space(\n                             this, &type_scheme.generics.regions,\n-                            |this, def| def.encode(this).unwrap()))\n+                            |this, def| this.emit_region_param_def(ecx, def)))\n                     })\n                 })\n             });\n@@ -804,6 +741,26 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                                                                 bounds)));\n     }\n \n+    fn emit_upvar_capture(&mut self, ecx: &e::EncodeContext, capture: &ty::UpvarCapture) {\n+        use serialize::Encoder;\n+\n+        self.emit_enum(\"UpvarCapture\", |this| {\n+            match *capture {\n+                ty::UpvarCapture::ByValue => {\n+                    this.emit_enum_variant(\"ByValue\", 1, 0, |_| Ok(()))\n+                }\n+                ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind, region }) => {\n+                    this.emit_enum_variant(\"ByRef\", 2, 0, |this| {\n+                        this.emit_enum_variant_arg(0,\n+                            |this| kind.encode(this));\n+                        this.emit_enum_variant_arg(1,\n+                            |this| Ok(this.emit_region(ecx, region)))\n+                    })\n+                }\n+            }\n+        }).unwrap()\n+    }\n+\n     fn emit_substs<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                        substs: &subst::Substs<'tcx>) {\n         self.emit_opaque(|this| Ok(tyencode::enc_substs(this,\n@@ -837,14 +794,16 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_autoref<'b>(&mut self, autoref: &ty::AutoRef<'tcx>) {\n+    fn emit_autoref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n+                        autoref: &ty::AutoRef<'tcx>) {\n         use serialize::Encoder;\n \n         self.emit_enum(\"AutoRef\", |this| {\n             match autoref {\n                 &ty::AutoPtr(r, m) => {\n                     this.emit_enum_variant(\"AutoPtr\", 0, 2, |this| {\n-                        this.emit_enum_variant_arg(0, |this| r.encode(this));\n+                        this.emit_enum_variant_arg(0,\n+                            |this| Ok(this.emit_region(ecx, *r)));\n                         this.emit_enum_variant_arg(1, |this| m.encode(this))\n                     })\n                 }\n@@ -868,7 +827,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                 this.emit_option(|this| {\n                     match auto_deref_ref.autoref {\n                         None => this.emit_option_none(),\n-                        Some(ref a) => this.emit_option_some(|this| Ok(this.emit_autoref(a))),\n+                        Some(ref a) => this.emit_option_some(|this| Ok(this.emit_autoref(ecx, a))),\n                     }\n                 })\n             });\n@@ -983,7 +942,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                                        .unwrap()\n                                        .clone();\n                 var_id.encode(rbml_w);\n-                upvar_capture.encode(rbml_w);\n+                rbml_w.emit_upvar_capture(ecx, &upvar_capture);\n             })\n         }\n     }\n@@ -1080,6 +1039,7 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                      f: F) -> R\n         where F: for<'x> FnOnce(&mut tydecode::TyDecoder<'x, 'tcx>) -> R;\n \n+    fn read_region(&mut self, dcx: &DecodeContext) -> ty::Region;\n     fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx>;\n     fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n     fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1088,6 +1048,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                    -> ty::PolyTraitRef<'tcx>;\n     fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> ty::TypeParameterDef<'tcx>;\n+    fn read_region_param_def(&mut self, dcx: &DecodeContext)\n+                             -> ty::RegionParameterDef;\n     fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                               -> ty::Predicate<'tcx>;\n     fn read_type_scheme<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1096,6 +1058,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                        -> ty::ExistentialBounds<'tcx>;\n     fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                            -> subst::Substs<'tcx>;\n+    fn read_upvar_capture(&mut self, dcx: &DecodeContext)\n+                          -> ty::UpvarCapture;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                     -> ty::AutoAdjustment<'tcx>;\n     fn read_cast_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1180,13 +1144,14 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             str\n         }\n     }\n-\n-    fn read_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> Ty<'tcx> {\n+    fn read_region(&mut self, dcx: &DecodeContext) -> ty::Region {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n-        // are not used during trans.\n-\n+        // are not used during trans. This also applies to read_ty.\n+        return self.read_ty_encoded(dcx, |decoder| decoder.parse_region());\n+    }\n+    fn read_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> Ty<'tcx> {\n         return self.read_ty_encoded(dcx, |decoder| decoder.parse_ty());\n     }\n \n@@ -1209,7 +1174,10 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                    -> ty::TypeParameterDef<'tcx> {\n         self.read_ty_encoded(dcx, |decoder| decoder.parse_type_param_def())\n     }\n-\n+    fn read_region_param_def(&mut self, dcx: &DecodeContext)\n+                             -> ty::RegionParameterDef {\n+        self.read_ty_encoded(dcx, |decoder| decoder.parse_region_param_def())\n+    }\n     fn read_predicate<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                               -> ty::Predicate<'tcx>\n     {\n@@ -1232,7 +1200,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                             regions:\n                             this.read_struct_field(\"regions\", 1, |this| {\n                                 Ok(this.read_vec_per_param_space(\n-                                    |this| Decodable::decode(this).unwrap()))\n+                                    |this| this.read_region_param_def(dcx)))\n                             }).unwrap(),\n                         })\n                     })\n@@ -1258,7 +1226,23 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                .parse_substs())\n         }).unwrap()\n     }\n-\n+    fn read_upvar_capture(&mut self, dcx: &DecodeContext) -> ty::UpvarCapture {\n+        self.read_enum(\"UpvarCapture\", |this| {\n+            let variants = [\"ByValue\", \"ByRef\"];\n+            this.read_enum_variant(&variants, |this, i| {\n+                Ok(match i {\n+                    1 => ty::UpvarCapture::ByValue,\n+                    2 => ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n+                        kind: this.read_enum_variant_arg(0,\n+                                  |this| Decodable::decode(this)).unwrap(),\n+                        region: this.read_enum_variant_arg(1,\n+                                    |this| Ok(this.read_region(dcx))).unwrap()\n+                    }),\n+                    _ => panic!(\"bad enum variant for ty::UpvarCapture\")\n+                })\n+            })\n+        }).unwrap()\n+    }\n     fn read_auto_adjustment<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                     -> ty::AutoAdjustment<'tcx> {\n         self.read_enum(\"AutoAdjustment\", |this| {\n@@ -1317,11 +1301,15 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                 Ok(match i {\n                     0 => {\n                         let r: ty::Region =\n-                            this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n+                            this.read_enum_variant_arg(0, |this| {\n+                                Ok(this.read_region(dcx))\n+                            }).unwrap();\n                         let m: ast::Mutability =\n-                            this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n+                            this.read_enum_variant_arg(1, |this| {\n+                                Decodable::decode(this)\n+                            }).unwrap();\n \n-                        ty::AutoPtr(dcx.tcx.mk_region(r.tr(dcx)), m)\n+                        ty::AutoPtr(dcx.tcx.mk_region(r), m)\n                     }\n                     1 => {\n                         let m: ast::Mutability =\n@@ -1376,6 +1364,9 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     /// case. We translate them with `tr_def_id()` which will map\n     /// the crate numbers back to the original source crate.\n     ///\n+    /// Scopes will end up as being totally bogus. This can actually\n+    /// be fixed though.\n+    ///\n     /// Unboxed closures are cloned along with the function being\n     /// inlined, and all side tables use interned node IDs, so we\n     /// translate their def IDs accordingly.\n@@ -1453,8 +1444,8 @@ fn decode_side_tables(dcx: &DecodeContext,\n                             var_id: dcx.tr_id(var_id),\n                             closure_expr_id: id\n                         };\n-                        let ub: ty::UpvarCapture = Decodable::decode(val_dsr).unwrap();\n-                        dcx.tcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub.tr(dcx));\n+                        let ub = val_dsr.read_upvar_capture(dcx);\n+                        dcx.tcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub);\n                     }\n                     c::tag_table_tcache => {\n                         let type_scheme = val_dsr.read_type_scheme(dcx);"}, {"sha": "91e35c0679bf2502eaf3b3d50dceafb62e4af043", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -12,7 +12,6 @@ use rustc_data_structures::graph;\n use middle::cfg::*;\n use middle::def;\n use middle::pat_util;\n-use middle::region::CodeExtent;\n use middle::ty;\n use syntax::ast;\n use syntax::ast_util;\n@@ -585,11 +584,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         to_loop: LoopScope,\n                         to_index: CFGIndex) {\n         let mut data = CFGEdgeData {exiting_scopes: vec!() };\n-        let mut scope = CodeExtent::from_node_id(from_expr.id);\n-        let target_scope = CodeExtent::from_node_id(to_loop.loop_id);\n+        let mut scope = self.tcx.region_maps.node_extent(from_expr.id);\n+        let target_scope = self.tcx.region_maps.node_extent(to_loop.loop_id);\n         while scope != target_scope {\n-\n-            data.exiting_scopes.push(scope.node_id());\n+            data.exiting_scopes.push(scope.node_id(&self.tcx.region_maps));\n             scope = self.tcx.region_maps.encl_scope(scope);\n         }\n         self.graph.add_edge(from_index, to_index, data);"}, {"sha": "ce03e10418d2e14b2887a22d772fda75488db6a1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -20,7 +20,7 @@ pub use self::MatchMode::*;\n use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n-use middle::{def, region, pat_util};\n+use middle::{def, pat_util};\n use middle::def_id::{DefId};\n use middle::infer;\n use middle::mem_categorization as mc;\n@@ -296,7 +296,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         for arg in &decl.inputs {\n             let arg_ty = return_if_err!(self.typer.node_ty(arg.pat.id));\n \n-            let fn_body_scope = region::CodeExtent::from_node_id(body.id);\n+            let fn_body_scope = self.tcx().region_maps.node_extent(body.id);\n             let arg_cmt = self.mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n@@ -579,7 +579,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         let callee_ty = return_if_err!(self.typer.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={:?} callee_ty={:?}\",\n                callee, callee_ty);\n-        let call_scope = region::CodeExtent::from_node_id(call.id);\n+        let call_scope = self.tcx().region_maps.node_extent(call.id);\n         match callee_ty.sty {\n             ty::TyBareFn(..) => {\n                 self.consume_expr(callee);\n@@ -862,7 +862,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 // Converting from a &T to *T (or &mut T to *mut T) is\n                 // treated as borrowing it for the enclosing temporary\n                 // scope.\n-                let r = ty::ReScope(region::CodeExtent::from_node_id(expr.id));\n+                let r = ty::ReScope(self.tcx().region_maps.node_extent(expr.id));\n \n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n@@ -917,7 +917,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         // methods are implicitly autoref'd which sadly does not use\n         // adjustments, so we must hardcode the borrow here.\n \n-        let r = ty::ReScope(region::CodeExtent::from_node_id(expr.id));\n+        let r = ty::ReScope(self.tcx().region_maps.node_extent(expr.id));\n         let bk = ty::ImmBorrow;\n \n         for &arg in &rhs {"}, {"sha": "c39c3fd30271236c3f097fcba8b31b961aa05025", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -135,7 +135,7 @@ impl FreeRegionMap {\n                     tcx.region_maps.is_subscope_of(sub_scope, super_scope),\n \n                 (ty::ReScope(sub_scope), ty::ReFree(fr)) =>\n-                    tcx.region_maps.is_subscope_of(sub_scope, fr.scope.to_code_extent()) ||\n+                    tcx.region_maps.is_subscope_of(sub_scope, fr.scope) ||\n                     self.is_static(fr),\n \n                 (ty::ReFree(sub_fr), ty::ReFree(super_fr)) =>\n@@ -162,8 +162,8 @@ impl FreeRegionMap {\n \n #[cfg(test)]\n fn free_region(index: u32) -> FreeRegion {\n-    use middle::region::DestructionScopeData;\n-    FreeRegion { scope: DestructionScopeData::new(0),\n+    use middle::region::DUMMY_CODE_EXTENT;\n+    FreeRegion { scope: DUMMY_CODE_EXTENT,\n                  bound_region: ty::BoundRegion::BrAnon(index) }\n }\n \n@@ -177,4 +177,3 @@ fn lub() {\n     map.relate_free_regions(frs[1], frs[2]);\n     assert_eq!(map.lub_free_regions(frs[0], frs[1]), ty::ReFree(frs[2]));\n }\n-"}, {"sha": "cfeec1c4f73e30d48073ac485042013cf263cde5", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -340,14 +340,14 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n \n             // Always make a fresh region variable for skolemized regions;\n             // the higher-ranked decision procedures rely on this.\n-            ty::ReInfer(ty::ReSkolemized(..)) => { }\n+            ty::ReSkolemized(..) => { }\n \n             // For anything else, we make a region variable, unless we\n             // are *equating*, in which case it's just wasteful.\n             ty::ReEmpty |\n             ty::ReStatic |\n             ty::ReScope(..) |\n-            ty::ReInfer(ty::ReVar(..)) |\n+            ty::ReVar(..) |\n             ty::ReFree(..) => {\n                 if !self.make_region_vars {\n                     return r;"}, {"sha": "61fa08c462069a0c3ca5c1bc4ed5071135aedcd6", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -121,11 +121,11 @@ impl<'tcx> ty::ctxt<'tcx> {\n                     format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n                             prefix, scope, suffix)\n                 };\n-                let span = match scope.span(&self.map) {\n+                let span = match scope.span(&self.region_maps, &self.map) {\n                     Some(s) => s,\n                     None => return self.sess.note(&unknown_scope())\n                 };\n-                let tag = match self.map.find(scope.node_id()) {\n+                let tag = match self.map.find(scope.node_id(&self.region_maps)) {\n                     Some(ast_map::NodeBlock(_)) => \"block\",\n                     Some(ast_map::NodeExpr(expr)) => match expr.node {\n                         ast::ExprCall(..) => \"call\",\n@@ -142,16 +142,16 @@ impl<'tcx> ty::ctxt<'tcx> {\n                         return self.sess.span_note(span, &unknown_scope());\n                     }\n                 };\n-                let scope_decorated_tag = match scope {\n-                    region::CodeExtent::Misc(_) => tag,\n-                    region::CodeExtent::ParameterScope { .. } => {\n+                let scope_decorated_tag = match self.region_maps.code_extent_data(scope) {\n+                    region::CodeExtentData::Misc(_) => tag,\n+                    region::CodeExtentData::ParameterScope { .. } => {\n                         \"scope of parameters for function\"\n                     }\n-                    region::CodeExtent::DestructionScope(_) => {\n+                    region::CodeExtentData::DestructionScope(_) => {\n                         new_string = format!(\"destruction scope surrounding {}\", tag);\n                         &new_string[..]\n                     }\n-                    region::CodeExtent::Remainder(r) => {\n+                    region::CodeExtentData::Remainder(r) => {\n                         new_string = format!(\"block suffix following statement {}\",\n                                              r.first_statement_index);\n                         &new_string[..]\n@@ -172,7 +172,7 @@ impl<'tcx> ty::ctxt<'tcx> {\n                     }\n                 };\n \n-                match self.map.find(fr.scope.node_id) {\n+                match self.map.find(fr.scope.node_id(&self.region_maps)) {\n                     Some(ast_map::NodeBlock(ref blk)) => {\n                         let (msg, opt_span) = explain_span(self, \"block\", blk.span);\n                         (format!(\"{} {}\", prefix, msg), opt_span)\n@@ -183,7 +183,8 @@ impl<'tcx> ty::ctxt<'tcx> {\n                         (format!(\"{} {}\", prefix, msg), opt_span)\n                     }\n                     Some(_) | None => {\n-                        // this really should not happen\n+                        // this really should not happen, but it does:\n+                        // FIXME(#27942)\n                         (format!(\"{} unknown free region bounded by scope {:?}\",\n                                  prefix, fr.scope), None)\n                     }\n@@ -196,9 +197,12 @@ impl<'tcx> ty::ctxt<'tcx> {\n \n             ty::ReEarlyBound(ref data) => (data.name.to_string(), None),\n \n-            // I believe these cases should not occur (except when debugging,\n-            // perhaps)\n-            ty::ReInfer(_) | ty::ReLateBound(..) => {\n+            // FIXME(#13998) ReSkolemized should probably print like\n+            // ReFree rather than dumping Debug output on the user.\n+            //\n+            // We shouldn't really be having unification failures with ReVar\n+            // and ReLateBound though.\n+            ty::ReSkolemized(..) | ty::ReVar(_) | ty::ReLateBound(..) => {\n                 (format!(\"lifetime {:?}\", region), None)\n             }\n         };\n@@ -419,7 +423,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                         return None\n                     }\n                     assert!(fr1.scope == fr2.scope);\n-                    (fr1.scope.node_id, fr1, fr2)\n+                    (fr1.scope.node_id(&tcx.region_maps), fr1, fr2)\n                 },\n                 _ => return None\n             };"}, {"sha": "c72a4fc0db3093cf1472ea853834e8c6ba4553a7", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -95,7 +95,8 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::ReStatic |\n             ty::ReFree(_) |\n             ty::ReScope(_) |\n-            ty::ReInfer(_) |\n+            ty::ReVar(_) |\n+            ty::ReSkolemized(..) |\n             ty::ReEmpty => {\n                 // replace all free regions with 'static\n                 ty::ReStatic"}, {"sha": "fb8da9b65daeebc1b79b97800fd435ba0a3aa5b8", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -335,7 +335,7 @@ fn var_ids<'a, 'tcx>(fields: &CombineFields<'a, 'tcx>,\n                      -> Vec<ty::RegionVid> {\n     map.iter()\n        .map(|(_, r)| match *r {\n-           ty::ReInfer(ty::ReVar(r)) => { r }\n+           ty::ReVar(r) => { r }\n            r => {\n                fields.tcx().sess.span_bug(\n                    fields.trace.origin.span(),\n@@ -347,7 +347,7 @@ fn var_ids<'a, 'tcx>(fields: &CombineFields<'a, 'tcx>,\n \n fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n     match r {\n-        ty::ReInfer(ty::ReVar(ref v)) => new_vars.iter().any(|x| x == v),\n+        ty::ReVar(ref v) => new_vars.iter().any(|x| x == v),\n         _ => false\n     }\n }\n@@ -443,7 +443,7 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n         }\n \n         region_vars.retain(|&region_vid| {\n-            let r = ty::ReInfer(ty::ReVar(region_vid));\n+            let r = ty::ReVar(region_vid);\n             !escaping_region_vars.contains(&r)\n         });\n \n@@ -561,7 +561,7 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n             // Each skolemized should only be relatable to itself\n             // or new variables:\n             match tainted_region {\n-                ty::ReInfer(ty::ReVar(vid)) => {\n+                ty::ReVar(vid) => {\n                     if new_vars.iter().any(|&x| x == vid) { continue; }\n                 }\n                 _ => {"}, {"sha": "4e8ed01c6b9e01e9a9318150cdcd6b48fe470284", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -1059,7 +1059,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region {\n-        ty::ReInfer(ty::ReVar(self.region_vars.new_region_var(origin)))\n+        ty::ReVar(self.region_vars.new_region_var(origin))\n     }\n \n     pub fn region_vars_for_defs(&self,"}, {"sha": "1785fe09f87a4c87903b0d1d0b356133aa4f06e3", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -25,7 +25,7 @@ use middle::free_region::FreeRegionMap;\n use middle::region;\n use middle::ty::{self, Ty, TypeError};\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n-use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound};\n+use middle::ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound};\n use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n use middle::ty_relate::RelateResult;\n use util::common::indenter;\n@@ -373,7 +373,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         let sc = self.skolemization_count.get();\n         self.skolemization_count.set(sc + 1);\n-        ReInfer(ReSkolemized(sc, br))\n+        ReSkolemized(sc, br)\n     }\n \n     pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> Region {\n@@ -510,13 +510,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           (_, ReStatic) => {\n             // all regions are subregions of static, so we can ignore this\n           }\n-          (ReInfer(ReVar(sub_id)), ReInfer(ReVar(sup_id))) => {\n+          (ReVar(sub_id), ReVar(sup_id)) => {\n             self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n           }\n-          (r, ReInfer(ReVar(sup_id))) => {\n+          (r, ReVar(sup_id)) => {\n             self.add_constraint(ConstrainRegSubVar(r, sup_id), origin);\n           }\n-          (ReInfer(ReVar(sub_id)), r) => {\n+          (ReVar(sub_id), r) => {\n             self.add_constraint(ConstrainVarSubReg(sub_id, r), origin);\n           }\n           _ => {\n@@ -621,7 +621,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let vars = TwoRegions { a: a, b: b };\n         match self.combine_map(t).borrow().get(&vars) {\n             Some(&c) => {\n-                return ReInfer(ReVar(c));\n+                return ReVar(c);\n             }\n             None => {}\n         }\n@@ -630,10 +630,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddCombination(t, vars));\n         }\n-        relate(self, a, ReInfer(ReVar(c)));\n-        relate(self, b, ReInfer(ReVar(c)));\n+        relate(self, a, ReVar(c));\n+        relate(self, b, ReVar(c));\n         debug!(\"combine_vars() c={:?}\", c);\n-        ReInfer(ReVar(c))\n+        ReVar(c)\n     }\n \n     pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot)\n@@ -672,22 +672,22 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     &AddConstraint(ConstrainVarSubVar(a, b)) => {\n                         consider_adding_bidirectional_edges(\n                             &mut result_set, r,\n-                            ReInfer(ReVar(a)), ReInfer(ReVar(b)));\n+                            ReVar(a), ReVar(b));\n                     }\n                     &AddConstraint(ConstrainRegSubVar(a, b)) => {\n                         consider_adding_bidirectional_edges(\n                             &mut result_set, r,\n-                            a, ReInfer(ReVar(b)));\n+                            a, ReVar(b));\n                     }\n                     &AddConstraint(ConstrainVarSubReg(a, b)) => {\n                         consider_adding_bidirectional_edges(\n                             &mut result_set, r,\n-                            ReInfer(ReVar(a)), b);\n+                            ReVar(a), b);\n                     }\n                     &AddGiven(a, b) => {\n                         consider_adding_bidirectional_edges(\n                             &mut result_set, r,\n-                            ReFree(a), ReInfer(ReVar(b)));\n+                            ReFree(a), ReVar(b));\n                     }\n                     &AddVerify(i) => {\n                         match (*self.verifys.borrow())[i] {\n@@ -775,7 +775,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             r // everything lives longer than empty\n           }\n \n-          (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n+          (ReVar(v_id), _) | (_, ReVar(v_id)) => {\n             self.tcx.sess.span_bug(\n                 (*self.var_origins.borrow())[v_id.index as usize].span(),\n                 &format!(\"lub_concrete_regions invoked with \\\n@@ -790,10 +790,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             // A \"free\" region can be interpreted as \"some region\n             // at least as big as the block fr.scope_id\".  So, we can\n             // reasonably compare free regions and scopes:\n-            let fr_scope = fr.scope.to_code_extent();\n-            let r_id = self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id);\n+            let r_id = self.tcx.region_maps.nearest_common_ancestor(fr.scope, s_id);\n \n-            if r_id == fr_scope {\n+            if r_id == fr.scope {\n               // if the free region's scope `fr.scope_id` is bigger than\n               // the scope region `s_id`, then the LUB is the free\n               // region itself:\n@@ -818,8 +817,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n           // For these types, we cannot define any additional\n           // relationship:\n-          (ReInfer(ReSkolemized(..)), _) |\n-          (_, ReInfer(ReSkolemized(..))) => {\n+          (ReSkolemized(..), _) |\n+          (_, ReSkolemized(..)) => {\n             if a == b {a} else {ReStatic}\n           }\n         }\n@@ -853,8 +852,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 Ok(ReEmpty)\n             }\n \n-            (ReInfer(ReVar(v_id)), _) |\n-            (_, ReInfer(ReVar(v_id))) => {\n+            (ReVar(v_id), _) |\n+            (_, ReVar(v_id)) => {\n                 self.tcx.sess.span_bug(\n                     (*self.var_origins.borrow())[v_id.index as usize].span(),\n                     &format!(\"glb_concrete_regions invoked with \\\n@@ -871,8 +870,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 // than the scope `s_id`, then we can say that the GLB\n                 // is the scope `s_id`.  Otherwise, as we do not know\n                 // big the free region is precisely, the GLB is undefined.\n-                let fr_scope = fr.scope.to_code_extent();\n-                if self.tcx.region_maps.nearest_common_ancestor(fr_scope, s_id) == fr_scope ||\n+                if self.tcx.region_maps.nearest_common_ancestor(fr.scope, s_id) == fr.scope ||\n                         free_regions.is_static(fr) {\n                     Ok(s)\n                 } else {\n@@ -890,8 +888,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n             // For these types, we cannot define any additional\n             // relationship:\n-            (ReInfer(ReSkolemized(..)), _) |\n-            (_, ReInfer(ReSkolemized(..))) => {\n+            (ReSkolemized(..), _) |\n+            (_, ReSkolemized(..)) => {\n                 if a == b {\n                     Ok(a)\n                 } else {\n@@ -927,8 +925,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 Ok(ty::ReFree(*b))\n             } else {\n                 this.intersect_scopes(ty::ReFree(*a), ty::ReFree(*b),\n-                                      a.scope.to_code_extent(),\n-                                      b.scope.to_code_extent())\n+                                      a.scope, b.scope)\n             }\n         }\n     }\n@@ -1632,7 +1629,7 @@ impl<'tcx> fmt::Debug for Verify<'tcx> {\n \n fn normalize(values: &Vec<VarValue>, r: ty::Region) -> ty::Region {\n     match r {\n-        ty::ReInfer(ReVar(rid)) => lookup(values, rid),\n+        ty::ReVar(rid) => lookup(values, rid),\n         _ => r\n     }\n }"}, {"sha": "9cc9f148ce183dbce9ad3f88a91804175c94b695", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         match r {\n-          ty::ReInfer(ty::ReVar(rid)) => self.infcx.region_vars.resolve_var(rid),\n+          ty::ReVar(rid) => self.infcx.region_vars.resolve_var(rid),\n           _ => r,\n         }\n     }"}, {"sha": "e1866d878bda63471f011df1cfd58e36e29e8ddb", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -111,7 +111,6 @@ use self::VarKind::*;\n \n use middle::def::*;\n use middle::pat_util;\n-use middle::region;\n use middle::ty;\n use lint;\n use util::nodemap::NodeMap;\n@@ -1509,7 +1508,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // within the fn body, late-bound regions are liberated:\n         let fn_ret =\n             self.ir.tcx.liberate_late_bound_regions(\n-                region::DestructionScopeData::new(body.id),\n+                self.ir.tcx.region_maps.item_extent(body.id),\n                 &self.fn_ret(id));\n \n         match fn_ret {"}, {"sha": "a991407310204c6d565ad81f9225d05a846ea788", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -77,7 +77,6 @@ use middle::def_id::DefId;\n use middle::infer;\n use middle::check_const;\n use middle::def;\n-use middle::region;\n use middle::ty::{self, Ty};\n \n use syntax::ast::{MutImmutable, MutMutable};\n@@ -749,7 +748,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n-            scope: region::DestructionScopeData::new(fn_body_id),\n+            scope: self.tcx().region_maps.item_extent(fn_body_id),\n             bound_region: ty::BrEnv\n         });\n "}, {"sha": "37b9d8aa645bcb6c94e098af49f2e251444091bf", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 313, "deletions": 321, "changes": 634, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -20,16 +20,27 @@ use ast_map;\n use metadata::inline::InlinedItem;\n use middle::ty::{self, Ty};\n use session::Session;\n-use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n+use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use std::cell::RefCell;\n+use std::collections::hash_map::Entry;\n+use std::mem;\n use syntax::codemap::{self, Span};\n use syntax::{ast, visit};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n use syntax::ast_util::stmt_id;\n-use syntax::ptr::P;\n use syntax::visit::{Visitor, FnKind};\n \n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n+           RustcDecodable, Debug, Copy)]\n+pub struct CodeExtent(u32);\n+\n+/// The root of everything. I should be using NonZero or profiling\n+/// instead of this (probably).\n+pub const ROOT_CODE_EXTENT : CodeExtent = CodeExtent(0);\n+/// A placeholder used in trans to stand for real code extents\n+pub const DUMMY_CODE_EXTENT : CodeExtent = CodeExtent(1);\n+\n /// CodeExtent represents a statically-describable extent that can be\n /// used to bound the lifetime/region for values.\n ///\n@@ -91,9 +102,8 @@ use syntax::visit::{Visitor, FnKind};\n /// placate the same deriving in `ty::FreeRegion`, but we may want to\n /// actually attach a more meaningful ordering to scopes than the one\n /// generated via deriving here.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n-           RustcDecodable, Debug, Copy)]\n-pub enum CodeExtent {\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy)]\n+pub enum CodeExtentData {\n     Misc(ast::NodeId),\n \n     // extent of parameters passed to a function or closure (they\n@@ -118,8 +128,9 @@ impl DestructionScopeData {\n     pub fn new(node_id: ast::NodeId) -> DestructionScopeData {\n         DestructionScopeData { node_id: node_id }\n     }\n-    pub fn to_code_extent(&self) -> CodeExtent {\n-        CodeExtent::DestructionScope(self.node_id)\n+    pub fn to_code_extent(&self, region_maps: &RegionMaps) -> CodeExtent {\n+        region_maps.lookup_code_extent(\n+            CodeExtentData::DestructionScope(self.node_id))\n     }\n }\n \n@@ -134,71 +145,62 @@ impl DestructionScopeData {\n /// * the subscope with `first_statement_index == 0` is scope of both\n ///   `a` and `b`; it does not include EXPR_1, but does include\n ///   everything after that first `let`. (If you want a scope that\n-///   includes EXPR_1 as well, then do not use `CodeExtent::Remainder`,\n+///   includes EXPR_1 as well, then do not use `CodeExtentData::Remainder`,\n ///   but instead another `CodeExtent` that encompasses the whole block,\n-///   e.g. `CodeExtent::Misc`.\n+///   e.g. `CodeExtentData::Misc`.\n ///\n /// * the subscope with `first_statement_index == 1` is scope of `c`,\n ///   and thus does not include EXPR_2, but covers the `...`.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n          RustcDecodable, Debug, Copy)]\n pub struct BlockRemainder {\n     pub block: ast::NodeId,\n-    pub first_statement_index: usize,\n+    pub first_statement_index: u32,\n }\n \n-impl CodeExtent {\n-    /// Creates a scope that represents the dynamic extent associated\n-    /// with `node_id`.\n-    pub fn from_node_id(node_id: ast::NodeId) -> CodeExtent {\n-        CodeExtent::Misc(node_id)\n-    }\n-\n+impl CodeExtentData {\n     /// Returns a node id associated with this scope.\n     ///\n     /// NB: likely to be replaced as API is refined; e.g. pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n     pub fn node_id(&self) -> ast::NodeId {\n         match *self {\n-            CodeExtent::Misc(node_id) => node_id,\n+            CodeExtentData::Misc(node_id) => node_id,\n \n             // These cases all return rough approximations to the\n             // precise extent denoted by `self`.\n-            CodeExtent::Remainder(br) => br.block,\n-            CodeExtent::DestructionScope(node_id) => node_id,\n-            CodeExtent::ParameterScope { fn_id: _, body_id } => body_id,\n+            CodeExtentData::Remainder(br) => br.block,\n+            CodeExtentData::DestructionScope(node_id) => node_id,\n+            CodeExtentData::ParameterScope { fn_id: _, body_id } => body_id,\n         }\n     }\n+}\n \n-    /// Maps this scope to a potentially new one according to the\n-    /// NodeId transformer `f_id`.\n-    pub fn map_id<F>(&self, mut f_id: F) -> CodeExtent where\n-        F: FnMut(ast::NodeId) -> ast::NodeId,\n-    {\n-        match *self {\n-            CodeExtent::Misc(node_id) => CodeExtent::Misc(f_id(node_id)),\n-            CodeExtent::Remainder(br) =>\n-                CodeExtent::Remainder(BlockRemainder {\n-                    block: f_id(br.block), first_statement_index: br.first_statement_index }),\n-            CodeExtent::DestructionScope(node_id) =>\n-                CodeExtent::DestructionScope(f_id(node_id)),\n-            CodeExtent::ParameterScope { fn_id, body_id } =>\n-                CodeExtent::ParameterScope { fn_id: f_id(fn_id), body_id: f_id(body_id) },\n+impl CodeExtent {\n+    #[inline]\n+    fn into_option(self) -> Option<CodeExtent> {\n+        if self == ROOT_CODE_EXTENT {\n+            None\n+        } else {\n+            Some(self)\n         }\n     }\n+    pub fn node_id(&self, region_maps: &RegionMaps) -> ast::NodeId {\n+        region_maps.code_extent_data(*self).node_id()\n+    }\n \n     /// Returns the span of this CodeExtent.  Note that in general the\n     /// returned span may not correspond to the span of any node id in\n     /// the AST.\n-    pub fn span(&self, ast_map: &ast_map::Map) -> Option<Span> {\n-        match ast_map.find(self.node_id()) {\n+    pub fn span(&self, region_maps: &RegionMaps, ast_map: &ast_map::Map) -> Option<Span> {\n+        match ast_map.find(self.node_id(region_maps)) {\n             Some(ast_map::NodeBlock(ref blk)) => {\n-                match *self {\n-                    CodeExtent::ParameterScope { .. } |\n-                    CodeExtent::Misc(_) |\n-                    CodeExtent::DestructionScope(_) => Some(blk.span),\n+                match region_maps.code_extent_data(*self) {\n+                    CodeExtentData::ParameterScope { .. } |\n+                    CodeExtentData::Misc(_) |\n+                    CodeExtentData::DestructionScope(_) => Some(blk.span),\n \n-                    CodeExtent::Remainder(r) => {\n+                    CodeExtentData::Remainder(r) => {\n                         assert_eq!(r.block, blk.id);\n                         // Want span for extent starting after the\n                         // indexed statement and ending at end of\n@@ -207,7 +209,7 @@ impl CodeExtent {\n                         //\n                         // (This is the special case aluded to in the\n                         // doc-comment for this method)\n-                        let stmt_span = blk.stmts[r.first_statement_index].span;\n+                        let stmt_span = blk.stmts[r.first_statement_index as usize].span;\n                         Some(Span { lo: stmt_span.hi, ..blk.span })\n                     }\n                 }\n@@ -222,13 +224,15 @@ impl CodeExtent {\n \n /// The region maps encode information about region relationships.\n pub struct RegionMaps {\n+    code_extents: RefCell<Vec<CodeExtentData>>,\n+    code_extent_interner: RefCell<FnvHashMap<CodeExtentData, CodeExtent>>,\n     /// `scope_map` maps from a scope id to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n     /// conditional expression or repeating block. (Note that the\n     /// enclosing scope id for the block associated with a closure is\n     /// the closure itself.)\n-    scope_map: RefCell<FnvHashMap<CodeExtent, CodeExtent>>,\n+    scope_map: RefCell<Vec<CodeExtent>>,\n \n     /// `var_map` maps from a variable or binding id to the block in\n     /// which that variable is declared.\n@@ -242,26 +246,6 @@ pub struct RegionMaps {\n     /// block (see `terminating_scopes`).\n     rvalue_scopes: RefCell<NodeMap<CodeExtent>>,\n \n-    /// `terminating_scopes` is a set containing the ids of each\n-    /// statement, or conditional/repeating expression. These scopes\n-    /// are calling \"terminating scopes\" because, when attempting to\n-    /// find the scope of a temporary, by default we search up the\n-    /// enclosing scopes until we encounter the terminating scope. A\n-    /// conditional/repeating expression is one which is not\n-    /// guaranteed to execute exactly once upon entering the parent\n-    /// scope. This could be because the expression only executes\n-    /// conditionally, such as the expression `b` in `a && b`, or\n-    /// because the expression may execute many times, such as a loop\n-    /// body. The reason that we distinguish such expressions is that,\n-    /// upon exiting the parent scope, we cannot statically know how\n-    /// many times the expression executed, and thus if the expression\n-    /// creates temporaries we cannot know statically how many such\n-    /// temporaries we would have to cleanup. Therefore we ensure that\n-    /// the temporaries never outlast the conditional/repeating\n-    /// expression, preventing the need for dynamic checks and/or\n-    /// arbitrary amounts of stack space.\n-    terminating_scopes: RefCell<FnvHashSet<CodeExtent>>,\n-\n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n     /// the block that is the fn body. This map points from the id of\n@@ -275,75 +259,6 @@ pub struct RegionMaps {\n     fn_tree: RefCell<NodeMap<ast::NodeId>>,\n }\n \n-/// Carries the node id for the innermost block or match expression,\n-/// for building up the `var_map` which maps ids to the blocks in\n-/// which they were declared.\n-#[derive(PartialEq, Eq, Debug, Copy, Clone)]\n-enum InnermostDeclaringBlock {\n-    None,\n-    Block(ast::NodeId),\n-    Statement(DeclaringStatementContext),\n-    Match(ast::NodeId),\n-    FnDecl { fn_id: ast::NodeId, body_id: ast::NodeId },\n-}\n-\n-impl InnermostDeclaringBlock {\n-    fn to_code_extent(&self) -> Option<CodeExtent> {\n-        let extent = match *self {\n-            InnermostDeclaringBlock::None => {\n-                return Option::None;\n-            }\n-            InnermostDeclaringBlock::FnDecl { fn_id, body_id } =>\n-                CodeExtent::ParameterScope { fn_id: fn_id, body_id: body_id },\n-            InnermostDeclaringBlock::Block(id) |\n-            InnermostDeclaringBlock::Match(id) => CodeExtent::from_node_id(id),\n-            InnermostDeclaringBlock::Statement(s) =>  s.to_code_extent(),\n-        };\n-        Option::Some(extent)\n-    }\n-}\n-\n-/// Contextual information for declarations introduced by a statement\n-/// (i.e. `let`). It carries node-id's for statement and enclosing\n-/// block both, as well as the statement's index within the block.\n-#[derive(PartialEq, Eq, Debug, Copy, Clone)]\n-struct DeclaringStatementContext {\n-    stmt_id: ast::NodeId,\n-    block_id: ast::NodeId,\n-    stmt_index: usize,\n-}\n-\n-impl DeclaringStatementContext {\n-    fn to_code_extent(&self) -> CodeExtent {\n-        CodeExtent::Remainder(BlockRemainder {\n-            block: self.block_id,\n-            first_statement_index: self.stmt_index,\n-        })\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Debug, Copy, Clone)]\n-enum InnermostEnclosingExpr {\n-    None,\n-    Some(ast::NodeId),\n-    Statement(DeclaringStatementContext),\n-}\n-\n-impl InnermostEnclosingExpr {\n-    fn to_code_extent(&self) -> Option<CodeExtent> {\n-        let extent = match *self {\n-            InnermostEnclosingExpr::None => {\n-                return Option::None;\n-            }\n-            InnermostEnclosingExpr::Statement(s) =>\n-                s.to_code_extent(),\n-            InnermostEnclosingExpr::Some(parent_id) =>\n-                CodeExtent::from_node_id(parent_id),\n-        };\n-        Some(extent)\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone)]\n pub struct Context {\n     /// the root of the current region tree. This is typically the id\n@@ -355,10 +270,10 @@ pub struct Context {\n     root_id: Option<ast::NodeId>,\n \n     /// the scope that contains any new variables declared\n-    var_parent: InnermostDeclaringBlock,\n+    var_parent: CodeExtent,\n \n     /// region parent of expressions etc\n-    parent: InnermostEnclosingExpr,\n+    parent: CodeExtent\n }\n \n struct RegionResolutionVisitor<'a> {\n@@ -367,14 +282,98 @@ struct RegionResolutionVisitor<'a> {\n     // Generated maps:\n     region_maps: &'a RegionMaps,\n \n-    cx: Context\n+    cx: Context,\n+\n+    /// `terminating_scopes` is a set containing the ids of each\n+    /// statement, or conditional/repeating expression. These scopes\n+    /// are calling \"terminating scopes\" because, when attempting to\n+    /// find the scope of a temporary, by default we search up the\n+    /// enclosing scopes until we encounter the terminating scope. A\n+    /// conditional/repeating expression is one which is not\n+    /// guaranteed to execute exactly once upon entering the parent\n+    /// scope. This could be because the expression only executes\n+    /// conditionally, such as the expression `b` in `a && b`, or\n+    /// because the expression may execute many times, such as a loop\n+    /// body. The reason that we distinguish such expressions is that,\n+    /// upon exiting the parent scope, we cannot statically know how\n+    /// many times the expression executed, and thus if the expression\n+    /// creates temporaries we cannot know statically how many such\n+    /// temporaries we would have to cleanup. Therefore we ensure that\n+    /// the temporaries never outlast the conditional/repeating\n+    /// expression, preventing the need for dynamic checks and/or\n+    /// arbitrary amounts of stack space. Terminating scopes end\n+    /// up being contained in a DestructionScope that contains the\n+    /// destructor's execution.\n+    terminating_scopes: NodeSet\n }\n \n \n impl RegionMaps {\n+    /// create a bogus code extent for the regions in astencode types. Nobody\n+    /// really cares about the contents of these.\n+    pub fn bogus_code_extent(&self, e: CodeExtentData) -> CodeExtent {\n+        self.intern_code_extent(e, DUMMY_CODE_EXTENT)\n+    }\n+    pub fn lookup_code_extent(&self, e: CodeExtentData) -> CodeExtent {\n+        self.code_extent_interner.borrow()[&e]\n+    }\n+    pub fn node_extent(&self, n: ast::NodeId) -> CodeExtent {\n+        self.lookup_code_extent(CodeExtentData::Misc(n))\n+    }\n+    // Returns the code extent for an item - the destruction scope.\n+    pub fn item_extent(&self, n: ast::NodeId) -> CodeExtent {\n+        self.lookup_code_extent(CodeExtentData::DestructionScope(n))\n+    }\n+    pub fn intern_code_extent(&self,\n+                              e: CodeExtentData,\n+                              parent: CodeExtent) -> CodeExtent {\n+        match self.code_extent_interner.borrow_mut().entry(e) {\n+            Entry::Occupied(o) => {\n+                // this can happen when the bogus code extents from tydecode\n+                // have (bogus) NodeId-s that overlap items created during\n+                // inlining.\n+                // We probably shouldn't be creating bogus code extents\n+                // though.\n+                let idx = *o.get();\n+                if parent == DUMMY_CODE_EXTENT {\n+                    info!(\"CodeExtent({}) = {:?} [parent={}] BOGUS!\",\n+                          idx.0, e, parent.0);\n+                } else {\n+                    assert_eq!(self.scope_map.borrow()[idx.0 as usize],\n+                               DUMMY_CODE_EXTENT);\n+                    info!(\"CodeExtent({}) = {:?} [parent={}] RECLAIMED!\",\n+                          idx.0, e, parent.0);\n+                    self.scope_map.borrow_mut()[idx.0 as usize] = parent;\n+                }\n+                idx\n+            }\n+            Entry::Vacant(v) => {\n+                if self.code_extents.borrow().len() > 0xffffffffusize {\n+                    unreachable!() // should pass a sess,\n+                                   // but this isn't the only place\n+                }\n+                let idx = CodeExtent(self.code_extents.borrow().len() as u32);\n+                info!(\"CodeExtent({}) = {:?} [parent={}]\", idx.0, e, parent.0);\n+                self.code_extents.borrow_mut().push(e);\n+                self.scope_map.borrow_mut().push(parent);\n+                *v.insert(idx)\n+            }\n+        }\n+    }\n+    pub fn intern_node(&self,\n+                       n: ast::NodeId,\n+                       parent: CodeExtent) -> CodeExtent {\n+        self.intern_code_extent(CodeExtentData::Misc(n), parent)\n+    }\n+    pub fn code_extent_data(&self, e: CodeExtent) -> CodeExtentData {\n+        self.code_extents.borrow()[e.0 as usize]\n+    }\n     pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(&CodeExtent, &CodeExtent) {\n-        for (child, parent) in self.scope_map.borrow().iter() {\n-            e(child, parent)\n+        for child_id in (1..self.code_extents.borrow().len()) {\n+            let child = CodeExtent(child_id as u32);\n+            if let Some(parent) = self.opt_encl_scope(child) {\n+                e(&child, &parent)\n+            }\n         }\n     }\n     pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, &CodeExtent) {\n@@ -387,12 +386,6 @@ impl RegionMaps {\n             e(child, parent)\n         }\n     }\n-    pub fn each_terminating_scope<E>(&self, mut e:E) where E: FnMut(&CodeExtent) {\n-        for scope in self.terminating_scopes.borrow().iter() {\n-            e(scope)\n-        }\n-    }\n-\n     /// Records that `sub_fn` is defined within `sup_fn`. These ids\n     /// should be the id of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n@@ -414,44 +407,27 @@ impl RegionMaps {\n         }\n     }\n \n-    pub fn record_encl_scope(&self, sub: CodeExtent, sup: CodeExtent) {\n-        debug!(\"record_encl_scope(sub={:?}, sup={:?})\", sub, sup);\n-        assert!(sub != sup);\n-        self.scope_map.borrow_mut().insert(sub, sup);\n-    }\n-\n     fn record_var_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id());\n+        assert!(var != lifetime.node_id(self));\n         self.var_map.borrow_mut().insert(var, lifetime);\n     }\n \n     fn record_rvalue_scope(&self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id());\n+        assert!(var != lifetime.node_id(self));\n         self.rvalue_scopes.borrow_mut().insert(var, lifetime);\n     }\n \n-    /// Records that a scope is a TERMINATING SCOPE. Whenever we create automatic temporaries --\n-    /// e.g. by an expression like `a().f` -- they will be freed within the innermost terminating\n-    /// scope.\n-    fn mark_as_terminating_scope(&self, scope_id: CodeExtent) {\n-        debug!(\"record_terminating_scope(scope_id={:?})\", scope_id);\n-        self.terminating_scopes.borrow_mut().insert(scope_id);\n-    }\n-\n     pub fn opt_encl_scope(&self, id: CodeExtent) -> Option<CodeExtent> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        self.scope_map.borrow().get(&id).cloned()\n+        self.scope_map.borrow()[id.0 as usize].into_option()\n     }\n \n     #[allow(dead_code)] // used in middle::cfg\n     pub fn encl_scope(&self, id: CodeExtent) -> CodeExtent {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        match self.scope_map.borrow().get(&id) {\n-            Some(&r) => r,\n-            None => { panic!(\"no enclosing scope for id {:?}\", id); }\n-        }\n+        self.opt_encl_scope(id).unwrap()\n     }\n \n     /// Returns the lifetime of the local variable `var_id`\n@@ -474,28 +450,33 @@ impl RegionMaps {\n             None => { }\n         }\n \n+        let scope_map : &[CodeExtent] = &self.scope_map.borrow();\n+        let code_extents: &[CodeExtentData] = &self.code_extents.borrow();\n+\n         // else, locate the innermost terminating scope\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n-        let mut id = match self.opt_encl_scope(CodeExtent::from_node_id(expr_id)) {\n+        let expr_extent = self.node_extent(expr_id);\n+        // For some reason, the expr's scope itself is skipped here.\n+        let mut id = match scope_map[expr_extent.0 as usize].into_option() {\n             Some(i) => i,\n-            None => { return None; }\n+            _ => return None\n         };\n \n-        while !self.terminating_scopes.borrow().contains(&id) {\n-            match self.opt_encl_scope(id) {\n-                Some(p) => {\n-                    id = p;\n-                }\n-                None => {\n-                    debug!(\"temporary_scope({:?}) = None\", expr_id);\n-                    return None;\n+        while let Some(p) = scope_map[id.0 as usize].into_option() {\n+            match code_extents[p.0 as usize] {\n+                CodeExtentData::DestructionScope(..) => {\n+                    debug!(\"temporary_scope({:?}) = {:?} [enclosing]\",\n+                           expr_id, id);\n+                    return Some(id);\n                 }\n+                _ => id = p\n             }\n         }\n-        debug!(\"temporary_scope({:?}) = {:?} [enclosing]\", expr_id, id);\n-        return Some(id);\n+\n+        debug!(\"temporary_scope({:?}) = None\", expr_id);\n+        return None;\n     }\n \n     pub fn var_region(&self, id: ast::NodeId) -> ty::Region {\n@@ -519,15 +500,15 @@ impl RegionMaps {\n                           superscope: CodeExtent)\n                           -> bool {\n         let mut s = subscope;\n+        debug!(\"is_subscope_of({:?}, {:?})\", subscope, superscope);\n         while superscope != s {\n-            match self.scope_map.borrow().get(&s) {\n+            match self.opt_encl_scope(s) {\n                 None => {\n                     debug!(\"is_subscope_of({:?}, {:?}, s={:?})=false\",\n                            subscope, superscope, s);\n-\n                     return false;\n                 }\n-                Some(&scope) => s = scope\n+                Some(scope) => s = scope\n             }\n         }\n \n@@ -545,8 +526,15 @@ impl RegionMaps {\n                                    -> CodeExtent {\n         if scope_a == scope_b { return scope_a; }\n \n-        let a_ancestors = ancestors_of(self, scope_a);\n-        let b_ancestors = ancestors_of(self, scope_b);\n+        let mut a_buf: [CodeExtent; 32] = [ROOT_CODE_EXTENT; 32];\n+        let mut a_vec: Vec<CodeExtent> = vec![];\n+        let mut b_buf: [CodeExtent; 32] = [ROOT_CODE_EXTENT; 32];\n+        let mut b_vec: Vec<CodeExtent> = vec![];\n+        let scope_map : &[CodeExtent] = &self.scope_map.borrow();\n+        let a_ancestors = ancestors_of(scope_map,\n+                                       scope_a, &mut a_buf, &mut a_vec);\n+        let b_ancestors = ancestors_of(scope_map,\n+                                       scope_b, &mut b_buf, &mut b_vec);\n         let mut a_index = a_ancestors.len() - 1;\n         let mut b_index = b_ancestors.len() - 1;\n \n@@ -564,11 +552,11 @@ impl RegionMaps {\n             // nesting. The reasoning behind this is subtle.  See the\n             // \"Modeling closures\" section of the README in\n             // middle::infer::region_inference for more details.\n-            let a_root_scope = a_ancestors[a_index];\n-            let b_root_scope = a_ancestors[a_index];\n+            let a_root_scope = self.code_extent_data(a_ancestors[a_index]);\n+            let b_root_scope = self.code_extent_data(a_ancestors[a_index]);\n             return match (a_root_scope, b_root_scope) {\n-                (CodeExtent::DestructionScope(a_root_id),\n-                 CodeExtent::DestructionScope(b_root_id)) => {\n+                (CodeExtentData::DestructionScope(a_root_id),\n+                 CodeExtentData::DestructionScope(b_root_id)) => {\n                     if self.fn_is_enclosed_by(a_root_id, b_root_id) {\n                         // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n                         scope_b\n@@ -599,69 +587,56 @@ impl RegionMaps {\n             }\n         }\n \n-        fn ancestors_of(this: &RegionMaps, scope: CodeExtent) -> Vec<CodeExtent> {\n+        fn ancestors_of<'a>(scope_map: &[CodeExtent],\n+                            scope: CodeExtent,\n+                            buf: &'a mut [CodeExtent; 32],\n+                            vec: &'a mut Vec<CodeExtent>) -> &'a [CodeExtent] {\n             // debug!(\"ancestors_of(scope={:?})\", scope);\n-            let mut result = vec!(scope);\n             let mut scope = scope;\n+\n+            let mut i = 0;\n+            while i < 32 {\n+                buf[i] = scope;\n+                match scope_map[scope.0 as usize].into_option() {\n+                    Some(superscope) => scope = superscope,\n+                    _ => return &buf[..i+1]\n+                }\n+                i += 1;\n+            }\n+\n+            *vec = Vec::with_capacity(64);\n+            vec.push_all(buf);\n             loop {\n-                match this.scope_map.borrow().get(&scope) {\n-                    None => return result,\n-                    Some(&superscope) => {\n-                        result.push(superscope);\n-                        scope = superscope;\n-                    }\n+                vec.push(scope);\n+                match scope_map[scope.0 as usize].into_option() {\n+                    Some(superscope) => scope = superscope,\n+                    _ => return &*vec\n                 }\n-                // debug!(\"ancestors_of_loop(scope={:?})\", scope);\n             }\n         }\n     }\n }\n \n-/// Records the current parent (if any) as the parent of `child_scope`.\n-fn record_superlifetime(visitor: &mut RegionResolutionVisitor,\n-                        child_scope: CodeExtent,\n-                        _sp: Span) {\n-    match visitor.cx.parent.to_code_extent() {\n-        Some(parent_scope) =>\n-            visitor.region_maps.record_encl_scope(child_scope, parent_scope),\n-        None => {}\n-    }\n-}\n-\n /// Records the lifetime of a local variable as `cx.var_parent`\n fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n                        var_id: ast::NodeId,\n                        _sp: Span) {\n-    match visitor.cx.var_parent.to_code_extent() {\n-        Some(parent_scope) =>\n-            visitor.region_maps.record_var_scope(var_id, parent_scope),\n-        None => {\n+    match visitor.cx.var_parent {\n+        ROOT_CODE_EXTENT => {\n             // this can happen in extern fn declarations like\n             //\n             // extern fn isalnum(c: c_int) -> c_int\n         }\n+        parent_scope =>\n+            visitor.region_maps.record_var_scope(var_id, parent_scope),\n     }\n }\n \n fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n     debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n     let prev_cx = visitor.cx;\n-\n-    let blk_scope = CodeExtent::Misc(blk.id);\n-\n-    // If block was previously marked as a terminating scope during\n-    // the recursive visit of its parent node in the AST, then we need\n-    // to account for the destruction scope representing the extent of\n-    // the destructors that run immediately after the the block itself\n-    // completes.\n-    if visitor.region_maps.terminating_scopes.borrow().contains(&blk_scope) {\n-        let dtor_scope = CodeExtent::DestructionScope(blk.id);\n-        record_superlifetime(visitor, dtor_scope, blk.span);\n-        visitor.region_maps.record_encl_scope(blk_scope, dtor_scope);\n-    } else {\n-        record_superlifetime(visitor, blk_scope, blk.span);\n-    }\n+    let block_extent = visitor.new_node_extent_with_dtor(blk.id);\n \n     // We treat the tail expression in the block (if any) somewhat\n     // differently from the statements. The issue has to do with\n@@ -690,35 +665,34 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n \n     visitor.cx = Context {\n         root_id: prev_cx.root_id,\n-        var_parent: InnermostDeclaringBlock::Block(blk.id),\n-        parent: InnermostEnclosingExpr::Some(blk.id),\n+        var_parent: block_extent,\n+        parent: block_extent,\n     };\n \n     {\n         // This block should be kept approximately in sync with\n         // `visit::walk_block`. (We manually walk the block, rather\n         // than call `walk_block`, in order to maintain precise\n-        // `InnermostDeclaringBlock` information.)\n+        // index information.)\n \n         for (i, statement) in blk.stmts.iter().enumerate() {\n-            if let ast::StmtDecl(_, stmt_id) = statement.node {\n+            if let ast::StmtDecl(..) = statement.node {\n                 // Each StmtDecl introduces a subscope for bindings\n                 // introduced by the declaration; this subscope covers\n                 // a suffix of the block . Each subscope in a block\n                 // has the previous subscope in the block as a parent,\n                 // except for the first such subscope, which has the\n                 // block itself as a parent.\n-                let declaring = DeclaringStatementContext {\n-                    stmt_id: stmt_id,\n-                    block_id: blk.id,\n-                    stmt_index: i,\n-                };\n-                record_superlifetime(\n-                    visitor, declaring.to_code_extent(), statement.span);\n+                let stmt_extent = visitor.new_code_extent(\n+                    CodeExtentData::Remainder(BlockRemainder {\n+                        block: blk.id,\n+                        first_statement_index: i as u32\n+                    })\n+                );\n                 visitor.cx = Context {\n                     root_id: prev_cx.root_id,\n-                    var_parent: InnermostDeclaringBlock::Statement(declaring),\n-                    parent: InnermostEnclosingExpr::Statement(declaring),\n+                    var_parent: stmt_extent,\n+                    parent: stmt_extent,\n                 };\n             }\n             visitor.visit_stmt(&**statement)\n@@ -730,22 +704,17 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n }\n \n fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &ast::Arm) {\n-    let arm_body_scope = CodeExtent::from_node_id(arm.body.id);\n-    visitor.region_maps.mark_as_terminating_scope(arm_body_scope);\n+    visitor.terminating_scopes.insert(arm.body.id);\n \n-    match arm.guard {\n-        Some(ref expr) => {\n-            let guard_scope = CodeExtent::from_node_id(expr.id);\n-            visitor.region_maps.mark_as_terminating_scope(guard_scope);\n-        }\n-        None => { }\n+    if let Some(ref expr) = arm.guard {\n+        visitor.terminating_scopes.insert(expr.id);\n     }\n \n     visit::walk_arm(visitor, arm);\n }\n \n fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &ast::Pat) {\n-    record_superlifetime(visitor, CodeExtent::from_node_id(pat.id), pat.span);\n+    visitor.new_node_extent(pat.id);\n \n     // If this is a binding (or maybe a binding, I'm too lazy to check\n     // the def map) then record the lifetime of that binding.\n@@ -763,53 +732,31 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &ast::Stmt) {\n     let stmt_id = stmt_id(stmt);\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n-    let stmt_scope = CodeExtent::from_node_id(stmt_id);\n-\n     // Every statement will clean up the temporaries created during\n     // execution of that statement. Therefore each statement has an\n     // associated destruction scope that represents the extent of the\n     // statement plus its destructors, and thus the extent for which\n     // regions referenced by the destructors need to survive.\n-    visitor.region_maps.mark_as_terminating_scope(stmt_scope);\n-    let dtor_scope = CodeExtent::DestructionScope(stmt_id);\n-    visitor.region_maps.record_encl_scope(stmt_scope, dtor_scope);\n-    record_superlifetime(visitor, dtor_scope, stmt.span);\n+    visitor.terminating_scopes.insert(stmt_id);\n+    let stmt_extent = visitor.new_node_extent_with_dtor(stmt_id);\n \n     let prev_parent = visitor.cx.parent;\n-    visitor.cx.parent = InnermostEnclosingExpr::Some(stmt_id);\n+    visitor.cx.parent = stmt_extent;\n     visit::walk_stmt(visitor, stmt);\n     visitor.cx.parent = prev_parent;\n }\n \n fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n-    let expr_scope = CodeExtent::Misc(expr.id);\n-    // If expr was previously marked as a terminating scope during the\n-    // recursive visit of its parent node in the AST, then we need to\n-    // account for the destruction scope representing the extent of\n-    // the destructors that run immediately after the the expression\n-    // itself completes.\n-    if visitor.region_maps.terminating_scopes.borrow().contains(&expr_scope) {\n-        let dtor_scope = CodeExtent::DestructionScope(expr.id);\n-        record_superlifetime(visitor, dtor_scope, expr.span);\n-        visitor.region_maps.record_encl_scope(expr_scope, dtor_scope);\n-    } else {\n-        record_superlifetime(visitor, expr_scope, expr.span);\n-    }\n-\n+    let expr_extent = visitor.new_node_extent_with_dtor(expr.id);\n     let prev_cx = visitor.cx;\n-    visitor.cx.parent = InnermostEnclosingExpr::Some(expr.id);\n+    visitor.cx.parent = expr_extent;\n \n     {\n-        let region_maps = &mut visitor.region_maps;\n-        let terminating = |e: &P<ast::Expr>| {\n-            let scope = CodeExtent::from_node_id(e.id);\n-            region_maps.mark_as_terminating_scope(scope)\n-        };\n-        let terminating_block = |b: &P<ast::Block>| {\n-            let scope = CodeExtent::from_node_id(b.id);\n-            region_maps.mark_as_terminating_scope(scope)\n+        let terminating_scopes = &mut visitor.terminating_scopes;\n+        let mut terminating = |id: ast::NodeId| {\n+            terminating_scopes.insert(id);\n         };\n         match expr.node {\n             // Conditional or repeating scopes are always terminating\n@@ -820,30 +767,30 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n             ast::ExprBinary(codemap::Spanned { node: ast::BiOr, .. }, _, ref r) => {\n                 // For shortcircuiting operators, mark the RHS as a terminating\n                 // scope since it only executes conditionally.\n-                terminating(r);\n+                terminating(r.id);\n             }\n \n             ast::ExprIf(_, ref then, Some(ref otherwise)) => {\n-                terminating_block(then);\n-                terminating(otherwise);\n+                terminating(then.id);\n+                terminating(otherwise.id);\n             }\n \n             ast::ExprIf(ref expr, ref then, None) => {\n-                terminating(expr);\n-                terminating_block(then);\n+                terminating(expr.id);\n+                terminating(then.id);\n             }\n \n             ast::ExprLoop(ref body, _) => {\n-                terminating_block(body);\n+                terminating(body.id);\n             }\n \n             ast::ExprWhile(ref expr, ref body, _) => {\n-                terminating(expr);\n-                terminating_block(body);\n+                terminating(expr.id);\n+                terminating(body.id);\n             }\n \n             ast::ExprMatch(..) => {\n-                visitor.cx.var_parent = InnermostDeclaringBlock::Match(expr.id);\n+                visitor.cx.var_parent = expr_extent;\n             }\n \n             ast::ExprAssignOp(..) | ast::ExprIndex(..) |\n@@ -883,10 +830,8 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     // For convenience in trans, associate with the local-id the var\n     // scope that will be used for any bindings declared in this\n     // pattern.\n-    let blk_scope = visitor.cx.var_parent.to_code_extent()\n-        .unwrap_or_else(|| visitor.sess.span_bug(\n-            local.span, \"local without enclosing block\"));\n-\n+    let blk_scope = visitor.cx.var_parent;\n+    assert!(blk_scope != ROOT_CODE_EXTENT); // locals must be within a block\n     visitor.region_maps.record_var_scope(local.id, blk_scope);\n \n     // As an exception to the normal rules governing temporary\n@@ -1109,13 +1054,16 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &ast::Item) {\n     // Items create a new outer block scope as far as we're concerned.\n     let prev_cx = visitor.cx;\n+    let prev_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n     visitor.cx = Context {\n         root_id: None,\n-        var_parent: InnermostDeclaringBlock::None,\n-        parent: InnermostEnclosingExpr::None\n+        var_parent: ROOT_CODE_EXTENT,\n+        parent: ROOT_CODE_EXTENT\n     };\n     visit::walk_item(visitor, item);\n+    visitor.create_item_scope_if_needed(item.id);\n     visitor.cx = prev_cx;\n+    visitor.terminating_scopes = prev_ts;\n }\n \n fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n@@ -1133,51 +1081,76 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n            body.id,\n            visitor.cx.parent);\n \n-    // This scope covers the function body, which includes the\n-    // bindings introduced by let statements as well as temporaries\n-    // created by the fn's tail expression (if any). It does *not*\n-    // include the fn parameters (see below).\n-    let body_scope = CodeExtent::from_node_id(body.id);\n-    visitor.region_maps.mark_as_terminating_scope(body_scope);\n-\n-    let dtor_scope = CodeExtent::DestructionScope(body.id);\n-    visitor.region_maps.record_encl_scope(body_scope, dtor_scope);\n-\n-    let fn_decl_scope = CodeExtent::ParameterScope { fn_id: id, body_id: body.id };\n-    visitor.region_maps.record_encl_scope(dtor_scope, fn_decl_scope);\n-\n-    record_superlifetime(visitor, fn_decl_scope, body.span);\n+    let fn_decl_scope = visitor.new_code_extent(\n+        CodeExtentData::ParameterScope { fn_id: id, body_id: body.id });\n \n     if let Some(root_id) = visitor.cx.root_id {\n         visitor.region_maps.record_fn_parent(body.id, root_id);\n     }\n \n     let outer_cx = visitor.cx;\n+    let outer_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n+    visitor.terminating_scopes.insert(body.id);\n \n     // The arguments and `self` are parented to the fn.\n     visitor.cx = Context {\n         root_id: Some(body.id),\n-        parent: InnermostEnclosingExpr::None,\n-        var_parent: InnermostDeclaringBlock::FnDecl {\n-            fn_id: id, body_id: body.id\n-        },\n+        parent: ROOT_CODE_EXTENT,\n+        var_parent: fn_decl_scope,\n     };\n+\n     visit::walk_fn_decl(visitor, decl);\n \n     // The body of the every fn is a root scope.\n     visitor.cx = Context {\n         root_id: Some(body.id),\n-        parent: InnermostEnclosingExpr::None,\n-        var_parent: InnermostDeclaringBlock::None\n+        parent: fn_decl_scope,\n+        var_parent: fn_decl_scope\n     };\n     visitor.visit_block(body);\n \n     // Restore context we had at the start.\n     visitor.cx = outer_cx;\n+    visitor.terminating_scopes = outer_ts;\n }\n \n-impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n+impl<'a> RegionResolutionVisitor<'a> {\n+    /// Records the current parent (if any) as the parent of `child_scope`.\n+    fn new_code_extent(&mut self, child_scope: CodeExtentData) -> CodeExtent {\n+        self.region_maps.intern_code_extent(child_scope, self.cx.parent)\n+    }\n \n+    fn new_node_extent(&mut self, child_scope: ast::NodeId) -> CodeExtent {\n+        self.new_code_extent(CodeExtentData::Misc(child_scope))\n+    }\n+\n+    fn new_node_extent_with_dtor(&mut self, id: ast::NodeId) -> CodeExtent {\n+        // If node was previously marked as a terminating scope during the\n+        // recursive visit of its parent node in the AST, then we need to\n+        // account for the destruction scope representing the extent of\n+        // the destructors that run immediately after it completes.\n+        if self.terminating_scopes.contains(&id) {\n+            let ds = self.new_code_extent(\n+                CodeExtentData::DestructionScope(id));\n+            self.region_maps.intern_node(id, ds)\n+        } else {\n+            self.new_node_extent(id)\n+        }\n+    }\n+\n+    fn create_item_scope_if_needed(&mut self, id: ast::NodeId) {\n+        // create a region for the destruction scope - this is needed\n+        // for constructing parameter environments based on the item.\n+        // functions put their destruction scopes *inside* their parameter\n+        // scopes.\n+        let scope = CodeExtentData::DestructionScope(id);\n+        if !self.region_maps.code_extent_interner.borrow().contains_key(&scope) {\n+            self.region_maps.intern_code_extent(scope, ROOT_CODE_EXTENT);\n+        }\n+    }\n+}\n+\n+impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n     fn visit_block(&mut self, b: &Block) {\n         resolve_block(self, b);\n     }\n@@ -1186,6 +1159,16 @@ impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n         resolve_item(self, i);\n     }\n \n+    fn visit_impl_item(&mut self, ii: &ast::ImplItem) {\n+        visit::walk_impl_item(self, ii);\n+        self.create_item_scope_if_needed(ii.id);\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n+        visit::walk_trait_item(self, ti);\n+        self.create_item_scope_if_needed(ti.id);\n+    }\n+\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n                 b: &'v Block, s: Span, n: NodeId) {\n         resolve_fn(self, fk, fd, b, s, n);\n@@ -1209,21 +1192,29 @@ impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n \n pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n     let maps = RegionMaps {\n-        scope_map: RefCell::new(FnvHashMap()),\n+        code_extents: RefCell::new(vec![]),\n+        code_extent_interner: RefCell::new(FnvHashMap()),\n+        scope_map: RefCell::new(vec![]),\n         var_map: RefCell::new(NodeMap()),\n         rvalue_scopes: RefCell::new(NodeMap()),\n-        terminating_scopes: RefCell::new(FnvHashSet()),\n         fn_tree: RefCell::new(NodeMap()),\n     };\n+    let root_extent = maps.bogus_code_extent(\n+        CodeExtentData::DestructionScope(ast::DUMMY_NODE_ID));\n+    assert_eq!(root_extent, ROOT_CODE_EXTENT);\n+    let bogus_extent = maps.bogus_code_extent(\n+        CodeExtentData::Misc(ast::DUMMY_NODE_ID));\n+    assert_eq!(bogus_extent, DUMMY_CODE_EXTENT);\n     {\n         let mut visitor = RegionResolutionVisitor {\n             sess: sess,\n             region_maps: &maps,\n             cx: Context {\n                 root_id: None,\n-                parent: InnermostEnclosingExpr::None,\n-                var_parent: InnermostDeclaringBlock::None,\n-            }\n+                parent: ROOT_CODE_EXTENT,\n+                var_parent: ROOT_CODE_EXTENT\n+            },\n+            terminating_scopes: NodeSet()\n         };\n         visit::walk_crate(&mut visitor, krate);\n     }\n@@ -1238,9 +1229,10 @@ pub fn resolve_inlined_item(sess: &Session,\n         region_maps: region_maps,\n         cx: Context {\n             root_id: None,\n-            parent: InnermostEnclosingExpr::None,\n-            var_parent: InnermostDeclaringBlock::None\n-        }\n+            parent: ROOT_CODE_EXTENT,\n+            var_parent: ROOT_CODE_EXTENT\n+        },\n+        terminating_scopes: NodeSet()\n     };\n     item.visit(&mut visitor);\n }"}, {"sha": "eff560653c140ff226f0e6da440a649463efb708", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 40, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -12,7 +12,6 @@\n #![allow(non_camel_case_types)]\n \n pub use self::InferTy::*;\n-pub use self::InferRegion::*;\n pub use self::ImplOrTraitItemId::*;\n pub use self::ClosureKind::*;\n pub use self::Variance::*;\n@@ -1504,7 +1503,7 @@ pub struct DebruijnIndex {\n }\n \n /// Representation of regions:\n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, Copy)]\n pub enum Region {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n@@ -1529,7 +1528,11 @@ pub enum Region {\n     ReStatic,\n \n     /// A region variable.  Should not exist after typeck.\n-    ReInfer(InferRegion),\n+    ReVar(RegionVid),\n+\n+    /// A skolemized region - basically the higher-ranked version of ReFree.\n+    /// Should not exist after typeck.\n+    ReSkolemized(u32, BoundRegion),\n \n     /// Empty lifetime is for data that is never accessed.\n     /// Bottom in the region lattice. We treat ReEmpty somewhat\n@@ -1606,7 +1609,7 @@ pub enum BorrowKind {\n \n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n-#[derive(PartialEq, Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(PartialEq, Clone, Debug, Copy)]\n pub enum UpvarCapture {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n@@ -1617,7 +1620,7 @@ pub enum UpvarCapture {\n     ByRef(UpvarBorrow),\n }\n \n-#[derive(PartialEq, Clone, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(PartialEq, Clone, Copy)]\n pub struct UpvarBorrow {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n@@ -1648,7 +1651,7 @@ impl Region {\n \n     pub fn needs_infer(&self) -> bool {\n         match *self {\n-            ty::ReInfer(..) => true,\n+            ty::ReVar(..) | ty::ReSkolemized(..) => true,\n             _ => false\n         }\n     }\n@@ -1676,7 +1679,7 @@ impl Region {\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n pub struct FreeRegion {\n-    pub scope: region::DestructionScopeData,\n+    pub scope: region::CodeExtent,\n     pub bound_region: BoundRegion\n }\n \n@@ -2187,29 +2190,6 @@ pub enum UnconstrainedNumeric {\n }\n \n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Eq, Hash, Debug, Copy)]\n-pub enum InferRegion {\n-    ReVar(RegionVid),\n-    ReSkolemized(u32, BoundRegion)\n-}\n-\n-impl cmp::PartialEq for InferRegion {\n-    fn eq(&self, other: &InferRegion) -> bool {\n-        match ((*self), *other) {\n-            (ReVar(rva), ReVar(rvb)) => {\n-                rva == rvb\n-            }\n-            (ReSkolemized(rva, _), ReSkolemized(rvb, _)) => {\n-                rva == rvb\n-            }\n-            _ => false\n-        }\n-    }\n-    fn ne(&self, other: &InferRegion) -> bool {\n-        !((*self) == (*other))\n-    }\n-}\n-\n impl fmt::Debug for TyVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"_#{}t\", self.index)\n@@ -2291,7 +2271,7 @@ pub struct TypeParameterDef<'tcx> {\n     pub object_lifetime_default: ObjectLifetimeDefault,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Clone, Debug)]\n+#[derive(Clone, Debug)]\n pub struct RegionParameterDef {\n     pub name: ast::Name,\n     pub def_id: DefId,\n@@ -3722,7 +3702,8 @@ impl FlagComputation {\n \n     fn add_region(&mut self, r: Region) {\n         match r {\n-            ty::ReInfer(_) => { self.add_flags(TypeFlags::HAS_RE_INFER); }\n+            ty::ReVar(..) |\n+            ty::ReSkolemized(..) => { self.add_flags(TypeFlags::HAS_RE_INFER); }\n             ty::ReLateBound(debruijn, _) => { self.add_depth(debruijn.depth); }\n             ty::ReEarlyBound(..) => { self.add_flags(TypeFlags::HAS_RE_EARLY_BOUND); }\n             ty::ReStatic => {}\n@@ -5728,7 +5709,7 @@ impl<'tcx> ctxt<'tcx> {\n                 self.note_and_explain_region(\"concrete lifetime that was found is \",\n                                            conc_region, \"\");\n             }\n-            RegionsOverlyPolymorphic(_, ty::ReInfer(ty::ReVar(_))) => {\n+            RegionsOverlyPolymorphic(_, ty::ReVar(_)) => {\n                 // don't bother to print out the message below for\n                 // inference variables, it's not very illuminating.\n             }\n@@ -6479,7 +6460,8 @@ impl<'tcx> ctxt<'tcx> {\n                     ReLateBound(..) |\n                     ReFree(..) |\n                     ReScope(..) |\n-                    ReInfer(..) => {\n+                    ReVar(..) |\n+                    ReSkolemized(..) => {\n                         tcx.sess.bug(\"unexpected region found when hashing a type\")\n                     }\n                 }\n@@ -6628,7 +6610,7 @@ impl<'tcx> ctxt<'tcx> {\n             types.push(def.space, self.mk_param_from_def(def));\n         }\n \n-        let free_id_outlive = region::DestructionScopeData::new(free_id);\n+        let free_id_outlive = self.region_maps.item_extent(free_id);\n \n         // map bound 'a => free 'a\n         let mut regions = VecPerParamSpace::empty();\n@@ -6659,7 +6641,7 @@ impl<'tcx> ctxt<'tcx> {\n         //\n \n         let free_substs = self.construct_free_substs(generics, free_id);\n-        let free_id_outlive = region::DestructionScopeData::new(free_id);\n+        let free_id_outlive = self.region_maps.item_extent(free_id);\n \n         //\n         // Compute the bounds on Self and the type parameters.\n@@ -6691,7 +6673,7 @@ impl<'tcx> ctxt<'tcx> {\n         let unnormalized_env = ty::ParameterEnvironment {\n             tcx: self,\n             free_substs: free_substs,\n-            implicit_region_bound: ty::ReScope(free_id_outlive.to_code_extent()),\n+            implicit_region_bound: ty::ReScope(free_id_outlive),\n             caller_bounds: predicates,\n             selection_cache: traits::SelectionCache::new(),\n             free_id: free_id,\n@@ -6855,7 +6837,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// Replace any late-bound regions bound in `value` with free variants attached to scope-id\n     /// `scope_id`.\n     pub fn liberate_late_bound_regions<T>(&self,\n-        all_outlive_scope: region::DestructionScopeData,\n+        all_outlive_scope: region::CodeExtent,\n         value: &Binder<T>)\n         -> T\n         where T : TypeFoldable<'tcx>\n@@ -7338,8 +7320,9 @@ impl HasTypeFlags for Region {\n             }\n         }\n         if flags.intersects(TypeFlags::HAS_RE_INFER) {\n-            if let ty::ReInfer(_) = *self {\n-                return true;\n+            match *self {\n+                ty::ReVar(_) | ty::ReSkolemized(..) => { return true }\n+                _ => {}\n             }\n         }\n         false"}, {"sha": "48c2e1e6dca7ae00b4a8cf90284f803e159c5074", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -13,7 +13,7 @@ use middle::def_id::DefId;\n use middle::subst::{self, Subst};\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n use middle::ty::{ReEarlyBound, BrFresh, ctxt};\n-use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region, ReEmpty};\n+use middle::ty::{ReFree, ReScope, ReStatic, Region, ReEmpty};\n use middle::ty::{ReSkolemized, ReVar, BrEnv};\n use middle::ty::{TyBool, TyChar, TyStruct, TyEnum};\n use middle::ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyBareFn};\n@@ -413,11 +413,11 @@ impl fmt::Debug for ty::Region {\n \n             ty::ReStatic => write!(f, \"ReStatic\"),\n \n-            ty::ReInfer(ReVar(ref vid)) => {\n+            ty::ReVar(ref vid) => {\n                 write!(f, \"{:?}\", vid)\n             }\n \n-            ty::ReInfer(ReSkolemized(id, ref bound_region)) => {\n+            ty::ReSkolemized(id, ref bound_region) => {\n                 write!(f, \"ReSkolemized({}, {:?})\", id, bound_region)\n             }\n \n@@ -442,11 +442,11 @@ impl fmt::Display for ty::Region {\n             }\n             ty::ReLateBound(_, br) |\n             ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-            ty::ReInfer(ReSkolemized(_, br)) => {\n+            ty::ReSkolemized(_, br) => {\n                 write!(f, \"{}\", br)\n             }\n             ty::ReScope(_) |\n-            ty::ReInfer(ReVar(_)) => Ok(()),\n+            ty::ReVar(_) => Ok(()),\n             ty::ReStatic => write!(f, \"'static\"),\n             ty::ReEmpty => write!(f, \"'<empty>\"),\n         }"}, {"sha": "3e3ce5c7be00211889e58d3b818f8bd4a7226b8e", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n             None => { }\n         }\n \n-        self.check_for_conflicting_loans(region::CodeExtent::from_node_id(borrow_id));\n+        self.check_for_conflicting_loans(borrow_id);\n     }\n \n     fn mutate(&mut self,\n@@ -230,16 +230,16 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.bccx.tcx }\n \n-    pub fn each_issued_loan<F>(&self, scope: region::CodeExtent, mut op: F) -> bool where\n+    pub fn each_issued_loan<F>(&self, node: ast::NodeId, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,\n     {\n         //! Iterates over each loan that has been issued\n-        //! on entrance to `scope`, regardless of whether it is\n+        //! on entrance to `node`, regardless of whether it is\n         //! actually *in scope* at that point.  Sometimes loans\n         //! are issued for future scopes and thus they may have been\n         //! *issued* but not yet be in effect.\n \n-        self.dfcx_loans.each_bit_on_entry(scope.node_id(), |loan_index| {\n+        self.dfcx_loans.each_bit_on_entry(node, |loan_index| {\n             let loan = &self.all_loans[loan_index];\n             op(loan)\n         })\n@@ -252,7 +252,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! currently in scope.\n \n         let tcx = self.tcx();\n-        self.each_issued_loan(scope, |loan| {\n+        self.each_issued_loan(scope.node_id(&tcx.region_maps), |loan| {\n             if tcx.region_maps.is_subscope_of(scope, loan.kill_scope) {\n                 op(loan)\n             } else {\n@@ -336,33 +336,33 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         return true;\n     }\n \n-    pub fn loans_generated_by(&self, scope: region::CodeExtent) -> Vec<usize> {\n+    pub fn loans_generated_by(&self, node: ast::NodeId) -> Vec<usize> {\n         //! Returns a vector of the loans that are generated as\n-        //! we enter `scope`.\n+        //! we enter `node`.\n \n         let mut result = Vec::new();\n-        self.dfcx_loans.each_gen_bit(scope.node_id(), |loan_index| {\n+        self.dfcx_loans.each_gen_bit(node, |loan_index| {\n             result.push(loan_index);\n             true\n         });\n         return result;\n     }\n \n-    pub fn check_for_conflicting_loans(&self, scope: region::CodeExtent) {\n+    pub fn check_for_conflicting_loans(&self, node: ast::NodeId) {\n         //! Checks to see whether any of the loans that are issued\n-        //! on entrance to `scope` conflict with loans that have already been\n-        //! issued when we enter `scope` (for example, we do not\n+        //! on entrance to `node` conflict with loans that have already been\n+        //! issued when we enter `node` (for example, we do not\n         //! permit two `&mut` borrows of the same variable).\n         //!\n         //! (Note that some loans can be *issued* without necessarily\n         //! taking effect yet.)\n \n-        debug!(\"check_for_conflicting_loans(scope={:?})\", scope);\n+        debug!(\"check_for_conflicting_loans(node={:?})\", node);\n \n-        let new_loan_indices = self.loans_generated_by(scope);\n+        let new_loan_indices = self.loans_generated_by(node);\n         debug!(\"new_loan_indices = {:?}\", new_loan_indices);\n \n-        self.each_issued_loan(scope, |issued_loan| {\n+        self.each_issued_loan(node, |issued_loan| {\n             for &new_loan_index in &new_loan_indices {\n                 let new_loan = &self.all_loans[new_loan_index];\n                 self.report_error_if_loans_conflict(issued_loan, new_loan);\n@@ -557,7 +557,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 old_loan.span,\n                 &format!(\"{}; {}\", borrow_summary, rule_summary));\n \n-            let old_loan_span = self.tcx().map.span(old_loan.kill_scope.node_id());\n+            let old_loan_span = self.tcx().map.span(\n+                old_loan.kill_scope.node_id(&self.tcx().region_maps));\n             self.bccx.span_end_note(old_loan_span,\n                                     \"previous borrow ends here\");\n \n@@ -673,7 +674,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         let mut ret = UseOk;\n \n         self.each_in_scope_loan_affecting_path(\n-            region::CodeExtent::from_node_id(expr_id), use_path, |loan| {\n+            self.tcx().region_maps.node_extent(expr_id), use_path, |loan| {\n             if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n                 ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n                 false\n@@ -787,7 +788,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         // Check that we don't invalidate any outstanding loans\n         if let Some(loan_path) = opt_loan_path(&assignee_cmt) {\n-            let scope = region::CodeExtent::from_node_id(assignment_id);\n+            let scope = self.tcx().region_maps.node_extent(assignment_id);\n             self.each_in_scope_loan_affecting_path(scope, &*loan_path, |loan| {\n                 self.report_illegal_mutation(assignment_span, &*loan_path, loan);\n                 false"}, {"sha": "cbdd0020a3032398bbcf0ad794e729dd602fab3c", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -44,7 +44,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n         all_loans: Vec::new(),\n-        item_ub: region::CodeExtent::from_node_id(body.id),\n+        item_ub: bccx.tcx.region_maps.node_extent(body.id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n@@ -360,7 +360,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 let loan_scope = match loan_region {\n                     ty::ReScope(scope) => scope,\n \n-                    ty::ReFree(ref fr) => fr.scope.to_code_extent(),\n+                    ty::ReFree(ref fr) => fr.scope,\n \n                     ty::ReStatic => {\n                         // If we get here, an error must have been\n@@ -377,7 +377,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     ty::ReEmpty |\n                     ty::ReLateBound(..) |\n                     ty::ReEarlyBound(..) |\n-                    ty::ReInfer(..) => {\n+                    ty::ReVar(..) |\n+                    ty::ReSkolemized(..) => {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n                             &format!(\"invalid borrow lifetime: {:?}\",\n@@ -386,7 +387,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 };\n                 debug!(\"loan_scope = {:?}\", loan_scope);\n \n-                let borrow_scope = region::CodeExtent::from_node_id(borrow_id);\n+                let borrow_scope = self.tcx().region_maps.node_extent(borrow_id);\n                 let gen_scope = self.compute_gen_scope(borrow_scope, loan_scope);\n                 debug!(\"gen_scope = {:?}\", gen_scope);\n "}, {"sha": "9a684021fcdd33d8d261ed1497cbf3cbf2448827", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -191,6 +191,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                           -> AnalysisData<'a, 'tcx>\n {\n     // Check the body of fn items.\n+    let tcx = this.tcx;\n     let id_range = ast_util::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n     let (all_loans, move_data) =\n         gather_loans::gather_loans_in_fn(this, id, decl, body);\n@@ -204,8 +205,9 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                              id_range,\n                              all_loans.len());\n     for (loan_idx, loan) in all_loans.iter().enumerate() {\n-        loan_dfcx.add_gen(loan.gen_scope.node_id(), loan_idx);\n-        loan_dfcx.add_kill(KillFrom::ScopeEnd, loan.kill_scope.node_id(), loan_idx);\n+        loan_dfcx.add_gen(loan.gen_scope.node_id(&tcx.region_maps), loan_idx);\n+        loan_dfcx.add_kill(KillFrom::ScopeEnd,\n+                           loan.kill_scope.node_id(&tcx.region_maps), loan_idx);\n     }\n     loan_dfcx.add_kills_from_flow_exits(cfg);\n     loan_dfcx.propagate(cfg, body);\n@@ -414,7 +416,7 @@ impl<'tcx> LoanPath<'tcx> {\n             LpVar(local_id) => tcx.region_maps.var_scope(local_id),\n             LpUpvar(upvar_id) => {\n                 let block_id = closure_to_block(upvar_id.closure_expr_id, tcx);\n-                region::CodeExtent::from_node_id(block_id)\n+                tcx.region_maps.node_extent(block_id)\n             }\n             LpDowncast(ref base, _) |\n             LpExtend(ref base, _, _) => base.kill_scope(tcx),\n@@ -1135,7 +1137,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n fn statement_scope_span(tcx: &ty::ctxt, region: ty::Region) -> Option<Span> {\n     match region {\n         ty::ReScope(scope) => {\n-            match tcx.map.find(scope.node_id()) {\n+            match tcx.map.find(scope.node_id(&tcx.region_maps)) {\n                 Some(ast_map::NodeStmt(stmt)) => Some(stmt.span),\n                 _ => None\n             }"}, {"sha": "a389095df791181ad0760304a57f01936ca05117", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -494,7 +494,7 @@ impl<'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = path.loan_path.kill_scope(tcx);\n                     let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n-                    self.kill_moves(path, kill_scope.node_id(),\n+                    self.kill_moves(path, kill_scope.node_id(&tcx.region_maps),\n                                     KillFrom::ScopeEnd, dfcx_moves);\n                 }\n                 LpExtend(..) => {}\n@@ -509,7 +509,7 @@ impl<'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = lp.kill_scope(tcx);\n                     dfcx_assign.add_kill(KillFrom::ScopeEnd,\n-                                         kill_scope.node_id(),\n+                                         kill_scope.node_id(&tcx.region_maps),\n                                          assignment_index);\n                 }\n                 LpExtend(..) => {"}, {"sha": "3277e07dfc163bd504acd158303053e956786a1a", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -17,7 +17,8 @@ use rustc_lint;\n use rustc_resolve as resolve;\n use rustc_typeck::middle::lang_items;\n use rustc_typeck::middle::free_region::FreeRegionMap;\n-use rustc_typeck::middle::region::{self, CodeExtent, DestructionScopeData};\n+use rustc_typeck::middle::region::{self, CodeExtent};\n+use rustc_typeck::middle::region::CodeExtentData;\n use rustc_typeck::middle::resolve_lifetime;\n use rustc_typeck::middle::stability;\n use rustc_typeck::middle::subst;\n@@ -153,24 +154,25 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn create_region_hierarchy(&self, rh: &RH) {\n+    pub fn create_region_hierarchy(&self, rh: &RH, parent: CodeExtent) {\n+        let me = self.infcx.tcx.region_maps.intern_node(rh.id, parent);\n         for child_rh in rh.sub {\n-            self.create_region_hierarchy(child_rh);\n-            self.infcx.tcx.region_maps.record_encl_scope(\n-                CodeExtent::from_node_id(child_rh.id),\n-                CodeExtent::from_node_id(rh.id));\n+            self.create_region_hierarchy(child_rh, me);\n         }\n     }\n \n     pub fn create_simple_region_hierarchy(&self) {\n         // creates a region hierarchy where 1 is root, 10 and 11 are\n         // children of 1, etc\n+        let dscope = self.infcx.tcx.region_maps.intern_code_extent(\n+            CodeExtentData::DestructionScope(1), region::ROOT_CODE_EXTENT);\n         self.create_region_hierarchy(\n             &RH {id: 1,\n                  sub: &[RH {id: 10,\n                             sub: &[]},\n                         RH {id: 11,\n-                            sub: &[]}]});\n+                            sub: &[]}]},\n+            dscope);\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n@@ -321,14 +323,16 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        let r = ty::ReScope(CodeExtent::from_node_id(id));\n+        let r = ty::ReScope(self.tcx().region_maps.node_extent(id));\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r),\n                                    self.tcx().types.isize)\n     }\n \n     pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region {\n-        ty::ReFree(ty::FreeRegion { scope: DestructionScopeData::new(nid),\n-                                    bound_region: ty::BrAnon(id)})\n+        ty::ReFree(ty::FreeRegion {\n+            scope: self.tcx().region_maps.item_extent(nid),\n+            bound_region: ty::BrAnon(id)\n+        })\n     }\n \n     pub fn t_rptr_free(&self, nid: ast::NodeId, id: u32) -> Ty<'tcx> {\n@@ -462,7 +466,8 @@ fn sub_free_bound_false() {\n     //! does NOT hold.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        env.create_simple_region_hierarchy();\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         env.check_not_sub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                           env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n@@ -478,8 +483,9 @@ fn sub_bound_free_true() {\n     //! DOES hold.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n         env.check_sub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n     })\n@@ -512,9 +518,10 @@ fn lub_free_bound_infer() {\n     //! anyhow.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        env.create_simple_region_hierarchy();\n         let t_infer1 = env.infcx.next_ty_var();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n         env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n@@ -535,8 +542,9 @@ fn lub_bound_bound() {\n #[test]\n fn lub_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n         env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n@@ -568,8 +576,9 @@ fn lub_bound_bound_inverse_order() {\n #[test]\n fn lub_free_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        let t_rptr_free2 = env.t_rptr_free(0, 2);\n+        env.create_simple_region_hierarchy();\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free2 = env.t_rptr_free(1, 2);\n         let t_rptr_static = env.t_rptr_static();\n         env.check_lub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n@@ -594,9 +603,10 @@ fn lub_returning_scope() {\n #[test]\n fn glb_free_free_with_common_scope() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        let t_rptr_free2 = env.t_rptr_free(0, 2);\n-        let t_rptr_scope = env.t_rptr_scope(0);\n+        env.create_simple_region_hierarchy();\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free2 = env.t_rptr_free(1, 2);\n+        let t_rptr_scope = env.t_rptr_scope(1);\n         env.check_glb(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_scope], env.tcx().types.isize));\n@@ -617,8 +627,9 @@ fn glb_bound_bound() {\n #[test]\n fn glb_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n         env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n@@ -738,10 +749,11 @@ fn escaping() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         // Situation:\n         // Theta = [A -> &'a foo]\n+        env.create_simple_region_hierarchy();\n \n         assert!(!env.t_nil().has_escaping_regions());\n \n-        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1, 1);\n         assert!(!t_rptr_free1.has_escaping_regions());\n \n         let t_rptr_bound1 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1));"}, {"sha": "ecfbaf57903060885e8382816355a3f0b12b6ce7", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -253,18 +253,16 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         // now we just say that if there is already an AST scope on the stack,\n         // this new AST scope had better be its immediate child.\n         let top_scope = self.top_ast_scope();\n+        let region_maps = &self.ccx.tcx().region_maps;\n         if top_scope.is_some() {\n-            assert!((self.ccx\n-                     .tcx()\n-                     .region_maps\n-                     .opt_encl_scope(region::CodeExtent::from_node_id(debug_loc.id))\n-                     .map(|s|s.node_id()) == top_scope)\n+            assert!((region_maps\n+                     .opt_encl_scope(region_maps.node_extent(debug_loc.id))\n+                     .map(|s|s.node_id(region_maps)) == top_scope)\n                     ||\n-                    (self.ccx\n-                     .tcx()\n-                     .region_maps\n-                     .opt_encl_scope(region::CodeExtent::DestructionScope(debug_loc.id))\n-                     .map(|s|s.node_id()) == top_scope));\n+                    (region_maps\n+                     .opt_encl_scope(region_maps.lookup_code_extent(\n+                         region::CodeExtentData::DestructionScope(debug_loc.id)))\n+                     .map(|s|s.node_id(region_maps)) == top_scope));\n         }\n \n         self.push_scope(CleanupScope::new(AstScopeKind(debug_loc.id),\n@@ -1111,7 +1109,7 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n                        -> ScopeId {\n     match tcx.region_maps.temporary_scope(id) {\n         Some(scope) => {\n-            let r = AstScope(scope.node_id());\n+            let r = AstScope(scope.node_id(&tcx.region_maps));\n             debug!(\"temporary_scope({}) = {:?}\", id, r);\n             r\n         }\n@@ -1125,7 +1123,7 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n pub fn var_scope(tcx: &ty::ctxt,\n                  id: ast::NodeId)\n                  -> ScopeId {\n-    let r = AstScope(tcx.region_maps.var_scope(id).node_id());\n+    let r = AstScope(tcx.region_maps.var_scope(id).node_id(&tcx.region_maps));\n     debug!(\"var_scope({}) = {:?}\", id, r);\n     r\n }"}, {"sha": "944169fc45ebbadde1641d501ddbcde506fccd59", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -179,7 +179,7 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n \n         Some(&rl::DefFreeRegion(scope, id)) => {\n             ty::ReFree(ty::FreeRegion {\n-                    scope: scope,\n+                    scope: tcx.region_maps.item_extent(scope.node_id),\n                     bound_region: ty::BrNamed(DefId::local(id),\n                                               lifetime.name)\n                 })"}, {"sha": "a3714fead8e28caaa29980fa28a3921af7dae7d2", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -14,7 +14,6 @@ use super::{check_fn, Expectation, FnCtxt};\n \n use astconv;\n use middle::def_id::DefId;\n-use middle::region;\n use middle::subst;\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use std::cmp;\n@@ -77,7 +76,7 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     fcx.write_ty(expr.id, closure_type);\n \n     let fn_sig = fcx.tcx().liberate_late_bound_regions(\n-        region::DestructionScopeData::new(body.id), &fn_ty.sig);\n+        fcx.tcx().region_maps.item_extent(body.id), &fn_ty.sig);\n \n     check_fn(fcx.ccx,\n              ast::Unsafety::Normal,"}, {"sha": "cf08490d720c94cb6c0ee14bf8ed8de03559c616", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -91,7 +91,6 @@ use middle::infer;\n use middle::infer::type_variable;\n use middle::pat_util::{self, pat_id_map};\n use middle::privacy::{AllPublic, LastMod};\n-use middle::region::{self};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{FnSig, GenericPredicates, TypeScheme};\n@@ -455,11 +454,11 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let inh = Inherited::new(ccx.tcx, &tables, param_env);\n \n             // Compute the fty from point of view of inside fn.\n+            let fn_scope = ccx.tcx.region_maps.item_extent(body.id);\n             let fn_sig =\n                 fn_ty.sig.subst(ccx.tcx, &inh.infcx.parameter_environment.free_substs);\n             let fn_sig =\n-                ccx.tcx.liberate_late_bound_regions(region::DestructionScopeData::new(body.id),\n-                                                    &fn_sig);\n+                ccx.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n             let fn_sig =\n                 inh.normalize_associated_types_in(body.span,\n                                                   body.id,"}, {"sha": "847cbfdbec6237d8aed4a0be8c441c3c46528412", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -294,7 +294,9 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n         let old_body_id = self.set_body_id(body.id);\n         self.relate_free_regions(&fn_sig[..], body.id, span);\n-        link_fn_args(self, CodeExtent::from_node_id(body.id), &fn_decl.inputs[..]);\n+        link_fn_args(self,\n+                     self.tcx().region_maps.node_extent(body.id),\n+                     &fn_decl.inputs[..]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n \n@@ -428,7 +430,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                 debug!(\"implication: {:?}\", implication);\n                 match implication {\n                     ImpliedBound::RegionSubRegion(ty::ReFree(free_a),\n-                                                  ty::ReInfer(ty::ReVar(vid_b))) => {\n+                                                  ty::ReVar(vid_b)) => {\n                         self.fcx.inh.infcx.add_given(free_a, vid_b);\n                     }\n                     ImpliedBound::RegionSubParam(r_a, param_b) => {\n@@ -564,17 +566,15 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     // No matter what, the type of each expression must outlive the\n     // scope of that expression. This also guarantees basic WF.\n     let expr_ty = rcx.resolve_node_type(expr.id);\n-\n+    // the region corresponding to this expression\n+    let expr_region = ty::ReScope(rcx.tcx().region_maps.node_extent(expr.id));\n     type_must_outlive(rcx, infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n-                      expr_ty, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n+                      expr_ty, expr_region);\n \n     let method_call = MethodCall::expr(expr.id);\n     let opt_method_callee = rcx.fcx.inh.tables.borrow().method_map.get(&method_call).cloned();\n     let has_method_map = opt_method_callee.is_some();\n \n-    // the region corresponding to this expression\n-    let expr_region = ty::ReScope(CodeExtent::from_node_id(expr.id));\n-\n     // If we are calling a method (either explicitly or via an\n     // overloaded operator), check that all of the types provided as\n     // arguments for its type parameters are well-formed, and all the regions\n@@ -609,7 +609,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                     // FIXME(#6268) remove to support nested method calls\n                     type_of_node_must_outlive(\n                         rcx, infer::AutoBorrow(expr.span),\n-                        expr.id, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n+                        expr.id, expr_region);\n                 }\n             }\n             /*\n@@ -726,7 +726,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                 type_must_outlive(rcx,\n                                   infer::Operand(expr.span),\n                                   ty,\n-                                  ty::ReScope(CodeExtent::from_node_id(expr.id)));\n+                                  expr_region);\n             }\n             visit::walk_expr(rcx, expr);\n         }\n@@ -756,7 +756,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             };\n             if let ty::TyRef(r_ptr, _) = base_ty.sty {\n                 mk_subregion_due_to_dereference(\n-                    rcx, expr.span, ty::ReScope(CodeExtent::from_node_id(expr.id)), *r_ptr);\n+                    rcx, expr.span, expr_region, *r_ptr);\n             }\n \n             visit::walk_expr(rcx, expr);\n@@ -789,8 +789,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             //\n             // FIXME(#6268) nested method calls requires that this rule change\n             let ty0 = rcx.resolve_node_type(expr.id);\n-            type_must_outlive(rcx, infer::AddrOf(expr.span),\n-                              ty0, ty::ReScope(CodeExtent::from_node_id(expr.id)));\n+            type_must_outlive(rcx, infer::AddrOf(expr.span), ty0, expr_region);\n             visit::walk_expr(rcx, expr);\n         }\n \n@@ -919,7 +918,7 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n     // call occurs.\n     //\n     // FIXME(#6268) to support nested method calls, should be callee_id\n-    let callee_scope = CodeExtent::from_node_id(call_expr.id);\n+    let callee_scope = rcx.tcx().region_maps.node_extent(call_expr.id);\n     let callee_region = ty::ReScope(callee_scope);\n \n     debug!(\"callee_region={:?}\", callee_region);\n@@ -966,7 +965,8 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n            derefs,\n            derefd_ty);\n \n-    let r_deref_expr = ty::ReScope(CodeExtent::from_node_id(deref_expr.id));\n+    let s_deref_expr = rcx.tcx().region_maps.node_extent(deref_expr.id);\n+    let r_deref_expr = ty::ReScope(s_deref_expr);\n     for i in 0..derefs {\n         let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n         debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n@@ -1083,7 +1083,7 @@ fn constrain_index<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n     debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n            rcx.fcx.infcx().ty_to_string(indexed_ty));\n \n-    let r_index_expr = ty::ReScope(CodeExtent::from_node_id(index_expr.id));\n+    let r_index_expr = ty::ReScope(rcx.tcx().region_maps.node_extent(index_expr.id));\n     if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n         match mt.ty.sty {\n             ty::TySlice(_) | ty::TyStr => {\n@@ -1234,7 +1234,7 @@ fn link_autoref(rcx: &Rcx,\n         }\n \n         ty::AutoUnsafe(m) => {\n-            let r = ty::ReScope(CodeExtent::from_node_id(expr.id));\n+            let r = ty::ReScope(rcx.tcx().region_maps.node_extent(expr.id));\n             link_region(rcx, expr.span, &r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n     }"}, {"sha": "0ef1d4b81acadffe2782c65fdb9c0ff7fa37a33f", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -466,10 +466,7 @@ pub struct BoundsChecker<'cx,'tcx:'cx> {\n     fcx: &'cx FnCtxt<'cx,'tcx>,\n     span: Span,\n \n-    // This field is often attached to item impls; it is not clear\n-    // that `CodeExtent` is well-defined for such nodes, so pnkfelix\n-    // has left it as a NodeId rather than porting to CodeExtent.\n-    scope: ast::NodeId,\n+    scope: region::CodeExtent,\n \n     binding_count: usize,\n     cache: Option<&'cx mut HashSet<Ty<'tcx>>>,\n@@ -480,6 +477,7 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n                scope: ast::NodeId,\n                cache: Option<&'cx mut HashSet<Ty<'tcx>>>)\n                -> BoundsChecker<'cx,'tcx> {\n+        let scope = fcx.tcx().region_maps.item_extent(scope);\n         BoundsChecker { fcx: fcx, span: DUMMY_SP, scope: scope,\n                         cache: cache, binding_count: 0 }\n     }\n@@ -532,7 +530,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n     {\n         self.binding_count += 1;\n         let value = self.fcx.tcx().liberate_late_bound_regions(\n-            region::DestructionScopeData::new(self.scope),\n+            self.scope,\n             binder);\n         debug!(\"BoundsChecker::fold_binder: late-bound regions replaced: {:?} at scope: {:?}\",\n                value, self.scope);"}, {"sha": "4280e392d180f38d2ed2ac275135937402763491", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -13,7 +13,6 @@ use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n use middle::def_id::DefId;\n-use middle::region::DestructionScopeData;\n use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use middle::traits;\n use middle::ty::{self, Ty};\n@@ -362,7 +361,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     {\n         let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n         let fty = fcx.instantiate_type_scheme(span, free_substs, fty);\n-        let free_id_outlive = DestructionScopeData::new(free_id);\n+        let free_id_outlive = fcx.tcx().region_maps.item_extent(free_id);\n         let sig = fcx.tcx().liberate_late_bound_regions(free_id_outlive, &fty.sig);\n \n         for &input_ty in &sig.inputs {"}, {"sha": "544f6d9f0ed858d28c34578623a7f572ffdda3f0", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -2311,7 +2311,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n             _ => typ,\n         };\n \n-        let body_scope = region::DestructionScopeData::new(body_id);\n+        let body_scope = tcx.region_maps.item_extent(body_id);\n \n         // \"Required type\" comes from the trait definition. It may\n         // contain late-bound regions from the method, but not the\n@@ -2363,7 +2363,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n \n     fn liberate_early_bound_regions<'tcx,T>(\n         tcx: &ty::ctxt<'tcx>,\n-        scope: region::DestructionScopeData,\n+        scope: region::CodeExtent,\n         value: &T)\n         -> T\n         where T : TypeFoldable<'tcx>"}, {"sha": "98058b804eee486b493987cea6147375c59340e9", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -1025,8 +1025,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // methods or in fn types.\n             }\n \n-            ty::ReFree(..) | ty::ReScope(..) | ty::ReInfer(..) |\n-            ty::ReEmpty => {\n+            ty::ReFree(..) | ty::ReScope(..) | ty::ReVar(..) |\n+            ty::ReSkolemized(..) | ty::ReEmpty => {\n                 // We don't expect to see anything but 'static or bound\n                 // regions when visiting member types or method types.\n                 self.tcx()"}, {"sha": "9cd376f8d31bdc46dfe41041a86ce888f745fc64", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3573470f009fa078fe063700b8df2854e8499e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bc3573470f009fa078fe063700b8df2854e8499e", "patch": "@@ -772,7 +772,8 @@ impl Clean<Option<Lifetime>> for ty::Region {\n             ty::ReLateBound(..) |\n             ty::ReFree(..) |\n             ty::ReScope(..) |\n-            ty::ReInfer(..) |\n+            ty::ReVar(..) |\n+            ty::ReSkolemized(..) |\n             ty::ReEmpty(..) => None\n         }\n     }"}]}