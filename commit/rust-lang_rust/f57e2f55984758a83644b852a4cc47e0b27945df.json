{"sha": "f57e2f55984758a83644b852a4cc47e0b27945df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1N2UyZjU1OTg0NzU4YTgzNjQ0Yjg1MmE0Y2M0N2UwYjI3OTQ1ZGY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-14T14:27:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-14T14:27:53Z"}, "message": "Merge #7993\n\n7993: Use auto-deref in completion scoring r=JoshMcguigan a=ivan770\n\nCloses #7982 \n\nCo-authored-by: ivan770 <leshenko.ivan770@gmail.com>", "tree": {"sha": "54d6221f672f343b848660434b653d269b7381ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54d6221f672f343b848660434b653d269b7381ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f57e2f55984758a83644b852a4cc47e0b27945df", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgTh1pCRBK7hj4Ov3rIwAAdHIIAGLw41e97eaK8bzfqPm/a/LJ\nwbLAyXe4wxyYiAFath/BDRMd3uLBhc3/jnz+ppBkdND34HzKhn58FVg4QnIXfoON\nHSmMct9Bl5T3MZhdCajt3lRxcwKVVb0EtGz5RE+GQao2l5EWkrQ8Nyps7ZYZs6uQ\nBwWkFHqZ5MBF2dHkDxnFTrfAECBIbnWGY1iMlZslfW+RrHUb2/dGjONAo7Q6dYd+\nykUMfX3H3F4JClL1JEXkK6zml1t6/D09zc+ltqD4/W3x/5hGPgBfz2Ndgs6nG8LJ\nCQBvhe7SMFvy49ZeMhzehiqB2WOdwjGC11ei1TP1atfOAeaSYTgIWAYd+/ZRvqs=\n=ZKrv\n-----END PGP SIGNATURE-----\n", "payload": "tree 54d6221f672f343b848660434b653d269b7381ec\nparent a32ca8ef796986b42536c3a14515db2cec1131b3\nparent 8a9ebe62a114ef83d46771b28e483f6b8ea5478e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615732073 +0000\ncommitter GitHub <noreply@github.com> 1615732073 +0000\n\nMerge #7993\n\n7993: Use auto-deref in completion scoring r=JoshMcguigan a=ivan770\n\nCloses #7982 \n\nCo-authored-by: ivan770 <leshenko.ivan770@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f57e2f55984758a83644b852a4cc47e0b27945df", "html_url": "https://github.com/rust-lang/rust/commit/f57e2f55984758a83644b852a4cc47e0b27945df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f57e2f55984758a83644b852a4cc47e0b27945df/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a32ca8ef796986b42536c3a14515db2cec1131b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a32ca8ef796986b42536c3a14515db2cec1131b3", "html_url": "https://github.com/rust-lang/rust/commit/a32ca8ef796986b42536c3a14515db2cec1131b3"}, {"sha": "8a9ebe62a114ef83d46771b28e483f6b8ea5478e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a9ebe62a114ef83d46771b28e483f6b8ea5478e", "html_url": "https://github.com/rust-lang/rust/commit/8a9ebe62a114ef83d46771b28e483f6b8ea5478e"}], "stats": {"total": 158, "additions": 137, "deletions": 21}, "files": [{"sha": "fcb8115fba06f113682b77945000eab07382c18e", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 137, "deletions": 21, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/f57e2f55984758a83644b852a4cc47e0b27945df/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f57e2f55984758a83644b852a4cc47e0b27945df/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=f57e2f55984758a83644b852a4cc47e0b27945df", "patch": "@@ -10,8 +10,10 @@ pub(crate) mod type_alias;\n \n mod builder_ext;\n \n+use base_db::Upcast;\n use hir::{\n-    AsAssocItem, Documentation, HasAttrs, HirDisplay, ModuleDef, Mutability, ScopeDef, Type,\n+    db::HirDatabase, AsAssocItem, Documentation, HasAttrs, HirDisplay, ModuleDef, Mutability,\n+    ScopeDef, Type,\n };\n use ide_db::{\n     helpers::{item_name, SnippetCap},\n@@ -251,19 +253,23 @@ impl<'a> Render<'a> {\n \n         if let ScopeDef::Local(local) = resolution {\n             let ty = local.ty(self.ctx.db());\n+\n             if let Some(relevance) = compute_relevance(&self.ctx, &ty, &local_name) {\n                 item.set_relevance(relevance);\n             }\n+\n             if let Some((_expected_name, expected_type)) = self.ctx.expected_name_and_type() {\n-                if let Some(ty_without_ref) = expected_type.remove_ref() {\n-                    if ty_without_ref == ty {\n-                        cov_mark::hit!(suggest_ref);\n-                        let mutability = if expected_type.is_mutable_reference() {\n-                            Mutability::Mut\n-                        } else {\n-                            Mutability::Shared\n-                        };\n-                        item.ref_match(mutability);\n+                if ty != expected_type {\n+                    if let Some(ty_without_ref) = expected_type.remove_ref() {\n+                        if relevance_type_match(self.ctx.db().upcast(), &ty, &ty_without_ref) {\n+                            cov_mark::hit!(suggest_ref);\n+                            let mutability = if expected_type.is_mutable_reference() {\n+                                Mutability::Mut\n+                            } else {\n+                                Mutability::Shared\n+                            };\n+                            item.ref_match(mutability);\n+                        }\n                     }\n                 }\n             }\n@@ -330,10 +336,12 @@ fn compute_relevance(ctx: &RenderContext, ty: &Type, name: &str) -> Option<Compl\n     Some(res)\n }\n \n+fn relevance_type_match(db: &dyn HirDatabase, ty: &Type, expected_type: &Type) -> bool {\n+    ty == expected_type || ty.autoderef(db).any(|deref_ty| &deref_ty == expected_type)\n+}\n+\n #[cfg(test)]\n mod tests {\n-    use std::cmp::Reverse;\n-\n     use expect_test::{expect, Expect};\n \n     use crate::{\n@@ -358,17 +366,27 @@ mod tests {\n             }\n         }\n \n-        let mut completions = get_all_items(TEST_CONFIG, ra_fixture);\n-        completions.sort_by_key(|it| (Reverse(it.relevance()), it.label().to_string()));\n-        let actual = completions\n+        let actual = get_all_items(TEST_CONFIG, ra_fixture)\n             .into_iter()\n             .filter(|it| it.completion_kind == CompletionKind::Reference)\n-            .map(|it| {\n+            .flat_map(|it| {\n+                let mut items = vec![];\n+\n                 let tag = it.kind().unwrap().tag();\n                 let relevance = display_relevance(it.relevance());\n-                format!(\"{} {} {}\\n\", tag, it.label(), relevance)\n+                items.push(format!(\"{} {} {}\\n\", tag, it.label(), relevance));\n+\n+                if let Some((mutability, relevance)) = it.ref_match() {\n+                    let label = format!(\"&{}{}\", mutability.as_keyword_for_ref(), it.label());\n+                    let relevance = display_relevance(relevance);\n+\n+                    items.push(format!(\"{} {} {}\\n\", tag, label, relevance));\n+                }\n+\n+                items\n             })\n             .collect::<String>();\n+\n         expect.assert_eq(&actual);\n     }\n \n@@ -838,9 +856,9 @@ fn test(bar: u32) { }\n fn foo(s: S) { test(s.$0) }\n \"#,\n             expect![[r#\"\n+                fd foo []\n                 fd bar [type+name]\n                 fd baz [type]\n-                fd foo []\n             \"#]],\n         );\n     }\n@@ -855,9 +873,9 @@ struct B { x: (), y: f32, bar: u32 }\n fn foo(a: A) { B { bar: a.$0 }; }\n \"#,\n             expect![[r#\"\n+                fd foo []\n                 fd bar [type+name]\n                 fd baz [type]\n-                fd foo []\n             \"#]],\n         )\n     }\n@@ -885,9 +903,9 @@ fn f(foo: i64) {  }\n fn foo(a: A) { f(B { bar: a.$0 }); }\n \"#,\n             expect![[r#\"\n+                fd foo []\n                 fd bar [type+name]\n                 fd baz [type]\n-                fd foo []\n             \"#]],\n         );\n     }\n@@ -915,9 +933,9 @@ struct Foo;\n fn f(foo: &Foo) { f(foo, w$0) }\n \"#,\n             expect![[r#\"\n+                lc foo []\n                 st Foo []\n                 fn f(\u2026) []\n-                lc foo []\n             \"#]],\n         );\n     }\n@@ -987,4 +1005,102 @@ fn main() {\n             \"#]],\n         )\n     }\n+\n+    #[test]\n+    fn suggest_deref() {\n+        check_relevance(\n+            r#\"\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct S;\n+struct T(S);\n+\n+impl Deref for T {\n+    type Target = S;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn foo(s: &S) {}\n+\n+fn main() {\n+    let t = T(S);\n+    let m = 123;\n+\n+    foo($0);\n+}\n+            \"#,\n+            expect![[r#\"\n+                lc m []\n+                lc t []\n+                lc &t [type]\n+                st T []\n+                st S []\n+                fn main() []\n+                tt Deref []\n+                fn foo(\u2026) []\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn suggest_deref_mut() {\n+        check_relevance(\n+            r#\"\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+#[lang = \"deref_mut\"]\n+pub trait DerefMut: Deref {\n+    fn deref_mut(&mut self) -> &mut Self::Target;\n+}\n+\n+struct S;\n+struct T(S);\n+\n+impl Deref for T {\n+    type Target = S;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl DerefMut for T {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+\n+fn foo(s: &mut S) {}\n+\n+fn main() {\n+    let t = T(S);\n+    let m = 123;\n+\n+    foo($0);\n+}\n+            \"#,\n+            expect![[r#\"\n+                lc m []\n+                lc t []\n+                lc &mut t [type]\n+                tt DerefMut []\n+                tt Deref []\n+                fn foo(\u2026) []\n+                st T []\n+                st S []\n+                fn main() []\n+            \"#]],\n+        )\n+    }\n }"}]}