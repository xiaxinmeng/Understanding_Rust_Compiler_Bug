{"sha": "d635a6e506012ad4d427578e394aa2041e7dbdfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MzVhNmU1MDYwMTJhZDRkNDI3NTc4ZTM5NGFhMjA0MWU3ZGJkZmI=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-01-21T23:22:03Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-01-22T13:10:08Z"}, "message": "add a container::Map trait", "tree": {"sha": "4a26021e49a12ca9287faf8538d4c6195b98db6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a26021e49a12ca9287faf8538d4c6195b98db6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d635a6e506012ad4d427578e394aa2041e7dbdfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d635a6e506012ad4d427578e394aa2041e7dbdfb", "html_url": "https://github.com/rust-lang/rust/commit/d635a6e506012ad4d427578e394aa2041e7dbdfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d635a6e506012ad4d427578e394aa2041e7dbdfb/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffb9049274beaac8ddde6b9632d8c9ac7715f9d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffb9049274beaac8ddde6b9632d8c9ac7715f9d1", "html_url": "https://github.com/rust-lang/rust/commit/ffb9049274beaac8ddde6b9632d8c9ac7715f9d1"}], "stats": {"total": 173, "additions": 91, "deletions": 82}, "files": [{"sha": "dd556aec45f8e2e129e9d01054e491a0fa0e0862", "filename": "src/libcore/container.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d635a6e506012ad4d427578e394aa2041e7dbdfb/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d635a6e506012ad4d427578e394aa2041e7dbdfb/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=d635a6e506012ad4d427578e394aa2041e7dbdfb", "patch": "@@ -10,11 +10,37 @@\n \n //! Container traits\n \n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n pub trait Mutable {\n     /// Clear the container, removing all values.\n     fn clear(&mut self);\n }\n \n+pub trait Map<K, V>: Mutable {\n+    /// Return true if the map contains a value for the specified key\n+    pure fn contains_key(&self, key: &K) -> bool;\n+\n+    /// Visit all key-value pairs\n+    pure fn each(&self, f: fn(&K, &V) -> bool);\n+\n+    /// Visit all keys\n+    pure fn each_key(&self, f: fn(&K) -> bool);\n+\n+    /// Visit all values\n+    pure fn each_value(&self, f: fn(&V) -> bool);\n+\n+    /// Insert a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Return true if the key did\n+    /// not already exist in the map.\n+    fn insert(&mut self, key: K, value: V) -> bool;\n+\n+    /// Remove a key-value pair from the map. Return true if the key\n+    /// was present in the map, otherwise false.\n+    fn remove(&mut self, key: &K) -> bool;\n+}\n+\n pub trait Set<T>: Mutable {\n     /// Return true if the set contains a value\n     pure fn contains(&self, value: &T) -> bool;"}, {"sha": "812b138097a8d1cd7addfb3f5454f1615e7a3db6", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 31, "deletions": 50, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d635a6e506012ad4d427578e394aa2041e7dbdfb/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d635a6e506012ad4d427578e394aa2041e7dbdfb/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=d635a6e506012ad4d427578e394aa2041e7dbdfb", "patch": "@@ -23,30 +23,10 @@ use hash::Hash;\n use prelude::*;\n use to_bytes::IterBytes;\n \n-pub trait SendMap<K:Eq Hash, V: Copy> {\n-    // FIXME(#3148)  ^^^^ once find_ref() works, we can drop V:copy\n-\n-    fn insert(&mut self, k: K, +v: V) -> bool;\n-    fn remove(&mut self, k: &K) -> bool;\n-    fn pop(&mut self, k: &K) -> Option<V>;\n-    fn swap(&mut self, k: K, +v: V) -> Option<V>;\n-    fn consume(&mut self, f: fn(K, V));\n-    pure fn len(&const self) -> uint;\n-    pure fn is_empty(&const self) -> bool;\n-    pure fn contains_key(&const self, k: &K) -> bool;\n-    pure fn each(&self, blk: fn(k: &K, v: &V) -> bool);\n-    pure fn each_key_ref(&self, blk: fn(k: &K) -> bool);\n-    pure fn each_value_ref(&self, blk: fn(v: &V) -> bool);\n-    pure fn find(&const self, k: &K) -> Option<V>;\n-    pure fn get(&const self, k: &K) -> V;\n-    pure fn find_ref(&self, k: &K) -> Option<&self/V>;\n-    pure fn get_ref(&self, k: &K) -> &self/V;\n-}\n-\n /// Open addressing with linear probing.\n pub mod linear {\n     use iter::BaseIter;\n-    use container::{Mutable, Set};\n+    use container::{Mutable, Map, Set};\n     use cmp::Eq;\n     use cmp;\n     use hash::Hash;\n@@ -287,7 +267,34 @@ pub mod linear {\n         }\n     }\n \n-    impl<K:Hash IterBytes Eq,V> LinearMap<K,V> {\n+    impl <K: Hash IterBytes Eq, V> LinearMap<K, V>: Map<K, V> {\n+        pure fn contains_key(&self, k: &K) -> bool {\n+            match self.bucket_for_key(self.buckets, k) {\n+                FoundEntry(_) => {true}\n+                TableFull | FoundHole(_) => {false}\n+            }\n+        }\n+\n+        pure fn each(&self, blk: fn(k: &K, v: &V) -> bool) {\n+            for vec::each(self.buckets) |slot| {\n+                let mut broke = false;\n+                do slot.iter |bucket| {\n+                    if !blk(&bucket.key, &bucket.value) {\n+                        broke = true; // FIXME(#3064) just write \"break;\"\n+                    }\n+                }\n+                if broke { break; }\n+            }\n+        }\n+\n+        pure fn each_key(&self, blk: fn(k: &K) -> bool) {\n+            self.each(|k, _v| blk(k))\n+        }\n+\n+        pure fn each_value(&self, blk: fn(v: &V) -> bool) {\n+            self.each(|_k, v| blk(v))\n+        }\n+\n         fn insert(&mut self, k: K, v: V) -> bool {\n             if self.size >= self.resize_at {\n                 // n.b.: We could also do this after searching, so\n@@ -309,7 +316,9 @@ pub mod linear {\n                 None => false,\n             }\n         }\n+    }\n \n+    impl<K:Hash IterBytes Eq,V> LinearMap<K,V> {\n         fn pop(&mut self, k: &K) -> Option<V> {\n             let hash = k.hash_keyed(self.k0, self.k1) as uint;\n             self.pop_internal(hash, k)\n@@ -363,14 +372,6 @@ pub mod linear {\n             self.len() == 0\n         }\n \n-        pure fn contains_key(&const self,\n-                        k: &K) -> bool {\n-            match self.bucket_for_key(self.buckets, k) {\n-                FoundEntry(_) => {true}\n-                TableFull | FoundHole(_) => {false}\n-            }\n-        }\n-\n         pure fn find_ref(&self, k: &K) -> Option<&self/V> {\n             match self.bucket_for_key(self.buckets, k) {\n                 FoundEntry(idx) => {\n@@ -397,26 +398,6 @@ pub mod linear {\n                 None => fail fmt!(\"No entry found for key: %?\", k),\n             }\n         }\n-\n-        pure fn each(&self, blk: fn(k: &K, v: &V) -> bool) {\n-            for vec::each(self.buckets) |slot| {\n-                let mut broke = false;\n-                do slot.iter |bucket| {\n-                    if !blk(&bucket.key, &bucket.value) {\n-                        broke = true; // FIXME(#3064) just write \"break;\"\n-                    }\n-                }\n-                if broke { break; }\n-            }\n-        }\n-\n-        pure fn each_key(&self, blk: fn(k: &K) -> bool) {\n-            self.each(|k, _v| blk(k))\n-        }\n-\n-        pure fn each_value(&self, blk: fn(v: &V) -> bool) {\n-            self.each(|_k, v| blk(v))\n-        }\n     }\n \n     impl<K:Hash IterBytes Eq, V: Copy> LinearMap<K,V> {"}, {"sha": "ff60d7d1c2bd25e5639456cc536c2cbc3313fec7", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d635a6e506012ad4d427578e394aa2041e7dbdfb/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d635a6e506012ad4d427578e394aa2041e7dbdfb/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=d635a6e506012ad4d427578e394aa2041e7dbdfb", "patch": "@@ -14,7 +14,7 @@\n \n #[forbid(deprecated_mode)];\n \n-use core::container::{Mutable, Set};\n+use core::container::{Mutable, Map, Set};\n use core::cmp::{Eq, Ord};\n use core::option::{Option, Some, None};\n use core::prelude::*;\n@@ -75,6 +75,39 @@ impl <K: Ord, V> TreeMap<K, V>: Mutable {\n     }\n }\n \n+impl <K: Ord, V> TreeMap<K, V>: Map<K, V> {\n+    /// Return true if the map contains a value for the specified key\n+    pure fn contains_key(&self, key: &K) -> bool {\n+        self.find(key).is_some()\n+    }\n+\n+    /// Visit all key-value pairs in order\n+    pure fn each(&self, f: fn(&K, &V) -> bool) { each(&self.root, f) }\n+\n+    /// Visit all keys in order\n+    pure fn each_key(&self, f: fn(&K) -> bool) { self.each(|k, _| f(k)) }\n+\n+    /// Visit all values in order\n+    pure fn each_value(&self, f: fn(&V) -> bool) { self.each(|_, v| f(v)) }\n+\n+    /// Insert a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Return true if the key did\n+    /// not already exist in the map.\n+    fn insert(&mut self, key: K, value: V) -> bool {\n+        let ret = insert(&mut self.root, key, value);\n+        if ret { self.length += 1 }\n+        ret\n+    }\n+\n+    /// Remove a key-value pair from the map. Return true if the key\n+    /// was present in the map, otherwise false.\n+    fn remove(&mut self, key: &K) -> bool {\n+        let ret = remove(&mut self.root, key);\n+        if ret { self.length -= 1 }\n+        ret\n+    }\n+}\n+\n impl <K: Ord, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     static pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n@@ -88,15 +121,6 @@ impl <K: Ord, V> TreeMap<K, V> {\n     /// Return true if the map contains some elements\n     pure fn is_not_empty(&self) -> bool { self.root.is_some() }\n \n-    /// Visit all key-value pairs in order\n-    pure fn each(&self, f: fn(&K, &V) -> bool) { each(&self.root, f) }\n-\n-    /// Visit all keys in order\n-    pure fn each_key(&self, f: fn(&K) -> bool) { self.each(|k, _| f(k)) }\n-\n-    /// Visit all values in order\n-    pure fn each_value(&self, f: fn(&V) -> bool) { self.each(|_, v| f(v)) }\n-\n     /// Visit all key-value pairs in reverse order\n     pure fn each_reverse(&self, f: fn(&K, &V) -> bool) {\n         each_reverse(&self.root, f);\n@@ -112,11 +136,6 @@ impl <K: Ord, V> TreeMap<K, V> {\n         self.each_reverse(|_, v| f(v))\n     }\n \n-    /// Return true if the map contains a value for the specified key\n-    pure fn contains_key(&self, key: &K) -> bool {\n-        self.find(key).is_some()\n-    }\n-\n     /// Return the value corresponding to the key in the map\n     pure fn find(&self, key: &K) -> Option<&self/V> {\n         let mut current: &self/Option<~TreeNode<K, V>> = &self.root;\n@@ -137,23 +156,6 @@ impl <K: Ord, V> TreeMap<K, V> {\n         }\n     }\n \n-    /// Insert a key-value pair into the map. An existing value for a\n-    /// key is replaced by the new value. Return true if the key did\n-    /// not already exist in the map.\n-    fn insert(&mut self, key: K, value: V) -> bool {\n-        let ret = insert(&mut self.root, key, value);\n-        if ret { self.length += 1 }\n-        ret\n-    }\n-\n-    /// Remove a key-value pair from the map. Return true if the key\n-    /// was present in the map, otherwise false.\n-    fn remove(&mut self, key: &K) -> bool {\n-        let ret = remove(&mut self.root, key);\n-        if ret { self.length -= 1 }\n-        ret\n-    }\n-\n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n     pure fn iter(&self) -> TreeMapIterator/&self<K, V> {"}]}