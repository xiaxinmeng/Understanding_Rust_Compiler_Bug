{"sha": "37cf649311bcf6fec2d9096b483ac4be81b70732", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3Y2Y2NDkzMTFiY2Y2ZmVjMmQ5MDk2YjQ4M2FjNGJlODFiNzA3MzI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-13T00:07:46Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-13T00:08:25Z"}, "message": "Document IterBytes, Eq, Cmp, Hash. Close #3449.", "tree": {"sha": "560e9f816124c2a928e7551343a281873e3563d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/560e9f816124c2a928e7551343a281873e3563d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37cf649311bcf6fec2d9096b483ac4be81b70732", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37cf649311bcf6fec2d9096b483ac4be81b70732", "html_url": "https://github.com/rust-lang/rust/commit/37cf649311bcf6fec2d9096b483ac4be81b70732", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37cf649311bcf6fec2d9096b483ac4be81b70732/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a6df9c90ff1042c07bf785b724884fb84df195f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a6df9c90ff1042c07bf785b724884fb84df195f", "html_url": "https://github.com/rust-lang/rust/commit/7a6df9c90ff1042c07bf785b724884fb84df195f"}], "stats": {"total": 62, "additions": 61, "deletions": 1}, "files": [{"sha": "4c4efc1385936e0003c643ad8596027671381148", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/37cf649311bcf6fec2d9096b483ac4be81b70732/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37cf649311bcf6fec2d9096b483ac4be81b70732/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=37cf649311bcf6fec2d9096b483ac4be81b70732", "patch": "@@ -5,6 +5,14 @@\n /// Interfaces used for comparison.\n \n // Awful hack to work around duplicate lang items in core test.\n+\n+/**\n+ * Trait for values that can be compared for a sort-order.\n+ *\n+ * Eventually this may be simplified to only require\n+ * an `le` method, with the others generated from\n+ * default implementations.\n+ */\n #[cfg(notest)]\n #[lang=\"ord\"]\n trait Ord {\n@@ -24,6 +32,14 @@ trait Ord {\n \n #[cfg(notest)]\n #[lang=\"eq\"]\n+/**\n+ * Trait for values that can be compared for equality\n+ * and inequality.\n+ *\n+ * Eventually this may be simplified to only require\n+ * an `eq` method, with the other generated from\n+ * a default implementation.\n+ */\n trait Eq {\n     pure fn eq(&&other: self) -> bool;\n     pure fn ne(&&other: self) -> bool;"}, {"sha": "1dec739dd217650ee28b1dc429cadff3a0dbaa7b", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/37cf649311bcf6fec2d9096b483ac4be81b70732/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37cf649311bcf6fec2d9096b483ac4be81b70732/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=37cf649311bcf6fec2d9096b483ac4be81b70732", "patch": "@@ -34,8 +34,31 @@ export hash_u16;\n export hash_u8;\n export hash_uint;\n \n-/// Types that can meaningfully be hashed should implement this.\n+/**\n+ * Types that can meaningfully be hashed should implement this.\n+ *\n+ * Note that this trait is likely to change somewhat as it is\n+ * closely related to `to_bytes::IterBytes` and in almost all\n+ * cases presently the two are (and must be) used together.\n+ *\n+ * In general, most types only need to implement `IterBytes`,\n+ * and the implementation of `Hash` below will take care of\n+ * the rest. This is the recommended approach, since constructing\n+ * good keyed hash functions is quite difficult.\n+ */\n trait Hash {\n+    /**\n+     * Compute a \"keyed\" hash of the value implementing the trait,\n+     * taking `k0` and `k1` as \"keying\" parameters that randomize or\n+     * otherwise perturb the hash function in such a way that a\n+     * hash table built using such \"keyed hash functions\" cannot\n+     * be made to perform linearly by an attacker controlling the\n+     * hashtable's contents.\n+     *\n+     * In practical terms, we implement this using the SipHash 2-4\n+     * function and require most types to only implement the\n+     * IterBytes trait, that feeds SipHash.\n+     */\n     pure fn hash_keyed(k0: u64, k1: u64) -> u64;\n }\n "}, {"sha": "3363f5a0a6a5b6d62b3d4e4e0370d03f5a1b12c4", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/37cf649311bcf6fec2d9096b483ac4be81b70732/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37cf649311bcf6fec2d9096b483ac4be81b70732/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=37cf649311bcf6fec2d9096b483ac4be81b70732", "patch": "@@ -6,7 +6,28 @@ use io::Writer;\n \n type Cb = fn(buf: &[const u8]) -> bool;\n \n+/**\n+ * A trait to implement in order to make a type hashable;\n+ * This works in combination with the trait `Hash::Hash`, and\n+ * may in the future be merged with that trait or otherwise\n+ * modified when default methods and trait inheritence are\n+ * completed.\n+ */\n trait IterBytes {\n+    /**\n+     * Call the provided callback `f` one or more times with\n+     * byte-slices that should be used when computing a hash\n+     * value or otherwise \"flattening\" the structure into\n+     * a sequence of bytes. The `lsb0` parameter conveys\n+     * whether the caller is asking for little-endian bytes\n+     * (`true`) or big-endian (`false`); this should only be\n+     * relevant in implementations that represent a single\n+     * multi-byte datum such as a 32 bit integer or 64 bit\n+     * floating-point value. It can be safely ignored for\n+     * larger structured types as they are usually processed\n+     * left-to-right in declaration order, regardless of\n+     * underlying memory endianness.\n+     */\n     pure fn iter_bytes(lsb0: bool, f: Cb);\n }\n "}]}