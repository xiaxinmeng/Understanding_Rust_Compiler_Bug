{"sha": "1c35ab322ff2f26962a3550fffc2fa4154224b64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMzVhYjMyMmZmMmYyNjk2MmEzNTUwZmZmYzJmYTQxNTQyMjRiNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-14T17:19:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-14T17:19:21Z"}, "message": "auto merge of #7751 : alexcrichton/rust/finish-tls, r=pcwalton\n\nThis changes the interface to `get`, and it also changes the keys to be static slices instead of static functions.\r\n\r\nThis allows the removal of the `unsafe` interface because while functions can monomorphize from different types to the same actual function, static slices cannot do this.\r\n\r\nFrom at least what I can tell, we don't need to worry about LLVM coalescing these addresses. If we ever use the `unnamed_addr` it looks like there's cause for worry, but there doesn't appear to be any coalescing atm.", "tree": {"sha": "d95eb9acc27f980f2365330b3aa9566e8eec2010", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d95eb9acc27f980f2365330b3aa9566e8eec2010"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c35ab322ff2f26962a3550fffc2fa4154224b64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c35ab322ff2f26962a3550fffc2fa4154224b64", "html_url": "https://github.com/rust-lang/rust/commit/1c35ab322ff2f26962a3550fffc2fa4154224b64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c35ab322ff2f26962a3550fffc2fa4154224b64/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66e2857253ff9bc8ce299398ad5bb346d64e3fc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/66e2857253ff9bc8ce299398ad5bb346d64e3fc3", "html_url": "https://github.com/rust-lang/rust/commit/66e2857253ff9bc8ce299398ad5bb346d64e3fc3"}, {"sha": "9fd2ac7428afa4f414f32b8b4876ca817ee85f16", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fd2ac7428afa4f414f32b8b4876ca817ee85f16", "html_url": "https://github.com/rust-lang/rust/commit/9fd2ac7428afa4f414f32b8b4876ca817ee85f16"}], "stats": {"total": 706, "additions": 357, "deletions": 349}, "files": [{"sha": "59801c945b626d9eca336a417ef2fb168320340a", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -66,24 +66,28 @@ pub unsafe fn read(prompt: &str) -> Option<~str> {\n     }\n }\n \n-pub type CompletionCb<'self> = @fn(~str, &'self fn(~str));\n+pub type CompletionCb = @fn(~str, @fn(~str));\n \n-fn complete_key(_v: @CompletionCb) {}\n+#[cfg(not(stage0))]\n+static complete_key: local_data::Key<@CompletionCb> = &local_data::Key;\n+#[cfg(stage0)]\n+fn complete_key(_: @CompletionCb) {}\n \n /// Bind to the main completion callback\n pub unsafe fn complete(cb: CompletionCb) {\n-    local_data::set(complete_key, @(cb));\n+    local_data::set(complete_key, @cb);\n \n     extern fn callback(line: *c_char, completions: *()) {\n-        unsafe {\n-            let cb = *local_data::get(complete_key, |k| k.map(|&k| *k))\n-                .get();\n-\n-            do cb(str::raw::from_c_str(line)) |suggestion| {\n-                do str::as_c_str(suggestion) |buf| {\n-                    rustrt::linenoiseAddCompletion(completions, buf);\n+        do local_data::get(complete_key) |cb| {\n+            let cb = **cb.unwrap();\n+\n+            unsafe {\n+                do cb(str::raw::from_c_str(line)) |suggestion| {\n+                    do str::as_c_str(suggestion) |buf| {\n+                        rustrt::linenoiseAddCompletion(completions, buf);\n+                    }\n                 }\n-            }\n+}\n         }\n     }\n "}, {"sha": "db4ad43e41d7a4967c953441bcd7a93d5a2b9d03", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -1195,39 +1195,4 @@ mod big_tests {\n             isSorted(arr);\n         }\n     }\n-\n-    struct LVal<'self> {\n-        val: uint,\n-        key: &'self fn:Copy(@uint),\n-    }\n-\n-    #[unsafe_destructor]\n-    impl<'self> Drop for LVal<'self> {\n-        fn drop(&self) {\n-            let x = unsafe { local_data::get(self.key, |k| k.map(|&k| *k)) };\n-            match x {\n-                Some(@y) => {\n-                    unsafe {\n-                        local_data::set(self.key, @(y+1));\n-                    }\n-                }\n-                _ => fail!(\"Expected key to work\"),\n-            }\n-        }\n-    }\n-\n-    impl<'self> Ord for LVal<'self> {\n-        fn lt<'a>(&self, other: &'a LVal<'self>) -> bool {\n-            (*self).val < other.val\n-        }\n-        fn le<'a>(&self, other: &'a LVal<'self>) -> bool {\n-            (*self).val <= other.val\n-        }\n-        fn gt<'a>(&self, other: &'a LVal<'self>) -> bool {\n-            (*self).val > other.val\n-        }\n-        fn ge<'a>(&self, other: &'a LVal<'self>) -> bool {\n-            (*self).val >= other.val\n-        }\n-    }\n }"}, {"sha": "aeed2d842c13145b21064a184dcd251ee7e99788", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -105,6 +105,7 @@ pub mod jit {\n     use metadata::cstore;\n \n     use std::cast;\n+    #[cfg(not(stage0))]\n     use std::local_data;\n     use std::unstable::intrinsics;\n \n@@ -202,18 +203,19 @@ pub mod jit {\n \n     // The stage1 compiler won't work, but that doesn't really matter. TLS\n     // changed only very recently to allow storage of owned values.\n-    fn engine_key(_: ~Engine) {}\n+    #[cfg(not(stage0))]\n+    static engine_key: local_data::Key<~Engine> = &local_data::Key;\n \n     #[cfg(not(stage0))]\n     fn set_engine(engine: ~Engine) {\n-        unsafe { local_data::set(engine_key, engine) }\n+        local_data::set(engine_key, engine)\n     }\n     #[cfg(stage0)]\n     fn set_engine(_: ~Engine) {}\n \n     #[cfg(not(stage0))]\n     pub fn consume_engine() -> Option<~Engine> {\n-        unsafe { local_data::pop(engine_key) }\n+        local_data::pop(engine_key)\n     }\n     #[cfg(stage0)]\n     pub fn consume_engine() -> Option<~Engine> { None }"}, {"sha": "b679da714a174f4614d55f58d99eed8be2ee245d", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -209,7 +209,7 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n      LintSpec {\n          lint: non_uppercase_statics,\n          desc: \"static constants should have uppercase identifiers\",\n-         default: warn\n+         default: allow\n      }),\n \n     (\"managed_heap_memory\","}, {"sha": "7182f7ff8b7d4b7f5d9c9f9119a135aa5f401ba1", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -87,49 +87,44 @@ use syntax::abi::{X86, X86_64, Arm, Mips};\n \n pub use middle::trans::context::task_llcx;\n \n-fn task_local_insn_key(_v: @~[&'static str]) {}\n+#[cfg(not(stage0))]\n+static task_local_insn_key: local_data::Key<@~[&'static str]> = &local_data::Key;\n+#[cfg(stage0)]\n+fn task_local_insn_key(_: @~[&'static str]) {}\n \n pub fn with_insn_ctxt(blk: &fn(&[&'static str])) {\n-    unsafe {\n-        let opt = local_data::get(task_local_insn_key, |k| k.map(|&k| *k));\n-        if opt.is_some() {\n-            blk(*opt.unwrap());\n-        }\n+    let opt = local_data::get(task_local_insn_key, |k| k.map(|&k| *k));\n+    if opt.is_some() {\n+        blk(*opt.unwrap());\n     }\n }\n \n pub fn init_insn_ctxt() {\n-    unsafe {\n-        local_data::set(task_local_insn_key, @~[]);\n-    }\n+    local_data::set(task_local_insn_key, @~[]);\n }\n \n pub struct _InsnCtxt { _x: () }\n \n #[unsafe_destructor]\n impl Drop for _InsnCtxt {\n     fn drop(&self) {\n-        unsafe {\n-            do local_data::modify(task_local_insn_key) |c| {\n-                do c.map_consume |ctx| {\n-                    let mut ctx = copy *ctx;\n-                    ctx.pop();\n-                    @ctx\n-                }\n+        do local_data::modify(task_local_insn_key) |c| {\n+            do c.map_consume |ctx| {\n+                let mut ctx = copy *ctx;\n+                ctx.pop();\n+                @ctx\n             }\n         }\n     }\n }\n \n pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     debug!(\"new InsnCtxt: %s\", s);\n-    unsafe {\n-        do local_data::modify(task_local_insn_key) |c| {\n-            do c.map_consume |ctx| {\n-                let mut ctx = copy *ctx;\n-                ctx.push(s);\n-                @ctx\n-            }\n+    do local_data::modify(task_local_insn_key) |c| {\n+        do c.map_consume |ctx| {\n+            let mut ctx = copy *ctx;\n+            ctx.push(s);\n+            @ctx\n         }\n     }\n     _InsnCtxt { _x: () }\n@@ -1428,7 +1423,7 @@ pub fn with_scope(bcx: block,\n \n pub fn with_scope_result(bcx: block,\n                          opt_node_info: Option<NodeInfo>,\n-                         name: &str,\n+                         _name: &str,\n                          f: &fn(block) -> Result) -> Result {\n     let _icx = push_ctxt(\"with_scope_result\");\n "}, {"sha": "42f6a4dad6b74b3779831eb265b259721e86b04e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -197,7 +197,7 @@ fn get_impl_resolutions(bcx: block,\n                         impl_id: ast::def_id)\n                          -> typeck::vtable_res {\n     if impl_id.crate == ast::local_crate {\n-        *bcx.ccx().maps.vtable_map.get(&impl_id.node)\n+        bcx.ccx().maps.vtable_map.get_copy(&impl_id.node)\n     } else {\n         // XXX: This is a temporary hack to work around not properly\n         // exporting information about resolutions for impls.\n@@ -670,15 +670,13 @@ pub fn trans_call_inner(in_cx: block,\n             None => { assert!(ty::type_is_immediate(bcx.tcx(), ret_ty)) }\n             Some(expr::Ignore) => {\n                 // drop the value if it is not being saved.\n-                unsafe {\n-                    if ty::type_needs_drop(bcx.tcx(), ret_ty) {\n-                        if ty::type_is_immediate(bcx.tcx(), ret_ty) {\n-                            let llscratchptr = alloc_ty(bcx, ret_ty, \"__ret\");\n-                            Store(bcx, llresult, llscratchptr);\n-                            bcx = glue::drop_ty(bcx, llscratchptr, ret_ty);\n-                        } else {\n-                            bcx = glue::drop_ty(bcx, llretslot, ret_ty);\n-                        }\n+                if ty::type_needs_drop(bcx.tcx(), ret_ty) {\n+                    if ty::type_is_immediate(bcx.tcx(), ret_ty) {\n+                        let llscratchptr = alloc_ty(bcx, ret_ty, \"__ret\");\n+                        Store(bcx, llresult, llscratchptr);\n+                        bcx = glue::drop_ty(bcx, llscratchptr, ret_ty);\n+                    } else {\n+                        bcx = glue::drop_ty(bcx, llretslot, ret_ty);\n                     }\n                 }\n             }"}, {"sha": "ffebb87d5cf043d4f7763ff1ae3925bc94535631", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -232,22 +232,24 @@ impl CrateContext {\n #[unsafe_destructor]\n impl Drop for CrateContext {\n     fn drop(&self) {\n-        unsafe {\n-            unset_task_llcx();\n-        }\n+        unset_task_llcx();\n     }\n }\n \n+#[cfg(stage0)]\n fn task_local_llcx_key(_v: @ContextRef) {}\n+#[cfg(not(stage0))]\n+static task_local_llcx_key: local_data::Key<@ContextRef> = &local_data::Key;\n+\n pub fn task_llcx() -> ContextRef {\n-    let opt = unsafe { local_data::get(task_local_llcx_key, |k| k.map(|&k| *k)) };\n+    let opt = local_data::get(task_local_llcx_key, |k| k.map(|&k| *k));\n     *opt.expect(\"task-local LLVMContextRef wasn't ever set!\")\n }\n \n-unsafe fn set_task_llcx(c: ContextRef) {\n+fn set_task_llcx(c: ContextRef) {\n     local_data::set(task_local_llcx_key, @c);\n }\n \n-unsafe fn unset_task_llcx() {\n+fn unset_task_llcx() {\n     local_data::pop(task_local_llcx_key);\n }"}, {"sha": "e03a6e7c167cc4289eadeaf80856e96ead9c6ed3", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -254,7 +254,7 @@ pub fn trans_break_cont(bcx: block,\n     // Locate closest loop block, outputting cleanup as we go.\n     let mut unwind = bcx;\n     let mut cur_scope = unwind.scope;\n-    let mut target = unwind;\n+    let mut target;\n     loop {\n         cur_scope = match cur_scope {\n             Some(@scope_info {"}, {"sha": "8e23f5431bcee63cc27218784981d6085dba4f40", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -3621,25 +3621,29 @@ pub fn trait_method_def_ids(cx: ctxt, id: ast::def_id) -> @~[def_id] {\n }\n \n pub fn impl_trait_ref(cx: ctxt, id: ast::def_id) -> Option<@TraitRef> {\n-    *do cx.impl_trait_cache.find_or_insert_with(id) |_| {\n-        if id.crate == ast::local_crate {\n-            debug!(\"(impl_trait_ref) searching for trait impl %?\", id);\n-            match cx.items.find(&id.node) {\n-                Some(&ast_map::node_item(@ast::item {\n-                                         node: ast::item_impl(_, ref opt_trait, _, _),\n-                                         _},\n-                                         _)) => {\n-                    match opt_trait {\n-                        &Some(ref t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n-                        &None => None\n-                    }\n+    match cx.impl_trait_cache.find(&id) {\n+        Some(&ret) => { return ret; }\n+        None => {}\n+    }\n+    let ret = if id.crate == ast::local_crate {\n+        debug!(\"(impl_trait_ref) searching for trait impl %?\", id);\n+        match cx.items.find(&id.node) {\n+            Some(&ast_map::node_item(@ast::item {\n+                                     node: ast::item_impl(_, ref opt_trait, _, _),\n+                                     _},\n+                                     _)) => {\n+                match opt_trait {\n+                    &Some(ref t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n+                    &None => None\n                 }\n-                _ => None\n             }\n-        } else {\n-            csearch::get_impl_trait(cx, id)\n+            _ => None\n         }\n-    }\n+    } else {\n+        csearch::get_impl_trait(cx, id)\n+    };\n+    cx.impl_trait_cache.insert(id, ret);\n+    return ret;\n }\n \n pub fn ty_to_def_id(ty: t) -> Option<ast::def_id> {"}, {"sha": "b8b8ab3145d54fb2a1eac141f034a8989016fd56", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -303,7 +303,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     match ty::get(main_t).sty {\n-        ty::ty_bare_fn(ref fn_ty) => {\n+        ty::ty_bare_fn(*) => {\n             match tcx.items.find(&main_id) {\n                 Some(&ast_map::node_item(it,_)) => {\n                     match it.node {"}, {"sha": "787d8d5685a34b9357e3baf6f15dcf9d527c8b1a", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -18,8 +18,6 @@\n #[crate_type = \"lib\"];\n \n #[allow(non_implicitly_copyable_typarams)];\n-#[allow(non_camel_case_types)];\n-#[allow(non_uppercase_statics)];\n #[deny(deprecated_pattern)];\n \n extern mod extra;"}, {"sha": "9031a001eca6025baaee687789bd0f03b2ce1cdb", "filename": "src/librusti/program.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -11,7 +11,6 @@\n use std::cast;\n use std::hashmap::HashMap;\n use std::local_data;\n-use std::sys;\n \n use syntax::ast;\n use syntax::parse::token;\n@@ -58,7 +57,7 @@ struct LocalVariable {\n }\n \n type LocalCache = @mut HashMap<~str, @~[u8]>;\n-fn tls_key(_k: LocalCache) {}\n+static tls_key: local_data::Key<LocalCache> = &local_data::Key;\n \n impl Program {\n     pub fn new() -> Program {\n@@ -131,21 +130,16 @@ impl Program {\n             fn main() {\n         \");\n \n-        let key: sys::Closure = unsafe {\n-            let tls_key: &'static fn(LocalCache) = tls_key;\n-            cast::transmute(tls_key)\n-        };\n+        let key: uint= unsafe { cast::transmute(tls_key) };\n         // First, get a handle to the tls map which stores all the local\n         // variables. This works by totally legitimately using the 'code'\n         // pointer of the 'tls_key' function as a uint, and then casting it back\n         // up to a function\n         code.push_str(fmt!(\"\n             let __tls_map: @mut ::std::hashmap::HashMap<~str, @~[u8]> = unsafe {\n-                let key = ::std::sys::Closure{ code: %? as *(),\n-                                               env: ::std::ptr::null() };\n-                let key = ::std::cast::transmute(key);\n+                let key = ::std::cast::transmute(%u);\n                 ::std::local_data::get(key, |k| k.map(|&x| *x)).unwrap()\n-            };\\n\", key.code as uint));\n+            };\\n\", key as uint));\n \n         // Using this __tls_map handle, deserialize each variable binding that\n         // we know about\n@@ -226,18 +220,14 @@ impl Program {\n         for self.local_vars.iter().advance |(name, value)| {\n             map.insert(copy *name, @copy value.data);\n         }\n-        unsafe {\n-            local_data::set(tls_key, map);\n-        }\n+        local_data::set(tls_key, map);\n     }\n \n     /// Once the program has finished running, this function will consume the\n     /// task-local cache of local variables. After the program finishes running,\n     /// it updates this cache with the new values of each local variable.\n     pub fn consume_cache(&mut self) {\n-        let map = unsafe {\n-            local_data::pop(tls_key).expect(\"tls is empty\")\n-        };\n+        let map = local_data::pop(tls_key).expect(\"tls is empty\");\n         do map.consume |name, value| {\n             match self.local_vars.find_mut(&name) {\n                 Some(v) => { v.data = copy *value; }"}, {"sha": "3a5be12b3c586f1654928e9621cdb8103b6c1aaf", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 68, "deletions": 15, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -23,13 +23,59 @@ pub struct Handler<T, U> {\n     prev: Option<@Handler<T, U>>,\n }\n \n+#[cfg(stage0)]\n pub struct Condition<'self, T, U> {\n     name: &'static str,\n     key: local_data::Key<'self, @Handler<T, U>>\n }\n+#[cfg(not(stage0))]\n+pub struct Condition<T, U> {\n+    name: &'static str,\n+    key: local_data::Key<@Handler<T, U>>\n+}\n+\n+#[cfg(not(stage0))]\n+impl<T, U> Condition<T, U> {\n+    pub fn trap<'a>(&'a self, h: &'a fn(T) -> U) -> Trap<'a, T, U> {\n+        unsafe {\n+            let p : *RustClosure = ::cast::transmute(&h);\n+            let prev = local_data::get(self.key, |k| k.map(|&x| *x));\n+            let h = @Handler { handle: *p, prev: prev };\n+            Trap { cond: self, handler: h }\n+        }\n+    }\n+\n+    pub fn raise(&self, t: T) -> U {\n+        let msg = fmt!(\"Unhandled condition: %s: %?\", self.name, t);\n+        self.raise_default(t, || fail!(copy msg))\n+    }\n \n+    pub fn raise_default(&self, t: T, default: &fn() -> U) -> U {\n+        unsafe {\n+            match local_data::pop(self.key) {\n+                None => {\n+                    debug!(\"Condition.raise: found no handler\");\n+                    default()\n+                }\n+                Some(handler) => {\n+                    debug!(\"Condition.raise: found handler\");\n+                    match handler.prev {\n+                        None => {}\n+                        Some(hp) => local_data::set(self.key, hp)\n+                    }\n+                    let handle : &fn(T) -> U =\n+                        ::cast::transmute(handler.handle);\n+                    let u = handle(t);\n+                    local_data::set(self.key, handler);\n+                    u\n+                }\n+            }\n+        }\n+    }\n+}\n+#[cfg(stage0)]\n impl<'self, T, U> Condition<'self, T, U> {\n-    pub fn trap(&'self self, h: &'self fn(T) -> U) -> Trap<'self, T, U> {\n+    pub fn trap<'a>(&'a self, h: &'a fn(T) -> U) -> Trap<'a, T, U> {\n         unsafe {\n             let p : *RustClosure = ::cast::transmute(&h);\n             let prev = local_data::get(self.key, |k| k.map(|&x| *x));\n@@ -67,38 +113,45 @@ impl<'self, T, U> Condition<'self, T, U> {\n     }\n }\n \n+#[cfg(stage0)]\n struct Trap<'self, T, U> {\n     cond: &'self Condition<'self, T, U>,\n     handler: @Handler<T, U>\n }\n+#[cfg(not(stage0))]\n+struct Trap<'self, T, U> {\n+    cond: &'self Condition<T, U>,\n+    handler: @Handler<T, U>\n+}\n \n impl<'self, T, U> Trap<'self, T, U> {\n     pub fn in<V>(&self, inner: &'self fn() -> V) -> V {\n-        unsafe {\n-            let _g = Guard { cond: self.cond };\n-            debug!(\"Trap: pushing handler to TLS\");\n-            local_data::set(self.cond.key, self.handler);\n-            inner()\n-        }\n+        let _g = Guard { cond: self.cond };\n+        debug!(\"Trap: pushing handler to TLS\");\n+        local_data::set(self.cond.key, self.handler);\n+        inner()\n     }\n }\n \n+#[cfg(stage0)]\n struct Guard<'self, T, U> {\n     cond: &'self Condition<'self, T, U>\n }\n+#[cfg(not(stage0))]\n+struct Guard<'self, T, U> {\n+    cond: &'self Condition<T, U>\n+}\n \n #[unsafe_destructor]\n impl<'self, T, U> Drop for Guard<'self, T, U> {\n     fn drop(&self) {\n-        unsafe {\n-            debug!(\"Guard: popping handler from TLS\");\n-            let curr = local_data::pop(self.cond.key);\n-            match curr {\n+        debug!(\"Guard: popping handler from TLS\");\n+        let curr = local_data::pop(self.cond.key);\n+        match curr {\n+            None => {}\n+            Some(h) => match h.prev {\n                 None => {}\n-                Some(h) => match h.prev {\n-                    None => {}\n-                    Some(hp) => local_data::set(self.cond.key, hp)\n-                }\n+                Some(hp) => local_data::set(self.cond.key, hp)\n             }\n         }\n     }"}, {"sha": "be170cce07e544aaeceeef6de60788e8405670d9", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 132, "deletions": 130, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -12,27 +12,26 @@\n \n Task local data management\n \n-Allows storing boxes with arbitrary types inside, to be accessed anywhere within\n-a task, keyed by a pointer to a global finaliser function. Useful for dynamic\n-variables, singletons, and interfacing with foreign code with bad callback\n-interfaces.\n+Allows storing arbitrary types inside task-local-storage (TLS), to be accessed\n+anywhere within a task, keyed by a global pointer parameterized over the type of\n+the TLS slot.  Useful for dynamic variables, singletons, and interfacing with\n+foreign code with bad callback interfaces.\n \n-To use, declare a monomorphic (no type parameters) global function at the type\n-to store, and use it as the 'key' when accessing.\n+To use, declare a static variable of the type you wish to store. The\n+initialization should be `&local_data::Key`. This is then the key to what you\n+wish to store.\n \n ~~~{.rust}\n use std::local_data;\n \n-fn key_int(_: @int) {}\n-fn key_vector(_: @~[int]) {}\n+static key_int: local_data::Key<int> = &local_data::Key;\n+static key_vector: local_data::Key<~[int]> = &local_data::Key;\n \n-unsafe {\n-    local_data::set(key_int, @3);\n-    assert!(local_data::get(key_int) == Some(@3));\n+local_data::set(key_int, 3);\n+local_data::get(key_int, |opt| assert_eq!(opt, Some(&3)));\n \n-    local_data::set(key_vector, @~[3]);\n-    assert!(local_data::get(key_vector).unwrap()[0] == 3);\n-}\n+local_data::set(key_vector, ~[4]);\n+local_data::get(key_int, |opt| assert_eq!(opt, Some(&~[4])));\n ~~~\n \n Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation\n@@ -47,76 +46,77 @@ use task::local_data_priv::{local_get, local_pop, local_set, Handle};\n #[cfg(test)] use task;\n \n /**\n- * Indexes a task-local data slot. The function's code pointer is used for\n- * comparison. Recommended use is to write an empty function for each desired\n- * task-local data slot (and use class destructors, not code inside the\n- * function, if specific teardown is needed). DO NOT use multiple\n- * instantiations of a single polymorphic function to index data of different\n- * types; arbitrary type coercion is possible this way.\n- *\n- * One other exception is that this global state can be used in a destructor\n- * context to create a circular @-box reference, which will crash during task\n- * failure (see issue #3039).\n+ * Indexes a task-local data slot. This pointer is used for comparison to\n+ * differentiate keys from one another. The actual type `T` is not used anywhere\n+ * as a member of this type, except that it is parameterized with it to define\n+ * the type of each key's value.\n  *\n- * These two cases aside, the interface is safe.\n+ * The value of each Key is of the singleton enum KeyValue. These also have the\n+ * same name as `Key` and their purpose is to take up space in the programs data\n+ * sections to ensure that each value of the `Key` type points to a unique\n+ * location.\n  */\n+#[cfg(not(stage0))]\n+pub type Key<T> = &'static KeyValue<T>;\n+#[cfg(stage0)]\n pub type Key<'self,T> = &'self fn:Copy(v: T);\n \n+pub enum KeyValue<T> { Key }\n+\n /**\n  * Remove a task-local data value from the table, returning the\n  * reference that was originally created to insert it.\n  */\n #[cfg(stage0)]\n-pub unsafe fn pop<T: 'static>(key: Key<@T>) -> Option<@T> {\n-    local_pop(Handle::new(), key)\n+pub fn pop<T: 'static>(key: Key<@T>) -> Option<@T> {\n+    unsafe { local_pop(Handle::new(), key) }\n }\n /**\n  * Remove a task-local data value from the table, returning the\n  * reference that was originally created to insert it.\n  */\n #[cfg(not(stage0))]\n-pub unsafe fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n-    local_pop(Handle::new(), key)\n+pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n+    unsafe { local_pop(Handle::new(), key) }\n }\n /**\n  * Retrieve a task-local data value. It will also be kept alive in the\n  * table until explicitly removed.\n  */\n #[cfg(stage0)]\n-pub unsafe fn get<T: 'static, U>(key: Key<@T>, f: &fn(Option<&@T>) -> U) -> U {\n-    local_get(Handle::new(), key, f)\n+pub fn get<T: 'static, U>(key: Key<@T>, f: &fn(Option<&@T>) -> U) -> U {\n+    unsafe { local_get(Handle::new(), key, f) }\n }\n /**\n  * Retrieve a task-local data value. It will also be kept alive in the\n  * table until explicitly removed.\n  */\n #[cfg(not(stage0))]\n-pub unsafe fn get<T: 'static, U>(key: Key<T>, f: &fn(Option<&T>) -> U) -> U {\n-    local_get(Handle::new(), key, f)\n+pub fn get<T: 'static, U>(key: Key<T>, f: &fn(Option<&T>) -> U) -> U {\n+    unsafe { local_get(Handle::new(), key, f) }\n }\n /**\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n  */\n #[cfg(stage0)]\n-pub unsafe fn set<T: 'static>(key: Key<@T>, data: @T) {\n-    local_set(Handle::new(), key, data)\n+pub fn set<T: 'static>(key: Key<@T>, data: @T) {\n+    unsafe { local_set(Handle::new(), key, data) }\n }\n /**\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n  */\n #[cfg(not(stage0))]\n-pub unsafe fn set<T: 'static>(key: Key<T>, data: T) {\n-    local_set(Handle::new(), key, data)\n+pub fn set<T: 'static>(key: Key<T>, data: T) {\n+    unsafe { local_set(Handle::new(), key, data) }\n }\n /**\n  * Modify a task-local data value. If the function returns 'None', the\n  * data is removed (and its reference dropped).\n  */\n #[cfg(stage0)]\n-pub unsafe fn modify<T: 'static>(key: Key<@T>,\n-                                 f: &fn(Option<@T>) -> Option<@T>) {\n+pub fn modify<T: 'static>(key: Key<@T>, f: &fn(Option<@T>) -> Option<@T>) {\n     match f(pop(key)) {\n         Some(next) => { set(key, next); }\n         None => {}\n@@ -127,8 +127,7 @@ pub unsafe fn modify<T: 'static>(key: Key<@T>,\n  * data is removed (and its reference dropped).\n  */\n #[cfg(not(stage0))]\n-pub unsafe fn modify<T: 'static>(key: Key<T>,\n-                                 f: &fn(Option<T>) -> Option<T>) {\n+pub fn modify<T: 'static>(key: Key<T>, f: &fn(Option<T>) -> Option<T>) {\n     match f(pop(key)) {\n         Some(next) => { set(key, next); }\n         None => {}\n@@ -137,64 +136,56 @@ pub unsafe fn modify<T: 'static>(key: Key<T>,\n \n #[test]\n fn test_tls_multitask() {\n-    unsafe {\n-        fn my_key(_x: @~str) { }\n-        set(my_key, @~\"parent data\");\n-        do task::spawn {\n-            // TLS shouldn't carry over.\n-            assert!(get(my_key, |k| k.map(|&k| *k)).is_none());\n-            set(my_key, @~\"child data\");\n-            assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) ==\n-                    ~\"child data\");\n-            // should be cleaned up for us\n-        }\n-        // Must work multiple times\n-        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n-        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n-        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n+    static my_key: Key<@~str> = &Key;\n+    set(my_key, @~\"parent data\");\n+    do task::spawn {\n+        // TLS shouldn't carry over.\n+        assert!(get(my_key, |k| k.map(|&k| *k)).is_none());\n+        set(my_key, @~\"child data\");\n+        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) ==\n+                ~\"child data\");\n+        // should be cleaned up for us\n     }\n+    // Must work multiple times\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n }\n \n #[test]\n fn test_tls_overwrite() {\n-    unsafe {\n-        fn my_key(_x: @~str) { }\n-        set(my_key, @~\"first data\");\n-        set(my_key, @~\"next data\"); // Shouldn't leak.\n-        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"next data\");\n-    }\n+    static my_key: Key<@~str> = &Key;\n+    set(my_key, @~\"first data\");\n+    set(my_key, @~\"next data\"); // Shouldn't leak.\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"next data\");\n }\n \n #[test]\n fn test_tls_pop() {\n-    unsafe {\n-        fn my_key(_x: @~str) { }\n-        set(my_key, @~\"weasel\");\n-        assert!(*(pop(my_key).get()) == ~\"weasel\");\n-        // Pop must remove the data from the map.\n-        assert!(pop(my_key).is_none());\n-    }\n+    static my_key: Key<@~str> = &Key;\n+    set(my_key, @~\"weasel\");\n+    assert!(*(pop(my_key).get()) == ~\"weasel\");\n+    // Pop must remove the data from the map.\n+    assert!(pop(my_key).is_none());\n }\n \n #[test]\n fn test_tls_modify() {\n-    unsafe {\n-        fn my_key(_x: @~str) { }\n-        modify(my_key, |data| {\n-            match data {\n-                Some(@ref val) => fail!(\"unwelcome value: %s\", *val),\n-                None           => Some(@~\"first data\")\n-            }\n-        });\n-        modify(my_key, |data| {\n-            match data {\n-                Some(@~\"first data\") => Some(@~\"next data\"),\n-                Some(@ref val)       => fail!(\"wrong value: %s\", *val),\n-                None                 => fail!(\"missing value\")\n-            }\n-        });\n-        assert!(*(pop(my_key).get()) == ~\"next data\");\n-    }\n+    static my_key: Key<@~str> = &Key;\n+    modify(my_key, |data| {\n+        match data {\n+            Some(@ref val) => fail!(\"unwelcome value: %s\", *val),\n+            None           => Some(@~\"first data\")\n+        }\n+    });\n+    modify(my_key, |data| {\n+        match data {\n+            Some(@~\"first data\") => Some(@~\"next data\"),\n+            Some(@ref val)       => fail!(\"wrong value: %s\", *val),\n+            None                 => fail!(\"missing value\")\n+        }\n+    });\n+    assert!(*(pop(my_key).get()) == ~\"next data\");\n }\n \n #[test]\n@@ -205,79 +196,90 @@ fn test_tls_crust_automorestack_memorial_bug() {\n     // to get recorded as something within a rust stack segment. Then a\n     // subsequent upcall (esp. for logging, think vsnprintf) would run on\n     // a stack smaller than 1 MB.\n-    fn my_key(_x: @~str) { }\n+    static my_key: Key<@~str> = &Key;\n     do task::spawn {\n-        unsafe { set(my_key, @~\"hax\"); }\n+        set(my_key, @~\"hax\");\n     }\n }\n \n #[test]\n fn test_tls_multiple_types() {\n-    fn str_key(_x: @~str) { }\n-    fn box_key(_x: @@()) { }\n-    fn int_key(_x: @int) { }\n+    static str_key: Key<@~str> = &Key;\n+    static box_key: Key<@@()> = &Key;\n+    static int_key: Key<@int> = &Key;\n     do task::spawn {\n-        unsafe {\n-            set(str_key, @~\"string data\");\n-            set(box_key, @@());\n-            set(int_key, @42);\n-        }\n+        set(str_key, @~\"string data\");\n+        set(box_key, @@());\n+        set(int_key, @42);\n     }\n }\n \n #[test]\n fn test_tls_overwrite_multiple_types() {\n-    fn str_key(_x: @~str) { }\n-    fn box_key(_x: @@()) { }\n-    fn int_key(_x: @int) { }\n+    static str_key: Key<@~str> = &Key;\n+    static box_key: Key<@@()> = &Key;\n+    static int_key: Key<@int> = &Key;\n     do task::spawn {\n-        unsafe {\n-            set(str_key, @~\"string data\");\n-            set(int_key, @42);\n-            // This could cause a segfault if overwriting-destruction is done\n-            // with the crazy polymorphic transmute rather than the provided\n-            // finaliser.\n-            set(int_key, @31337);\n-        }\n+        set(str_key, @~\"string data\");\n+        set(int_key, @42);\n+        // This could cause a segfault if overwriting-destruction is done\n+        // with the crazy polymorphic transmute rather than the provided\n+        // finaliser.\n+        set(int_key, @31337);\n     }\n }\n \n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_tls_cleanup_on_failure() {\n-    unsafe {\n-        fn str_key(_x: @~str) { }\n-        fn box_key(_x: @@()) { }\n-        fn int_key(_x: @int) { }\n-        set(str_key, @~\"parent data\");\n+    static str_key: Key<@~str> = &Key;\n+    static box_key: Key<@@()> = &Key;\n+    static int_key: Key<@int> = &Key;\n+    set(str_key, @~\"parent data\");\n+    set(box_key, @@());\n+    do task::spawn {\n+        // spawn_linked\n+        set(str_key, @~\"string data\");\n         set(box_key, @@());\n-        do task::spawn {\n-            // spawn_linked\n-            set(str_key, @~\"string data\");\n-            set(box_key, @@());\n-            set(int_key, @42);\n-            fail!();\n-        }\n-        // Not quite nondeterministic.\n-        set(int_key, @31337);\n+        set(int_key, @42);\n         fail!();\n     }\n+    // Not quite nondeterministic.\n+    set(int_key, @31337);\n+    fail!();\n }\n \n #[test]\n fn test_static_pointer() {\n-    unsafe {\n-        fn key(_x: @&'static int) { }\n-        static VALUE: int = 0;\n-        set(key, @&VALUE);\n-    }\n+    static key: Key<@&'static int> = &Key;\n+    static VALUE: int = 0;\n+    let v: @&'static int = @&VALUE;\n+    set(key, v);\n }\n \n #[test]\n fn test_owned() {\n-    unsafe {\n-        fn key(_x: ~int) { }\n-        set(key, ~1);\n-    }\n+    static key: Key<~int> = &Key;\n+    set(key, ~1);\n+}\n+\n+#[test]\n+fn test_same_key_type() {\n+    static key1: Key<int> = &Key;\n+    static key2: Key<int> = &Key;\n+    static key3: Key<int> = &Key;\n+    static key4: Key<int> = &Key;\n+    static key5: Key<int> = &Key;\n+    set(key1, 1);\n+    set(key2, 2);\n+    set(key3, 3);\n+    set(key4, 4);\n+    set(key5, 5);\n+\n+    get(key1, |x| assert_eq!(*x.unwrap(), 1));\n+    get(key2, |x| assert_eq!(*x.unwrap(), 2));\n+    get(key3, |x| assert_eq!(*x.unwrap(), 3));\n+    get(key4, |x| assert_eq!(*x.unwrap(), 4));\n+    get(key5, |x| assert_eq!(*x.unwrap(), 5));\n }"}, {"sha": "58175db1241d2f330767bd89009a98f5ddfe2f78", "filename": "src/libstd/os.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -1239,30 +1239,29 @@ struct OverriddenArgs {\n     val: ~[~str]\n }\n \n+#[cfg(stage0)]\n fn overridden_arg_key(_v: @OverriddenArgs) {}\n+#[cfg(not(stage0))]\n+static overridden_arg_key: local_data::Key<@OverriddenArgs> = &local_data::Key;\n \n /// Returns the arguments which this program was started with (normally passed\n /// via the command line).\n ///\n /// The return value of the function can be changed by invoking the\n /// `os::set_args` function.\n pub fn args() -> ~[~str] {\n-    unsafe {\n-        match local_data::get(overridden_arg_key, |k| k.map(|&k| *k)) {\n-            None => real_args(),\n-            Some(args) => copy args.val\n-        }\n+    match local_data::get(overridden_arg_key, |k| k.map(|&k| *k)) {\n+        None => real_args(),\n+        Some(args) => copy args.val\n     }\n }\n \n /// For the current task, overrides the task-local cache of the arguments this\n /// program had when it started. These new arguments are only available to the\n /// current task via the `os::args` method.\n pub fn set_args(new_args: ~[~str]) {\n-    unsafe {\n-        let overridden_args = @OverriddenArgs { val: copy new_args };\n-        local_data::set(overridden_arg_key, overridden_args);\n-    }\n+    let overridden_args = @OverriddenArgs { val: copy new_args };\n+    local_data::set(overridden_arg_key, overridden_args);\n }\n \n // FIXME #6100 we should really use an internal implementation of this - using"}, {"sha": "6f89e7ffb0794212a1c09f0bdd4750d7992a5d1e", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -851,7 +851,10 @@ pub fn seed() -> ~[u8] {\n }\n \n // used to make space in TLS for a random number generator\n+#[cfg(stage0)]\n fn tls_rng_state(_v: @@mut IsaacRng) {}\n+#[cfg(not(stage0))]\n+static tls_rng_state: local_data::Key<@@mut IsaacRng> = &local_data::Key;\n \n /**\n  * Gives back a lazily initialized task-local random number generator,\n@@ -860,17 +863,12 @@ fn tls_rng_state(_v: @@mut IsaacRng) {}\n  */\n #[inline]\n pub fn task_rng() -> @mut IsaacRng {\n-    let r : Option<@@mut IsaacRng>;\n-    unsafe {\n-        r = local_data::get(tls_rng_state, |k| k.map(|&k| *k));\n-    }\n+    let r = local_data::get(tls_rng_state, |k| k.map(|&k| *k));\n     match r {\n         None => {\n-            unsafe {\n-                let rng = @@mut IsaacRng::new_seeded(seed());\n-                local_data::set(tls_rng_state, rng);\n-                *rng\n-            }\n+            let rng = @@mut IsaacRng::new_seeded(seed());\n+            local_data::set(tls_rng_state, rng);\n+            *rng\n         }\n         Some(rng) => *rng\n     }"}, {"sha": "17d0d59660f1b52191cdfd562c4fa0fddc5266f8", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -348,14 +348,12 @@ mod test {\n     fn tls() {\n         use local_data;\n         do run_in_newsched_task() {\n-            unsafe {\n-                fn key(_x: @~str) { }\n-                local_data::set(key, @~\"data\");\n-                assert!(*local_data::get(key, |k| k.map(|&k| *k)).get() == ~\"data\");\n-                fn key2(_x: @~str) { }\n-                local_data::set(key2, @~\"data\");\n-                assert!(*local_data::get(key2, |k| k.map(|&k| *k)).get() == ~\"data\");\n-            }\n+            static key: local_data::Key<@~str> = &local_data::Key;\n+            local_data::set(key, @~\"data\");\n+            assert!(*local_data::get(key, |k| k.map(|&k| *k)).get() == ~\"data\");\n+            static key2: local_data::Key<@~str> = &local_data::Key;\n+            local_data::set(key2, @~\"data\");\n+            assert!(*local_data::get(key2, |k| k.map(|&k| *k)).get() == ~\"data\");\n         }\n     }\n "}, {"sha": "03b895b38601a78010728f1a2312cf96823972c4", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -222,6 +222,7 @@ mod std {\n     pub use condition;\n     pub use option;\n     pub use kinds;\n+    pub use local_data;\n     pub use sys;\n     pub use pipes;\n     pub use unstable;"}, {"sha": "d46e5707f14a9cc6698f24c98da20225b07652f3", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -15,7 +15,6 @@ use libc;\n use local_data;\n use prelude::*;\n use ptr;\n-use sys;\n use task::rt;\n use util;\n \n@@ -142,9 +141,8 @@ unsafe fn get_local_map(handle: Handle) -> &mut TaskLocalMap {\n     }\n }\n \n-unsafe fn key_to_key_value<T: 'static>(key: local_data::Key<T>) -> *libc::c_void {\n-    let pair: sys::Closure = cast::transmute(key);\n-    return pair.code as *libc::c_void;\n+fn key_to_key_value<T: 'static>(key: local_data::Key<T>) -> *libc::c_void {\n+    unsafe { cast::transmute(key) }\n }\n \n pub unsafe fn local_pop<T: 'static>(handle: Handle,"}, {"sha": "206d19e175fe9c8513037e741bf6995d25087ae4", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -80,6 +80,7 @@ use cell::Cell;\n use container::MutableMap;\n use comm::{Chan, GenericChan};\n use hashmap::HashSet;\n+use local_data;\n use task::local_data_priv::{local_get, local_set, OldHandle};\n use task::rt::rust_task;\n use task::rt;\n@@ -465,10 +466,14 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n \n // FIXME (#2912): Work around core-vs-coretest function duplication. Can't use\n // a proper closure because the #[test]s won't understand. Have to fake it.\n-macro_rules! taskgroup_key (\n-    // Use a \"code pointer\" value that will never be a real code pointer.\n-    () => (cast::transmute((-2 as uint, 0u)))\n-)\n+#[cfg(not(stage0))]\n+fn taskgroup_key() -> local_data::Key<@@mut TCB> {\n+    unsafe { cast::transmute(-2) }\n+}\n+#[cfg(stage0)]\n+fn taskgroup_key() -> local_data::Key<@@mut TCB> {\n+    unsafe { cast::transmute((-2, 0)) }\n+}\n \n fn gen_child_taskgroup(linked: bool, supervised: bool)\n     -> (TaskGroupArc, AncestorList, bool) {\n@@ -478,7 +483,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n          * Step 1. Get spawner's taskgroup info.\n          *##################################################################*/\n         let spawner_group: @@mut TCB =\n-            do local_get(OldHandle(spawner), taskgroup_key!()) |group| {\n+            do local_get(OldHandle(spawner), taskgroup_key()) |group| {\n                 match group {\n                     None => {\n                         // Main task, doing first spawn ever. Lazily initialise\n@@ -495,7 +500,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                                               AncestorList(None),\n                                               true,\n                                               None);\n-                        local_set(OldHandle(spawner), taskgroup_key!(), group);\n+                        local_set(OldHandle(spawner), taskgroup_key(), group);\n                         group\n                     }\n                     Some(&group) => group\n@@ -688,7 +693,7 @@ fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n                                       is_main,\n                                       notifier);\n                 unsafe {\n-                    local_set(OldHandle(child), taskgroup_key!(), group);\n+                    local_set(OldHandle(child), taskgroup_key(), group);\n                 }\n \n                 // Run the child's body."}, {"sha": "a1d209d19ac5600a1833aa71e8e47ee7f58c2347", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -20,7 +20,6 @@ use std::hashmap::HashMap;\n use std::int;\n use std::num;\n use std::option;\n-use std::cast;\n use std::local_data;\n \n pub fn path_name_i(idents: &[ident]) -> ~str {\n@@ -695,18 +694,17 @@ pub fn new_sctable_internal() -> SCTable {\n \n // fetch the SCTable from TLS, create one if it doesn't yet exist.\n pub fn get_sctable() -> @mut SCTable {\n-    unsafe {\n-        let sctable_key = (cast::transmute::<(uint, uint),\n-                           &fn:Copy(v: @@mut SCTable)>(\n-                               (-4 as uint, 0u)));\n-        match local_data::get(sctable_key, |k| k.map(|&k| *k)) {\n-            None => {\n-                let new_table = @@mut new_sctable_internal();\n-                local_data::set(sctable_key,new_table);\n-                *new_table\n-            },\n-            Some(intr) => *intr\n-        }\n+    #[cfg(not(stage0))]\n+    static sctable_key: local_data::Key<@@mut SCTable> = &local_data::Key;\n+    #[cfg(stage0)]\n+    fn sctable_key(_: @@mut SCTable) {}\n+    match local_data::get(sctable_key, |k| k.map(|&k| *k)) {\n+        None => {\n+            let new_table = @@mut new_sctable_internal();\n+            local_data::set(sctable_key,new_table);\n+            *new_table\n+        },\n+        Some(intr) => *intr\n     }\n }\n "}, {"sha": "b45cde6a8e342dacc45985604f52a50d89e5d80e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -579,11 +579,13 @@ pub fn core_macros() -> @str {\n         { pub $c:ident: $in:ty -> $out:ty; } => {\n \n             pub mod $c {\n-                fn key(_x: @::std::condition::Handler<$in,$out>) { }\n+                #[allow(non_uppercase_statics)];\n+                static key: ::std::local_data::Key<\n+                    @::std::condition::Handler<$in, $out>> =\n+                    &::std::local_data::Key;\n \n-                #[allow(non_uppercase_statics)]\n                 pub static cond :\n-                    ::std::condition::Condition<'static,$in,$out> =\n+                    ::std::condition::Condition<$in,$out> =\n                     ::std::condition::Condition {\n                         name: stringify!($c),\n                         key: key\n@@ -595,11 +597,13 @@ pub fn core_macros() -> @str {\n \n             // FIXME (#6009): remove mod's `pub` below once variant above lands.\n             pub mod $c {\n-                fn key(_x: @::std::condition::Handler<$in,$out>) { }\n+                #[allow(non_uppercase_statics)];\n+                static key: ::std::local_data::Key<\n+                    @::std::condition::Handler<$in, $out>> =\n+                    &::std::local_data::Key;\n \n-                #[allow(non_uppercase_statics)]\n                 pub static cond :\n-                    ::std::condition::Condition<'static,$in,$out> =\n+                    ::std::condition::Condition<$in,$out> =\n                     ::std::condition::Condition {\n                         name: stringify!($c),\n                         key: key"}, {"sha": "5866b8a5af55d51f563a29c461b4c9133cbfa15e", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -144,7 +144,8 @@ pub struct protocol_ {\n impl protocol_ {\n     /// Get a state.\n     pub fn get_state(&self, name: &str) -> state {\n-        *self.states.iter().find_(|i| name == i.name).get()\n+        let mut i = self.states.iter();\n+        *i.find_(|i| name == i.name).get()\n     }\n \n     pub fn get_state_by_id(&self, id: uint) -> state { self.states[id] }"}, {"sha": "01860c3ae995bfe20c37224eb2e45bf069afd58e", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -15,7 +15,6 @@ use parse::token;\n use util::interner::StrInterner;\n use util::interner;\n \n-use std::cast;\n use std::cmp::Equiv;\n use std::local_data;\n use std::rand;\n@@ -485,18 +484,17 @@ fn mk_fresh_ident_interner() -> @ident_interner {\n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n pub fn get_ident_interner() -> @ident_interner {\n-    unsafe {\n-        let key =\n-            (cast::transmute::<(uint, uint),\n-             &fn:Copy(v: @@::parse::token::ident_interner)>(\n-                 (-3 as uint, 0u)));\n-        match local_data::get(key, |k| k.map(|&k| *k)) {\n-            Some(interner) => *interner,\n-            None => {\n-                let interner = mk_fresh_ident_interner();\n-                local_data::set(key, @interner);\n-                interner\n-            }\n+    #[cfg(not(stage0))]\n+    static key: local_data::Key<@@::parse::token::ident_interner> =\n+        &local_data::Key;\n+    #[cfg(stage0)]\n+    fn key(_: @@::parse::token::ident_interner) {}\n+    match local_data::get(key, |k| k.map(|&k| *k)) {\n+        Some(interner) => *interner,\n+        None => {\n+            let interner = mk_fresh_ident_interner();\n+            local_data::set(key, @interner);\n+            interner\n         }\n     }\n }"}, {"sha": "7a1e9923ab72031f0ffa2feb1e81e7728c6cf73d", "filename": "src/libsyntax/syntax.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibsyntax%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Flibsyntax%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -20,8 +20,6 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[allow(non_camel_case_types)];\n-#[allow(non_uppercase_statics)];\n #[deny(deprecated_pattern)];\n \n extern mod extra;"}, {"sha": "576b1c452a5ecccb05d4e408203639022967512c", "filename": "src/test/compile-fail/core-tls-store-pointer.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c35ab322ff2f26962a3550fffc2fa4154224b64/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs?ref=1c35ab322ff2f26962a3550fffc2fa4154224b64", "patch": "@@ -12,10 +12,7 @@\n \n use std::local_data;\n \n-fn key(_x: @&int) { }\n+static key: local_data::Key<@&int> = &local_data::Key;\n+//~^ ERROR only 'static is allowed\n \n-fn main() {\n-    unsafe {\n-        local_data::set(key, @&0); //~ ERROR does not fulfill `'static`\n-    }\n-}\n+fn main() {}"}]}