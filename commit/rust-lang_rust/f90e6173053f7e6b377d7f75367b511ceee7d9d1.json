{"sha": "f90e6173053f7e6b377d7f75367b511ceee7d9d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MGU2MTczMDUzZjdlNmIzNzdkN2Y3NTM2N2I1MTFjZWVlN2Q5ZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-19T15:14:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-19T15:14:15Z"}, "message": "Auto merge of #77908 - bugadani:obl-forest, r=nnethercote\n\nTry to make ObligationForest more efficient\n\nThis PR tries to decrease the number of allocations in ObligationForest, as well as moves some cold path code to an uninlined function.", "tree": {"sha": "04cae106c4a83518e04e5ffb51c8492aad63b90c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04cae106c4a83518e04e5ffb51c8492aad63b90c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f90e6173053f7e6b377d7f75367b511ceee7d9d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f90e6173053f7e6b377d7f75367b511ceee7d9d1", "html_url": "https://github.com/rust-lang/rust/commit/f90e6173053f7e6b377d7f75367b511ceee7d9d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f90e6173053f7e6b377d7f75367b511ceee7d9d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb2462c53f2cc3f140c0f1ea0976261cab968a34", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb2462c53f2cc3f140c0f1ea0976261cab968a34", "html_url": "https://github.com/rust-lang/rust/commit/cb2462c53f2cc3f140c0f1ea0976261cab968a34"}, {"sha": "8c7a8a62ddffe8bd9c144a8647a31c8138366f42", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7a8a62ddffe8bd9c144a8647a31c8138366f42", "html_url": "https://github.com/rust-lang/rust/commit/8c7a8a62ddffe8bd9c144a8647a31c8138366f42"}], "stats": {"total": 685, "additions": 329, "deletions": 356}, "files": [{"sha": "a5b2df1da5d6d8c6d83fab062cdaecbb7506caa1", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 64, "deletions": 52, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f90e6173053f7e6b377d7f75367b511ceee7d9d1/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90e6173053f7e6b377d7f75367b511ceee7d9d1/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=f90e6173053f7e6b377d7f75367b511ceee7d9d1", "patch": "@@ -149,8 +149,8 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// comments in `process_obligation` for details.\n     active_cache: FxHashMap<O::CacheKey, usize>,\n \n-    /// A vector reused in compress(), to avoid allocating new vectors.\n-    node_rewrites: Vec<usize>,\n+    /// A vector reused in compress() and find_cycles_from_node(), to avoid allocating new vectors.\n+    reused_node_vec: Vec<usize>,\n \n     obligation_tree_id_generator: ObligationTreeIdGenerator,\n \n@@ -251,12 +251,22 @@ enum NodeState {\n     Error,\n }\n \n+/// This trait allows us to have two different Outcome types:\n+///  - the normal one that does as little as possible\n+///  - one for tests that does some additional work and checking\n+pub trait OutcomeTrait {\n+    type Error;\n+    type Obligation;\n+\n+    fn new() -> Self;\n+    fn mark_not_stalled(&mut self);\n+    fn is_stalled(&self) -> bool;\n+    fn record_completed(&mut self, outcome: &Self::Obligation);\n+    fn record_error(&mut self, error: Self::Error);\n+}\n+\n #[derive(Debug)]\n pub struct Outcome<O, E> {\n-    /// Obligations that were completely evaluated, including all\n-    /// (transitive) subobligations. Only computed if requested.\n-    pub completed: Option<Vec<O>>,\n-\n     /// Backtrace of obligations that were found to be in error.\n     pub errors: Vec<Error<O, E>>,\n \n@@ -269,12 +279,29 @@ pub struct Outcome<O, E> {\n     pub stalled: bool,\n }\n \n-/// Should `process_obligations` compute the `Outcome::completed` field of its\n-/// result?\n-#[derive(PartialEq)]\n-pub enum DoCompleted {\n-    No,\n-    Yes,\n+impl<O, E> OutcomeTrait for Outcome<O, E> {\n+    type Error = Error<O, E>;\n+    type Obligation = O;\n+\n+    fn new() -> Self {\n+        Self { stalled: true, errors: vec![] }\n+    }\n+\n+    fn mark_not_stalled(&mut self) {\n+        self.stalled = false;\n+    }\n+\n+    fn is_stalled(&self) -> bool {\n+        self.stalled\n+    }\n+\n+    fn record_completed(&mut self, _outcome: &Self::Obligation) {\n+        // do nothing\n+    }\n+\n+    fn record_error(&mut self, error: Self::Error) {\n+        self.errors.push(error)\n+    }\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -289,7 +316,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             nodes: vec![],\n             done_cache: Default::default(),\n             active_cache: Default::default(),\n-            node_rewrites: vec![],\n+            reused_node_vec: vec![],\n             obligation_tree_id_generator: (0..).map(ObligationTreeId),\n             error_cache: Default::default(),\n         }\n@@ -363,8 +390,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             .map(|(index, _node)| Error { error: error.clone(), backtrace: self.error_at(index) })\n             .collect();\n \n-        let successful_obligations = self.compress(DoCompleted::Yes);\n-        assert!(successful_obligations.unwrap().is_empty());\n+        self.compress(|_| assert!(false));\n         errors\n     }\n \n@@ -392,16 +418,12 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// be called in a loop until `outcome.stalled` is false.\n     ///\n     /// This _cannot_ be unrolled (presently, at least).\n-    pub fn process_obligations<P>(\n-        &mut self,\n-        processor: &mut P,\n-        do_completed: DoCompleted,\n-    ) -> Outcome<O, P::Error>\n+    pub fn process_obligations<P, OUT>(&mut self, processor: &mut P) -> OUT\n     where\n         P: ObligationProcessor<Obligation = O>,\n+        OUT: OutcomeTrait<Obligation = O, Error = Error<O, P::Error>>,\n     {\n-        let mut errors = vec![];\n-        let mut stalled = true;\n+        let mut outcome = OUT::new();\n \n         // Note that the loop body can append new nodes, and those new nodes\n         // will then be processed by subsequent iterations of the loop.\n@@ -429,7 +451,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 }\n                 ProcessResult::Changed(children) => {\n                     // We are not (yet) stalled.\n-                    stalled = false;\n+                    outcome.mark_not_stalled();\n                     node.state.set(NodeState::Success);\n \n                     for child in children {\n@@ -442,28 +464,22 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     }\n                 }\n                 ProcessResult::Error(err) => {\n-                    stalled = false;\n-                    errors.push(Error { error: err, backtrace: self.error_at(index) });\n+                    outcome.mark_not_stalled();\n+                    outcome.record_error(Error { error: err, backtrace: self.error_at(index) });\n                 }\n             }\n             index += 1;\n         }\n \n-        if stalled {\n-            // There's no need to perform marking, cycle processing and compression when nothing\n-            // changed.\n-            return Outcome {\n-                completed: if do_completed == DoCompleted::Yes { Some(vec![]) } else { None },\n-                errors,\n-                stalled,\n-            };\n+        // There's no need to perform marking, cycle processing and compression when nothing\n+        // changed.\n+        if !outcome.is_stalled() {\n+            self.mark_successes();\n+            self.process_cycles(processor);\n+            self.compress(|obl| outcome.record_completed(obl));\n         }\n \n-        self.mark_successes();\n-        self.process_cycles(processor);\n-        let completed = self.compress(do_completed);\n-\n-        Outcome { completed, errors, stalled }\n+        outcome\n     }\n \n     /// Returns a vector of obligations for `p` and all of its\n@@ -526,7 +542,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n             let node = &self.nodes[index];\n             let state = node.state.get();\n             if state == NodeState::Success {\n-                node.state.set(NodeState::Waiting);\n                 // This call site is cold.\n                 self.uninlined_mark_dependents_as_waiting(node);\n             } else {\n@@ -538,17 +553,18 @@ impl<O: ForestObligation> ObligationForest<O> {\n     // This never-inlined function is for the cold call site.\n     #[inline(never)]\n     fn uninlined_mark_dependents_as_waiting(&self, node: &Node<O>) {\n+        // Mark node Waiting in the cold uninlined code instead of the hot inlined\n+        node.state.set(NodeState::Waiting);\n         self.inlined_mark_dependents_as_waiting(node)\n     }\n \n     /// Report cycles between all `Success` nodes, and convert all `Success`\n     /// nodes to `Done`. This must be called after `mark_successes`.\n-    fn process_cycles<P>(&self, processor: &mut P)\n+    fn process_cycles<P>(&mut self, processor: &mut P)\n     where\n         P: ObligationProcessor<Obligation = O>,\n     {\n-        let mut stack = vec![];\n-\n+        let mut stack = std::mem::take(&mut self.reused_node_vec);\n         for (index, node) in self.nodes.iter().enumerate() {\n             // For some benchmarks this state test is extremely hot. It's a win\n             // to handle the no-op cases immediately to avoid the cost of the\n@@ -559,6 +575,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         }\n \n         debug_assert!(stack.is_empty());\n+        self.reused_node_vec = stack;\n     }\n \n     fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, index: usize)\n@@ -591,13 +608,12 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// indices and hence invalidates any outstanding indices. `process_cycles`\n     /// must be run beforehand to remove any cycles on `Success` nodes.\n     #[inline(never)]\n-    fn compress(&mut self, do_completed: DoCompleted) -> Option<Vec<O>> {\n+    fn compress(&mut self, mut outcome_cb: impl FnMut(&O)) {\n         let orig_nodes_len = self.nodes.len();\n-        let mut node_rewrites: Vec<_> = std::mem::take(&mut self.node_rewrites);\n+        let mut node_rewrites: Vec<_> = std::mem::take(&mut self.reused_node_vec);\n         debug_assert!(node_rewrites.is_empty());\n         node_rewrites.extend(0..orig_nodes_len);\n         let mut dead_nodes = 0;\n-        let mut removed_done_obligations: Vec<O> = vec![];\n \n         // Move removable nodes to the end, preserving the order of the\n         // remaining nodes.\n@@ -627,10 +643,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     } else {\n                         self.done_cache.insert(node.obligation.as_cache_key().clone());\n                     }\n-                    if do_completed == DoCompleted::Yes {\n-                        // Extract the success stories.\n-                        removed_done_obligations.push(node.obligation.clone());\n-                    }\n+                    // Extract the success stories.\n+                    outcome_cb(&node.obligation);\n                     node_rewrites[index] = orig_nodes_len;\n                     dead_nodes += 1;\n                 }\n@@ -654,9 +668,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         }\n \n         node_rewrites.truncate(0);\n-        self.node_rewrites = node_rewrites;\n-\n-        if do_completed == DoCompleted::Yes { Some(removed_done_obligations) } else { None }\n+        self.reused_node_vec = node_rewrites;\n     }\n \n     fn apply_rewrites(&mut self, node_rewrites: &[usize]) {"}, {"sha": "371c62c063fa79a90feec7e708a1cdce32473d6e", "filename": "compiler/rustc_data_structures/src/obligation_forest/tests.rs", "status": "modified", "additions": 261, "deletions": 298, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/f90e6173053f7e6b377d7f75367b511ceee7d9d1/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90e6173053f7e6b377d7f75367b511ceee7d9d1/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs?ref=f90e6173053f7e6b377d7f75367b511ceee7d9d1", "patch": "@@ -17,6 +17,40 @@ struct ClosureObligationProcessor<OF, BF, O, E> {\n     marker: PhantomData<(O, E)>,\n }\n \n+struct TestOutcome<O, E> {\n+    pub completed: Vec<O>,\n+    pub errors: Vec<Error<O, E>>,\n+    pub stalled: bool,\n+}\n+\n+impl<O, E> OutcomeTrait for TestOutcome<O, E>\n+where\n+    O: Clone,\n+{\n+    type Error = Error<O, E>;\n+    type Obligation = O;\n+\n+    fn new() -> Self {\n+        Self { errors: vec![], stalled: false, completed: vec![] }\n+    }\n+\n+    fn mark_not_stalled(&mut self) {\n+        self.stalled = false;\n+    }\n+\n+    fn is_stalled(&self) -> bool {\n+        self.stalled\n+    }\n+\n+    fn record_completed(&mut self, outcome: &Self::Obligation) {\n+        self.completed.push(outcome.clone())\n+    }\n+\n+    fn record_error(&mut self, error: Self::Error) {\n+        self.errors.push(error)\n+    }\n+}\n+\n #[allow(non_snake_case)]\n fn C<OF, BF, O>(of: OF, bf: BF) -> ClosureObligationProcessor<OF, BF, O, &'static str>\n where\n@@ -65,20 +99,17 @@ fn push_pop() {\n     //      A |-> A.1\n     //        |-> A.2\n     //        |-> A.3\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n-                \"B\" => ProcessResult::Error(\"B is for broken\"),\n-                \"C\" => ProcessResult::Changed(vec![]),\n-                \"A.1\" | \"A.2\" | \"A.3\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap(), vec![\"C\"]);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n+            \"B\" => ProcessResult::Error(\"B is for broken\"),\n+            \"C\" => ProcessResult::Changed(vec![]),\n+            \"A.1\" | \"A.2\" | \"A.3\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok, vec![\"C\"]);\n     assert_eq!(err, vec![Error { error: \"B is for broken\", backtrace: vec![\"B\"] }]);\n \n     // second round: two delays, one success, creating an uneven set of subtasks:\n@@ -88,60 +119,51 @@ fn push_pop() {\n     //      D |-> D.1\n     //        |-> D.2\n     forest.register_obligation(\"D\");\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A.1\" => ProcessResult::Unchanged,\n-                \"A.2\" => ProcessResult::Unchanged,\n-                \"A.3\" => ProcessResult::Changed(vec![\"A.3.i\"]),\n-                \"D\" => ProcessResult::Changed(vec![\"D.1\", \"D.2\"]),\n-                \"A.3.i\" | \"D.1\" | \"D.2\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap(), Vec::<&'static str>::new());\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A.1\" => ProcessResult::Unchanged,\n+            \"A.2\" => ProcessResult::Unchanged,\n+            \"A.3\" => ProcessResult::Changed(vec![\"A.3.i\"]),\n+            \"D\" => ProcessResult::Changed(vec![\"D.1\", \"D.2\"]),\n+            \"A.3.i\" | \"D.1\" | \"D.2\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok, Vec::<&'static str>::new());\n     assert_eq!(err, Vec::new());\n \n     // third round: ok in A.1 but trigger an error in A.2. Check that it\n     // propagates to A, but not D.1 or D.2.\n     //      D |-> D.1 |-> D.1.i\n     //        |-> D.2 |-> D.2.i\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A.1\" => ProcessResult::Changed(vec![]),\n-                \"A.2\" => ProcessResult::Error(\"A is for apple\"),\n-                \"A.3.i\" => ProcessResult::Changed(vec![]),\n-                \"D.1\" => ProcessResult::Changed(vec![\"D.1.i\"]),\n-                \"D.2\" => ProcessResult::Changed(vec![\"D.2.i\"]),\n-                \"D.1.i\" | \"D.2.i\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    let mut ok = ok.unwrap();\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A.1\" => ProcessResult::Changed(vec![]),\n+            \"A.2\" => ProcessResult::Error(\"A is for apple\"),\n+            \"A.3.i\" => ProcessResult::Changed(vec![]),\n+            \"D.1\" => ProcessResult::Changed(vec![\"D.1.i\"]),\n+            \"D.2\" => ProcessResult::Changed(vec![\"D.2.i\"]),\n+            \"D.1.i\" | \"D.2.i\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    let mut ok = ok;\n     ok.sort();\n     assert_eq!(ok, vec![\"A.1\", \"A.3\", \"A.3.i\"]);\n     assert_eq!(err, vec![Error { error: \"A is for apple\", backtrace: vec![\"A.2\", \"A\"] }]);\n \n     // fourth round: error in D.1.i\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"D.1.i\" => ProcessResult::Error(\"D is for dumb\"),\n-                \"D.2.i\" => ProcessResult::Changed(vec![]),\n-                _ => panic!(\"unexpected obligation {:?}\", obligation),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    let mut ok = ok.unwrap();\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"D.1.i\" => ProcessResult::Error(\"D is for dumb\"),\n+            \"D.2.i\" => ProcessResult::Changed(vec![]),\n+            _ => panic!(\"unexpected obligation {:?}\", obligation),\n+        },\n+        |_| {},\n+    ));\n+    let mut ok = ok;\n     ok.sort();\n     assert_eq!(ok, vec![\"D.2\", \"D.2.i\"]);\n     assert_eq!(err, vec![Error { error: \"D is for dumb\", backtrace: vec![\"D.1.i\", \"D.1\", \"D\"] }]);\n@@ -160,72 +182,60 @@ fn success_in_grandchildren() {\n     let mut forest = ObligationForest::new();\n     forest.register_obligation(\"A\");\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n-                \"A.1\" => ProcessResult::Changed(vec![]),\n-                \"A.2\" => ProcessResult::Changed(vec![\"A.2.i\", \"A.2.ii\"]),\n-                \"A.3\" => ProcessResult::Changed(vec![]),\n-                \"A.2.i\" | \"A.2.ii\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    let mut ok = ok.unwrap();\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n+            \"A.1\" => ProcessResult::Changed(vec![]),\n+            \"A.2\" => ProcessResult::Changed(vec![\"A.2.i\", \"A.2.ii\"]),\n+            \"A.3\" => ProcessResult::Changed(vec![]),\n+            \"A.2.i\" | \"A.2.ii\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    let mut ok = ok;\n     ok.sort();\n     assert_eq!(ok, vec![\"A.1\", \"A.3\"]);\n     assert!(err.is_empty());\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A.2.i\" => ProcessResult::Unchanged,\n-                \"A.2.ii\" => ProcessResult::Changed(vec![]),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap(), vec![\"A.2.ii\"]);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A.2.i\" => ProcessResult::Unchanged,\n+            \"A.2.ii\" => ProcessResult::Changed(vec![]),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok, vec![\"A.2.ii\"]);\n     assert!(err.is_empty());\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A.2.i\" => ProcessResult::Changed(vec![\"A.2.i.a\"]),\n-                \"A.2.i.a\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert!(ok.unwrap().is_empty());\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A.2.i\" => ProcessResult::Changed(vec![\"A.2.i.a\"]),\n+            \"A.2.i.a\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert!(ok.is_empty());\n     assert!(err.is_empty());\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A.2.i.a\" => ProcessResult::Changed(vec![]),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    let mut ok = ok.unwrap();\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A.2.i.a\" => ProcessResult::Changed(vec![]),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    let mut ok = ok;\n     ok.sort();\n     assert_eq!(ok, vec![\"A\", \"A.2\", \"A.2.i\", \"A.2.i.a\"]);\n     assert!(err.is_empty());\n \n-    let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations(&mut C(|_| unreachable!(), |_| {}), DoCompleted::Yes);\n+    let TestOutcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|_| unreachable!(), |_| {}));\n \n-    assert!(ok.unwrap().is_empty());\n+    assert!(ok.is_empty());\n     assert!(err.is_empty());\n }\n \n@@ -235,18 +245,15 @@ fn to_errors_no_throw() {\n     // yields to correct errors (and does not panic, in particular).\n     let mut forest = ObligationForest::new();\n     forest.register_obligation(\"A\");\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n-                \"A.1\" | \"A.2\" | \"A.3\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n+            \"A.1\" | \"A.2\" | \"A.3\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err.len(), 0);\n     let errors = forest.to_errors(());\n     assert_eq!(errors[0].backtrace, vec![\"A.1\", \"A\"]);\n@@ -260,51 +267,42 @@ fn diamond() {\n     // check that diamond dependencies are handled correctly\n     let mut forest = ObligationForest::new();\n     forest.register_obligation(\"A\");\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\"]),\n-                \"A.1\" | \"A.2\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\"]),\n+            \"A.1\" | \"A.2\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err.len(), 0);\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A.1\" => ProcessResult::Changed(vec![\"D\"]),\n-                \"A.2\" => ProcessResult::Changed(vec![\"D\"]),\n-                \"D\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A.1\" => ProcessResult::Changed(vec![\"D\"]),\n+            \"A.2\" => ProcessResult::Changed(vec![\"D\"]),\n+            \"D\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err.len(), 0);\n \n     let mut d_count = 0;\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"D\" => {\n-                    d_count += 1;\n-                    ProcessResult::Changed(vec![])\n-                }\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"D\" => {\n+                d_count += 1;\n+                ProcessResult::Changed(vec![])\n+            }\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n     assert_eq!(d_count, 1);\n-    let mut ok = ok.unwrap();\n+    let mut ok = ok;\n     ok.sort();\n     assert_eq!(ok, vec![\"A\", \"A.1\", \"A.2\", \"D\"]);\n     assert_eq!(err.len(), 0);\n@@ -313,51 +311,42 @@ fn diamond() {\n     assert_eq!(errors.len(), 0);\n \n     forest.register_obligation(\"A'\");\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A'\" => ProcessResult::Changed(vec![\"A'.1\", \"A'.2\"]),\n-                \"A'.1\" | \"A'.2\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A'\" => ProcessResult::Changed(vec![\"A'.1\", \"A'.2\"]),\n+            \"A'.1\" | \"A'.2\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err.len(), 0);\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A'.1\" => ProcessResult::Changed(vec![\"D'\", \"A'\"]),\n-                \"A'.2\" => ProcessResult::Changed(vec![\"D'\"]),\n-                \"D'\" | \"A'\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A'.1\" => ProcessResult::Changed(vec![\"D'\", \"A'\"]),\n+            \"A'.2\" => ProcessResult::Changed(vec![\"D'\"]),\n+            \"D'\" | \"A'\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err.len(), 0);\n \n     let mut d_count = 0;\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"D'\" => {\n-                    d_count += 1;\n-                    ProcessResult::Error(\"operation failed\")\n-                }\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"D'\" => {\n+                d_count += 1;\n+                ProcessResult::Error(\"operation failed\")\n+            }\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n     assert_eq!(d_count, 1);\n-    assert_eq!(ok.unwrap().len(), 0);\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(\n         err,\n         vec![super::Error { error: \"operation failed\", backtrace: vec![\"D'\", \"A'.1\", \"A'\"] }]\n@@ -375,35 +364,27 @@ fn done_dependency() {\n     forest.register_obligation(\"B: Sized\");\n     forest.register_obligation(\"C: Sized\");\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A: Sized\" | \"B: Sized\" | \"C: Sized\" => ProcessResult::Changed(vec![]),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    let mut ok = ok.unwrap();\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A: Sized\" | \"B: Sized\" | \"C: Sized\" => ProcessResult::Changed(vec![]),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    let mut ok = ok;\n     ok.sort();\n     assert_eq!(ok, vec![\"A: Sized\", \"B: Sized\", \"C: Sized\"]);\n     assert_eq!(err.len(), 0);\n \n     forest.register_obligation(\"(A,B,C): Sized\");\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"(A,B,C): Sized\" => {\n-                    ProcessResult::Changed(vec![\"A: Sized\", \"B: Sized\", \"C: Sized\"])\n-                }\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap(), vec![\"(A,B,C): Sized\"]);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"(A,B,C): Sized\" => ProcessResult::Changed(vec![\"A: Sized\", \"B: Sized\", \"C: Sized\"]),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok, vec![\"(A,B,C): Sized\"]);\n     assert_eq!(err.len(), 0);\n }\n \n@@ -416,64 +397,52 @@ fn orphan() {\n     forest.register_obligation(\"C1\");\n     forest.register_obligation(\"C2\");\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A\" => ProcessResult::Changed(vec![\"D\", \"E\"]),\n-                \"B\" => ProcessResult::Unchanged,\n-                \"C1\" => ProcessResult::Changed(vec![]),\n-                \"C2\" => ProcessResult::Changed(vec![]),\n-                \"D\" | \"E\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    let mut ok = ok.unwrap();\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A\" => ProcessResult::Changed(vec![\"D\", \"E\"]),\n+            \"B\" => ProcessResult::Unchanged,\n+            \"C1\" => ProcessResult::Changed(vec![]),\n+            \"C2\" => ProcessResult::Changed(vec![]),\n+            \"D\" | \"E\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    let mut ok = ok;\n     ok.sort();\n     assert_eq!(ok, vec![\"C1\", \"C2\"]);\n     assert_eq!(err.len(), 0);\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"D\" | \"E\" => ProcessResult::Unchanged,\n-                \"B\" => ProcessResult::Changed(vec![\"D\"]),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"D\" | \"E\" => ProcessResult::Unchanged,\n+            \"B\" => ProcessResult::Changed(vec![\"D\"]),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err.len(), 0);\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"D\" => ProcessResult::Unchanged,\n-                \"E\" => ProcessResult::Error(\"E is for error\"),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"D\" => ProcessResult::Unchanged,\n+            \"E\" => ProcessResult::Error(\"E is for error\"),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err, vec![super::Error { error: \"E is for error\", backtrace: vec![\"E\", \"A\"] }]);\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"D\" => ProcessResult::Error(\"D is dead\"),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"D\" => ProcessResult::Error(\"D is dead\"),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err, vec![super::Error { error: \"D is dead\", backtrace: vec![\"D\"] }]);\n \n     let errors = forest.to_errors(());\n@@ -487,35 +456,29 @@ fn simultaneous_register_and_error() {\n     forest.register_obligation(\"A\");\n     forest.register_obligation(\"B\");\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A\" => ProcessResult::Error(\"An error\"),\n-                \"B\" => ProcessResult::Changed(vec![\"A\"]),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A\" => ProcessResult::Error(\"An error\"),\n+            \"B\" => ProcessResult::Changed(vec![\"A\"]),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err, vec![super::Error { error: \"An error\", backtrace: vec![\"A\"] }]);\n \n     let mut forest = ObligationForest::new();\n     forest.register_obligation(\"B\");\n     forest.register_obligation(\"A\");\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A\" => ProcessResult::Error(\"An error\"),\n-                \"B\" => ProcessResult::Changed(vec![\"A\"]),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A\" => ProcessResult::Error(\"An error\"),\n+            \"B\" => ProcessResult::Changed(vec![\"A\"]),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err, vec![super::Error { error: \"An error\", backtrace: vec![\"A\"] }]);\n }"}, {"sha": "9a8b5534dfe83089ec944691d47420707f13b743", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f90e6173053f7e6b377d7f75367b511ceee7d9d1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90e6173053f7e6b377d7f75367b511ceee7d9d1/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=f90e6173053f7e6b377d7f75367b511ceee7d9d1", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::{InferCtxt, TyOrConstInferVar};\n use rustc_data_structures::obligation_forest::ProcessResult;\n-use rustc_data_structures::obligation_forest::{DoCompleted, Error, ForestObligation};\n+use rustc_data_structures::obligation_forest::{Error, ForestObligation, Outcome};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n use rustc_errors::ErrorReported;\n use rustc_infer::traits::{TraitEngine, TraitEngineExt as _, TraitObligation};\n@@ -129,13 +129,11 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n             debug!(\"select: starting another iteration\");\n \n             // Process pending obligations.\n-            let outcome = self.predicates.process_obligations(\n-                &mut FulfillProcessor {\n+            let outcome: Outcome<_, _> =\n+                self.predicates.process_obligations(&mut FulfillProcessor {\n                     selcx,\n                     register_region_obligations: self.register_region_obligations,\n-                },\n-                DoCompleted::No,\n-            );\n+                });\n             debug!(\"select: outcome={:#?}\", outcome);\n \n             // FIXME: if we kept the original cache key, we could mark projection"}]}