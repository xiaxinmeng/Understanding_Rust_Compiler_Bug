{"sha": "c2d3f908867335e393ac549a9e9c18d6c75f2996", "node_id": "C_kwDOAAsO6NoAKGMyZDNmOTA4ODY3MzM1ZTM5M2FjNTQ5YTllOWMxOGQ2Yzc1ZjI5OTY", "commit": {"author": {"name": "C\u00f4me ALLART", "email": "come.allart@etu.emse.fr", "date": "2022-01-06T00:51:04Z"}, "committer": {"name": "C\u00f4me ALLART", "email": "come.allart@etu.emse.fr", "date": "2022-01-06T00:51:04Z"}, "message": "fix: remove brackets if no generic types", "tree": {"sha": "9ac08637cf6f184cb3e57477cb8e110764a45b73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ac08637cf6f184cb3e57477cb8e110764a45b73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2d3f908867335e393ac549a9e9c18d6c75f2996", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d3f908867335e393ac549a9e9c18d6c75f2996", "html_url": "https://github.com/rust-lang/rust/commit/c2d3f908867335e393ac549a9e9c18d6c75f2996", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2d3f908867335e393ac549a9e9c18d6c75f2996/comments", "author": null, "committer": null, "parents": [{"sha": "4a5341e0448d716e2ead16f89449543b63ee6f78", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a5341e0448d716e2ead16f89449543b63ee6f78", "html_url": "https://github.com/rust-lang/rust/commit/4a5341e0448d716e2ead16f89449543b63ee6f78"}], "stats": {"total": 109, "additions": 60, "deletions": 49}, "files": [{"sha": "97d1c2bd6d812ece04bd7e42ebdbc00dd965a86f", "filename": "crates/ide_assists/src/handlers/generate_documentation_template.rs", "status": "modified", "additions": 60, "deletions": 49, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/c2d3f908867335e393ac549a9e9c18d6c75f2996/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2d3f908867335e393ac549a9e9c18d6c75f2996/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs?ref=c2d3f908867335e393ac549a9e9c18d6c75f2996", "patch": "@@ -89,7 +89,7 @@ fn introduction_builder(ast_func: &ast::Fn, ctx: &AssistContext) -> String {\n             let is_new = ast_func.name()?.to_string() == \"new\";\n             match is_new && ret_ty == self_ty {\n                 true => {\n-                    Some(format!(\"Creates a new [`{}`].\", lifetimes_removed(&self_type(ast_func)?)))\n+                    Some(format!(\"Creates a new [`{}`].\", self_type_without_lifetimes(ast_func)?))\n                 }\n                 false => None,\n             }\n@@ -223,61 +223,32 @@ fn self_name(ast_func: &ast::Fn) -> Option<String> {\n }\n \n /// Heper function to get the name of the type of `self`\n-fn self_type(ast_func: &ast::Fn) -> Option<String> {\n-    ast_func\n-        .syntax()\n-        .ancestors()\n-        .find_map(ast::Impl::cast)\n-        .and_then(|i| i.self_ty())\n-        .map(|t| (t.to_string()))\n+fn self_type(ast_func: &ast::Fn) -> Option<ast::Type> {\n+    ast_func.syntax().ancestors().find_map(ast::Impl::cast).and_then(|i| i.self_ty())\n }\n \n-/// Output the same string as the input, removing lifetimes.\n-///\n-/// Lifetimes are detected as starting with a `'` and ending with `,\\s*` or before a `>`.\n-fn lifetimes_removed(with_lifetimes: &str) -> String {\n-    #[derive(Debug)]\n-    enum State {\n-        OutOfLifetime,\n-        AfterLifetime,\n-        InLifetime,\n-    }\n-\n-    let mut state = State::OutOfLifetime;\n-    let mut without_lifetimes = String::new();\n-    for c in with_lifetimes.chars() {\n-        match state {\n-            State::OutOfLifetime => {\n-                if c == '\\'' {\n-                    state = State::InLifetime;\n-                } else {\n-                    without_lifetimes.push(c);\n-                }\n-            }\n-            State::InLifetime => {\n-                if c == ',' {\n-                    state = State::AfterLifetime;\n-                } else if c == '>' {\n-                    without_lifetimes.push(c);\n-                    state = State::OutOfLifetime;\n-                }\n-            }\n-            State::AfterLifetime => {\n-                if c == '\\'' {\n-                    state = State::InLifetime;\n-                } else if !c.is_whitespace() {\n-                    without_lifetimes.push(c);\n-                    state = State::OutOfLifetime;\n-                }\n-            }\n-        }\n+/// Output the real name of `Self` like `MyType<T>`, without the lifetimes.\n+fn self_type_without_lifetimes(ast_func: &ast::Fn) -> Option<String> {\n+    let path_segment =\n+        ast::PathType::cast(self_type(ast_func)?.syntax().clone())?.path()?.segment()?;\n+    let mut name = path_segment.name_ref()?.to_string();\n+    let generics = path_segment\n+        .generic_arg_list()?\n+        .generic_args()\n+        .filter(|generic| matches!(generic, ast::GenericArg::TypeArg(_)))\n+        .map(|generic| generic.to_string());\n+    let generics: String = Itertools::intersperse(generics, \", \".to_string()).collect();\n+    if !generics.is_empty() {\n+        name.push('<');\n+        name.push_str(&generics);\n+        name.push('>');\n     }\n-    without_lifetimes\n+    Some(name)\n }\n \n /// Heper function to get the name of the type of `self` without generic arguments\n fn self_partial_type(ast_func: &ast::Fn) -> Option<String> {\n-    let mut self_type = self_type(ast_func)?;\n+    let mut self_type = self_type(ast_func)?.to_string();\n     if let Some(idx) = self_type.find(|c| ['<', ' '].contains(&c)) {\n         self_type.truncate(idx);\n     }\n@@ -1114,6 +1085,46 @@ impl<'a, 'b, T> MyGenericStruct<'a, 'b, T> {\n         );\n     }\n \n+    #[test]\n+    fn removes_all_lifetimes_and_brackets_from_description() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+#[derive(Debug, PartialEq)]\n+pub struct MyGenericStruct<'a, 'b> {\n+    pub x: &'a usize,\n+    pub y: &'b usize,\n+}\n+impl<'a, 'b> MyGenericStruct<'a, 'b> {\n+    pub fn new$0(x: &'a usize, y: &'b usize) -> Self {\n+        MyGenericStruct { x, y }\n+    }\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug, PartialEq)]\n+pub struct MyGenericStruct<'a, 'b> {\n+    pub x: &'a usize,\n+    pub y: &'b usize,\n+}\n+impl<'a, 'b> MyGenericStruct<'a, 'b> {\n+    /// Creates a new [`MyGenericStruct`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::MyGenericStruct;\n+    ///\n+    /// assert_eq!(MyGenericStruct::new(x, y), );\n+    /// ```\n+    pub fn new(x: &'a usize, y: &'b usize) -> Self {\n+        MyGenericStruct { x, y }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn detects_new_with_self() {\n         check_assist("}]}