{"sha": "a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2YTMxZWNiMDQ4MWFmM2JkNWY4YmEzNjU1ZGRhMGRkZTlkZjcxMTY=", "commit": {"author": {"name": "klutzy", "email": "klutzytheklutzy@gmail.com", "date": "2014-01-10T15:22:06Z"}, "committer": {"name": "klutzy", "email": "klutzytheklutzy@gmail.com", "date": "2014-01-22T18:03:55Z"}, "message": "rustpkg::crate_id: Remove CrateId\n\nThere is no significant difference between `rustpkg::crate_id::CrateId`\nand `syntax::crateid::CrateId`. rustpkg's one is replaced by syntax's\none.", "tree": {"sha": "59f55e23be54a04d03224c7559a42ef38651b28c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59f55e23be54a04d03224c7559a42ef38651b28c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "comment_count": 13, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "html_url": "https://github.com/rust-lang/rust/commit/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/comments", "author": {"login": "klutzy", "id": 1589355, "node_id": "MDQ6VXNlcjE1ODkzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1589355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klutzy", "html_url": "https://github.com/klutzy", "followers_url": "https://api.github.com/users/klutzy/followers", "following_url": "https://api.github.com/users/klutzy/following{/other_user}", "gists_url": "https://api.github.com/users/klutzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klutzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klutzy/subscriptions", "organizations_url": "https://api.github.com/users/klutzy/orgs", "repos_url": "https://api.github.com/users/klutzy/repos", "events_url": "https://api.github.com/users/klutzy/events{/privacy}", "received_events_url": "https://api.github.com/users/klutzy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "klutzy", "id": 1589355, "node_id": "MDQ6VXNlcjE1ODkzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1589355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klutzy", "html_url": "https://github.com/klutzy", "followers_url": "https://api.github.com/users/klutzy/followers", "following_url": "https://api.github.com/users/klutzy/following{/other_user}", "gists_url": "https://api.github.com/users/klutzy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klutzy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klutzy/subscriptions", "organizations_url": "https://api.github.com/users/klutzy/orgs", "repos_url": "https://api.github.com/users/klutzy/repos", "events_url": "https://api.github.com/users/klutzy/events{/privacy}", "received_events_url": "https://api.github.com/users/klutzy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df9067cd1597ba31b640a7ae6457aa04920f2631", "url": "https://api.github.com/repos/rust-lang/rust/commits/df9067cd1597ba31b640a7ae6457aa04920f2631", "html_url": "https://github.com/rust-lang/rust/commit/df9067cd1597ba31b640a7ae6457aa04920f2631"}], "stats": {"total": 912, "additions": 413, "deletions": 499}, "files": [{"sha": "13d5a1177049b720a68c881ce92022366096f2ef", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "patch": "@@ -11,7 +11,6 @@\n use CtxMethods;\n use context::*;\n use crate::*;\n-use crate_id::*;\n use package_source::*;\n use path_util::{platform_library_name, target_build_dir};\n use target::*;\n@@ -26,6 +25,7 @@ use extra::arc::{Arc,RWArc};\n use extra::workcache;\n use extra::workcache::{Database, FreshnessMap};\n use extra::treemap::TreeMap;\n+use syntax::crateid::CrateId;\n \n // A little sad -- duplicated from rustc::back::*\n #[cfg(target_arch = \"arm\")]\n@@ -78,20 +78,19 @@ pub fn new_workcache_context(p: &Path) -> workcache::Context {\n     workcache::Context::new_with_freshness(db, cfg, Arc::new(freshness))\n }\n \n-pub fn build_lib(sysroot: Path, root: Path, name: ~str, version: Option<~str>,\n-                 lib: Path) {\n-    build_lib_with_cfgs(sysroot, root, name, version, lib, ~[])\n+pub fn build_lib(sysroot: Path, root: Path, name: ~str, lib: Path) {\n+    build_lib_with_cfgs(sysroot, root, name, lib, ~[])\n }\n \n-pub fn build_lib_with_cfgs(sysroot: Path, root: Path, name: ~str,\n-                           version: Option<~str>, lib: Path, cfgs: ~[~str]) {\n+pub fn build_lib_with_cfgs(sysroot: Path, root: Path, name: ~str, lib: Path, cfgs: ~[~str]) {\n     let cx = default_context(sysroot, root.clone());\n+    let crate_id: CrateId = from_str(name).expect(\"valid crate id\");\n     let pkg_src = PkgSrc {\n         source_workspace: root.clone(),\n         build_in_destination: false,\n         destination_workspace: root.clone(),\n         start_dir: root.join_many([\"src\", name.as_slice()]),\n-        id: CrateId{ version: version, ..CrateId::new(name)},\n+        id: crate_id,\n         // n.b. This assumes the package only has one crate\n         libs: ~[mk_crate(lib)],\n         mains: ~[],\n@@ -101,20 +100,19 @@ pub fn build_lib_with_cfgs(sysroot: Path, root: Path, name: ~str,\n     pkg_src.build(&cx, cfgs, []);\n }\n \n-pub fn build_exe(sysroot: Path, root: Path, name: ~str, version: Option<~str>,\n-                 main: Path) {\n-    build_exe_with_cfgs(sysroot, root, name, version, main, ~[])\n+pub fn build_exe(sysroot: Path, root: Path, name: ~str, main: Path) {\n+    build_exe_with_cfgs(sysroot, root, name, main, ~[])\n }\n \n-pub fn build_exe_with_cfgs(sysroot: Path, root: Path, name: ~str,\n-                           version: Option<~str>, main: Path, cfgs: ~[~str]) {\n+pub fn build_exe_with_cfgs(sysroot: Path, root: Path, name: ~str, main: Path, cfgs: ~[~str]) {\n     let cx = default_context(sysroot, root.clone());\n+    let crate_id: CrateId = from_str(name).expect(\"valid crate id\");\n     let pkg_src = PkgSrc {\n         source_workspace: root.clone(),\n         build_in_destination: false,\n         destination_workspace: root.clone(),\n         start_dir: root.join_many([\"src\", name.as_slice()]),\n-        id: CrateId{ version: version, ..CrateId::new(name)},\n+        id: crate_id,\n         libs: ~[],\n         // n.b. This assumes the package only has one crate\n         mains: ~[mk_crate(main)],\n@@ -128,11 +126,10 @@ pub fn build_exe_with_cfgs(sysroot: Path, root: Path, name: ~str,\n pub fn install_pkg(cx: &BuildContext,\n                    workspace: Path,\n                    name: ~str,\n-                   version: Option<~str>,\n                    // For now, these inputs are assumed to be inputs to each of the crates\n                    more_inputs: ~[(~str, Path)]) { // pairs of Kind and Path\n-    let crateid = CrateId{ version: version, ..CrateId::new(name)};\n-    cx.install(PkgSrc::new(workspace.clone(), workspace, false, crateid),\n+    let crate_id: CrateId = from_str(name).expect(\"valid crate id\");\n+    cx.install(PkgSrc::new(workspace.clone(), workspace, false, crate_id),\n                &WhatToBuild{ build_type: Inferred,\n                              inputs_to_discover: more_inputs,\n                              sources: Everything });\n@@ -156,10 +153,10 @@ pub fn build_library_in_workspace(exec: &mut workcache::Exec,\n     let out_name = workspace_build_dir.join_many([package_name.to_str(),\n                                                   platform_library_name(output)]);\n     // make paths absolute\n-    let crateid = CrateId::new(package_name);\n+    let crateid: CrateId = from_str(package_name).expect(\"valid crate id\");\n     let absolute_paths = paths.map(|s| {\n             let whatever = workspace.join_many([~\"src\",\n-                                crateid.to_str(),\n+                                crateid.short_name_with_version(),\n                                 s.to_owned()]);\n             whatever.as_str().unwrap().to_owned()\n         });\n@@ -189,7 +186,7 @@ pub fn my_workspace(context: &Context, package_name: &str) -> Path {\n     use bad_pkg_id     = conditions::bad_pkg_id::cond;\n \n     // (this assumes no particular version is requested)\n-    let crateid = CrateId::new(package_name);\n+    let crateid = from_str(package_name).expect(\"valid crate id\");\n     let workspaces = pkg_parent_workspaces(context, &crateid);\n     if workspaces.is_empty() {\n         bad_pkg_id.raise((Path::new(package_name), package_name.to_owned()));"}, {"sha": "d18161d7c4a370b1c46bf40b0e70ec8317974722", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "patch": "@@ -10,7 +10,7 @@\n \n // Useful conditions\n \n-pub use crate_id::CrateId;\n+pub use syntax::crateid::CrateId;\n pub use std::io::FileStat;\n pub use std::io::process::ProcessExit;\n pub use std::path::Path;"}, {"sha": "4a87bcb70f50a586364595ff42549dfe2dc8a7c9", "filename": "src/librustpkg/crate_id.rs", "status": "removed", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/df9067cd1597ba31b640a7ae6457aa04920f2631/src%2Flibrustpkg%2Fcrate_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9067cd1597ba31b640a7ae6457aa04920f2631/src%2Flibrustpkg%2Fcrate_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcrate_id.rs?ref=df9067cd1597ba31b640a7ae6457aa04920f2631", "patch": "@@ -1,144 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::hash::Streaming;\n-use syntax::crateid;\n-use extra::hex::ToHex;\n-use rustc::util::sha2::{Digest, Sha256};\n-\n-/// Path-fragment identifier of a package such as\n-/// 'github.com/graydon/test'; path must be a relative\n-/// path with >=1 component.\n-#[deriving(Clone)]\n-pub struct CrateId {\n-    /// This is a path, on the local filesystem, referring to where the\n-    /// files for this package live. For example:\n-    /// github.com/mozilla/quux-whatever (it's assumed that if we're\n-    /// working with a package ID of this form, rustpkg has already cloned\n-    /// the sources into a local directory in the RUST_PATH).\n-    path: Path,\n-    /// Short name. This is the path's filestem, but we store it\n-    /// redundantly so as to not call get() everywhere (filestem() returns an\n-    /// option)\n-    /// The short name does not need to be a valid Rust identifier.\n-    /// Users can write: `extern mod foo = \"...\";` to get around the issue\n-    /// of package IDs whose short names aren't valid Rust identifiers.\n-    short_name: ~str,\n-    /// The requested package version.\n-    version: Option<~str>\n-}\n-\n-impl Eq for CrateId {\n-    fn eq(&self, other: &CrateId) -> bool {\n-        self.path == other.path && self.version == other.version\n-    }\n-}\n-\n-impl CrateId {\n-    pub fn version_or_default<'a>(&'a self) -> &'a str {\n-        match self.version {\n-            Some(ref ver) => ver.as_slice(),\n-            None => \"0.0\"\n-        }\n-    }\n-\n-    pub fn new(s: &str) -> CrateId {\n-        use conditions::bad_pkg_id::cond;\n-\n-        let raw_crateid: Option<crateid::CrateId> = from_str(s);\n-        if raw_crateid.is_none() {\n-            return cond.raise((Path::new(s), ~\"bad crateid\"))\n-        }\n-        let raw_crateid = raw_crateid.unwrap();\n-        let crateid::CrateId { path, name, version } = raw_crateid;\n-        let path = Path::new(path);\n-\n-        CrateId {\n-            path: path,\n-            short_name: name,\n-            version: version\n-        }\n-    }\n-\n-    pub fn to_crate_id_str(&self) -> ~str {\n-        format!(\"{}\\\\#{}\", self.path.as_str().unwrap(), self.version_or_default())\n-    }\n-\n-    pub fn to_lib_name(&self) -> ~str {\n-        format!(\"{}-{}-{}\", self.short_name, self.hash(), self.version_or_default())\n-    }\n-\n-    pub fn hash(&self) -> ~str {\n-        let mut hasher = Sha256::new();\n-        hasher.reset();\n-        hasher.input_str(self.to_crate_id_str());\n-        let hash = hasher.result_bytes().to_hex();\n-        hash.slice_chars(0, 8).to_owned()\n-    }\n-\n-    pub fn short_name_with_version(&self) -> ~str {\n-        format!(\"{}-{}\", self.short_name, self.version_or_default())\n-    }\n-\n-    /// True if the ID has multiple components\n-    pub fn is_complex(&self) -> bool {\n-        self.short_name.as_bytes() != self.path.as_vec()\n-    }\n-\n-    pub fn prefixes(&self) -> Prefixes {\n-        prefixes(&self.path)\n-    }\n-\n-    // This is the workcache function name for the *installed*\n-    // binaries for this package (as opposed to the built ones,\n-    // which are per-crate).\n-    pub fn install_tag(&self) -> ~str {\n-        format!(\"install({})\", self.to_str())\n-    }\n-}\n-\n-pub fn prefixes(p: &Path) -> Prefixes {\n-    Prefixes {\n-        components: p.str_components().map(|x|x.unwrap().to_owned()).to_owned_vec(),\n-        remaining: ~[]\n-    }\n-}\n-\n-struct Prefixes {\n-    priv components: ~[~str],\n-    priv remaining: ~[~str]\n-}\n-\n-impl Iterator<(Path, Path)> for Prefixes {\n-    #[inline]\n-    fn next(&mut self) -> Option<(Path, Path)> {\n-        if self.components.len() <= 1 {\n-            None\n-        }\n-        else {\n-            let last = self.components.pop().unwrap();\n-            self.remaining.unshift(last);\n-            // converting to str and then back is a little unfortunate\n-            Some((Path::new(self.components.connect(\"/\")),\n-                  Path::new(self.remaining.connect(\"/\"))))\n-        }\n-    }\n-}\n-\n-impl ToStr for CrateId {\n-    fn to_str(&self) -> ~str {\n-        // should probably use the filestem and not the whole path\n-        format!(\"{}-{}\", self.path.as_str().unwrap(), self.version_or_default())\n-    }\n-}\n-\n-pub fn write<W: Writer>(writer: &mut W, string: &str) {\n-    writer.write(string.as_bytes());\n-}"}, {"sha": "c7900181a77d15220d585a308269755d1c0de52b", "filename": "src/librustpkg/installed_packages.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Finstalled_packages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Finstalled_packages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Finstalled_packages.rs?ref=a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "patch": "@@ -11,10 +11,10 @@\n // Listing installed packages\n \n use rustc::metadata::filesearch::rust_path;\n-use path_util::*;\n use std::os;\n use std::io;\n use std::io::fs;\n+use syntax::crateid::CrateId;\n \n pub fn list_installed_packages(f: |&CrateId| -> bool) -> bool  {\n     let workspaces = rust_path();\n@@ -28,7 +28,8 @@ pub fn list_installed_packages(f: |&CrateId| -> bool) -> bool  {\n             match exec.filestem_str() {\n                 None => (),\n                 Some(exec_path) => {\n-                    if !f(&CrateId::new(exec_path)) {\n+                    let crate_id = from_str(exec_path).expect(\"valid crate id\");\n+                    if !f(&crate_id) {\n                         return false;\n                     }\n                 }\n@@ -50,7 +51,8 @@ pub fn list_installed_packages(f: |&CrateId| -> bool) -> bool  {\n                     let rel_path = rel_p.join(basename);\n                     rel_path.display().with_str(|s| {\n                         debug!(\"Rel name: {}\", s);\n-                        f(&CrateId::new(s));\n+                        let crate_id = from_str(s).expect(\"valid crate id\");\n+                        f(&crate_id);\n                     });\n                 }\n                 None => ()"}, {"sha": "e5e494e9b5f0c115c84bae81a0cca088a3bee052", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "patch": "@@ -33,6 +33,7 @@ use rustc::metadata::filesearch;\n use rustc::metadata::filesearch::rust_path;\n use rustc::util::sha2;\n use syntax::{ast, diagnostic};\n+use syntax::crateid::CrateId;\n use messages::{error, warn, note};\n use parse_args::{ParseResult, parse_args};\n use path_util::{build_pkg_id_in_workspace, built_test_in_workspace};\n@@ -46,7 +47,6 @@ use context::{BuildContext, Trans, Nothing, Pretty, Analysis,\n               LLVMAssemble, LLVMCompileBitcode};\n use context::{Command, BuildCmd, CleanCmd, DoCmd, HelpCmd, InfoCmd, InstallCmd, ListCmd,\n     PreferCmd, TestCmd, InitCmd, UninstallCmd, UnpreferCmd};\n-use crate_id::CrateId;\n use package_source::PkgSrc;\n use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench};\n use target::{Main, Tests, MaybeCustom, Inferred, JustOne};\n@@ -60,7 +60,6 @@ mod crate;\n pub mod exit_codes;\n mod installed_packages;\n mod messages;\n-pub mod crate_id;\n pub mod package_source;\n mod parse_args;\n mod path_util;\n@@ -103,7 +102,7 @@ impl<'a> PkgScript<'a> {\n                  workspace: &Path,\n                  id: &'a CrateId) -> PkgScript<'a> {\n         // Get the executable name that was invoked\n-        let binary = os::args()[0].to_owned();\n+        let binary = os::args()[0];\n         // Build the rustc session data structures to pass\n         // to the compiler\n         debug!(\"pkgscript parse: {}\", sysroot.display());\n@@ -244,7 +243,7 @@ impl CtxMethods for BuildContext {\n             match cwd_to_workspace() {\n                 None if dir_has_crate_file(&cwd) => {\n                     // FIXME (#9639): This needs to handle non-utf8 paths\n-                    let crateid = CrateId::new(cwd.filename_str().unwrap());\n+                    let crateid = from_str(cwd.filename_str().unwrap()).expect(\"valid crate id\");\n                     let mut pkg_src = PkgSrc::new(cwd, default_workspace(), true, crateid);\n                     self.build(&mut pkg_src, what);\n                     match pkg_src {\n@@ -269,7 +268,7 @@ impl CtxMethods for BuildContext {\n         } else {\n             // The package id is presumed to be the first command-line\n             // argument\n-            let crateid = CrateId::new(args[0].clone());\n+            let crateid = from_str(args[0]).expect(\"valid crate id\");\n             let mut dest_ws = default_workspace();\n             each_pkg_parent_workspace(&self.context, &crateid, |workspace| {\n                 debug!(\"found pkg {} in workspace {}, trying to build\",\n@@ -308,7 +307,7 @@ impl CtxMethods for BuildContext {\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n-                    let crateid = CrateId::new(args[0].clone());\n+                    let crateid = from_str(args[0]).expect(\"valid crate id\");\n                     self.clean(&cwd, &crateid); // tjc: should use workspace, not cwd\n                 }\n             }\n@@ -341,7 +340,7 @@ impl CtxMethods for BuildContext {\n                             // FIXME (#9639): This needs to handle non-utf8 paths\n \n                             let inferred_crateid =\n-                                CrateId::new(cwd.filename_str().unwrap());\n+                                from_str(cwd.filename_str().unwrap()).expect(\"valid crate id\");\n                             self.install(PkgSrc::new(cwd, default_workspace(),\n                                                      true, inferred_crateid),\n                                          &WhatToBuild::new(MaybeCustom, Everything));\n@@ -357,7 +356,7 @@ impl CtxMethods for BuildContext {\n                 else {\n                     // The package id is presumed to be the first command-line\n                     // argument\n-                    let crateid = CrateId::new(args[0]);\n+                    let crateid = from_str(args[0]).expect(\"valid crate id\");\n                     let workspaces = pkg_parent_workspaces(&self.context, &crateid);\n                     debug!(\"package ID = {}, found it in {:?} workspaces\",\n                            crateid.to_str(), workspaces.len());\n@@ -383,7 +382,7 @@ impl CtxMethods for BuildContext {\n             ListCmd => {\n                 println!(\"Installed packages:\");\n                 installed_packages::list_installed_packages(|pkg_id| {\n-                    pkg_id.path.display().with_str(|s| println!(\"{}\", s));\n+                    println!(\"{}\", pkg_id.path);\n                     true\n                 });\n             }\n@@ -420,7 +419,7 @@ impl CtxMethods for BuildContext {\n                     return usage::uninstall();\n                 }\n \n-                let crateid = CrateId::new(args[0]);\n+                let crateid = from_str(args[0]).expect(\"valid crate id\");\n                 if !installed_packages::package_is_installed(&crateid) {\n                     warn(format!(\"Package {} doesn't seem to be installed! \\\n                                   Doing nothing.\", args[0]));\n@@ -458,24 +457,24 @@ impl CtxMethods for BuildContext {\n         let workspace = pkg_src.source_workspace.clone();\n         let crateid = pkg_src.id.clone();\n \n+        let path = crateid.path.as_slice();\n         debug!(\"build: workspace = {} (in Rust path? {:?} is git dir? {:?} \\\n                 crateid = {} pkgsrc start_dir = {}\", workspace.display(),\n-               in_rust_path(&workspace), is_git_dir(&workspace.join(&crateid.path)),\n+               in_rust_path(&workspace), is_git_dir(&workspace.join(path)),\n                crateid.to_str(), pkg_src.start_dir.display());\n         debug!(\"build: what to build = {:?}\", what_to_build);\n \n         // If workspace isn't in the RUST_PATH, and it's a git repo,\n         // then clone it into the first entry in RUST_PATH, and repeat\n-        if !in_rust_path(&workspace) && is_git_dir(&workspace.join(&crateid.path)) {\n+        if !in_rust_path(&workspace) && is_git_dir(&workspace.join(path)) {\n             let mut out_dir = default_workspace().join(\"src\");\n-            out_dir.push(&crateid.path);\n-            let git_result = source_control::safe_git_clone(&workspace.join(&crateid.path),\n+            out_dir.push(path);\n+            let git_result = source_control::safe_git_clone(&workspace.join(path),\n                                                             &crateid.version,\n                                                             &out_dir);\n             match git_result {\n                 CheckedOutSources => make_read_only(&out_dir),\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                _ => cond.raise((crateid.path.as_str().unwrap().to_owned(), out_dir.clone()))\n+                _ => cond.raise((path.to_owned(), out_dir.clone()))\n             };\n             let default_ws = default_workspace();\n             debug!(\"Calling build recursively with {:?} and {:?}\", default_ws.display(),\n@@ -652,7 +651,8 @@ impl CtxMethods for BuildContext {\n                target_exec.display(), target_lib,\n                maybe_executable, maybe_library);\n \n-        self.workcache_context.with_prep(id.install_tag(), |prep| {\n+        let install_tag = format!(\"install({}-{})\", id.path, id.version_or_default());\n+        self.workcache_context.with_prep(install_tag, |prep| {\n             for ee in maybe_executable.iter() {\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 prep.declare_input(\"binary\","}, {"sha": "5ac62c5284e080f3713149d5f98552efab7997df", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 51, "deletions": 23, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "patch": "@@ -11,7 +11,6 @@\n extern mod extra;\n \n use target::*;\n-use crate_id::CrateId;\n use std::io;\n use std::io::fs;\n use std::os;\n@@ -27,7 +26,7 @@ use workcache_support;\n use workcache_support::{digest_only_date, digest_file_with_date, crate_tag};\n use extra::workcache;\n use extra::treemap::TreeMap;\n-\n+use syntax::crateid::CrateId;\n use rustc::driver::session;\n \n // An enumeration of the unpacked source of a package workspace.\n@@ -68,12 +67,38 @@ impl ToStr for PkgSrc {\n     }\n }\n condition! {\n-    // #6009: should this be pub or not, when #8215 is fixed?\n     build_err: (~str) -> ~str;\n }\n \n-impl PkgSrc {\n+fn prefixes(p: &Path) -> Prefixes {\n+    Prefixes {\n+        components: p.str_components().map(|x|x.unwrap().to_owned()).to_owned_vec(),\n+        remaining: ~[]\n+    }\n+}\n+\n+struct Prefixes {\n+    priv components: ~[~str],\n+    priv remaining: ~[~str]\n+}\n+\n+impl Iterator<(Path, Path)> for Prefixes {\n+    #[inline]\n+    fn next(&mut self) -> Option<(Path, Path)> {\n+        if self.components.len() <= 1 {\n+            None\n+        }\n+        else {\n+            let last = self.components.pop().unwrap();\n+            self.remaining.unshift(last);\n+            // converting to str and then back is a little unfortunate\n+            Some((Path::new(self.components.connect(\"/\")),\n+                  Path::new(self.remaining.connect(\"/\"))))\n+        }\n+    }\n+}\n \n+impl PkgSrc {\n     pub fn new(mut source_workspace: Path,\n                destination_workspace: Path,\n                use_rust_path_hack: bool,\n@@ -98,21 +123,22 @@ impl PkgSrc {\n         } else {\n             // We search for sources under both src/ and build/ , because build/ is where\n             // automatically-checked-out sources go.\n+            let path = Path::new(id.path.as_slice());\n             let mut result = source_workspace.join(\"src\");\n-            result.push(&id.path.dir_path());\n+            result.push(&path.dir_path());\n             result.push(id.short_name_with_version());\n             to_try.push(result);\n             let mut result = source_workspace.join(\"src\");\n-            result.push(&id.path);\n+            result.push(&path);\n             to_try.push(result);\n \n             let mut result = build_dir.join(\"src\");\n-            result.push(&id.path.dir_path());\n+            result.push(&path.dir_path());\n             result.push(id.short_name_with_version());\n             to_try.push(result.clone());\n             output_names.push(result);\n             let mut other_result = build_dir.join(\"src\");\n-            other_result.push(&id.path);\n+            other_result.push(&path);\n             to_try.push(other_result.clone());\n             output_names.push(other_result);\n \n@@ -132,9 +158,10 @@ impl PkgSrc {\n             None => {\n                 // See if any of the prefixes of this package ID form a valid package ID\n                 // That is, is this a package ID that points into the middle of a workspace?\n-                for (prefix, suffix) in id.prefixes() {\n-                    let crate_id = CrateId::new(prefix.as_str().unwrap());\n-                    let path = build_dir.join(&crate_id.path);\n+                for (prefix, suffix) in prefixes(&Path::new(id.path.as_slice())) {\n+                    let crate_id: Option<CrateId> = from_str(prefix.as_str().unwrap());\n+                    let crate_id = crate_id.expect(\"valid crate id\");\n+                    let path = build_dir.join(crate_id.path.as_slice());\n                     debug!(\"in loop: checking if {} is a directory\", path.display());\n                     if path.is_dir() {\n                         let ps = PkgSrc::new(source_workspace,\n@@ -163,7 +190,7 @@ impl PkgSrc {\n                             }\n                         }\n \n-                    };\n+                    }\n                 }\n \n                 // Ok, no prefixes work, so try fetching from git\n@@ -179,11 +206,12 @@ impl PkgSrc {\n                     }\n                     match ok_d {\n                         Some(ref d) => {\n-                            if d.is_ancestor_of(&id.path)\n-                                || d.is_ancestor_of(&versionize(&id.path, &id.version)) {\n+                            let path = Path::new(id.path.as_slice());\n+                            if d.is_ancestor_of(&path)\n+                                || d.is_ancestor_of(&versionize(id.path, &id.version)) {\n                                 // Strip off the package ID\n                                 source_workspace = d.clone();\n-                                for _ in id.path.components() {\n+                                for _ in path.components() {\n                                     source_workspace.pop();\n                                 }\n                                 // Strip off the src/ part\n@@ -226,8 +254,7 @@ impl PkgSrc {\n                                         exist, and couldn't interpret it as a URL fragment\"))\n                                 }\n                             }\n-                        }\n-                        else {\n+                        } else {\n                             cond.raise((id.clone(),\n                                 ~\"supplied path for package dir does not \\\n                                 exist, and couldn't interpret it as a URL fragment\"))\n@@ -268,24 +295,25 @@ impl PkgSrc {\n         use conditions::git_checkout_failed::cond;\n \n         let cwd = os::getcwd();\n+        let path = Path::new(crateid.path.as_slice());\n         debug!(\"Checking whether {} (path = {}) exists locally. Cwd = {}, does it? {:?}\",\n-                crateid.to_str(), crateid.path.display(),\n+                crateid.to_str(), crateid.path,\n                 cwd.display(),\n-                crateid.path.exists());\n+                path.exists());\n \n-        match safe_git_clone(&crateid.path, &crateid.version, local) {\n+        match safe_git_clone(&path, &crateid.version, local) {\n             CheckedOutSources => {\n                 make_read_only(local);\n                 Some(local.clone())\n             }\n             DirToUse(clone_target) => {\n-                if crateid.path.components().nth(1).is_none() {\n+                if path.components().nth(1).is_none() {\n                     // If a non-URL, don't bother trying to fetch\n                     return None;\n                 }\n \n                 // FIXME (#9639): This needs to handle non-utf8 paths\n-                let url = format!(\"https://{}\", crateid.path.as_str().unwrap());\n+                let url = format!(\"https://{}\", path.as_str().unwrap());\n                 debug!(\"Fetching package: git clone {} {} [version={}]\",\n                         url, clone_target.display(), crateid.version_or_default());\n \n@@ -345,7 +373,7 @@ impl PkgSrc {\n         use conditions::missing_pkg_files::cond;\n \n         let prefix = self.start_dir.components().len();\n-        debug!(\"Matching against {}\", self.id.short_name);\n+        debug!(\"Matching against {}\", self.id.name);\n         for pth in fs::walk_dir(&self.start_dir) {\n             let maybe_known_crate_set = match pth.filename_str() {\n                 Some(filename) if filter(filename) => match filename {"}, {"sha": "a0d49e7565f185062373793f55b1bef787f57bef", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "patch": "@@ -12,16 +12,18 @@\n \n #[allow(dead_code)];\n \n-pub use crate_id::CrateId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n-pub use version::{Version, split_version, split_version_general, try_parsing_version};\n+pub use version::{Version, split_version_general};\n pub use rustc::metadata::filesearch::rust_path;\n \n use std::libc;\n use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use std::os;\n use std::io;\n use std::io::fs;\n+use extra::hex::ToHex;\n+use syntax::crateid::CrateId;\n+use rustc::util::sha2::{Digest, Sha256};\n use rustc::metadata::filesearch::{libdir, relative_target_lib_path};\n use rustc::driver::driver::host_triple;\n use messages::*;\n@@ -77,13 +79,13 @@ pub fn workspace_contains_crate_id_(crateid: &CrateId, workspace: &Path,\n     let mut found = None;\n     for p in fs::walk_dir(&src_dir) {\n         if p.is_dir() {\n-            if p == src_dir.join(&crateid.path) || {\n+            if p == src_dir.join(crateid.path.as_slice()) || {\n                 let pf = p.filename_str();\n                 pf.iter().any(|&g| {\n                     match split_version_general(g, '-') {\n                         None => false,\n                         Some((ref might_match, ref vers)) => {\n-                            *might_match == crateid.short_name\n+                            *might_match == crateid.name\n                                 && (crateid.version == *vers || crateid.version == None)\n                         }\n                     }\n@@ -178,33 +180,39 @@ pub fn built_library_in_workspace(crateid: &CrateId, workspace: &Path) -> Option\n /// Does the actual searching stuff\n pub fn installed_library_in_workspace(crate_id: &CrateId, workspace: &Path) -> Option<Path> {\n     // This could break once we're handling multiple versions better -- I should add a test for it\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    match crate_id.path.filename_str() {\n+    let path = Path::new(crate_id.path.as_slice());\n+    match path.filename_str() {\n         None => None,\n         Some(_short_name) => library_in_workspace(crate_id, Install, workspace)\n     }\n }\n \n /// `workspace` is used to figure out the directory to search.\n-/// `short_name` is taken as the link name of the library.\n+/// `name` is taken as the link name of the library.\n pub fn library_in_workspace(crate_id: &CrateId, where: Target, workspace: &Path) -> Option<Path> {\n     debug!(\"library_in_workspace: checking whether a library named {} exists\",\n-           crate_id.short_name);\n+           crate_id.name);\n \n     let dir_to_search = match where {\n-        Build => target_build_dir(workspace).join(&crate_id.path),\n+        Build => target_build_dir(workspace).join(crate_id.path.as_slice()),\n         Install => target_lib_dir(workspace)\n     };\n \n     library_in(crate_id, &dir_to_search)\n }\n \n-pub fn system_library(sysroot: &Path, crate_id: &str) -> Option<Path> {\n-    library_in(&CrateId::new(crate_id), &sysroot.join(relative_target_lib_path(host_triple())))\n+pub fn system_library(sysroot: &Path, crate_id: &CrateId) -> Option<Path> {\n+    library_in(crate_id, &sysroot.join(relative_target_lib_path(host_triple())))\n }\n \n fn library_in(crate_id: &CrateId, dir_to_search: &Path) -> Option<Path> {\n-    let lib_name = crate_id.to_lib_name();\n+    let mut hasher = Sha256::new();\n+    hasher.reset();\n+    hasher.input_str(crate_id.to_str());\n+    let hash = hasher.result_bytes().to_hex();\n+    let hash = hash.slice_chars(0, 8);\n+\n+    let lib_name = format!(\"{}-{}-{}\", crate_id.name, hash, crate_id.version_or_default());\n     let filenames = [\n         format!(\"{}{}.{}\", \"lib\", lib_name, \"rlib\"),\n         format!(\"{}{}{}\", os::consts::DLL_PREFIX, lib_name, os::consts::DLL_SUFFIX),\n@@ -219,7 +227,7 @@ fn library_in(crate_id: &CrateId, dir_to_search: &Path) -> Option<Path> {\n         }\n     }\n     debug!(\"warning: library_in_workspace didn't find a library in {} for {}\",\n-           dir_to_search.display(), crate_id.short_name);\n+           dir_to_search.display(), crate_id.to_str());\n     return None;\n }\n \n@@ -271,7 +279,7 @@ fn target_file_in_workspace(crateid: &CrateId, workspace: &Path,\n     // Artifacts in the build directory live in a package-ID-specific subdirectory,\n     // but installed ones don't.\n     let result = match (where, what) {\n-                (Build, _)      => target_build_dir(workspace).join(&crateid.path),\n+                (Build, _)      => target_build_dir(workspace).join(crateid.path.as_slice()),\n                 (Install, Lib)  => target_lib_dir(workspace),\n                 (Install, _)    => target_bin_dir(workspace)\n     };\n@@ -287,7 +295,7 @@ fn target_file_in_workspace(crateid: &CrateId, workspace: &Path,\n /// Creates it if it doesn't exist.\n pub fn build_pkg_id_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n     let mut result = target_build_dir(workspace);\n-    result.push(&crateid.path);\n+    result.push(crateid.path.as_slice());\n     debug!(\"Creating build dir {} for package id {}\", result.display(),\n            crateid.to_str());\n     fs::mkdir_recursive(&result, io::UserRWX);\n@@ -297,24 +305,24 @@ pub fn build_pkg_id_in_workspace(crateid: &CrateId, workspace: &Path) -> Path {\n /// Return the output file for a given directory name,\n /// given whether we're building a library and whether we're building tests\n pub fn mk_output_path(what: OutputType, where: Target,\n-                      pkg_id: &CrateId, workspace: Path) -> Path {\n-    let short_name_with_version = pkg_id.short_name_with_version();\n+                      crate_id: &CrateId, workspace: Path) -> Path {\n+    let short_name_with_version = crate_id.short_name_with_version();\n     // Not local_path.dir_path()! For package foo/bar/blat/, we want\n     // the executable blat-0.5 to live under blat/\n     let dir = match where {\n         // If we're installing, it just goes under <workspace>...\n         Install => workspace,\n         // and if we're just building, it goes in a package-specific subdir\n-        Build => workspace.join(&pkg_id.path)\n+        Build => workspace.join(crate_id.path.as_slice())\n     };\n-    debug!(\"[{:?}:{:?}] mk_output_path: short_name = {}, path = {}\", what, where,\n-           if what == Lib { short_name_with_version.clone() } else { pkg_id.short_name.clone() },\n+    debug!(\"[{:?}:{:?}] mk_output_path: name = {}, path = {}\", what, where,\n+           if what == Lib { short_name_with_version.clone() } else { crate_id.name.clone() },\n            dir.display());\n     let mut output_path = match what {\n         // this code is duplicated from elsewhere; fix this\n         Lib => dir.join(os::dll_filename(short_name_with_version)),\n         // executable names *aren't* versioned\n-        _ => dir.join(format!(\"{}{}{}\", pkg_id.short_name,\n+        _ => dir.join(format!(\"{}{}{}\", crate_id.name,\n                            match what {\n                                Test => \"test\",\n                                Bench => \"bench\",\n@@ -361,11 +369,12 @@ fn dir_has_file(dir: &Path, file: &str) -> bool {\n \n pub fn find_dir_using_rust_path_hack(p: &CrateId) -> Option<Path> {\n     let rp = rust_path();\n+    let path = Path::new(p.path.as_slice());\n     for dir in rp.iter() {\n         // Require that the parent directory match the package ID\n         // Note that this only matches if the package ID being searched for\n         // has a name that's a single component\n-        if dir.ends_with_path(&p.path) || dir.ends_with_path(&versionize(&p.path, &p.version)) {\n+        if dir.ends_with_path(&path) || dir.ends_with_path(&versionize(p.path, &p.version)) {\n             debug!(\"In find_dir_using_rust_path_hack: checking dir {}\", dir.display());\n             if dir_has_crate_file(dir) {\n                 debug!(\"Did find id {} in dir {}\", p.to_str(), dir.display());\n@@ -387,7 +396,8 @@ pub fn user_set_rust_path() -> bool {\n }\n \n /// Append the version string onto the end of the path's filename\n-pub fn versionize(p: &Path, v: &Version) -> Path {\n+pub fn versionize(p: &str, v: &Version) -> Path {\n+    let p = Path::new(p);\n     let q = p.filename().expect(\"path is a directory\");\n     let mut q = q.to_owned();\n     q.push('-' as u8);"}, {"sha": "bf8ec1e738cabc2538ef7f4702169681ef427bc7", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 261, "deletions": 248, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "patch": "@@ -20,12 +20,12 @@ use extra::arc::Arc;\n use extra::arc::RWArc;\n use extra::tempfile::TempDir;\n use extra::workcache;\n-use extra::workcache::{Database};\n+use extra::workcache::Database;\n use extra::treemap::TreeMap;\n use extra::getopts::groups::getopts;\n use std::run::ProcessOutput;\n use installed_packages::list_installed_packages;\n-use crate_id::CrateId;\n+use syntax::crateid::CrateId;\n use path_util::{target_executable_in_workspace, target_test_in_workspace,\n                target_bench_in_workspace, make_dir_rwx,\n                library_in_workspace, installed_library_in_workspace,\n@@ -58,18 +58,17 @@ fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n }\n \n fn fake_pkg() -> CrateId {\n-    let sn = ~\"bogus\";\n     CrateId {\n-        path: Path::new(sn.as_slice()),\n-        short_name: sn,\n+        path: ~\"bogus\",\n+        name: ~\"bogus\",\n         version: None\n     }\n }\n \n fn git_repo_pkg() -> CrateId {\n     CrateId {\n-        path: Path::new(\"mockgithub.com/catamorphism/test-pkg\"),\n-        short_name: ~\"test-pkg\",\n+        path: ~\"mockgithub.com/catamorphism/test-pkg\",\n+        name: ~\"test-pkg\",\n         version: None\n     }\n }\n@@ -273,14 +272,11 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n         err_fd: None\n     }).expect(format!(\"failed to exec `{}`\", cmd));\n     let output = prog.finish_with_output();\n-    debug!(\"Output from command {} with args {:?} was {} \\\\{{}\\\\}[{:?}]\",\n+    debug!(\"Output from command {} with args {:?} was --- {} \\\\{{}\\\\} --- [{:?}]\",\n            cmd, args, str::from_utf8(output.output).unwrap(),\n            str::from_utf8(output.error).unwrap(),\n            output.status);\n     if !output.status.success() {\n-        debug!(\"Command {} {:?} failed with exit code {:?}; its output was --- {} {} ---\",\n-              cmd, args, output.status,\n-              str::from_utf8(output.output).unwrap(), str::from_utf8(output.error).unwrap());\n         Fail(output)\n     }\n     else {\n@@ -297,7 +293,7 @@ fn create_local_package(crateid: &CrateId) -> TempDir {\n \n fn create_local_package_in(crateid: &CrateId, pkgdir: &Path) -> Path {\n \n-    let package_dir = pkgdir.join_many([~\"src\", crateid.to_str()]);\n+    let package_dir = pkgdir.join_many([~\"src\", crateid.short_name_with_version()]);\n \n     // Create main, lib, test, and bench files\n     fs::mkdir_recursive(&package_dir, io::UserRWX);\n@@ -325,11 +321,15 @@ fn create_local_package_with_dep(crateid: &CrateId, subord_crateid: &CrateId) ->\n     let package_dir = create_local_package(crateid);\n     create_local_package_in(subord_crateid, package_dir.path());\n     // Write a main.rs file into crateid that references subord_crateid\n-    writeFile(&package_dir.path().join_many([~\"src\", crateid.to_str(), ~\"main.rs\"]),\n+    writeFile(&package_dir.path().join_many([~\"src\",\n+                                             crateid.short_name_with_version(),\n+                                             ~\"main.rs\"]),\n               format!(\"extern mod {};\\nfn main() \\\\{\\\\}\",\n-                   subord_crateid.short_name));\n+                   subord_crateid.name));\n     // Write a lib.rs file into subord_crateid that has something in it\n-    writeFile(&package_dir.path().join_many([~\"src\", subord_crateid.to_str(), ~\"lib.rs\"]),\n+    writeFile(&package_dir.path().join_many([~\"src\",\n+                                             subord_crateid.short_name_with_version(),\n+                                             ~\"lib.rs\"]),\n               \"pub fn f() {}\");\n     package_dir\n }\n@@ -362,19 +362,21 @@ fn assert_executable_exists(repo: &Path, short_name: &str) {\n }\n \n fn executable_exists(repo: &Path, short_name: &str) -> bool {\n+    let crate_id = from_str(short_name).expect(\"valid crate id\");\n     debug!(\"executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let exec = target_executable_in_workspace(&CrateId::new(short_name), repo);\n+    let exec = target_executable_in_workspace(&crate_id, repo);\n     exec.exists() && is_rwx(&exec)\n }\n \n fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n+    let crate_id = from_str(short_name).expect(\"valid crate id\");\n     debug!(\"test_executable_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let exec = built_test_in_workspace(&CrateId::new(short_name), repo);\n+    let exec = built_test_in_workspace(&crate_id, repo);\n     exec.map_or(false, |exec| exec.exists() && is_rwx(&exec))\n }\n \n fn remove_executable_file(p: &CrateId, workspace: &Path) {\n-    let exec = target_executable_in_workspace(&CrateId::new(p.short_name), workspace);\n+    let exec = target_executable_in_workspace(p, workspace);\n     if exec.exists() {\n         fs::unlink(&exec);\n     }\n@@ -387,15 +389,16 @@ fn assert_built_executable_exists(repo: &Path, short_name: &str) {\n fn built_executable_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"assert_built_executable_exists: repo = {}, short_name = {}\",\n             repo.display(), short_name);\n-    let exec = built_executable_in_workspace(&CrateId::new(short_name), repo);\n+    let crate_id = from_str(short_name).expect(\"valid crate id\");\n+    let exec = built_executable_in_workspace(&crate_id, repo);\n     exec.is_some() && {\n        let execname = exec.get_ref();\n        execname.exists() && is_rwx(execname)\n     }\n }\n \n fn remove_built_executable_file(p: &CrateId, workspace: &Path) {\n-    let exec = built_executable_in_workspace(&CrateId::new(p.short_name), workspace);\n+    let exec = built_executable_in_workspace(p, workspace);\n     match exec {\n         Some(r) => fs::unlink(&r),\n         None    => ()\n@@ -430,7 +433,8 @@ fn assert_built_library_exists(repo: &Path, short_name: &str) {\n \n fn built_library_exists(repo: &Path, short_name: &str) -> bool {\n     debug!(\"assert_built_library_exists: repo = {}, short_name = {}\", repo.display(), short_name);\n-    let lib = built_library_in_workspace(&CrateId::new(short_name), repo);\n+    let crate_id = from_str(short_name).expect(\"valid crate id\");\n+    let lib = built_library_in_workspace(&crate_id, repo);\n     lib.is_some() && {\n         let libname = lib.get_ref();\n         libname.exists() && is_rwx(libname)\n@@ -465,15 +469,16 @@ fn command_line_test_output_with_env(args: &[~str], env: ~[(~str, ~str)]) -> ~[~\n fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n     debug!(\"lib_output_file_name: given {} and short name {}\",\n            workspace.display(), short_name);\n-    library_in_workspace(&CrateId::new(short_name),\n+    let crate_id = from_str(short_name).expect(\"valid crate id\");\n+    library_in_workspace(&crate_id,\n                          Build,\n                          workspace).expect(\"lib_output_file_name\")\n }\n \n #[cfg(target_os = \"linux\")]\n fn touch_source_file(workspace: &Path, crateid: &CrateId) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", crateid.to_str()]);\n+    let pkg_src_dir = workspace.join_many([~\"src\", crateid.short_name_with_version()]);\n     let contents = fs::readdir(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n@@ -493,7 +498,7 @@ fn touch_source_file(workspace: &Path, crateid: &CrateId) {\n #[cfg(not(target_os = \"linux\"))]\n fn touch_source_file(workspace: &Path, crateid: &CrateId) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", crateid.to_str()]);\n+    let pkg_src_dir = workspace.join_many([~\"src\", crateid.short_name_with_version()]);\n     let contents = fs::readdir(&pkg_src_dir);\n     for p in contents.iter() {\n         if p.extension_str() == Some(\"rs\") {\n@@ -512,7 +517,7 @@ fn touch_source_file(workspace: &Path, crateid: &CrateId) {\n /// Add a comment at the end\n fn frob_source_file(workspace: &Path, crateid: &CrateId, filename: &str) {\n     use conditions::bad_path::cond;\n-    let pkg_src_dir = workspace.join_many([~\"src\", crateid.to_str()]);\n+    let pkg_src_dir = workspace.join_many([~\"src\", crateid.short_name_with_version()]);\n     let mut maybe_p = None;\n     let maybe_file = pkg_src_dir.join(filename);\n     debug!(\"Trying to frob {} -- {}\", pkg_src_dir.display(), filename);\n@@ -615,7 +620,7 @@ fn test_install_invalid() {\n \n #[test]\n fn test_install_valid_external() {\n-    let temp_pkg_id = CrateId::new(\"foo\");\n+    let temp_pkg_id: CrateId = from_str(\"foo\").unwrap();\n     let (tempdir, _) = mk_temp_workspace(&temp_pkg_id);\n     let temp_workspace = tempdir.path();\n     command_line_test([~\"install\", ~\"foo\"], temp_workspace);\n@@ -653,7 +658,8 @@ fn test_install_invalid_external() {\n #[test]\n fn test_install_git() {\n     let temp_pkg_id = git_repo_pkg();\n-    let repo = init_git_repo(&temp_pkg_id.path);\n+    let path = Path::new(temp_pkg_id.path.as_slice());\n+    let repo = init_git_repo(&path);\n     let repo = repo.path();\n     debug!(\"repo = {}\", repo.display());\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n@@ -670,10 +676,9 @@ fn test_install_git() {\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n     debug!(\"test_install_git: calling rustpkg install {} in {}\",\n-           temp_pkg_id.path.display(), repo.display());\n+           temp_pkg_id.path, repo.display());\n     // should have test, bench, lib, and main\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([~\"install\", temp_pkg_id.path.as_str().unwrap().to_owned()], repo);\n+    command_line_test([~\"install\", temp_pkg_id.path.to_owned()], repo);\n     let ws = repo.join(\".rust\");\n     // Check that all files exist\n     debug!(\"Checking for files in {}\", ws.display());\n@@ -702,8 +707,6 @@ fn test_install_git() {\n \n #[test]\n fn test_crate_ids_must_be_relative_path_like() {\n-    use conditions::bad_pkg_id::cond;\n-\n     /*\n     Okay:\n     - One identifier, with no slashes\n@@ -715,32 +718,16 @@ fn test_crate_ids_must_be_relative_path_like() {\n \n     */\n \n-    let whatever = CrateId::new(\"foo\");\n+    let foo: CrateId = from_str(\"foo\").unwrap();\n+    assert_eq!(~\"foo#0.0\", foo.to_str());\n+    let test_pkg: CrateId = from_str(\"github.com/catamorphism/test-pkg\").unwrap();\n+    assert_eq!(~\"github.com/catamorphism/test-pkg#0.0\", test_pkg.to_str());\n \n-    assert_eq!(~\"foo-0.0\", whatever.to_str());\n-    assert!(\"github.com/catamorphism/test-pkg-0.0\" ==\n-            CrateId::new(\"github.com/catamorphism/test-pkg\").to_str());\n-\n-    cond.trap(|(p, e)| {\n-        assert!(p.filename().is_none());\n-        assert!(\"bad crateid\" == e);\n-        whatever.clone()\n-    }).inside(|| {\n-        let x = CrateId::new(\"\");\n-        assert_eq!(~\"foo-0.0\", x.to_str());\n-    });\n+    let x: Option<CrateId> = from_str(\"\");\n+    assert_eq!(x, None);\n \n-    cond.trap(|(p, e)| {\n-        let abs = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n-        assert_eq!(p, abs);\n-        assert!(\"bad crateid\" == e);\n-        whatever.clone()\n-    }).inside(|| {\n-        let zp = os::make_absolute(&Path::new(\"foo/bar/quux\"));\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let z = CrateId::new(zp.as_str().unwrap());\n-        assert_eq!(~\"foo-0.0\", z.to_str());\n-    })\n+    let z: Option<CrateId> = from_str(\"/foo/bar/quux\");\n+    assert_eq!(z, None);\n }\n \n #[test]\n@@ -765,7 +752,8 @@ fn test_package_request_version() {\n \n     command_line_test([~\"install\", format!(\"{}\\\\#0.3\", local_path)], repo);\n \n-    assert!(match installed_library_in_workspace(&CrateId::new(format!(\"{}\\\\#0.3\", local_path)),\n+    let crate_id = from_str(format!(\"{}\\\\#0.3\", local_path)).unwrap();\n+    assert!(match installed_library_in_workspace(&crate_id,\n                                                  &repo.join(\".rust\")) {\n         Some(p) => {\n             debug!(\"installed: {}\", p.display());\n@@ -774,7 +762,7 @@ fn test_package_request_version() {\n         }\n         None    => false\n     });\n-    let temp_pkg_id = CrateId::new(\"mockgithub.com/catamorphism/test_pkg_version#0.3\");\n+    let temp_pkg_id = from_str(\"mockgithub.com/catamorphism/test_pkg_version#0.3\").unwrap();\n     assert!(target_executable_in_workspace(&temp_pkg_id, &repo.join(\".rust\"))\n             == repo.join_many([\".rust\", \"bin\", \"test_pkg_version\"]));\n \n@@ -812,20 +800,23 @@ fn rustpkg_library_target() {\n     add_git_tag(&package_dir, ~\"0.0\");\n \n     command_line_test([~\"install\", ~\"foo\"], foo_repo);\n-    assert_lib_exists(&foo_repo.join(\".rust\"), &CrateId::new(\"foo\"));\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    assert_lib_exists(&foo_repo.join(\".rust\"), &crate_id);\n }\n \n #[test]\n fn rustpkg_local_pkg() {\n-    let dir = create_local_package(&CrateId::new(\"foo\"));\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    let dir = create_local_package(&crate_id);\n     command_line_test([~\"install\", ~\"foo\"], dir.path());\n     assert_executable_exists(dir.path(), \"foo\");\n }\n \n #[test]\n #[ignore(reason=\"busted\")]\n fn package_script_with_default_build() {\n-    let dir = create_local_package(&CrateId::new(\"fancy-lib\"));\n+    let crate_id: CrateId = from_str(\"fancy-lib\").unwrap();\n+    let dir = create_local_package(&crate_id);\n     let dir = dir.path();\n     debug!(\"dir = {}\", dir.display());\n     let mut source = test_sysroot().dir_path();\n@@ -835,7 +826,7 @@ fn package_script_with_default_build() {\n     debug!(\"package_script_with_default_build: {}\", source.display());\n     fs::copy(&source, &dir.join_many([\"src\", \"fancy-lib-0.0\", \"pkg.rs\"]));\n     command_line_test([~\"install\", ~\"fancy-lib\"], dir);\n-    assert_lib_exists(dir, &CrateId::new(\"fancy-lib\"));\n+    assert_lib_exists(dir, &crate_id);\n     assert!(target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]).exists());\n     let generated_path = target_build_dir(dir).join_many([~\"fancy-lib\", ~\"generated.rs\"]);\n     debug!(\"generated path = {}\", generated_path.display());\n@@ -866,7 +857,8 @@ fn rustpkg_install_no_arg() {\n               \"fn main() { let _x = (); }\");\n     debug!(\"install_no_arg: dir = {}\", package_dir.display());\n     command_line_test([~\"install\"], &package_dir);\n-    assert_lib_exists(&tmp, &CrateId::new(\"foo\"));\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    assert_lib_exists(&tmp, &crate_id);\n }\n \n #[test]\n@@ -882,14 +874,16 @@ fn rustpkg_clean_no_arg() {\n     command_line_test([~\"build\"], &package_dir);\n     assert_built_executable_exists(&tmp, \"foo\");\n     command_line_test([~\"clean\"], &package_dir);\n-    let res = built_executable_in_workspace(&CrateId::new(\"foo\"), &tmp);\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    let res = built_executable_in_workspace(&crate_id, &tmp);\n     assert!(!res.as_ref().map_or(false, |m| m.exists()));\n }\n \n #[test]\n fn rust_path_test() {\n     let dir_for_path = TempDir::new(\"more_rust\").expect(\"rust_path_test failed\");\n-    let dir = mk_workspace(dir_for_path.path(), &CrateId::new(\"foo\"));\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    let dir = mk_workspace(dir_for_path.path(), &crate_id);\n     debug!(\"dir = {}\", dir.display());\n     writeFile(&dir.join(\"main.rs\"), \"fn main() { let _x = (); }\");\n \n@@ -940,11 +934,11 @@ fn rust_path_parse() {\n fn test_list() {\n     let dir = TempDir::new(\"test_list\").expect(\"test_list failed\");\n     let dir = dir.path();\n-    let foo = CrateId::new(\"foo\");\n+    let foo: CrateId = from_str(\"foo\").unwrap();\n     create_local_package_in(&foo, dir);\n-    let bar = CrateId::new(\"bar\");\n+    let bar: CrateId = from_str(\"bar\").unwrap();\n     create_local_package_in(&bar, dir);\n-    let quux = CrateId::new(\"quux\");\n+    let quux: CrateId = from_str(\"quux\").unwrap();\n     create_local_package_in(&quux, dir);\n \n // list doesn't output very much right now...\n@@ -970,9 +964,9 @@ fn test_list() {\n fn install_remove() {\n     let dir = TempDir::new(\"install_remove\").expect(\"install_remove\");\n     let dir = dir.path();\n-    let foo = CrateId::new(\"foo\");\n-    let bar = CrateId::new(\"bar\");\n-    let quux = CrateId::new(\"quux\");\n+    let foo: CrateId = from_str(\"foo\").unwrap();\n+    let bar: CrateId = from_str(\"bar\").unwrap();\n+    let quux: CrateId = from_str(\"quux\").unwrap();\n     create_local_package_in(&foo, dir);\n     create_local_package_in(&bar, dir);\n     create_local_package_in(&quux, dir);\n@@ -999,15 +993,15 @@ fn install_check_duplicates() {\n     // check invariant that there are no dups in the pkg database\n     let dir = TempDir::new(\"install_remove\").expect(\"install_remove\");\n     let dir = dir.path();\n-    let foo = CrateId::new(\"foo\");\n+    let foo: CrateId = from_str(\"foo\").unwrap();\n     create_local_package_in(&foo, dir);\n \n     command_line_test([~\"install\", ~\"foo\"], dir);\n     command_line_test([~\"install\", ~\"foo\"], dir);\n     let mut contents = ~[];\n     let check_dups = |p: &CrateId| {\n         if contents.contains(p) {\n-            fail!(\"package {} appears in `list` output more than once\", p.path.display());\n+            fail!(\"package {} appears in `list` output more than once\", p.path);\n         }\n         else {\n             contents.push((*p).clone());\n@@ -1019,7 +1013,7 @@ fn install_check_duplicates() {\n \n #[test]\n fn no_rebuilding() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1040,7 +1034,7 @@ fn no_rebuilding() {\n #[test]\n #[ignore]\n fn no_recopying() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     command_line_test([~\"install\", ~\"foo\"], workspace);\n@@ -1059,8 +1053,8 @@ fn no_recopying() {\n \n #[test]\n fn no_rebuilding_dep() {\n-    let p_id = CrateId::new(\"foo\");\n-    let dep_id = CrateId::new(\"bar\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n+    let dep_id: CrateId = from_str(\"bar\").unwrap();\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1078,8 +1072,8 @@ fn no_rebuilding_dep() {\n \n #[test]\n fn do_rebuild_dep_dates_change() {\n-    let p_id = CrateId::new(\"foo\");\n-    let dep_id = CrateId::new(\"bar\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n+    let dep_id: CrateId = from_str(\"bar\").unwrap();\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1098,8 +1092,8 @@ fn do_rebuild_dep_dates_change() {\n \n #[test]\n fn do_rebuild_dep_only_contents_change() {\n-    let p_id = CrateId::new(\"foo\");\n-    let dep_id = CrateId::new(\"bar\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n+    let dep_id: CrateId = from_str(\"bar\").unwrap();\n     let workspace = create_local_package_with_dep(&p_id, &dep_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n@@ -1119,8 +1113,10 @@ fn do_rebuild_dep_only_contents_change() {\n \n #[test]\n fn test_versions() {\n-    let workspace = create_local_package(&CrateId::new(\"foo#0.1\"));\n-    let _other_workspace = create_local_package(&CrateId::new(\"foo#0.2\"));\n+    let foo_01: CrateId = from_str(\"foo#0.1\").unwrap();\n+    let foo_02: CrateId = from_str(\"foo#0.2\").unwrap();\n+    let workspace = create_local_package(&foo_01);\n+    let _other_workspace = create_local_package(&foo_02);\n     command_line_test([~\"install\", ~\"foo#0.1\"], workspace.path());\n     let output = command_line_test_output([~\"list\"]);\n     // make sure output includes versions\n@@ -1130,7 +1126,8 @@ fn test_versions() {\n #[test]\n #[ignore(reason = \"do not yet implemented\")]\n fn test_build_hooks() {\n-    let workspace = create_local_package_with_custom_build_hook(&CrateId::new(\"foo\"),\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    let workspace = create_local_package_with_custom_build_hook(&crate_id,\n                                                                 \"frob\");\n     command_line_test([~\"do\", ~\"foo\", ~\"frob\"], workspace.path());\n }\n@@ -1140,14 +1137,16 @@ fn test_build_hooks() {\n #[ignore(reason = \"info not yet implemented\")]\n fn test_info() {\n     let expected_info = ~\"package foo\"; // fill in\n-    let workspace = create_local_package(&CrateId::new(\"foo\"));\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    let workspace = create_local_package(&crate_id);\n     let output = command_line_test([~\"info\", ~\"foo\"], workspace.path());\n     assert_eq!(str::from_utf8_owned(output.output).unwrap(), expected_info);\n }\n \n #[test]\n fn test_uninstall() {\n-    let workspace = create_local_package(&CrateId::new(\"foo\"));\n+    let crate_id: CrateId = from_str(\"foo\").unwrap();\n+    let workspace = create_local_package(&crate_id);\n     command_line_test([~\"uninstall\", ~\"foo\"], workspace.path());\n     let output = command_line_test([~\"list\"], workspace.path());\n     assert!(!str::from_utf8(output.output).unwrap().contains(\"foo\"));\n@@ -1156,7 +1155,7 @@ fn test_uninstall() {\n #[test]\n fn test_non_numeric_tag() {\n     let temp_pkg_id = git_repo_pkg();\n-    let repo = init_git_repo(&temp_pkg_id.path);\n+    let repo = init_git_repo(&Path::new(temp_pkg_id.path.as_slice()));\n     let repo = repo.path();\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n     writeFile(&repo_subdir.join(\"foo\"), \"foo\");\n@@ -1168,9 +1167,7 @@ fn test_non_numeric_tag() {\n     writeFile(&repo_subdir.join(\"not_on_testbranch_only\"), \"bye bye\");\n     add_all_and_commit(&repo_subdir);\n \n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([~\"install\", format!(\"{}\\\\#testbranch\",\n-                                           temp_pkg_id.path.as_str().unwrap())], repo);\n+    command_line_test([~\"install\", format!(\"{}\\\\#testbranch\", temp_pkg_id.path)], repo);\n     let file1 = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\", \"testbranch_only\"]);\n     let file2 = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\", \"master_only\"]);\n     assert!(file1.exists());\n@@ -1283,7 +1280,7 @@ fn test_extern_mod_simpler() {\n \n #[test]\n fn test_import_rustpkg() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"pkg.rs\"]),\n@@ -1296,7 +1293,7 @@ fn test_import_rustpkg() {\n \n #[test]\n fn test_macro_pkg_script() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"pkg.rs\"]),\n@@ -1313,7 +1310,8 @@ fn multiple_workspaces() {\n // Copy the exact same package into directory B and install it\n // Set the RUST_PATH to A:B\n // Make a third package that uses foo, make sure we can build/install it\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n+    let bar_p_id: CrateId = from_str(\"bar\").unwrap();\n     let (a_loc, _pkg_dir) = mk_temp_workspace(&p_id);\n     let (b_loc, _pkg_dir) = mk_temp_workspace(&p_id);\n     let (a_loc, b_loc) = (a_loc.path(), b_loc.path());\n@@ -1324,7 +1322,7 @@ fn multiple_workspaces() {\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let env = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", a_loc.as_str().unwrap(),\n                                             b_loc.as_str().unwrap()))]);\n-    let c_loc = create_local_package_with_dep(&CrateId::new(\"bar\"), &CrateId::new(\"foo\"));\n+    let c_loc = create_local_package_with_dep(&bar_p_id, &p_id);\n     command_line_test_with_env([~\"install\", ~\"bar\"], c_loc.path(), env);\n }\n \n@@ -1337,26 +1335,28 @@ fn rust_path_hack_test(hack_flag: bool) {\n       make sure built files for foo are in B\n       make sure nothing gets built into A or A/../build[lib,bin]\n */\n-   let p_id = CrateId::new(\"foo\");\n-   let workspace = create_local_package(&p_id);\n-   let workspace = workspace.path();\n-   let dest_workspace = mk_empty_workspace(&CrateId::new(\"bar\"), \"dest_workspace\");\n-   let dest_workspace = dest_workspace.path();\n-   let foo_path = workspace.join_many([\"src\", \"foo-0.0\"]);\n-   let rust_path = Some(~[(~\"RUST_PATH\",\n-       format!(\"{}:{}\",\n-               dest_workspace.as_str().unwrap(),\n-               foo_path.as_str().unwrap()))]);\n-   command_line_test_with_env(~[~\"install\"] + if hack_flag { ~[~\"--rust-path-hack\"] } else { ~[] } +\n-                               ~[~\"foo\"], dest_workspace, rust_path);\n-   assert_lib_exists(dest_workspace, &CrateId::new(\"foo\"));\n-   assert_executable_exists(dest_workspace, \"foo\");\n-   assert_built_library_exists(dest_workspace, \"foo\");\n-   assert_built_executable_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(workspace, &CrateId::new(\"foo\")));\n-   assert!(!executable_exists(workspace, \"foo\"));\n-   assert!(!built_library_exists(workspace, \"foo\"));\n-   assert!(!built_executable_exists(workspace, \"foo\"));\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n+    let bar_p_id: CrateId = from_str(\"bar\").unwrap();\n+    let workspace = create_local_package(&p_id);\n+    let workspace = workspace.path();\n+    let dest_workspace = mk_empty_workspace(&bar_p_id, \"dest_workspace\");\n+    let dest_workspace = dest_workspace.path();\n+    let foo_path = workspace.join_many([\"src\", \"foo-0.0\"]);\n+    let rust_path = Some(~[(~\"RUST_PATH\",\n+        format!(\"{}:{}\",\n+                dest_workspace.as_str().unwrap(),\n+                foo_path.as_str().unwrap()))]);\n+    command_line_test_with_env(~[~\"install\"] +\n+                               if hack_flag { ~[~\"--rust-path-hack\"] } else { ~[] } + ~[~\"foo\"],\n+                               dest_workspace, rust_path);\n+    assert_lib_exists(dest_workspace, &p_id);\n+    assert_executable_exists(dest_workspace, \"foo\");\n+    assert_built_library_exists(dest_workspace, \"foo\");\n+    assert_built_executable_exists(dest_workspace, \"foo\");\n+    assert!(!lib_exists(workspace, &p_id));\n+    assert!(!executable_exists(workspace, \"foo\"));\n+    assert!(!built_library_exists(workspace, \"foo\"));\n+    assert!(!built_executable_exists(workspace, \"foo\"));\n }\n \n // Notice that this is the only test case where the --rust-path-hack\n@@ -1382,88 +1382,95 @@ fn test_rust_path_can_contain_package_dirs_without_flag() {\n \n #[test]\n fn rust_path_hack_cwd() {\n-   // Same as rust_path_hack_test, but the CWD is the dir to build out of\n-   let cwd = TempDir::new(\"foo\").expect(\"rust_path_hack_cwd\");\n-   let cwd = cwd.path().join(\"foo\");\n-   fs::mkdir_recursive(&cwd, io::UserRWX);\n-   writeFile(&cwd.join(\"lib.rs\"), \"pub fn f() { }\");\n-\n-   let dest_workspace = mk_empty_workspace(&CrateId::new(\"bar\"), \"dest_workspace\");\n-   let dest_workspace = dest_workspace.path();\n-   // FIXME (#9639): This needs to handle non-utf8 paths\n-   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n-   command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n-   debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &CrateId::new(\"foo\"));\n-   assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(&cwd, &CrateId::new(\"foo\")));\n-   assert!(!built_library_exists(&cwd, \"foo\"));\n+    // Same as rust_path_hack_test, but the CWD is the dir to build out of\n+    let cwd = TempDir::new(\"foo\").expect(\"rust_path_hack_cwd\");\n+    let cwd = cwd.path().join(\"foo\");\n+    fs::mkdir_recursive(&cwd, io::UserRWX);\n+    writeFile(&cwd.join(\"lib.rs\"), \"pub fn f() { }\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n+    let bar_id: CrateId = from_str(\"bar\").unwrap();\n+\n+    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n+    let dest_workspace = dest_workspace.path();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n+    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"foo\"], &cwd, rust_path);\n+    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n+    assert_lib_exists(dest_workspace, &foo_id);\n+    assert_built_library_exists(dest_workspace, \"foo\");\n+    assert!(!lib_exists(&cwd, &foo_id));\n+    assert!(!built_library_exists(&cwd, \"foo\"));\n }\n \n #[test]\n fn rust_path_hack_multi_path() {\n-   // Same as rust_path_hack_test, but with a more complex package ID\n-   let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_cwd\");\n-   let subdir = cwd.path().join_many([\"foo\", \"bar\", \"quux\"]);\n-   fs::mkdir_recursive(&subdir, io::UserRWX);\n-   writeFile(&subdir.join(\"lib.rs\"), \"pub fn f() { }\");\n-   let name = ~\"foo/bar/quux\";\n-\n-   let dest_workspace = mk_empty_workspace(&CrateId::new(\"bar\"), \"dest_workspace\");\n-   let dest_workspace = dest_workspace.path();\n-   // FIXME (#9639): This needs to handle non-utf8 paths\n-   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n-   command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n-   debug!(\"Checking that {} exists in {}\", name, dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &CrateId::new(\"foo/bar/quux\"));\n-   assert_built_library_exists(dest_workspace, name);\n-   assert!(!lib_exists(&subdir, &CrateId::new(\"foo/bar/quux\")));\n-   assert!(!built_library_exists(&subdir, name));\n+    // Same as rust_path_hack_test, but with a more complex package ID\n+    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_cwd\");\n+    let subdir = cwd.path().join_many([\"foo\", \"bar\", \"quux\"]);\n+    fs::mkdir_recursive(&subdir, io::UserRWX);\n+    writeFile(&subdir.join(\"lib.rs\"), \"pub fn f() { }\");\n+    let name = ~\"foo/bar/quux\";\n+    let foo_id: CrateId = from_str(\"foo/bar/quux\").unwrap();\n+    let bar_id: CrateId = from_str(\"bar\").unwrap();\n+\n+    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n+    let dest_workspace = dest_workspace.path();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n+    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", name.clone()], &subdir, rust_path);\n+    debug!(\"Checking that {} exists in {}\", name, dest_workspace.display());\n+    assert_lib_exists(dest_workspace, &foo_id);\n+    assert_built_library_exists(dest_workspace, name);\n+    assert!(!lib_exists(&subdir, &foo_id));\n+    assert!(!built_library_exists(&subdir, name));\n }\n \n #[test]\n fn rust_path_hack_install_no_arg() {\n-   // Same as rust_path_hack_cwd, but making rustpkg infer the pkg id\n-   let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_install_no_arg\");\n-   let cwd = cwd.path();\n-   let source_dir = cwd.join(\"foo\");\n-   assert!(make_dir_rwx(&source_dir));\n-   writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n-\n-   let dest_workspace = mk_empty_workspace(&CrateId::new(\"bar\"), \"dest_workspace\");\n-   let dest_workspace = dest_workspace.path();\n-   // FIXME (#9639): This needs to handle non-utf8 paths\n-   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n-   command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n-   debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-   assert_lib_exists(dest_workspace, &CrateId::new(\"foo\"));\n-   assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!lib_exists(&source_dir, &CrateId::new(\"foo\")));\n-   assert!(!built_library_exists(cwd, \"foo\"));\n+    // Same as rust_path_hack_cwd, but making rustpkg infer the pkg id\n+    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_install_no_arg\");\n+    let cwd = cwd.path();\n+    let source_dir = cwd.join(\"foo\");\n+    assert!(make_dir_rwx(&source_dir));\n+    writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n+\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n+    let bar_id: CrateId = from_str(\"bar\").unwrap();\n+    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n+    let dest_workspace = dest_workspace.path();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n+    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n+    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n+    assert_lib_exists(dest_workspace, &foo_id);\n+    assert_built_library_exists(dest_workspace, \"foo\");\n+    assert!(!lib_exists(&source_dir, &foo_id));\n+    assert!(!built_library_exists(cwd, \"foo\"));\n }\n \n #[test]\n fn rust_path_hack_build_no_arg() {\n-   // Same as rust_path_hack_install_no_arg, but building instead of installing\n-   let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_build_no_arg\");\n-   let source_dir = cwd.path().join(\"foo\");\n-   assert!(make_dir_rwx(&source_dir));\n-   writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n-\n-   let dest_workspace = mk_empty_workspace(&CrateId::new(\"bar\"), \"dest_workspace\");\n-   let dest_workspace = dest_workspace.path();\n-   // FIXME (#9639): This needs to handle non-utf8 paths\n-   let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n-   command_line_test_with_env([~\"build\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n-   debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n-   assert_built_library_exists(dest_workspace, \"foo\");\n-   assert!(!built_library_exists(&source_dir, \"foo\"));\n+    // Same as rust_path_hack_install_no_arg, but building instead of installing\n+    let cwd = TempDir::new(\"pkg_files\").expect(\"rust_path_hack_build_no_arg\");\n+    let source_dir = cwd.path().join(\"foo\");\n+    assert!(make_dir_rwx(&source_dir));\n+    writeFile(&source_dir.join(\"lib.rs\"), \"pub fn f() { }\");\n+\n+    let bar_id: CrateId = from_str(\"bar\").unwrap();\n+    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n+    let dest_workspace = dest_workspace.path();\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    let rust_path = Some(~[(~\"RUST_PATH\", dest_workspace.as_str().unwrap().to_owned())]);\n+    command_line_test_with_env([~\"build\", ~\"--rust-path-hack\"], &source_dir, rust_path);\n+    debug!(\"Checking that foo exists in {}\", dest_workspace.display());\n+    assert_built_library_exists(dest_workspace, \"foo\");\n+    assert!(!built_library_exists(&source_dir, \"foo\"));\n }\n \n #[test]\n fn rust_path_hack_build_with_dependency() {\n-    let foo_id = CrateId::new(\"foo\");\n-    let dep_id = CrateId::new(\"dep\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n+    let dep_id: CrateId = from_str(\"dep\").unwrap();\n     // Tests that when --rust-path-hack is in effect, dependencies get built\n     // into the destination workspace and not the source directory\n     let work_dir = create_local_package(&foo_id);\n@@ -1488,7 +1495,8 @@ fn rust_path_hack_build_with_dependency() {\n fn rust_path_install_target() {\n     let dir_for_path = TempDir::new(\n         \"source_workspace\").expect(\"rust_path_install_target failed\");\n-    let mut dir = mk_workspace(dir_for_path.path(), &CrateId::new(\"foo\"));\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n+    let mut dir = mk_workspace(dir_for_path.path(), &foo_id);\n     debug!(\"dir = {}\", dir.display());\n     writeFile(&dir.join(\"main.rs\"), \"fn main() { let _x = (); }\");\n     let dir_to_install_to = TempDir::new(\n@@ -1511,7 +1519,7 @@ fn rust_path_install_target() {\n \n #[test]\n fn sysroot_flag() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     // no-op sysroot setting; I'm not sure how else to test this\n@@ -1527,7 +1535,7 @@ fn sysroot_flag() {\n \n #[test]\n fn compile_flag_build() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1544,7 +1552,7 @@ fn compile_flag_build() {\n #[test]\n fn compile_flag_fail() {\n     // --no-link shouldn't be accepted for install\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1560,7 +1568,7 @@ fn compile_flag_fail() {\n \n #[test]\n fn notrans_flag_build() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n@@ -1585,7 +1593,7 @@ fn notrans_flag_build() {\n #[test]\n fn notrans_flag_fail() {\n     // --no-trans shouldn't be accepted for install\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n@@ -1600,13 +1608,13 @@ fn notrans_flag_fail() {\n                           workspace, None, BAD_FLAG_CODE);\n         assert!(!built_executable_exists(workspace, \"foo\"));\n         assert!(!object_file_exists(workspace, \"foo\"));\n-        assert!(!lib_exists(workspace, &CrateId::new(\"foo\")));\n+        assert!(!lib_exists(workspace, &p_id));\n     }\n }\n \n #[test]\n fn dash_S() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1623,7 +1631,7 @@ fn dash_S() {\n \n #[test]\n fn dash_S_fail() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1640,7 +1648,7 @@ fn dash_S_fail() {\n \n #[test]\n fn test_cfg_build() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     // If the cfg flag gets messed up, this won't compile\n@@ -1659,7 +1667,7 @@ fn test_cfg_build() {\n \n #[test]\n fn test_cfg_fail() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     writeFile(&workspace.join_many([\"src\", \"foo-0.0\", \"main.rs\"]),\n@@ -1678,7 +1686,7 @@ fn test_cfg_fail() {\n \n #[test]\n fn test_emit_llvm_S_build() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1696,7 +1704,7 @@ fn test_emit_llvm_S_build() {\n \n #[test]\n fn test_emit_llvm_S_fail() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1716,7 +1724,7 @@ fn test_emit_llvm_S_fail() {\n \n #[test]\n fn test_emit_llvm_build() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1735,7 +1743,7 @@ fn test_emit_llvm_build() {\n \n #[test]\n fn test_emit_llvm_fail() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1756,7 +1764,7 @@ fn test_emit_llvm_fail() {\n \n #[test]\n fn test_linker_build() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let matches = getopts([], optgroups());\n@@ -1801,7 +1809,7 @@ fn test_build_install_flags_fail() {\n \n #[test]\n fn test_optimized_build() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1842,8 +1850,8 @@ fn crateid_pointing_to_subdir() {\n     fs::mkdir_recursive(&testpkg_dir, io::UserRWX);\n \n     writeFile(&testpkg_dir.join(\"main.rs\"),\n-              \"extern mod foo = \\\"mockgithub.com/mozilla/some_repo/extras/foo\\\";\\n\n-               extern mod bar = \\\"mockgithub.com/mozilla/some_repo/extras/bar\\\";\\n\n+              \"extern mod foo = \\\"mockgithub.com/mozilla/some_repo/extras/foo#foo:0.0\\\";\\n\n+               extern mod bar = \\\"mockgithub.com/mozilla/some_repo/extras/bar#bar:0.0\\\";\\n\n                use foo::f; use bar::g; \\n\n                fn main() { f(); g(); }\");\n \n@@ -1853,9 +1861,9 @@ fn crateid_pointing_to_subdir() {\n \n #[test]\n fn test_recursive_deps() {\n-    let a_id = CrateId::new(\"a\");\n-    let b_id = CrateId::new(\"b\");\n-    let c_id = CrateId::new(\"c\");\n+    let a_id: CrateId = from_str(\"a\").unwrap();\n+    let b_id: CrateId = from_str(\"b\").unwrap();\n+    let c_id: CrateId = from_str(\"c\").unwrap();\n     let b_workspace = create_local_package_with_dep(&b_id, &c_id);\n     let b_workspace = b_workspace.path();\n     writeFile(&b_workspace.join_many([\"src\", \"c-0.0\", \"lib.rs\"]),\n@@ -1872,17 +1880,18 @@ fn test_recursive_deps() {\n     command_line_test_with_env([~\"install\", ~\"a\"],\n                                a_workspace,\n                                environment);\n-    assert_lib_exists(a_workspace, &CrateId::new(\"a\"));\n-    assert_lib_exists(b_workspace, &CrateId::new(\"b\"));\n-    assert_lib_exists(b_workspace, &CrateId::new(\"c\"));\n+    assert_lib_exists(a_workspace, &a_id);\n+    assert_lib_exists(b_workspace, &b_id);\n+    assert_lib_exists(b_workspace, &c_id);\n }\n \n #[test]\n fn test_install_to_rust_path() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let second_workspace = create_local_package(&p_id);\n     let second_workspace = second_workspace.path();\n-    let first_workspace = mk_empty_workspace(&CrateId::new(\"p\"), \"dest\");\n+    let none_id: CrateId = from_str(\"p\").unwrap();\n+    let first_workspace = mk_empty_workspace(&none_id, \"dest\");\n     let first_workspace = first_workspace.path();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let rust_path = Some(~[(~\"RUST_PATH\",\n@@ -1903,7 +1912,7 @@ fn test_install_to_rust_path() {\n \n #[test]\n fn test_target_specific_build_dir() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1919,7 +1928,7 @@ fn test_target_specific_build_dir() {\n \n #[test]\n fn test_target_specific_install_dir() {\n-    let p_id = CrateId::new(\"foo\");\n+    let p_id: CrateId = from_str(\"foo\").unwrap();\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n     let test_sys = test_sysroot();\n@@ -1929,7 +1938,7 @@ fn test_target_specific_install_dir() {\n                        ~\"foo\"],\n                       workspace);\n     assert!(workspace.join_many([~\"lib\", host_triple()]).is_dir());\n-    assert_lib_exists(workspace, &CrateId::new(\"foo\"));\n+    assert_lib_exists(workspace, &p_id);\n     assert!(fs::readdir(&workspace.join(\"lib\")).len() == 1);\n     assert!(workspace.join(\"bin\").is_dir());\n     assert_executable_exists(workspace, \"foo\");\n@@ -1938,7 +1947,7 @@ fn test_target_specific_install_dir() {\n #[test]\n #[ignore(reason = \"See #7240\")]\n fn test_dependencies_terminate() {\n-    let b_id = CrateId::new(\"b\");\n+    let b_id: CrateId = from_str(\"b\").unwrap();\n     let workspace = create_local_package(&b_id);\n     let workspace = workspace.path();\n     let b_dir = workspace.join_many([\"src\", \"b-0.0\"]);\n@@ -1951,42 +1960,42 @@ fn test_dependencies_terminate() {\n \n #[test]\n fn install_after_build() {\n-    let b_id = CrateId::new(\"b\");\n+    let b_id: CrateId = from_str(\"b\").unwrap();\n     let workspace = create_local_package(&b_id);\n     let workspace = workspace.path();\n     command_line_test([~\"build\", ~\"b\"], workspace);\n     command_line_test([~\"install\", ~\"b\"], workspace);\n-    assert_executable_exists(workspace, b_id.short_name);\n+    assert_executable_exists(workspace, b_id.name);\n     assert_lib_exists(workspace, &b_id);\n }\n \n #[test]\n fn reinstall() {\n-    let b = CrateId::new(\"b\");\n+    let b: CrateId = from_str(\"b\").unwrap();\n     let workspace = create_local_package(&b);\n     let workspace = workspace.path();\n     // 1. Install, then remove executable file, then install again,\n     // and make sure executable was re-installed\n     command_line_test([~\"install\", ~\"b\"], workspace);\n-    assert_executable_exists(workspace, b.short_name);\n+    assert_executable_exists(workspace, b.name);\n     assert_lib_exists(workspace, &b);\n     remove_executable_file(&b, workspace);\n     command_line_test([~\"install\", ~\"b\"], workspace);\n-    assert_executable_exists(workspace, b.short_name);\n+    assert_executable_exists(workspace, b.name);\n     // 2. Build, then remove build executable file, then build again,\n     // and make sure executable was re-built.\n     command_line_test([~\"build\", ~\"b\"], workspace);\n     remove_built_executable_file(&b, workspace);\n     command_line_test([~\"build\", ~\"b\"], workspace);\n-    assert_built_executable_exists(workspace, b.short_name);\n+    assert_built_executable_exists(workspace, b.name);\n     // 3. Install, then remove both executable and built executable,\n     // then install again, make sure both were recreated\n     command_line_test([~\"install\", ~\"b\"], workspace);\n     remove_executable_file(&b, workspace);\n     remove_built_executable_file(&b, workspace);\n     command_line_test([~\"install\", ~\"b\"], workspace);\n-    assert_executable_exists(workspace, b.short_name);\n-    assert_built_executable_exists(workspace, b.short_name);\n+    assert_executable_exists(workspace, b.name);\n+    assert_built_executable_exists(workspace, b.name);\n }\n \n #[test]\n@@ -2001,11 +2010,11 @@ fn correct_package_name_with_rust_path_hack() {\n     */\n \n     // Set RUST_PATH to something containing only the sources for foo\n-    let foo_id = CrateId::new(\"foo\");\n-    let bar_id = CrateId::new(\"bar\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n+    let bar_id: CrateId = from_str(\"bar\").unwrap();\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n-    let dest_workspace = mk_empty_workspace(&CrateId::new(\"bar\"), \"dest_workspace\");\n+    let dest_workspace = mk_empty_workspace(&bar_id, \"dest_workspace\");\n     let dest_workspace = dest_workspace.path();\n \n     writeFile(&dest_workspace.join_many([\"src\", \"bar-0.0\", \"main.rs\"]),\n@@ -2031,7 +2040,7 @@ fn correct_package_name_with_rust_path_hack() {\n \n #[test]\n fn test_rustpkg_test_creates_exec() {\n-    let foo_id = CrateId::new(\"foo\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n@@ -2042,7 +2051,8 @@ fn test_rustpkg_test_creates_exec() {\n \n #[test]\n fn test_rustpkg_test_output() {\n-    let workspace = create_local_package_with_test(&CrateId::new(\"foo\"));\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n+    let workspace = create_local_package_with_test(&foo_id);\n     let output = command_line_test([~\"test\", ~\"foo\"], workspace.path());\n     let output_str = str::from_utf8(output.output).unwrap();\n     // The first two assertions are separate because test output may\n@@ -2054,7 +2064,7 @@ fn test_rustpkg_test_output() {\n \n #[test]\n fn test_rustpkg_test_failure_exit_status() {\n-    let foo_id = CrateId::new(\"foo\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n@@ -2068,7 +2078,7 @@ fn test_rustpkg_test_failure_exit_status() {\n \n #[test]\n fn test_rustpkg_test_cfg() {\n-    let foo_id = CrateId::new(\"foo\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     writeFile(&foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]),\n@@ -2081,7 +2091,7 @@ fn test_rustpkg_test_cfg() {\n \n #[test]\n fn test_rebuild_when_needed() {\n-    let foo_id = CrateId::new(\"foo\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     let test_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]);\n@@ -2102,7 +2112,7 @@ fn test_rebuild_when_needed() {\n #[test]\n #[ignore] // FIXME (#10257): This doesn't work as is since a read only file can't execute\n fn test_no_rebuilding() {\n-    let foo_id = CrateId::new(\"foo\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     let test_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"test.rs\"]);\n@@ -2124,8 +2134,9 @@ fn test_no_rebuilding() {\n fn test_installed_read_only() {\n     // Install sources from a \"remote\" (actually a local github repo)\n     // Check that afterward, sources are read-only and installed under build/\n-    let mut temp_pkg_id = git_repo_pkg();\n-    let repo = init_git_repo(&temp_pkg_id.path);\n+    let temp_pkg_id = git_repo_pkg();\n+    let path = Path::new(temp_pkg_id.path.as_slice());\n+    let repo = init_git_repo(&path);\n     let repo = repo.path();\n     debug!(\"repo = {}\", repo.display());\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n@@ -2137,10 +2148,9 @@ fn test_installed_read_only() {\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"0.0\"); // this has the effect of committing the files\n     // update crateid to what will be auto-detected\n-    temp_pkg_id.version = Some(~\"0.0\");\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([~\"install\", temp_pkg_id.path.as_str().unwrap().to_owned()], repo);\n+    command_line_test([~\"install\", temp_pkg_id.to_str()], repo);\n \n     let ws = repo.join(\".rust\");\n     // Check that all files exist\n@@ -2156,8 +2166,10 @@ fn test_installed_read_only() {\n     assert!(is_rwx(&built_lib));\n \n     // Make sure sources are (a) under \"build\" and (b) read-only\n-    let src1 = target_build_dir(&ws).join_many([~\"src\", temp_pkg_id.to_str(), ~\"main.rs\"]);\n-    let src2 = target_build_dir(&ws).join_many([~\"src\", temp_pkg_id.to_str(), ~\"lib.rs\"]);\n+    let temp_dir = format!(\"{}-{}\", temp_pkg_id.path, temp_pkg_id.version_or_default());\n+    let src1 = target_build_dir(&ws).join_many([~\"src\", temp_dir.clone(), ~\"main.rs\"]);\n+    let src2 = target_build_dir(&ws).join_many([~\"src\", temp_dir.clone(), ~\"lib.rs\"]);\n+    debug!(\"src1: {}\", src1.display());\n     assert!(src1.exists());\n     assert!(src2.exists());\n     assert!(is_read_only(&src1));\n@@ -2167,7 +2179,7 @@ fn test_installed_read_only() {\n #[test]\n fn test_installed_local_changes() {\n     let temp_pkg_id = git_repo_pkg();\n-    let repo = init_git_repo(&temp_pkg_id.path);\n+    let repo = init_git_repo(&Path::new(temp_pkg_id.path.as_slice()));\n     let repo = repo.path();\n     debug!(\"repo = {}\", repo.display());\n     let repo_subdir = repo.join_many([\"mockgithub.com\", \"catamorphism\", \"test-pkg\"]);\n@@ -2180,9 +2192,7 @@ fn test_installed_local_changes() {\n               \"pub fn f() { let _x = (); }\");\n     add_git_tag(&repo_subdir, ~\"0.1\"); // this has the effect of committing the files\n \n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([~\"install\", temp_pkg_id.path.as_str().unwrap().to_owned()], repo);\n-\n+    command_line_test([~\"install\", temp_pkg_id.path.to_owned()], repo);\n \n     // We installed the dependency.\n     // Now start a new workspace and clone it into it\n@@ -2214,14 +2224,13 @@ fn test_installed_local_changes() {\n               fn main() { g(); }\");\n     // And make sure we can build it\n \n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    command_line_test([~\"build\", importer_pkg_id.path.as_str().unwrap().to_owned()],\n-                      hacking_workspace);\n+    command_line_test([~\"build\", importer_pkg_id.path.to_owned()], hacking_workspace);\n }\n \n #[test]\n fn test_7402() {\n-    let dir = create_local_package(&CrateId::new(\"foo\"));\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n+    let dir = create_local_package(&foo_id);\n     let dest_workspace = TempDir::new(\"more_rust\").expect(\"test_7402\");\n     let dest_workspace = dest_workspace.path();\n     // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -2235,7 +2244,7 @@ fn test_7402() {\n \n #[test]\n fn test_compile_error() {\n-    let foo_id = CrateId::new(\"foo\");\n+    let foo_id: CrateId = from_str(\"foo\").unwrap();\n     let foo_workspace = create_local_package(&foo_id);\n     let foo_workspace = foo_workspace.path();\n     let main_crate = foo_workspace.join_many([\"src\", \"foo-0.0\", \"main.rs\"]);\n@@ -2269,7 +2278,8 @@ fn test_c_dependency_ok() {\n     // registers a hook to build it if it's not fresh\n     // After running `build`, test that the C library built\n \n-    let dir = create_local_package(&CrateId::new(\"cdep\"));\n+    let cdep_id: CrateId = from_str(\"cdep\").unwrap();\n+    let dir = create_local_package(&cdep_id);\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n@@ -2292,7 +2302,8 @@ fn test_c_dependency_ok() {\n #[test]\n #[ignore(reason=\"busted\")]\n fn test_c_dependency_no_rebuilding() {\n-    let dir = create_local_package(&CrateId::new(\"cdep\"));\n+    let cdep_id: CrateId = from_str(\"cdep\").unwrap();\n+    let dir = create_local_package(&cdep_id);\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n@@ -2326,7 +2337,8 @@ fn test_c_dependency_no_rebuilding() {\n #[test]\n #[ignore(reason=\"busted\")]\n fn test_c_dependency_yes_rebuilding() {\n-    let dir = create_local_package(&CrateId::new(\"cdep\"));\n+    let cdep_id: CrateId = from_str(\"cdep\").unwrap();\n+    let dir = create_local_package(&cdep_id);\n     let dir = dir.path();\n     writeFile(&dir.join_many([\"src\", \"cdep-0.0\", \"main.rs\"]),\n               \"#[link_args = \\\"-lfoo\\\"]\\nextern { fn f(); } \\\n@@ -2347,7 +2359,7 @@ fn test_c_dependency_yes_rebuilding() {\n     assert!(c_library_path.exists());\n \n     // Now, make the Rust library read-only so rebuilding will fail\n-    match built_library_in_workspace(&CrateId::new(\"cdep\"), dir) {\n+    match built_library_in_workspace(&cdep_id, dir) {\n         Some(ref pth) => assert!(chmod_read_only(pth)),\n         None => assert_built_library_exists(dir, \"cdep\")\n     }\n@@ -2365,7 +2377,8 @@ fn test_c_dependency_yes_rebuilding() {\n fn correct_error_dependency() {\n     // Supposing a package we're trying to install via a dependency doesn't\n     // exist, we should throw a condition, and not ICE\n-    let workspace_dir = create_local_package(&CrateId::new(\"badpkg\"));\n+    let crate_id: CrateId = from_str(\"badpkg\").unwrap();\n+    let workspace_dir = create_local_package(&crate_id);\n \n     let dir = workspace_dir.path();\n     let main_rs = dir.join_many([\"src\", \"badpkg-0.0\", \"main.rs\"]);"}, {"sha": "9042dfea2562e0a1aa518cdd64ead7af778d30c2", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "patch": "@@ -10,14 +10,18 @@\n \n #[allow(dead_code)];\n \n+pub use target::{OutputType, Main, Lib, Bench, Test, JustOne, lib_name_of, lib_crate_filename};\n+pub use target::{Target, Build, Install};\n+pub use target::{lib_name_of, lib_crate_filename, WhatToBuild, MaybeCustom, Inferred};\n+\n use std::cell::RefCell;\n use std::libc;\n use std::os;\n use std::io;\n use std::io::fs;\n use extra::workcache;\n use rustc::metadata::creader::Loader;\n-use rustc::driver::{driver, session};\n+use extra::treemap::TreeMap;\n use extra::getopts::groups::getopts;\n use syntax;\n use syntax::codemap::{DUMMY_SP, Spanned};\n@@ -28,19 +32,16 @@ use syntax::attr::AttrMetaMethods;\n use syntax::fold::Folder;\n use syntax::visit::Visitor;\n use syntax::util::small_vector::SmallVector;\n+use syntax::crateid::CrateId;\n use rustc::back::link::OutputTypeExe;\n use rustc::back::link;\n+use rustc::driver::{driver, session};\n use CtxMethods;\n use context::{in_target, StopBefore, Link, Assemble, BuildContext};\n-use crate_id::CrateId;\n use package_source::PkgSrc;\n use workspace::pkg_parent_workspaces;\n use path_util::{system_library, target_build_dir};\n use path_util::{default_workspace, built_library_in_workspace};\n-pub use target::{OutputType, Main, Lib, Bench, Test, JustOne, lib_name_of, lib_crate_filename};\n-pub use target::{Target, Build, Install};\n-use extra::treemap::TreeMap;\n-pub use target::{lib_name_of, lib_crate_filename, WhatToBuild, MaybeCustom, Inferred};\n use workcache_support::{digest_file_with_date, digest_only_date};\n use messages::error;\n \n@@ -177,11 +178,11 @@ pub fn compile_input(context: &BuildContext,\n     // not sure if we should support anything else\n \n     let mut out_dir = target_build_dir(workspace);\n-    out_dir.push(&crate_id.path);\n+    out_dir.push(crate_id.path.as_slice());\n     // Make the output directory if it doesn't exist already\n     fs::mkdir_recursive(&out_dir, io::UserRWX);\n \n-    let binary = os::args()[0].to_owned();\n+    let binary = os::args()[0];\n \n     debug!(\"flags: {}\", flags.connect(\" \"));\n     debug!(\"cfgs: {}\", cfgs.connect(\" \"));\n@@ -312,7 +313,7 @@ pub fn compile_input(context: &BuildContext,\n     if !attr::contains_name(crate.attrs, \"crate_id\") {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let crateid_attr =\n-            attr::mk_name_value_item_str(@\"crate_id\", crate_id.to_crate_id_str().to_managed());\n+            attr::mk_name_value_item_str(@\"crate_id\", crate_id.to_str().to_managed());\n \n         debug!(\"crateid attr: {:?}\", crateid_attr);\n         crate.attrs.push(attr::mk_attr(crateid_attr));\n@@ -441,7 +442,7 @@ pub fn compile_crate(ctxt: &BuildContext,\n                      opt: session::OptLevel,\n                      what: OutputType) -> Option<Path> {\n     debug!(\"compile_crate: crate={}, workspace={}\", crate.display(), workspace.display());\n-    debug!(\"compile_crate: short_name = {}, flags =...\", crate_id.to_str());\n+    debug!(\"compile_crate: name = {}, flags =...\", crate_id.to_str());\n     for fl in flags.iter() {\n         debug!(\"+++ {}\", *fl);\n     }\n@@ -470,8 +471,9 @@ impl<'a> CrateInstaller<'a> {\n                     None => self.sess.str_of(lib_ident)\n                 };\n                 debug!(\"Finding and installing... {}\", lib_name);\n+                let crate_id: CrateId = from_str(lib_name).expect(\"valid crate id\");\n                 // Check standard Rust library path first\n-                let whatever = system_library(&self.context.sysroot_to_use(), lib_name);\n+                let whatever = system_library(&self.context.sysroot_to_use(), &crate_id);\n                 debug!(\"system library returned {:?}\", whatever);\n                 match whatever {\n                     Some(ref installed_path) => {\n@@ -491,10 +493,8 @@ impl<'a> CrateInstaller<'a> {\n                     }\n                     None => {\n                         // FIXME #8711: need to parse version out of path_opt\n-                        debug!(\"Trying to install library {}, rebuilding it\",\n-                               lib_name.to_str());\n+                        debug!(\"Trying to install library {}, rebuilding it\", crate_id.to_str());\n                         // Try to install it\n-                        let crate_id = CrateId::new(lib_name);\n                         // Find all the workspaces in the RUST_PATH that contain this package.\n                         let workspaces = pkg_parent_workspaces(&self.context.context,\n                                                                &crate_id);\n@@ -526,8 +526,8 @@ impl<'a> CrateInstaller<'a> {\n                                  // Nonexistent package? Then print a better error\n                                  error(format!(\"Package {} depends on {}, but I don't know \\\n                                                how to find it\",\n-                                               self.parent.path.display(),\n-                                               crate_id.path.display()));\n+                                               self.parent.path,\n+                                               crate_id.path));\n                                  fail!()\n                         }).inside(|| {\n                             PkgSrc::new(source_workspace.clone(),"}, {"sha": "e19a19dc8ab6addaae34142a44a487bd7e6fec00", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "patch": "@@ -11,12 +11,11 @@\n // rustpkg utilities having to do with workspaces\n \n use std::os;\n-use std::path::Path;\n use context::Context;\n use path_util::{workspace_contains_crate_id, find_dir_using_rust_path_hack, default_workspace};\n use path_util::rust_path;\n use util::option_to_vec;\n-use crate_id::CrateId;\n+use syntax::crateid::CrateId;\n \n pub fn each_pkg_parent_workspace(cx: &Context,\n                                  crateid: &CrateId,\n@@ -29,7 +28,7 @@ pub fn each_pkg_parent_workspace(cx: &Context,\n         // tjc: make this a condition\n         fail!(\"Package {} not found in any of \\\n                     the following workspaces: {}\",\n-                   crateid.path.display(),\n+                   crateid.path,\n                    rust_path().map(|p| p.display().to_str()).to_str());\n     }\n     for ws in workspaces.iter() {\n@@ -64,7 +63,8 @@ pub fn cwd_to_workspace() -> Option<(Path, CrateId)> {\n             let rel = cwd.path_relative_from(&srcpath);\n             let rel_s = rel.as_ref().and_then(|p|p.as_str());\n             if rel_s.is_some() {\n-                return Some((path, CrateId::new(rel_s.unwrap())));\n+                let crate_id = from_str(rel_s.unwrap()).expect(\"valid crate id\");\n+                return Some((path, crate_id));\n             }\n         }\n     }"}, {"sha": "0831f319ce7b9f9fac92ac17c3fa6027c50ffff9", "filename": "src/libsyntax/crateid.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6a31ecb0481af3bd5f8ba3655dda0dde9df7116/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=a6a31ecb0481af3bd5f8ba3655dda0dde9df7116", "patch": "@@ -70,7 +70,11 @@ impl FromStr for CrateId {\n             };\n \n             let version = if !hash_version.is_empty() {\n-                Some(hash_version.to_owned())\n+                if hash_version == \"0.0\" {\n+                    None\n+                } else {\n+                    Some(hash_version.to_owned())\n+                }\n             } else {\n                 None\n             };\n@@ -93,6 +97,10 @@ impl CrateId {\n             Some(ref version) => version.as_slice(),\n         }\n     }\n+\n+    pub fn short_name_with_version(&self) -> ~str {\n+        format!(\"{}-{}\", self.name, self.version_or_default())\n+    }\n }\n \n #[test]"}]}