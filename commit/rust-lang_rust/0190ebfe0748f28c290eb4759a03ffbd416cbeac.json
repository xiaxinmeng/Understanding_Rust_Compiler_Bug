{"sha": "0190ebfe0748f28c290eb4759a03ffbd416cbeac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxOTBlYmZlMDc0OGYyOGMyOTBlYjQ3NTlhMDNmZmJkNDE2Y2JlYWM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-04-22T00:39:04Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-28T20:26:19Z"}, "message": "Support all expression forms in typestate\n\nAdded support for self_method, cont, chan, port, recv, send, be,\ndo_while, spawn, and ext; handled break and cont correctly.\n(However, there are no non-xfailed test cases for ext or spawn in\nstage0 currently.)\n\nAlthough the standard library compiles and all test cases pass with\ntypestate enabled, I left typestate checking disabled as rustc\nterminates abnormally when building the standard library if so,\neven though it does generate code correctly.", "tree": {"sha": "a419e87e4071017aa52399f74646865f3f2c22ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a419e87e4071017aa52399f74646865f3f2c22ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0190ebfe0748f28c290eb4759a03ffbd416cbeac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0190ebfe0748f28c290eb4759a03ffbd416cbeac", "html_url": "https://github.com/rust-lang/rust/commit/0190ebfe0748f28c290eb4759a03ffbd416cbeac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0190ebfe0748f28c290eb4759a03ffbd416cbeac/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c4f8cb45924326e21547d19cbed683115657616", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4f8cb45924326e21547d19cbed683115657616", "html_url": "https://github.com/rust-lang/rust/commit/7c4f8cb45924326e21547d19cbed683115657616"}], "stats": {"total": 286, "additions": 274, "deletions": 12}, "files": [{"sha": "693521778ddd5f3fc6dc55552d7cfb64f339315d", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 198, "deletions": 12, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/0190ebfe0748f28c290eb4759a03ffbd416cbeac/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0190ebfe0748f28c290eb4759a03ffbd416cbeac/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=0190ebfe0748f28c290eb4759a03ffbd416cbeac", "patch": "@@ -106,6 +106,7 @@ import util.common.log_stmt;\n import util.common.log_block;\n import util.common.log_stmt_err;\n import util.common.log_block_err;\n+import util.common.has_nonlocal_exits;\n import util.common.decl_lhs;\n import util.typestate_ann;\n import util.typestate_ann.ts_ann;\n@@ -466,6 +467,9 @@ fn expr_ann(&expr e) -> ann {\n     case (expr_cont(?a)) {\n         ret a;\n     }\n+    case (expr_self_method(_, ?a)) {\n+        ret a;\n+    }\n   }\n }\n \n@@ -896,6 +900,11 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             _vec.push[@expr](args, operator);\n             find_pre_post_exprs(fm, enclosing, args, a);\n         }\n+        case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n+            auto args = _vec.clone[@expr](operands);\n+            _vec.push[@expr](args, operator);\n+            find_pre_post_exprs(fm, enclosing, args, a);\n+        }\n         case (expr_vec(?args, _, ?a)) {\n             find_pre_post_exprs(fm, enclosing, args, a);\n         }\n@@ -923,10 +932,19 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             // Otherwise, variable is global, so it must be initialized\n             set_pre_and_post(a, res);\n         }\n+        case (expr_self_method(?v, ?a)) {\n+            /* v is a method of the enclosing obj, so it must be\n+               initialized, right? */\n+            set_pre_and_post(a, empty_pre_post(num_local_vars));\n+        }\n         case(expr_log(_, ?arg, ?a)) {\n             find_pre_post_expr(fm, enclosing, *arg);\n             set_pre_and_post(a, expr_pp(*arg));\n         }\n+        case (expr_chan(?arg, ?a)) {\n+            find_pre_post_expr(fm, enclosing, *arg);\n+            set_pre_and_post(a, expr_pp(*arg));\n+        }\n         case(expr_put(?opt, ?a)) {\n             alt (opt) {\n                 case (some[@expr](?arg)) {\n@@ -963,6 +981,22 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n                 }\n             }\n         }\n+        case (expr_recv(?lhs, ?rhs, ?a)) {\n+            alt (lhs.node) {\n+                case (expr_path(?p, some[def](def_local(?d_id)), ?a_lhs)) {\n+                    find_pre_post_expr(fm, enclosing, *rhs);\n+                    set_pre_and_post(a, expr_pp(*rhs));\n+                    log(\"gen:\");\n+                    log_expr(e);\n+                    gen(enclosing, a, d_id);\n+                }\n+                case (_) {\n+                    // doesn't check that lhs is an lval, but\n+                    // that's probably ok\n+                    find_pre_post_exprs(fm, enclosing, vec(lhs, rhs), a);\n+                }\n+            }\n+        }\n         case (expr_assign_op(_, ?lhs, ?rhs, ?a)) {\n             /* Different from expr_assign in that the lhs *must*\n                already be initialized */\n@@ -987,6 +1021,11 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n                 }\n             }\n         }\n+        case (expr_be(?e, ?a)) {\n+            find_pre_post_expr(fm, enclosing, *e);\n+            set_pre_and_post(a, rec(precondition=expr_prestate(*e),\n+                          postcondition=false_postcond(num_local_vars)));\n+        }\n         case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n             find_pre_post_expr(fm, enclosing, *antec);\n             find_pre_post_block(fm, enclosing, conseq);\n@@ -1028,6 +1067,9 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n              FIXME */\n             find_pre_post_exprs(fm, enclosing, vec(l, r), a);\n         }\n+        case (expr_send(?l, ?r, ?a)) {\n+            find_pre_post_exprs(fm, enclosing, vec(l, r), a);\n+        }\n         case (expr_unary(_,?operand,?a)) {\n             find_pre_post_expr(fm, enclosing, *operand);\n             set_pre_and_post(a, expr_pp(*operand));\n@@ -1048,6 +1090,24 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n                   intersect_postconds(vec(expr_postcond(*test),\n                                           block_postcond(body)))));\n         }\n+        case (expr_do_while(?body, ?test, ?a)) {\n+            find_pre_post_block(fm, enclosing, body);\n+            find_pre_post_expr(fm, enclosing, *test);\n+   \n+            auto loop_postcond = union_postconds(num_local_vars,\n+                            vec(block_postcond(body), expr_postcond(*test)));\n+            /* conservative approximination: if the body\n+               could break or cont, the test may never be executed */\n+            if (has_nonlocal_exits(body)) {\n+                loop_postcond = empty_poststate(num_local_vars);\n+            }\n+\n+            set_pre_and_post(a, \n+               rec(precondition=seq_preconds(num_local_vars,\n+                                             vec(block_pp(body),\n+                                                 expr_pp(*test))),\n+                   postcondition=loop_postcond));\n+        }\n         case (expr_for(?d, ?index, ?body, ?a)) {\n             find_pre_post_loop(fm, enclosing, d, index, body, a);\n         }\n@@ -1104,10 +1164,15 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n         case (expr_break(?a)) {\n             set_pre_and_post(a, empty_pre_post(num_local_vars));\n         }\n-        case(_) {\n-            log_err(\"this sort of expr isn't implemented!\");\n-            log_expr_err(e);\n-            fail;\n+        case (expr_cont(?a)) {\n+            set_pre_and_post(a, empty_pre_post(num_local_vars));\n+        }\n+        case (expr_port(?a)) {\n+            set_pre_and_post(a, empty_pre_post(num_local_vars));\n+        }\n+        case (expr_ext(_, _, _, ?expanded, ?a)) {\n+            find_pre_post_expr(fm, enclosing, *expanded);\n+            set_pre_and_post(a, expr_pp(*expanded));\n         }\n     }\n }\n@@ -1181,6 +1246,22 @@ fn find_pre_post_stmt(fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n \n fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n     -> () {\n+    /* Want to say that if there is a break or cont in this\n+     block, then that invalidates the poststate upheld by\n+    any of the stmts after it. \n+    Given that the typechecker has run, we know any break will be in\n+    a block that forms a loop body. So that's ok. There'll never be an\n+    expr_break outside a loop body, therefore, no expr_break outside a block.\n+    */\n+\n+    /* Conservative approximation for now: This says that if a block contains\n+     *any* breaks or conts, then its postcondition doesn't promise anything.\n+     This will mean that:\n+     x = 0;\n+     break;\n+\n+     won't have a postcondition that says x is initialized, but that's ok.\n+     */\n     auto nv = num_locals(enclosing);\n \n     fn do_one_(fn_info_map fm, fn_info i, &@stmt s) -> () {\n@@ -1214,7 +1295,11 @@ fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */\n     _vec.push[postcond](postconds, block_precond);\n-    auto block_postcond = union_postconds(nv, postconds);\n+    auto block_postcond = empty_poststate(nv);\n+    /* conservative approximation */\n+    if (! has_nonlocal_exits(b)) {\n+        block_postcond = union_postconds(nv, postconds);\n+    }\n     set_pre_and_post(b.node.a, rec(precondition=block_precond,\n                                    postcondition=block_postcond));\n }\n@@ -1406,6 +1491,12 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                                     expr_poststate(*operator), a, operands)\n           || changed);\n     }\n+    case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n+        changed = find_pre_post_state_expr(fm, enclosing, pres, operator);\n+        ret(find_pre_post_state_exprs(fm, enclosing,\n+                 expr_poststate(*operator), a, operands)\n+          || changed);\n+    }\n     case (expr_bind(?operator, ?maybe_args, ?a)) {\n         changed = find_pre_post_state_expr(fm, enclosing, pres, operator)\n             || changed;\n@@ -1423,6 +1514,19 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = extend_poststate_ann(a, expr_poststate(*e)) || changed;\n         ret changed;\n     }\n+    case (expr_chan(?e, ?a)) {\n+        changed = find_pre_post_state_expr(fm, enclosing, pres, e);\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*e)) || changed;\n+        ret changed;\n+    }\n+    case (expr_ext(_, _, _, ?expanded, ?a)) {\n+        changed = find_pre_post_state_expr(fm, enclosing, pres, expanded);\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*expanded))\n+           || changed;\n+        ret changed;\n+    }\n     case (expr_put(?maybe_e, ?a)) {\n         alt (maybe_e) {\n             case (some[@expr](?arg)) {\n@@ -1486,6 +1590,32 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         }\n         ret changed;\n     }\n+    case (expr_recv(?lhs, ?rhs, ?a)) {\n+        extend_prestate_ann(a, pres);\n+\n+        alt (lhs.node) {\n+            case (expr_path(?p, some[def](def_local(?d_id)), ?a_lhs)) {\n+                // receive to local var\n+                changed = pure_exp(a_lhs, pres) || changed;\n+                changed = find_pre_post_state_expr(fm, enclosing, pres, rhs)\n+                    || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(*rhs))\n+                    || changed;\n+                changed = gen_poststate(enclosing, a, d_id) || changed;\n+            }\n+            case (_) {\n+                // receive to something that must already have been init'd\n+                changed = find_pre_post_state_expr(fm, enclosing, pres, lhs)\n+                    || changed;\n+                changed = find_pre_post_state_expr(fm, enclosing,\n+                     expr_poststate(*lhs), rhs) || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(*rhs))\n+                    || changed;\n+            }\n+        }\n+        ret changed;\n+    }\n+\n     case (expr_ret(?maybe_ret_val, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed;\n         set_poststate_ann(a, false_postcond(num_local_vars));\n@@ -1498,6 +1628,12 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         }\n         ret changed;\n     }\n+    case (expr_be(?e, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        set_poststate_ann(a, false_postcond(num_local_vars));\n+        changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n+        ret changed;\n+    }\n     case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed;\n         changed = find_pre_post_state_expr(fm, enclosing, pres, antec)\n@@ -1529,6 +1665,15 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = extend_poststate_ann(a, expr_poststate(*r)) || changed;\n         ret changed;\n     }\n+    case (expr_send(?l, ?r, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = find_pre_post_state_expr(fm, enclosing, pres, l)\n+                    || changed;\n+        changed = find_pre_post_state_expr(fm,\n+                    enclosing, expr_poststate(*l), r) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*r)) || changed;\n+        ret changed;\n+    }\n     case (expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n         /* quite similar to binary -- should abstract this */\n         changed = extend_prestate_ann(a, pres) || changed;\n@@ -1558,6 +1703,27 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                                         block_poststate(body)))) || changed;\n         ret changed;\n     }\n+    case (expr_do_while(?body, ?test, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = find_pre_post_state_block(fm, enclosing, pres, body)\n+            || changed;\n+        changed = find_pre_post_state_expr(fm, enclosing,\n+                     block_poststate(body), test) || changed;\n+\n+        /* conservative approximination: if the body of the loop\n+           could break or cont, we revert to the prestate\n+           (TODO: could treat cont differently from break, since\n+           if there's a cont, the test will execute) */\n+        if (has_nonlocal_exits(body)) {\n+            changed = set_poststate_ann(a, pres) || changed;\n+        }\n+        else {\n+            changed = extend_poststate_ann(a, expr_poststate(*test))\n+              || changed;\n+        }\n+\n+        ret changed;\n+    }\n     case (expr_for(?d, ?index, ?body, ?a)) {\n         ret find_pre_post_state_loop(fm, enclosing, pres, d, index, body, a);\n     }\n@@ -1634,13 +1800,16 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n     case (expr_break(?a)) {\n         ret pure_exp(a, pres);\n     }\n-    case (_) {\n-      log_err(\"find_pre_post_state_expr: implement this case!\");\n-      log_expr_err(*e);\n-      fail;\n+    case (expr_cont(?a)) {\n+        ret pure_exp(a, pres);\n+    }\n+    case (expr_port(?a)) {\n+        ret pure_exp(a, pres);\n+    }\n+    case (expr_self_method(_, ?a)) {\n+        ret pure_exp(a, pres);\n     }\n   }\n-\n }\n \n fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n@@ -1733,6 +1902,8 @@ fn find_pre_post_state_block(&fn_info_map fm, &fn_info enclosing,\n                              &prestate pres0, &block b)\n   -> bool {\n \n+    /* FIXME handle non-local exits */\n+\n   auto changed = false;\n   auto num_local_vars = num_locals(enclosing);\n \n@@ -1756,6 +1927,20 @@ fn find_pre_post_state_block(&fn_info_map fm, &fn_info enclosing,\n       post = expr_poststate(*e);\n     }\n   }\n+\n+  /*\n+  log_err(\"block:\");\n+  log_block_err(b);\n+  log_err(\"has non-local exits?\");\n+  log_err(has_nonlocal_exits(b));\n+  */\n+\n+  /* conservative approximation: if a block contains a break\n+     or cont, we assume nothing about the poststate */\n+  if (has_nonlocal_exits(b)) {\n+      post = pres0;\n+  }\n+  \n   set_prestate_ann(@b.node.a, pres0);\n   set_poststate_ann(b.node.a, post);\n \n@@ -1802,7 +1987,7 @@ fn check_states_expr(fn_info enclosing, &expr e) -> () {\n   let prestate pres   = expr_prestate(e);\n \n   if (!implies(pres, prec)) {\n-      log_err(\"check_states_expr: unsatisfied precondition for \");\n+      log_err(\"check_states_expr: Unsatisfied precondition constraint for \");\n       log_expr_err(e);\n       log_err(\"Precondition: \");\n       log_bitv_err(enclosing, prec);\n@@ -1831,7 +2016,8 @@ fn check_states_stmt(fn_info enclosing, &stmt s) -> () {\n       */\n \n       if (!implies(pres, prec)) {\n-        log_err(\"check_states_stmt: unsatisfied precondition for \");\n+        log_err(\"check_states_stmt: \"\n+              + \"Unsatisfied precondition constraint for \");\n         log_stmt_err(s);\n         log_err(\"Precondition: \");\n         log_bitv_err(enclosing, prec);"}, {"sha": "fd0d688bab8e8c60f977dba02ebf2c117f5a2aff", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0190ebfe0748f28c290eb4759a03ffbd416cbeac/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0190ebfe0748f28c290eb4759a03ffbd416cbeac/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=0190ebfe0748f28c290eb4759a03ffbd416cbeac", "patch": "@@ -1,10 +1,15 @@\n+import std.map;\n+import std.map.hashmap;\n import std._uint;\n import std._int;\n import std._vec;\n import std.option.none;\n import front.ast;\n import util.typestate_ann.ts_ann;\n \n+import middle.fold;\n+import middle.fold.respan;\n+\n import std.io.stdout;\n import std.io.str_writer;\n import std.io.string_writer;\n@@ -16,6 +21,7 @@ import pretty.pp.mkstate;\n type filename = str;\n type span = rec(uint lo, uint hi);\n type spanned[T] = rec(T node, span span);\n+type flag = hashmap[str, ()];\n \n tag ty_mach {\n     ty_i8;\n@@ -222,6 +228,32 @@ fn decl_lhs(@ast.decl d) -> ast.def_id {\n     }\n }\n \n+fn has_nonlocal_exits(&ast.block b) -> bool {\n+    /* overkill, but just passing around a mutable bool doesn't seem\n+       to work in rustboot */\n+    auto has_exits = new_str_hash[()]();\n+ \n+   fn set_break(&flag f, &span sp, ast.ann a) -> @ast.expr {\n+        f.insert(\"foo\", ());\n+        ret @respan(sp, ast.expr_break(a));\n+    }\n+    fn set_cont(&flag f, &span sp, ast.ann a) -> @ast.expr {\n+        f.insert(\"foo\", ());\n+        ret @respan(sp, ast.expr_cont(a));\n+    }\n+    fn check_b(&flag f) -> bool {\n+        ret (f.size() == 0u);\n+    }\n+\n+    auto fld0 = fold.new_identity_fold[flag]();\n+\n+    fld0 = @rec(fold_expr_break = bind set_break(_,_,_),\n+                fold_expr_cont  = bind set_cont(_,_,_),\n+                keep_going      = bind check_b(_) with *fld0);\n+    fold.fold_block[flag](has_exits, fld0, b);\n+\n+    ret (has_exits.size() > 0u);\n+}\n //\n // Local Variables:\n // mode: rust"}, {"sha": "e9085dd25e8239f187ab7a5347cd90ec048eabe4", "filename": "src/test/compile-fail/break-uninit.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0190ebfe0748f28c290eb4759a03ffbd416cbeac/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0190ebfe0748f28c290eb4759a03ffbd416cbeac/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-uninit.rs?ref=0190ebfe0748f28c290eb4759a03ffbd416cbeac", "patch": "@@ -0,0 +1,22 @@\n+// xfail-boot\n+// xfail-stage0\n+// error-pattern:Unsatisfied precondition\n+\n+fn foo() -> int {\n+  let int x;\n+  let int i;\n+\n+  do {\n+    i = 0;\n+    break;\n+    x = 0;\n+  } while ((x = 0) != 0);\n+\n+  log(x);\n+\n+  ret 17;\n+}\n+\n+fn main() {\n+  log(foo());\n+}"}, {"sha": "8ef83f08cf5ec0a0abca93a51c2964b1e5c36dec", "filename": "src/test/compile-fail/break-uninit2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0190ebfe0748f28c290eb4759a03ffbd416cbeac/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0190ebfe0748f28c290eb4759a03ffbd416cbeac/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-uninit2.rs?ref=0190ebfe0748f28c290eb4759a03ffbd416cbeac", "patch": "@@ -0,0 +1,22 @@\n+// xfail-boot\n+// xfail-stage0\n+// error-pattern:Unsatisfied precondition\n+\n+fn foo() -> int {\n+  let int x;\n+  let int i;\n+\n+  do {\n+    i = 0;\n+    break;\n+    x = 0;\n+  } while (1 != 2);\n+\n+  log(x);\n+\n+  ret 17;\n+}\n+\n+fn main() {\n+  log(foo());\n+}"}]}