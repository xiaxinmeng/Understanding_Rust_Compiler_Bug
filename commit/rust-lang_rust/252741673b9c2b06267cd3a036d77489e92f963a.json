{"sha": "252741673b9c2b06267cd3a036d77489e92f963a", "node_id": "C_kwDOAAsO6NoAKDI1Mjc0MTY3M2I5YzJiMDYyNjdjZDNhMDM2ZDc3NDg5ZTkyZjk2M2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-28T04:02:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-28T04:02:25Z"}, "message": "Auto merge of #107360 - bjorn3:fix_thin_archive_reading, r=wesleywiser\n\nFix thin archive reading\n\nThis includes a revert of https://github.com/rust-lang/rust/pull/105221 to restore fat archive reading with LlvmArchiveBuilder.\n\nShould fix #107162, #107334 and https://github.com/google/shaderc-rs/issues/133", "tree": {"sha": "e84a2f4ee63c69322b28040f06a04283c13d847b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e84a2f4ee63c69322b28040f06a04283c13d847b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/252741673b9c2b06267cd3a036d77489e92f963a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/252741673b9c2b06267cd3a036d77489e92f963a", "html_url": "https://github.com/rust-lang/rust/commit/252741673b9c2b06267cd3a036d77489e92f963a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/252741673b9c2b06267cd3a036d77489e92f963a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cd6bad51fb34a0d89e97c27814041fe4d0838b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cd6bad51fb34a0d89e97c27814041fe4d0838b5", "html_url": "https://github.com/rust-lang/rust/commit/6cd6bad51fb34a0d89e97c27814041fe4d0838b5"}, {"sha": "de363d54c40a378717881240e719f5f7223ba376", "url": "https://api.github.com/repos/rust-lang/rust/commits/de363d54c40a378717881240e719f5f7223ba376", "html_url": "https://github.com/rust-lang/rust/commit/de363d54c40a378717881240e719f5f7223ba376"}], "stats": {"total": 88, "additions": 49, "deletions": 39}, "files": [{"sha": "58ca87524deb69d891cc1dbfe8c953de5cdc4b95", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/252741673b9c2b06267cd3a036d77489e92f963a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252741673b9c2b06267cd3a036d77489e92f963a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=252741673b9c2b06267cd3a036d77489e92f963a", "patch": "@@ -15,8 +15,8 @@ use crate::errors::{\n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind, LLVMMachineType, LLVMRustCOFFShortExport};\n use rustc_codegen_ssa::back::archive::{\n-    get_native_object_symbols, ArArchiveBuilder, ArchiveBuildFailure, ArchiveBuilder,\n-    ArchiveBuilderBuilder, UnknownArchiveKind,\n+    get_native_object_symbols, try_extract_macho_fat_archive, ArArchiveBuilder,\n+    ArchiveBuildFailure, ArchiveBuilder, ArchiveBuilderBuilder, UnknownArchiveKind,\n };\n \n use rustc_session::cstore::DllImport;\n@@ -66,15 +66,21 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n         archive: &Path,\n         skip: Box<dyn FnMut(&str) -> bool + 'static>,\n     ) -> io::Result<()> {\n-        let archive_ro = match ArchiveRO::open(archive) {\n+        let mut archive = archive.to_path_buf();\n+        if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n+            if let Some(new_archive) = try_extract_macho_fat_archive(&self.sess, &archive)? {\n+                archive = new_archive\n+            }\n+        }\n+        let archive_ro = match ArchiveRO::open(&archive) {\n             Ok(ar) => ar,\n             Err(e) => return Err(io::Error::new(io::ErrorKind::Other, e)),\n         };\n         if self.additions.iter().any(|ar| ar.path() == archive) {\n             return Ok(());\n         }\n         self.additions.push(Addition::Archive {\n-            path: archive.to_path_buf(),\n+            path: archive,\n             archive: archive_ro,\n             skip: Box::new(skip),\n         });\n@@ -102,7 +108,9 @@ pub struct LlvmArchiveBuilderBuilder;\n \n impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n-        if sess.target.arch == \"wasm32\" || sess.target.arch == \"wasm64\" {\n+        // FIXME use ArArchiveBuilder on most targets again once reading thin archives is\n+        // implemented\n+        if true || sess.target.arch == \"wasm32\" || sess.target.arch == \"wasm64\" {\n             Box::new(LlvmArchiveBuilder { sess, additions: Vec::new() })\n         } else {\n             Box::new(ArArchiveBuilder::new(sess, get_llvm_object_symbols))"}, {"sha": "d3cd085cfb66854f374041ab5d5a2aeba32925bc", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 36, "deletions": 34, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/252741673b9c2b06267cd3a036d77489e92f963a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/252741673b9c2b06267cd3a036d77489e92f963a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=252741673b9c2b06267cd3a036d77489e92f963a", "patch": "@@ -14,7 +14,7 @@ use tempfile::Builder as TempFileBuilder;\n \n use std::error::Error;\n use std::fs::File;\n-use std::io;\n+use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n \n // Re-exporting for rustc_codegen_llvm::back::archive\n@@ -116,42 +116,51 @@ impl<'a> ArArchiveBuilder<'a> {\n     }\n }\n \n-fn try_filter_fat_archs<'a>(\n+fn try_filter_fat_archs(\n     archs: object::read::Result<&[impl FatArch]>,\n     target_arch: object::Architecture,\n-    archive_map_data: &'a [u8],\n-) -> io::Result<Option<(&'a [u8], u64)>> {\n+    archive_path: &Path,\n+    archive_map_data: &[u8],\n+) -> io::Result<Option<PathBuf>> {\n     let archs = archs.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n \n     let desired = match archs.iter().find(|a| a.architecture() == target_arch) {\n         Some(a) => a,\n         None => return Ok(None),\n     };\n \n-    Ok(Some((\n+    let (mut new_f, extracted_path) = tempfile::Builder::new()\n+        .suffix(archive_path.file_name().unwrap())\n+        .tempfile()?\n+        .keep()\n+        .unwrap();\n+\n+    new_f.write_all(\n         desired.data(archive_map_data).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,\n-        desired.offset().into(),\n-    )))\n+    )?;\n+\n+    Ok(Some(extracted_path))\n }\n \n-pub fn try_extract_macho_fat_archive<'a>(\n+pub fn try_extract_macho_fat_archive(\n     sess: &Session,\n-    archive_bytes: &'a [u8],\n-) -> io::Result<Option<(&'a [u8], u64)>> {\n+    archive_path: &Path,\n+) -> io::Result<Option<PathBuf>> {\n+    let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n     let target_arch = match sess.target.arch.as_ref() {\n         \"aarch64\" => object::Architecture::Aarch64,\n         \"x86_64\" => object::Architecture::X86_64,\n         _ => return Ok(None),\n     };\n \n-    match object::macho::FatHeader::parse(archive_bytes) {\n+    match object::macho::FatHeader::parse(&*archive_map) {\n         Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC => {\n-            let archs = object::macho::FatHeader::parse_arch32(archive_bytes);\n-            try_filter_fat_archs(archs, target_arch, archive_bytes)\n+            let archs = object::macho::FatHeader::parse_arch32(&*archive_map);\n+            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n         }\n         Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC_64 => {\n-            let archs = object::macho::FatHeader::parse_arch64(archive_bytes);\n-            try_filter_fat_archs(archs, target_arch, archive_bytes)\n+            let archs = object::macho::FatHeader::parse_arch64(&*archive_map);\n+            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n         }\n         // Not a FatHeader at all, just return None.\n         _ => Ok(None),\n@@ -164,24 +173,21 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         archive_path: &Path,\n         mut skip: Box<dyn FnMut(&str) -> bool + 'static>,\n     ) -> io::Result<()> {\n-        let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n+        let mut archive_path = archive_path.to_path_buf();\n+        if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n+            if let Some(new_archive_path) =\n+                try_extract_macho_fat_archive(&self.sess, &archive_path)?\n+            {\n+                archive_path = new_archive_path\n+            }\n+        }\n+\n         if self.src_archives.iter().any(|archive| archive.0 == archive_path) {\n             return Ok(());\n         }\n \n-        let (archive_bytes, offset) = if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n-            if let Some((sub_archive, archive_offset)) =\n-                try_extract_macho_fat_archive(&self.sess, &*archive_map)?\n-            {\n-                (sub_archive, Some(archive_offset))\n-            } else {\n-                (&*archive_map, None)\n-            }\n-        } else {\n-            (&*archive_map, None)\n-        };\n-\n-        let archive = ArchiveFile::parse(&*archive_bytes)\n+        let archive_map = unsafe { Mmap::map(File::open(&archive_path)?)? };\n+        let archive = ArchiveFile::parse(&*archive_map)\n             .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n         let archive_index = self.src_archives.len();\n \n@@ -190,13 +196,9 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             let file_name = String::from_utf8(entry.name().to_vec())\n                 .map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;\n             if !skip(&file_name) {\n-                let mut range = entry.file_range();\n-                if let Some(offset) = offset {\n-                    range.0 += offset;\n-                }\n                 self.entries.push((\n                     file_name.into_bytes(),\n-                    ArchiveEntry::FromArchive { archive_index, file_range: range },\n+                    ArchiveEntry::FromArchive { archive_index, file_range: entry.file_range() },\n                 ));\n             }\n         }"}]}