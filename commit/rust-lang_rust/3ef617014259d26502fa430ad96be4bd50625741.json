{"sha": "3ef617014259d26502fa430ad96be4bd50625741", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZjYxNzAxNDI1OWQyNjUwMmZhNDMwYWQ5NmJlNGJkNTA2MjU3NDE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-03-29T09:51:43Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-04-11T13:01:04Z"}, "message": "Remove CPlace::NoPlace", "tree": {"sha": "6e6a2265e777d52d16b32d0db56fe5d26cd77d2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e6a2265e777d52d16b32d0db56fe5d26cd77d2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ef617014259d26502fa430ad96be4bd50625741", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ef617014259d26502fa430ad96be4bd50625741", "html_url": "https://github.com/rust-lang/rust/commit/3ef617014259d26502fa430ad96be4bd50625741", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ef617014259d26502fa430ad96be4bd50625741/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53307fd2e1fbf184aa3af44194a0f3b1bffea9a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/53307fd2e1fbf184aa3af44194a0f3b1bffea9a5", "html_url": "https://github.com/rust-lang/rust/commit/53307fd2e1fbf184aa3af44194a0f3b1bffea9a5"}], "stats": {"total": 68, "additions": 21, "deletions": 47}, "files": [{"sha": "4405f98addff6a445a38b5501b73ff337aa7a669", "filename": "src/abi/comments.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ef617014259d26502fa430ad96be4bd50625741/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef617014259d26502fa430ad96be4bd50625741/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=3ef617014259d26502fa430ad96be4bd50625741", "patch": "@@ -76,7 +76,6 @@ pub(super) fn add_local_place_comments<'tcx>(\n             assert_eq!(local, var);\n             (\"ssa\", std::borrow::Cow::Borrowed(\"\"))\n         }\n-        CPlaceInner::NoPlace => (\"zst\", \"\".into()),\n         CPlaceInner::Addr(ptr, meta) => {\n             let meta = if let Some(meta) = meta {\n                 Cow::Owned(format!(\",meta={}\", meta))"}, {"sha": "582021cb083d4ac8c21f09c210f047d19c915a6b", "filename": "src/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef617014259d26502fa430ad96be4bd50625741/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef617014259d26502fa430ad96be4bd50625741/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=3ef617014259d26502fa430ad96be4bd50625741", "patch": "@@ -657,7 +657,7 @@ pub(crate) fn codegen_drop<'tcx>(\n         let drop_fn_ty = drop_fn.monomorphic_ty(fx.tcx);\n         match ty.kind {\n             ty::Dynamic(..) => {\n-                let (ptr, vtable) = drop_place.to_ptr_maybe_unsized(fx);\n+                let (ptr, vtable) = drop_place.to_ptr_maybe_unsized();\n                 let ptr = ptr.get_addr(fx);\n                 let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable.unwrap());\n "}, {"sha": "449c77c3c09b5b967eace80c6d865944b27872bc", "filename": "src/abi/returning.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ef617014259d26502fa430ad96be4bd50625741/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef617014259d26502fa430ad96be4bd50625741/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=3ef617014259d26502fa430ad96be4bd50625741", "patch": "@@ -70,7 +70,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx, B: Backend, T>(\n     let return_ptr = match output_pass_mode {\n         PassMode::NoPass => None,\n         PassMode::ByRef { sized: true } => match ret_place {\n-            Some(ret_place) => Some(ret_place.to_ptr(fx).get_addr(fx)),\n+            Some(ret_place) => Some(ret_place.to_ptr().get_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)),\n         },\n         PassMode::ByRef { sized: false } => todo!(),"}, {"sha": "414f6c30ce5ca3d7ee620144c218d7ed1655468c", "filename": "src/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ef617014259d26502fa430ad96be4bd50625741/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef617014259d26502fa430ad96be4bd50625741/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=3ef617014259d26502fa430ad96be4bd50625741", "patch": "@@ -730,7 +730,7 @@ fn codegen_array_len<'tcx>(\n             fx.bcx.ins().iconst(fx.pointer_type, len)\n         }\n         ty::Slice(_elem_ty) => place\n-            .to_ptr_maybe_unsized(fx)\n+            .to_ptr_maybe_unsized()\n             .1\n             .expect(\"Length metadata for slice place\"),\n         _ => bug!(\"Rvalue::Len({:?})\", place),\n@@ -776,7 +776,7 @@ pub(crate) fn trans_place<'tcx>(\n                     ty::Array(elem_ty, _len) => {\n                         assert!(!from_end, \"array subslices are never `from_end`\");\n                         let elem_layout = fx.layout_of(elem_ty);\n-                        let ptr = cplace.to_ptr(fx);\n+                        let ptr = cplace.to_ptr();\n                         cplace = CPlace::for_ptr(\n                             ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * from as i64),\n                             fx.layout_of(fx.tcx.mk_array(elem_ty, to as u64 - from as u64)),\n@@ -785,7 +785,7 @@ pub(crate) fn trans_place<'tcx>(\n                     ty::Slice(elem_ty) => {\n                         assert!(from_end, \"slice subslices should be `from_end`\");\n                         let elem_layout = fx.layout_of(elem_ty);\n-                        let (ptr, len) = cplace.to_ptr_maybe_unsized(fx);\n+                        let (ptr, len) = cplace.to_ptr_maybe_unsized();\n                         let len = len.unwrap();\n                         cplace = CPlace::for_ptr_with_extra(\n                             ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * from as i64),"}, {"sha": "51da712b55d1c47cf3aefcdb0af4720a75133830", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3ef617014259d26502fa430ad96be4bd50625741/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef617014259d26502fa430ad96be4bd50625741/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=3ef617014259d26502fa430ad96be4bd50625741", "patch": "@@ -348,7 +348,6 @@ fn place_location<'a, 'tcx>(\n             // For PointerBase::Stack:\n             //AttributeValue::Exprloc(Expression(translate_loc(ValueLoc::Stack(*stack_slot), &context.func.stack_slots).unwrap()))\n         }\n-        CPlaceInner::NoPlace => AttributeValue::Exprloc(Expression(vec![])),\n     }\n }\n "}, {"sha": "619b7199b538dca99e2836198d9aecdaea186586", "filename": "src/value_and_place.rs", "status": "modified", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3ef617014259d26502fa430ad96be4bd50625741/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ef617014259d26502fa430ad96be4bd50625741/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=3ef617014259d26502fa430ad96be4bd50625741", "patch": "@@ -100,7 +100,7 @@ impl<'tcx> CValue<'tcx> {\n             CValueInner::ByVal(_) | CValueInner::ByValPair(_, _) => {\n                 let cplace = CPlace::new_stack_slot(fx, layout);\n                 cplace.write_cvalue(fx, self);\n-                (cplace.to_ptr(fx), None)\n+                (cplace.to_ptr(), None)\n             }\n         }\n     }\n@@ -259,7 +259,6 @@ pub(crate) struct CPlace<'tcx> {\n pub(crate) enum CPlaceInner {\n     Var(Local),\n     Addr(Pointer, Option<Value>),\n-    NoPlace,\n }\n \n impl<'tcx> CPlace<'tcx> {\n@@ -273,7 +272,7 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn no_place(layout: TyAndLayout<'tcx>) -> CPlace<'tcx> {\n         CPlace {\n-            inner: CPlaceInner::NoPlace,\n+            inner: CPlaceInner::Addr(Pointer::dangling(layout.align.pref), None),\n             layout,\n         }\n     }\n@@ -284,10 +283,7 @@ impl<'tcx> CPlace<'tcx> {\n     ) -> CPlace<'tcx> {\n         assert!(!layout.is_unsized());\n         if layout.size.bytes() == 0 {\n-            return CPlace {\n-                inner: CPlaceInner::NoPlace,\n-                layout,\n-            };\n+            return CPlace::no_place(layout);\n         }\n \n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n@@ -343,33 +339,20 @@ impl<'tcx> CPlace<'tcx> {\n                     CValue::by_ref(ptr, layout)\n                 }\n             }\n-            CPlaceInner::NoPlace => CValue::by_ref(\n-                Pointer::dangling(self.layout.align.pref),\n-                layout,\n-            ),\n         }\n     }\n \n-    pub(crate) fn to_ptr(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>) -> Pointer {\n-        match self.to_ptr_maybe_unsized(fx) {\n+    pub(crate) fn to_ptr(self) -> Pointer {\n+        match self.to_ptr_maybe_unsized() {\n             (ptr, None) => ptr,\n             (_, Some(_)) => bug!(\"Expected sized cplace, found {:?}\", self),\n         }\n     }\n \n-    pub(crate) fn to_ptr_maybe_unsized(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    ) -> (Pointer, Option<Value>) {\n+    pub(crate) fn to_ptr_maybe_unsized(self) -> (Pointer, Option<Value>) {\n         match self.inner {\n             CPlaceInner::Addr(ptr, extra) => (ptr, extra),\n-            CPlaceInner::NoPlace => {\n-                (\n-                    Pointer::const_addr(fx, i64::try_from(self.layout.align.pref.bytes()).unwrap()),\n-                    None,\n-                )\n-            }\n-            CPlaceInner::Var(_) => bug!(\"Expected CPlace::Addr, found CPlace::Var\"),\n+            CPlaceInner::Var(_) => bug!(\"Expected CPlace::Addr, found {:?}\", self),\n         }\n     }\n \n@@ -460,12 +443,11 @@ impl<'tcx> CPlace<'tcx> {\n                 fx.bcx.def_var(mir_var(var), data);\n                 return;\n             }\n-            CPlaceInner::Addr(ptr, None) => ptr,\n-            CPlaceInner::NoPlace => {\n-                if dst_layout.abi != Abi::Uninhabited {\n-                    assert_eq!(dst_layout.size.bytes(), 0, \"{:?}\", dst_layout);\n+            CPlaceInner::Addr(ptr, None) => {\n+                if dst_layout.size == Size::ZERO || dst_layout.abi == Abi::Uninhabited {\n+                    return;\n                 }\n-                return;\n+                ptr\n             }\n             CPlaceInner::Addr(_, Some(_)) => bug!(\"Can't write value to unsized place {:?}\", self),\n         };\n@@ -524,7 +506,7 @@ impl<'tcx> CPlace<'tcx> {\n         field: mir::Field,\n     ) -> CPlace<'tcx> {\n         let layout = self.layout();\n-        let (base, extra) = self.to_ptr_maybe_unsized(fx);\n+        let (base, extra) = self.to_ptr_maybe_unsized();\n \n         let (field_ptr, field_layout) = codegen_field(fx, base, extra, layout, field);\n         if field_layout.is_unsized() {\n@@ -540,8 +522,8 @@ impl<'tcx> CPlace<'tcx> {\n         index: Value,\n     ) -> CPlace<'tcx> {\n         let (elem_layout, ptr) = match self.layout().ty.kind {\n-            ty::Array(elem_ty, _) => (fx.layout_of(elem_ty), self.to_ptr(fx)),\n-            ty::Slice(elem_ty) => (fx.layout_of(elem_ty), self.to_ptr_maybe_unsized(fx).0),\n+            ty::Array(elem_ty, _) => (fx.layout_of(elem_ty), self.to_ptr()),\n+            ty::Slice(elem_ty) => (fx.layout_of(elem_ty), self.to_ptr_maybe_unsized().0),\n             _ => bug!(\"place_index({:?})\", self.layout().ty),\n         };\n \n@@ -565,27 +547,21 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn write_place_ref(self, fx: &mut FunctionCx<'_, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n         if has_ptr_meta(fx.tcx, self.layout().ty) {\n-            let (ptr, extra) = self.to_ptr_maybe_unsized(fx);\n+            let (ptr, extra) = self.to_ptr_maybe_unsized();\n             let ptr = CValue::by_val_pair(\n                 ptr.get_addr(fx),\n                 extra.expect(\"unsized type without metadata\"),\n                 dest.layout(),\n             );\n             dest.write_cvalue(fx, ptr);\n         } else {\n-            let ptr = CValue::by_val(self.to_ptr(fx).get_addr(fx), dest.layout());\n+            let ptr = CValue::by_val(self.to_ptr().get_addr(fx), dest.layout());\n             dest.write_cvalue(fx, ptr);\n         }\n     }\n \n     pub(crate) fn unchecked_cast_to(self, layout: TyAndLayout<'tcx>) -> Self {\n         assert!(!self.layout().is_unsized());\n-        match self.inner {\n-            CPlaceInner::NoPlace => {\n-                assert!(layout.size.bytes() == 0);\n-            }\n-            _ => {}\n-        }\n         CPlace {\n             inner: self.inner,\n             layout,"}]}