{"sha": "6680d03d14c60e7e7d4b7e0347b8829151855854", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ODBkMDNkMTRjNjBlN2U3ZDRiN2UwMzQ3Yjg4MjkxNTE4NTU4NTQ=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-05-31T23:53:27Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-10T21:48:56Z"}, "message": "Use BitMatrix for storage conflicts", "tree": {"sha": "fe2e70b0155bc16fa2804a101821b23053a3824a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe2e70b0155bc16fa2804a101821b23053a3824a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6680d03d14c60e7e7d4b7e0347b8829151855854", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6680d03d14c60e7e7d4b7e0347b8829151855854", "html_url": "https://github.com/rust-lang/rust/commit/6680d03d14c60e7e7d4b7e0347b8829151855854", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6680d03d14c60e7e7d4b7e0347b8829151855854/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66e7493543bfef2bdd12454155670cc810de8ea9", "url": "https://api.github.com/repos/rust-lang/rust/commits/66e7493543bfef2bdd12454155670cc810de8ea9", "html_url": "https://github.com/rust-lang/rust/commit/66e7493543bfef2bdd12454155670cc810de8ea9"}], "stats": {"total": 61, "additions": 32, "deletions": 29}, "files": [{"sha": "3e9f7b51cb1c53315b72cd9de2db4be7d27dc62e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6680d03d14c60e7e7d4b7e0347b8829151855854/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6680d03d14c60e7e7d4b7e0347b8829151855854/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=6680d03d14c60e7e7d4b7e0347b8829151855854", "patch": "@@ -9,7 +9,7 @@ use crate::hir::def_id::DefId;\n use crate::hir::{self, InlineAsm as HirInlineAsm};\n use crate::mir::interpret::{ConstValue, InterpError, Scalar};\n use crate::mir::visit::MirVisitable;\n-use rustc_data_structures::bit_set::BitSet;\n+use rustc_data_structures::bit_set::BitMatrix;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n@@ -3008,7 +3008,7 @@ pub struct GeneratorLayout<'tcx> {\n     /// Which saved locals are storage-live at the same time. Locals that do not\n     /// have conflicts with each other are allowed to overlap in the computed\n     /// layout.\n-    pub storage_conflicts: IndexVec<GeneratorSavedLocal, BitSet<GeneratorSavedLocal>>,\n+    pub storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n \n     /// Names and scopes of all the stored generator locals.\n     /// NOTE(tmandry) This is *strictly* a temporary hack for codegen\n@@ -3586,7 +3586,7 @@ impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n     }\n }\n \n-impl<'tcx, T: Idx> TypeFoldable<'tcx> for BitSet<T> {\n+impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> Self {\n         self.clone()\n     }"}, {"sha": "279784ef701b17231f43920cc0f70c53b308ad49", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6680d03d14c60e7e7d4b7e0347b8829151855854/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6680d03d14c60e7e7d4b7e0347b8829151855854/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=6680d03d14c60e7e7d4b7e0347b8829151855854", "patch": "@@ -678,12 +678,13 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n                 // Next, check every pair of eligible locals to see if they\n                 // conflict.\n-                for (local_a, conflicts_a) in info.storage_conflicts.iter_enumerated() {\n+                for local_a in info.storage_conflicts.rows() {\n+                    let conflicts_a = info.storage_conflicts.count(local_a);\n                     if ineligible_locals.contains(local_a) {\n                         continue;\n                     }\n \n-                    for local_b in conflicts_a.iter() {\n+                    for local_b in info.storage_conflicts.iter(local_a) {\n                         // local_a and local_b are storage live at the same time, therefore they\n                         // cannot overlap in the generator layout. The only way to guarantee\n                         // this is if they are in the same variant, or one is ineligible\n@@ -697,8 +698,8 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         // If they conflict, we will choose one to make ineligible.\n                         // This is not always optimal; it's just a greedy heuristic\n                         // that seems to produce good results most of the time.\n-                        let conflicts_b = &info.storage_conflicts[local_b];\n-                        let (remove, other) = if conflicts_a.count() > conflicts_b.count() {\n+                        let conflicts_b = info.storage_conflicts.count(local_b);\n+                        let (remove, other) = if conflicts_a > conflicts_b {\n                             (local_a, local_b)\n                         } else {\n                             (local_b, local_a)"}, {"sha": "e9adb976c28922a48ec10aab624ece57acb4c629", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/6680d03d14c60e7e7d4b7e0347b8829151855854/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6680d03d14c60e7e7d4b7e0347b8829151855854/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=6680d03d14c60e7e7d4b7e0347b8829151855854", "patch": "@@ -59,7 +59,7 @@ use rustc::ty::layout::VariantIdx;\n use rustc::ty::subst::SubstsRef;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::bit_set::BitSet;\n+use rustc_data_structures::bit_set::{BitSet, BitMatrix};\n use std::borrow::Cow;\n use std::iter;\n use std::mem;\n@@ -408,7 +408,7 @@ struct LivenessInfo {\n     /// For every saved local, the set of other saved locals that are\n     /// storage-live at the same time as this local. We cannot overlap locals in\n     /// the layout which have conflicting storage.\n-    storage_conflicts: IndexVec<GeneratorSavedLocal, BitSet<GeneratorSavedLocal>>,\n+    storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n \n     /// For every suspending block, the locals which are storage-live across\n     /// that suspension point.\n@@ -551,7 +551,9 @@ fn compute_storage_conflicts(\n     ignored: &StorageIgnored,\n     storage_live: DataflowResults<'tcx, MaybeStorageLive<'mir, 'tcx>>,\n     storage_live_analysis: MaybeStorageLive<'mir, 'tcx>,\n-) -> IndexVec<GeneratorSavedLocal, BitSet<GeneratorSavedLocal>> {\n+) -> BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal> {\n+    assert_eq!(body.local_decls.len(), ignored.0.domain_size());\n+    assert_eq!(body.local_decls.len(), stored_locals.domain_size());\n     debug!(\"compute_storage_conflicts({:?})\", body.span);\n     debug!(\"ignored = {:?}\", ignored.0);\n \n@@ -564,18 +566,15 @@ fn compute_storage_conflicts(\n     // liveness. Those that do must be in the same variant to remain candidates.\n     // FIXME(tmandry): Consider using sparse bitsets here once we have good\n     // benchmarks for generators.\n-    let mut local_conflicts: IndexVec<Local, _> =\n-        // Add conflicts for every ineligible local.\n-        iter::repeat(ineligible_locals.clone())\n-        .take(body.local_decls.len())\n-        .collect();\n+    let mut local_conflicts: BitMatrix<Local, Local> =\n+        BitMatrix::from_row_n(&ineligible_locals, body.local_decls.len());\n \n     for_each_location(body, &storage_live_analysis, &storage_live, |state, loc| {\n         let mut eligible_storage_live = state.clone().to_dense();\n         eligible_storage_live.intersect(&stored_locals);\n \n         for local in eligible_storage_live.iter() {\n-            local_conflicts[local].union(&eligible_storage_live);\n+            local_conflicts.union_row_with(&eligible_storage_live, local);\n         }\n \n         if eligible_storage_live.count() > 1 {\n@@ -588,19 +587,22 @@ fn compute_storage_conflicts(\n     // However, in practice these bitsets are not usually large. The layout code\n     // also needs to keep track of how many conflicts each local has, so it's\n     // simpler to keep it this way for now.\n-    let storage_conflicts: IndexVec<GeneratorSavedLocal, _> = stored_locals\n-        .iter()\n-        .map(|local_a| {\n-            if ineligible_locals.contains(local_a) {\n-                // Conflicts with everything.\n-                BitSet::new_filled(stored_locals.count())\n-            } else {\n-                // Keep overlap information only for stored locals.\n-                renumber_bitset(&local_conflicts[local_a], stored_locals)\n+    let mut storage_conflicts = BitMatrix::new(stored_locals.count(), stored_locals.count());\n+    for (idx_a, local_a) in stored_locals.iter().enumerate() {\n+        let saved_local_a = GeneratorSavedLocal::new(idx_a);\n+        if ineligible_locals.contains(local_a) {\n+            // Conflicts with everything.\n+            storage_conflicts.insert_all_into_row(saved_local_a);\n+        } else {\n+            // Keep overlap information only for stored locals.\n+            for (idx_b, local_b) in stored_locals.iter().enumerate() {\n+                let saved_local_b = GeneratorSavedLocal::new(idx_b);\n+                if local_conflicts.contains(local_a, local_b) {\n+                    storage_conflicts.insert(saved_local_a, saved_local_b);\n+                }\n             }\n-        })\n-        .collect();\n-\n+        }\n+    }\n     storage_conflicts\n }\n \n@@ -700,7 +702,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         variant_fields.push(fields);\n     }\n     debug!(\"generator variant_fields = {:?}\", variant_fields);\n-    debug!(\"generator storage_conflicts = {:?}\", storage_conflicts);\n+    debug!(\"generator storage_conflicts = {:#?}\", storage_conflicts);\n \n     let layout = GeneratorLayout {\n         field_tys: tys,"}]}