{"sha": "df8debf6d9afc431adbbd8311dcaf2b70eb9762e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmOGRlYmY2ZDlhZmM0MzFhZGJiZDgzMTFkY2FmMmI3MGViOTc2MmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-25T23:08:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-25T23:08:56Z"}, "message": "Auto merge of #38920 - petrochenkov:selfimpl, r=eddyb\n\nPartially implement RFC 1647 (`Self` in impl headers)\n\nThe name resolution part is easy, but the typeck part contains an unexpected problem.\n\nIt turns out that `Self` type *depends* on bounds and `where` clauses, so we need to convert them first to determine what the `Self` type is! If bounds/`where` clauses can refer to `Self` then we have a cyclic dependency.\nThis is required to support impls like this:\n```\n// Found in libcollections\nimpl<I: IntoIterator> SpecExtend<I> for LinkedList<I::Item> { .... }\n                                                      ^^^^^ associated type `Item` is found using information from bounds\n\n```\nI'm not yet sure how to resolve this issue.\nOne possible solution (that feels hacky) is to make two passes over generics - first collect predicates ignoring everything involving `Self`, then determine `Self`, then collect predicates again without ignoring anything. (Some kind of lazy on-demand checking or something looks like a proper solution.)\n\nThis patch in its current state doesn't solve the problem with `Self` in bounds, so the only observable things it does is improving error messages and supporting `impl Trait<Self> for Type {}`.\n\nThere's also a question about feature gating. It's non-trivial to *detect* \"newly resolved\" `Self`s to feature gate them, but it's simple to *enable* the new resolution behavior when the feature gate is already specified. Alternatively this can be considered a bug fix and merged without a feature gate.\n\ncc https://github.com/rust-lang/rust/issues/38864\nr? @nikomatsakis\ncc @eddyb\nWhitespace ignoring diff https://github.com/rust-lang/rust/pull/38920/files?w=1", "tree": {"sha": "0b20a4a0d61487b9321ed2e8e21bfd0f61a8ecd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b20a4a0d61487b9321ed2e8e21bfd0f61a8ecd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df8debf6d9afc431adbbd8311dcaf2b70eb9762e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df8debf6d9afc431adbbd8311dcaf2b70eb9762e", "html_url": "https://github.com/rust-lang/rust/commit/df8debf6d9afc431adbbd8311dcaf2b70eb9762e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df8debf6d9afc431adbbd8311dcaf2b70eb9762e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94d4589388f3c82b4042276d8fd78f8d8009b531", "url": "https://api.github.com/repos/rust-lang/rust/commits/94d4589388f3c82b4042276d8fd78f8d8009b531", "html_url": "https://github.com/rust-lang/rust/commit/94d4589388f3c82b4042276d8fd78f8d8009b531"}, {"sha": "f9bdf34b5aebb52488fa03c0351254dce820342a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9bdf34b5aebb52488fa03c0351254dce820342a", "html_url": "https://github.com/rust-lang/rust/commit/f9bdf34b5aebb52488fa03c0351254dce820342a"}], "stats": {"total": 189, "additions": 122, "deletions": 67}, "files": [{"sha": "b5e2715ab4f0b141d51d5776a365450a6c9432d8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 61, "deletions": 53, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/df8debf6d9afc431adbbd8311dcaf2b70eb9762e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df8debf6d9afc431adbbd8311dcaf2b70eb9762e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=df8debf6d9afc431adbbd8311dcaf2b70eb9762e", "patch": "@@ -1548,7 +1548,10 @@ impl<'a> Resolver<'a> {\n             }\n \n             ItemKind::DefaultImpl(_, ref trait_ref) => {\n-                self.with_optional_trait_ref(Some(trait_ref), |_, _| {});\n+                self.with_optional_trait_ref(Some(trait_ref), |this, _| {\n+                    // Resolve type arguments in trait path\n+                    visit::walk_trait_ref(this, trait_ref);\n+                });\n             }\n             ItemKind::Impl(.., ref generics, ref opt_trait_ref, ref self_type, ref impl_items) =>\n                 self.resolve_implementation(generics,\n@@ -1712,7 +1715,6 @@ impl<'a> Resolver<'a> {\n                 new_val = Some((def.def_id(), trait_ref.clone()));\n                 new_id = Some(def.def_id());\n             }\n-            visit::walk_trait_ref(self, trait_ref);\n         }\n         let original_trait_ref = replace(&mut self.current_trait_ref, new_val);\n         let result = f(self, new_id);\n@@ -1740,60 +1742,66 @@ impl<'a> Resolver<'a> {\n                               impl_items: &[ImplItem]) {\n         // If applicable, create a rib for the type parameters.\n         self.with_type_parameter_rib(HasTypeParameters(generics, ItemRibKind), |this| {\n-            // Resolve the type parameters.\n-            this.visit_generics(generics);\n-\n-            // Resolve the trait reference, if necessary.\n-            this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n-                // Resolve the self type.\n-                this.visit_ty(self_type);\n-\n-                let item_def_id = this.definitions.local_def_id(item_id);\n-                this.with_self_rib(Def::SelfTy(trait_id, Some(item_def_id)), |this| {\n-                    this.with_current_self_type(self_type, |this| {\n-                        for impl_item in impl_items {\n-                            this.check_proc_macro_attrs(&impl_item.attrs);\n-                            this.resolve_visibility(&impl_item.vis);\n-                            match impl_item.node {\n-                                ImplItemKind::Const(..) => {\n-                                    // If this is a trait impl, ensure the const\n-                                    // exists in trait\n-                                    this.check_trait_item(impl_item.ident.name,\n-                                                          ValueNS,\n-                                                          impl_item.span,\n-                                        |n, s| ResolutionError::ConstNotMemberOfTrait(n, s));\n-                                    visit::walk_impl_item(this, impl_item);\n-                                }\n-                                ImplItemKind::Method(ref sig, _) => {\n-                                    // If this is a trait impl, ensure the method\n-                                    // exists in trait\n-                                    this.check_trait_item(impl_item.ident.name,\n-                                                          ValueNS,\n-                                                          impl_item.span,\n-                                        |n, s| ResolutionError::MethodNotMemberOfTrait(n, s));\n-\n-                                    // We also need a new scope for the method-\n-                                    // specific type parameters.\n-                                    let type_parameters =\n-                                        HasTypeParameters(&sig.generics,\n-                                                          MethodRibKind(!sig.decl.has_self()));\n-                                    this.with_type_parameter_rib(type_parameters, |this| {\n+            // Dummy self type for better errors if `Self` is used in the trait path.\n+            this.with_self_rib(Def::SelfTy(None, None), |this| {\n+                // Resolve the trait reference, if necessary.\n+                this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n+                    let item_def_id = this.definitions.local_def_id(item_id);\n+                    this.with_self_rib(Def::SelfTy(trait_id, Some(item_def_id)), |this| {\n+                        if let Some(trait_ref) = opt_trait_reference.as_ref() {\n+                            // Resolve type arguments in trait path\n+                            visit::walk_trait_ref(this, trait_ref);\n+                        }\n+                        // Resolve the self type.\n+                        this.visit_ty(self_type);\n+                        // Resolve the type parameters.\n+                        this.visit_generics(generics);\n+                        this.with_current_self_type(self_type, |this| {\n+                            for impl_item in impl_items {\n+                                this.check_proc_macro_attrs(&impl_item.attrs);\n+                                this.resolve_visibility(&impl_item.vis);\n+                                match impl_item.node {\n+                                    ImplItemKind::Const(..) => {\n+                                        // If this is a trait impl, ensure the const\n+                                        // exists in trait\n+                                        this.check_trait_item(impl_item.ident.name,\n+                                                            ValueNS,\n+                                                            impl_item.span,\n+                                            |n, s| ResolutionError::ConstNotMemberOfTrait(n, s));\n                                         visit::walk_impl_item(this, impl_item);\n-                                    });\n-                                }\n-                                ImplItemKind::Type(ref ty) => {\n-                                    // If this is a trait impl, ensure the type\n-                                    // exists in trait\n-                                    this.check_trait_item(impl_item.ident.name,\n-                                                          TypeNS,\n-                                                          impl_item.span,\n-                                        |n, s| ResolutionError::TypeNotMemberOfTrait(n, s));\n-\n-                                    this.visit_ty(ty);\n+                                    }\n+                                    ImplItemKind::Method(ref sig, _) => {\n+                                        // If this is a trait impl, ensure the method\n+                                        // exists in trait\n+                                        this.check_trait_item(impl_item.ident.name,\n+                                                            ValueNS,\n+                                                            impl_item.span,\n+                                            |n, s| ResolutionError::MethodNotMemberOfTrait(n, s));\n+\n+                                        // We also need a new scope for the method-\n+                                        // specific type parameters.\n+                                        let type_parameters =\n+                                            HasTypeParameters(&sig.generics,\n+                                                            MethodRibKind(!sig.decl.has_self()));\n+                                        this.with_type_parameter_rib(type_parameters, |this| {\n+                                            visit::walk_impl_item(this, impl_item);\n+                                        });\n+                                    }\n+                                    ImplItemKind::Type(ref ty) => {\n+                                        // If this is a trait impl, ensure the type\n+                                        // exists in trait\n+                                        this.check_trait_item(impl_item.ident.name,\n+                                                            TypeNS,\n+                                                            impl_item.span,\n+                                            |n, s| ResolutionError::TypeNotMemberOfTrait(n, s));\n+\n+                                        this.visit_ty(ty);\n+                                    }\n+                                    ImplItemKind::Macro(_) =>\n+                                        panic!(\"unexpanded macro in resolve!\"),\n                                 }\n-                                ImplItemKind::Macro(_) => panic!(\"unexpanded macro in resolve!\"),\n                             }\n-                        }\n+                        });\n                     });\n                 });\n             });"}, {"sha": "838dbef8ecf1b3d13e09db328f5b41a3999b68a1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/df8debf6d9afc431adbbd8311dcaf2b70eb9762e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df8debf6d9afc431adbbd8311dcaf2b70eb9762e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=df8debf6d9afc431adbbd8311dcaf2b70eb9762e", "patch": "@@ -1401,11 +1401,23 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n                 assert_eq!(opt_self_ty, None);\n                 tcx.prohibit_type_params(&path.segments);\n-                let ty = tcx.item_type(def_id);\n-                if let Some(free_substs) = self.get_free_substs() {\n-                    ty.subst(tcx, free_substs)\n+\n+                // FIXME: Self type is not always computed when we are here because type parameter\n+                // bounds may affect Self type and have to be converted before it.\n+                let ty = if def_id.is_local() {\n+                    tcx.item_types.borrow().get(&def_id).cloned()\n                 } else {\n-                    ty\n+                    Some(tcx.item_type(def_id))\n+                };\n+                if let Some(ty) = ty {\n+                    if let Some(free_substs) = self.get_free_substs() {\n+                        ty.subst(tcx, free_substs)\n+                    } else {\n+                        ty\n+                    }\n+                } else {\n+                    tcx.sess.span_err(span, \"`Self` type is used before it's determined\");\n+                    tcx.types.err\n                 }\n             }\n             Def::SelfTy(Some(_), None) => {"}, {"sha": "adc208a0202a2861e7792d2a33f8e7669ea38390", "filename": "src/test/compile-fail/resolve-self-in-impl-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/df8debf6d9afc431adbbd8311dcaf2b70eb9762e/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df8debf6d9afc431adbbd8311dcaf2b70eb9762e/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl-2.rs?ref=df8debf6d9afc431adbbd8311dcaf2b70eb9762e", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S<T = u8>(T);\n+trait Tr<T = u8> {}\n+\n+impl Self for S {} //~ ERROR expected trait, found self type `Self`\n+impl Self::N for S {} //~ ERROR cannot find trait `N` in `Self`\n+\n+fn main() {}"}, {"sha": "82037b6c9ed02646ac201915a642eedd2b1f4732", "filename": "src/test/compile-fail/resolve-self-in-impl.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/df8debf6d9afc431adbbd8311dcaf2b70eb9762e/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df8debf6d9afc431adbbd8311dcaf2b70eb9762e/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs?ref=df8debf6d9afc431adbbd8311dcaf2b70eb9762e", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S<T = u8>(T);\n+trait Tr<T = u8> {}\n+\n+impl Tr<Self> for S {} // OK\n+\n+// FIXME: `Self` cannot be used in bounds because it depends on bounds itself.\n+impl<T: Tr<Self>> Tr<T> for S {} //~ ERROR `Self` type is used before it's determined\n+impl<T = Self> Tr<T> for S {} //~ ERROR `Self` type is used before it's determined\n+impl Tr for S where Self: Copy {} //~ ERROR `Self` type is used before it's determined\n+impl Tr for S where S<Self>: Copy {} //~ ERROR `Self` type is used before it's determined\n+impl Tr for Self {} //~ ERROR `Self` type is used before it's determined\n+impl Tr for S<Self> {} //~ ERROR `Self` type is used before it's determined\n+impl Self {} //~ ERROR `Self` type is used before it's determined\n+impl S<Self> {} //~ ERROR `Self` type is used before it's determined\n+\n+fn main() {}"}, {"sha": "881f04300ed036f67ed5dd1c74c8b14375dca2da", "filename": "src/test/ui/resolve/issue-23305.stderr", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/df8debf6d9afc431adbbd8311dcaf2b70eb9762e/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df8debf6d9afc431adbbd8311dcaf2b70eb9762e/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr?ref=df8debf6d9afc431adbbd8311dcaf2b70eb9762e", "patch": "@@ -1,16 +1,8 @@\n-error[E0411]: cannot find type `Self` in this scope\n+error: `Self` type is used before it's determined\n   --> $DIR/issue-23305.rs:15:12\n    |\n 15 | impl ToNbt<Self> {}\n-   |            ^^^^ `Self` is only available in traits and impls\n-\n-error[E0038]: the trait `ToNbt` cannot be made into an object\n-  --> $DIR/issue-23305.rs:15:6\n-   |\n-15 | impl ToNbt<Self> {}\n-   |      ^^^^^^^^^^^ the trait `ToNbt` cannot be made into an object\n-   |\n-   = note: method `new` has no receiver\n+   |            ^^^^\n \n error: aborting due to previous error\n "}]}