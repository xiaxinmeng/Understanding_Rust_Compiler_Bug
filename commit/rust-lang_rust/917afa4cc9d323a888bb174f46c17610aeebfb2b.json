{"sha": "917afa4cc9d323a888bb174f46c17610aeebfb2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxN2FmYTRjYzlkMzIzYTg4OGJiMTc0ZjQ2YzE3NjEwYWVlYmZiMmI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-15T00:26:10Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-15T18:38:46Z"}, "message": "rustc: Remove a bunch of exterior vectors", "tree": {"sha": "7bda3042c02f37404b0ddb5efc6c6da7866a3f1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bda3042c02f37404b0ddb5efc6c6da7866a3f1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/917afa4cc9d323a888bb174f46c17610aeebfb2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/917afa4cc9d323a888bb174f46c17610aeebfb2b", "html_url": "https://github.com/rust-lang/rust/commit/917afa4cc9d323a888bb174f46c17610aeebfb2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/917afa4cc9d323a888bb174f46c17610aeebfb2b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a716eb28ecc8fcd16c9d2595e989601efaab3b1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a716eb28ecc8fcd16c9d2595e989601efaab3b1a", "html_url": "https://github.com/rust-lang/rust/commit/a716eb28ecc8fcd16c9d2595e989601efaab3b1a"}], "stats": {"total": 633, "additions": 302, "deletions": 331}, "files": [{"sha": "aa0f71ff8e2931dd8894b6f52456da831145c35c", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -7,7 +7,7 @@ import middle::ty;\n import metadata::encoder;\n import std::str;\n import std::fs;\n-import std::vec;\n+import std::ivec;\n import std::option;\n import option::some;\n import option::none;\n@@ -360,10 +360,14 @@ fn build_link_meta(&session::session sess, &ast::crate c,\n             case (some(?v)) { v }\n             case (none) {\n                 auto name = {\n-                    auto os = str::split(fs::basename(output), '.' as u8);\n-                    assert (vec::len(os) >= 2u);\n-                    vec::pop(os);\n-                    str::connect(os, \".\")\n+                    auto os_vec = str::split(fs::basename(output), '.' as u8);\n+                    // FIXME: Remove this vec->ivec conversion.\n+                    auto os = ~[];\n+                    for (str s in os_vec) { os += ~[s]; }\n+\n+                    assert (ivec::len(os) >= 2u);\n+                    ivec::pop(os);\n+                    str::connect_ivec(os, \".\")\n                 };\n                 warn_missing(sess, \"name\", name);\n                 name"}, {"sha": "400ed3beab8aa00b84588a59cc8948b36aa6a55c", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -64,7 +64,7 @@ fn declare_upcalls(type_names tn, TypeRef tydesc_type, TypeRef taskptr_type,\n                    ModuleRef llmod)\n    -> @upcalls {\n     fn decl(type_names tn, TypeRef tydesc_type, TypeRef taskptr_type,\n-            ModuleRef llmod, str name, vec[TypeRef] tys,\n+            ModuleRef llmod, str name, TypeRef[] tys,\n             TypeRef rv) -> ValueRef {\n         let TypeRef[] arg_tys = ~[taskptr_type];\n         for (TypeRef t in tys) { arg_tys += ~[t]; }\n@@ -76,62 +76,62 @@ fn declare_upcalls(type_names tn, TypeRef tydesc_type, TypeRef taskptr_type,\n     // FIXME: Sigh:.. remove this when I fix the typechecker pushdown.\n     // --pcwalton\n \n-    let vec[TypeRef] empty_vec = [];\n-    ret @rec(grow_task=dv(\"grow_task\", [T_size_t()]),\n-             log_int=dv(\"log_int\", [T_i32(), T_i32()]),\n-             log_float=dv(\"log_float\", [T_i32(), T_f32()]),\n-             log_double=dv(\"log_double\", [T_i32(), T_ptr(T_f64())]),\n-             log_str=dv(\"log_str\", [T_i32(), T_ptr(T_str())]),\n-             trace_word=dv(\"trace_word\", [T_int()]),\n-             trace_str=dv(\"trace_str\", [T_ptr(T_i8())]),\n-             new_port=d(\"new_port\", [T_size_t()], T_opaque_port_ptr()),\n-             del_port=dv(\"del_port\", [T_opaque_port_ptr()]),\n-             new_chan=d(\"new_chan\", [T_opaque_port_ptr()],\n+    let TypeRef[] empty_vec = ~[];\n+    ret @rec(grow_task=dv(\"grow_task\", ~[T_size_t()]),\n+             log_int=dv(\"log_int\", ~[T_i32(), T_i32()]),\n+             log_float=dv(\"log_float\", ~[T_i32(), T_f32()]),\n+             log_double=dv(\"log_double\", ~[T_i32(), T_ptr(T_f64())]),\n+             log_str=dv(\"log_str\", ~[T_i32(), T_ptr(T_str())]),\n+             trace_word=dv(\"trace_word\", ~[T_int()]),\n+             trace_str=dv(\"trace_str\", ~[T_ptr(T_i8())]),\n+             new_port=d(\"new_port\", ~[T_size_t()], T_opaque_port_ptr()),\n+             del_port=dv(\"del_port\", ~[T_opaque_port_ptr()]),\n+             new_chan=d(\"new_chan\", ~[T_opaque_port_ptr()],\n                         T_opaque_chan_ptr()),\n-             flush_chan=dv(\"flush_chan\", [T_opaque_chan_ptr()]),\n-             del_chan=dv(\"del_chan\", [T_opaque_chan_ptr()]),\n-             clone_chan=d(\"clone_chan\", [taskptr_type, T_opaque_chan_ptr()],\n+             flush_chan=dv(\"flush_chan\", ~[T_opaque_chan_ptr()]),\n+             del_chan=dv(\"del_chan\", ~[T_opaque_chan_ptr()]),\n+             clone_chan=d(\"clone_chan\", ~[taskptr_type, T_opaque_chan_ptr()],\n                           T_opaque_chan_ptr()),\n              _yield=dv(\"yield\", empty_vec),\n-             sleep=dv(\"sleep\", [T_size_t()]),\n-             send=dv(\"send\", [T_opaque_chan_ptr(), T_ptr(T_i8())]),\n-             recv=dv(\"recv\", [T_ptr(T_ptr(T_i8())), T_opaque_port_ptr()]),\n-             _fail=dv(\"fail\", [T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n-             kill=dv(\"kill\", [taskptr_type]),\n+             sleep=dv(\"sleep\", ~[T_size_t()]),\n+             send=dv(\"send\", ~[T_opaque_chan_ptr(), T_ptr(T_i8())]),\n+             recv=dv(\"recv\", ~[T_ptr(T_ptr(T_i8())), T_opaque_port_ptr()]),\n+             _fail=dv(\"fail\", ~[T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n+             kill=dv(\"kill\", ~[taskptr_type]),\n              exit=dv(\"exit\", empty_vec),\n-             malloc=d(\"malloc\", [T_size_t(), T_ptr(tydesc_type)],\n+             malloc=d(\"malloc\", ~[T_size_t(), T_ptr(tydesc_type)],\n                       T_ptr(T_i8())),\n-             free=dv(\"free\", [T_ptr(T_i8()), T_int()]),\n+             free=dv(\"free\", ~[T_ptr(T_i8()), T_int()]),\n              shared_malloc=d(\"shared_malloc\",\n-                      [T_size_t(), T_ptr(tydesc_type)], T_ptr(T_i8())),\n-             shared_free=dv(\"shared_free\", [T_ptr(T_i8())]),\n-             mark=d(\"mark\", [T_ptr(T_i8())], T_int()),\n-             new_str=d(\"new_str\", [T_ptr(T_i8()), T_size_t()],\n+                      ~[T_size_t(), T_ptr(tydesc_type)], T_ptr(T_i8())),\n+             shared_free=dv(\"shared_free\", ~[T_ptr(T_i8())]),\n+             mark=d(\"mark\", ~[T_ptr(T_i8())], T_int()),\n+             new_str=d(\"new_str\", ~[T_ptr(T_i8()), T_size_t()],\n                        T_ptr(T_str())),\n-                     dup_str=d(\"dup_str\", [taskptr_type, T_ptr(T_str())],\n+                     dup_str=d(\"dup_str\", ~[taskptr_type, T_ptr(T_str())],\n                        T_ptr(T_str())),\n-             new_vec=d(\"new_vec\", [T_size_t(), T_ptr(tydesc_type)],\n+             new_vec=d(\"new_vec\", ~[T_size_t(), T_ptr(tydesc_type)],\n                        T_opaque_vec_ptr()),\n              vec_append=d(\"vec_append\",\n-                          [T_ptr(tydesc_type), T_ptr(tydesc_type),\n-                           T_ptr(T_opaque_vec_ptr()), T_opaque_vec_ptr(),\n-                           T_bool()], T_void()),\n+                          ~[T_ptr(tydesc_type), T_ptr(tydesc_type),\n+                            T_ptr(T_opaque_vec_ptr()), T_opaque_vec_ptr(),\n+                            T_bool()], T_void()),\n              get_type_desc=d(\"get_type_desc\",\n-                             [T_ptr(T_nil()), T_size_t(), T_size_t(),\n-                              T_size_t(), T_ptr(T_ptr(tydesc_type))],\n+                             ~[T_ptr(T_nil()), T_size_t(), T_size_t(),\n+                               T_size_t(), T_ptr(T_ptr(tydesc_type))],\n                              T_ptr(tydesc_type)),\n-             new_task=d(\"new_task\", [T_ptr(T_str())], taskptr_type),\n+             new_task=d(\"new_task\", ~[T_ptr(T_str())], taskptr_type),\n              start_task=d(\"start_task\",\n-                          [taskptr_type, T_int(), T_int(), T_size_t()],\n-                          taskptr_type),\n-             ivec_resize=d(\"ivec_resize\", [T_ptr(T_opaque_ivec()), T_int()],\n+                          ~[taskptr_type, T_int(), T_int(), T_size_t()],\n+                            taskptr_type),\n+             ivec_resize=d(\"ivec_resize\", ~[T_ptr(T_opaque_ivec()), T_int()],\n                            T_void()),\n-             ivec_spill=d(\"ivec_spill\", [T_ptr(T_opaque_ivec()), T_int()],\n+             ivec_spill=d(\"ivec_spill\", ~[T_ptr(T_opaque_ivec()), T_int()],\n                           T_void()),\n              ivec_resize_shared=d(\"ivec_resize_shared\",\n-                           [T_ptr(T_opaque_ivec()), T_int()], T_void()),\n+                           ~[T_ptr(T_opaque_ivec()), T_int()], T_void()),\n              ivec_spill_shared=d(\"ivec_spill_shared\",\n-                          [T_ptr(T_opaque_ivec()), T_int()], T_void()));\n+                          ~[T_ptr(T_opaque_ivec()), T_int()], T_void()));\n }\n //\n // Local Variables:"}, {"sha": "83e775c847dec56fdcc23f4f272053acc2460db2", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -301,8 +301,12 @@ fn build_session_options(str binary, getopts::match match, str binary_dir) ->\n    @session::options {\n     auto library = opt_present(match, \"lib\");\n     auto static = opt_present(match, \"static\");\n-    auto library_search_paths = [binary_dir + \"/lib\"];\n-    library_search_paths += getopts::opt_strs(match, \"L\");\n+\n+    auto library_search_paths = ~[binary_dir + \"/lib\"];\n+    // FIXME: Remove this vec->ivec conversion.\n+    auto lsp_vec = getopts::opt_strs(match, \"L\");\n+    for (str lsp in lsp_vec) { library_search_paths += ~[lsp]; }\n+\n     auto output_type =\n         if (opt_present(match, \"parse-only\")) {\n             link::output_type_none\n@@ -398,7 +402,7 @@ fn opts() -> vec[getopts::opt] {\n }\n \n fn main(vec[str] args) {\n-    auto binary = vec::shift[str](args);\n+    auto binary = vec::shift(args);\n     auto binary_dir = fs::dirname(binary);\n     auto match =\n         alt (getopts::getopts(args, opts())) {\n@@ -554,7 +558,10 @@ fn main(vec[str] args) {\n         gcc_args += [\"-l\" + libarg];\n     }\n \n-    gcc_args += cstore::get_used_link_args(cstore);\n+    // FIXME: Remove this ivec->vec conversion.\n+    auto ula = cstore::get_used_link_args(cstore);\n+    for (str arg in ula) { gcc_args += [arg]; }\n+\n     auto used_libs = cstore::get_used_libraries(cstore);\n     for (str l in used_libs) {\n         gcc_args += [\"-l\" + l];"}, {"sha": "f07fbc6f859149a276a34073b9fe9894eab1a35a", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -10,7 +10,6 @@ import std::option;\n import std::option::some;\n import std::option::none;\n import std::str;\n-import std::vec;\n import syntax::parse::parser::parse_sess;\n \n tag os { os_win32; os_macos; os_linux; }\n@@ -36,14 +35,14 @@ type options =\n         bool time_passes,\n         bool time_llvm_passes,\n         back::link::output_type output_type,\n-        vec[str] library_search_paths,\n+        str[] library_search_paths,\n         str sysroot,\n         // The crate config requested for the session, which may be combined\n         // with additional crate configurations during the compile process\n         ast::crate_cfg cfg,\n         bool test);\n \n-type crate_metadata = rec(str name, vec[u8] data);\n+type crate_metadata = rec(str name, u8[] data);\n \n obj session(@config targ_cfg,\n             @options opts,"}, {"sha": "33b160c5c1fa38472126bf9de1b919d9bf325530", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -14,7 +14,6 @@ import back::x86;\n import util::common;\n import std::ivec;\n import std::str;\n-import std::vec;\n import std::fs;\n import std::ioivec;\n import std::option;\n@@ -47,7 +46,7 @@ fn read_crates(session::session sess,\n type env =\n     @rec(session::session sess,\n          @hashmap[str, int] crate_cache,\n-         vec[str] library_search_paths,\n+         str[] library_search_paths,\n          mutable ast::crate_num next_crate_num);\n \n fn visit_view_item(env e, &@ast::view_item i) {\n@@ -128,7 +127,7 @@ fn default_native_lib_naming(session::session sess, bool static) ->\n \n fn find_library_crate(&session::session sess, &ast::ident ident,\n                       &(@ast::meta_item)[] metas,\n-                      &vec[str] library_search_paths)\n+                      &str[] library_search_paths)\n         -> option::t[tup(str, @u8[])] {\n \n     attr::require_unique_names(sess, metas);\n@@ -162,7 +161,7 @@ fn find_library_crate(&session::session sess, &ast::ident ident,\n \n fn find_library_crate_aux(&rec(str prefix, str suffix) nn, str crate_name,\n                           &(@ast::meta_item)[] metas,\n-                          &vec[str] library_search_paths) ->\n+                          &str[] library_search_paths) ->\n                           option::t[tup(str, @u8[])] {\n     let str prefix = nn.prefix + crate_name;\n     // FIXME: we could probably use a 'glob' function in std::fs but it will\n@@ -220,7 +219,7 @@ fn get_metadata_section(str filename) -> option::t[@u8[]] {\n \n fn load_library_crate(&session::session sess, span span,\n                       &ast::ident ident, &(@ast::meta_item)[] metas,\n-                      &vec[str] library_search_paths) -> tup(str, @u8[]) {\n+                      &str[] library_search_paths) -> tup(str, @u8[]) {\n \n     alt (find_library_crate(sess, ident, metas, library_search_paths)) {\n         case (some(?t)) {"}, {"sha": "f2f24b9b71f3435063695aa65d8c12f197607ebb", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -26,7 +26,7 @@ fn get_type_param_count(&cstore::cstore cstore, &ast::def_id def) -> uint {\n }\n \n fn lookup_defs(&cstore::cstore cstore, ast::crate_num cnum,\n-               vec[ast::ident] path) -> vec[ast::def] {\n+               &ast::ident[] path) -> ast::def[] {\n     auto cdata = cstore::get_crate_data(cstore, cnum).data;\n     ret decoder::lookup_defs(cdata, cnum, path);\n }"}, {"sha": "7f150c088b1a51ddafb03996f1152c90d3e4c19c", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -1,8 +1,8 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n+import std::ivec;\n import std::map;\n-import std::vec;\n import std::str;\n import syntax::ast;\n \n@@ -42,9 +42,9 @@ tag cstore {\n \n type cstore_private = @rec(map::hashmap[ast::crate_num, crate_metadata] metas,\n                            use_crate_map use_crate_map,\n-                           mutable vec[str] used_crate_files,\n-                           mutable vec[str] used_libraries,\n-                           mutable vec[str] used_link_args);\n+                           mutable str[] used_crate_files,\n+                           mutable str[] used_libraries,\n+                           mutable str[] used_link_args);\n \n // Map from node_id's of local use statements to crate numbers\n type use_crate_map = map::hashmap[ast::node_id, ast::crate_num];\n@@ -61,9 +61,9 @@ fn mk_cstore() -> cstore {\n     auto crate_map = map::new_int_hash[ast::crate_num]();\n     ret private(@rec(metas = meta_cache,\n                      use_crate_map = crate_map,\n-                     mutable used_crate_files = [],\n-                     mutable used_libraries = [],\n-                     mutable used_link_args = []));\n+                     mutable used_crate_files = ~[],\n+                     mutable used_libraries = ~[],\n+                     mutable used_link_args = ~[]));\n }\n \n fn get_crate_data(&cstore cstore, ast::crate_num cnum) -> crate_metadata {\n@@ -86,35 +86,39 @@ iter iter_crate_data(&cstore cstore) -> @tup(ast::crate_num, crate_metadata) {\n }\n \n fn add_used_crate_file(&cstore cstore, &str lib) {\n-    if (!vec::member(lib, p(cstore).used_crate_files)) {\n-        p(cstore).used_crate_files += [lib];\n+    if (!ivec::member(lib, p(cstore).used_crate_files)) {\n+        p(cstore).used_crate_files += ~[lib];\n     }\n }\n \n-fn get_used_crate_files(&cstore cstore) -> vec[str] {\n+fn get_used_crate_files(&cstore cstore) -> str[] {\n     ret p(cstore).used_crate_files;\n }\n \n fn add_used_library(&cstore cstore, &str lib) -> bool {\n     if (lib == \"\") { ret false; }\n \n-    if (vec::member(lib, p(cstore).used_libraries)) {\n+    if (ivec::member(lib, p(cstore).used_libraries)) {\n         ret false;\n     }\n \n-    p(cstore).used_libraries += [lib];\n+    p(cstore).used_libraries += ~[lib];\n     ret true;\n }\n \n-fn get_used_libraries(&cstore cstore) -> vec[str] {\n+fn get_used_libraries(&cstore cstore) -> str[] {\n     ret p(cstore).used_libraries;\n }\n \n fn add_used_link_args(&cstore cstore, &str args) {\n-    p(cstore).used_link_args += str::split(args, ' ' as u8);\n+    auto used_link_args_vec = str::split(args, ' ' as u8);\n+    // TODO: Remove this vec->ivec conversion.\n+    for (str ula in used_link_args_vec) {\n+        p(cstore).used_link_args += ~[ula];\n+    }\n }\n \n-fn get_used_link_args(&cstore cstore) -> vec[str] {\n+fn get_used_link_args(&cstore cstore) -> str[] {\n     ret p(cstore).used_link_args;\n }\n "}, {"sha": "14c69503175675c1e49f13bf9af9b1f05e9e2b31", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -3,7 +3,6 @@\n import std::ebmlivec;\n import std::ivec;\n import std::option;\n-import std::vec;\n import std::str;\n import std::ioivec;\n import std::map::hashmap;\n@@ -125,38 +124,38 @@ fn item_ty_param_count(&ebmlivec::doc item) -> uint {\n }\n \n fn tag_variant_ids(&ebmlivec::doc item,\n-                   ast::crate_num this_cnum) -> vec[ast::def_id] {\n-    let vec[ast::def_id] ids = [];\n+                   ast::crate_num this_cnum) -> ast::def_id[] {\n+    let ast::def_id[] ids = ~[];\n     auto v = tag_items_data_item_variant;\n     for each (ebmlivec::doc p in ebmlivec::tagged_docs(item, v)) {\n         auto ext = parse_def_id(ebmlivec::doc_data(p));\n-        vec::push[ast::def_id](ids, tup(this_cnum, ext._1));\n+        ids += ~[tup(this_cnum, ext._1)];\n     }\n     ret ids;\n }\n \n // Given a path and serialized crate metadata, returns the ID of the\n // definition the path refers to.\n-fn resolve_path(vec[ast::ident] path, @u8[] data) -> vec[ast::def_id] {\n+fn resolve_path(&ast::ident[] path, @u8[] data) -> ast::def_id[] {\n     fn eq_item(&u8[] data, str s) -> bool {\n         ret str::eq(str::unsafe_from_bytes_ivec(data), s);\n     }\n-    auto s = str::connect(path, \"::\");\n+    auto s = str::connect_ivec(path, \"::\");\n     auto md = ebmlivec::new_doc(data);\n     auto paths = ebmlivec::get_doc(md, tag_paths);\n     auto eqer = bind eq_item(_, s);\n-    let vec[ast::def_id] result = [];\n+    let ast::def_id[] result = ~[];\n     for (ebmlivec::doc doc in lookup_hash(paths, eqer, hash_path(s))) {\n         auto did_doc = ebmlivec::get_doc(doc, tag_def_id);\n-        vec::push(result, parse_def_id(ebmlivec::doc_data(did_doc)));\n+        result += ~[parse_def_id(ebmlivec::doc_data(did_doc))];\n     }\n     ret result;\n }\n \n // Crate metadata queries\n-fn lookup_defs(&@u8[] data, ast::crate_num cnum,\n-               vec[ast::ident] path) -> vec[ast::def] {\n-    ret vec::map(bind lookup_def(cnum, data, _), resolve_path(path, data));\n+fn lookup_defs(&@u8[] data, ast::crate_num cnum, &ast::ident[] path)\n+        -> ast::def[] {\n+    ret ivec::map(bind lookup_def(cnum, data, _), resolve_path(path, data));\n }\n \n \n@@ -352,16 +351,16 @@ fn get_crate_attributes(@u8[] data) -> ast::attribute[] {\n \n type crate_dep = tup(ast::crate_num, str);\n \n-fn get_crate_deps(@u8[] data) -> vec[crate_dep] {\n-    let vec[crate_dep] deps = [];\n+fn get_crate_deps(@u8[] data) -> crate_dep[] {\n+    let crate_dep[] deps = ~[];\n     auto cratedoc = ebmlivec::new_doc(data);\n     auto depsdoc = ebmlivec::get_doc(cratedoc, tag_crate_deps);\n     auto crate_num = 1;\n     for each (ebmlivec::doc depdoc in\n               ebmlivec::tagged_docs(depsdoc, tag_crate_dep)) {\n         auto depname =\n             str::unsafe_from_bytes_ivec(ebmlivec::doc_data(depdoc));\n-        deps += [tup(crate_num, depname)];\n+        deps += ~[tup(crate_num, depname)];\n         crate_num += 1;\n     }\n     ret deps;"}, {"sha": "b4d96d17a3e963d15e019e8731278cf057c75af6", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -2,7 +2,6 @@\n \n import std::ivec;\n import std::str;\n-import std::vec;\n import std::uint;\n import std::option;\n import std::option::none;"}, {"sha": "5581640251db04068d84561e4e3d0f61653900de", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 93, "deletions": 90, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -7,7 +7,7 @@ import ast::def_id;\n import syntax::codemap::span;\n import syntax::visit;\n import visit::vt;\n-import std::vec;\n+import std::ivec;\n import std::str;\n import std::option;\n import std::option::some;\n@@ -25,14 +25,14 @@ import std::option::is_none;\n tag valid { valid; overwritten(span, ast::path); val_taken(span, ast::path); }\n \n type restrict =\n-    @rec(vec[node_id] root_vars,\n+    @rec(node_id[] root_vars,\n          node_id block_defnum,\n-         vec[node_id] bindings,\n-         vec[ty::t] tys,\n-         vec[uint] depends_on,\n+         node_id[] bindings,\n+         ty::t[] tys,\n+         uint[] depends_on,\n          mutable valid ok);\n \n-type scope = vec[restrict];\n+type scope = @restrict[];\n \n tag local_info { arg(ast::mode); objfield(ast::mutability); }\n \n@@ -50,7 +50,7 @@ fn check_crate(@ty::ctxt tcx, &@ast::crate crate) {\n              visit_expr=bind visit_expr(cx, _, _, _),\n              visit_decl=bind visit_decl(cx, _, _, _)\n              with *visit::default_visitor[scope]());\n-    visit::visit_crate(*crate, [], visit::mk_vt(v));\n+    visit::visit_crate(*crate, @~[], visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n }\n \n@@ -60,7 +60,7 @@ fn visit_fn(&@ctx cx, &ast::_fn f, &ast::ty_param[] tp, &span sp,\n     for (ast::arg arg_ in f.decl.inputs) {\n         cx.local_map.insert(arg_.id, arg(arg_.mode));\n     }\n-    v.visit_block(f.body, [], v);\n+    v.visit_block(f.body, @~[], v);\n }\n \n fn visit_item(&@ctx cx, &@ast::item i, &scope sc, &vt[scope] v) {\n@@ -148,48 +148,45 @@ fn visit_decl(&@ctx cx, &@ast::decl d, &scope sc, &vt[scope] v) {\n }\n \n fn check_call(&ctx cx, &@ast::expr f, &(@ast::expr)[] args, &scope sc) ->\n-   rec(vec[node_id] root_vars, vec[ty::t] unsafe_ts) {\n+   rec(node_id[] root_vars, ty::t[] unsafe_ts) {\n     auto fty = ty::expr_ty(*cx.tcx, f);\n     auto arg_ts = fty_args(cx, fty);\n-    let vec[node_id] roots = [];\n-    let vec[tup(uint, node_id)] mut_roots = [];\n-    let vec[ty::t] unsafe_ts = [];\n-    let vec[uint] unsafe_t_offsets = [];\n+    let node_id[] roots = ~[];\n+    let tup(uint, node_id)[] mut_roots = ~[];\n+    let ty::t[] unsafe_ts = ~[];\n+    let uint[] unsafe_t_offsets = ~[];\n     auto i = 0u;\n     for (ty::arg arg_t in arg_ts) {\n         if (arg_t.mode != ty::mo_val) {\n             auto arg = args.(i);\n             auto root = expr_root(cx, arg, false);\n             if (arg_t.mode == ty::mo_alias(true)) {\n                 alt (path_def_id(cx, arg)) {\n-                    case (some(?did)) {\n-                        vec::push(mut_roots, tup(i, did._1));\n-                    }\n-                    case (_) {\n-                        if (!mut_field(root.ds)) {\n-                            auto m =\n-                                \"passing a temporary value or \\\n+                  some(?did) { mut_roots += ~[tup(i, did._1)]; }\n+                  _ {\n+                    if (!mut_field(root.ds)) {\n+                        auto m = \"passing a temporary value or \\\n                                  immutable field by mutable alias\";\n-                            cx.tcx.sess.span_err(arg.span, m);\n-                        }\n+                        cx.tcx.sess.span_err(arg.span, m);\n                     }\n+                  }\n                 }\n             }\n             alt (path_def_id(cx, root.ex)) {\n-                case (some(?did)) { vec::push(roots, did._1); }\n-                case (_) { }\n+              some(?did) { roots += ~[did._1]; }\n+              _ { }\n             }\n             alt (inner_mut(root.ds)) {\n-                case (some(?t)) {\n-                    vec::push(unsafe_ts, t);\n-                    vec::push(unsafe_t_offsets, i);\n-                }\n-                case (_) { }\n+              some(?t) {\n+                unsafe_ts += ~[t];\n+                unsafe_t_offsets += ~[i];\n+              }\n+              _ { }\n             }\n         }\n         i += 1u;\n     }\n-    if (vec::len(unsafe_ts) > 0u) {\n+    if (ivec::len(unsafe_ts) > 0u) {\n         alt (f.node) {\n             case (ast::expr_path(_)) {\n                 if (def_is_local(cx.tcx.def_map.get(f.id), true)) {\n@@ -223,12 +220,18 @@ fn check_call(&ctx cx, &@ast::expr f, &(@ast::expr)[] args, &scope sc) ->\n     // Ensure we're not passing a root by mutable alias.\n \n     for (tup(uint, node_id) root in mut_roots) {\n-        auto mut_alias_to_root = vec::count(root._1, roots) > 1u;\n-        for (restrict r in sc) {\n-            if (vec::member(root._1, r.root_vars)) {\n-                mut_alias_to_root = true;\n+        auto mut_alias_to_root = false;\n+        auto mut_alias_to_root_count = 0u;\n+        for (node_id r in roots) {\n+            if root._1 == r {\n+                mut_alias_to_root_count += 1u;\n+                if mut_alias_to_root_count > 1u {\n+                    mut_alias_to_root = true;\n+                    break;\n+                }\n             }\n         }\n+\n         if (mut_alias_to_root) {\n             cx.tcx.sess.span_err(args.(root._0).span,\n                                  \"passing a mutable alias to a \\\n@@ -281,31 +284,31 @@ fn check_alt(&ctx cx, &@ast::expr input, &ast::arm[] arms, &scope sc,\n     visit::visit_expr(input, sc, v);\n     auto root = expr_root(cx, input, true);\n     auto roots = alt (path_def_id(cx, root.ex)) {\n-        some(?did) { [did._1] }\n-        _ { [] }\n+      some(?did) { ~[did._1] }\n+      _ { ~[] }\n     };\n-    let vec[ty::t] forbidden_tp =\n-        alt (inner_mut(root.ds)) { some(?t) { [t] } _ { [] } };\n+    let ty::t[] forbidden_tp =\n+        alt (inner_mut(root.ds)) { some(?t) { ~[t] } _ { ~[] } };\n     for (ast::arm a in arms) {\n         auto dnums = arm_defnums(a);\n         auto new_sc = sc;\n-        if (vec::len(dnums) > 0u) {\n-            new_sc = sc + [@rec(root_vars=roots,\n-                                block_defnum=dnums.(0),\n-                                bindings=dnums,\n-                                tys=forbidden_tp,\n-                                depends_on=deps(sc, roots),\n-                                mutable ok=valid)];\n+        if (ivec::len(dnums) > 0u) {\n+            new_sc = @(*sc + ~[@rec(root_vars=roots,\n+                                    block_defnum=dnums.(0),\n+                                    bindings=dnums,\n+                                    tys=forbidden_tp,\n+                                    depends_on=deps(sc, roots),\n+                                    mutable ok=valid)]);\n         }\n         visit::visit_arm(a, new_sc, v);\n     }\n }\n \n-fn arm_defnums(&ast::arm arm) -> vec[node_id] {\n-    auto dnums = [];\n-    fn walk_pat(&mutable vec[node_id] found, &@ast::pat p) {\n+fn arm_defnums(&ast::arm arm) -> node_id[] {\n+    auto dnums = ~[];\n+    fn walk_pat(&mutable node_id[] found, &@ast::pat p) {\n         alt (p.node) {\n-            case (ast::pat_bind(_)) { vec::push(found, p.id); }\n+            case (ast::pat_bind(_)) { found += ~[p.id]; }\n             case (ast::pat_tag(_, ?children)) {\n                 for (@ast::pat child in children) { walk_pat(found, child); }\n             }\n@@ -330,11 +333,11 @@ fn check_for_each(&ctx cx, &@ast::local local, &@ast::expr call,\n             auto new_sc =\n                 @rec(root_vars=data.root_vars,\n                      block_defnum=defnum,\n-                     bindings=[defnum],\n+                     bindings=~[defnum],\n                      tys=data.unsafe_ts,\n                      depends_on=deps(sc, data.root_vars),\n                      mutable ok=valid);\n-            visit::visit_block(block, sc + [new_sc], v);\n+            visit::visit_block(block, @(*sc + ~[new_sc]), v);\n         }\n     }\n }\n@@ -345,16 +348,16 @@ fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq, &ast::block block,\n     auto defnum = local.node.id;\n     auto root = expr_root(cx, seq, false);\n     auto root_def = alt (path_def_id(cx, root.ex)) {\n-        some(?did) { [did._1] }\n-        _ { [] }\n+      some(?did) { ~[did._1] }\n+      _ { ~[] }\n     };\n-    auto unsafe = alt (inner_mut(root.ds)) { some(?t) { [t] } _ { [] } };\n+    auto unsafe = alt (inner_mut(root.ds)) { some(?t) { ~[t] } _ { ~[] } };\n \n     // If this is a mutable vector, don't allow it to be touched.\n     auto seq_t = ty::expr_ty(*cx.tcx, seq);\n     alt (ty::struct(*cx.tcx, seq_t)) {\n         ty::ty_vec(?mt) | ty::ty_ivec(?mt) {\n-            if (mt.mut != ast::imm) { unsafe = [seq_t]; }\n+            if (mt.mut != ast::imm) { unsafe = ~[seq_t]; }\n         }\n         ty::ty_str | ty::ty_istr { /* no-op */ }\n         _ {\n@@ -365,11 +368,11 @@ fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq, &ast::block block,\n     auto new_sc =\n         @rec(root_vars=root_def,\n              block_defnum=defnum,\n-             bindings=[defnum],\n+             bindings=~[defnum],\n              tys=unsafe,\n              depends_on=deps(sc, root_def),\n              mutable ok=valid);\n-    visit::visit_block(block, sc + [new_sc], v);\n+    visit::visit_block(block, @(*sc + ~[new_sc]), v);\n }\n \n fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::node_id id,\n@@ -378,15 +381,15 @@ fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::node_id id,\n     if (!def_is_local(def, true)) { ret; }\n     auto my_defnum = ast::def_id_of_def(def)._1;\n     auto var_t = ty::expr_ty(*cx.tcx, ex);\n-    for (restrict r in sc) {\n+    for (restrict r in *sc) {\n         // excludes variables introduced since the alias was made\n         if (my_defnum < r.block_defnum) {\n             for (ty::t t in r.tys) {\n                 if (ty_can_unsafely_include(cx, t, var_t, assign)) {\n                     r.ok = val_taken(ex.span, p);\n                 }\n             }\n-        } else if (vec::member(my_defnum, r.bindings)) {\n+        } else if (ivec::member(my_defnum, r.bindings)) {\n             test_scope(cx, sc, r, p);\n         }\n     }\n@@ -403,15 +406,15 @@ fn check_lval(&@ctx cx, &@ast::expr dest, &scope sc, &vt[scope] v) {\n                 cx.tcx.sess.span_err(dest.span,\n                                      \"assigning to immutable obj field\");\n             }\n-            for (restrict r in sc) {\n-                if (vec::member(dnum, r.root_vars)) {\n+            for (restrict r in *sc) {\n+                if (ivec::member(dnum, r.root_vars)) {\n                     r.ok = overwritten(dest.span, p);\n                 }\n             }\n         }\n         case (_) {\n             auto root = expr_root(*cx, dest, false);\n-            if (vec::len(root.ds) == 0u) {\n+            if (ivec::len(*root.ds) == 0u) {\n                 cx.tcx.sess.span_err(dest.span, \"assignment to non-lvalue\");\n             } else if (!root.ds.(0).mut) {\n                 auto name =\n@@ -443,7 +446,7 @@ fn check_move_rhs(&@ctx cx, &@ast::expr src, &scope sc, &vt[scope] v) {\n         case (_) {\n             auto root = expr_root(*cx, src, false);\n             // Not a path and no-derefs means this is a temporary.\n-            if (vec::len(root.ds) != 0u) {\n+            if (ivec::len(*root.ds) != 0u) {\n                 cx.tcx.sess.span_err\n                     (src.span, \"moving out of a data structure\");\n             }\n@@ -463,8 +466,8 @@ fn is_immutable_alias(&@ctx cx, &scope sc, node_id dnum) -> bool {\n         case (some(arg(ast::alias(false)))) { ret true; }\n         case (_) { }\n     }\n-    for (restrict r in sc) {\n-        if (vec::member(dnum, r.bindings)) { ret true; }\n+    for (restrict r in *sc) {\n+        if (ivec::member(dnum, r.bindings)) { ret true; }\n     }\n     ret false;\n }\n@@ -495,12 +498,12 @@ fn test_scope(&ctx cx, &scope sc, &restrict r, &ast::path p) {\n     }\n }\n \n-fn deps(&scope sc, vec[node_id] roots) -> vec[uint] {\n+fn deps(&scope sc, &node_id[] roots) -> uint[] {\n     auto i = 0u;\n-    auto result = [];\n-    for (restrict r in sc) {\n+    auto result = ~[];\n+    for (restrict r in *sc) {\n         for (node_id dn in roots) {\n-            if (vec::member(dn, r.bindings)) { vec::push(result, i); }\n+            if ivec::member(dn, r.bindings) { result += ~[i]; }\n         }\n         i += 1u;\n     }\n@@ -509,31 +512,31 @@ fn deps(&scope sc, vec[node_id] roots) -> vec[uint] {\n \n tag deref_t { unbox; field; index; }\n \n-type deref = rec(bool mut, deref_t kind, ty::t outer_t);\n+type deref = @rec(bool mut, deref_t kind, ty::t outer_t);\n \n \n // Finds the root (the thing that is dereferenced) for the given expr, and a\n // vec of dereferences that were used on this root. Note that, in this vec,\n // the inner derefs come in front, so foo.bar.baz becomes rec(ex=foo,\n // ds=[field(baz),field(bar)])\n fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n-   rec(@ast::expr ex, vec[deref] ds) {\n+   rec(@ast::expr ex, @deref[] ds) {\n     fn maybe_auto_unbox(&ctx cx, &ty::t t) ->\n        rec(ty::t t, option::t[deref] d) {\n         alt (ty::struct(*cx.tcx, t)) {\n             case (ty::ty_box(?mt)) {\n                 ret rec(t=mt.ty,\n-                        d=some(rec(mut=mt.mut != ast::imm,\n-                                   kind=unbox,\n-                                   outer_t=t)));\n+                        d=some(@rec(mut=mt.mut != ast::imm,\n+                                    kind=unbox,\n+                                    outer_t=t)));\n             }\n             case (_) { ret rec(t=t, d=none); }\n         }\n     }\n-    fn maybe_push_auto_unbox(&option::t[deref] d, &mutable vec[deref] ds) {\n-        alt (d) { case (some(?d)) { vec::push(ds, d); } case (none) { } }\n+    fn maybe_push_auto_unbox(&option::t[deref] d, &mutable deref[] ds) {\n+        alt (d) { case (some(?d)) { ds += ~[d]; } case (none) { } }\n     }\n-    let vec[deref] ds = [];\n+    let deref[] ds = ~[];\n     while (true) {\n         alt ({ ex.node }) {\n             case (ast::expr_field(?base, ?ident)) {\n@@ -555,7 +558,7 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n                     }\n                     case (ty::ty_obj(_)) { }\n                 }\n-                vec::push(ds, rec(mut=mut, kind=field, outer_t=auto_unbox.t));\n+                ds += ~[@rec(mut=mut, kind=field, outer_t=auto_unbox.t)];\n                 maybe_push_auto_unbox(auto_unbox.d, ds);\n                 ex = base;\n             }\n@@ -564,14 +567,14 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n                     maybe_auto_unbox(cx, ty::expr_ty(*cx.tcx, base));\n                 alt (ty::struct(*cx.tcx, auto_unbox.t)) {\n                     case (ty::ty_vec(?mt)) {\n-                        vec::push(ds, rec(mut=mt.mut != ast::imm,\n-                                          kind=index,\n-                                          outer_t=auto_unbox.t));\n+                        ds += ~[@rec(mut=mt.mut != ast::imm,\n+                                    kind=index,\n+                                    outer_t=auto_unbox.t)];\n                     }\n                     case (ty::ty_ivec(?mt)) {\n-                        vec::push(ds, rec(mut=mt.mut != ast::imm,\n-                                          kind=index,\n-                                          outer_t=auto_unbox.t));\n+                        ds += ~[@rec(mut=mt.mut != ast::imm,\n+                                    kind=index,\n+                                    outer_t=auto_unbox.t)];\n                     }\n                 }\n                 maybe_push_auto_unbox(auto_unbox.d, ds);\n@@ -587,7 +590,7 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n                         case (ty::ty_tag(_, _)) {}\n                         case (ty::ty_ptr(?mt)) { mut = mt.mut != ast::imm; }\n                     }\n-                    vec::push(ds, rec(mut=mut, kind=unbox, outer_t=base_t));\n+                    ds += ~[@rec(mut=mut, kind=unbox, outer_t=base_t)];\n                     ex = base;\n                 } else { break; }\n             }\n@@ -598,16 +601,16 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n         auto auto_unbox = maybe_auto_unbox(cx, ty::expr_ty(*cx.tcx, ex));\n         maybe_push_auto_unbox(auto_unbox.d, ds);\n     }\n-    ret rec(ex=ex, ds=ds);\n+    ret rec(ex=ex, ds=@ds);\n }\n \n-fn mut_field(&vec[deref] ds) -> bool {\n-    for (deref d in ds) { if (d.mut) { ret true; } }\n+fn mut_field(&@deref[] ds) -> bool {\n+    for (deref d in *ds) { if (d.mut) { ret true; } }\n     ret false;\n }\n \n-fn inner_mut(&vec[deref] ds) -> option::t[ty::t] {\n-    for (deref d in ds) { if (d.mut) { ret some(d.outer_t); } }\n+fn inner_mut(&@deref[] ds) -> option::t[ty::t] {\n+    for (deref d in *ds) { if (d.mut) { ret some(d.outer_t); } }\n     ret none;\n }\n "}, {"sha": "a0fbc6a7061f818921db72bcbbf989bcc28adb43", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -1168,11 +1168,7 @@ fn ns_for_def(def d) -> namespace {\n \n fn lookup_external(&env e, int cnum, &ident[] ids, namespace ns) ->\n    option::t[def] {\n-    // FIXME: Remove this ivec->vec conversion.\n-    auto ids_vec = [];\n-    for (ident i in ids) { ids_vec += [i]; }\n-\n-    for (def d in csearch::lookup_defs(e.sess.get_cstore(), cnum, ids_vec)) {\n+    for (def d in csearch::lookup_defs(e.sess.get_cstore(), cnum, ids)) {\n         e.ext_map.insert(ast::def_id_of_def(d), ids);\n         if (ns == ns_for_def(d)) { ret some(d); }\n     }"}, {"sha": "2ef71234fddf1e39c2d571303e611753f8a6e5d2", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -1364,7 +1364,7 @@ fn check_pat(&@fn_ctxt fcx, &ast::pat_id_map map, &@ast::pat pat,\n                         fcx.ccx.tcx.sess.span_fatal(pat.span, s);\n                     }\n \n-                    // TODO: vec::iter2\n+                    // TODO: ivec::iter2\n \n                     auto i = 0u;\n                     for (@ast::pat subpat in subpats) {"}, {"sha": "92639819aa95e50125d40f916e4a1118be09fd92", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -1,6 +1,6 @@\n+import std::ivec;\n import std::uint;\n import std::str;\n-import std::vec;\n import std::termivec;\n import std::ioivec;\n import std::option;\n@@ -14,33 +14,33 @@ type filename = str;\n  * with single-word things, rather than passing records all over the\n  * compiler.\n  */\n-type filemap = @rec(filename name, uint start_pos, mutable vec[uint] lines);\n+type filemap = @rec(filename name, uint start_pos, mutable uint[] lines);\n \n-type codemap = @rec(mutable vec[filemap] files);\n+type codemap = @rec(mutable filemap[] files);\n \n type loc = rec(filename filename, uint line, uint col);\n \n fn new_codemap() -> codemap {\n-    let vec[filemap] files = [];\n+    let filemap[] files = ~[];\n     ret @rec(mutable files=files);\n }\n \n fn new_filemap(filename filename, uint start_pos) -> filemap {\n-    ret @rec(name=filename, start_pos=start_pos, mutable lines=[0u]);\n+    ret @rec(name=filename, start_pos=start_pos, mutable lines=~[0u]);\n }\n \n-fn next_line(filemap file, uint pos) { vec::push[uint](file.lines, pos); }\n+fn next_line(filemap file, uint pos) { file.lines += ~[pos]; }\n \n fn lookup_pos(codemap map, uint pos) -> loc {\n     auto a = 0u;\n-    auto b = vec::len[filemap](map.files);\n+    auto b = ivec::len[filemap](map.files);\n     while (b - a > 1u) {\n         auto m = (a + b) / 2u;\n         if (map.files.(m).start_pos > pos) { b = m; } else { a = m; }\n     }\n     auto f = map.files.(a);\n     a = 0u;\n-    b = vec::len[uint](f.lines);\n+    b = ivec::len[uint](f.lines);\n     while (b - a > 1u) {\n         auto m = (a + b) / 2u;\n         if (f.lines.(m) > pos) { b = m; } else { a = m; }\n@@ -91,8 +91,8 @@ fn emit_diagnostic(&option::t[span] sp, &str msg, &str kind, u8 color,\n             auto max_lines = 6u;\n             auto elided = false;\n             auto display_lines = lines.lines;\n-            if (vec::len(display_lines) > max_lines) {\n-                display_lines = vec::slice(display_lines, 0u, max_lines);\n+            if (ivec::len(display_lines) > max_lines) {\n+                display_lines = ivec::slice(display_lines, 0u, max_lines);\n                 elided = true;\n             }\n             // Print the offending lines\n@@ -106,7 +106,8 @@ fn emit_diagnostic(&option::t[span] sp, &str msg, &str kind, u8 color,\n                 ioivec::stdout().write_str(s);\n             }\n             if (elided) {\n-                auto last_line = display_lines.(vec::len(display_lines) - 1u);\n+                auto last_line = display_lines.(ivec::len(display_lines) -\n+                                                1u);\n                 auto s = #fmt(\"%s:%u \", fm.name, last_line + 1u);\n                 auto indent = str::char_len(s);\n                 auto out = \"\";\n@@ -116,7 +117,7 @@ fn emit_diagnostic(&option::t[span] sp, &str msg, &str kind, u8 color,\n             }\n \n             // If there's one line at fault we can easily point to the problem\n-            if (vec::len(lines.lines) == 1u) {\n+            if (ivec::len(lines.lines) == 1u) {\n                 auto lo = codemap::lookup_pos(cm, option::get(sp).lo);\n                 auto digits = 0u;\n                 auto num = lines.lines.(0) / 10u;\n@@ -156,21 +157,21 @@ fn emit_note(&option::t[span] sp, &str msg, &codemap cm) {\n     emit_diagnostic(sp, msg, \"note\", 10u8, cm);\n }\n \n-type file_lines = rec(str name, vec[uint] lines);\n+type file_lines = rec(str name, uint[] lines);\n \n fn span_to_lines(span sp, codemap::codemap cm) -> @file_lines {\n     auto lo = codemap::lookup_pos(cm, sp.lo);\n     auto hi = codemap::lookup_pos(cm, sp.hi);\n-    auto lines = [];\n+    auto lines = ~[];\n     for each (uint i in uint::range(lo.line - 1u, hi.line as uint)) {\n-        lines += [i];\n+        lines += ~[i];\n     }\n     ret @rec(name=lo.filename, lines=lines);\n }\n \n fn get_line(filemap fm, int line, &str file) -> str {\n     let uint end;\n-    if ((line as uint) + 1u >= vec::len(fm.lines)) {\n+    if ((line as uint) + 1u >= ivec::len(fm.lines)) {\n         end = str::byte_len(file);\n     } else {\n         end = fm.lines.(line + 1);"}, {"sha": "5488867dcdda9e483b0ddc433a3e43840094ff11", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -1,5 +1,4 @@\n \n-import std::vec;\n import std::str;\n import std::option;\n import std::option::some;\n@@ -19,7 +18,7 @@ tag eval_mode { mode_depend; mode_parse; }\n type ctx =\n     @rec(parser p,\n          eval_mode mode,\n-         mutable vec[str] deps,\n+         mutable str[] deps,\n          parser::parse_sess sess,\n          mutable uint chpos,\n          ast::crate_cfg cfg);\n@@ -55,7 +54,7 @@ fn eval_crate_directive(ctx cx, @ast::crate_directive cdir, str prefix,\n             } else {\n                 prefix + std::fs::path_sep() + file_path\n             };\n-            if (cx.mode == mode_depend) { cx.deps += [full_path]; ret; }\n+            if (cx.mode == mode_depend) { cx.deps += ~[full_path]; ret; }\n             auto p0 =\n                 new_parser_from_file(cx.sess, cx.cfg, full_path, cx.chpos);\n             auto inner_attrs = parse_inner_attrs_and_next(p0);"}, {"sha": "da7c978ba785784f208c4fe4f0ffc74b70c53385", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -1,8 +1,8 @@\n \n import std::ioivec;\n-import std::str;\n-import std::vec;\n import std::int;\n+import std::ivec;\n+import std::str;\n import std::map;\n import std::map::hashmap;\n import std::option;\n@@ -40,7 +40,7 @@ fn new_reader(&codemap::codemap cm, str src, codemap::filemap filemap,\n                mutable uint mark_pos,\n                mutable uint mark_chpos,\n                mutable uint chpos,\n-               mutable vec[str] strs,\n+               mutable str[] strs,\n                codemap::filemap fm,\n                @interner::interner[str] itr) {\n         fn is_eof() -> bool { ret ch == -1 as char; }\n@@ -83,7 +83,7 @@ fn new_reader(&codemap::codemap cm, str src, codemap::filemap filemap,\n             codemap::emit_error(some(rec(lo=chpos, hi=chpos)), m, cm);\n         }\n     }\n-    let vec[str] strs = [];\n+    let str[] strs = ~[];\n     auto rd =\n         reader(cm, src, str::byte_len(src), 0u, 0u, -1 as char, 0u,\n                filemap.start_pos, filemap.start_pos, strs, filemap, itr);\n@@ -578,7 +578,7 @@ tag cmnt_style {\n \n }\n \n-type cmnt = rec(cmnt_style style, vec[str] lines, uint pos);\n+type cmnt = rec(cmnt_style style, str[] lines, uint pos);\n \n fn read_to_eol(&reader rdr) -> str {\n     auto val = \"\";\n@@ -610,7 +610,7 @@ fn consume_whitespace_counting_blank_lines(&reader rdr,\n     while (is_whitespace(rdr.curr()) && !rdr.is_eof()) {\n         if (rdr.curr() == '\\n' && rdr.next() == '\\n') {\n             log \">>> blank-line comment\";\n-            let vec[str] v = [];\n+            let str[] v = ~[];\n             comments += ~[rec(style=blank_line, lines=v,\n                               pos=rdr.get_chpos())];\n         }\n@@ -621,11 +621,11 @@ fn consume_whitespace_counting_blank_lines(&reader rdr,\n fn read_line_comments(&reader rdr, bool code_to_the_left) -> cmnt {\n     log \">>> line comments\";\n     auto p = rdr.get_chpos();\n-    let vec[str] lines = [];\n+    let str[] lines = ~[];\n     while (rdr.curr() == '/' && rdr.next() == '/') {\n         auto line = read_one_line_comment(rdr);\n         log line;\n-        lines += [line];\n+        lines += ~[line];\n         consume_non_eol_whitespace(rdr);\n     }\n     log \"<<< line comments\";\n@@ -643,7 +643,7 @@ fn all_whitespace(&str s, uint begin, uint end) -> bool {\n     ret true;\n }\n \n-fn trim_whitespace_prefix_and_push_line(&mutable vec[str] lines, &str s,\n+fn trim_whitespace_prefix_and_push_line(&mutable str[] lines, &str s,\n                                         uint col) {\n     auto s1;\n     if (all_whitespace(s, 0u, col)) {\n@@ -652,13 +652,13 @@ fn trim_whitespace_prefix_and_push_line(&mutable vec[str] lines, &str s,\n         } else { s1 = \"\"; }\n     } else { s1 = s; }\n     log \"pushing line: \" + s1;\n-    lines += [s1];\n+    lines += ~[s1];\n }\n \n fn read_block_comment(&reader rdr, bool code_to_the_left) -> cmnt {\n     log \">>> block comment\";\n     auto p = rdr.get_chpos();\n-    let vec[str] lines = [];\n+    let str[] lines = ~[];\n     let uint col = rdr.get_col();\n     rdr.bump();\n     rdr.bump();\n@@ -693,7 +693,7 @@ fn read_block_comment(&reader rdr, bool code_to_the_left) -> cmnt {\n     }\n     auto style = if (code_to_the_left) { trailing } else { isolated };\n     consume_non_eol_whitespace(rdr);\n-    if (!rdr.is_eof() && rdr.curr() != '\\n' && vec::len(lines) == 1u) {\n+    if (!rdr.is_eof() && rdr.curr() != '\\n' && ivec::len(lines) == 1u) {\n         style = mixed;\n     }\n     log \"<<< block comment\";"}, {"sha": "2f810f84614f83b26c245a5f82e594c0219897ce", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 55, "deletions": 93, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -1,7 +1,6 @@\n \n import std::ioivec;\n import std::ivec;\n-import std::vec;\n import std::str;\n import std::option;\n import std::option::some;\n@@ -45,7 +44,7 @@ type parser =\n         fn get_lo_pos() -> uint ;\n         fn get_hi_pos() -> uint ;\n         fn get_last_lo_pos() -> uint ;\n-        fn get_prec_table() -> vec[op_spec] ;\n+        fn get_prec_table() -> @op_spec[] ;\n         fn get_str(token::str_num) -> str ;\n         fn get_reader() -> lexer::reader ;\n         fn get_filemap() -> codemap::filemap ;\n@@ -62,7 +61,7 @@ fn new_parser_from_file(parse_sess sess, ast::crate_cfg cfg,\n     auto srdr = ioivec::file_reader(path);\n     auto src = str::unsafe_from_bytes_ivec(srdr.read_whole_stream());\n     auto filemap = codemap::new_filemap(path, pos);\n-    vec::push(sess.cm.files, filemap);\n+    sess.cm.files += ~[filemap];\n     auto itr = @interner::mk(str::hash, str::eq);\n     auto rdr = lexer::new_reader(sess.cm, src, filemap, itr);\n \n@@ -80,7 +79,7 @@ fn new_parser(parse_sess sess, ast::crate_cfg cfg, lexer::reader rdr,\n                      mutable uint last_lo,\n                      mutable restriction restr,\n                      lexer::reader rdr,\n-                     vec[op_spec] precs,\n+                     @op_spec[] precs,\n                      hashmap[str, ()] bad_words) {\n         fn peek() -> token::token { ret tok; }\n         fn bump() {\n@@ -107,7 +106,7 @@ fn new_parser(parse_sess sess, ast::crate_cfg cfg, lexer::reader rdr,\n         fn get_last_lo_pos() -> uint { ret last_lo; }\n         fn get_file_type() -> file_type { ret ftype; }\n         fn get_cfg() -> ast::crate_cfg { ret cfg; }\n-        fn get_prec_table() -> vec[op_spec] { ret precs; }\n+        fn get_prec_table() -> @op_spec[] { ret precs; }\n         fn get_str(token::str_num i) -> str {\n             ret interner::get(*rdr.get_interner(), i);\n         }\n@@ -258,7 +257,7 @@ fn parse_ty_fn(ast::proto proto, &parser p, uint lo) -> ast::ty_ {\n     }\n     auto lo = p.get_lo_pos();\n     auto inputs =\n-        parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+        parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                        parse_fn_input_ty, p);\n     auto constrs = parse_constrs(~[], p);\n     let @ast::ty output;\n@@ -308,7 +307,7 @@ fn parse_ty_obj(&parser p, &mutable uint hi) -> ast::ty_ {\n         fail;\n     }\n     auto f = parse_method_sig;\n-    auto meths = parse_seq_ivec(token::LBRACE, token::RBRACE, none, f, p);\n+    auto meths = parse_seq(token::LBRACE, token::RBRACE, none, f, p);\n     hi = meths.span.hi;\n     ret ast::ty_obj(meths.node);\n }\n@@ -352,7 +351,7 @@ fn parse_ty_constr(&ast::arg[] fn_args, &parser p) -> @ast::constr {\n     auto path = parse_path(p);\n     auto pf = bind parse_constr_arg(fn_args, _);\n     let rec((@ast::constr_arg)[] node, span span) args =\n-        parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA), pf,\n+        parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA), pf,\n                        p);\n     // FIXME fix the def_id\n \n@@ -409,12 +408,8 @@ fn parse_ty_postfix(@ast::ty orig_t, &parser p) -> @ast::ty {\n \n         if (mut == ast::imm && p.peek() != token::RBRACKET) {\n             // This is explicit type parameter instantiation.\n-            auto seq = parse_seq_to_end(token::RBRACKET, some(token::COMMA),\n-                                        parse_ty, p);\n-\n-            // FIXME: Remove this vec->ivec conversion.\n-            auto seq_ivec = ~[];\n-            for (@ast::ty typ in seq) { seq_ivec += ~[typ]; }\n+            auto seq = parse_seq_to_end(token::RBRACKET,\n+                                             some(token::COMMA), parse_ty, p);\n \n             alt (orig_t.node) {\n                 case (ast::ty_path(?pth, ?ann)) {\n@@ -423,7 +418,7 @@ fn parse_ty_postfix(@ast::ty orig_t, &parser p) -> @ast::ty {\n                                  ast::ty_path(spanned(lo, hi,\n                                               rec(global=pth.node.global,\n                                                   idents=pth.node.idents,\n-                                                  types=seq_ivec)),\n+                                                  types=seq)),\n                                               ann));\n                 }\n                 case (_) {\n@@ -522,13 +517,13 @@ fn parse_ty(&parser p) -> @ast::ty {\n         expect(p, token::RBRACKET);\n     } else if (eat_word(p, \"tup\")) {\n         auto elems =\n-            parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                            parse_mt, p);\n         hi = elems.span.hi;\n         t = ast::ty_tup(elems.node);\n     } else if (eat_word(p, \"rec\")) {\n         auto elems =\n-            parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                            parse_ty_field, p);\n         hi = elems.span.hi;\n         t = ast::ty_rec(elems.node);\n@@ -577,23 +572,6 @@ fn parse_arg(&parser p) -> ast::arg {\n }\n \n fn parse_seq_to_end[T](token::token ket, option::t[token::token] sep,\n-                       fn(&parser) -> T  f, &parser p) -> vec[T] {\n-    let bool first = true;\n-    let vec[T] v = [];\n-    while (p.peek() != ket) {\n-        alt (sep) {\n-            case (some(?t)) {\n-                if (first) { first = false; } else { expect(p, t); }\n-            }\n-            case (_) { }\n-        }\n-        v += [f(p)];\n-    }\n-    expect(p, ket);\n-    ret v;\n-}\n-\n-fn parse_seq_to_end_ivec[T](token::token ket, option::t[token::token] sep,\n                             fn(&parser)->T  f, &parser p) -> T[] {\n     let bool first = true;\n     let T[] v = ~[];\n@@ -612,21 +590,11 @@ fn parse_seq_to_end_ivec[T](token::token ket, option::t[token::token] sep,\n \n \n fn parse_seq[T](token::token bra, token::token ket,\n-                option::t[token::token] sep, fn(&parser) -> T  f, &parser p)\n-   -> ast::spanned[vec[T]] {\n-    auto lo = p.get_lo_pos();\n-    expect(p, bra);\n-    auto result = parse_seq_to_end[T](ket, sep, f, p);\n-    auto hi = p.get_hi_pos();\n-    ret spanned(lo, hi, result);\n-}\n-\n-fn parse_seq_ivec[T](token::token bra, token::token ket,\n                      option::t[token::token] sep,\n                      fn(&parser)->T  f, &parser p) -> ast::spanned[T[]] {\n     auto lo = p.get_lo_pos();\n     expect(p, bra);\n-    auto result = parse_seq_to_end_ivec[T](ket, sep, f, p);\n+    auto result = parse_seq_to_end[T](ket, sep, f, p);\n     auto hi = p.get_hi_pos();\n     ret spanned(lo, hi, result);\n }\n@@ -704,15 +672,10 @@ fn parse_path_and_ty_param_substs(&parser p) -> ast::path {\n     if (p.peek() == token::LBRACKET) {\n         auto seq = parse_seq(token::LBRACKET, token::RBRACKET,\n                              some(token::COMMA), parse_ty, p);\n-\n-        // FIXME: Remove this vec->ivec conversion.\n-        auto seq_ivec = ~[];\n-        for (@ast::ty typ in seq.node) { seq_ivec += ~[typ]; }\n-\n         auto hi = p.get_hi_pos();\n         path = spanned(lo, hi, rec(global=path.node.global,\n                                    idents=path.node.idents,\n-                                   types=seq_ivec));\n+                                   types=seq.node));\n     }\n     ret path;\n }\n@@ -793,15 +756,15 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             ret rec(mut=m, expr=e);\n         }\n         auto es =\n-            parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                            parse_elt, p);\n         hi = es.span.hi;\n         ex = ast::expr_tup(es.node);\n     } else if (p.peek() == token::LBRACKET) {\n         p.bump();\n         auto mut = parse_mutability(p);\n         auto es =\n-            parse_seq_to_end_ivec(token::RBRACKET, some(token::COMMA),\n+            parse_seq_to_end(token::RBRACKET, some(token::COMMA),\n                                   parse_expr, p);\n         ex = ast::expr_vec(es, mut, ast::sk_rc);\n     } else if (p.peek() == token::POUND_LT) {\n@@ -822,7 +785,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n                 p.bump();\n                 auto mut = parse_mutability(p);\n                 auto es =\n-                    parse_seq_to_end_ivec(token::RBRACKET, some(token::COMMA),\n+                    parse_seq_to_end(token::RBRACKET, some(token::COMMA),\n                                           parse_expr, p);\n                 ex = ast::expr_vec(es, mut, ast::sk_unique);\n             }\n@@ -848,7 +811,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         if (p.peek() == token::LPAREN) {\n             p.bump();\n             fields =\n-                some(parse_seq_to_end_ivec(token::RPAREN, some(token::COMMA),\n+                some(parse_seq_to_end(token::RPAREN, some(token::COMMA),\n                                            parse_anon_obj_field, p));\n         }\n         let (@ast::method)[] meths = ~[];\n@@ -902,7 +865,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n             }\n         }\n         auto es =\n-            parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                            parse_expr_opt, p);\n         hi = es.span.hi;\n         ex = ast::expr_bind(e, es.node);\n@@ -1003,7 +966,7 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n \n         let @ast::expr f = parse_self_method(p);\n         auto es =\n-            parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+            parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                            parse_expr, p);\n         hi = es.span.hi;\n         ex = ast::expr_call(f, es.node);\n@@ -1033,7 +996,7 @@ fn parse_syntax_ext_naked(&parser p, uint lo) -> @ast::expr {\n     if (ivec::len(pth.node.idents) == 0u) {\n         p.fatal(\"expected a syntax expander name\");\n     }\n-    auto es = parse_seq_ivec(token::LPAREN, token::RPAREN,\n+    auto es = parse_seq(token::LPAREN, token::RPAREN,\n                              some(token::COMMA), parse_expr, p);\n     auto hi = es.span.hi;\n     ret mk_mac_expr(p, lo, hi, ast::mac_invoc(pth, es.node, none));\n@@ -1061,7 +1024,7 @@ fn parse_dot_or_call_expr_with(&parser p, @ast::expr e) -> @ast::expr {\n                     // Call expr.\n \n                     auto es =\n-                        parse_seq_ivec(token::LPAREN, token::RPAREN,\n+                        parse_seq(token::LPAREN, token::RPAREN,\n                                        some(token::COMMA), parse_expr, p);\n                     hi = es.span.hi;\n                     e = mk_expr(p, lo, hi, ast::expr_call(e, es.node));\n@@ -1157,27 +1120,27 @@ type op_spec = rec(token::token tok, ast::binop op, int prec);\n \n \n // FIXME make this a const, don't store it in parser state\n-fn prec_table() -> vec[op_spec] {\n-    ret [rec(tok=token::BINOP(token::STAR), op=ast::mul, prec=11),\n-         rec(tok=token::BINOP(token::SLASH), op=ast::div, prec=11),\n-         rec(tok=token::BINOP(token::PERCENT), op=ast::rem, prec=11),\n-         rec(tok=token::BINOP(token::PLUS), op=ast::add, prec=10),\n-         rec(tok=token::BINOP(token::MINUS), op=ast::sub, prec=10),\n-         rec(tok=token::BINOP(token::LSL), op=ast::lsl, prec=9),\n-         rec(tok=token::BINOP(token::LSR), op=ast::lsr, prec=9),\n-         rec(tok=token::BINOP(token::ASR), op=ast::asr, prec=9),\n-         rec(tok=token::BINOP(token::AND), op=ast::bitand, prec=8),\n-         rec(tok=token::BINOP(token::CARET), op=ast::bitxor, prec=6),\n-         rec(tok=token::BINOP(token::OR), op=ast::bitor, prec=6),\n-         // 'as' sits between here with 5\n-         rec(tok=token::LT, op=ast::lt, prec=4),\n-         rec(tok=token::LE, op=ast::le, prec=4),\n-         rec(tok=token::GE, op=ast::ge, prec=4),\n-         rec(tok=token::GT, op=ast::gt, prec=4),\n-         rec(tok=token::EQEQ, op=ast::eq, prec=3),\n-         rec(tok=token::NE, op=ast::ne, prec=3),\n-         rec(tok=token::ANDAND, op=ast::and, prec=2),\n-         rec(tok=token::OROR, op=ast::or, prec=1)];\n+fn prec_table() -> @op_spec[] {\n+    ret @~[rec(tok=token::BINOP(token::STAR), op=ast::mul, prec=11),\n+           rec(tok=token::BINOP(token::SLASH), op=ast::div, prec=11),\n+           rec(tok=token::BINOP(token::PERCENT), op=ast::rem, prec=11),\n+           rec(tok=token::BINOP(token::PLUS), op=ast::add, prec=10),\n+           rec(tok=token::BINOP(token::MINUS), op=ast::sub, prec=10),\n+           rec(tok=token::BINOP(token::LSL), op=ast::lsl, prec=9),\n+           rec(tok=token::BINOP(token::LSR), op=ast::lsr, prec=9),\n+           rec(tok=token::BINOP(token::ASR), op=ast::asr, prec=9),\n+           rec(tok=token::BINOP(token::AND), op=ast::bitand, prec=8),\n+           rec(tok=token::BINOP(token::CARET), op=ast::bitxor, prec=6),\n+           rec(tok=token::BINOP(token::OR), op=ast::bitor, prec=6),\n+           // 'as' sits between here with 5\n+           rec(tok=token::LT, op=ast::lt, prec=4),\n+           rec(tok=token::LE, op=ast::le, prec=4),\n+           rec(tok=token::GE, op=ast::ge, prec=4),\n+           rec(tok=token::GT, op=ast::gt, prec=4),\n+           rec(tok=token::EQEQ, op=ast::eq, prec=3),\n+           rec(tok=token::NE, op=ast::ne, prec=3),\n+           rec(tok=token::ANDAND, op=ast::and, prec=2),\n+           rec(tok=token::OROR, op=ast::or, prec=1)];\n }\n \n fn parse_binops(&parser p) -> @ast::expr {\n@@ -1191,7 +1154,7 @@ const int ternary_prec = 0;\n \n fn parse_more_binops(&parser p, @ast::expr lhs, int min_prec) -> @ast::expr {\n     auto peeked = p.peek();\n-    for (op_spec cur in p.get_prec_table()) {\n+    for (op_spec cur in *p.get_prec_table()) {\n         if (cur.prec > min_prec && cur.tok == peeked) {\n             p.bump();\n             auto rhs = parse_more_binops(p, parse_prefix_expr(p), cur.prec);\n@@ -1378,7 +1341,7 @@ fn parse_spawn_expr(&parser p) -> @ast::expr {\n \n     auto fn_expr = parse_bottom_expr(p);\n     auto es =\n-        parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+        parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                        parse_expr, p);\n     auto hi = es.span.hi;\n     ret mk_expr(p, lo, hi, ast::expr_spawn\n@@ -1515,7 +1478,7 @@ fn parse_pat(&parser p) -> @ast::pat {\n                     case (token::LPAREN) {\n                         auto f = parse_pat;\n                         auto a =\n-                            parse_seq_ivec(token::LPAREN, token::RPAREN,\n+                            parse_seq(token::LPAREN, token::RPAREN,\n                                            some(token::COMMA), f, p);\n                         args = a.node;\n                         hi = a.span.hi;\n@@ -1763,15 +1726,15 @@ fn parse_ty_params(&parser p) -> ast::ty_param[] {\n     let ast::ty_param[] ty_params = ~[];\n     if (p.peek() == token::LBRACKET) {\n         ty_params =\n-            parse_seq_ivec(token::LBRACKET, token::RBRACKET,\n+            parse_seq(token::LBRACKET, token::RBRACKET,\n                            some(token::COMMA), parse_ty_param, p).node;\n     }\n     ret ty_params;\n }\n \n fn parse_fn_decl(&parser p, ast::purity purity) -> ast::fn_decl {\n     let ast::spanned[ast::arg[]] inputs =\n-        parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+        parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                        parse_arg, p);\n     let ty_or_bang rslt;\n     auto constrs = parse_constrs(inputs.node, p).node;\n@@ -1879,7 +1842,7 @@ fn parse_item_obj(&parser p, ast::layer lyr, &ast::attribute[] attrs) ->\n     auto ident = parse_value_ident(p);\n     auto ty_params = parse_ty_params(p);\n     let ast::spanned[ast::obj_field[]] fields =\n-        parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+        parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                        parse_obj_field, p);\n     let (@ast::method)[] meths = ~[];\n     let option::t[@ast::method] dtor = none;\n@@ -2110,7 +2073,7 @@ fn parse_item_tag(&parser p, &ast::attribute[] attrs) -> @ast::item {\n                     case (token::LPAREN) {\n                         auto arg_tys =\n                             parse_seq(token::LPAREN, token::RPAREN,\n-                                      some(token::COMMA), parse_ty, p);\n+                                           some(token::COMMA), parse_ty, p);\n                         for (@ast::ty ty in arg_tys.node) {\n                             args += ~[rec(ty=ty, id=p.get_id())];\n                         }\n@@ -2284,8 +2247,8 @@ fn parse_meta_item(&parser p) -> @ast::meta_item {\n }\n \n fn parse_meta_seq(&parser p) -> (@ast::meta_item)[] {\n-    ret parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                       parse_meta_item, p).node;\n+    ret parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                  parse_meta_item, p).node;\n }\n \n fn parse_optional_meta(&parser p) -> (@ast::meta_item)[] {\n@@ -2424,7 +2387,7 @@ fn parse_crate_from_source_str(&str name, &str source, &ast::crate_cfg cfg,\n     auto sess = @rec(cm=cm, mutable next_id=0);\n     auto ftype = SOURCE_FILE;\n     auto filemap = codemap::new_filemap(name, 0u);\n-    sess.cm.files += [filemap];\n+    sess.cm.files += ~[filemap];\n     auto itr = @interner::mk(str::hash, str::eq);\n     auto rdr = lexer::new_reader(sess.cm, source, filemap, itr);\n     auto p = new_parser(sess, cfg, rdr, ftype);\n@@ -2548,15 +2511,14 @@ fn parse_crate_from_crate_file(&str input, &ast::crate_cfg cfg,\n     auto crate_attrs = leading_attrs._0;\n     auto first_cdir_attr = leading_attrs._1;\n     auto cdirs = parse_crate_directives(p, token::EOF, first_cdir_attr);\n-    let vec[str] deps = [];\n+    let str[] deps = ~[];\n     auto cx = @rec(p=p,\n                    mode=eval::mode_parse,\n                    mutable deps=deps,\n                    sess=sess,\n                    mutable chpos=p.get_chpos(),\n                    cfg = p.get_cfg());\n-    auto m =\n-        eval::eval_crate_directives_to_mod(cx, cdirs, prefix);\n+    auto m = eval::eval_crate_directives_to_mod(cx, cdirs, prefix);\n     auto hi = p.get_hi_pos();\n     expect(p, token::EOF);\n     ret @spanned(lo, hi, rec(directives=cdirs,"}, {"sha": "21a9bfa6b195e0b4b28a854c302706e4e3e6fb7d", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -1,6 +1,6 @@\n \n import std::ioivec;\n-import std::vec;\n+import std::ivec;\n import std::str;\n \n \n@@ -74,10 +74,10 @@ fn tok_str(token t) -> str {\n     }\n }\n \n-fn buf_str(vec[mutable token] toks, vec[mutable int] szs, uint left,\n-           uint right, uint lim) -> str {\n-    auto n = vec::len(toks);\n-    assert (n == vec::len(szs));\n+fn buf_str(&token[mutable] toks, &int[mutable] szs, uint left, uint right,\n+           uint lim) -> str {\n+    auto n = ivec::len(toks);\n+    assert (n == ivec::len(szs));\n     auto i = left;\n     auto L = lim;\n     auto s = \"[\";\n@@ -104,10 +104,10 @@ fn mk_printer(ioivec::writer out, uint linewidth) -> printer {\n \n     let uint n = 3u * linewidth;\n     log #fmt(\"mk_printer %u\", linewidth);\n-    let vec[mutable token] token = vec::init_elt_mut(EOF, n);\n-    let vec[mutable int] size = vec::init_elt_mut(0, n);\n-    let vec[mutable uint] scan_stack = vec::init_elt_mut(0u, n);\n-    let vec[print_stack_elt] print_stack = [];\n+    let token[mutable] token = ivec::init_elt_mut(EOF, n);\n+    let int[mutable] size = ivec::init_elt_mut(0, n);\n+    let uint[mutable] scan_stack = ivec::init_elt_mut(0u, n);\n+    let print_stack_elt[] print_stack = ~[];\n     ret printer(out, n, linewidth as int, // margin\n                  linewidth as int, // space\n                  0u, // left\n@@ -208,9 +208,9 @@ obj printer(ioivec::writer out,\n \n             mutable uint right, // index of right side of input stream\n \n-            mutable vec[mutable token] token,\n+            mutable token[mutable] token,\n              // ring-buffr stream goes through\n-            mutable vec[mutable int] size, // ring-buffer of calculated sizes\n+            mutable int[mutable] size, // ring-buffer of calculated sizes\n \n             mutable int left_total, // running size of stream \"...left\"\n \n@@ -222,15 +222,15 @@ obj printer(ioivec::writer out,\n              // BEGIN (if there is any) on top of it. Stuff is flushed off the\n              // bottom as it becomes irrelevant due to the primary ring-buffer\n              // advancing.\n-             mutable vec[mutable uint] scan_stack,\n+             mutable uint[mutable] scan_stack,\n             mutable bool scan_stack_empty, // top==bottom disambiguator\n \n             mutable uint top, // index of top of scan_stack\n \n             mutable uint bottom, // index of bottom of scan_stack\n \n              // stack of blocks-in-progress being flushed by print\n-            mutable vec[print_stack_elt] print_stack,\n+            mutable print_stack_elt[] print_stack,\n \n             // buffered indentation to avoid writing trailing whitespace\n             mutable int pending_indentation) {\n@@ -403,7 +403,7 @@ obj printer(ioivec::writer out,\n         pending_indentation += amount;\n     }\n     fn top() -> print_stack_elt {\n-        auto n = vec::len(print_stack);\n+        auto n = ivec::len(print_stack);\n         let print_stack_elt top = rec(offset=0, pbreak=broken(inconsistent));\n         if (n != 0u) { top = print_stack.(n - 1u); }\n         ret top;\n@@ -425,17 +425,17 @@ obj printer(ioivec::writer out,\n                     auto col = margin - space + b.offset;\n                     log #fmt(\"print BEGIN -> push broken block at col %d\",\n                              col);\n-                    vec::push(print_stack,\n-                              rec(offset=col, pbreak=broken(b.breaks)));\n+                    print_stack += ~[rec(offset=col,\n+                                         pbreak=broken(b.breaks))];\n                 } else {\n                     log \"print BEGIN -> push fitting block\";\n-                    vec::push(print_stack, rec(offset=0, pbreak=fits));\n+                    print_stack += ~[rec(offset=0, pbreak=fits)];\n                 }\n             }\n             case (END) {\n                 log \"print END -> pop END\";\n-                assert (vec::len(print_stack) != 0u);\n-                vec::pop(print_stack);\n+                assert (ivec::len(print_stack) != 0u);\n+                ivec::pop(print_stack);\n             }\n             case (BREAK(?b)) {\n                 auto top = self.top();"}, {"sha": "8ade4ff6a022573119323a1a6556492d0b90b288", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917afa4cc9d323a888bb174f46c17610aeebfb2b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=917afa4cc9d323a888bb174f46c17610aeebfb2b", "patch": "@@ -4,7 +4,6 @@ import std::int;\n import std::ioivec;\n import std::str;\n import std::uint;\n-import std::vec;\n import std::option;\n import parse::lexer;\n import syntax::codemap::codemap;\n@@ -1267,7 +1266,7 @@ fn print_view_item(&ps s, &@ast::view_item item) {\n // FIXME: The fact that this builds up the table anew for every call is\n // not good. Eventually, table should be a const.\n fn operator_prec(ast::binop op) -> int {\n-    for (parse::parser::op_spec spec in parse::parser::prec_table()) {\n+    for (parse::parser::op_spec spec in *parse::parser::prec_table()) {\n         if (spec.op == op) { ret spec.prec; }\n     }\n     fail;\n@@ -1445,7 +1444,7 @@ fn maybe_print_comment(&ps s, uint pos) {\n fn print_comment(&ps s, lexer::cmnt cmnt) {\n     alt (cmnt.style) {\n         case (lexer::mixed) {\n-            assert (vec::len(cmnt.lines) == 1u);\n+            assert (ivec::len(cmnt.lines) == 1u);\n             zerobreak(s.s);\n             word(s.s, cmnt.lines.(0));\n             zerobreak(s.s);\n@@ -1456,7 +1455,7 @@ fn print_comment(&ps s, lexer::cmnt cmnt) {\n         }\n         case (lexer::trailing) {\n             word(s.s, \" \");\n-            if (vec::len(cmnt.lines) == 1u) {\n+            if (ivec::len(cmnt.lines) == 1u) {\n                 word(s.s, cmnt.lines.(0));\n                 hardbreak(s.s);\n             } else {"}]}