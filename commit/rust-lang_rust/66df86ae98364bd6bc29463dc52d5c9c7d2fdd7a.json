{"sha": "66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZGY4NmFlOTgzNjRiZDZiYzI5NDYzZGM1MmQ1YzljN2QyZmRkN2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-17T09:21:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-17T09:21:36Z"}, "message": "auto merge of #10466 : alexcrichton/rust/issue-10334, r=cmr\n\nThese commits create a `Buffer` trait in the `io` module which represents an I/O reader which is internally buffered. This abstraction is used to reasonably implement `read_line` and `read_until` along with at least an ok implementation of `read_char` (although I certainly haven't benchmarked `read_char`).", "tree": {"sha": "323febd79e7a86a12ccd1dd75358b012cbecd76b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/323febd79e7a86a12ccd1dd75358b012cbecd76b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a", "html_url": "https://github.com/rust-lang/rust/commit/66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a577f384e22b51bc7299ba9521a6054b3a1ddfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a577f384e22b51bc7299ba9521a6054b3a1ddfc", "html_url": "https://github.com/rust-lang/rust/commit/0a577f384e22b51bc7299ba9521a6054b3a1ddfc"}, {"sha": "01343d3d2987dfea6a3982aba3735a95c9a0c51c", "url": "https://api.github.com/repos/rust-lang/rust/commits/01343d3d2987dfea6a3982aba3735a95c9a0c51c", "html_url": "https://github.com/rust-lang/rust/commit/01343d3d2987dfea6a3982aba3735a95c9a0c51c"}], "stats": {"total": 259, "additions": 157, "deletions": 102}, "files": [{"sha": "2d8f1a721661993684a4a248739693b98a65253d", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 26, "deletions": 81, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a", "patch": "@@ -55,8 +55,7 @@ use prelude::*;\n \n use num;\n use vec;\n-use str;\n-use super::{Reader, Writer, Stream, Decorator};\n+use super::{Stream, Decorator};\n \n // libuv recommends 64k buffers to maximize throughput\n // https://groups.google.com/forum/#!topic/libuv/oQO1HJAIDdA\n@@ -93,45 +92,10 @@ impl<R: Reader> BufferedReader<R> {\n     pub fn new(inner: R) -> BufferedReader<R> {\n         BufferedReader::with_capacity(DEFAULT_CAPACITY, inner)\n     }\n+}\n \n-    /// Reads the next line of input, interpreted as a sequence of utf-8\n-    /// encoded unicode codepoints. If a newline is encountered, then the\n-    /// newline is contained in the returned string.\n-    pub fn read_line(&mut self) -> Option<~str> {\n-        self.read_until('\\n' as u8).map(str::from_utf8_owned)\n-    }\n-\n-    /// Reads a sequence of bytes leading up to a specified delimeter. Once the\n-    /// specified byte is encountered, reading ceases and the bytes up to and\n-    /// including the delimiter are returned.\n-    pub fn read_until(&mut self, byte: u8) -> Option<~[u8]> {\n-        let mut res = ~[];\n-        let mut used;\n-        loop {\n-            {\n-                let available = self.fill_buffer();\n-                match available.iter().position(|&b| b == byte) {\n-                    Some(i) => {\n-                        res.push_all(available.slice_to(i + 1));\n-                        used = i + 1;\n-                        break\n-                    }\n-                    None => {\n-                        res.push_all(available);\n-                        used = available.len();\n-                    }\n-                }\n-            }\n-            if used == 0 {\n-                break\n-            }\n-            self.pos += used;\n-        }\n-        self.pos += used;\n-        return if res.len() == 0 {None} else {Some(res)};\n-    }\n-\n-    fn fill_buffer<'a>(&'a mut self) -> &'a [u8] {\n+impl<R: Reader> Buffer for BufferedReader<R> {\n+    fn fill<'a>(&'a mut self) -> &'a [u8] {\n         if self.pos == self.cap {\n             match self.inner.read(self.buf) {\n                 Some(cap) => {\n@@ -143,12 +107,17 @@ impl<R: Reader> BufferedReader<R> {\n         }\n         return self.buf.slice(self.pos, self.cap);\n     }\n+\n+    fn consume(&mut self, amt: uint) {\n+        self.pos += amt;\n+        assert!(self.pos <= self.cap);\n+    }\n }\n \n impl<R: Reader> Reader for BufferedReader<R> {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         let nread = {\n-            let available = self.fill_buffer();\n+            let available = self.fill();\n             if available.len() == 0 {\n                 return None;\n             }\n@@ -166,17 +135,9 @@ impl<R: Reader> Reader for BufferedReader<R> {\n }\n \n impl<R: Reader> Decorator<R> for BufferedReader<R> {\n-    fn inner(self) -> R {\n-        self.inner\n-    }\n-\n-    fn inner_ref<'a>(&'a self) -> &'a R {\n-        &self.inner\n-    }\n-\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R {\n-        &mut self.inner\n-    }\n+    fn inner(self) -> R { self.inner }\n+    fn inner_ref<'a>(&'a self) -> &'a R { &self.inner }\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R { &mut self.inner }\n }\n \n /// Wraps a Writer and buffers output to it\n@@ -279,13 +240,8 @@ impl<W: Writer> Decorator<W> for LineBufferedWriter<W> {\n struct InternalBufferedWriter<W>(BufferedWriter<W>);\n \n impl<W: Reader> Reader for InternalBufferedWriter<W> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        self.inner.read(buf)\n-    }\n-\n-    fn eof(&mut self) -> bool {\n-        self.inner.eof()\n-    }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.inner.read(buf) }\n+    fn eof(&mut self) -> bool { self.inner.eof() }\n }\n \n /// Wraps a Stream and buffers input and output to and from it\n@@ -311,35 +267,24 @@ impl<S: Stream> BufferedStream<S> {\n     }\n }\n \n-impl<S: Stream> Reader for BufferedStream<S> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        self.inner.read(buf)\n-    }\n+impl<S: Stream> Buffer for BufferedStream<S> {\n+    fn fill<'a>(&'a mut self) -> &'a [u8] { self.inner.fill() }\n+    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n+}\n \n-    fn eof(&mut self) -> bool {\n-        self.inner.eof()\n-    }\n+impl<S: Stream> Reader for BufferedStream<S> {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.inner.read(buf) }\n+    fn eof(&mut self) -> bool { self.inner.eof() }\n }\n \n impl<S: Stream> Writer for BufferedStream<S> {\n-    fn write(&mut self, buf: &[u8]) {\n-        self.inner.inner.write(buf)\n-    }\n-\n-    fn flush(&mut self) {\n-        self.inner.inner.flush()\n-    }\n+    fn write(&mut self, buf: &[u8]) { self.inner.inner.write(buf) }\n+    fn flush(&mut self) { self.inner.inner.flush() }\n }\n \n impl<S: Stream> Decorator<S> for BufferedStream<S> {\n-    fn inner(self) -> S {\n-        self.inner.inner.inner()\n-    }\n-\n-    fn inner_ref<'a>(&'a self) -> &'a S {\n-        self.inner.inner.inner_ref()\n-    }\n-\n+    fn inner(self) -> S { self.inner.inner.inner() }\n+    fn inner_ref<'a>(&'a self) -> &'a S { self.inner.inner.inner_ref() }\n     fn inner_mut_ref<'a>(&'a mut self) -> &'a mut S {\n         self.inner.inner.inner_mut_ref()\n     }"}, {"sha": "4b9c5ca5d4ab02bfa6c060dbee0afd2d31e1df7d", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a", "patch": "@@ -123,29 +123,18 @@ impl Reader for MemReader {\n \n impl Seek for MemReader {\n     fn tell(&self) -> u64 { self.pos as u64 }\n-\n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n \n-impl Decorator<~[u8]> for MemReader {\n-\n-    fn inner(self) -> ~[u8] {\n-        match self {\n-            MemReader { buf: buf, _ } => buf\n-        }\n-    }\n-\n-    fn inner_ref<'a>(&'a self) -> &'a ~[u8] {\n-        match *self {\n-            MemReader { buf: ref buf, _ } => buf\n-        }\n-    }\n+impl Buffer for MemReader {\n+    fn fill<'a>(&'a mut self) -> &'a [u8] { self.buf.slice_from(self.pos) }\n+    fn consume(&mut self, amt: uint) { self.pos += amt; }\n+}\n \n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] {\n-        match *self {\n-            MemReader { buf: ref mut buf, _ } => buf\n-        }\n-    }\n+impl Decorator<~[u8]> for MemReader {\n+    fn inner(self) -> ~[u8] { self.buf }\n+    fn inner_ref<'a>(&'a self) -> &'a ~[u8] { &self.buf }\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] { &mut self.buf }\n }\n \n \n@@ -244,6 +233,11 @@ impl<'self> Seek for BufReader<'self> {\n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n \n+impl<'self> Buffer for BufReader<'self> {\n+    fn fill<'a>(&'a mut self) -> &'a [u8] { self.buf.slice_from(self.pos) }\n+    fn consume(&mut self, amt: uint) { self.pos += amt; }\n+}\n+\n ///Calls a function with a MemWriter and returns\n ///the writer's stored vector.\n pub fn with_mem_writer(writeFn:&fn(&mut MemWriter)) -> ~[u8] {\n@@ -394,4 +388,20 @@ mod test {\n         let buf = with_mem_writer(|wr| wr.write([1,2,3,4,5,6,7]));\n         assert_eq!(buf, ~[1,2,3,4,5,6,7]);\n     }\n+\n+    #[test]\n+    fn test_read_char() {\n+        let mut r = BufReader::new(bytes!(\"Vi\u1ec7t\"));\n+        assert_eq!(r.read_char(), Some('V'));\n+        assert_eq!(r.read_char(), Some('i'));\n+        assert_eq!(r.read_char(), Some('\u1ec7'));\n+        assert_eq!(r.read_char(), Some('t'));\n+        assert_eq!(r.read_char(), None);\n+    }\n+\n+    #[test]\n+    fn test_read_bad_char() {\n+        let mut r = BufReader::new(bytes!(0x80));\n+        assert_eq!(r.read_char(), None);\n+    }\n }"}, {"sha": "c56189dbb2b17ed1fe04d48ffbd15bab2f9b70b0", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 101, "deletions": 1, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a", "patch": "@@ -247,11 +247,12 @@ use iter::Iterator;\n use option::{Option, Some, None};\n use path::Path;\n use result::{Ok, Err, Result};\n+use str;\n use str::{StrSlice, OwnedStr};\n use to_str::ToStr;\n use uint;\n use unstable::finally::Finally;\n-use vec::{OwnedVector, MutableVector};\n+use vec::{OwnedVector, MutableVector, ImmutableVector, OwnedCopyableVector};\n use vec;\n \n // Reexports\n@@ -960,6 +961,105 @@ pub trait Stream: Reader + Writer { }\n \n impl<T: Reader + Writer> Stream for T {}\n \n+/// A Buffer is a type of reader which has some form of internal buffering to\n+/// allow certain kinds of reading operations to be more optimized than others.\n+/// This type extends the `Reader` trait with a few methods that are not\n+/// possible to reasonably implement with purely a read interface.\n+pub trait Buffer: Reader {\n+    /// Fills the internal buffer of this object, returning the buffer contents.\n+    /// Note that none of the contents will be \"read\" in the sense that later\n+    /// calling `read` may return the same contents.\n+    ///\n+    /// The `consume` function must be called with the number of bytes that are\n+    /// consumed from this buffer returned to ensure that the bytes are never\n+    /// returned twice.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if a read error is\n+    /// encountered.\n+    fn fill<'a>(&'a mut self) -> &'a [u8];\n+\n+    /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n+    /// so they should no longer be returned in calls to `fill` or `read`.\n+    fn consume(&mut self, amt: uint);\n+\n+    /// Reads the next line of input, interpreted as a sequence of utf-8\n+    /// encoded unicode codepoints. If a newline is encountered, then the\n+    /// newline is contained in the returned string.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if a read error is\n+    /// encountered. The task will also fail if sequence of bytes leading up to\n+    /// the newline character are not valid utf-8.\n+    fn read_line(&mut self) -> Option<~str> {\n+        self.read_until('\\n' as u8).map(str::from_utf8_owned)\n+    }\n+\n+    /// Reads a sequence of bytes leading up to a specified delimeter. Once the\n+    /// specified byte is encountered, reading ceases and the bytes up to and\n+    /// including the delimiter are returned.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if a read error is\n+    /// encountered.\n+    fn read_until(&mut self, byte: u8) -> Option<~[u8]> {\n+        let mut res = ~[];\n+        let mut used;\n+        loop {\n+            {\n+                let available = self.fill();\n+                match available.iter().position(|&b| b == byte) {\n+                    Some(i) => {\n+                        res.push_all(available.slice_to(i + 1));\n+                        used = i + 1;\n+                        break\n+                    }\n+                    None => {\n+                        res.push_all(available);\n+                        used = available.len();\n+                    }\n+                }\n+            }\n+            if used == 0 {\n+                break\n+            }\n+            self.consume(used);\n+        }\n+        self.consume(used);\n+        return if res.len() == 0 {None} else {Some(res)};\n+    }\n+\n+    /// Reads the next utf8-encoded character from the underlying stream.\n+    ///\n+    /// This will return `None` if the following sequence of bytes in the\n+    /// stream are not a valid utf8-sequence, or if an I/O error is encountered.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if a read error is\n+    /// encountered.\n+    fn read_char(&mut self) -> Option<char> {\n+        let width = {\n+            let available = self.fill();\n+            if available.len() == 0 { return None } // read error\n+            str::utf8_char_width(available[0])\n+        };\n+        if width == 0 { return None } // not uf8\n+        let mut buf = [0, ..4];\n+        match self.read(buf.mut_slice_to(width)) {\n+            Some(n) if n == width => {}\n+            Some(*) | None => return None // read error\n+        }\n+        match str::from_utf8_slice_opt(buf.slice_to(width)) {\n+            Some(s) => Some(s.char_at(0)),\n+            None => None\n+        }\n+    }\n+}\n+\n pub enum SeekStyle {\n     /// Seek from the beginning of the stream\n     SeekSet,"}, {"sha": "60fe21bb8d2b68a56535ded399c926c585006c44", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=66df86ae98364bd6bc29463dc52d5c9c7d2fdd7a", "patch": "@@ -67,7 +67,7 @@ pub use num::{Orderable, Signed, Unsigned, Round};\n pub use num::{Primitive, Int, Float, ToStrRadix, ToPrimitive, FromPrimitive};\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;\n-pub use io::{Writer, Reader, Seek};\n+pub use io::{Buffer, Writer, Reader, Seek};\n pub use send_str::{SendStr, SendStrOwned, SendStrStatic, IntoSendStr};\n pub use str::{Str, StrVector, StrSlice, OwnedStr};\n pub use to_bytes::IterBytes;"}]}