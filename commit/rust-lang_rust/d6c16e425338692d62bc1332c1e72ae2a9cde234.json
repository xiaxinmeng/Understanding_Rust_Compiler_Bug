{"sha": "d6c16e425338692d62bc1332c1e72ae2a9cde234", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YzE2ZTQyNTMzODY5MmQ2MmJjMTMzMmMxZTcyYWUyYTljZGUyMzQ=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-14T22:59:58Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-15T16:21:12Z"}, "message": "Make all rustdoc functions and structs crate-private\n\nThis gives warnings about dead code.", "tree": {"sha": "40a7d4ff465d3799cfee802c8830134438da9337", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40a7d4ff465d3799cfee802c8830134438da9337"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6c16e425338692d62bc1332c1e72ae2a9cde234", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6c16e425338692d62bc1332c1e72ae2a9cde234", "html_url": "https://github.com/rust-lang/rust/commit/d6c16e425338692d62bc1332c1e72ae2a9cde234", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6c16e425338692d62bc1332c1e72ae2a9cde234/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb", "html_url": "https://github.com/rust-lang/rust/commit/5fab31e5ddf5f2613bf57a0a7286dc6f5887e1cb"}], "stats": {"total": 1854, "additions": 927, "deletions": 927}, "files": [{"sha": "ff996b2a9254e5ae51c6f5ac97962a14cf89051a", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -20,21 +20,21 @@ struct RegionDeps<'tcx> {\n     smaller: FxHashSet<RegionTarget<'tcx>>,\n }\n \n-pub struct AutoTraitFinder<'a, 'tcx> {\n-    pub cx: &'a core::DocContext<'tcx>,\n-    pub f: auto_trait::AutoTraitFinder<'tcx>,\n+crate struct AutoTraitFinder<'a, 'tcx> {\n+    crate cx: &'a core::DocContext<'tcx>,\n+    crate f: auto_trait::AutoTraitFinder<'tcx>,\n }\n \n impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n-    pub fn new(cx: &'a core::DocContext<'tcx>) -> Self {\n+    crate fn new(cx: &'a core::DocContext<'tcx>) -> Self {\n         let f = auto_trait::AutoTraitFinder::new(cx.tcx);\n \n         AutoTraitFinder { cx, f }\n     }\n \n     // FIXME(eddyb) figure out a better way to pass information about\n     // parametrization of `ty` than `param_env_def_id`.\n-    pub fn get_auto_trait_impls(&self, ty: Ty<'tcx>, param_env_def_id: DefId) -> Vec<Item> {\n+    crate fn get_auto_trait_impls(&self, ty: Ty<'tcx>, param_env_def_id: DefId) -> Vec<Item> {\n         let param_env = self.cx.tcx.param_env(param_env_def_id);\n \n         debug!(\"get_auto_trait_impls({:?})\", ty);"}, {"sha": "5721927d0ec8d58720e12a6938bdef4510530d55", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -9,18 +9,18 @@ use rustc_span::DUMMY_SP;\n \n use super::*;\n \n-pub struct BlanketImplFinder<'a, 'tcx> {\n-    pub cx: &'a core::DocContext<'tcx>,\n+crate struct BlanketImplFinder<'a, 'tcx> {\n+    crate cx: &'a core::DocContext<'tcx>,\n }\n \n impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n-    pub fn new(cx: &'a core::DocContext<'tcx>) -> Self {\n+    crate fn new(cx: &'a core::DocContext<'tcx>) -> Self {\n         BlanketImplFinder { cx }\n     }\n \n     // FIXME(eddyb) figure out a better way to pass information about\n     // parametrization of `ty` than `param_env_def_id`.\n-    pub fn get_blanket_impls(&self, ty: Ty<'tcx>, param_env_def_id: DefId) -> Vec<Item> {\n+    crate fn get_blanket_impls(&self, ty: Ty<'tcx>, param_env_def_id: DefId) -> Vec<Item> {\n         let param_env = self.cx.tcx.param_env(param_env_def_id);\n \n         debug!(\"get_blanket_impls({:?})\", ty);"}, {"sha": "2f169d1d3f3a52b47d3a3c84f2211c90ed1616fb", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -20,7 +20,7 @@ use crate::html::escape::Escape;\n mod tests;\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum Cfg {\n+crate enum Cfg {\n     /// Accepts all configurations.\n     True,\n     /// Denies all configurations.\n@@ -36,9 +36,9 @@ pub enum Cfg {\n }\n \n #[derive(PartialEq, Debug)]\n-pub struct InvalidCfgError {\n-    pub msg: &'static str,\n-    pub span: Span,\n+crate struct InvalidCfgError {\n+    crate msg: &'static str,\n+    crate span: Span,\n }\n \n impl Cfg {\n@@ -59,7 +59,7 @@ impl Cfg {\n     ///\n     /// If the content is not properly formatted, it will return an error indicating what and where\n     /// the error is.\n-    pub fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n+    crate fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n         let name = match cfg.ident() {\n             Some(ident) => ident.name,\n             None => {\n@@ -102,7 +102,7 @@ impl Cfg {\n     ///\n     /// Equivalent to `attr::cfg_matches`.\n     // FIXME: Actually make use of `features`.\n-    pub fn matches(&self, parse_sess: &ParseSess, features: Option<&Features>) -> bool {\n+    crate fn matches(&self, parse_sess: &ParseSess, features: Option<&Features>) -> bool {\n         match *self {\n             Cfg::False => false,\n             Cfg::True => true,"}, {"sha": "daca4f8a9332f4f790aae3b8d0fddf9a8a570570", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -3,11 +3,11 @@\n \n mod auto_trait;\n mod blanket_impl;\n-pub mod cfg;\n-pub mod inline;\n+crate mod cfg;\n+crate mod inline;\n mod simplify;\n-pub mod types;\n-pub mod utils;\n+crate mod types;\n+crate mod utils;\n \n use rustc_ast as ast;\n use rustc_attr as attr;\n@@ -39,18 +39,18 @@ use crate::doctree;\n \n use utils::*;\n \n-pub use utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n+crate use utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n \n-pub use self::types::FnRetTy::*;\n-pub use self::types::ItemKind::*;\n-pub use self::types::SelfTy::*;\n-pub use self::types::Type::*;\n-pub use self::types::Visibility::{Inherited, Public};\n-pub use self::types::*;\n+crate use self::types::FnRetTy::*;\n+crate use self::types::ItemKind::*;\n+crate use self::types::SelfTy::*;\n+crate use self::types::Type::*;\n+crate use self::types::Visibility::{Inherited, Public};\n+crate use self::types::*;\n \n const FN_OUTPUT_NAME: &str = \"Output\";\n \n-pub trait Clean<T> {\n+crate trait Clean<T> {\n     fn clean(&self, cx: &DocContext<'_>) -> T;\n }\n "}, {"sha": "121c9d2bc4cd6e06b8fa14769ed7672b8c4b44a1", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -21,7 +21,7 @@ use crate::clean::GenericArgs as PP;\n use crate::clean::WherePredicate as WP;\n use crate::core::DocContext;\n \n-pub fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n+crate fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     // First, partition the where clause into its separate components\n     let mut params: BTreeMap<_, Vec<_>> = BTreeMap::new();\n     let mut lifetimes = Vec::new();\n@@ -74,7 +74,7 @@ pub fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     clauses\n }\n \n-pub fn merge_bounds(\n+crate fn merge_bounds(\n     cx: &clean::DocContext<'_>,\n     bounds: &mut Vec<clean::GenericBound>,\n     trait_did: DefId,"}, {"sha": "aff62667176a0049b6263948e23b1ab991e1fa4e", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 274, "deletions": 274, "changes": 548, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -45,47 +45,47 @@ use self::ItemKind::*;\n use self::SelfTy::*;\n use self::Type::*;\n \n-thread_local!(pub static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = Default::default());\n+thread_local!(crate static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = Default::default());\n \n #[derive(Clone, Debug)]\n-pub struct Crate {\n-    pub name: String,\n-    pub version: Option<String>,\n-    pub src: FileName,\n-    pub module: Option<Item>,\n-    pub externs: Vec<(CrateNum, ExternalCrate)>,\n-    pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n+crate struct Crate {\n+    crate name: String,\n+    crate version: Option<String>,\n+    crate src: FileName,\n+    crate module: Option<Item>,\n+    crate externs: Vec<(CrateNum, ExternalCrate)>,\n+    crate primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n     // These are later on moved into `CACHEKEY`, leaving the map empty.\n     // Only here so that they can be filtered through the rustdoc passes.\n-    pub external_traits: Rc<RefCell<FxHashMap<DefId, Trait>>>,\n-    pub masked_crates: FxHashSet<CrateNum>,\n-    pub collapsed: bool,\n+    crate external_traits: Rc<RefCell<FxHashMap<DefId, Trait>>>,\n+    crate masked_crates: FxHashSet<CrateNum>,\n+    crate collapsed: bool,\n }\n \n #[derive(Clone, Debug)]\n-pub struct ExternalCrate {\n-    pub name: String,\n-    pub src: FileName,\n-    pub attrs: Attributes,\n-    pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n-    pub keywords: Vec<(DefId, String, Attributes)>,\n+crate struct ExternalCrate {\n+    crate name: String,\n+    crate src: FileName,\n+    crate attrs: Attributes,\n+    crate primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n+    crate keywords: Vec<(DefId, String, Attributes)>,\n }\n \n /// Anything with a source location and set of attributes and, optionally, a\n /// name. That is, anything that can be documented. This doesn't correspond\n /// directly to the AST's concept of an item; it's a strict superset.\n #[derive(Clone)]\n-pub struct Item {\n+crate struct Item {\n     /// Stringified span\n-    pub source: Span,\n+    crate source: Span,\n     /// Not everything has a name. E.g., impls\n-    pub name: Option<String>,\n-    pub attrs: Attributes,\n-    pub kind: ItemKind,\n-    pub visibility: Visibility,\n-    pub def_id: DefId,\n-    pub stability: Option<Stability>,\n-    pub deprecation: Option<Deprecation>,\n+    crate name: Option<String>,\n+    crate attrs: Attributes,\n+    crate visibility: Visibility,\n+    crate kind: ItemKind,\n+    crate def_id: DefId,\n+    crate stability: Option<Stability>,\n+    crate deprecation: Option<Deprecation>,\n }\n \n impl fmt::Debug for Item {\n@@ -108,80 +108,80 @@ impl fmt::Debug for Item {\n impl Item {\n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n-    pub fn doc_value(&self) -> Option<&str> {\n+    crate fn doc_value(&self) -> Option<&str> {\n         self.attrs.doc_value()\n     }\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n     /// with newlines.\n-    pub fn collapsed_doc_value(&self) -> Option<String> {\n+    crate fn collapsed_doc_value(&self) -> Option<String> {\n         self.attrs.collapsed_doc_value()\n     }\n \n-    pub fn links(&self) -> Vec<RenderedLink> {\n+    crate fn links(&self) -> Vec<RenderedLink> {\n         self.attrs.links(&self.def_id.krate)\n     }\n \n-    pub fn is_crate(&self) -> bool {\n+    crate fn is_crate(&self) -> bool {\n         match self.kind {\n             StrippedItem(box ModuleItem(Module { is_crate: true, .. }))\n             | ModuleItem(Module { is_crate: true, .. }) => true,\n             _ => false,\n         }\n     }\n-    pub fn is_mod(&self) -> bool {\n+    crate fn is_mod(&self) -> bool {\n         self.type_() == ItemType::Module\n     }\n-    pub fn is_trait(&self) -> bool {\n+    crate fn is_trait(&self) -> bool {\n         self.type_() == ItemType::Trait\n     }\n-    pub fn is_struct(&self) -> bool {\n+    crate fn is_struct(&self) -> bool {\n         self.type_() == ItemType::Struct\n     }\n-    pub fn is_enum(&self) -> bool {\n+    crate fn is_enum(&self) -> bool {\n         self.type_() == ItemType::Enum\n     }\n-    pub fn is_variant(&self) -> bool {\n+    crate fn is_variant(&self) -> bool {\n         self.type_() == ItemType::Variant\n     }\n-    pub fn is_associated_type(&self) -> bool {\n+    crate fn is_associated_type(&self) -> bool {\n         self.type_() == ItemType::AssocType\n     }\n-    pub fn is_associated_const(&self) -> bool {\n+    crate fn is_associated_const(&self) -> bool {\n         self.type_() == ItemType::AssocConst\n     }\n-    pub fn is_method(&self) -> bool {\n+    crate fn is_method(&self) -> bool {\n         self.type_() == ItemType::Method\n     }\n-    pub fn is_ty_method(&self) -> bool {\n+    crate fn is_ty_method(&self) -> bool {\n         self.type_() == ItemType::TyMethod\n     }\n-    pub fn is_typedef(&self) -> bool {\n+    crate fn is_typedef(&self) -> bool {\n         self.type_() == ItemType::Typedef\n     }\n-    pub fn is_primitive(&self) -> bool {\n+    crate fn is_primitive(&self) -> bool {\n         self.type_() == ItemType::Primitive\n     }\n-    pub fn is_union(&self) -> bool {\n+    crate fn is_union(&self) -> bool {\n         self.type_() == ItemType::Union\n     }\n-    pub fn is_import(&self) -> bool {\n+    crate fn is_import(&self) -> bool {\n         self.type_() == ItemType::Import\n     }\n-    pub fn is_extern_crate(&self) -> bool {\n+    crate fn is_extern_crate(&self) -> bool {\n         self.type_() == ItemType::ExternCrate\n     }\n-    pub fn is_keyword(&self) -> bool {\n+    crate fn is_keyword(&self) -> bool {\n         self.type_() == ItemType::Keyword\n     }\n-    pub fn is_stripped(&self) -> bool {\n+    crate fn is_stripped(&self) -> bool {\n         match self.kind {\n             StrippedItem(..) => true,\n             ImportItem(ref i) => !i.should_be_displayed,\n             _ => false,\n         }\n     }\n-    pub fn has_stripped_fields(&self) -> Option<bool> {\n+    crate fn has_stripped_fields(&self) -> Option<bool> {\n         match self.kind {\n             StructItem(ref _struct) => Some(_struct.fields_stripped),\n             UnionItem(ref union) => Some(union.fields_stripped),\n@@ -192,7 +192,7 @@ impl Item {\n         }\n     }\n \n-    pub fn stability_class(&self) -> Option<String> {\n+    crate fn stability_class(&self) -> Option<String> {\n         self.stability.as_ref().and_then(|ref s| {\n             let mut classes = Vec::with_capacity(2);\n \n@@ -209,23 +209,23 @@ impl Item {\n         })\n     }\n \n-    pub fn stable_since(&self) -> Option<SymbolStr> {\n+    crate fn stable_since(&self) -> Option<SymbolStr> {\n         match self.stability?.level {\n             StabilityLevel::Stable { since, .. } => Some(since.as_str()),\n             StabilityLevel::Unstable { .. } => None,\n         }\n     }\n \n-    pub fn is_non_exhaustive(&self) -> bool {\n+    crate fn is_non_exhaustive(&self) -> bool {\n         self.attrs.other_attrs.iter().any(|a| a.has_name(sym::non_exhaustive))\n     }\n \n     /// Returns a documentation-level item type from the item.\n-    pub fn type_(&self) -> ItemType {\n+    crate fn type_(&self) -> ItemType {\n         ItemType::from(self)\n     }\n \n-    pub fn is_default(&self) -> bool {\n+    crate fn is_default(&self) -> bool {\n         match self.kind {\n             ItemKind::MethodItem(ref meth) => {\n                 if let Some(defaultness) = meth.defaultness {\n@@ -239,15 +239,15 @@ impl Item {\n     }\n \n     /// See comments on next_def_id\n-    pub fn is_fake(&self) -> bool {\n+    crate fn is_fake(&self) -> bool {\n         MAX_DEF_ID.with(|m| {\n             m.borrow().get(&self.def_id.krate).map(|id| self.def_id >= *id).unwrap_or(false)\n         })\n     }\n }\n \n #[derive(Clone, Debug)]\n-pub enum ItemKind {\n+crate enum ItemKind {\n     ExternCrateItem(String, Option<String>),\n     ImportItem(Import),\n     StructItem(Struct),\n@@ -286,14 +286,14 @@ pub enum ItemKind {\n }\n \n impl ItemKind {\n-    pub fn is_type_alias(&self) -> bool {\n+    crate fn is_type_alias(&self) -> bool {\n         match *self {\n             ItemKind::TypedefItem(_, _) | ItemKind::AssocTypeItem(_, _) => true,\n             _ => false,\n         }\n     }\n \n-    pub fn as_assoc_kind(&self) -> Option<AssocKind> {\n+    crate fn as_assoc_kind(&self) -> Option<AssocKind> {\n         match *self {\n             ItemKind::AssocConstItem(..) => Some(AssocKind::Const),\n             ItemKind::AssocTypeItem(..) => Some(AssocKind::Type),\n@@ -304,12 +304,12 @@ impl ItemKind {\n }\n \n #[derive(Clone, Debug)]\n-pub struct Module {\n-    pub items: Vec<Item>,\n-    pub is_crate: bool,\n+crate struct Module {\n+    crate items: Vec<Item>,\n+    crate is_crate: bool,\n }\n \n-pub struct ListAttributesIter<'a> {\n+crate struct ListAttributesIter<'a> {\n     attrs: slice::Iter<'a, ast::Attribute>,\n     current_list: vec::IntoIter<ast::NestedMetaItem>,\n     name: Symbol,\n@@ -343,7 +343,7 @@ impl<'a> Iterator for ListAttributesIter<'a> {\n     }\n }\n \n-pub trait AttributesExt {\n+crate trait AttributesExt {\n     /// Finds an attribute as List and returns the list of attributes nested inside.\n     fn lists(&self, name: Symbol) -> ListAttributesIter<'_>;\n }\n@@ -354,7 +354,7 @@ impl AttributesExt for [ast::Attribute] {\n     }\n }\n \n-pub trait NestedAttributesExt {\n+crate trait NestedAttributesExt {\n     /// Returns `true` if the attribute list contains a specific `Word`\n     fn has_word(self, word: Symbol) -> bool;\n }\n@@ -374,20 +374,20 @@ impl<I: IntoIterator<Item = ast::NestedMetaItem>> NestedAttributesExt for I {\n /// information can be given when a doctest fails. Sugared doc comments and \"raw\" doc comments are\n /// kept separate because of issue #42760.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct DocFragment {\n-    pub line: usize,\n-    pub span: rustc_span::Span,\n+crate struct DocFragment {\n+    crate line: usize,\n+    crate span: rustc_span::Span,\n     /// The module this doc-comment came from.\n     ///\n     /// This allows distinguishing between the original documentation and a pub re-export.\n     /// If it is `None`, the item was not re-exported.\n-    pub parent_module: Option<DefId>,\n-    pub doc: String,\n-    pub kind: DocFragmentKind,\n+    crate parent_module: Option<DefId>,\n+    crate doc: String,\n+    crate kind: DocFragmentKind,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum DocFragmentKind {\n+crate enum DocFragmentKind {\n     /// A doc fragment created from a `///` or `//!` doc comment.\n     SugaredDoc,\n     /// A doc fragment created from a \"raw\" `#[doc=\"\"]` attribute.\n@@ -413,21 +413,21 @@ impl<'a> FromIterator<&'a DocFragment> for String {\n }\n \n #[derive(Clone, Debug, Default)]\n-pub struct Attributes {\n-    pub doc_strings: Vec<DocFragment>,\n-    pub other_attrs: Vec<ast::Attribute>,\n-    pub cfg: Option<Arc<Cfg>>,\n-    pub span: Option<rustc_span::Span>,\n+crate struct Attributes {\n+    crate doc_strings: Vec<DocFragment>,\n+    crate other_attrs: Vec<ast::Attribute>,\n+    crate cfg: Option<Arc<Cfg>>,\n+    crate span: Option<rustc_span::Span>,\n     /// map from Rust paths to resolved defs and potential URL fragments\n-    pub links: Vec<ItemLink>,\n-    pub inner_docs: bool,\n+    crate links: Vec<ItemLink>,\n+    crate inner_docs: bool,\n }\n \n #[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\n /// A link that has not yet been rendered.\n ///\n /// This link will be turned into a rendered link by [`Attributes::links`]\n-pub struct ItemLink {\n+crate struct ItemLink {\n     /// The original link written in the markdown\n     pub(crate) link: String,\n     /// The link text displayed in the HTML.\n@@ -440,7 +440,7 @@ pub struct ItemLink {\n     pub(crate) fragment: Option<String>,\n }\n \n-pub struct RenderedLink {\n+crate struct RenderedLink {\n     /// The text the link was original written as.\n     ///\n     /// This could potentially include disambiguators and backticks.\n@@ -453,7 +453,7 @@ pub struct RenderedLink {\n \n impl Attributes {\n     /// Extracts the content from an attribute `#[doc(cfg(content))]`.\n-    pub fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n+    crate fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n         use rustc_ast::NestedMetaItem::MetaItem;\n \n         if let ast::MetaItemKind::List(ref nmis) = mi.kind {\n@@ -478,7 +478,7 @@ impl Attributes {\n     /// Reads a `MetaItem` from within an attribute, looks for whether it is a\n     /// `#[doc(include=\"file\")]`, and returns the filename and contents of the file as loaded from\n     /// its expansion.\n-    pub fn extract_include(mi: &ast::MetaItem) -> Option<(String, String)> {\n+    crate fn extract_include(mi: &ast::MetaItem) -> Option<(String, String)> {\n         mi.meta_item_list().and_then(|list| {\n             for meta in list {\n                 if meta.has_name(sym::include) {\n@@ -514,7 +514,7 @@ impl Attributes {\n         })\n     }\n \n-    pub fn has_doc_flag(&self, flag: Symbol) -> bool {\n+    crate fn has_doc_flag(&self, flag: Symbol) -> bool {\n         for attr in &self.other_attrs {\n             if !attr.has_name(sym::doc) {\n                 continue;\n@@ -530,7 +530,7 @@ impl Attributes {\n         false\n     }\n \n-    pub fn from_ast(\n+    crate fn from_ast(\n         diagnostic: &::rustc_errors::Handler,\n         attrs: &[ast::Attribute],\n         additional_attrs: Option<(&[ast::Attribute], DefId)>,\n@@ -634,20 +634,20 @@ impl Attributes {\n \n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n-    pub fn doc_value(&self) -> Option<&str> {\n+    crate fn doc_value(&self) -> Option<&str> {\n         self.doc_strings.first().map(|s| s.doc.as_str())\n     }\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n     /// with newlines.\n-    pub fn collapsed_doc_value(&self) -> Option<String> {\n+    crate fn collapsed_doc_value(&self) -> Option<String> {\n         if !self.doc_strings.is_empty() { Some(self.doc_strings.iter().collect()) } else { None }\n     }\n \n     /// Gets links as a vector\n     ///\n     /// Cache must be populated before call\n-    pub fn links(&self, krate: &CrateNum) -> Vec<RenderedLink> {\n+    crate fn links(&self, krate: &CrateNum) -> Vec<RenderedLink> {\n         use crate::html::format::href;\n         use crate::html::render::CURRENT_DEPTH;\n \n@@ -711,7 +711,7 @@ impl Attributes {\n             .collect()\n     }\n \n-    pub fn get_doc_aliases(&self) -> FxHashSet<String> {\n+    crate fn get_doc_aliases(&self) -> FxHashSet<String> {\n         self.other_attrs\n             .lists(sym::doc)\n             .filter(|a| a.has_name(sym::alias))\n@@ -756,13 +756,13 @@ impl AttributesExt for Attributes {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericBound {\n+crate enum GenericBound {\n     TraitBound(PolyTrait, hir::TraitBoundModifier),\n     Outlives(Lifetime),\n }\n \n impl GenericBound {\n-    pub fn maybe_sized(cx: &DocContext<'_>) -> GenericBound {\n+    crate fn maybe_sized(cx: &DocContext<'_>) -> GenericBound {\n         let did = cx.tcx.require_lang_item(LangItem::Sized, None);\n         let empty = cx.tcx.intern_substs(&[]);\n         let path = external_path(cx, cx.tcx.item_name(did), Some(did), false, vec![], empty);\n@@ -776,7 +776,7 @@ impl GenericBound {\n         )\n     }\n \n-    pub fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n+    crate fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n         use rustc_hir::TraitBoundModifier as TBM;\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n             if trait_.def_id() == cx.tcx.lang_items().sized_trait() {\n@@ -786,14 +786,14 @@ impl GenericBound {\n         false\n     }\n \n-    pub fn get_poly_trait(&self) -> Option<PolyTrait> {\n+    crate fn get_poly_trait(&self) -> Option<PolyTrait> {\n         if let GenericBound::TraitBound(ref p, _) = *self {\n             return Some(p.clone());\n         }\n         None\n     }\n \n-    pub fn get_trait_type(&self) -> Option<Type> {\n+    crate fn get_trait_type(&self) -> Option<Type> {\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, _) = *self {\n             Some(trait_.clone())\n         } else {\n@@ -803,33 +803,33 @@ impl GenericBound {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Lifetime(pub String);\n+crate struct Lifetime(pub String);\n \n impl Lifetime {\n-    pub fn get_ref<'a>(&'a self) -> &'a str {\n+    crate fn get_ref<'a>(&'a self) -> &'a str {\n         let Lifetime(ref s) = *self;\n         let s: &'a str = s;\n         s\n     }\n \n-    pub fn statik() -> Lifetime {\n+    crate fn statik() -> Lifetime {\n         Lifetime(\"'static\".to_string())\n     }\n \n-    pub fn elided() -> Lifetime {\n+    crate fn elided() -> Lifetime {\n         Lifetime(\"'_\".to_string())\n     }\n }\n \n #[derive(Clone, Debug)]\n-pub enum WherePredicate {\n+crate enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<GenericBound> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<GenericBound> },\n     EqPredicate { lhs: Type, rhs: Type },\n }\n \n impl WherePredicate {\n-    pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n+    crate fn get_bounds(&self) -> Option<&[GenericBound]> {\n         match *self {\n             WherePredicate::BoundPredicate { ref bounds, .. } => Some(bounds),\n             WherePredicate::RegionPredicate { ref bounds, .. } => Some(bounds),\n@@ -839,7 +839,7 @@ impl WherePredicate {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericParamDefKind {\n+crate enum GenericParamDefKind {\n     Lifetime,\n     Type {\n         did: DefId,\n@@ -854,7 +854,7 @@ pub enum GenericParamDefKind {\n }\n \n impl GenericParamDefKind {\n-    pub fn is_type(&self) -> bool {\n+    crate fn is_type(&self) -> bool {\n         match *self {\n             GenericParamDefKind::Type { .. } => true,\n             _ => false,\n@@ -864,7 +864,7 @@ impl GenericParamDefKind {\n     // FIXME(eddyb) this either returns the default of a type parameter, or the\n     // type of a `const` parameter. It seems that the intention is to *visit*\n     // any embedded types, but `get_type` seems to be the wrong name for that.\n-    pub fn get_type(&self) -> Option<Type> {\n+    crate fn get_type(&self) -> Option<Type> {\n         match self {\n             GenericParamDefKind::Type { default, .. } => default.clone(),\n             GenericParamDefKind::Const { ty, .. } => Some(ty.clone()),\n@@ -874,28 +874,28 @@ impl GenericParamDefKind {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct GenericParamDef {\n-    pub name: String,\n-    pub kind: GenericParamDefKind,\n+crate struct GenericParamDef {\n+    crate name: String,\n+    crate kind: GenericParamDefKind,\n }\n \n impl GenericParamDef {\n-    pub fn is_synthetic_type_param(&self) -> bool {\n+    crate fn is_synthetic_type_param(&self) -> bool {\n         match self.kind {\n             GenericParamDefKind::Lifetime | GenericParamDefKind::Const { .. } => false,\n             GenericParamDefKind::Type { ref synthetic, .. } => synthetic.is_some(),\n         }\n     }\n \n-    pub fn is_type(&self) -> bool {\n+    crate fn is_type(&self) -> bool {\n         self.kind.is_type()\n     }\n \n-    pub fn get_type(&self) -> Option<Type> {\n+    crate fn get_type(&self) -> Option<Type> {\n         self.kind.get_type()\n     }\n \n-    pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n+    crate fn get_bounds(&self) -> Option<&[GenericBound]> {\n         match self.kind {\n             GenericParamDefKind::Type { ref bounds, .. } => Some(bounds),\n             _ => None,\n@@ -905,49 +905,49 @@ impl GenericParamDef {\n \n // maybe use a Generic enum and use Vec<Generic>?\n #[derive(Clone, Debug, Default)]\n-pub struct Generics {\n-    pub params: Vec<GenericParamDef>,\n-    pub where_predicates: Vec<WherePredicate>,\n+crate struct Generics {\n+    crate params: Vec<GenericParamDef>,\n+    crate where_predicates: Vec<WherePredicate>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Method {\n-    pub generics: Generics,\n-    pub decl: FnDecl,\n-    pub header: hir::FnHeader,\n-    pub defaultness: Option<hir::Defaultness>,\n-    pub all_types: Vec<(Type, TypeKind)>,\n-    pub ret_types: Vec<(Type, TypeKind)>,\n+crate struct Method {\n+    crate generics: Generics,\n+    crate decl: FnDecl,\n+    crate header: hir::FnHeader,\n+    crate defaultness: Option<hir::Defaultness>,\n+    crate all_types: Vec<(Type, TypeKind)>,\n+    crate ret_types: Vec<(Type, TypeKind)>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct TyMethod {\n-    pub header: hir::FnHeader,\n-    pub decl: FnDecl,\n-    pub generics: Generics,\n-    pub all_types: Vec<(Type, TypeKind)>,\n-    pub ret_types: Vec<(Type, TypeKind)>,\n+crate struct TyMethod {\n+    crate header: hir::FnHeader,\n+    crate decl: FnDecl,\n+    crate generics: Generics,\n+    crate all_types: Vec<(Type, TypeKind)>,\n+    crate ret_types: Vec<(Type, TypeKind)>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Function {\n-    pub decl: FnDecl,\n-    pub generics: Generics,\n-    pub header: hir::FnHeader,\n-    pub all_types: Vec<(Type, TypeKind)>,\n-    pub ret_types: Vec<(Type, TypeKind)>,\n+crate struct Function {\n+    crate decl: FnDecl,\n+    crate generics: Generics,\n+    crate header: hir::FnHeader,\n+    crate all_types: Vec<(Type, TypeKind)>,\n+    crate ret_types: Vec<(Type, TypeKind)>,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct FnDecl {\n-    pub inputs: Arguments,\n-    pub output: FnRetTy,\n-    pub c_variadic: bool,\n-    pub attrs: Attributes,\n+crate struct FnDecl {\n+    crate inputs: Arguments,\n+    crate output: FnRetTy,\n+    crate c_variadic: bool,\n+    crate attrs: Attributes,\n }\n \n impl FnDecl {\n-    pub fn self_type(&self) -> Option<SelfTy> {\n+    crate fn self_type(&self) -> Option<SelfTy> {\n         self.inputs.values.get(0).and_then(|v| v.to_self())\n     }\n \n@@ -960,7 +960,7 @@ impl FnDecl {\n     ///\n     /// This function will panic if the return type does not match the expected sugaring for async\n     /// functions.\n-    pub fn sugared_async_return_type(&self) -> FnRetTy {\n+    crate fn sugared_async_return_type(&self) -> FnRetTy {\n         match &self.output {\n             FnRetTy::Return(Type::ImplTrait(bounds)) => match &bounds[0] {\n                 GenericBound::TraitBound(PolyTrait { trait_, .. }, ..) => {\n@@ -975,25 +975,25 @@ impl FnDecl {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Arguments {\n-    pub values: Vec<Argument>,\n+crate struct Arguments {\n+    crate values: Vec<Argument>,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Argument {\n-    pub type_: Type,\n-    pub name: String,\n+crate struct Argument {\n+    crate type_: Type,\n+    crate name: String,\n }\n \n #[derive(Clone, PartialEq, Debug)]\n-pub enum SelfTy {\n+crate enum SelfTy {\n     SelfValue,\n     SelfBorrowed(Option<Lifetime>, Mutability),\n     SelfExplicit(Type),\n }\n \n impl Argument {\n-    pub fn to_self(&self) -> Option<SelfTy> {\n+    crate fn to_self(&self) -> Option<SelfTy> {\n         if self.name != \"self\" {\n             return None;\n         }\n@@ -1010,7 +1010,7 @@ impl Argument {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum FnRetTy {\n+crate enum FnRetTy {\n     Return(Type),\n     DefaultReturn,\n }\n@@ -1025,34 +1025,34 @@ impl GetDefId for FnRetTy {\n }\n \n #[derive(Clone, Debug)]\n-pub struct Trait {\n-    pub auto: bool,\n-    pub unsafety: hir::Unsafety,\n-    pub items: Vec<Item>,\n-    pub generics: Generics,\n-    pub bounds: Vec<GenericBound>,\n-    pub is_spotlight: bool,\n-    pub is_auto: bool,\n+crate struct Trait {\n+    crate auto: bool,\n+    crate unsafety: hir::Unsafety,\n+    crate items: Vec<Item>,\n+    crate generics: Generics,\n+    crate bounds: Vec<GenericBound>,\n+    crate is_spotlight: bool,\n+    crate is_auto: bool,\n }\n \n #[derive(Clone, Debug)]\n-pub struct TraitAlias {\n-    pub generics: Generics,\n-    pub bounds: Vec<GenericBound>,\n+crate struct TraitAlias {\n+    crate generics: Generics,\n+    crate bounds: Vec<GenericBound>,\n }\n \n /// A trait reference, which may have higher ranked lifetimes.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct PolyTrait {\n-    pub trait_: Type,\n-    pub generic_params: Vec<GenericParamDef>,\n+crate struct PolyTrait {\n+    crate trait_: Type,\n+    crate generic_params: Vec<GenericParamDef>,\n }\n \n /// A representation of a type suitable for hyperlinking purposes. Ideally, one can get the original\n /// type out of the AST/`TyCtxt` given one of these, if more information is needed. Most\n /// importantly, it does not preserve mutability or boxes.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum Type {\n+crate enum Type {\n     /// Structs/enums/traits (most that would be an `hir::TyKind::Path`).\n     ResolvedPath {\n         path: Path,\n@@ -1095,7 +1095,7 @@ pub enum Type {\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Copy, Debug)]\n-pub enum PrimitiveType {\n+crate enum PrimitiveType {\n     Isize,\n     I8,\n     I16,\n@@ -1124,7 +1124,7 @@ pub enum PrimitiveType {\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Copy, Debug)]\n-pub enum TypeKind {\n+crate enum TypeKind {\n     Enum,\n     Function,\n     Module,\n@@ -1141,7 +1141,7 @@ pub enum TypeKind {\n     TraitAlias,\n }\n \n-pub trait GetDefId {\n+crate trait GetDefId {\n     fn def_id(&self) -> Option<DefId>;\n }\n \n@@ -1152,7 +1152,7 @@ impl<T: GetDefId> GetDefId for Option<T> {\n }\n \n impl Type {\n-    pub fn primitive_type(&self) -> Option<PrimitiveType> {\n+    crate fn primitive_type(&self) -> Option<PrimitiveType> {\n         match *self {\n             Primitive(p) | BorrowedRef { type_: box Primitive(p), .. } => Some(p),\n             Slice(..) | BorrowedRef { type_: box Slice(..), .. } => Some(PrimitiveType::Slice),\n@@ -1172,21 +1172,21 @@ impl Type {\n         }\n     }\n \n-    pub fn is_generic(&self) -> bool {\n+    crate fn is_generic(&self) -> bool {\n         match *self {\n             ResolvedPath { is_generic, .. } => is_generic,\n             _ => false,\n         }\n     }\n \n-    pub fn is_self_type(&self) -> bool {\n+    crate fn is_self_type(&self) -> bool {\n         match *self {\n             Generic(ref name) => name == \"Self\",\n             _ => false,\n         }\n     }\n \n-    pub fn generics(&self) -> Option<Vec<Type>> {\n+    crate fn generics(&self) -> Option<Vec<Type>> {\n         match *self {\n             ResolvedPath { ref path, .. } => path.segments.last().and_then(|seg| {\n                 if let GenericArgs::AngleBracketed { ref args, .. } = seg.args {\n@@ -1206,7 +1206,7 @@ impl Type {\n         }\n     }\n \n-    pub fn bindings(&self) -> Option<&[TypeBinding]> {\n+    crate fn bindings(&self) -> Option<&[TypeBinding]> {\n         match *self {\n             ResolvedPath { ref path, .. } => path.segments.last().and_then(|seg| {\n                 if let GenericArgs::AngleBracketed { ref bindings, .. } = seg.args {\n@@ -1219,14 +1219,14 @@ impl Type {\n         }\n     }\n \n-    pub fn is_full_generic(&self) -> bool {\n+    crate fn is_full_generic(&self) -> bool {\n         match *self {\n             Type::Generic(_) => true,\n             _ => false,\n         }\n     }\n \n-    pub fn projection(&self) -> Option<(&Type, DefId, &str)> {\n+    crate fn projection(&self) -> Option<(&Type, DefId, &str)> {\n         let (self_, trait_, name) = match self {\n             QPath { ref self_type, ref trait_, ref name } => (self_type, trait_, name),\n             _ => return None,\n@@ -1267,7 +1267,7 @@ impl GetDefId for Type {\n }\n \n impl PrimitiveType {\n-    pub fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n+    crate fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n         match prim {\n             hir::PrimTy::Int(IntTy::Isize) => PrimitiveType::Isize,\n             hir::PrimTy::Int(IntTy::I8) => PrimitiveType::I8,\n@@ -1289,7 +1289,7 @@ impl PrimitiveType {\n         }\n     }\n \n-    pub fn from_symbol(s: Symbol) -> Option<PrimitiveType> {\n+    crate fn from_symbol(s: Symbol) -> Option<PrimitiveType> {\n         match s {\n             sym::isize => Some(PrimitiveType::Isize),\n             sym::i8 => Some(PrimitiveType::I8),\n@@ -1320,7 +1320,7 @@ impl PrimitiveType {\n         }\n     }\n \n-    pub fn as_str(&self) -> &'static str {\n+    crate fn as_str(&self) -> &'static str {\n         use self::PrimitiveType::*;\n         match *self {\n             Isize => \"isize\",\n@@ -1351,11 +1351,11 @@ impl PrimitiveType {\n         }\n     }\n \n-    pub fn impls(&self, tcx: TyCtxt<'_>) -> &'static SmallVec<[DefId; 4]> {\n+    crate fn impls(&self, tcx: TyCtxt<'_>) -> &'static SmallVec<[DefId; 4]> {\n         Self::all_impls(tcx).get(self).expect(\"missing impl for primitive type\")\n     }\n \n-    pub fn all_impls(tcx: TyCtxt<'_>) -> &'static FxHashMap<PrimitiveType, SmallVec<[DefId; 4]>> {\n+    crate fn all_impls(tcx: TyCtxt<'_>) -> &'static FxHashMap<PrimitiveType, SmallVec<[DefId; 4]>> {\n         static CELL: OnceCell<FxHashMap<PrimitiveType, SmallVec<[DefId; 4]>>> = OnceCell::new();\n \n         CELL.get_or_init(move || {\n@@ -1431,7 +1431,7 @@ impl PrimitiveType {\n         })\n     }\n \n-    pub fn to_url_str(&self) -> &'static str {\n+    crate fn to_url_str(&self) -> &'static str {\n         self.as_str()\n     }\n }\n@@ -1485,71 +1485,71 @@ impl From<hir::PrimTy> for PrimitiveType {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum Visibility {\n+crate enum Visibility {\n     Public,\n     Inherited,\n     Crate,\n     Restricted(DefId, Path),\n }\n \n #[derive(Clone, Debug)]\n-pub struct Struct {\n-    pub struct_type: doctree::StructType,\n-    pub generics: Generics,\n-    pub fields: Vec<Item>,\n-    pub fields_stripped: bool,\n+crate struct Struct {\n+    crate struct_type: doctree::StructType,\n+    crate generics: Generics,\n+    crate fields: Vec<Item>,\n+    crate fields_stripped: bool,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Union {\n-    pub struct_type: doctree::StructType,\n-    pub generics: Generics,\n-    pub fields: Vec<Item>,\n-    pub fields_stripped: bool,\n+crate struct Union {\n+    crate struct_type: doctree::StructType,\n+    crate generics: Generics,\n+    crate fields: Vec<Item>,\n+    crate fields_stripped: bool,\n }\n \n /// This is a more limited form of the standard Struct, different in that\n /// it lacks the things most items have (name, id, parameterization). Found\n /// only as a variant in an enum.\n #[derive(Clone, Debug)]\n-pub struct VariantStruct {\n-    pub struct_type: doctree::StructType,\n-    pub fields: Vec<Item>,\n-    pub fields_stripped: bool,\n+crate struct VariantStruct {\n+    crate struct_type: doctree::StructType,\n+    crate fields: Vec<Item>,\n+    crate fields_stripped: bool,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Enum {\n-    pub variants: IndexVec<VariantIdx, Item>,\n-    pub generics: Generics,\n-    pub variants_stripped: bool,\n+crate struct Enum {\n+    crate variants: IndexVec<VariantIdx, Item>,\n+    crate generics: Generics,\n+    crate variants_stripped: bool,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Variant {\n-    pub kind: VariantKind,\n+crate struct Variant {\n+    crate kind: VariantKind,\n }\n \n #[derive(Clone, Debug)]\n-pub enum VariantKind {\n+crate enum VariantKind {\n     CLike,\n     Tuple(Vec<Type>),\n     Struct(VariantStruct),\n }\n \n #[derive(Clone, Debug)]\n-pub struct Span {\n-    pub filename: FileName,\n-    pub cnum: CrateNum,\n-    pub loline: usize,\n-    pub locol: usize,\n-    pub hiline: usize,\n-    pub hicol: usize,\n-    pub original: rustc_span::Span,\n+crate struct Span {\n+    crate filename: FileName,\n+    crate cnum: CrateNum,\n+    crate loline: usize,\n+    crate locol: usize,\n+    crate hiline: usize,\n+    crate hicol: usize,\n+    crate original: rustc_span::Span,\n }\n \n impl Span {\n-    pub fn empty() -> Span {\n+    crate fn empty() -> Span {\n         Span {\n             filename: FileName::Anon(0),\n             cnum: LOCAL_CRATE,\n@@ -1561,49 +1561,49 @@ impl Span {\n         }\n     }\n \n-    pub fn span(&self) -> rustc_span::Span {\n+    crate fn span(&self) -> rustc_span::Span {\n         self.original\n     }\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Path {\n-    pub global: bool,\n-    pub res: Res,\n-    pub segments: Vec<PathSegment>,\n+crate struct Path {\n+    crate global: bool,\n+    crate res: Res,\n+    crate segments: Vec<PathSegment>,\n }\n \n impl Path {\n-    pub fn last_name(&self) -> &str {\n+    crate fn last_name(&self) -> &str {\n         self.segments.last().expect(\"segments were empty\").name.as_str()\n     }\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericArg {\n+crate enum GenericArg {\n     Lifetime(Lifetime),\n     Type(Type),\n     Const(Constant),\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericArgs {\n+crate enum GenericArgs {\n     AngleBracketed { args: Vec<GenericArg>, bindings: Vec<TypeBinding> },\n     Parenthesized { inputs: Vec<Type>, output: Option<Type> },\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct PathSegment {\n-    pub name: String,\n-    pub args: GenericArgs,\n+crate struct PathSegment {\n+    crate name: String,\n+    crate args: GenericArgs,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Typedef {\n-    pub type_: Type,\n-    pub generics: Generics,\n+crate struct Typedef {\n+    crate type_: Type,\n+    crate generics: Generics,\n     // Type of target item.\n-    pub item_type: Option<Type>,\n+    crate item_type: Option<Type>,\n }\n \n impl GetDefId for Typedef {\n@@ -1613,122 +1613,122 @@ impl GetDefId for Typedef {\n }\n \n #[derive(Clone, Debug)]\n-pub struct OpaqueTy {\n-    pub bounds: Vec<GenericBound>,\n-    pub generics: Generics,\n+crate struct OpaqueTy {\n+    crate bounds: Vec<GenericBound>,\n+    crate generics: Generics,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct BareFunctionDecl {\n-    pub unsafety: hir::Unsafety,\n-    pub generic_params: Vec<GenericParamDef>,\n-    pub decl: FnDecl,\n-    pub abi: Abi,\n+crate struct BareFunctionDecl {\n+    crate unsafety: hir::Unsafety,\n+    crate generic_params: Vec<GenericParamDef>,\n+    crate decl: FnDecl,\n+    crate abi: Abi,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Static {\n-    pub type_: Type,\n-    pub mutability: Mutability,\n+crate struct Static {\n+    crate type_: Type,\n+    crate mutability: Mutability,\n     /// It's useful to have the value of a static documented, but I have no\n     /// desire to represent expressions (that'd basically be all of the AST,\n     /// which is huge!). So, have a string.\n-    pub expr: String,\n+    crate expr: String,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct Constant {\n-    pub type_: Type,\n-    pub expr: String,\n-    pub value: Option<String>,\n-    pub is_literal: bool,\n+crate struct Constant {\n+    crate type_: Type,\n+    crate expr: String,\n+    crate value: Option<String>,\n+    crate is_literal: bool,\n }\n \n #[derive(Clone, PartialEq, Debug)]\n-pub enum ImplPolarity {\n+crate enum ImplPolarity {\n     Positive,\n     Negative,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Impl {\n-    pub unsafety: hir::Unsafety,\n-    pub generics: Generics,\n-    pub provided_trait_methods: FxHashSet<String>,\n-    pub trait_: Option<Type>,\n-    pub for_: Type,\n-    pub items: Vec<Item>,\n-    pub polarity: Option<ImplPolarity>,\n-    pub synthetic: bool,\n-    pub blanket_impl: Option<Type>,\n+crate struct Impl {\n+    crate unsafety: hir::Unsafety,\n+    crate generics: Generics,\n+    crate provided_trait_methods: FxHashSet<String>,\n+    crate trait_: Option<Type>,\n+    crate for_: Type,\n+    crate items: Vec<Item>,\n+    crate polarity: Option<ImplPolarity>,\n+    crate synthetic: bool,\n+    crate blanket_impl: Option<Type>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Import {\n-    pub kind: ImportKind,\n-    pub source: ImportSource,\n-    pub should_be_displayed: bool,\n+crate struct Import {\n+    crate kind: ImportKind,\n+    crate source: ImportSource,\n+    crate should_be_displayed: bool,\n }\n \n impl Import {\n-    pub fn new_simple(name: String, source: ImportSource, should_be_displayed: bool) -> Self {\n+    crate fn new_simple(name: String, source: ImportSource, should_be_displayed: bool) -> Self {\n         Self { kind: ImportKind::Simple(name), source, should_be_displayed }\n     }\n \n-    pub fn new_glob(source: ImportSource, should_be_displayed: bool) -> Self {\n+    crate fn new_glob(source: ImportSource, should_be_displayed: bool) -> Self {\n         Self { kind: ImportKind::Glob, source, should_be_displayed }\n     }\n }\n \n #[derive(Clone, Debug)]\n-pub enum ImportKind {\n+crate enum ImportKind {\n     // use source as str;\n     Simple(String),\n     // use source::*;\n     Glob,\n }\n \n #[derive(Clone, Debug)]\n-pub struct ImportSource {\n-    pub path: Path,\n-    pub did: Option<DefId>,\n+crate struct ImportSource {\n+    crate path: Path,\n+    crate did: Option<DefId>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Macro {\n-    pub source: String,\n-    pub imported_from: Option<String>,\n+crate struct Macro {\n+    crate source: String,\n+    crate imported_from: Option<String>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct ProcMacro {\n-    pub kind: MacroKind,\n-    pub helpers: Vec<String>,\n+crate struct ProcMacro {\n+    crate kind: MacroKind,\n+    crate helpers: Vec<String>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Deprecation {\n-    pub since: Option<String>,\n-    pub note: Option<String>,\n-    pub is_since_rustc_version: bool,\n+crate struct Deprecation {\n+    crate since: Option<String>,\n+    crate note: Option<String>,\n+    crate is_since_rustc_version: bool,\n }\n \n /// An type binding on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n /// `A: Send + Sync` in `Foo<A: Send + Sync>`).\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct TypeBinding {\n-    pub name: String,\n-    pub kind: TypeBindingKind,\n+crate struct TypeBinding {\n+    crate name: String,\n+    crate kind: TypeBindingKind,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum TypeBindingKind {\n+crate enum TypeBindingKind {\n     Equality { ty: Type },\n     Constraint { bounds: Vec<GenericBound> },\n }\n \n impl TypeBinding {\n-    pub fn ty(&self) -> &Type {\n+    crate fn ty(&self) -> &Type {\n         match self.kind {\n             TypeBindingKind::Equality { ref ty } => ty,\n             _ => panic!(\"expected equality type binding for parenthesized generic args\"),"}, {"sha": "22917fbceb48a12dcb0fa773a8a1328fc6b8f341", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::ty::{self, DefIdTree, Ty};\n use rustc_span::symbol::{kw, sym, Symbol};\n use std::mem;\n \n-pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n+crate fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n     use crate::visit_lib::LibEmbargoVisitor;\n \n     let krate = cx.tcx.hir().krate();\n@@ -102,11 +102,11 @@ pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n }\n \n // extract the stability index for a node from tcx, if possible\n-pub fn get_stability(cx: &DocContext<'_>, def_id: DefId) -> Option<Stability> {\n+crate fn get_stability(cx: &DocContext<'_>, def_id: DefId) -> Option<Stability> {\n     cx.tcx.lookup_stability(def_id).cloned()\n }\n \n-pub fn get_deprecation(cx: &DocContext<'_>, def_id: DefId) -> Option<Deprecation> {\n+crate fn get_deprecation(cx: &DocContext<'_>, def_id: DefId) -> Option<Deprecation> {\n     cx.tcx.lookup_deprecation(def_id).clean(cx)\n }\n \n@@ -183,7 +183,7 @@ pub(super) fn external_path(\n /// i.e. `[T, U]` when you have the following bounds: `T: Display, U: Option<T>` will return\n /// `[Display, Option]` (we just returns the list of the types, we don't care about the\n /// wrapped types in here).\n-pub fn get_real_types(\n+crate fn get_real_types(\n     generics: &Generics,\n     arg: &Type,\n     cx: &DocContext<'_>,\n@@ -261,7 +261,7 @@ pub fn get_real_types(\n ///\n /// i.e. `fn foo<A: Display, B: Option<A>>(x: u32, y: B)` will return\n /// `[u32, Display, Option]`.\n-pub fn get_all_types(\n+crate fn get_all_types(\n     generics: &Generics,\n     decl: &FnDecl,\n     cx: &DocContext<'_>,\n@@ -296,7 +296,7 @@ pub fn get_all_types(\n     (all_types.into_iter().collect(), ret_types)\n }\n \n-pub fn strip_type(ty: Type) -> Type {\n+crate fn strip_type(ty: Type) -> Type {\n     match ty {\n         Type::ResolvedPath { path, param_names, did, is_generic } => {\n             Type::ResolvedPath { path: strip_path(&path), param_names, did, is_generic }\n@@ -319,7 +319,7 @@ pub fn strip_type(ty: Type) -> Type {\n     }\n }\n \n-pub fn strip_path(path: &Path) -> Path {\n+crate fn strip_path(path: &Path) -> Path {\n     let segments = path\n         .segments\n         .iter()\n@@ -332,7 +332,7 @@ pub fn strip_path(path: &Path) -> Path {\n     Path { global: path.global, res: path.res, segments }\n }\n \n-pub fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n+crate fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n     let segments = match *p {\n         hir::QPath::Resolved(_, ref path) => &path.segments,\n         hir::QPath::TypeRelative(_, ref segment) => return segment.ident.to_string(),\n@@ -351,7 +351,7 @@ pub fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n     s\n }\n \n-pub fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut Vec<Item>) {\n+crate fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut Vec<Item>) {\n     let tcx = cx.tcx;\n \n     for item in items {\n@@ -378,7 +378,7 @@ pub fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut V\n     }\n }\n \n-pub trait ToSource {\n+crate trait ToSource {\n     fn to_src(&self, cx: &DocContext<'_>) -> String;\n }\n \n@@ -394,7 +394,7 @@ impl ToSource for rustc_span::Span {\n     }\n }\n \n-pub fn name_from_pat(p: &hir::Pat<'_>) -> String {\n+crate fn name_from_pat(p: &hir::Pat<'_>) -> String {\n     use rustc_hir::*;\n     debug!(\"trying to get a name from pattern: {:?}\", p);\n \n@@ -440,7 +440,7 @@ pub fn name_from_pat(p: &hir::Pat<'_>) -> String {\n     }\n }\n \n-pub fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n+crate fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n     match n.val {\n         ty::ConstKind::Unevaluated(def, _, promoted) => {\n             let mut s = if let Some(def) = def.as_local() {\n@@ -470,7 +470,7 @@ pub fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n     }\n }\n \n-pub fn print_evaluated_const(cx: &DocContext<'_>, def_id: DefId) -> Option<String> {\n+crate fn print_evaluated_const(cx: &DocContext<'_>, def_id: DefId) -> Option<String> {\n     cx.tcx.const_eval_poly(def_id).ok().and_then(|val| {\n         let ty = cx.tcx.type_of(def_id);\n         match (val, ty.kind()) {\n@@ -518,7 +518,7 @@ fn print_const_with_custom_print_scalar(cx: &DocContext<'_>, ct: &'tcx ty::Const\n     }\n }\n \n-pub fn is_literal_expr(cx: &DocContext<'_>, hir_id: hir::HirId) -> bool {\n+crate fn is_literal_expr(cx: &DocContext<'_>, hir_id: hir::HirId) -> bool {\n     if let hir::Node::Expr(expr) = cx.tcx.hir().get(hir_id) {\n         if let hir::ExprKind::Lit(_) = &expr.kind {\n             return true;\n@@ -534,7 +534,7 @@ pub fn is_literal_expr(cx: &DocContext<'_>, hir_id: hir::HirId) -> bool {\n     false\n }\n \n-pub fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n+crate fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n     let value = &cx.tcx.hir().body(body).value;\n \n     let snippet = if !value.span.from_expansion() {\n@@ -547,7 +547,7 @@ pub fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt\n-pub fn resolve_type(cx: &DocContext<'_>, path: Path, id: hir::HirId) -> Type {\n+crate fn resolve_type(cx: &DocContext<'_>, path: Path, id: hir::HirId) -> Type {\n     debug!(\"resolve_type({:?},{:?})\", path, id);\n \n     let is_generic = match path.res {\n@@ -565,7 +565,7 @@ pub fn resolve_type(cx: &DocContext<'_>, path: Path, id: hir::HirId) -> Type {\n     ResolvedPath { path, param_names: None, did, is_generic }\n }\n \n-pub fn get_auto_trait_and_blanket_impls(\n+crate fn get_auto_trait_and_blanket_impls(\n     cx: &DocContext<'tcx>,\n     ty: Ty<'tcx>,\n     param_env_def_id: DefId,\n@@ -576,7 +576,7 @@ pub fn get_auto_trait_and_blanket_impls(\n         .chain(BlanketImplFinder::new(cx).get_blanket_impls(ty, param_env_def_id))\n }\n \n-pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n+crate fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n     debug!(\"register_res({:?})\", res);\n \n     let (did, kind) = match res {\n@@ -616,14 +616,14 @@ pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n     did\n }\n \n-pub fn resolve_use_source(cx: &DocContext<'_>, path: Path) -> ImportSource {\n+crate fn resolve_use_source(cx: &DocContext<'_>, path: Path) -> ImportSource {\n     ImportSource {\n         did: if path.res.opt_def_id().is_none() { None } else { Some(register_res(cx, path.res)) },\n         path,\n     }\n }\n \n-pub fn enter_impl_trait<F, R>(cx: &DocContext<'_>, f: F) -> R\n+crate fn enter_impl_trait<F, R>(cx: &DocContext<'_>, f: F) -> R\n where\n     F: FnOnce() -> R,\n {"}, {"sha": "e60970af0d341920153195353e54b1f074fbfecd", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -30,13 +30,13 @@ use crate::passes::{self, Condition, DefaultPassOption};\n use crate::theme;\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum OutputFormat {\n+crate enum OutputFormat {\n     Json,\n     Html,\n }\n \n impl OutputFormat {\n-    pub fn is_json(&self) -> bool {\n+    crate fn is_json(&self) -> bool {\n         match self {\n             OutputFormat::Json => true,\n             _ => false,\n@@ -58,96 +58,96 @@ impl TryFrom<&str> for OutputFormat {\n \n /// Configuration options for rustdoc.\n #[derive(Clone)]\n-pub struct Options {\n+crate struct Options {\n     // Basic options / Options passed directly to rustc\n     /// The crate root or Markdown file to load.\n-    pub input: PathBuf,\n+    crate input: PathBuf,\n     /// The name of the crate being documented.\n-    pub crate_name: Option<String>,\n+    crate crate_name: Option<String>,\n     /// Whether or not this is a proc-macro crate\n-    pub proc_macro_crate: bool,\n+    crate proc_macro_crate: bool,\n     /// How to format errors and warnings.\n-    pub error_format: ErrorOutputType,\n+    crate error_format: ErrorOutputType,\n     /// Library search paths to hand to the compiler.\n-    pub libs: Vec<SearchPath>,\n+    crate libs: Vec<SearchPath>,\n     /// Library search paths strings to hand to the compiler.\n-    pub lib_strs: Vec<String>,\n+    crate lib_strs: Vec<String>,\n     /// The list of external crates to link against.\n-    pub externs: Externs,\n+    crate externs: Externs,\n     /// The list of external crates strings to link against.\n-    pub extern_strs: Vec<String>,\n+    crate extern_strs: Vec<String>,\n     /// List of `cfg` flags to hand to the compiler. Always includes `rustdoc`.\n-    pub cfgs: Vec<String>,\n+    crate cfgs: Vec<String>,\n     /// Codegen options to hand to the compiler.\n-    pub codegen_options: CodegenOptions,\n+    crate codegen_options: CodegenOptions,\n     /// Codegen options strings to hand to the compiler.\n-    pub codegen_options_strs: Vec<String>,\n+    crate codegen_options_strs: Vec<String>,\n     /// Debugging (`-Z`) options to pass to the compiler.\n-    pub debugging_opts: DebuggingOptions,\n+    crate debugging_opts: DebuggingOptions,\n     /// Debugging (`-Z`) options strings to pass to the compiler.\n-    pub debugging_opts_strs: Vec<String>,\n+    crate debugging_opts_strs: Vec<String>,\n     /// The target used to compile the crate against.\n-    pub target: TargetTriple,\n+    crate target: TargetTriple,\n     /// Edition used when reading the crate. Defaults to \"2015\". Also used by default when\n     /// compiling doctests from the crate.\n-    pub edition: Edition,\n+    crate edition: Edition,\n     /// The path to the sysroot. Used during the compilation process.\n-    pub maybe_sysroot: Option<PathBuf>,\n+    crate maybe_sysroot: Option<PathBuf>,\n     /// Lint information passed over the command-line.\n-    pub lint_opts: Vec<(String, Level)>,\n+    crate lint_opts: Vec<(String, Level)>,\n     /// Whether to ask rustc to describe the lints it knows. Practically speaking, this will not be\n     /// used, since we abort if we have no input file, but it's included for completeness.\n-    pub describe_lints: bool,\n+    crate describe_lints: bool,\n     /// What level to cap lints at.\n-    pub lint_cap: Option<Level>,\n+    crate lint_cap: Option<Level>,\n \n     // Options specific to running doctests\n     /// Whether we should run doctests instead of generating docs.\n-    pub should_test: bool,\n+    crate should_test: bool,\n     /// List of arguments to pass to the test harness, if running tests.\n-    pub test_args: Vec<String>,\n+    crate test_args: Vec<String>,\n     /// Optional path to persist the doctest executables to, defaults to a\n     /// temporary directory if not set.\n-    pub persist_doctests: Option<PathBuf>,\n+    crate persist_doctests: Option<PathBuf>,\n     /// Runtool to run doctests with\n-    pub runtool: Option<String>,\n+    crate runtool: Option<String>,\n     /// Arguments to pass to the runtool\n-    pub runtool_args: Vec<String>,\n+    crate runtool_args: Vec<String>,\n     /// Whether to allow ignoring doctests on a per-target basis\n     /// For example, using ignore-foo to ignore running the doctest on any target that\n     /// contains \"foo\" as a substring\n-    pub enable_per_target_ignores: bool,\n+    crate enable_per_target_ignores: bool,\n \n     /// The path to a rustc-like binary to build tests with. If not set, we\n     /// default to loading from $sysroot/bin/rustc.\n-    pub test_builder: Option<PathBuf>,\n+    crate test_builder: Option<PathBuf>,\n \n     // Options that affect the documentation process\n     /// The selected default set of passes to use.\n     ///\n     /// Be aware: This option can come both from the CLI and from crate attributes!\n-    pub default_passes: DefaultPassOption,\n+    crate default_passes: DefaultPassOption,\n     /// Any passes manually selected by the user.\n     ///\n     /// Be aware: This option can come both from the CLI and from crate attributes!\n-    pub manual_passes: Vec<String>,\n+    crate manual_passes: Vec<String>,\n     /// Whether to display warnings during doc generation or while gathering doctests. By default,\n     /// all non-rustdoc-specific lints are allowed when generating docs.\n-    pub display_warnings: bool,\n+    crate display_warnings: bool,\n     /// Whether to run the `calculate-doc-coverage` pass, which counts the number of public items\n     /// with and without documentation.\n-    pub show_coverage: bool,\n+    crate show_coverage: bool,\n \n     // Options that alter generated documentation pages\n     /// Crate version to note on the sidebar of generated docs.\n-    pub crate_version: Option<String>,\n+    crate crate_version: Option<String>,\n     /// Collected options specific to outputting final pages.\n-    pub render_options: RenderOptions,\n+    crate render_options: RenderOptions,\n     /// Output format rendering (used only for \"show-coverage\" option for the moment)\n-    pub output_format: Option<OutputFormat>,\n+    crate output_format: Option<OutputFormat>,\n     /// If this option is set to `true`, rustdoc will only run checks and not generate\n     /// documentation.\n-    pub run_check: bool,\n+    crate run_check: bool,\n }\n \n impl fmt::Debug for Options {\n@@ -195,89 +195,89 @@ impl fmt::Debug for Options {\n \n /// Configuration options for the HTML page-creation process.\n #[derive(Clone, Debug)]\n-pub struct RenderOptions {\n+crate struct RenderOptions {\n     /// Output directory to generate docs into. Defaults to `doc`.\n-    pub output: PathBuf,\n+    crate output: PathBuf,\n     /// External files to insert into generated pages.\n-    pub external_html: ExternalHtml,\n+    crate external_html: ExternalHtml,\n     /// A pre-populated `IdMap` with the default headings and any headings added by Markdown files\n     /// processed by `external_html`.\n-    pub id_map: IdMap,\n+    crate id_map: IdMap,\n     /// If present, playground URL to use in the \"Run\" button added to code samples.\n     ///\n     /// Be aware: This option can come both from the CLI and from crate attributes!\n-    pub playground_url: Option<String>,\n+    crate playground_url: Option<String>,\n     /// Whether to sort modules alphabetically on a module page instead of using declaration order.\n     /// `true` by default.\n     //\n     // FIXME(misdreavus): the flag name is `--sort-modules-by-appearance` but the meaning is\n     // inverted once read.\n-    pub sort_modules_alphabetically: bool,\n+    crate sort_modules_alphabetically: bool,\n     /// List of themes to extend the docs with. Original argument name is included to assist in\n     /// displaying errors if it fails a theme check.\n-    pub themes: Vec<StylePath>,\n+    crate themes: Vec<StylePath>,\n     /// If present, CSS file that contains rules to add to the default CSS.\n-    pub extension_css: Option<PathBuf>,\n+    crate extension_css: Option<PathBuf>,\n     /// A map of crate names to the URL to use instead of querying the crate's `html_root_url`.\n-    pub extern_html_root_urls: BTreeMap<String, String>,\n+    crate extern_html_root_urls: BTreeMap<String, String>,\n     /// A map of the default settings (values are as for DOM storage API). Keys should lack the\n     /// `rustdoc-` prefix.\n-    pub default_settings: HashMap<String, String>,\n+    crate default_settings: HashMap<String, String>,\n     /// If present, suffix added to CSS/JavaScript files when referencing them in generated pages.\n-    pub resource_suffix: String,\n+    crate resource_suffix: String,\n     /// Whether to run the static CSS/JavaScript through a minifier when outputting them. `true` by\n     /// default.\n     //\n     // FIXME(misdreavus): the flag name is `--disable-minification` but the meaning is inverted\n     // once read.\n-    pub enable_minification: bool,\n+    crate enable_minification: bool,\n     /// Whether to create an index page in the root of the output directory. If this is true but\n     /// `enable_index_page` is None, generate a static listing of crates instead.\n-    pub enable_index_page: bool,\n+    crate enable_index_page: bool,\n     /// A file to use as the index page at the root of the output directory. Overrides\n     /// `enable_index_page` to be true if set.\n-    pub index_page: Option<PathBuf>,\n+    crate index_page: Option<PathBuf>,\n     /// An optional path to use as the location of static files. If not set, uses combinations of\n     /// `../` to reach the documentation root.\n-    pub static_root_path: Option<String>,\n+    crate static_root_path: Option<String>,\n \n     // Options specific to reading standalone Markdown files\n     /// Whether to generate a table of contents on the output file when reading a standalone\n     /// Markdown file.\n-    pub markdown_no_toc: bool,\n+    crate markdown_no_toc: bool,\n     /// Additional CSS files to link in pages generated from standalone Markdown files.\n-    pub markdown_css: Vec<String>,\n+    crate markdown_css: Vec<String>,\n     /// If present, playground URL to use in the \"Run\" button added to code samples generated from\n     /// standalone Markdown files. If not present, `playground_url` is used.\n-    pub markdown_playground_url: Option<String>,\n+    crate markdown_playground_url: Option<String>,\n     /// If false, the `select` element to have search filtering by crates on rendered docs\n     /// won't be generated.\n-    pub generate_search_filter: bool,\n+    crate generate_search_filter: bool,\n     /// Document items that have lower than `pub` visibility.\n-    pub document_private: bool,\n+    crate document_private: bool,\n     /// Document items that have `doc(hidden)`.\n-    pub document_hidden: bool,\n-    pub unstable_features: rustc_feature::UnstableFeatures,\n+    crate document_hidden: bool,\n+    crate unstable_features: rustc_feature::UnstableFeatures,\n }\n \n /// Temporary storage for data obtained during `RustdocVisitor::clean()`.\n /// Later on moved into `CACHE_KEY`.\n #[derive(Default, Clone)]\n-pub struct RenderInfo {\n-    pub inlined: FxHashSet<DefId>,\n-    pub external_paths: crate::core::ExternalPaths,\n-    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n-    pub access_levels: AccessLevels<DefId>,\n-    pub deref_trait_did: Option<DefId>,\n-    pub deref_mut_trait_did: Option<DefId>,\n-    pub owned_box_did: Option<DefId>,\n-    pub output_format: Option<OutputFormat>,\n+crate struct RenderInfo {\n+    crate inlined: FxHashSet<DefId>,\n+    crate external_paths: crate::core::ExternalPaths,\n+    crate exact_paths: FxHashMap<DefId, Vec<String>>,\n+    crate access_levels: AccessLevels<DefId>,\n+    crate deref_trait_did: Option<DefId>,\n+    crate deref_mut_trait_did: Option<DefId>,\n+    crate owned_box_did: Option<DefId>,\n+    crate output_format: Option<OutputFormat>,\n }\n \n impl Options {\n     /// Parses the given command-line for options. If an error message or other early-return has\n     /// been printed, returns `Err` with the exit code.\n-    pub fn from_matches(matches: &getopts::Matches) -> Result<Options, i32> {\n+    crate fn from_matches(matches: &getopts::Matches) -> Result<Options, i32> {\n         // Check for unstable options.\n         nightly_options::check_nightly_options(&matches, &opts());\n \n@@ -656,7 +656,7 @@ impl Options {\n     }\n \n     /// Returns `true` if the file given as `self.input` is a Markdown file.\n-    pub fn markdown_input(&self) -> bool {\n+    crate fn markdown_input(&self) -> bool {\n         self.input.extension().map_or(false, |e| e == \"md\" || e == \"markdown\")\n     }\n }"}, {"sha": "7d73f3f356b02cbf1402d5c30c367cd32de75e1c", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -36,52 +36,52 @@ use crate::config::{Options as RustdocOptions, RenderOptions};\n use crate::config::{OutputFormat, RenderInfo};\n use crate::passes::{self, Condition::*, ConditionalPass};\n \n-pub use rustc_session::config::{CodegenOptions, DebuggingOptions, Input, Options};\n-pub use rustc_session::search_paths::SearchPath;\n+crate use rustc_session::config::{CodegenOptions, DebuggingOptions, Input, Options};\n+crate use rustc_session::search_paths::SearchPath;\n \n-pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n+crate type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n-pub struct DocContext<'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-    pub resolver: Rc<RefCell<interface::BoxedResolver>>,\n+crate struct DocContext<'tcx> {\n+    crate tcx: TyCtxt<'tcx>,\n+    crate resolver: Rc<RefCell<interface::BoxedResolver>>,\n     /// Later on moved into `CACHE_KEY`\n-    pub renderinfo: RefCell<RenderInfo>,\n+    crate renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `CACHE_KEY`\n-    pub external_traits: Rc<RefCell<FxHashMap<DefId, clean::Trait>>>,\n+    crate external_traits: Rc<RefCell<FxHashMap<DefId, clean::Trait>>>,\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time.\n-    pub active_extern_traits: RefCell<FxHashSet<DefId>>,\n+    crate active_extern_traits: RefCell<FxHashSet<DefId>>,\n     // The current set of type and lifetime substitutions,\n     // for expanding type aliases at the HIR level:\n     /// Table `DefId` of type parameter -> substituted type\n-    pub ty_substs: RefCell<FxHashMap<DefId, clean::Type>>,\n+    crate ty_substs: RefCell<FxHashMap<DefId, clean::Type>>,\n     /// Table `DefId` of lifetime parameter -> substituted lifetime\n-    pub lt_substs: RefCell<FxHashMap<DefId, clean::Lifetime>>,\n+    crate lt_substs: RefCell<FxHashMap<DefId, clean::Lifetime>>,\n     /// Table `DefId` of const parameter -> substituted const\n-    pub ct_substs: RefCell<FxHashMap<DefId, clean::Constant>>,\n+    crate ct_substs: RefCell<FxHashMap<DefId, clean::Constant>>,\n     /// Table synthetic type parameter for `impl Trait` in argument position -> bounds\n-    pub impl_trait_bounds: RefCell<FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>>,\n-    pub fake_def_ids: RefCell<FxHashMap<CrateNum, DefId>>,\n-    pub all_fake_def_ids: RefCell<FxHashSet<DefId>>,\n+    crate impl_trait_bounds: RefCell<FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>>,\n+    crate fake_def_ids: RefCell<FxHashMap<CrateNum, DefId>>,\n+    crate all_fake_def_ids: RefCell<FxHashSet<DefId>>,\n     /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n     // FIXME(eddyb) make this a `ty::TraitRef<'tcx>` set.\n-    pub generated_synthetics: RefCell<FxHashSet<(Ty<'tcx>, DefId)>>,\n-    pub auto_traits: Vec<DefId>,\n+    crate generated_synthetics: RefCell<FxHashSet<(Ty<'tcx>, DefId)>>,\n+    crate auto_traits: Vec<DefId>,\n     /// The options given to rustdoc that could be relevant to a pass.\n-    pub render_options: RenderOptions,\n+    crate render_options: RenderOptions,\n     /// The traits in scope for a given module.\n     ///\n     /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n     /// `map<module, set<trait>>`\n-    pub module_trait_cache: RefCell<FxHashMap<DefId, FxHashSet<DefId>>>,\n+    crate module_trait_cache: RefCell<FxHashMap<DefId, FxHashSet<DefId>>>,\n }\n \n impl<'tcx> DocContext<'tcx> {\n-    pub fn sess(&self) -> &Session {\n+    crate fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n \n-    pub fn enter_resolver<F, R>(&self, f: F) -> R\n+    crate fn enter_resolver<F, R>(&self, f: F) -> R\n     where\n         F: FnOnce(&mut resolve::Resolver<'_>) -> R,\n     {\n@@ -90,7 +90,7 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Call the closure with the given parameters set as\n     /// the substitutions for a type alias' RHS.\n-    pub fn enter_alias<F, R>(\n+    crate fn enter_alias<F, R>(\n         &self,\n         ty_substs: FxHashMap<DefId, clean::Type>,\n         lt_substs: FxHashMap<DefId, clean::Lifetime>,\n@@ -120,7 +120,7 @@ impl<'tcx> DocContext<'tcx> {\n     // Instead, we construct 'fake' def ids, which start immediately after the last DefId.\n     // In the Debug impl for clean::Item, we explicitly check for fake\n     // def ids, as we'll end up with a panic if we use the DefId Debug impl for fake DefIds\n-    pub fn next_def_id(&self, crate_num: CrateNum) -> DefId {\n+    crate fn next_def_id(&self, crate_num: CrateNum) -> DefId {\n         let start_def_id = {\n             let num_def_ids = if crate_num == LOCAL_CRATE {\n                 self.tcx.hir().definitions().def_path_table().num_def_ids()\n@@ -150,23 +150,23 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Like `hir().local_def_id_to_hir_id()`, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n-    pub fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n+    crate fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n         if self.all_fake_def_ids.borrow().contains(&def_id) {\n             None\n         } else {\n             def_id.as_local().map(|def_id| self.tcx.hir().local_def_id_to_hir_id(def_id))\n         }\n     }\n \n-    pub fn stability(&self, id: HirId) -> Option<attr::Stability> {\n+    crate fn stability(&self, id: HirId) -> Option<attr::Stability> {\n         self.tcx\n             .hir()\n             .opt_local_def_id(id)\n             .and_then(|def_id| self.tcx.lookup_stability(def_id.to_def_id()))\n             .cloned()\n     }\n \n-    pub fn deprecation(&self, id: HirId) -> Option<attr::Deprecation> {\n+    crate fn deprecation(&self, id: HirId) -> Option<attr::Deprecation> {\n         self.tcx\n             .hir()\n             .opt_local_def_id(id)\n@@ -178,7 +178,7 @@ impl<'tcx> DocContext<'tcx> {\n ///\n /// If the given `error_format` is `ErrorOutputType::Json` and no `SourceMap` is given, a new one\n /// will be created for the handler.\n-pub fn new_handler(\n+crate fn new_handler(\n     error_format: ErrorOutputType,\n     source_map: Option<Lrc<source_map::SourceMap>>,\n     debugging_opts: &DebuggingOptions,\n@@ -280,7 +280,7 @@ where\n     (lint_opts, lint_caps)\n }\n \n-pub fn run_core(\n+crate fn run_core(\n     options: RustdocOptions,\n ) -> (clean::Crate, RenderInfo, RenderOptions, Lrc<Session>) {\n     // Parse, resolve, and typecheck the given crate.\n@@ -725,7 +725,7 @@ impl<'tcx> Visitor<'tcx> for EmitIgnoredResolutionErrors<'tcx> {\n /// `DefId` or parameter index (`ty::ParamTy.index`) of a synthetic type parameter\n /// for `impl Trait` in argument position.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub enum ImplTraitParam {\n+crate enum ImplTraitParam {\n     DefId(DefId),\n     ParamIndex(u32),\n }"}, {"sha": "9b740acfcdfd7fe598e0e152e2e430008af5a58d", "filename": "src/librustdoc/docfs.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fdocfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fdocfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdocfs.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -24,38 +24,38 @@ macro_rules! try_err {\n     };\n }\n \n-pub trait PathError {\n+crate trait PathError {\n     fn new<S, P: AsRef<Path>>(e: S, path: P) -> Self\n     where\n         S: ToString + Sized;\n }\n \n-pub struct DocFS {\n+crate struct DocFS {\n     sync_only: bool,\n     errors: Option<Sender<String>>,\n }\n \n impl DocFS {\n-    pub fn new(errors: Sender<String>) -> DocFS {\n+    crate fn new(errors: Sender<String>) -> DocFS {\n         DocFS { sync_only: false, errors: Some(errors) }\n     }\n \n-    pub fn set_sync_only(&mut self, sync_only: bool) {\n+    crate fn set_sync_only(&mut self, sync_only: bool) {\n         self.sync_only = sync_only;\n     }\n \n-    pub fn close(&mut self) {\n+    crate fn close(&mut self) {\n         self.errors = None;\n     }\n \n-    pub fn create_dir_all<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n+    crate fn create_dir_all<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n         // For now, dir creation isn't a huge time consideration, do it\n         // synchronously, which avoids needing ordering between write() actions\n         // and directory creation.\n         fs::create_dir_all(path)\n     }\n \n-    pub fn write<P, C, E>(&self, path: P, contents: C) -> Result<(), E>\n+    crate fn write<P, C, E>(&self, path: P, contents: C) -> Result<(), E>\n     where\n         P: AsRef<Path>,\n         C: AsRef<[u8]>,"}, {"sha": "c79b2395d231b138a17f301bda14940ec3b8ac95", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -31,17 +31,17 @@ use crate::html::markdown::{self, ErrorCodes, Ignore, LangString};\n use crate::passes::span_of_attrs;\n \n #[derive(Clone, Default)]\n-pub struct TestOptions {\n+crate struct TestOptions {\n     /// Whether to disable the default `extern crate my_crate;` when creating doctests.\n-    pub no_crate_inject: bool,\n+    crate no_crate_inject: bool,\n     /// Whether to emit compilation warnings when compiling doctests. Setting this will suppress\n     /// the default `#![allow(unused)]`.\n-    pub display_warnings: bool,\n+    crate display_warnings: bool,\n     /// Additional crate-level attributes to add to doctests.\n-    pub attrs: Vec<String>,\n+    crate attrs: Vec<String>,\n }\n \n-pub fn run(options: Options) -> Result<(), ErrorReported> {\n+crate fn run(options: Options) -> Result<(), ErrorReported> {\n     let input = config::Input::File(options.input.clone());\n \n     let invalid_codeblock_attributes_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTES.name;\n@@ -363,7 +363,7 @@ fn run_test(\n \n /// Transforms a test into code that can be compiled into a Rust binary, and returns the number of\n /// lines before the test code begins.\n-pub fn make_test(\n+crate fn make_test(\n     s: &str,\n     cratename: Option<&str>,\n     dont_insert_main: bool,\n@@ -605,16 +605,16 @@ fn partition_source(s: &str) -> (String, String, String) {\n     (before, after, crates)\n }\n \n-pub trait Tester {\n+crate trait Tester {\n     fn add_test(&mut self, test: String, config: LangString, line: usize);\n     fn get_line(&self) -> usize {\n         0\n     }\n     fn register_header(&mut self, _name: &str, _level: u32) {}\n }\n \n-pub struct Collector {\n-    pub tests: Vec<testing::TestDescAndFn>,\n+crate struct Collector {\n+    crate tests: Vec<testing::TestDescAndFn>,\n \n     // The name of the test displayed to the user, separated by `::`.\n     //\n@@ -650,7 +650,7 @@ pub struct Collector {\n }\n \n impl Collector {\n-    pub fn new(\n+    crate fn new(\n         cratename: String,\n         options: Options,\n         use_headers: bool,\n@@ -682,7 +682,7 @@ impl Collector {\n         format!(\"{} - {}(line {})\", filename, item_path, line)\n     }\n \n-    pub fn set_position(&mut self, position: Span) {\n+    crate fn set_position(&mut self, position: Span) {\n         self.position = position;\n     }\n "}, {"sha": "a80ac1e72fcaf17f024f45e087e851151ec70802", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 173, "deletions": 173, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -1,6 +1,6 @@\n //! This module is used to store stuff from Rust's AST in a more convenient\n //! manner (and with prettier names) before cleaning.\n-pub use self::StructType::*;\n+crate use self::StructType::*;\n \n use rustc_ast as ast;\n use rustc_span::hygiene::MacroKind;\n@@ -10,35 +10,35 @@ use rustc_hir as hir;\n use rustc_hir::def_id::CrateNum;\n use rustc_hir::HirId;\n \n-pub struct Module<'hir> {\n-    pub name: Option<Symbol>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub where_outer: Span,\n-    pub where_inner: Span,\n-    pub extern_crates: Vec<ExternCrate<'hir>>,\n-    pub imports: Vec<Import<'hir>>,\n-    pub structs: Vec<Struct<'hir>>,\n-    pub unions: Vec<Union<'hir>>,\n-    pub enums: Vec<Enum<'hir>>,\n-    pub fns: Vec<Function<'hir>>,\n-    pub mods: Vec<Module<'hir>>,\n-    pub id: hir::HirId,\n-    pub typedefs: Vec<Typedef<'hir>>,\n-    pub opaque_tys: Vec<OpaqueTy<'hir>>,\n-    pub statics: Vec<Static<'hir>>,\n-    pub constants: Vec<Constant<'hir>>,\n-    pub traits: Vec<Trait<'hir>>,\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub impls: Vec<Impl<'hir>>,\n-    pub foreigns: Vec<ForeignItem<'hir>>,\n-    pub macros: Vec<Macro<'hir>>,\n-    pub proc_macros: Vec<ProcMacro<'hir>>,\n-    pub trait_aliases: Vec<TraitAlias<'hir>>,\n-    pub is_crate: bool,\n+crate struct Module<'hir> {\n+    crate name: Option<Symbol>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate where_outer: Span,\n+    crate where_inner: Span,\n+    crate extern_crates: Vec<ExternCrate<'hir>>,\n+    crate imports: Vec<Import<'hir>>,\n+    crate structs: Vec<Struct<'hir>>,\n+    crate unions: Vec<Union<'hir>>,\n+    crate enums: Vec<Enum<'hir>>,\n+    crate fns: Vec<Function<'hir>>,\n+    crate mods: Vec<Module<'hir>>,\n+    crate id: hir::HirId,\n+    crate typedefs: Vec<Typedef<'hir>>,\n+    crate opaque_tys: Vec<OpaqueTy<'hir>>,\n+    crate statics: Vec<Static<'hir>>,\n+    crate constants: Vec<Constant<'hir>>,\n+    crate traits: Vec<Trait<'hir>>,\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate impls: Vec<Impl<'hir>>,\n+    crate foreigns: Vec<ForeignItem<'hir>>,\n+    crate macros: Vec<Macro<'hir>>,\n+    crate proc_macros: Vec<ProcMacro<'hir>>,\n+    crate trait_aliases: Vec<TraitAlias<'hir>>,\n+    crate is_crate: bool,\n }\n \n impl Module<'hir> {\n-    pub fn new(\n+    crate fn new(\n         name: Option<Symbol>,\n         attrs: &'hir [ast::Attribute],\n         vis: &'hir hir::Visibility<'hir>,\n@@ -73,7 +73,7 @@ impl Module<'hir> {\n }\n \n #[derive(Debug, Clone, Copy)]\n-pub enum StructType {\n+crate enum StructType {\n     /// A braced struct\n     Plain,\n     /// A tuple struct\n@@ -82,190 +82,190 @@ pub enum StructType {\n     Unit,\n }\n \n-pub struct Struct<'hir> {\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub id: hir::HirId,\n-    pub struct_type: StructType,\n-    pub name: Symbol,\n-    pub generics: &'hir hir::Generics<'hir>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub fields: &'hir [hir::StructField<'hir>],\n-    pub span: Span,\n+crate struct Struct<'hir> {\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate id: hir::HirId,\n+    crate struct_type: StructType,\n+    crate name: Symbol,\n+    crate generics: &'hir hir::Generics<'hir>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate fields: &'hir [hir::StructField<'hir>],\n+    crate span: Span,\n }\n \n-pub struct Union<'hir> {\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub id: hir::HirId,\n-    pub struct_type: StructType,\n-    pub name: Symbol,\n-    pub generics: &'hir hir::Generics<'hir>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub fields: &'hir [hir::StructField<'hir>],\n-    pub span: Span,\n+crate struct Union<'hir> {\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate id: hir::HirId,\n+    crate struct_type: StructType,\n+    crate name: Symbol,\n+    crate generics: &'hir hir::Generics<'hir>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate fields: &'hir [hir::StructField<'hir>],\n+    crate span: Span,\n }\n \n-pub struct Enum<'hir> {\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub variants: Vec<Variant<'hir>>,\n-    pub generics: &'hir hir::Generics<'hir>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub id: hir::HirId,\n-    pub span: Span,\n-    pub name: Symbol,\n+crate struct Enum<'hir> {\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate variants: Vec<Variant<'hir>>,\n+    crate generics: &'hir hir::Generics<'hir>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate id: hir::HirId,\n+    crate span: Span,\n+    crate name: Symbol,\n }\n \n-pub struct Variant<'hir> {\n-    pub name: Symbol,\n-    pub id: hir::HirId,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub def: &'hir hir::VariantData<'hir>,\n-    pub span: Span,\n+crate struct Variant<'hir> {\n+    crate name: Symbol,\n+    crate id: hir::HirId,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate def: &'hir hir::VariantData<'hir>,\n+    crate span: Span,\n }\n \n-pub struct Function<'hir> {\n-    pub decl: &'hir hir::FnDecl<'hir>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub id: hir::HirId,\n-    pub name: Symbol,\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub header: hir::FnHeader,\n-    pub span: Span,\n-    pub generics: &'hir hir::Generics<'hir>,\n-    pub body: hir::BodyId,\n+crate struct Function<'hir> {\n+    crate decl: &'hir hir::FnDecl<'hir>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate id: hir::HirId,\n+    crate name: Symbol,\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate header: hir::FnHeader,\n+    crate span: Span,\n+    crate generics: &'hir hir::Generics<'hir>,\n+    crate body: hir::BodyId,\n }\n \n-pub struct Typedef<'hir> {\n-    pub ty: &'hir hir::Ty<'hir>,\n-    pub gen: &'hir hir::Generics<'hir>,\n-    pub name: Symbol,\n-    pub id: hir::HirId,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub span: Span,\n-    pub vis: &'hir hir::Visibility<'hir>,\n+crate struct Typedef<'hir> {\n+    crate ty: &'hir hir::Ty<'hir>,\n+    crate gen: &'hir hir::Generics<'hir>,\n+    crate name: Symbol,\n+    crate id: hir::HirId,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate span: Span,\n+    crate vis: &'hir hir::Visibility<'hir>,\n }\n \n-pub struct OpaqueTy<'hir> {\n-    pub opaque_ty: &'hir hir::OpaqueTy<'hir>,\n-    pub name: Symbol,\n-    pub id: hir::HirId,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub span: Span,\n-    pub vis: &'hir hir::Visibility<'hir>,\n+crate struct OpaqueTy<'hir> {\n+    crate opaque_ty: &'hir hir::OpaqueTy<'hir>,\n+    crate name: Symbol,\n+    crate id: hir::HirId,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate span: Span,\n+    crate vis: &'hir hir::Visibility<'hir>,\n }\n \n #[derive(Debug)]\n-pub struct Static<'hir> {\n-    pub type_: &'hir hir::Ty<'hir>,\n-    pub mutability: hir::Mutability,\n-    pub expr: hir::BodyId,\n-    pub name: Symbol,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub id: hir::HirId,\n-    pub span: Span,\n+crate struct Static<'hir> {\n+    crate type_: &'hir hir::Ty<'hir>,\n+    crate mutability: hir::Mutability,\n+    crate expr: hir::BodyId,\n+    crate name: Symbol,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate id: hir::HirId,\n+    crate span: Span,\n }\n \n-pub struct Constant<'hir> {\n-    pub type_: &'hir hir::Ty<'hir>,\n-    pub expr: hir::BodyId,\n-    pub name: Symbol,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub id: hir::HirId,\n-    pub span: Span,\n+crate struct Constant<'hir> {\n+    crate type_: &'hir hir::Ty<'hir>,\n+    crate expr: hir::BodyId,\n+    crate name: Symbol,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate id: hir::HirId,\n+    crate span: Span,\n }\n \n-pub struct Trait<'hir> {\n-    pub is_auto: hir::IsAuto,\n-    pub unsafety: hir::Unsafety,\n-    pub name: Symbol,\n-    pub items: Vec<&'hir hir::TraitItem<'hir>>,\n-    pub generics: &'hir hir::Generics<'hir>,\n-    pub bounds: &'hir [hir::GenericBound<'hir>],\n-    pub attrs: &'hir [ast::Attribute],\n-    pub id: hir::HirId,\n-    pub span: Span,\n-    pub vis: &'hir hir::Visibility<'hir>,\n+crate struct Trait<'hir> {\n+    crate is_auto: hir::IsAuto,\n+    crate unsafety: hir::Unsafety,\n+    crate name: Symbol,\n+    crate items: Vec<&'hir hir::TraitItem<'hir>>,\n+    crate generics: &'hir hir::Generics<'hir>,\n+    crate bounds: &'hir [hir::GenericBound<'hir>],\n+    crate attrs: &'hir [ast::Attribute],\n+    crate id: hir::HirId,\n+    crate span: Span,\n+    crate vis: &'hir hir::Visibility<'hir>,\n }\n \n-pub struct TraitAlias<'hir> {\n-    pub name: Symbol,\n-    pub generics: &'hir hir::Generics<'hir>,\n-    pub bounds: &'hir [hir::GenericBound<'hir>],\n-    pub attrs: &'hir [ast::Attribute],\n-    pub id: hir::HirId,\n-    pub span: Span,\n-    pub vis: &'hir hir::Visibility<'hir>,\n+crate struct TraitAlias<'hir> {\n+    crate name: Symbol,\n+    crate generics: &'hir hir::Generics<'hir>,\n+    crate bounds: &'hir [hir::GenericBound<'hir>],\n+    crate attrs: &'hir [ast::Attribute],\n+    crate id: hir::HirId,\n+    crate span: Span,\n+    crate vis: &'hir hir::Visibility<'hir>,\n }\n \n #[derive(Debug)]\n-pub struct Impl<'hir> {\n-    pub unsafety: hir::Unsafety,\n-    pub polarity: hir::ImplPolarity,\n-    pub defaultness: hir::Defaultness,\n-    pub constness: hir::Constness,\n-    pub generics: &'hir hir::Generics<'hir>,\n-    pub trait_: &'hir Option<hir::TraitRef<'hir>>,\n-    pub for_: &'hir hir::Ty<'hir>,\n-    pub items: Vec<&'hir hir::ImplItem<'hir>>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub span: Span,\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub id: hir::HirId,\n+crate struct Impl<'hir> {\n+    crate unsafety: hir::Unsafety,\n+    crate polarity: hir::ImplPolarity,\n+    crate defaultness: hir::Defaultness,\n+    crate constness: hir::Constness,\n+    crate generics: &'hir hir::Generics<'hir>,\n+    crate trait_: &'hir Option<hir::TraitRef<'hir>>,\n+    crate for_: &'hir hir::Ty<'hir>,\n+    crate items: Vec<&'hir hir::ImplItem<'hir>>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate span: Span,\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate id: hir::HirId,\n }\n \n-pub struct ForeignItem<'hir> {\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub id: hir::HirId,\n-    pub name: Symbol,\n-    pub kind: &'hir hir::ForeignItemKind<'hir>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub span: Span,\n+crate struct ForeignItem<'hir> {\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate id: hir::HirId,\n+    crate name: Symbol,\n+    crate kind: &'hir hir::ForeignItemKind<'hir>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate span: Span,\n }\n \n // For Macro we store the DefId instead of the NodeId, since we also create\n // these imported macro_rules (which only have a DUMMY_NODE_ID).\n-pub struct Macro<'hir> {\n-    pub name: Symbol,\n-    pub hid: hir::HirId,\n-    pub def_id: hir::def_id::DefId,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub span: Span,\n-    pub matchers: Vec<Span>,\n-    pub imported_from: Option<Symbol>,\n+crate struct Macro<'hir> {\n+    crate name: Symbol,\n+    crate hid: hir::HirId,\n+    crate def_id: hir::def_id::DefId,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate span: Span,\n+    crate matchers: Vec<Span>,\n+    crate imported_from: Option<Symbol>,\n }\n \n-pub struct ExternCrate<'hir> {\n-    pub name: Symbol,\n-    pub hir_id: HirId,\n-    pub cnum: CrateNum,\n-    pub path: Option<String>,\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub span: Span,\n+crate struct ExternCrate<'hir> {\n+    crate name: Symbol,\n+    crate hir_id: HirId,\n+    crate cnum: CrateNum,\n+    crate path: Option<String>,\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate span: Span,\n }\n \n #[derive(Debug)]\n-pub struct Import<'hir> {\n-    pub name: Symbol,\n-    pub id: hir::HirId,\n-    pub vis: &'hir hir::Visibility<'hir>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub path: &'hir hir::Path<'hir>,\n-    pub glob: bool,\n-    pub span: Span,\n+crate struct Import<'hir> {\n+    crate name: Symbol,\n+    crate id: hir::HirId,\n+    crate vis: &'hir hir::Visibility<'hir>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate path: &'hir hir::Path<'hir>,\n+    crate glob: bool,\n+    crate span: Span,\n }\n \n-pub struct ProcMacro<'hir> {\n-    pub name: Symbol,\n-    pub id: hir::HirId,\n-    pub kind: MacroKind,\n-    pub helpers: Vec<Symbol>,\n-    pub attrs: &'hir [ast::Attribute],\n-    pub span: Span,\n+crate struct ProcMacro<'hir> {\n+    crate name: Symbol,\n+    crate id: hir::HirId,\n+    crate kind: MacroKind,\n+    crate helpers: Vec<Symbol>,\n+    crate attrs: &'hir [ast::Attribute],\n+    crate span: Span,\n }\n \n-pub fn struct_type_from_def(vdata: &hir::VariantData<'_>) -> StructType {\n+crate fn struct_type_from_def(vdata: &hir::VariantData<'_>) -> StructType {\n     match *vdata {\n         hir::VariantData::Struct(..) => Plain,\n         hir::VariantData::Tuple(..) => Tuple,"}, {"sha": "82d0002b98b180d2ae514314740d8d6fd714d4a6", "filename": "src/librustdoc/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ferror.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -5,9 +5,9 @@ use std::path::{Path, PathBuf};\n use crate::docfs::PathError;\n \n #[derive(Debug)]\n-pub struct Error {\n-    pub file: PathBuf,\n-    pub error: String,\n+crate struct Error {\n+    crate file: PathBuf,\n+    crate error: String,\n }\n \n impl error::Error for Error {}"}, {"sha": "6c86baa36ac7de8dbf9e1f10e3d1c0306756c290", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -5,20 +5,20 @@ use std::path::Path;\n use std::str;\n \n #[derive(Clone, Debug)]\n-pub struct ExternalHtml {\n+crate struct ExternalHtml {\n     /// Content that will be included inline in the <head> section of a\n     /// rendered Markdown file or generated documentation\n-    pub in_header: String,\n+    crate in_header: String,\n     /// Content that will be included inline between <body> and the content of\n     /// a rendered Markdown file or generated documentation\n-    pub before_content: String,\n+    crate before_content: String,\n     /// Content that will be included inline between the content and </body> of\n     /// a rendered Markdown file or generated documentation\n-    pub after_content: String,\n+    crate after_content: String,\n }\n \n impl ExternalHtml {\n-    pub fn load(\n+    crate fn load(\n         in_header: &[String],\n         before_content: &[String],\n         after_content: &[String],\n@@ -50,12 +50,12 @@ impl ExternalHtml {\n     }\n }\n \n-pub enum LoadStringError {\n+crate enum LoadStringError {\n     ReadFail,\n     BadUtf8,\n }\n \n-pub fn load_string<P: AsRef<Path>>(\n+crate fn load_string<P: AsRef<Path>>(\n     file_path: P,\n     diag: &rustc_errors::Handler,\n ) -> Result<String, LoadStringError> {"}, {"sha": "a72860ef0a8fd1f01c3f4cf0bf48842ef6e9999d", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -1,9 +1,9 @@\n use crate::clean::*;\n \n-pub struct StripItem(pub Item);\n+crate struct StripItem(pub Item);\n \n impl StripItem {\n-    pub fn strip(self) -> Option<Item> {\n+    crate fn strip(self) -> Option<Item> {\n         match self.0 {\n             Item { kind: StrippedItem(..), .. } => Some(self.0),\n             mut i => {\n@@ -14,7 +14,7 @@ impl StripItem {\n     }\n }\n \n-pub trait DocFolder: Sized {\n+crate trait DocFolder: Sized {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n         self.fold_item_recur(item)\n     }"}, {"sha": "917c1a95fdbf5c5e1f3050ea374e8f1b2c9c7d73", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -30,25 +30,25 @@ thread_local!(crate static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n /// to `Send` so it may be stored in a `Arc` instance and shared among the various\n /// rendering threads.\n #[derive(Default)]\n-pub struct Cache {\n+crate struct Cache {\n     /// Maps a type ID to all known implementations for that type. This is only\n     /// recognized for intra-crate `ResolvedPath` types, and is used to print\n     /// out extra documentation on the page of an enum/struct.\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    pub impls: FxHashMap<DefId, Vec<Impl>>,\n+    crate impls: FxHashMap<DefId, Vec<Impl>>,\n \n     /// Maintains a mapping of local crate `DefId`s to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+    crate paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n \n     /// Similar to `paths`, but only holds external paths. This is only used for\n     /// generating explicit hyperlinks to other crates.\n-    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+    crate external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n \n     /// Maps local `DefId`s of exported types to fully qualified paths.\n     /// Unlike 'paths', this mapping ignores any renames that occur\n@@ -60,36 +60,36 @@ pub struct Cache {\n     /// to the path used if the corresponding type is inlined. By\n     /// doing this, we can detect duplicate impls on a trait page, and only display\n     /// the impl for the inlined type.\n-    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n+    crate exact_paths: FxHashMap<DefId, Vec<String>>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n     /// parent trait if no extra documentation is specified, and default methods\n     /// should show up in documentation about trait implementations.\n-    pub traits: FxHashMap<DefId, clean::Trait>,\n+    crate traits: FxHashMap<DefId, clean::Trait>,\n \n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n+    crate implementors: FxHashMap<DefId, Vec<Impl>>,\n \n     /// Cache of where external crate documentation can be found.\n-    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n+    crate extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n \n     /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n+    crate primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n \n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n     // the access levels from the privacy check pass.\n-    pub access_levels: AccessLevels<DefId>,\n+    crate access_levels: AccessLevels<DefId>,\n \n     /// The version of the crate being documented, if given from the `--crate-version` flag.\n-    pub crate_version: Option<String>,\n+    crate crate_version: Option<String>,\n \n     /// Whether to document private items.\n     /// This is stored in `Cache` so it doesn't need to be passed through all rustdoc functions.\n-    pub document_private: bool,\n+    crate document_private: bool,\n \n     // Private fields only used when initially crawling a crate to build a cache\n     stack: Vec<String>,\n@@ -98,17 +98,17 @@ pub struct Cache {\n     stripped_mod: bool,\n     masked_crates: FxHashSet<CrateNum>,\n \n-    pub search_index: Vec<IndexItem>,\n-    pub deref_trait_did: Option<DefId>,\n-    pub deref_mut_trait_did: Option<DefId>,\n-    pub owned_box_did: Option<DefId>,\n+    crate search_index: Vec<IndexItem>,\n+    crate deref_trait_did: Option<DefId>,\n+    crate deref_mut_trait_did: Option<DefId>,\n+    crate owned_box_did: Option<DefId>,\n \n     // In rare case where a structure is defined in one module but implemented\n     // in another, if the implementing module is parsed before defining module,\n     // then the fully qualified name of the structure isn't presented in `paths`\n     // yet when its implementation methods are being indexed. Caches such methods\n     // and their parent id here and indexes them at the end of crate parsing.\n-    pub orphan_impl_items: Vec<(DefId, clean::Item)>,\n+    crate orphan_impl_items: Vec<(DefId, clean::Item)>,\n \n     // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n     // even though the trait itself is not exported. This can happen if a trait\n@@ -121,11 +121,11 @@ pub struct Cache {\n \n     /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n     /// we need the alias element to have an array of items.\n-    pub aliases: BTreeMap<String, Vec<usize>>,\n+    crate aliases: BTreeMap<String, Vec<usize>>,\n }\n \n impl Cache {\n-    pub fn from_krate(\n+    crate fn from_krate(\n         render_info: RenderInfo,\n         document_private: bool,\n         extern_html_root_urls: &BTreeMap<String, String>,"}, {"sha": "af512e3746092683c5a9616c5f1a64f2a9602ae8", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -20,7 +20,7 @@ use crate::clean;\n /// a heading, edit the listing in `html/render.rs`, function `sidebar_module`. This uses an\n /// ordering based on a helper function inside `item_module`, in the same file.\n #[derive(Copy, PartialEq, Eq, Clone, Debug, PartialOrd, Ord)]\n-pub enum ItemType {\n+crate enum ItemType {\n     Module = 0,\n     ExternCrate = 1,\n     Import = 2,\n@@ -124,7 +124,7 @@ impl From<clean::TypeKind> for ItemType {\n }\n \n impl ItemType {\n-    pub fn as_str(&self) -> &'static str {\n+    crate fn as_str(&self) -> &'static str {\n         match *self {\n             ItemType::Module => \"mod\",\n             ItemType::ExternCrate => \"externcrate\","}, {"sha": "55fd4948f45272299f10c22cdd959ab13c0576fe", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -1,8 +1,8 @@\n-pub mod cache;\n-pub mod item_type;\n-pub mod renderer;\n+crate mod cache;\n+crate mod item_type;\n+crate mod renderer;\n \n-pub use renderer::{run_format, FormatRenderer};\n+crate use renderer::{run_format, FormatRenderer};\n \n use rustc_span::def_id::DefId;\n \n@@ -11,34 +11,34 @@ use crate::clean::types::GetDefId;\n \n /// Specifies whether rendering directly implemented trait items or ones from a certain Deref\n /// impl.\n-pub enum AssocItemRender<'a> {\n+crate enum AssocItemRender<'a> {\n     All,\n     DerefFor { trait_: &'a clean::Type, type_: &'a clean::Type, deref_mut_: bool },\n }\n \n /// For different handling of associated items from the Deref target of a type rather than the type\n /// itself.\n #[derive(Copy, Clone, PartialEq)]\n-pub enum RenderMode {\n+crate enum RenderMode {\n     Normal,\n     ForDeref { mut_: bool },\n }\n \n /// Metadata about implementations for a type or trait.\n #[derive(Clone, Debug)]\n-pub struct Impl {\n-    pub impl_item: clean::Item,\n+crate struct Impl {\n+    crate impl_item: clean::Item,\n }\n \n impl Impl {\n-    pub fn inner_impl(&self) -> &clean::Impl {\n+    crate fn inner_impl(&self) -> &clean::Impl {\n         match self.impl_item.kind {\n             clean::ImplItem(ref impl_) => impl_,\n             _ => panic!(\"non-impl item found in impl\"),\n         }\n     }\n \n-    pub fn trait_did(&self) -> Option<DefId> {\n+    crate fn trait_did(&self) -> Option<DefId> {\n         self.inner_impl().trait_.def_id()\n     }\n }"}, {"sha": "d0fdc69cc1932752574a796512635cc6a0b1b705", "filename": "src/librustdoc/formats/renderer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -10,7 +10,7 @@ use crate::formats::cache::{Cache, CACHE_KEY};\n /// Allows for different backends to rustdoc to be used with the `run_format()` function. Each\n /// backend renderer has hooks for initialization, documenting an item, entering and exiting a\n /// module, and cleanup/finalizing output.\n-pub trait FormatRenderer: Clone {\n+crate trait FormatRenderer: Clone {\n     /// Sets up any state required for the renderer. When this is called the cache has already been\n     /// populated.\n     fn init(\n@@ -43,7 +43,7 @@ pub trait FormatRenderer: Clone {\n }\n \n /// Main method for rendering a crate.\n-pub fn run_format<T: FormatRenderer>(\n+crate fn run_format<T: FormatRenderer>(\n     krate: clean::Crate,\n     options: RenderOptions,\n     render_info: RenderInfo,"}, {"sha": "60c19551983cdf577b15dd3d44e518b67be957f4", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -7,7 +7,7 @@ use std::fmt;\n \n /// Wrapper struct which will emit the HTML-escaped version of the contained\n /// string when passed to a format string.\n-pub struct Escape<'a>(pub &'a str);\n+crate struct Escape<'a>(pub &'a str);\n \n impl<'a> fmt::Display for Escape<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "d2722ed1cd23115f42ada67681fb69ada8c3122e", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -21,7 +21,7 @@ use crate::html::escape::Escape;\n use crate::html::render::cache::ExternalLocation;\n use crate::html::render::CURRENT_DEPTH;\n \n-pub trait Print {\n+crate trait Print {\n     fn print(self, buffer: &mut Buffer);\n }\n \n@@ -47,7 +47,7 @@ impl Print for &'_ str {\n }\n \n #[derive(Debug, Clone)]\n-pub struct Buffer {\n+crate struct Buffer {\n     for_html: bool,\n     buffer: String,\n }\n@@ -115,28 +115,28 @@ impl Buffer {\n }\n \n /// Wrapper struct for properly emitting a function or method declaration.\n-pub struct Function<'a> {\n+crate struct Function<'a> {\n     /// The declaration to emit.\n-    pub decl: &'a clean::FnDecl,\n+    crate decl: &'a clean::FnDecl,\n     /// The length of the function header and name. In other words, the number of characters in the\n     /// function declaration up to but not including the parentheses.\n     ///\n     /// Used to determine line-wrapping.\n-    pub header_len: usize,\n+    crate header_len: usize,\n     /// The number of spaces to indent each successive line with, if line-wrapping is necessary.\n-    pub indent: usize,\n+    crate indent: usize,\n     /// Whether the function is async or not.\n-    pub asyncness: hir::IsAsync,\n+    crate asyncness: hir::IsAsync,\n }\n \n /// Wrapper struct for emitting a where-clause from Generics.\n-pub struct WhereClause<'a> {\n+crate struct WhereClause<'a> {\n     /// The Generics from which to emit a where-clause.\n-    pub gens: &'a clean::Generics,\n+    crate gens: &'a clean::Generics,\n     /// The number of spaces to indent each line with.\n-    pub indent: usize,\n+    crate indent: usize,\n     /// Whether the where-clause needs to add a comma and newline after the last bound.\n-    pub end_newline: bool,\n+    crate end_newline: bool,\n }\n \n fn comma_sep<T: fmt::Display>(items: impl Iterator<Item = T>) -> impl fmt::Display {\n@@ -480,7 +480,7 @@ impl clean::Path {\n     }\n }\n \n-pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n+crate fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n     let cache = cache();\n     if !did.is_local() && !cache.access_levels.is_public(did) && !cache.document_private {\n         return None;\n@@ -618,7 +618,7 @@ fn tybounds(param_names: &Option<Vec<clean::GenericBound>>) -> impl fmt::Display\n     })\n }\n \n-pub fn anchor(did: DefId, text: &str) -> impl fmt::Display + '_ {\n+crate fn anchor(did: DefId, text: &str) -> impl fmt::Display + '_ {\n     display_fn(move |f| {\n         if let Some((url, short_ty, fqp)) = href(did) {\n             write!(\n@@ -910,7 +910,7 @@ impl clean::Impl {\n }\n \n // The difference from above is that trait is not hyperlinked.\n-pub fn fmt_impl_for_trait_page(i: &clean::Impl, f: &mut Buffer, use_absolute: bool) {\n+crate fn fmt_impl_for_trait_page(i: &clean::Impl, f: &mut Buffer, use_absolute: bool) {\n     f.from_display(i.print_inner(false, use_absolute))\n }\n "}, {"sha": "22233731411508be24c0d1cb079c04afafe50e4e", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -15,7 +15,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::with_default_session_globals;\n \n /// Highlights `src`, returning the HTML output.\n-pub fn render_with_highlighting(\n+crate fn render_with_highlighting(\n     src: String,\n     class: Option<&str>,\n     playground_button: Option<&str>,"}, {"sha": "e8039942f4f8325a0374bd917fb53ce00afcd3b4", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -7,33 +7,33 @@ use crate::html::format::{Buffer, Print};\n use crate::html::render::{ensure_trailing_slash, StylePath};\n \n #[derive(Clone)]\n-pub struct Layout {\n-    pub logo: String,\n-    pub favicon: String,\n-    pub external_html: ExternalHtml,\n-    pub default_settings: HashMap<String, String>,\n-    pub krate: String,\n+crate struct Layout {\n+    crate logo: String,\n+    crate favicon: String,\n+    crate external_html: ExternalHtml,\n+    crate default_settings: HashMap<String, String>,\n+    crate krate: String,\n     /// The given user css file which allow to customize the generated\n     /// documentation theme.\n-    pub css_file_extension: Option<PathBuf>,\n+    crate css_file_extension: Option<PathBuf>,\n     /// If false, the `select` element to have search filtering by crates on rendered docs\n     /// won't be generated.\n-    pub generate_search_filter: bool,\n+    crate generate_search_filter: bool,\n }\n \n-pub struct Page<'a> {\n-    pub title: &'a str,\n-    pub css_class: &'a str,\n-    pub root_path: &'a str,\n-    pub static_root_path: Option<&'a str>,\n-    pub description: &'a str,\n-    pub keywords: &'a str,\n-    pub resource_suffix: &'a str,\n-    pub extra_scripts: &'a [&'a str],\n-    pub static_extra_scripts: &'a [&'a str],\n+crate struct Page<'a> {\n+    crate title: &'a str,\n+    crate css_class: &'a str,\n+    crate root_path: &'a str,\n+    crate static_root_path: Option<&'a str>,\n+    crate description: &'a str,\n+    crate keywords: &'a str,\n+    crate resource_suffix: &'a str,\n+    crate extra_scripts: &'a [&'a str],\n+    crate static_extra_scripts: &'a [&'a str],\n }\n \n-pub fn render<T: Print, S: Print>(\n+crate fn render<T: Print, S: Print>(\n     layout: &Layout,\n     page: &Page<'_>,\n     sidebar: S,\n@@ -228,7 +228,7 @@ pub fn render<T: Print, S: Print>(\n     )\n }\n \n-pub fn redirect(url: &str) -> String {\n+crate fn redirect(url: &str) -> String {\n     // <script> triggers a redirect before refresh, so this is fine.\n     format!(\n         r##\"<!DOCTYPE html>"}, {"sha": "6165c36424b52d6e8f1e4c7f83e025e6095c51db", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -49,52 +49,52 @@ pub(crate) fn opts() -> Options {\n \n /// When `to_string` is called, this struct will emit the HTML corresponding to\n /// the rendered version of the contained markdown string.\n-pub struct Markdown<'a>(\n-    pub &'a str,\n+crate struct Markdown<'a>(\n+    crate &'a str,\n     /// A list of link replacements.\n-    pub &'a [RenderedLink],\n+    crate &'a [RenderedLink],\n     /// The current list of used header IDs.\n-    pub &'a mut IdMap,\n+    crate &'a mut IdMap,\n     /// Whether to allow the use of explicit error codes in doctest lang strings.\n-    pub ErrorCodes,\n+    crate ErrorCodes,\n     /// Default edition to use when parsing doctests (to add a `fn main`).\n-    pub Edition,\n-    pub &'a Option<Playground>,\n+    crate Edition,\n+    crate &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders the markdown with a table of contents.\n-pub struct MarkdownWithToc<'a>(\n-    pub &'a str,\n-    pub &'a mut IdMap,\n-    pub ErrorCodes,\n-    pub Edition,\n-    pub &'a Option<Playground>,\n+crate struct MarkdownWithToc<'a>(\n+    crate &'a str,\n+    crate &'a mut IdMap,\n+    crate ErrorCodes,\n+    crate Edition,\n+    crate &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders the markdown escaping HTML tags.\n-pub struct MarkdownHtml<'a>(\n-    pub &'a str,\n-    pub &'a mut IdMap,\n-    pub ErrorCodes,\n-    pub Edition,\n-    pub &'a Option<Playground>,\n+crate struct MarkdownHtml<'a>(\n+    crate &'a str,\n+    crate &'a mut IdMap,\n+    crate ErrorCodes,\n+    crate Edition,\n+    crate &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders only the first paragraph.\n-pub struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [RenderedLink]);\n+crate struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [RenderedLink]);\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum ErrorCodes {\n+crate enum ErrorCodes {\n     Yes,\n     No,\n }\n \n impl ErrorCodes {\n-    pub fn from(b: bool) -> Self {\n+    crate fn from(b: bool) -> Self {\n         match b {\n             true => ErrorCodes::Yes,\n             false => ErrorCodes::No,\n         }\n     }\n \n-    pub fn as_bool(self) -> bool {\n+    crate fn as_bool(self) -> bool {\n         match self {\n             ErrorCodes::Yes => true,\n             ErrorCodes::No => false,\n@@ -160,9 +160,9 @@ fn slugify(c: char) -> Option<char> {\n }\n \n #[derive(Clone, Debug)]\n-pub struct Playground {\n-    pub crate_name: Option<String>,\n-    pub url: String,\n+crate struct Playground {\n+    crate crate_name: Option<String>,\n+    crate url: String,\n }\n \n /// Adds syntax highlighting and playground Run buttons to Rust code blocks.\n@@ -643,7 +643,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n     }\n }\n \n-pub fn find_testable_code<T: doctest::Tester>(\n+crate fn find_testable_code<T: doctest::Tester>(\n     doc: &str,\n     tests: &mut T,\n     error_codes: ErrorCodes,\n@@ -709,19 +709,19 @@ pub fn find_testable_code<T: doctest::Tester>(\n     }\n }\n \n-pub struct ExtraInfo<'a, 'b> {\n+crate struct ExtraInfo<'a, 'b> {\n     hir_id: Option<HirId>,\n     item_did: Option<DefId>,\n     sp: Span,\n     tcx: &'a TyCtxt<'b>,\n }\n \n impl<'a, 'b> ExtraInfo<'a, 'b> {\n-    pub fn new(tcx: &'a TyCtxt<'b>, hir_id: HirId, sp: Span) -> ExtraInfo<'a, 'b> {\n+    crate fn new(tcx: &'a TyCtxt<'b>, hir_id: HirId, sp: Span) -> ExtraInfo<'a, 'b> {\n         ExtraInfo { hir_id: Some(hir_id), item_did: None, sp, tcx }\n     }\n \n-    pub fn new_did(tcx: &'a TyCtxt<'b>, did: DefId, sp: Span) -> ExtraInfo<'a, 'b> {\n+    crate fn new_did(tcx: &'a TyCtxt<'b>, did: DefId, sp: Span) -> ExtraInfo<'a, 'b> {\n         ExtraInfo { hir_id: None, item_did: Some(did), sp, tcx }\n     }\n \n@@ -753,21 +753,21 @@ impl<'a, 'b> ExtraInfo<'a, 'b> {\n }\n \n #[derive(Eq, PartialEq, Clone, Debug)]\n-pub struct LangString {\n+crate struct LangString {\n     original: String,\n-    pub should_panic: bool,\n-    pub no_run: bool,\n-    pub ignore: Ignore,\n-    pub rust: bool,\n-    pub test_harness: bool,\n-    pub compile_fail: bool,\n-    pub error_codes: Vec<String>,\n-    pub allow_fail: bool,\n-    pub edition: Option<Edition>,\n+    crate should_panic: bool,\n+    crate no_run: bool,\n+    crate ignore: Ignore,\n+    crate rust: bool,\n+    crate test_harness: bool,\n+    crate compile_fail: bool,\n+    crate error_codes: Vec<String>,\n+    crate allow_fail: bool,\n+    crate edition: Option<Edition>,\n }\n \n #[derive(Eq, PartialEq, Clone, Debug)]\n-pub enum Ignore {\n+crate enum Ignore {\n     All,\n     None,\n     Some(Vec<String>),\n@@ -923,7 +923,7 @@ impl LangString {\n }\n \n impl Markdown<'_> {\n-    pub fn into_string(self) -> String {\n+    crate fn into_string(self) -> String {\n         let Markdown(md, links, mut ids, codes, edition, playground) = self;\n \n         // This is actually common enough to special-case\n@@ -955,7 +955,7 @@ impl Markdown<'_> {\n }\n \n impl MarkdownWithToc<'_> {\n-    pub fn into_string(self) -> String {\n+    crate fn into_string(self) -> String {\n         let MarkdownWithToc(md, mut ids, codes, edition, playground) = self;\n \n         let p = Parser::new_ext(md, opts());\n@@ -976,7 +976,7 @@ impl MarkdownWithToc<'_> {\n }\n \n impl MarkdownHtml<'_> {\n-    pub fn into_string(self) -> String {\n+    crate fn into_string(self) -> String {\n         let MarkdownHtml(md, mut ids, codes, edition, playground) = self;\n \n         // This is actually common enough to special-case\n@@ -1003,7 +1003,7 @@ impl MarkdownHtml<'_> {\n }\n \n impl MarkdownSummaryLine<'_> {\n-    pub fn into_string(self) -> String {\n+    crate fn into_string(self) -> String {\n         let MarkdownSummaryLine(md, links) = self;\n         // This is actually common enough to special-case\n         if md.is_empty() {\n@@ -1039,7 +1039,7 @@ impl MarkdownSummaryLine<'_> {\n /// - Headings, links, and formatting are stripped.\n /// - Inline code is rendered as-is, surrounded by backticks.\n /// - HTML and code blocks are ignored.\n-pub fn plain_text_summary(md: &str) -> String {\n+crate fn plain_text_summary(md: &str) -> String {\n     if md.is_empty() {\n         return String::new();\n     }\n@@ -1064,7 +1064,7 @@ pub fn plain_text_summary(md: &str) -> String {\n     s\n }\n \n-pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n+crate fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n     if md.is_empty() {\n         return vec![];\n     }\n@@ -1120,11 +1120,11 @@ pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n crate struct RustCodeBlock {\n     /// The range in the markdown that the code block occupies. Note that this includes the fences\n     /// for fenced code blocks.\n-    pub range: Range<usize>,\n+    crate range: Range<usize>,\n     /// The range in the markdown that the code within the code block occupies.\n-    pub code: Range<usize>,\n-    pub is_fenced: bool,\n-    pub syntax: Option<String>,\n+    crate code: Range<usize>,\n+    crate is_fenced: bool,\n+    crate syntax: Option<String>,\n }\n \n /// Returns a range of bytes for each code block in the markdown that is tagged as `rust` or\n@@ -1210,7 +1210,7 @@ crate fn rust_code_blocks(md: &str, extra_info: &ExtraInfo<'_, '_>) -> Vec<RustC\n }\n \n #[derive(Clone, Default, Debug)]\n-pub struct IdMap {\n+crate struct IdMap {\n     map: FxHashMap<String, usize>,\n }\n \n@@ -1243,21 +1243,21 @@ fn init_id_map() -> FxHashMap<String, usize> {\n }\n \n impl IdMap {\n-    pub fn new() -> Self {\n+    crate fn new() -> Self {\n         IdMap { map: init_id_map() }\n     }\n \n-    pub fn populate<I: IntoIterator<Item = String>>(&mut self, ids: I) {\n+    crate fn populate<I: IntoIterator<Item = String>>(&mut self, ids: I) {\n         for id in ids {\n             let _ = self.derive(id);\n         }\n     }\n \n-    pub fn reset(&mut self) {\n+    crate fn reset(&mut self) {\n         self.map = init_id_map();\n     }\n \n-    pub fn derive(&mut self, candidate: String) -> String {\n+    crate fn derive(&mut self, candidate: String) -> String {\n         let id = match self.map.get_mut(&candidate) {\n             None => candidate,\n             Some(a) => {"}, {"sha": "6e088cee5fd4350b96c7f0cddf4bf22e806872df", "filename": "src/librustdoc/html/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmod.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -2,8 +2,8 @@ crate mod escape;\n crate mod format;\n crate mod highlight;\n crate mod layout;\n-pub mod markdown;\n-pub mod render;\n+crate mod markdown;\n+crate mod render;\n crate mod sources;\n crate mod static_files;\n crate mod toc;"}, {"sha": "cef9b8952dd7d0b4f4324b2bb613b374e98ae1a8", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -13,7 +13,7 @@ use crate::html::render::{plain_text_summary, shorten};\n use crate::html::render::{Generic, IndexItem, IndexItemFunctionType, RenderType, TypeWithKind};\n \n /// Indicates where an external crate can be found.\n-pub enum ExternalLocation {\n+crate enum ExternalLocation {\n     /// Remote URL root of the external crate\n     Remote(String),\n     /// This external crate can be found in the local doc/ folder\n@@ -24,7 +24,7 @@ pub enum ExternalLocation {\n \n /// Attempts to find where an external crate is located, given that we're\n /// rendering in to the specified source destination.\n-pub fn extern_location(\n+crate fn extern_location(\n     e: &clean::ExternalCrate,\n     extern_url: Option<&str>,\n     dst: &Path,\n@@ -62,7 +62,7 @@ pub fn extern_location(\n }\n \n /// Builds the search index from the collected metadata\n-pub fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n+crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let mut defid_to_pathid = FxHashMap::default();\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n     let mut crate_paths = vec![];"}, {"sha": "c82c289bc22b4d0f0130a5017192be684f57e312", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -25,7 +25,7 @@\n //! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n-pub mod cache;\n+crate mod cache;\n \n #[cfg(test)]\n mod tests;\n@@ -82,7 +82,7 @@ use crate::html::{highlight, layout, static_files};\n use cache::{build_index, ExternalLocation};\n \n /// A pair of name and its optional document.\n-pub type NameDoc = (String, Option<String>);\n+crate type NameDoc = (String, Option<String>);\n \n crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n     crate::html::format::display_fn(move |f| {\n@@ -101,60 +101,60 @@ crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n crate struct Context {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n-    pub current: Vec<String>,\n+    crate current: Vec<String>,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n-    pub dst: PathBuf,\n+    crate dst: PathBuf,\n     /// A flag, which when `true`, will render pages which redirect to the\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n-    pub render_redirect_pages: bool,\n+    crate render_redirect_pages: bool,\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     id_map: Rc<RefCell<IdMap>>,\n-    pub shared: Arc<SharedContext>,\n+    crate shared: Arc<SharedContext>,\n     all: Rc<RefCell<AllTypes>>,\n     /// Storage for the errors produced while generating documentation so they\n     /// can be printed together at the end.\n-    pub errors: Rc<Receiver<String>>,\n+    crate errors: Rc<Receiver<String>>,\n }\n \n crate struct SharedContext {\n     /// The path to the crate root source minus the file name.\n     /// Used for simplifying paths to the highlighted source code files.\n-    pub src_root: PathBuf,\n+    crate src_root: PathBuf,\n     /// This describes the layout of each page, and is not modified after\n     /// creation of the context (contains info like the favicon and added html).\n-    pub layout: layout::Layout,\n+    crate layout: layout::Layout,\n     /// This flag indicates whether `[src]` links should be generated or not. If\n     /// the source files are present in the html rendering, then this will be\n     /// `true`.\n-    pub include_sources: bool,\n+    crate include_sources: bool,\n     /// The local file sources we've emitted and their respective url-paths.\n-    pub local_sources: FxHashMap<PathBuf, String>,\n+    crate local_sources: FxHashMap<PathBuf, String>,\n     /// Whether the collapsed pass ran\n-    pub collapsed: bool,\n+    crate collapsed: bool,\n     /// The base-URL of the issue tracker for when an item has been tagged with\n     /// an issue number.\n-    pub issue_tracker_base_url: Option<String>,\n+    crate issue_tracker_base_url: Option<String>,\n     /// The directories that have already been created in this doc run. Used to reduce the number\n     /// of spurious `create_dir_all` calls.\n-    pub created_dirs: RefCell<FxHashSet<PathBuf>>,\n+    crate created_dirs: RefCell<FxHashSet<PathBuf>>,\n     /// This flag indicates whether listings of modules (in the side bar and documentation itself)\n     /// should be ordered alphabetically or in order of appearance (in the source code).\n-    pub sort_modules_alphabetically: bool,\n+    crate sort_modules_alphabetically: bool,\n     /// Additional CSS files to be added to the generated docs.\n-    pub style_files: Vec<StylePath>,\n+    crate style_files: Vec<StylePath>,\n     /// Suffix to be added on resource files (if suffix is \"-v2\" then \"light.css\" becomes\n     /// \"light-v2.css\").\n-    pub resource_suffix: String,\n+    crate resource_suffix: String,\n     /// Optional path string to be used to load static files on output pages. If not set, uses\n     /// combinations of `../` to reach the documentation root.\n-    pub static_root_path: Option<String>,\n+    crate static_root_path: Option<String>,\n     /// The fs handle we are working with.\n-    pub fs: DocFS,\n+    crate fs: DocFS,\n     /// The default edition used to parse doctests.\n-    pub edition: Edition,\n-    pub codes: ErrorCodes,\n+    crate edition: Edition,\n+    crate codes: ErrorCodes,\n     playground: Option<markdown::Playground>,\n }\n \n@@ -186,7 +186,7 @@ impl SharedContext {\n \n     /// Based on whether the `collapse-docs` pass was run, return either the `doc_value` or the\n     /// `collapsed_doc_value` of the given item.\n-    pub fn maybe_collapsed_doc_value<'a>(&self, item: &'a clean::Item) -> Option<Cow<'a, str>> {\n+    crate fn maybe_collapsed_doc_value<'a>(&self, item: &'a clean::Item) -> Option<Cow<'a, str>> {\n         if self.collapsed {\n             item.collapsed_doc_value().map(|s| s.into())\n         } else {\n@@ -201,14 +201,14 @@ impl SharedContext {\n /// Struct representing one entry in the JS search index. These are all emitted\n /// by hand to a large JS file at the end of cache-creation.\n #[derive(Debug)]\n-pub struct IndexItem {\n-    pub ty: ItemType,\n-    pub name: String,\n-    pub path: String,\n-    pub desc: String,\n-    pub parent: Option<DefId>,\n-    pub parent_idx: Option<usize>,\n-    pub search_type: Option<IndexItemFunctionType>,\n+crate struct IndexItem {\n+    crate ty: ItemType,\n+    crate name: String,\n+    crate path: String,\n+    crate desc: String,\n+    crate parent: Option<DefId>,\n+    crate parent_idx: Option<usize>,\n+    crate search_type: Option<IndexItemFunctionType>,\n }\n \n impl Serialize for IndexItem {\n@@ -282,7 +282,7 @@ impl Serialize for Generic {\n \n /// Full type of functions/methods in the search index.\n #[derive(Debug)]\n-pub struct IndexItemFunctionType {\n+crate struct IndexItemFunctionType {\n     inputs: Vec<TypeWithKind>,\n     output: Option<Vec<TypeWithKind>>,\n }\n@@ -340,16 +340,16 @@ impl Serialize for TypeWithKind {\n }\n \n #[derive(Debug, Clone)]\n-pub struct StylePath {\n+crate struct StylePath {\n     /// The path to the theme\n-    pub path: PathBuf,\n+    crate path: PathBuf,\n     /// What the `disabled` attribute should be set to in the HTML tag\n-    pub disabled: bool,\n+    crate disabled: bool,\n }\n \n-thread_local!(pub static CURRENT_DEPTH: Cell<usize> = Cell::new(0));\n+thread_local!(crate static CURRENT_DEPTH: Cell<usize> = Cell::new(0));\n \n-pub fn initial_ids() -> Vec<String> {\n+crate fn initial_ids() -> Vec<String> {\n     [\n         \"main\",\n         \"search\",\n@@ -1701,7 +1701,7 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer, cache: &Cache)\n \n     // Write `src` tag\n     //\n-    // When this item is part of a `pub use` in a downstream crate, the\n+    // When this item is part of a `crate use` in a downstream crate, the\n     // [src] link in the downstream documentation will actually come back to\n     // this page, and this link will be auto-clicked. The `id` attribute is\n     // used to find the link to auto-click.\n@@ -1994,7 +1994,7 @@ fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n }\n \n /// Compare two strings treating multi-digit numbers as single units (i.e. natural sort order).\n-pub fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n+crate fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n     /// Takes a non-numeric and a numeric part from the given &str.\n     fn take_parts<'a>(s: &mut &'a str) -> (&'a str, &'a str) {\n         let i = s.find(|c: char| c.is_ascii_digit());\n@@ -2081,14 +2081,14 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n     // This call is to remove re-export duplicates in cases such as:\n     //\n     // ```\n-    // pub mod foo {\n-    //     pub mod bar {\n-    //         pub trait Double { fn foo(); }\n+    // crate mod foo {\n+    //     crate mod bar {\n+    //         crate trait Double { fn foo(); }\n     //     }\n     // }\n     //\n-    // pub use foo::bar::*;\n-    // pub use foo::*;\n+    // crate use foo::bar::*;\n+    // crate use foo::*;\n     // ```\n     //\n     // `Double` will appear twice in the generated docs."}, {"sha": "0f82649409f360ef83495821afac70a946832c18", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -137,7 +137,7 @@ impl<'a> SourceCollector<'a> {\n /// static HTML tree. Each component in the cleaned path will be passed as an\n /// argument to `f`. The very last component of the path (ie the file name) will\n /// be passed to `f` if `keep_filename` is true, and ignored otherwise.\n-pub fn clean_path<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n+crate fn clean_path<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n where\n     F: FnMut(&OsStr),\n {"}, {"sha": "132ac42c4228369ee2185363825e3c8bcc023ec4", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -8,111 +8,111 @@\n //! directly written to a `Write` handle.\n \n /// The file contents of the main `rustdoc.css` file, responsible for the core layout of the page.\n-pub static RUSTDOC_CSS: &str = include_str!(\"static/rustdoc.css\");\n+crate static RUSTDOC_CSS: &str = include_str!(\"static/rustdoc.css\");\n \n /// The file contents of `settings.css`, responsible for the items on the settings page.\n-pub static SETTINGS_CSS: &str = include_str!(\"static/settings.css\");\n+crate static SETTINGS_CSS: &str = include_str!(\"static/settings.css\");\n \n /// The file contents of the `noscript.css` file, used in case JS isn't supported or is disabled.\n-pub static NOSCRIPT_CSS: &str = include_str!(\"static/noscript.css\");\n+crate static NOSCRIPT_CSS: &str = include_str!(\"static/noscript.css\");\n \n /// The file contents of `normalize.css`, included to even out standard elements between browser\n /// implementations.\n-pub static NORMALIZE_CSS: &str = include_str!(\"static/normalize.css\");\n+crate static NORMALIZE_CSS: &str = include_str!(\"static/normalize.css\");\n \n /// The file contents of `main.js`, which contains the core JavaScript used on documentation pages,\n /// including search behavior and docblock folding, among others.\n-pub static MAIN_JS: &str = include_str!(\"static/main.js\");\n+crate static MAIN_JS: &str = include_str!(\"static/main.js\");\n \n /// The file contents of `settings.js`, which contains the JavaScript used to handle the settings\n /// page.\n-pub static SETTINGS_JS: &str = include_str!(\"static/settings.js\");\n+crate static SETTINGS_JS: &str = include_str!(\"static/settings.js\");\n \n /// The file contents of `storage.js`, which contains functionality related to browser Local\n /// Storage, used to store documentation settings.\n-pub static STORAGE_JS: &str = include_str!(\"static/storage.js\");\n+crate static STORAGE_JS: &str = include_str!(\"static/storage.js\");\n \n /// The file contents of `brush.svg`, the icon used for the theme-switch button.\n-pub static BRUSH_SVG: &[u8] = include_bytes!(\"static/brush.svg\");\n+crate static BRUSH_SVG: &[u8] = include_bytes!(\"static/brush.svg\");\n \n /// The file contents of `wheel.svg`, the icon used for the settings button.\n-pub static WHEEL_SVG: &[u8] = include_bytes!(\"static/wheel.svg\");\n+crate static WHEEL_SVG: &[u8] = include_bytes!(\"static/wheel.svg\");\n \n /// The file contents of `down-arrow.svg`, the icon used for the crate choice combobox.\n-pub static DOWN_ARROW_SVG: &[u8] = include_bytes!(\"static/down-arrow.svg\");\n+crate static DOWN_ARROW_SVG: &[u8] = include_bytes!(\"static/down-arrow.svg\");\n \n /// The contents of `COPYRIGHT.txt`, the license listing for files distributed with documentation\n /// output.\n-pub static COPYRIGHT: &[u8] = include_bytes!(\"static/COPYRIGHT.txt\");\n+crate static COPYRIGHT: &[u8] = include_bytes!(\"static/COPYRIGHT.txt\");\n \n /// The contents of `LICENSE-APACHE.txt`, the text of the Apache License, version 2.0.\n-pub static LICENSE_APACHE: &[u8] = include_bytes!(\"static/LICENSE-APACHE.txt\");\n+crate static LICENSE_APACHE: &[u8] = include_bytes!(\"static/LICENSE-APACHE.txt\");\n \n /// The contents of `LICENSE-MIT.txt`, the text of the MIT License.\n-pub static LICENSE_MIT: &[u8] = include_bytes!(\"static/LICENSE-MIT.txt\");\n+crate static LICENSE_MIT: &[u8] = include_bytes!(\"static/LICENSE-MIT.txt\");\n \n /// The contents of `rust-logo.png`, the default icon of the documentation.\n-pub static RUST_LOGO: &[u8] = include_bytes!(\"static/rust-logo.png\");\n+crate static RUST_LOGO: &[u8] = include_bytes!(\"static/rust-logo.png\");\n /// The default documentation favicons (SVG and PNG fallbacks)\n-pub static RUST_FAVICON_SVG: &[u8] = include_bytes!(\"static/favicon.svg\");\n-pub static RUST_FAVICON_PNG_16: &[u8] = include_bytes!(\"static/favicon-16x16.png\");\n-pub static RUST_FAVICON_PNG_32: &[u8] = include_bytes!(\"static/favicon-32x32.png\");\n+crate static RUST_FAVICON_SVG: &[u8] = include_bytes!(\"static/favicon.svg\");\n+crate static RUST_FAVICON_PNG_16: &[u8] = include_bytes!(\"static/favicon-16x16.png\");\n+crate static RUST_FAVICON_PNG_32: &[u8] = include_bytes!(\"static/favicon-32x32.png\");\n \n /// The built-in themes given to every documentation site.\n-pub mod themes {\n+crate mod themes {\n     /// The \"light\" theme, selected by default when no setting is available. Used as the basis for\n     /// the `--check-theme` functionality.\n-    pub static LIGHT: &str = include_str!(\"static/themes/light.css\");\n+    crate static LIGHT: &str = include_str!(\"static/themes/light.css\");\n \n     /// The \"dark\" theme.\n-    pub static DARK: &str = include_str!(\"static/themes/dark.css\");\n+    crate static DARK: &str = include_str!(\"static/themes/dark.css\");\n \n     /// The \"ayu\" theme.\n-    pub static AYU: &str = include_str!(\"static/themes/ayu.css\");\n+    crate static AYU: &str = include_str!(\"static/themes/ayu.css\");\n }\n \n /// Files related to the Fira Sans font.\n-pub mod fira_sans {\n+crate mod fira_sans {\n     /// The file `FiraSans-Regular.woff`, the Regular variant of the Fira Sans font.\n-    pub static REGULAR: &[u8] = include_bytes!(\"static/FiraSans-Regular.woff\");\n+    crate static REGULAR: &[u8] = include_bytes!(\"static/FiraSans-Regular.woff\");\n \n     /// The file `FiraSans-Medium.woff`, the Medium variant of the Fira Sans font.\n-    pub static MEDIUM: &[u8] = include_bytes!(\"static/FiraSans-Medium.woff\");\n+    crate static MEDIUM: &[u8] = include_bytes!(\"static/FiraSans-Medium.woff\");\n \n     /// The file `FiraSans-LICENSE.txt`, the license text for the Fira Sans font.\n-    pub static LICENSE: &[u8] = include_bytes!(\"static/FiraSans-LICENSE.txt\");\n+    crate static LICENSE: &[u8] = include_bytes!(\"static/FiraSans-LICENSE.txt\");\n }\n \n /// Files related to the Source Serif Pro font.\n-pub mod source_serif_pro {\n+crate mod source_serif_pro {\n     /// The file `SourceSerifPro-Regular.ttf.woff`, the Regular variant of the Source Serif Pro\n     /// font.\n-    pub static REGULAR: &[u8] = include_bytes!(\"static/SourceSerifPro-Regular.ttf.woff\");\n+    crate static REGULAR: &[u8] = include_bytes!(\"static/SourceSerifPro-Regular.ttf.woff\");\n \n     /// The file `SourceSerifPro-Bold.ttf.woff`, the Bold variant of the Source Serif Pro font.\n-    pub static BOLD: &[u8] = include_bytes!(\"static/SourceSerifPro-Bold.ttf.woff\");\n+    crate static BOLD: &[u8] = include_bytes!(\"static/SourceSerifPro-Bold.ttf.woff\");\n \n     /// The file `SourceSerifPro-It.ttf.woff`, the Italic variant of the Source Serif Pro font.\n-    pub static ITALIC: &[u8] = include_bytes!(\"static/SourceSerifPro-It.ttf.woff\");\n+    crate static ITALIC: &[u8] = include_bytes!(\"static/SourceSerifPro-It.ttf.woff\");\n \n     /// The file `SourceSerifPro-LICENSE.txt`, the license text for the Source Serif Pro font.\n-    pub static LICENSE: &[u8] = include_bytes!(\"static/SourceSerifPro-LICENSE.md\");\n+    crate static LICENSE: &[u8] = include_bytes!(\"static/SourceSerifPro-LICENSE.md\");\n }\n \n /// Files related to the Source Code Pro font.\n-pub mod source_code_pro {\n+crate mod source_code_pro {\n     /// The file `SourceCodePro-Regular.woff`, the Regular variant of the Source Code Pro font.\n-    pub static REGULAR: &[u8] = include_bytes!(\"static/SourceCodePro-Regular.woff\");\n+    crate static REGULAR: &[u8] = include_bytes!(\"static/SourceCodePro-Regular.woff\");\n \n     /// The file `SourceCodePro-Semibold.woff`, the Semibold variant of the Source Code Pro font.\n-    pub static SEMIBOLD: &[u8] = include_bytes!(\"static/SourceCodePro-Semibold.woff\");\n+    crate static SEMIBOLD: &[u8] = include_bytes!(\"static/SourceCodePro-Semibold.woff\");\n \n     /// The file `SourceCodePro-LICENSE.txt`, the license text of the Source Code Pro font.\n-    pub static LICENSE: &[u8] = include_bytes!(\"static/SourceCodePro-LICENSE.txt\");\n+    crate static LICENSE: &[u8] = include_bytes!(\"static/SourceCodePro-LICENSE.txt\");\n }\n \n /// Files related to the sidebar in rustdoc sources.\n-pub mod sidebar {\n+crate mod sidebar {\n     /// File script to handle sidebar.\n-    pub static SOURCE_SCRIPT: &str = include_str!(\"static/source-script.js\");\n+    crate static SOURCE_SCRIPT: &str = include_str!(\"static/source-script.js\");\n }"}, {"sha": "b39a4e179cd164e35df536d1ac75b3f0828099f0", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -2,7 +2,7 @@\n \n /// A (recursive) table of contents\n #[derive(Debug, PartialEq)]\n-pub struct Toc {\n+crate struct Toc {\n     /// The levels are strictly decreasing, i.e.\n     ///\n     /// `entries[0].level >= entries[1].level >= ...`\n@@ -26,7 +26,7 @@ impl Toc {\n }\n \n #[derive(Debug, PartialEq)]\n-pub struct TocEntry {\n+crate struct TocEntry {\n     level: u32,\n     sec_number: String,\n     name: String,\n@@ -36,7 +36,7 @@ pub struct TocEntry {\n \n /// Progressive construction of a table of contents.\n #[derive(PartialEq)]\n-pub struct TocBuilder {\n+crate struct TocBuilder {\n     top_level: Toc,\n     /// The current hierarchy of parent headings, the levels are\n     /// strictly increasing (i.e., `chain[0].level < chain[1].level <\n@@ -50,12 +50,12 @@ pub struct TocBuilder {\n }\n \n impl TocBuilder {\n-    pub fn new() -> TocBuilder {\n+    crate fn new() -> TocBuilder {\n         TocBuilder { top_level: Toc { entries: Vec::new() }, chain: Vec::new() }\n     }\n \n     /// Converts into a true `Toc` struct.\n-    pub fn into_toc(mut self) -> Toc {\n+    crate fn into_toc(mut self) -> Toc {\n         // we know all levels are >= 1.\n         self.fold_until(0);\n         self.top_level\n@@ -115,7 +115,7 @@ impl TocBuilder {\n     /// Push a level `level` heading into the appropriate place in the\n     /// hierarchy, returning a string containing the section number in\n     /// `<num>.<num>.<num>` format.\n-    pub fn push(&mut self, level: u32, name: String, id: String) -> &str {\n+    crate fn push(&mut self, level: u32, name: String, id: String) -> &str {\n         assert!(level >= 1);\n \n         // collapse all previous sections into their parents until we"}, {"sha": "5eb1f7b1f7780ff04e6655ad9c663e585b6bdd1a", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -7,7 +7,7 @@ use crate::formats::FormatRenderer;\n use rustc_span::edition::Edition;\n \n #[derive(Clone)]\n-pub struct JsonRenderer {}\n+crate struct JsonRenderer {}\n \n impl FormatRenderer for JsonRenderer {\n     fn init("}, {"sha": "95347b2625df532c8b48d1c27f92fbf026d2b900", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -77,15 +77,15 @@ mod error;\n mod doctest;\n mod fold;\n crate mod formats;\n-pub mod html;\n+crate mod html;\n mod json;\n mod markdown;\n mod passes;\n mod theme;\n mod visit_ast;\n mod visit_lib;\n \n-pub fn main() {\n+crate fn main() {\n     rustc_driver::set_sigpipe_handler();\n     rustc_driver::install_ice_hook();\n     rustc_driver::init_env_logger(\"RUSTDOC_LOG\");"}, {"sha": "963f2cf71f389761c9bd8f4f367c13df5a7c737f", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -32,7 +32,7 @@ fn extract_leading_metadata(s: &str) -> (Vec<&str>, &str) {\n \n /// Render `input` (e.g., \"foo.md\") into an HTML file in `output`\n /// (e.g., output = \"bar\" => \"bar/foo.html\").\n-pub fn render<P: AsRef<Path>>(\n+crate fn render<P: AsRef<Path>>(\n     input: P,\n     options: RenderOptions,\n     edition: Edition,\n@@ -114,7 +114,7 @@ pub fn render<P: AsRef<Path>>(\n }\n \n /// Runs any tests/code examples in the markdown file `input`.\n-pub fn test(mut options: Options) -> Result<(), String> {\n+crate fn test(mut options: Options) -> Result<(), String> {\n     let input_str = read_to_string(&options.input)\n         .map_err(|err| format!(\"{}: {}\", options.input.display(), err))?;\n     let mut opts = TestOptions::default();"}, {"sha": "aca218e538165c87b0c758c4e355ab7facd83590", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -14,7 +14,7 @@ use serde::Serialize;\n use std::collections::BTreeMap;\n use std::ops;\n \n-pub const CALCULATE_DOC_COVERAGE: Pass = Pass {\n+crate const CALCULATE_DOC_COVERAGE: Pass = Pass {\n     name: \"calculate-doc-coverage\",\n     run: calculate_doc_coverage,\n     description: \"counts the number of items with and without documentation\","}, {"sha": "a48fa738e3b727cc944500e82bc5c0006e92be88", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -11,13 +11,13 @@ use crate::fold::DocFolder;\n use crate::html::markdown::{self, RustCodeBlock};\n use crate::passes::{span_of_attrs, Pass};\n \n-pub const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n+crate const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n     name: \"check-code-block-syntax\",\n     run: check_code_block_syntax,\n     description: \"validates syntax inside Rust code blocks\",\n };\n \n-pub fn check_code_block_syntax(krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n+crate fn check_code_block_syntax(krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n     SyntaxChecker { cx }.fold_crate(krate)\n }\n "}, {"sha": "1f9f5c58e5a93279277231a38c2edf09c6bc6d2f", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -6,13 +6,13 @@ use crate::passes::Pass;\n \n use std::mem::take;\n \n-pub const COLLAPSE_DOCS: Pass = Pass {\n+crate const COLLAPSE_DOCS: Pass = Pass {\n     name: \"collapse-docs\",\n     run: collapse_docs,\n     description: \"concatenates all document attributes into one document attribute\",\n };\n \n-pub fn collapse_docs(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n+crate fn collapse_docs(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     let mut krate = Collapser.fold_crate(krate);\n     krate.collapsed = true;\n     krate\n@@ -66,7 +66,7 @@ fn collapse(doc_strings: &mut Vec<DocFragment>) {\n }\n \n impl clean::Attributes {\n-    pub fn collapse_doc_comments(&mut self) {\n+    crate fn collapse_doc_comments(&mut self) {\n         collapse(&mut self.doc_strings);\n     }\n }"}, {"sha": "895414b1d7e4c8c1e280ad6681fca0192ff2d356", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -39,13 +39,13 @@ use crate::passes::Pass;\n \n use super::span_of_attrs;\n \n-pub const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n+crate const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n     name: \"collect-intra-doc-links\",\n     run: collect_intra_doc_links,\n     description: \"reads a crate's documentation to resolve intra-doc-links\",\n };\n \n-pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n+crate fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     LinkCollector::new(cx).fold_crate(krate)\n }\n "}, {"sha": "2946db1f46206d2acbcd6128deba7c2aea461fda", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -7,13 +7,13 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_span::symbol::sym;\n \n-pub const COLLECT_TRAIT_IMPLS: Pass = Pass {\n+crate const COLLECT_TRAIT_IMPLS: Pass = Pass {\n     name: \"collect-trait-impls\",\n     run: collect_trait_impls,\n     description: \"retrieves trait impls for items in the crate\",\n };\n \n-pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n+crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     let mut synth = SyntheticImplCollector::new(cx);\n     let mut krate = synth.fold_crate(krate);\n "}, {"sha": "60fe8080f56b41dc817c8f5714788c3cfb0d270a", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -12,7 +12,7 @@ use crate::html::markdown::{find_testable_code, ErrorCodes, Ignore, LangString};\n use rustc_middle::lint::LintSource;\n use rustc_session::lint;\n \n-pub const CHECK_PRIVATE_ITEMS_DOC_TESTS: Pass = Pass {\n+crate const CHECK_PRIVATE_ITEMS_DOC_TESTS: Pass = Pass {\n     name: \"check-private-items-doc-tests\",\n     run: check_private_items_doc_tests,\n     description: \"check private items doc tests\",\n@@ -28,7 +28,7 @@ impl<'a, 'tcx> PrivateItemDocTestLinter<'a, 'tcx> {\n     }\n }\n \n-pub fn check_private_items_doc_tests(krate: Crate, cx: &DocContext<'_>) -> Crate {\n+crate fn check_private_items_doc_tests(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     let mut coll = PrivateItemDocTestLinter::new(cx);\n \n     coll.fold_crate(krate)\n@@ -57,7 +57,7 @@ impl crate::doctest::Tester for Tests {\n     }\n }\n \n-pub fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n+crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n     if matches!(item.kind,\n         clean::StructFieldItem(_)\n         | clean::VariantItem(_)\n@@ -79,7 +79,7 @@ pub fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool\n     level != lint::Level::Allow || matches!(source, LintSource::Default)\n }\n \n-pub fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n+crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n     let hir_id = match cx.as_local_hir_id(item.def_id) {\n         Some(hir_id) => hir_id,\n         None => {"}, {"sha": "01efd07cbcde7a48c6953acbf941539cb729c553", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -9,7 +9,7 @@ use rustc_session::lint;\n use std::iter::Peekable;\n use std::str::CharIndices;\n \n-pub const CHECK_INVALID_HTML_TAGS: Pass = Pass {\n+crate const CHECK_INVALID_HTML_TAGS: Pass = Pass {\n     name: \"check-invalid-html-tags\",\n     run: check_invalid_html_tags,\n     description: \"detects invalid HTML tags in doc comments\",\n@@ -25,7 +25,7 @@ impl<'a, 'tcx> InvalidHtmlTagsLinter<'a, 'tcx> {\n     }\n }\n \n-pub fn check_invalid_html_tags(krate: Crate, cx: &DocContext<'_>) -> Crate {\n+crate fn check_invalid_html_tags(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     if !cx.tcx.sess.is_nightly_build() {\n         krate\n     } else {"}, {"sha": "51818d7faf0071f70243dfe11f78cd69dcc66080", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -9,67 +9,67 @@ use crate::clean::{self, DocFragmentKind};\n use crate::core::DocContext;\n \n mod stripper;\n-pub use stripper::*;\n+crate use stripper::*;\n \n mod non_autolinks;\n-pub use self::non_autolinks::CHECK_NON_AUTOLINKS;\n+crate use self::non_autolinks::CHECK_NON_AUTOLINKS;\n \n mod collapse_docs;\n-pub use self::collapse_docs::COLLAPSE_DOCS;\n+crate use self::collapse_docs::COLLAPSE_DOCS;\n \n mod strip_hidden;\n-pub use self::strip_hidden::STRIP_HIDDEN;\n+crate use self::strip_hidden::STRIP_HIDDEN;\n \n mod strip_private;\n-pub use self::strip_private::STRIP_PRIVATE;\n+crate use self::strip_private::STRIP_PRIVATE;\n \n mod strip_priv_imports;\n-pub use self::strip_priv_imports::STRIP_PRIV_IMPORTS;\n+crate use self::strip_priv_imports::STRIP_PRIV_IMPORTS;\n \n mod unindent_comments;\n-pub use self::unindent_comments::UNINDENT_COMMENTS;\n+crate use self::unindent_comments::UNINDENT_COMMENTS;\n \n mod propagate_doc_cfg;\n-pub use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n+crate use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n \n mod collect_intra_doc_links;\n-pub use self::collect_intra_doc_links::COLLECT_INTRA_DOC_LINKS;\n+crate use self::collect_intra_doc_links::COLLECT_INTRA_DOC_LINKS;\n \n mod doc_test_lints;\n-pub use self::doc_test_lints::CHECK_PRIVATE_ITEMS_DOC_TESTS;\n+crate use self::doc_test_lints::CHECK_PRIVATE_ITEMS_DOC_TESTS;\n \n mod collect_trait_impls;\n-pub use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n+crate use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n \n mod check_code_block_syntax;\n-pub use self::check_code_block_syntax::CHECK_CODE_BLOCK_SYNTAX;\n+crate use self::check_code_block_syntax::CHECK_CODE_BLOCK_SYNTAX;\n \n mod calculate_doc_coverage;\n-pub use self::calculate_doc_coverage::CALCULATE_DOC_COVERAGE;\n+crate use self::calculate_doc_coverage::CALCULATE_DOC_COVERAGE;\n \n mod html_tags;\n-pub use self::html_tags::CHECK_INVALID_HTML_TAGS;\n+crate use self::html_tags::CHECK_INVALID_HTML_TAGS;\n \n /// A single pass over the cleaned documentation.\n ///\n /// Runs in the compiler context, so it has access to types and traits and the like.\n #[derive(Copy, Clone)]\n-pub struct Pass {\n-    pub name: &'static str,\n-    pub run: fn(clean::Crate, &DocContext<'_>) -> clean::Crate,\n-    pub description: &'static str,\n+crate struct Pass {\n+    crate name: &'static str,\n+    crate run: fn(clean::Crate, &DocContext<'_>) -> clean::Crate,\n+    crate description: &'static str,\n }\n \n /// In a list of passes, a pass that may or may not need to be run depending on options.\n #[derive(Copy, Clone)]\n-pub struct ConditionalPass {\n-    pub pass: Pass,\n-    pub condition: Condition,\n+crate struct ConditionalPass {\n+    crate pass: Pass,\n+    crate condition: Condition,\n }\n \n /// How to decide whether to run a conditional pass.\n #[derive(Copy, Clone)]\n-pub enum Condition {\n+crate enum Condition {\n     Always,\n     /// When `--document-private-items` is passed.\n     WhenDocumentPrivate,\n@@ -80,7 +80,7 @@ pub enum Condition {\n }\n \n /// The full list of passes.\n-pub const PASSES: &[Pass] = &[\n+crate const PASSES: &[Pass] = &[\n     CHECK_PRIVATE_ITEMS_DOC_TESTS,\n     STRIP_HIDDEN,\n     UNINDENT_COMMENTS,\n@@ -97,7 +97,7 @@ pub const PASSES: &[Pass] = &[\n ];\n \n /// The list of passes run by default.\n-pub const DEFAULT_PASSES: &[ConditionalPass] = &[\n+crate const DEFAULT_PASSES: &[ConditionalPass] = &[\n     ConditionalPass::always(COLLECT_TRAIT_IMPLS),\n     ConditionalPass::always(COLLAPSE_DOCS),\n     ConditionalPass::always(UNINDENT_COMMENTS),\n@@ -113,34 +113,34 @@ pub const DEFAULT_PASSES: &[ConditionalPass] = &[\n ];\n \n /// The list of default passes run when `--doc-coverage` is passed to rustdoc.\n-pub const COVERAGE_PASSES: &[ConditionalPass] = &[\n+crate const COVERAGE_PASSES: &[ConditionalPass] = &[\n     ConditionalPass::always(COLLECT_TRAIT_IMPLS),\n     ConditionalPass::new(STRIP_HIDDEN, WhenNotDocumentHidden),\n     ConditionalPass::new(STRIP_PRIVATE, WhenNotDocumentPrivate),\n     ConditionalPass::always(CALCULATE_DOC_COVERAGE),\n ];\n \n impl ConditionalPass {\n-    pub const fn always(pass: Pass) -> Self {\n+    crate const fn always(pass: Pass) -> Self {\n         Self::new(pass, Always)\n     }\n \n-    pub const fn new(pass: Pass, condition: Condition) -> Self {\n+    crate const fn new(pass: Pass, condition: Condition) -> Self {\n         ConditionalPass { pass, condition }\n     }\n }\n \n /// A shorthand way to refer to which set of passes to use, based on the presence of\n /// `--no-defaults` and `--show-coverage`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum DefaultPassOption {\n+crate enum DefaultPassOption {\n     Default,\n     Coverage,\n     None,\n }\n \n /// Returns the given default set of passes.\n-pub fn defaults(default_set: DefaultPassOption) -> &'static [ConditionalPass] {\n+crate fn defaults(default_set: DefaultPassOption) -> &'static [ConditionalPass] {\n     match default_set {\n         DefaultPassOption::Default => DEFAULT_PASSES,\n         DefaultPassOption::Coverage => COVERAGE_PASSES,\n@@ -149,7 +149,7 @@ pub fn defaults(default_set: DefaultPassOption) -> &'static [ConditionalPass] {\n }\n \n /// If the given name matches a known pass, returns its information.\n-pub fn find_pass(pass_name: &str) -> Option<Pass> {\n+crate fn find_pass(pass_name: &str) -> Option<Pass> {\n     PASSES.iter().find(|p| p.name == pass_name).copied()\n }\n "}, {"sha": "c9c49968b93e1be6b1918147cb33d586ff7c6294", "filename": "src/librustdoc/passes/non_autolinks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -9,7 +9,7 @@ use regex::Regex;\n use rustc_errors::Applicability;\n use rustc_session::lint;\n \n-pub const CHECK_NON_AUTOLINKS: Pass = Pass {\n+crate const CHECK_NON_AUTOLINKS: Pass = Pass {\n     name: \"check-non-autolinks\",\n     run: check_non_autolinks,\n     description: \"detects URLS that could be written using angle brackets\",\n@@ -52,7 +52,7 @@ impl<'a, 'tcx> NonAutolinksLinter<'a, 'tcx> {\n     }\n }\n \n-pub fn check_non_autolinks(krate: Crate, cx: &DocContext<'_>) -> Crate {\n+crate fn check_non_autolinks(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     if !cx.tcx.sess.is_nightly_build() {\n         krate\n     } else {"}, {"sha": "fbfc693c5347de06801e391469df798a1fee6f87", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -6,13 +6,13 @@ use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::Pass;\n \n-pub const PROPAGATE_DOC_CFG: Pass = Pass {\n+crate const PROPAGATE_DOC_CFG: Pass = Pass {\n     name: \"propagate-doc-cfg\",\n     run: propagate_doc_cfg,\n     description: \"propagates `#[doc(cfg(...))]` to child items\",\n };\n \n-pub fn propagate_doc_cfg(cr: Crate, _: &DocContext<'_>) -> Crate {\n+crate fn propagate_doc_cfg(cr: Crate, _: &DocContext<'_>) -> Crate {\n     CfgPropagator { parent_cfg: None }.fold_crate(cr)\n }\n "}, {"sha": "6da753ea6e695b91c5bd7271a752c2e34513ff22", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -8,14 +8,14 @@ use crate::core::DocContext;\n use crate::fold::{DocFolder, StripItem};\n use crate::passes::{ImplStripper, Pass};\n \n-pub const STRIP_HIDDEN: Pass = Pass {\n+crate const STRIP_HIDDEN: Pass = Pass {\n     name: \"strip-hidden\",\n     run: strip_hidden,\n     description: \"strips all doc(hidden) items from the output\",\n };\n \n /// Strip items marked `#[doc(hidden)]`\n-pub fn strip_hidden(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n+crate fn strip_hidden(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     let mut retained = DefIdSet::default();\n \n     // strip all #[doc(hidden)] items"}, {"sha": "6eeaabacbc138fe9212d04e4d628fed4fd74635b", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -3,12 +3,12 @@ use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::{ImportStripper, Pass};\n \n-pub const STRIP_PRIV_IMPORTS: Pass = Pass {\n+crate const STRIP_PRIV_IMPORTS: Pass = Pass {\n     name: \"strip-priv-imports\",\n     run: strip_priv_imports,\n     description: \"strips all private import statements (`use`, `extern crate`) from a crate\",\n };\n \n-pub fn strip_priv_imports(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n+crate fn strip_priv_imports(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     ImportStripper.fold_crate(krate)\n }"}, {"sha": "e812bcd87fe3c8c838a764c4e7b1a346ba9e58b9", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -5,7 +5,7 @@ use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::{ImplStripper, ImportStripper, Pass, Stripper};\n \n-pub const STRIP_PRIVATE: Pass = Pass {\n+crate const STRIP_PRIVATE: Pass = Pass {\n     name: \"strip-private\",\n     run: strip_private,\n     description: \"strips all private items from a crate which cannot be seen externally, \\\n@@ -14,7 +14,7 @@ pub const STRIP_PRIVATE: Pass = Pass {\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-pub fn strip_private(mut krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n+crate fn strip_private(mut krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n     let mut retained = DefIdSet::default();\n     let access_levels = cx.renderinfo.borrow().access_levels.clone();"}, {"sha": "3a10142adcfcd943bae0a6e42323935026da3023", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -5,10 +5,10 @@ use std::mem;\n use crate::clean::{self, GetDefId, Item};\n use crate::fold::{DocFolder, StripItem};\n \n-pub struct Stripper<'a> {\n-    pub retained: &'a mut DefIdSet,\n-    pub access_levels: &'a AccessLevels<DefId>,\n-    pub update_retained: bool,\n+crate struct Stripper<'a> {\n+    crate retained: &'a mut DefIdSet,\n+    crate access_levels: &'a AccessLevels<DefId>,\n+    crate update_retained: bool,\n }\n \n impl<'a> DocFolder for Stripper<'a> {\n@@ -117,8 +117,8 @@ impl<'a> DocFolder for Stripper<'a> {\n }\n \n /// This stripper discards all impls which reference stripped items\n-pub struct ImplStripper<'a> {\n-    pub retained: &'a DefIdSet,\n+crate struct ImplStripper<'a> {\n+    crate retained: &'a DefIdSet,\n }\n \n impl<'a> DocFolder for ImplStripper<'a> {\n@@ -158,7 +158,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n }\n \n /// This stripper discards all private import statements (`use`, `extern crate`)\n-pub struct ImportStripper;\n+crate struct ImportStripper;\n \n impl DocFolder for ImportStripper {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {"}, {"sha": "eb2f066bbdebb1afb64a2e4d34863275e520e5cb", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -8,13 +8,13 @@ use crate::passes::Pass;\n #[cfg(test)]\n mod tests;\n \n-pub const UNINDENT_COMMENTS: Pass = Pass {\n+crate const UNINDENT_COMMENTS: Pass = Pass {\n     name: \"unindent-comments\",\n     run: unindent_comments,\n     description: \"removes excess indentation on comments in order for markdown to like it\",\n };\n \n-pub fn unindent_comments(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n+crate fn unindent_comments(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     CommentCleaner.fold_crate(krate)\n }\n \n@@ -28,7 +28,7 @@ impl fold::DocFolder for CommentCleaner {\n }\n \n impl clean::Attributes {\n-    pub fn unindent_doc_comments(&mut self) {\n+    crate fn unindent_doc_comments(&mut self) {\n         unindent_fragments(&mut self.doc_strings);\n     }\n }"}, {"sha": "3bcf64f91c9a695c384d1bd5310ffd4c697f2e08", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -9,9 +9,9 @@ use rustc_errors::Handler;\n mod tests;\n \n #[derive(Debug, Clone, Eq)]\n-pub struct CssPath {\n-    pub name: String,\n-    pub children: FxHashSet<CssPath>,\n+crate struct CssPath {\n+    crate name: String,\n+    crate children: FxHashSet<CssPath>,\n }\n \n // This PartialEq implementation IS NOT COMMUTATIVE!!!\n@@ -212,7 +212,7 @@ fn inner(v: &[u8], events: &[Events], pos: &mut usize) -> FxHashSet<CssPath> {\n     paths.iter().cloned().collect()\n }\n \n-pub fn load_css_paths(v: &[u8]) -> CssPath {\n+crate fn load_css_paths(v: &[u8]) -> CssPath {\n     let events = load_css_events(v);\n     let mut pos = 0;\n \n@@ -221,7 +221,7 @@ pub fn load_css_paths(v: &[u8]) -> CssPath {\n     parent\n }\n \n-pub fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n+crate fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n     if against.name == other.name {\n         for child in &against.children {\n             let mut found = false;\n@@ -248,7 +248,7 @@ pub fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>)\n     }\n }\n \n-pub fn test_theme_against<P: AsRef<Path>>(\n+crate fn test_theme_against<P: AsRef<Path>>(\n     f: &P,\n     against: &CssPath,\n     diag: &Handler,"}, {"sha": "509cc47caf86da8a19453701d75f722a1f2298f0", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -34,7 +34,7 @@ fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<String> {\n // Also, is there some reason that this doesn't use the 'visit'\n // framework from syntax?.\n \n-pub struct RustdocVisitor<'a, 'tcx> {\n+crate struct RustdocVisitor<'a, 'tcx> {\n     cx: &'a mut core::DocContext<'tcx>,\n     view_item_stack: FxHashSet<hir::HirId>,\n     inlining: bool,\n@@ -44,7 +44,7 @@ pub struct RustdocVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n-    pub fn new(cx: &'a mut core::DocContext<'tcx>) -> RustdocVisitor<'a, 'tcx> {\n+    crate fn new(cx: &'a mut core::DocContext<'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n         let mut stack = FxHashSet::default();\n         stack.insert(hir::CRATE_HIR_ID);\n@@ -62,7 +62,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         self.exact_paths.entry(did).or_insert_with(|| def_id_to_path(tcx, did));\n     }\n \n-    pub fn visit(mut self, krate: &'tcx hir::Crate<'_>) -> Module<'tcx> {\n+    crate fn visit(mut self, krate: &'tcx hir::Crate<'_>) -> Module<'tcx> {\n         let mut module = self.visit_mod_contents(\n             krate.item.span,\n             krate.item.attrs,\n@@ -251,7 +251,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om\n     }\n \n-    /// Tries to resolve the target of a `pub use` statement and inlines the\n+    /// Tries to resolve the target of a `crate use` statement and inlines the\n     /// target if it is defined locally and would not be documented otherwise,\n     /// or when it is specifically requested with `please_inline`.\n     /// (the latter is the case when the import is marked `doc(inline)`)"}, {"sha": "0bf22562eaedee649bcef1ae732038e4c714098a", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6c16e425338692d62bc1332c1e72ae2a9cde234/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=d6c16e425338692d62bc1332c1e72ae2a9cde234", "patch": "@@ -11,7 +11,7 @@ use crate::clean::{AttributesExt, NestedAttributesExt};\n \n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n-pub struct LibEmbargoVisitor<'a, 'tcx> {\n+crate struct LibEmbargoVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     // Accessibility levels for reachable nodes\n     access_levels: &'a mut AccessLevels<DefId>,\n@@ -22,7 +22,7 @@ pub struct LibEmbargoVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n-    pub fn new(cx: &'a mut crate::core::DocContext<'tcx>) -> LibEmbargoVisitor<'a, 'tcx> {\n+    crate fn new(cx: &'a mut crate::core::DocContext<'tcx>) -> LibEmbargoVisitor<'a, 'tcx> {\n         LibEmbargoVisitor {\n             tcx: cx.tcx,\n             access_levels: &mut cx.renderinfo.get_mut().access_levels,\n@@ -31,7 +31,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n         }\n     }\n \n-    pub fn visit_lib(&mut self, cnum: CrateNum) {\n+    crate fn visit_lib(&mut self, cnum: CrateNum) {\n         let did = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n         self.update(did, Some(AccessLevel::Public));\n         self.visit_mod(did);\n@@ -51,7 +51,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n         }\n     }\n \n-    pub fn visit_mod(&mut self, def_id: DefId) {\n+    crate fn visit_mod(&mut self, def_id: DefId) {\n         if !self.visited_mods.insert(def_id) {\n             return;\n         }"}]}