{"sha": "41f234df09440dcd9420cc752649c68135fc09ed", "node_id": "C_kwDOAAsO6NoAKDQxZjIzNGRmMDk0NDBkY2Q5NDIwY2M3NTI2NDljNjgxMzVmYzA5ZWQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-03T16:28:57Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-03T16:28:57Z"}, "message": "Diagnose value breaks in incorrect breakables", "tree": {"sha": "f541c97b3b1b52298295930d0bba8320a2638bf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f541c97b3b1b52298295930d0bba8320a2638bf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41f234df09440dcd9420cc752649c68135fc09ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41f234df09440dcd9420cc752649c68135fc09ed", "html_url": "https://github.com/rust-lang/rust/commit/41f234df09440dcd9420cc752649c68135fc09ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41f234df09440dcd9420cc752649c68135fc09ed/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6", "html_url": "https://github.com/rust-lang/rust/commit/02eb2d758e88ab1afb7b04ea0e8dbf0310c4e5a6"}], "stats": {"total": 109, "additions": 71, "deletions": 38}, "files": [{"sha": "cca787befee3062d139f64b5f4ab9e91ce52f802", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41f234df09440dcd9420cc752649c68135fc09ed/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f234df09440dcd9420cc752649c68135fc09ed/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=41f234df09440dcd9420cc752649c68135fc09ed", "patch": "@@ -167,7 +167,8 @@ pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n     PrivateField { expr: ExprId, field: FieldId },\n     PrivateAssocItem { id: ExprOrPatId, item: AssocItemId },\n-    BreakOutsideOfLoop { expr: ExprId, is_break: bool },\n+    // FIXME: Make this proper\n+    BreakOutsideOfLoop { expr: ExprId, is_break: bool, bad_value_break: bool },\n     MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n }\n \n@@ -411,7 +412,7 @@ struct BreakableContext {\n     /// Whether this context contains at least one break expression.\n     may_break: bool,\n     /// The coercion target of the context.\n-    coerce: CoerceMany,\n+    coerce: Option<CoerceMany>,\n     /// The optional label of the context.\n     label: Option<name::Name>,\n     kind: BreakableKind,"}, {"sha": "e64b020c7fbd2ab3d1471d0a09175184fce91979", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/41f234df09440dcd9420cc752649c68135fc09ed/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f234df09440dcd9420cc752649c68135fc09ed/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=41f234df09440dcd9420cc752649c68135fc09ed", "patch": "@@ -133,7 +133,7 @@ impl<'a> InferenceContext<'a> {\n                         let break_ty = self.table.new_type_var();\n                         let (breaks, ty) = self.with_breakable_ctx(\n                             BreakableKind::Block,\n-                            break_ty.clone(),\n+                            Some(break_ty.clone()),\n                             *label,\n                             |this| {\n                                 this.infer_block(\n@@ -153,7 +153,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Unsafe { body } => self.infer_expr(*body, expected),\n             Expr::Const { body } => {\n-                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n                     this.infer_expr(*body, expected)\n                 })\n                 .1\n@@ -169,7 +169,7 @@ impl<'a> InferenceContext<'a> {\n                 let ok_ty =\n                     self.resolve_associated_type(try_ty.clone(), self.resolve_ops_try_output());\n \n-                self.with_breakable_ctx(BreakableKind::Block, ok_ty.clone(), None, |this| {\n+                self.with_breakable_ctx(BreakableKind::Block, Some(ok_ty.clone()), None, |this| {\n                     this.infer_expr(*body, &Expectation::has_type(ok_ty));\n                 });\n \n@@ -183,7 +183,7 @@ impl<'a> InferenceContext<'a> {\n                     mem::replace(&mut self.return_coercion, Some(CoerceMany::new(ret_ty.clone())));\n \n                 let (_, inner_ty) =\n-                    self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                    self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n                         this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty))\n                     });\n \n@@ -203,7 +203,7 @@ impl<'a> InferenceContext<'a> {\n                 // let ty = expected.coercion_target_type(&mut self.table);\n                 let ty = self.table.new_type_var();\n                 let (breaks, ()) =\n-                    self.with_breakable_ctx(BreakableKind::Loop, ty, label, |this| {\n+                    self.with_breakable_ctx(BreakableKind::Loop, Some(ty), label, |this| {\n                         this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                     });\n \n@@ -216,7 +216,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n             &Expr::While { condition, body, label } => {\n-                self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n+                self.with_breakable_ctx(BreakableKind::Loop, None, label, |this| {\n                     this.infer_expr(\n                         condition,\n                         &Expectation::HasType(this.result.standard_types.bool_.clone()),\n@@ -236,7 +236,7 @@ impl<'a> InferenceContext<'a> {\n                     self.resolve_associated_type(into_iter_ty, self.resolve_iterator_item());\n \n                 self.infer_top_pat(pat, &pat_ty);\n-                self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n+                self.with_breakable_ctx(BreakableKind::Loop, None, label, |this| {\n                     this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n                 });\n \n@@ -321,7 +321,7 @@ impl<'a> InferenceContext<'a> {\n                 let prev_resume_yield_tys =\n                     mem::replace(&mut self.resume_yield_tys, resume_yield_tys);\n \n-                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                self.with_breakable_ctx(BreakableKind::Border, None, None, |this| {\n                     this.infer_return(*body);\n                 });\n \n@@ -439,42 +439,50 @@ impl<'a> InferenceContext<'a> {\n                     self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                         expr: tgt_expr,\n                         is_break: false,\n+                        bad_value_break: false,\n                     });\n                 };\n                 self.result.standard_types.never.clone()\n             }\n             Expr::Break { expr, label } => {\n                 let val_ty = if let Some(expr) = *expr {\n-                    let opt_coerce_to = find_breakable(&mut self.breakables, label.as_ref())\n-                        .map(|ctxt| ctxt.coerce.expected_ty());\n-                    self.infer_expr_inner(\n-                        expr,\n-                        &Expectation::HasType(opt_coerce_to.unwrap_or_else(|| self.err_ty())),\n-                    )\n+                    let opt_coerce_to = match find_breakable(&mut self.breakables, label.as_ref()) {\n+                        Some(ctxt) => match &ctxt.coerce {\n+                            Some(coerce) => coerce.expected_ty(),\n+                            None => {\n+                                self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n+                                    expr: tgt_expr,\n+                                    is_break: true,\n+                                    bad_value_break: true,\n+                                });\n+                                self.err_ty()\n+                            }\n+                        },\n+                        None => self.err_ty(),\n+                    };\n+                    self.infer_expr_inner(expr, &Expectation::HasType(opt_coerce_to))\n                 } else {\n                     TyBuilder::unit()\n                 };\n \n                 match find_breakable(&mut self.breakables, label.as_ref()) {\n-                    Some(ctxt) => {\n-                        // avoiding the borrowck\n-                        let mut coerce = mem::replace(\n-                            &mut ctxt.coerce,\n-                            CoerceMany::new(expected.coercion_target_type(&mut self.table)),\n-                        );\n-\n-                        // FIXME: create a synthetic `()` during lowering so we have something to refer to here?\n-                        coerce.coerce(self, *expr, &val_ty);\n-\n-                        let ctxt = find_breakable(&mut self.breakables, label.as_ref())\n-                            .expect(\"breakable stack changed during coercion\");\n-                        ctxt.coerce = coerce;\n-                        ctxt.may_break = true;\n-                    }\n+                    Some(ctxt) => match ctxt.coerce.take() {\n+                        Some(mut coerce) => {\n+                            coerce.coerce(self, *expr, &val_ty);\n+\n+                            // Avoiding borrowck\n+                            let ctxt = find_breakable(&mut self.breakables, label.as_ref())\n+                                .expect(\"breakable stack changed during coercion\");\n+                            ctxt.may_break = true;\n+                            ctxt.coerce = Some(coerce);\n+                        }\n+                        None => ctxt.may_break = true,\n+                    },\n                     None => {\n                         self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                             expr: tgt_expr,\n                             is_break: true,\n+                            bad_value_break: false,\n                         });\n                     }\n                 }\n@@ -1712,16 +1720,16 @@ impl<'a> InferenceContext<'a> {\n     fn with_breakable_ctx<T>(\n         &mut self,\n         kind: BreakableKind,\n-        ty: Ty,\n+        ty: Option<Ty>,\n         label: Option<LabelId>,\n         cb: impl FnOnce(&mut Self) -> T,\n     ) -> (Option<Ty>, T) {\n         self.breakables.push({\n             let label = label.map(|label| self.body[label].name.clone());\n-            BreakableContext { kind, may_break: false, coerce: CoerceMany::new(ty), label }\n+            BreakableContext { kind, may_break: false, coerce: ty.map(CoerceMany::new), label }\n         });\n         let res = cb(self);\n         let ctx = self.breakables.pop().expect(\"breakable stack broken\");\n-        (ctx.may_break.then(|| ctx.coerce.complete(self)), res)\n+        (if ctx.may_break { ctx.coerce.map(|ctx| ctx.complete(self)) } else { None }, res)\n     }\n }"}, {"sha": "bb7468d466047ef79ab429b36252c792b660f425", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41f234df09440dcd9420cc752649c68135fc09ed/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f234df09440dcd9420cc752649c68135fc09ed/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=41f234df09440dcd9420cc752649c68135fc09ed", "patch": "@@ -140,6 +140,7 @@ pub struct PrivateField {\n pub struct BreakOutsideOfLoop {\n     pub expr: InFile<AstPtr<ast::Expr>>,\n     pub is_break: bool,\n+    pub bad_value_break: bool,\n }\n \n #[derive(Debug)]"}, {"sha": "c9ae12d8d3308344f9f50f5aeba2c7b14617f935", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41f234df09440dcd9420cc752649c68135fc09ed/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f234df09440dcd9420cc752649c68135fc09ed/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=41f234df09440dcd9420cc752649c68135fc09ed", "patch": "@@ -1373,11 +1373,15 @@ impl DefWithBody {\n                     let field = source_map.field_syntax(*expr);\n                     acc.push(NoSuchField { field }.into())\n                 }\n-                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break } => {\n+                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop {\n+                    expr,\n+                    is_break,\n+                    bad_value_break,\n+                } => {\n                     let expr = source_map\n                         .expr_syntax(expr)\n                         .expect(\"break outside of loop in synthetic syntax\");\n-                    acc.push(BreakOutsideOfLoop { expr, is_break }.into())\n+                    acc.push(BreakOutsideOfLoop { expr, is_break, bad_value_break }.into())\n                 }\n                 hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n                     match source_map.expr_syntax(*call_expr) {"}, {"sha": "114face2dca8566ed569c5bddfd2dfc813dcf1f8", "filename": "crates/ide-diagnostics/src/handlers/break_outside_of_loop.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/41f234df09440dcd9420cc752649c68135fc09ed/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41f234df09440dcd9420cc752649c68135fc09ed/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs?ref=41f234df09440dcd9420cc752649c68135fc09ed", "patch": "@@ -7,10 +7,15 @@ pub(crate) fn break_outside_of_loop(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::BreakOutsideOfLoop,\n ) -> Diagnostic {\n-    let construct = if d.is_break { \"break\" } else { \"continue\" };\n+    let message = if d.bad_value_break {\n+        \"can't break with a value in this position\".to_owned()\n+    } else {\n+        let construct = if d.is_break { \"break\" } else { \"continue\" };\n+        format!(\"{construct} outside of loop\")\n+    };\n     Diagnostic::new(\n         \"break-outside-of-loop\",\n-        format!(\"{construct} outside of loop\"),\n+        message,\n         ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n     )\n }\n@@ -132,6 +137,20 @@ fn foo() {\n       //^^^^^^^^^^^ error: continue outside of loop\n     }\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn value_break_in_for_loop() {\n+        check_diagnostics(\n+            r#\"\n+fn test() {\n+    for _ in [()] {\n+        break 3;\n+     // ^^^^^^^ error: can't break with a value in this position\n+    }\n+}\n \"#,\n         );\n     }"}]}