{"sha": "1a81a3e5cfc47908154b13bd921f9c03c5592010", "node_id": "C_kwDOAAsO6NoAKDFhODFhM2U1Y2ZjNDc5MDgxNTRiMTNiZDkyMWY5YzAzYzU1OTIwMTA", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2023-03-02T05:51:04Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2023-03-02T05:51:04Z"}, "message": "Remove `snippet_with_macro_callsite`", "tree": {"sha": "0f52a269be5656ecb468fbc8d02e3ee35d6f8d90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f52a269be5656ecb468fbc8d02e3ee35d6f8d90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a81a3e5cfc47908154b13bd921f9c03c5592010", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a81a3e5cfc47908154b13bd921f9c03c5592010", "html_url": "https://github.com/rust-lang/rust/commit/1a81a3e5cfc47908154b13bd921f9c03c5592010", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a81a3e5cfc47908154b13bd921f9c03c5592010/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "113c704d225c63c1a0eec29cfa9478b7537e7d73", "url": "https://api.github.com/repos/rust-lang/rust/commits/113c704d225c63c1a0eec29cfa9478b7537e7d73", "html_url": "https://github.com/rust-lang/rust/commit/113c704d225c63c1a0eec29cfa9478b7537e7d73"}], "stats": {"total": 393, "additions": 200, "deletions": 193}, "files": [{"sha": "80c22742ba442b5990e9e86754b625510c65f01c", "filename": "clippy_lints/src/default.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_sugg};\n-use clippy_utils::source::snippet_with_macro_callsite;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::{has_drop, is_copy};\n use clippy_utils::{\n     any_parent_is_automatically_derived, contains_name, get_parent_expr, is_from_proc_macro, match_def_path, paths,\n@@ -160,6 +160,8 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n                 }\n             };\n \n+            let init_ctxt = local.span.ctxt();\n+\n             // find all \"later statement\"'s where the fields of the binding set as\n             // Default::default() get reassigned, unless the reassignment refers to the original binding\n             let mut first_assign = None;\n@@ -169,7 +171,7 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n                 // find out if and which field was set by this `consecutive_statement`\n                 if let Some((field_ident, assign_rhs)) = field_reassigned_by_stmt(consecutive_statement, binding_name) {\n                     // interrupt and cancel lint if assign_rhs references the original binding\n-                    if contains_name(binding_name, assign_rhs, cx) {\n+                    if contains_name(binding_name, assign_rhs, cx) || init_ctxt != consecutive_statement.span.ctxt() {\n                         cancel_lint = true;\n                         break;\n                     }\n@@ -204,11 +206,12 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n                     .iter()\n                     .all(|field| assigned_fields.iter().any(|(a, _)| a == &field.name));\n \n+                let mut app = Applicability::Unspecified;\n                 let field_list = assigned_fields\n                     .into_iter()\n                     .map(|(field, rhs)| {\n                         // extract and store the assigned value for help message\n-                        let value_snippet = snippet_with_macro_callsite(cx, rhs.span, \"..\");\n+                        let value_snippet = snippet_with_context(cx, rhs.span, init_ctxt, \"..\", &mut app).0;\n                         format!(\"{field}: {value_snippet}\")\n                     })\n                     .collect::<Vec<String>>()"}, {"sha": "725bd3d54bc22e52d2da6f61e5d36ed8e795dc4f", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -1,8 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::eager_or_lazy::switch_to_eager_eval;\n use clippy_utils::msrvs::{self, Msrv};\n-use clippy_utils::source::snippet_with_macro_callsite;\n+use clippy_utils::source::snippet_with_context;\n+use clippy_utils::sugg::Sugg;\n use clippy_utils::{contains_return, higher, is_else_clause, is_res_lang_ctor, path_res, peel_blocks};\n+use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -72,21 +74,20 @@ impl<'tcx> LateLintPass<'tcx> for IfThenSomeElseNone {\n             return;\n         }\n \n+        let ctxt = expr.span.ctxt();\n+\n         if let Some(higher::If { cond, then, r#else: Some(els) }) = higher::If::hir(expr)\n             && let ExprKind::Block(then_block, _) = then.kind\n             && let Some(then_expr) = then_block.expr\n             && let ExprKind::Call(then_call, [then_arg]) = then_expr.kind\n+            && then_expr.span.ctxt() == ctxt\n             && is_res_lang_ctor(cx, path_res(cx, then_call), OptionSome)\n             && is_res_lang_ctor(cx, path_res(cx, peel_blocks(els)), OptionNone)\n             && !stmts_contains_early_return(then_block.stmts)\n         {\n-            let cond_snip = snippet_with_macro_callsite(cx, cond.span, \"[condition]\");\n-            let cond_snip = if matches!(cond.kind, ExprKind::Unary(_, _) | ExprKind::Binary(_, _, _)) {\n-                format!(\"({cond_snip})\")\n-            } else {\n-                cond_snip.into_owned()\n-            };\n-            let arg_snip = snippet_with_macro_callsite(cx, then_arg.span, \"\");\n+            let mut app = Applicability::Unspecified;\n+            let cond_snip = Sugg::hir_with_context(cx, cond, expr.span.ctxt(), \"[condition]\", &mut app).maybe_par().to_string();\n+            let arg_snip = snippet_with_context(cx, then_arg.span, ctxt, \"[body]\", &mut app).0;\n             let mut method_body = if then_block.stmts.is_empty() {\n                 arg_snip.into_owned()\n             } else {"}, {"sha": "9d9341559ac722eb8416c76c26493b4355ae154f", "filename": "clippy_lints/src/loops/same_item_push.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -1,15 +1,17 @@\n use super::SAME_ITEM_PUSH;\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::path_to_local;\n-use clippy_utils::source::snippet_with_macro_callsite;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Mutability, Node, Pat, PatKind, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n+use rustc_span::SyntaxContext;\n use std::iter::Iterator;\n \n /// Detects for loop pushing the same item into a Vec\n@@ -20,9 +22,10 @@ pub(super) fn check<'tcx>(\n     body: &'tcx Expr<'_>,\n     _: &'tcx Expr<'_>,\n ) {\n-    fn emit_lint(cx: &LateContext<'_>, vec: &Expr<'_>, pushed_item: &Expr<'_>) {\n-        let vec_str = snippet_with_macro_callsite(cx, vec.span, \"\");\n-        let item_str = snippet_with_macro_callsite(cx, pushed_item.span, \"\");\n+    fn emit_lint(cx: &LateContext<'_>, vec: &Expr<'_>, pushed_item: &Expr<'_>, ctxt: SyntaxContext) {\n+        let mut app = Applicability::Unspecified;\n+        let vec_str = snippet_with_context(cx, vec.span, ctxt, \"\", &mut app).0;\n+        let item_str = snippet_with_context(cx, pushed_item.span, ctxt, \"\", &mut app).0;\n \n         span_lint_and_help(\n             cx,\n@@ -43,7 +46,7 @@ pub(super) fn check<'tcx>(\n     walk_expr(&mut same_item_push_visitor, body);\n     if_chain! {\n         if same_item_push_visitor.should_lint();\n-        if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push;\n+        if let Some((vec, pushed_item, ctxt)) = same_item_push_visitor.vec_push;\n         let vec_ty = cx.typeck_results().expr_ty(vec);\n         let ty = vec_ty.walk().nth(1).unwrap().expect_ty();\n         if cx\n@@ -69,11 +72,11 @@ pub(super) fn check<'tcx>(\n                                 then {\n                                     match init.kind {\n                                         // immutable bindings that are initialized with literal\n-                                        ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n+                                        ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item, ctxt),\n                                         // immutable bindings that are initialized with constant\n                                         ExprKind::Path(ref path) => {\n                                             if let Res::Def(DefKind::Const, ..) = cx.qpath_res(path, init.hir_id) {\n-                                                emit_lint(cx, vec, pushed_item);\n+                                                emit_lint(cx, vec, pushed_item, ctxt);\n                                             }\n                                         }\n                                         _ => {},\n@@ -82,11 +85,11 @@ pub(super) fn check<'tcx>(\n                             }\n                         },\n                         // constant\n-                        Res::Def(DefKind::Const, ..) => emit_lint(cx, vec, pushed_item),\n+                        Res::Def(DefKind::Const, ..) => emit_lint(cx, vec, pushed_item, ctxt),\n                         _ => {},\n                     }\n                 },\n-                ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item),\n+                ExprKind::Lit(..) => emit_lint(cx, vec, pushed_item, ctxt),\n                 _ => {},\n             }\n         }\n@@ -98,7 +101,7 @@ struct SameItemPushVisitor<'a, 'tcx> {\n     non_deterministic_expr: bool,\n     multiple_pushes: bool,\n     // this field holds the last vec push operation visited, which should be the only push seen\n-    vec_push: Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>,\n+    vec_push: Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>, SyntaxContext)>,\n     cx: &'a LateContext<'tcx>,\n     used_locals: FxHashSet<HirId>,\n }\n@@ -118,7 +121,7 @@ impl<'a, 'tcx> SameItemPushVisitor<'a, 'tcx> {\n         if_chain! {\n             if !self.non_deterministic_expr;\n             if !self.multiple_pushes;\n-            if let Some((vec, _)) = self.vec_push;\n+            if let Some((vec, _, _)) = self.vec_push;\n             if let Some(hir_id) = path_to_local(vec);\n             then {\n                 !self.used_locals.contains(&hir_id)\n@@ -173,7 +176,10 @@ impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n \n // Given some statement, determine if that statement is a push on a Vec. If it is, return\n // the Vec being pushed into and the item being pushed\n-fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+fn get_vec_push<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    stmt: &'tcx Stmt<'_>,\n+) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>, SyntaxContext)> {\n     if_chain! {\n             // Extract method being called\n             if let StmtKind::Semi(semi_stmt) = &stmt.kind;\n@@ -184,7 +190,7 @@ fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr), sym::Vec);\n             if path.ident.name.as_str() == \"push\";\n             then {\n-                return Some((self_expr, pushed_item))\n+                return Some((self_expr, pushed_item, semi_stmt.span.ctxt()))\n             }\n     }\n     None"}, {"sha": "84ff3c710c25659ecff08c02314a8d297f33fff4", "filename": "clippy_lints/src/matches/manual_unwrap_or.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -33,14 +33,8 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, scrutinee:\n             let reindented_or_body =\n                 reindent_multiline(or_body_snippet.into(), true, Some(indent));\n \n-            let suggestion = if scrutinee.span.from_expansion() {\n-                    // we don't want parentheses around macro, e.g. `(some_macro!()).unwrap_or(0)`\n-                    sugg::Sugg::hir_with_macro_callsite(cx, scrutinee, \"..\")\n-                }\n-                else {\n-                    sugg::Sugg::hir(cx, scrutinee, \"..\").maybe_par()\n-                };\n-\n+            let mut app = Applicability::MachineApplicable;\n+            let suggestion = sugg::Sugg::hir_with_context(cx, scrutinee, expr.span.ctxt(), \"..\", &mut app).maybe_par();\n             span_lint_and_sugg(\n                 cx,\n                 MANUAL_UNWRAP_OR, expr.span,\n@@ -49,7 +43,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, scrutinee:\n                 format!(\n                     \"{suggestion}.unwrap_or({reindented_or_body})\",\n                 ),\n-                Applicability::MachineApplicable,\n+                app,\n             );\n         }\n     }"}, {"sha": "df1e585f10b21e60a359fde343343061542bedf3", "filename": "clippy_lints/src/matches/match_bool.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -10,9 +10,9 @@ use rustc_middle::ty;\n \n use super::MATCH_BOOL;\n \n-pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+pub(crate) fn check(cx: &LateContext<'_>, scrutinee: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     // Type of expression is `bool`.\n-    if *cx.typeck_results().expr_ty(ex).kind() == ty::Bool {\n+    if *cx.typeck_results().expr_ty(scrutinee).kind() == ty::Bool {\n         span_lint_and_then(\n             cx,\n             MATCH_BOOL,\n@@ -36,24 +36,26 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr:\n                     };\n \n                     if let Some((true_expr, false_expr)) = exprs {\n+                        let mut app = Applicability::HasPlaceholders;\n+                        let ctxt = expr.span.ctxt();\n                         let sugg = match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n                             (false, false) => Some(format!(\n                                 \"if {} {} else {}\",\n-                                snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\", Some(expr.span)),\n-                                expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n+                                snippet(cx, scrutinee.span, \"b\"),\n+                                expr_block(cx, true_expr, ctxt, \"..\", Some(expr.span), &mut app),\n+                                expr_block(cx, false_expr, ctxt, \"..\", Some(expr.span), &mut app)\n                             )),\n                             (false, true) => Some(format!(\n                                 \"if {} {}\",\n-                                snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\", Some(expr.span))\n+                                snippet(cx, scrutinee.span, \"b\"),\n+                                expr_block(cx, true_expr, ctxt, \"..\", Some(expr.span), &mut app)\n                             )),\n                             (true, false) => {\n-                                let test = Sugg::hir(cx, ex, \"..\");\n+                                let test = Sugg::hir(cx, scrutinee, \"..\");\n                                 Some(format!(\n                                     \"if {} {}\",\n                                     !test,\n-                                    expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n+                                    expr_block(cx, false_expr, ctxt, \"..\", Some(expr.span), &mut app)\n                                 ))\n                             },\n                             (true, true) => None,"}, {"sha": "aba4c85c59e284a631c853600795b49e7087ebae", "filename": "clippy_lints/src/matches/match_ref_pats.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -1,13 +1,14 @@\n use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n-use clippy_utils::source::snippet;\n+use clippy_utils::source::{snippet, walk_span_to_context};\n use clippy_utils::sugg::Sugg;\n use core::iter::once;\n+use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, Pat, PatKind};\n use rustc_lint::LateContext;\n \n use super::MATCH_REF_PATS;\n \n-pub(crate) fn check<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n+pub(crate) fn check<'a, 'b, I>(cx: &LateContext<'_>, scrutinee: &Expr<'_>, pats: I, expr: &Expr<'_>)\n where\n     'b: 'a,\n     I: Clone + Iterator<Item = &'a Pat<'b>>,\n@@ -17,13 +18,28 @@ where\n     }\n \n     let (first_sugg, msg, title);\n-    let span = ex.span.source_callsite();\n-    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n-        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n+    let ctxt = expr.span.ctxt();\n+    let mut app = Applicability::Unspecified;\n+    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = scrutinee.kind {\n+        if scrutinee.span.ctxt() != ctxt {\n+            return;\n+        }\n+        first_sugg = once((\n+            scrutinee.span,\n+            Sugg::hir_with_context(cx, inner, ctxt, \"..\", &mut app).to_string(),\n+        ));\n         msg = \"try\";\n         title = \"you don't need to add `&` to both the expression and the patterns\";\n     } else {\n-        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n+        let Some(span) = walk_span_to_context(scrutinee.span, ctxt) else {\n+            return;\n+        };\n+        first_sugg = once((\n+            span,\n+            Sugg::hir_with_context(cx, scrutinee, ctxt, \"..\", &mut app)\n+                .deref()\n+                .to_string(),\n+        ));\n         msg = \"instead of prefixing all patterns with `&`, you can dereference the expression\";\n         title = \"you don't need to add `&` to all patterns\";\n     }"}, {"sha": "eec5c1143d45231f782c3ff718ec39a64385f4f3", "filename": "clippy_lints/src/matches/match_single_binding.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::macros::HirNode;\n-use clippy_utils::source::{indent_of, snippet, snippet_block, snippet_with_applicability};\n-use clippy_utils::sugg::Sugg;\n+use clippy_utils::source::{indent_of, snippet, snippet_block_with_context, snippet_with_applicability};\n use clippy_utils::{get_parent_expr, is_refutable, peel_blocks};\n use rustc_errors::Applicability;\n use rustc_hir::{Arm, Expr, ExprKind, Node, PatKind};\n@@ -24,21 +23,25 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n     let matched_vars = ex.span;\n     let bind_names = arms[0].pat.span;\n     let match_body = peel_blocks(arms[0].body);\n-    let mut snippet_body = if match_body.span.from_expansion() {\n-        Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n-    } else {\n-        snippet_block(cx, match_body.span, \"..\", Some(expr.span)).to_string()\n-    };\n+    let mut app = Applicability::MaybeIncorrect;\n+    let (snippet_body, from_macro) = snippet_block_with_context(\n+        cx,\n+        match_body.span,\n+        arms[0].span.ctxt(),\n+        \"..\",\n+        Some(expr.span),\n+        &mut app,\n+    );\n+    let mut snippet_body = snippet_body.to_string();\n \n     // Do we need to add ';' to suggestion ?\n-    if let ExprKind::Block(block, _) = match_body.kind {\n+    if matches!(match_body.kind, ExprKind::Block(..)) {\n         // macro + expr_ty(body) == ()\n-        if block.span.from_expansion() && cx.typeck_results().expr_ty(match_body).is_unit() {\n+        if from_macro && cx.typeck_results().expr_ty(match_body).is_unit() {\n             snippet_body.push(';');\n         }\n     }\n \n-    let mut applicability = Applicability::MaybeIncorrect;\n     match arms[0].pat.kind {\n         PatKind::Binding(..) | PatKind::Tuple(_, _) | PatKind::Struct(..) => {\n             let (target_span, sugg) = match opt_parent_assign_span(cx, ex) {\n@@ -48,7 +51,7 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                         (ex, expr),\n                         (bind_names, matched_vars),\n                         &snippet_body,\n-                        &mut applicability,\n+                        &mut app,\n                         Some(span),\n                         true,\n                     );\n@@ -60,7 +63,7 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                         \"this assignment could be simplified\",\n                         \"consider removing the `match` expression\",\n                         sugg,\n-                        applicability,\n+                        app,\n                     );\n \n                     return;\n@@ -69,10 +72,10 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                     span,\n                     format!(\n                         \"let {} = {};\\n{}let {} = {snippet_body};\",\n-                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, bind_names, \"..\", &mut app),\n+                        snippet_with_applicability(cx, matched_vars, \"..\", &mut app),\n                         \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n-                        snippet_with_applicability(cx, pat_span, \"..\", &mut applicability)\n+                        snippet_with_applicability(cx, pat_span, \"..\", &mut app)\n                     ),\n                 ),\n                 None => {\n@@ -81,7 +84,7 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                         (ex, expr),\n                         (bind_names, matched_vars),\n                         &snippet_body,\n-                        &mut applicability,\n+                        &mut app,\n                         None,\n                         true,\n                     );\n@@ -96,7 +99,7 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                 \"this match could be written as a `let` statement\",\n                 \"consider using a `let` statement\",\n                 sugg,\n-                applicability,\n+                app,\n             );\n         },\n         PatKind::Wild => {\n@@ -106,7 +109,7 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                     (ex, expr),\n                     (bind_names, matched_vars),\n                     &snippet_body,\n-                    &mut applicability,\n+                    &mut app,\n                     None,\n                     false,\n                 );\n@@ -118,7 +121,7 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                     \"this match could be replaced by its scrutinee and body\",\n                     \"consider using the scrutinee and body instead\",\n                     sugg,\n-                    applicability,\n+                    app,\n                 );\n             } else {\n                 span_lint_and_sugg("}, {"sha": "e86106700540e77581011bec1bd89f5c8ec8e412", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -1,6 +1,6 @@\n use super::REDUNDANT_PATTERN_MATCHING;\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::source::snippet;\n+use clippy_utils::source::{snippet, walk_span_to_context};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{is_type_diagnostic_item, needs_ordered_drop};\n use clippy_utils::visitors::any_temporaries_need_ordered_drop;\n@@ -150,22 +150,25 @@ fn find_sugg_for_if_let<'tcx>(\n             // if/while let ... = ... { ... }\n             // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n             let expr_span = expr.span;\n+            let ctxt = expr.span.ctxt();\n \n             // if/while let ... = ... { ... }\n-            //                 ^^^\n-            let op_span = result_expr.span.source_callsite();\n+            //                    ^^^\n+            let Some(res_span) = walk_span_to_context(result_expr.span.source_callsite(), ctxt) else {\n+                return;\n+            };\n \n             // if/while let ... = ... { ... }\n-            // ^^^^^^^^^^^^^^^^^^^\n-            let span = expr_span.until(op_span.shrink_to_hi());\n+            // ^^^^^^^^^^^^^^^^^^^^^^\n+            let span = expr_span.until(res_span.shrink_to_hi());\n \n-            let app = if needs_drop {\n+            let mut app = if needs_drop {\n                 Applicability::MaybeIncorrect\n             } else {\n                 Applicability::MachineApplicable\n             };\n \n-            let sugg = Sugg::hir_with_macro_callsite(cx, result_expr, \"_\")\n+            let sugg = Sugg::hir_with_context(cx, result_expr, ctxt, \"_\", &mut app)\n                 .maybe_par()\n                 .to_string();\n "}, {"sha": "ad47c13896c58251805eb65a76181051347b47ef", "filename": "clippy_lints/src/matches/single_match.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -67,8 +67,10 @@ fn report_single_pattern(\n     els: Option<&Expr<'_>>,\n ) {\n     let lint = if els.is_some() { SINGLE_MATCH_ELSE } else { SINGLE_MATCH };\n+    let ctxt = expr.span.ctxt();\n+    let mut app = Applicability::HasPlaceholders;\n     let els_str = els.map_or(String::new(), |els| {\n-        format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n+        format!(\" else {}\", expr_block(cx, els, ctxt, \"..\", Some(expr.span), &mut app))\n     });\n \n     let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n@@ -103,7 +105,7 @@ fn report_single_pattern(\n                 // PartialEq for different reference counts may not exist.\n                 \"&\".repeat(ref_count_diff),\n                 snippet(cx, arms[0].pat.span, \"..\"),\n-                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n+                expr_block(cx, arms[0].body, ctxt, \"..\", Some(expr.span), &mut app),\n             );\n             (msg, sugg)\n         } else {\n@@ -112,21 +114,13 @@ fn report_single_pattern(\n                 \"if let {} = {} {}{els_str}\",\n                 snippet(cx, arms[0].pat.span, \"..\"),\n                 snippet(cx, ex.span, \"..\"),\n-                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n+                expr_block(cx, arms[0].body, ctxt, \"..\", Some(expr.span), &mut app),\n             );\n             (msg, sugg)\n         }\n     };\n \n-    span_lint_and_sugg(\n-        cx,\n-        lint,\n-        expr.span,\n-        msg,\n-        \"try this\",\n-        sugg,\n-        Applicability::HasPlaceholders,\n-    );\n+    span_lint_and_sugg(cx, lint, expr.span, msg, \"try this\", sugg, app);\n }\n \n fn check_opt_like<'a>("}, {"sha": "8ddb912f90b8e4f6adcdae7f60489ac1abde2564", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -1,6 +1,6 @@\n use super::{contains_return, BIND_INSTEAD_OF_MAP};\n use clippy_utils::diagnostics::{multispan_sugg_with_applicability, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::{snippet, snippet_with_macro_callsite};\n+use clippy_utils::source::{snippet, snippet_with_context};\n use clippy_utils::{peel_blocks, visitors::find_all_ret_expressions};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -77,11 +77,8 @@ pub(crate) trait BindInsteadOfMap {\n             if !contains_return(inner_expr);\n             if let Some(msg) = Self::lint_msg(cx);\n             then {\n-                let some_inner_snip = if inner_expr.span.from_expansion() {\n-                    snippet_with_macro_callsite(cx, inner_expr.span, \"_\")\n-                } else {\n-                    snippet(cx, inner_expr.span, \"_\")\n-                };\n+                let mut app = Applicability::MachineApplicable;\n+                let some_inner_snip = snippet_with_context(cx, inner_expr.span, closure_expr.span.ctxt(), \"_\", &mut app).0;\n \n                 let closure_args_snip = snippet(cx, closure_args_span, \"..\");\n                 let option_snip = snippet(cx, recv.span, \"..\");\n@@ -93,7 +90,7 @@ pub(crate) trait BindInsteadOfMap {\n                     &msg,\n                     \"try this\",\n                     note,\n-                    Applicability::MachineApplicable,\n+                    app,\n                 );\n                 true\n             } else {"}, {"sha": "5e8ad0861f33d8d1c639faf143320707867c5a8d", "filename": "clippy_lints/src/methods/clone_on_ref_ptr.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::paths;\n-use clippy_utils::source::snippet_with_macro_callsite;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::{is_type_diagnostic_item, match_type};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -33,7 +33,9 @@ pub(super) fn check(\n             return;\n         };\n \n-        let snippet = snippet_with_macro_callsite(cx, receiver.span, \"..\");\n+        // Sometimes unnecessary ::<_> after Rc/Arc/Weak\n+        let mut app = Applicability::Unspecified;\n+        let snippet = snippet_with_context(cx, receiver.span, expr.span.ctxt(), \"..\", &mut app).0;\n \n         span_lint_and_sugg(\n             cx,\n@@ -42,7 +44,7 @@ pub(super) fn check(\n             \"using `.clone()` on a ref-counted pointer\",\n             \"try this\",\n             format!(\"{caller_type}::<{}>::clone(&{snippet})\", subst.type_at(0)),\n-            Applicability::Unspecified, // Sometimes unnecessary ::<_> after Rc/Arc/Weak\n+            app,\n         );\n     }\n }"}, {"sha": "7ce28ea93e01a2747ca007048b1a8bd8ce99cb55", "filename": "clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::eager_or_lazy::switch_to_lazy_eval;\n-use clippy_utils::source::{snippet, snippet_with_macro_callsite};\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n use clippy_utils::{contains_return, is_trait_item, last_path_segment};\n use if_chain::if_chain;\n@@ -9,7 +9,6 @@ use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use std::borrow::Cow;\n \n use super::OR_FUN_CALL;\n \n@@ -111,37 +110,24 @@ pub(super) fn check<'tcx>(\n             if poss.contains(&name);\n \n             then {\n+                let ctxt = span.ctxt();\n+                let mut app = Applicability::HasPlaceholders;\n                 let sugg = {\n                     let (snippet_span, use_lambda) = match (fn_has_arguments, fun_span) {\n                         (false, Some(fun_span)) => (fun_span, false),\n                         _ => (arg.span, true),\n                     };\n \n-                    let format_span = |span: Span| {\n-                        let not_macro_argument_snippet = snippet_with_macro_callsite(cx, span, \"..\");\n-                        let snip = if not_macro_argument_snippet == \"vec![]\" {\n-                            let macro_expanded_snipped = snippet(cx, snippet_span, \"..\");\n-                            match macro_expanded_snipped.strip_prefix(\"$crate::vec::\") {\n-                                Some(stripped) => Cow::Owned(stripped.to_owned()),\n-                                None => macro_expanded_snipped,\n-                            }\n-                        } else {\n-                            not_macro_argument_snippet\n-                        };\n-\n-                        snip.to_string()\n-                    };\n-\n-                    let snip = format_span(snippet_span);\n+                    let snip = snippet_with_context(cx, snippet_span, ctxt, \"..\", &mut app).0;\n                     let snip = if use_lambda {\n                         let l_arg = if fn_has_arguments { \"_\" } else { \"\" };\n                         format!(\"|{l_arg}| {snip}\")\n                     } else {\n-                        snip\n+                        snip.into_owned()\n                     };\n \n                     if let Some(f) = second_arg {\n-                        let f = format_span(f.span);\n+                        let f = snippet_with_context(cx, f.span, ctxt, \"..\", &mut app).0;\n                         format!(\"{snip}, {f}\")\n                     } else {\n                         snip\n@@ -155,7 +141,7 @@ pub(super) fn check<'tcx>(\n                     &format!(\"use of `{name}` followed by a function call\"),\n                     \"try this\",\n                     format!(\"{name}_{suffix}({sugg})\"),\n-                    Applicability::HasPlaceholders,\n+                    app,\n                 );\n             }\n         }"}, {"sha": "3752b9a946f8ea20a9dfc91450bf154293eda6a4", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_hir_and_then};\n-use clippy_utils::source::{snippet, snippet_opt};\n+use clippy_utils::source::{snippet, snippet_opt, snippet_with_context};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n@@ -181,20 +181,17 @@ impl<'tcx> LateLintPass<'tcx> for LintPass {\n             if let PatKind::Binding(BindingAnnotation(ByRef::Yes, mutabl), .., name, None) = local.pat.kind;\n             if let Some(init) = local.init;\n             then {\n-                // use the macro callsite when the init span (but not the whole local span)\n-                // comes from an expansion like `vec![1, 2, 3]` in `let ref _ = vec![1, 2, 3];`\n-                let sugg_init = if init.span.from_expansion() && !local.span.from_expansion() {\n-                    Sugg::hir_with_macro_callsite(cx, init, \"..\")\n-                } else {\n-                    Sugg::hir(cx, init, \"..\")\n-                };\n+                let ctxt = local.span.ctxt();\n+                let mut app = Applicability::MachineApplicable;\n+                let sugg_init = Sugg::hir_with_context(cx, init, ctxt, \"..\", &mut app);\n                 let (mutopt, initref) = if mutabl == Mutability::Mut {\n                     (\"mut \", sugg_init.mut_addr())\n                 } else {\n                     (\"\", sugg_init.addr())\n                 };\n                 let tyopt = if let Some(ty) = local.ty {\n-                    format!(\": &{mutopt}{ty}\", ty=snippet(cx, ty.span, \"..\"))\n+                    let ty_snip = snippet_with_context(cx, ty.span, ctxt, \"_\", &mut app).0;\n+                    format!(\": &{mutopt}{ty_snip}\")\n                 } else {\n                     String::new()\n                 };\n@@ -212,7 +209,7 @@ impl<'tcx> LateLintPass<'tcx> for LintPass {\n                                 \"let {name}{tyopt} = {initref};\",\n                                 name=snippet(cx, name.span, \"..\"),\n                             ),\n-                            Applicability::MachineApplicable,\n+                            app,\n                         );\n                     }\n                 );"}, {"sha": "c87059bf61de3cb2f119cb9db4e6290e2e8af0e5", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -340,26 +340,19 @@ fn suggest_bool_comparison<'a, 'tcx>(\n     cx: &LateContext<'tcx>,\n     e: &'tcx Expr<'_>,\n     expr: &Expr<'_>,\n-    mut applicability: Applicability,\n+    mut app: Applicability,\n     message: &str,\n     conv_hint: impl FnOnce(Sugg<'a>) -> Sugg<'a>,\n ) {\n-    let hint = if expr.span.from_expansion() {\n-        if applicability != Applicability::Unspecified {\n-            applicability = Applicability::MaybeIncorrect;\n-        }\n-        Sugg::hir_with_macro_callsite(cx, expr, \"..\")\n-    } else {\n-        Sugg::hir_with_applicability(cx, expr, \"..\", &mut applicability)\n-    };\n+    let hint = Sugg::hir_with_context(cx, expr, e.span.ctxt(), \"..\", &mut app);\n     span_lint_and_sugg(\n         cx,\n         BOOL_COMPARISON,\n         e.span,\n         message,\n         \"try simplifying it as shown\",\n         conv_hint(hint).to_string(),\n-        applicability,\n+        app,\n     );\n }\n "}, {"sha": "bbbcda069c5517fe0074fbe99c738870dedc30a4", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::{\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::SyntaxContext;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -95,10 +96,10 @@ struct OptionOccurrence {\n     none_expr: String,\n }\n \n-fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: bool, as_mut: bool) -> String {\n+fn format_option_in_sugg(cond_sugg: Sugg<'_>, as_ref: bool, as_mut: bool) -> String {\n     format!(\n         \"{}{}\",\n-        Sugg::hir_with_macro_callsite(cx, cond_expr, \"..\").maybe_par(),\n+        cond_sugg.maybe_par(),\n         if as_mut {\n             \".as_mut()\"\n         } else if as_ref {\n@@ -111,6 +112,7 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n \n fn try_get_option_occurrence<'tcx>(\n     cx: &LateContext<'tcx>,\n+    ctxt: SyntaxContext,\n     pat: &Pat<'tcx>,\n     expr: &Expr<'_>,\n     if_then: &'tcx Expr<'_>,\n@@ -160,11 +162,23 @@ fn try_get_option_occurrence<'tcx>(\n                 }\n             }\n \n+            let mut app = Applicability::Unspecified;\n             return Some(OptionOccurrence {\n-                option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),\n+                option: format_option_in_sugg(\n+                    Sugg::hir_with_context(cx, cond_expr, ctxt, \"..\", &mut app),\n+                    as_ref,\n+                    as_mut,\n+                ),\n                 method_sugg: method_sugg.to_string(),\n-                some_expr: format!(\"|{capture_mut}{capture_name}| {}\", Sugg::hir_with_macro_callsite(cx, some_body, \"..\")),\n-                none_expr: format!(\"{}{}\", if method_sugg == \"map_or\" { \"\" } else { \"|| \" }, Sugg::hir_with_macro_callsite(cx, none_body, \"..\")),\n+                some_expr: format!(\n+                    \"|{capture_mut}{capture_name}| {}\",\n+                    Sugg::hir_with_context(cx, some_body, ctxt, \"..\", &mut app),\n+                ),\n+                none_expr: format!(\n+                    \"{}{}\",\n+                    if method_sugg == \"map_or\" { \"\" } else { \"|| \" },\n+                    Sugg::hir_with_context(cx, none_body, ctxt, \"..\", &mut app),\n+                ),\n             });\n         }\n     }\n@@ -194,7 +208,7 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n     }) = higher::IfLet::hir(cx, expr)\n     {\n         if !is_else_clause(cx.tcx, expr) {\n-            return try_get_option_occurrence(cx, let_pat, let_expr, if_then, if_else);\n+            return try_get_option_occurrence(cx, expr.span.ctxt(), let_pat, let_expr, if_then, if_else);\n         }\n     }\n     None\n@@ -203,7 +217,7 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n fn detect_option_match<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionOccurrence> {\n     if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n         if let Some((let_pat, if_then, if_else)) = try_convert_match(cx, arms) {\n-            return try_get_option_occurrence(cx, let_pat, ex, if_then, if_else);\n+            return try_get_option_occurrence(cx, expr.span.ctxt(), let_pat, ex, if_then, if_else);\n         }\n     }\n     None"}, {"sha": "355f907e2577b6ebebc75bdbf7338e86ed9d6596", "filename": "clippy_lints/src/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -1,7 +1,6 @@\n use crate::rustc_lint::LintContext;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::sugg;\n+use clippy_utils::source::snippet_with_context;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Block, ExprKind};\n@@ -44,25 +43,23 @@ impl<'tcx> LateLintPass<'tcx> for SemicolonIfNothingReturned {\n             if let Some(expr) = block.expr;\n             let t_expr = cx.typeck_results().expr_ty(expr);\n             if t_expr.is_unit();\n-            if let snippet = snippet_with_macro_callsite(cx, expr.span, \"}\");\n+            let mut app = Applicability::MaybeIncorrect;\n+            if let snippet = snippet_with_context(cx, expr.span, block.span.ctxt(), \"}\", &mut app).0;\n             if !snippet.ends_with('}') && !snippet.ends_with(';');\n             if cx.sess().source_map().is_multiline(block.span);\n             then {\n                 // filter out the desugared `for` loop\n                 if let ExprKind::DropTemps(..) = &expr.kind {\n                     return;\n                 }\n-\n-                let sugg = sugg::Sugg::hir_with_macro_callsite(cx, expr, \"..\");\n-                let suggestion = format!(\"{sugg};\");\n                 span_lint_and_sugg(\n                     cx,\n                     SEMICOLON_IF_NOTHING_RETURNED,\n                     expr.span.source_callsite(),\n                     \"consider adding a `;` to the last statement for consistent formatting\",\n                     \"add a `;` here\",\n-                    suggestion,\n-                    Applicability::MaybeIncorrect,\n+                    format!(\"{snippet};\"),\n+                    app,\n                 );\n             }\n         }"}, {"sha": "a0164fdfc1ea0291a4de79982e4a27b8d90bf575", "filename": "clippy_lints/src/unit_types/let_unit_value.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::get_parent_node;\n-use clippy_utils::source::snippet_with_macro_callsite;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::visitors::{for_each_local_assignment, for_each_value_source};\n use core::ops::ControlFlow;\n use rustc_errors::Applicability;\n@@ -48,12 +48,13 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n                 \"this let-binding has unit value\",\n                 |diag| {\n                     if let Some(expr) = &local.init {\n-                        let snip = snippet_with_macro_callsite(cx, expr.span, \"()\");\n+                        let mut app = Applicability::MachineApplicable;\n+                        let snip = snippet_with_context(cx, expr.span, local.span.ctxt(), \"()\", &mut app).0;\n                         diag.span_suggestion(\n                             local.span,\n                             \"omit the `let` binding\",\n                             format!(\"{snip};\"),\n-                            Applicability::MachineApplicable, // snippet\n+                            app,\n                         );\n                     }\n                 },"}, {"sha": "47f19557e587293b4efb111175663771f7f188b0", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n-use clippy_utils::source::{snippet, snippet_with_macro_callsite};\n+use clippy_utils::source::{snippet, snippet_with_context};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{is_copy, is_type_diagnostic_item, same_type_and_consts};\n use clippy_utils::{get_parent_expr, is_trait_method, match_def_path, path_to_local, paths};\n@@ -68,15 +68,16 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                     let a = cx.typeck_results().expr_ty(e);\n                     let b = cx.typeck_results().expr_ty(recv);\n                     if same_type_and_consts(a, b) {\n-                        let sugg = snippet_with_macro_callsite(cx, recv.span, \"<expr>\").to_string();\n+                        let mut app = Applicability::MachineApplicable;\n+                        let sugg = snippet_with_context(cx, recv.span, e.span.ctxt(), \"<expr>\", &mut app).0;\n                         span_lint_and_sugg(\n                             cx,\n                             USELESS_CONVERSION,\n                             e.span,\n                             &format!(\"useless conversion to the same type: `{b}`\"),\n                             \"consider removing `.into()`\",\n-                            sugg,\n-                            Applicability::MachineApplicable, // snippet\n+                            sugg.into_owned(),\n+                            app,\n                         );\n                     }\n                 }\n@@ -165,7 +166,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                             if same_type_and_consts(a, b);\n \n                             then {\n-                                let sugg = Sugg::hir_with_macro_callsite(cx, arg, \"<expr>\").maybe_par();\n+                                let mut app = Applicability::MachineApplicable;\n+                                let sugg = Sugg::hir_with_context(cx, arg, e.span.ctxt(), \"<expr>\", &mut app).maybe_par();\n                                 let sugg_msg =\n                                     format!(\"consider removing `{}()`\", snippet(cx, path.span, \"From::from\"));\n                                 span_lint_and_sugg(\n@@ -175,7 +177,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                                     &format!(\"useless conversion to the same type: `{b}`\"),\n                                     &sugg_msg,\n                                     sugg.to_string(),\n-                                    Applicability::MachineApplicable, // snippet\n+                                    app,\n                                 );\n                             }\n                         }"}, {"sha": "62fa37660fad5b0f241bfe6eeab1a4f4099a0943", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -12,24 +12,21 @@ use rustc_span::{BytePos, Pos, Span, SpanData, SyntaxContext, DUMMY_SP};\n use std::borrow::Cow;\n \n /// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n-/// Also takes an `Option<String>` which can be put inside the braces.\n-pub fn expr_block<'a, T: LintContext>(\n+pub fn expr_block<T: LintContext>(\n     cx: &T,\n     expr: &Expr<'_>,\n-    option: Option<String>,\n-    default: &'a str,\n+    outer: SyntaxContext,\n+    default: &str,\n     indent_relative_to: Option<Span>,\n-) -> Cow<'a, str> {\n-    let code = snippet_block(cx, expr.span, default, indent_relative_to);\n-    let string = option.unwrap_or_default();\n-    if expr.span.from_expansion() {\n-        Cow::Owned(format!(\"{{ {} }}\", snippet_with_macro_callsite(cx, expr.span, default)))\n+    app: &mut Applicability,\n+) -> String {\n+    let (code, from_macro) = snippet_block_with_context(cx, expr.span, outer, default, indent_relative_to, app);\n+    if from_macro {\n+        format!(\"{{ {code} }}\")\n     } else if let ExprKind::Block(_, _) = expr.kind {\n-        Cow::Owned(format!(\"{code}{string}\"))\n-    } else if string.is_empty() {\n-        Cow::Owned(format!(\"{{ {code} }}\"))\n+        format!(\"{code}\")\n     } else {\n-        Cow::Owned(format!(\"{{\\n{code};\\n{string}\\n}}\"))\n+        format!(\"{{ {code} }}\")\n     }\n }\n \n@@ -229,12 +226,6 @@ fn snippet_with_applicability_sess<'a>(\n     )\n }\n \n-/// Same as `snippet`, but should only be used when it's clear that the input span is\n-/// not a macro argument.\n-pub fn snippet_with_macro_callsite<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n-    snippet(cx, span.source_callsite(), default)\n-}\n-\n /// Converts a span to a code snippet. Returns `None` if not available.\n pub fn snippet_opt(cx: &impl LintContext, span: Span) -> Option<String> {\n     snippet_opt_sess(cx.sess(), span)\n@@ -303,6 +294,19 @@ pub fn snippet_block_with_applicability<'a>(\n     reindent_multiline(snip, true, indent)\n }\n \n+pub fn snippet_block_with_context<'a>(\n+    cx: &impl LintContext,\n+    span: Span,\n+    outer: SyntaxContext,\n+    default: &'a str,\n+    indent_relative_to: Option<Span>,\n+    app: &mut Applicability,\n+) -> (Cow<'a, str>, bool) {\n+    let (snip, from_macro) = snippet_with_context(cx, span, outer, default, app);\n+    let indent = indent_relative_to.and_then(|s| indent_of(cx, s));\n+    (reindent_multiline(snip, true, indent), from_macro)\n+}\n+\n /// Same as `snippet_with_applicability`, but first walks the span up to the given context. This\n /// will result in the macro call, rather then the expansion, if the span is from a child context.\n /// If the span is not from a child context, it will be used directly instead."}, {"sha": "8e3ee22a7656b742b0a423430967a828ced42f52", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -1,9 +1,7 @@\n //! Contains utility functions to generate suggestions.\n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::source::{\n-    snippet, snippet_opt, snippet_with_applicability, snippet_with_context, snippet_with_macro_callsite,\n-};\n+use crate::source::{snippet, snippet_opt, snippet_with_applicability, snippet_with_context};\n use crate::ty::expr_sig;\n use crate::{get_parent_expr_for_hir, higher};\n use rustc_ast::util::parser::AssocOp;\n@@ -89,12 +87,6 @@ impl<'a> Sugg<'a> {\n         })\n     }\n \n-    /// Same as `hir`, but will use the pre expansion span if the `expr` was in a macro.\n-    pub fn hir_with_macro_callsite(cx: &LateContext<'_>, expr: &hir::Expr<'_>, default: &'a str) -> Self {\n-        let get_snippet = |span| snippet_with_macro_callsite(cx, span, default);\n-        Self::hir_from_snippet(expr, get_snippet)\n-    }\n-\n     /// Same as `hir`, but first walks the span up to the given context. This will result in the\n     /// macro call, rather then the expansion, if the span is from a child context. If the span is\n     /// not from a child context, it will be used directly instead."}, {"sha": "42348df4480b3ec7b142866c317f07d7a60d5619", "filename": "tests/ui/redundant_pattern_matching_result.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/tests%2Fui%2Fredundant_pattern_matching_result.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/tests%2Fui%2Fredundant_pattern_matching_result.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_result.fixed?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -69,8 +69,8 @@ fn issue5504() {\n     }\n \n     fn try_result_opt() -> Result<i32, i32> {\n-        while (r#try!(result_opt())).is_some() {}\n-        if (r#try!(result_opt())).is_some() {}\n+        while r#try!(result_opt()).is_some() {}\n+        if r#try!(result_opt()).is_some() {}\n         Ok(42)\n     }\n "}, {"sha": "d6a46babb77952de2a4d3f602841b77172bef6d6", "filename": "tests/ui/redundant_pattern_matching_result.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a81a3e5cfc47908154b13bd921f9c03c5592010/tests%2Fui%2Fredundant_pattern_matching_result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a81a3e5cfc47908154b13bd921f9c03c5592010/tests%2Fui%2Fredundant_pattern_matching_result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_result.stderr?ref=1a81a3e5cfc47908154b13bd921f9c03c5592010", "patch": "@@ -88,13 +88,13 @@ error: redundant pattern matching, consider using `is_some()`\n   --> $DIR/redundant_pattern_matching_result.rs:84:19\n    |\n LL |         while let Some(_) = r#try!(result_opt()) {}\n-   |         ----------^^^^^^^----------------------- help: try this: `while (r#try!(result_opt())).is_some()`\n+   |         ----------^^^^^^^----------------------- help: try this: `while r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n   --> $DIR/redundant_pattern_matching_result.rs:85:16\n    |\n LL |         if let Some(_) = r#try!(result_opt()) {}\n-   |         -------^^^^^^^----------------------- help: try this: `if (r#try!(result_opt())).is_some()`\n+   |         -------^^^^^^^----------------------- help: try this: `if r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n   --> $DIR/redundant_pattern_matching_result.rs:91:12"}]}