{"sha": "aa5740c715001f981515ed46faaddebf67cb9539", "node_id": "C_kwDOAAsO6NoAKGFhNTc0MGM3MTUwMDFmOTgxNTE1ZWQ0NmZhYWRkZWJmNjdjYjk1Mzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-23T12:51:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-23T12:51:15Z"}, "message": "Auto merge of #90104 - spastorino:coherence-for-negative-trait, r=nikomatsakis\n\nImplement coherence checks for negative trait impls\n\nThe main purpose of this PR is to be able to [move Error trait to core](https://github.com/rust-lang/project-error-handling/issues/3).\n\nThis feature is necessary to handle the following from impl on box.\n\n```rust\nimpl From<&str> for Box<dyn Error> { ... }\n```\n\nWithout having negative traits affect coherence moving the error trait into `core` and moving that `From` impl to `alloc` will cause the from impl to no longer compiler because of a potential future incompatibility. The compiler indicates that `&str` _could_ introduce an `Error` impl in the future, and thus prevents the `From` impl in `alloc` that would cause overlap with `From<E: Error> for Box<dyn Error>`. Adding `impl !Error for &str {}` with the negative trait coherence feature will disable this error by encoding a stability guarantee that `&str` will never implement `Error`, making the `From` impl compile.\n\nWe would have this in `alloc`:\n\n```rust\nimpl From<&str> for Box<dyn Error> {} // A\nimpl<E> From<E> for Box<dyn Error> where E: Error {} // B\n```\n\nand this in `core`:\n\n```rust\ntrait Error {}\nimpl !Error for &str {}\n```\n\nr? `@nikomatsakis`\n\nThis PR was built on top of `@yaahc` PR #85764.\n\nLanguage team proposal: to https://github.com/rust-lang/lang-team/issues/96", "tree": {"sha": "68687408faa98d4127cd5b297a543a83f13262eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68687408faa98d4127cd5b297a543a83f13262eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa5740c715001f981515ed46faaddebf67cb9539", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa5740c715001f981515ed46faaddebf67cb9539", "html_url": "https://github.com/rust-lang/rust/commit/aa5740c715001f981515ed46faaddebf67cb9539", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa5740c715001f981515ed46faaddebf67cb9539/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55ccbd090d96ec3bb28dbcb383e65bbfa3c293ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/55ccbd090d96ec3bb28dbcb383e65bbfa3c293ff", "html_url": "https://github.com/rust-lang/rust/commit/55ccbd090d96ec3bb28dbcb383e65bbfa3c293ff"}, {"sha": "3287f72d39df22a4672527f8f97a771d11071a6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3287f72d39df22a4672527f8f97a771d11071a6c", "html_url": "https://github.com/rust-lang/rust/commit/3287f72d39df22a4672527f8f97a771d11071a6c"}], "stats": {"total": 738, "additions": 545, "deletions": 193}, "files": [{"sha": "0fa72ed8241bc61086a1c7cf0fd05cb07ffd6872", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -94,6 +94,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Some(ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n                 trait_ref,\n                 constness: ty::BoundConstness::NotConst,\n+                polarity: ty::ImplPolarity::Positive,\n             }))),\n             locations,\n             category,"}, {"sha": "85f37c813d85d1b2bbe3242b4c8159b90197ffc7", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -854,6 +854,7 @@ impl Visitor<'tcx> for Checker<'mir, 'tcx> {\n                         Binder::dummy(TraitPredicate {\n                             trait_ref,\n                             constness: ty::BoundConstness::ConstIfConst,\n+                            polarity: ty::ImplPolarity::Positive,\n                         }),\n                     );\n "}, {"sha": "aa42f8936f32c26da5bf10824b97d38f9f0c4ee1", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -162,6 +162,7 @@ impl Qualif for NeedsNonConstDrop {\n             ty::Binder::dummy(ty::TraitPredicate {\n                 trait_ref,\n                 constness: ty::BoundConstness::ConstIfConst,\n+                polarity: ty::ImplPolarity::Positive,\n             }),\n         );\n "}, {"sha": "33188d375f5d5e2f333ff8605a5414cf58b796ac", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -556,6 +556,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(TEST, rustc_outlives, Normal, template!(Word)),\n     rustc_attr!(TEST, rustc_capture_analysis, Normal, template!(Word)),\n     rustc_attr!(TEST, rustc_insignificant_dtor, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_strict_coherence, Normal, template!(Word)),\n     rustc_attr!(TEST, rustc_variance, Normal, template!(Word)),\n     rustc_attr!(TEST, rustc_layout, Normal, template!(List: \"field1, field2, ...\")),\n     rustc_attr!(TEST, rustc_regions, Normal, template!(Word)),"}, {"sha": "e8622b3c819d2316316daa9c3a46aaddcc35181d", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -10,7 +10,7 @@ pub mod util;\n \n use rustc_hir as hir;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::{self, Const, Ty};\n+use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n use rustc_span::Span;\n \n pub use self::FulfillmentErrorCode::*;\n@@ -55,6 +55,20 @@ pub struct Obligation<'tcx, T> {\n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n+impl PredicateObligation<'tcx> {\n+    /// Flips the polarity of the inner predicate.\n+    ///\n+    /// Given `T: Trait` predicate it returns `T: !Trait` and given `T: !Trait` returns `T: Trait`.\n+    pub fn flip_polarity(&self, tcx: TyCtxt<'tcx>) -> Option<PredicateObligation<'tcx>> {\n+        Some(PredicateObligation {\n+            cause: self.cause.clone(),\n+            param_env: self.param_env,\n+            predicate: self.predicate.flip_polarity(tcx)?,\n+            recursion_depth: self.recursion_depth,\n+        })\n+    }\n+}\n+\n // `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(PredicateObligation<'_>, 32);\n@@ -129,6 +143,10 @@ impl<'tcx> FulfillmentError<'tcx> {\n }\n \n impl<'tcx> TraitObligation<'tcx> {\n+    pub fn polarity(&self) -> ty::ImplPolarity {\n+        self.predicate.skip_binder().polarity\n+    }\n+\n     pub fn self_ty(&self) -> ty::Binder<'tcx, Ty<'tcx>> {\n         self.predicate.map_bound(|p| p.self_ty())\n     }"}, {"sha": "560660517f34b27ab7134b515951762b6e9c8133", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -12,12 +12,14 @@ use rustc_hir::def_id::DefId;\n use rustc_query_system::cache::Cache;\n \n pub type SelectionCache<'tcx> = Cache<\n-    ty::ConstnessAnd<ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>>,\n+    (ty::ConstnessAnd<ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>>, ty::ImplPolarity),\n     SelectionResult<'tcx, SelectionCandidate<'tcx>>,\n >;\n \n-pub type EvaluationCache<'tcx> =\n-    Cache<ty::ParamEnvAnd<'tcx, ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>>, EvaluationResult>;\n+pub type EvaluationCache<'tcx> = Cache<\n+    (ty::ParamEnvAnd<'tcx, ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>>, ty::ImplPolarity),\n+    EvaluationResult,\n+>;\n \n /// The selection process begins by considering all impls, where\n /// clauses, and so forth that might resolve an obligation. Sometimes\n@@ -101,7 +103,7 @@ pub enum SelectionCandidate<'tcx> {\n         /// `false` if there are no *further* obligations.\n         has_nested: bool,\n     },\n-    ParamCandidate(ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>),\n+    ParamCandidate((ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>, ty::ImplPolarity)),\n     ImplCandidate(DefId),\n     AutoImplCandidate(DefId),\n "}, {"sha": "2bd9415171d7d5d2ac0af852205e531aa736a01c", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -34,6 +34,7 @@ impl<T> ExpectedFound<T> {\n pub enum TypeError<'tcx> {\n     Mismatch,\n     ConstnessMismatch(ExpectedFound<ty::BoundConstness>),\n+    PolarityMismatch(ExpectedFound<ty::ImplPolarity>),\n     UnsafetyMismatch(ExpectedFound<hir::Unsafety>),\n     AbiMismatch(ExpectedFound<abi::Abi>),\n     Mutability,\n@@ -104,6 +105,9 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             ConstnessMismatch(values) => {\n                 write!(f, \"expected {} bound, found {} bound\", values.expected, values.found)\n             }\n+            PolarityMismatch(values) => {\n+                write!(f, \"expected {} polarity, found {} polarity\", values.expected, values.found)\n+            }\n             UnsafetyMismatch(values) => {\n                 write!(f, \"expected {} fn, found {} fn\", values.expected, values.found)\n             }\n@@ -212,10 +216,9 @@ impl<'tcx> TypeError<'tcx> {\n         use self::TypeError::*;\n         match self {\n             CyclicTy(_) | CyclicConst(_) | UnsafetyMismatch(_) | ConstnessMismatch(_)\n-            | Mismatch | AbiMismatch(_) | FixedArraySize(_) | ArgumentSorts(..) | Sorts(_)\n-            | IntMismatch(_) | FloatMismatch(_) | VariadicMismatch(_) | TargetFeatureCast(_) => {\n-                false\n-            }\n+            | PolarityMismatch(_) | Mismatch | AbiMismatch(_) | FixedArraySize(_)\n+            | ArgumentSorts(..) | Sorts(_) | IntMismatch(_) | FloatMismatch(_)\n+            | VariadicMismatch(_) | TargetFeatureCast(_) => false,\n \n             Mutability\n             | ArgumentMutability(_)"}, {"sha": "cf47da157d19f7c969eb8e0e9724d06056f052f0", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 63, "deletions": 2, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -164,7 +164,18 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-#[derive(Copy, Clone, PartialEq, TyEncodable, TyDecodable, HashStable, Debug)]\n+#[derive(\n+    Copy,\n+    Clone,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    TyEncodable,\n+    TyDecodable,\n+    HashStable,\n+    Debug,\n+    TypeFoldable\n+)]\n pub enum ImplPolarity {\n     /// `impl Trait for Type`\n     Positive,\n@@ -177,6 +188,27 @@ pub enum ImplPolarity {\n     Reservation,\n }\n \n+impl ImplPolarity {\n+    /// Flips polarity by turning `Positive` into `Negative` and `Negative` into `Positive`.\n+    pub fn flip(&self) -> Option<ImplPolarity> {\n+        match self {\n+            ImplPolarity::Positive => Some(ImplPolarity::Negative),\n+            ImplPolarity::Negative => Some(ImplPolarity::Positive),\n+            ImplPolarity::Reservation => None,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for ImplPolarity {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::Positive => f.write_str(\"positive\"),\n+            Self::Negative => f.write_str(\"negative\"),\n+            Self::Reservation => f.write_str(\"reservation\"),\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Copy, Hash, TyEncodable, TyDecodable, HashStable)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n@@ -459,6 +491,29 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn kind(self) -> Binder<'tcx, PredicateKind<'tcx>> {\n         self.inner.kind\n     }\n+\n+    /// Flips the polarity of a Predicate.\n+    ///\n+    /// Given `T: Trait` predicate it returns `T: !Trait` and given `T: !Trait` returns `T: Trait`.\n+    pub fn flip_polarity(&self, tcx: TyCtxt<'tcx>) -> Option<Predicate<'tcx>> {\n+        let kind = self\n+            .inner\n+            .kind\n+            .map_bound(|kind| match kind {\n+                PredicateKind::Trait(TraitPredicate { trait_ref, constness, polarity }) => {\n+                    Some(PredicateKind::Trait(TraitPredicate {\n+                        trait_ref,\n+                        constness,\n+                        polarity: polarity.flip()?,\n+                    }))\n+                }\n+\n+                _ => None,\n+            })\n+            .transpose()?;\n+\n+        Some(tcx.mk_predicate(kind))\n+    }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n@@ -654,6 +709,8 @@ pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>,\n \n     pub constness: BoundConstness,\n+\n+    pub polarity: ImplPolarity,\n }\n \n pub type PolyTraitPredicate<'tcx> = ty::Binder<'tcx, TraitPredicate<'tcx>>;\n@@ -788,7 +845,11 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         self.value\n             .map_bound(|trait_ref| {\n-                PredicateKind::Trait(ty::TraitPredicate { trait_ref, constness: self.constness })\n+                PredicateKind::Trait(ty::TraitPredicate {\n+                    trait_ref,\n+                    constness: self.constness,\n+                    polarity: ty::ImplPolarity::Positive,\n+                })\n             })\n             .to_predicate(tcx)\n     }"}, {"sha": "8b20e1eec9a86e03ba2d3992530b195e385f4a59", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -797,6 +797,20 @@ impl<'tcx> Relate<'tcx> for GenericArg<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for ty::ImplPolarity {\n+    fn relate<R: TypeRelation<'tcx>>(\n+        relation: &mut R,\n+        a: ty::ImplPolarity,\n+        b: ty::ImplPolarity,\n+    ) -> RelateResult<'tcx, ty::ImplPolarity> {\n+        if a != b {\n+            Err(TypeError::PolarityMismatch(expected_found(relation, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n@@ -806,6 +820,7 @@ impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n         Ok(ty::TraitPredicate {\n             trait_ref: relation.relate(a.trait_ref, b.trait_ref)?,\n             constness: relation.relate(a.constness, b.constness)?,\n+            polarity: relation.relate(a.polarity, b.polarity)?,\n         })\n     }\n }"}, {"sha": "d6069395474ab21ddd877c02e804944deafc7d44", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -157,7 +157,7 @@ impl fmt::Debug for ty::TraitPredicate<'tcx> {\n         if let ty::BoundConstness::ConstIfConst = self.constness {\n             write!(f, \"~const \")?;\n         }\n-        write!(f, \"TraitPredicate({:?})\", self.trait_ref)\n+        write!(f, \"TraitPredicate({:?}, polarity:{:?})\", self.trait_ref, self.polarity)\n     }\n }\n \n@@ -365,8 +365,11 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n-        tcx.lift(self.trait_ref)\n-            .map(|trait_ref| ty::TraitPredicate { trait_ref, constness: self.constness })\n+        tcx.lift(self.trait_ref).map(|trait_ref| ty::TraitPredicate {\n+            trait_ref,\n+            constness: self.constness,\n+            polarity: self.polarity,\n+        })\n     }\n }\n \n@@ -591,6 +594,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n         Some(match self {\n             Mismatch => Mismatch,\n             ConstnessMismatch(x) => ConstnessMismatch(x),\n+            PolarityMismatch(x) => PolarityMismatch(x),\n             UnsafetyMismatch(x) => UnsafetyMismatch(x),\n             AbiMismatch(x) => AbiMismatch(x),\n             Mutability => Mutability,"}, {"sha": "874de3366d79213ee7499075d518f5a41f3eb58d", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -882,6 +882,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n         self.map_bound(|trait_ref| ty::TraitPredicate {\n             trait_ref,\n             constness: ty::BoundConstness::NotConst,\n+            polarity: ty::ImplPolarity::Positive,\n         })\n     }\n }"}, {"sha": "fa34b9abc1e6c9314288ae045f6d1e71dde8ec03", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -124,9 +124,11 @@ where\n \n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<V::BreakTy> {\n         match predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref, constness: _ }) => {\n-                self.visit_trait(trait_ref)\n-            }\n+            ty::PredicateKind::Trait(ty::TraitPredicate {\n+                trait_ref,\n+                constness: _,\n+                polarity: _,\n+            }) => self.visit_trait(trait_ref),\n             ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n                 ty.visit_with(self)?;\n                 self.visit_projection_ty(projection_ty)"}, {"sha": "3e6526d147e293cb8849fa9893c745834be19bd8", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -1141,6 +1141,7 @@ symbols! {\n         rustc_specialization_trait,\n         rustc_stable,\n         rustc_std_internal_symbol,\n+        rustc_strict_coherence,\n         rustc_symbol_name,\n         rustc_synthetic,\n         rustc_test_marker,"}, {"sha": "6452b520452d6802b157c023ecf457620a3da1c3", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -286,6 +286,8 @@ impl AutoTraitFinder<'tcx> {\n                 substs: infcx.tcx.mk_substs_trait(ty, &[]),\n             },\n             constness: ty::BoundConstness::NotConst,\n+            // Auto traits are positive\n+            polarity: ty::ImplPolarity::Positive,\n         }));\n \n         let computed_preds = param_env.caller_bounds().iter();"}, {"sha": "42d3194aed48af5883490d2d7be5d738024b209e", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -5,9 +5,12 @@\n //! [trait-specialization]: https://rustc-dev-guide.rust-lang.org/traits/specialization.html\n \n use crate::infer::{CombinedSnapshot, InferOk, TyCtxtInferExt};\n+use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::SkipLeakCheck;\n-use crate::traits::{self, Normalized, Obligation, ObligationCause, SelectionContext};\n+use crate::traits::{\n+    self, Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext,\n+};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::Subst;\n@@ -158,6 +161,19 @@ fn overlap_within_probe(\n     b_def_id: DefId,\n     snapshot: &CombinedSnapshot<'_, 'tcx>,\n ) -> Option<OverlapResult<'tcx>> {\n+    fn loose_check(selcx: &mut SelectionContext<'cx, 'tcx>, o: &PredicateObligation<'tcx>) -> bool {\n+        !selcx.predicate_may_hold_fatal(o)\n+    }\n+\n+    fn strict_check(selcx: &SelectionContext<'cx, 'tcx>, o: &PredicateObligation<'tcx>) -> bool {\n+        let infcx = selcx.infcx();\n+        let tcx = infcx.tcx;\n+        o.flip_polarity(tcx)\n+            .as_ref()\n+            .map(|o| selcx.infcx().predicate_must_hold_modulo_regions(o))\n+            .unwrap_or(false)\n+    }\n+\n     // For the purposes of this check, we don't bring any placeholder\n     // types into scope; instead, we replace the generic types with\n     // fresh type variables, and hence we do our evaluations in an\n@@ -184,8 +200,29 @@ fn overlap_within_probe(\n \n     debug!(\"overlap: unification check succeeded\");\n \n-    // Are any of the obligations unsatisfiable? If so, no overlap.\n+    // There's no overlap if obligations are unsatisfiable or if the obligation negated is\n+    // satisfied.\n+    //\n+    // For example, given these two impl headers:\n+    //\n+    // `impl<'a> From<&'a str> for Box<dyn Error>`\n+    // `impl<E> From<E> for Box<dyn Error> where E: Error`\n+    //\n+    // So we have:\n+    //\n+    // `Box<dyn Error>: From<&'?a str>`\n+    // `Box<dyn Error>: From<?E>`\n+    //\n+    // After equating the two headers:\n+    //\n+    // `Box<dyn Error> = Box<dyn Error>`\n+    // So, `?E = &'?a str` and then given the where clause `&'?a str: Error`.\n+    //\n+    // If the obligation `&'?a str: Error` holds, it means that there's overlap. If that doesn't\n+    // hold we need to check if `&'?a str: !Error` holds, if doesn't hold there's overlap because\n+    // at some point an impl for `&'?a str: Error` could be added.\n     let infcx = selcx.infcx();\n+    let tcx = infcx.tcx;\n     let opt_failing_obligation = a_impl_header\n         .predicates\n         .iter()\n@@ -199,7 +236,17 @@ fn overlap_within_probe(\n             predicate: p,\n         })\n         .chain(obligations)\n-        .find(|o| !selcx.predicate_may_hold_fatal(o));\n+        .find(|o| {\n+            // if both impl headers are set to strict coherence it means that this will be accepted\n+            // only if it's stated that T: !Trait. So only prove that the negated obligation holds.\n+            if tcx.has_attr(a_def_id, sym::rustc_strict_coherence)\n+                && tcx.has_attr(b_def_id, sym::rustc_strict_coherence)\n+            {\n+                strict_check(selcx, o)\n+            } else {\n+                loose_check(selcx, o) || tcx.features().negative_impls && strict_check(selcx, o)\n+            }\n+        });\n     // FIXME: the call to `selcx.predicate_may_hold_fatal` above should be ported\n     // to the canonical trait query form, `infcx.predicate_may_hold`, once\n     // the new system supports intercrate mode (which coherence needs)."}, {"sha": "428873b8d3dda8ae2676f93c3527f030deb8bbad", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -804,6 +804,7 @@ pub fn vtable_trait_upcasting_coercion_new_vptr_slot(\n         ty::Binder::dummy(ty::TraitPredicate {\n             trait_ref,\n             constness: ty::BoundConstness::NotConst,\n+            polarity: ty::ImplPolarity::Positive,\n         }),\n     );\n "}, {"sha": "e0098cc92d51569ac0509b08e34024fca73648b1", "filename": "compiler/rustc_trait_selection/src/traits/relationships.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -44,6 +44,7 @@ pub(crate) fn update<'tcx, T>(\n                             ty::PredicateKind::Trait(ty::TraitPredicate {\n                                 trait_ref,\n                                 constness: predicate.constness,\n+                                polarity: predicate.polarity,\n                             })\n                         })\n                         .to_predicate(infcx.tcx),"}, {"sha": "e12b84742bf700ce4a9b85eb5feab86585e5ff21", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 72, "deletions": 62, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -121,7 +121,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(None);\n         }\n \n-        let mut candidates = candidate_set.vec;\n+        let candidates = candidate_set.vec;\n \n         debug!(?stack, ?candidates, \"assembled {} candidates\", candidates.len());\n \n@@ -134,6 +134,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // candidate which assumes $0 == int, one that assumes `$0 ==\n         // usize`, etc. This spells an ambiguity.\n \n+        let mut candidates = self.filter_impls(candidates, stack.obligation);\n+\n         // If there is more than one candidate, first winnow them down\n         // by considering extra conditions (nested obligations and so\n         // forth). We don't winnow if there is exactly one\n@@ -149,7 +151,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Instead, we select the right impl now but report \"`Bar` does\n         // not implement `Clone`\".\n         if candidates.len() == 1 {\n-            return self.filter_impls(candidates.pop().unwrap(), stack.obligation);\n+            return self.filter_reservation_impls(candidates.pop().unwrap(), stack.obligation);\n         }\n \n         // Winnow, but record the exact outcome of evaluation, which\n@@ -223,7 +225,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // Just one candidate left.\n-        self.filter_impls(candidates.pop().unwrap().candidate, stack.obligation)\n+        self.filter_reservation_impls(candidates.pop().unwrap().candidate, stack.obligation)\n     }\n \n     #[instrument(skip(self, stack), level = \"debug\")]\n@@ -254,68 +256,75 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let mut candidates = SelectionCandidateSet { vec: Vec::new(), ambiguous: false };\n \n-        self.assemble_candidates_for_trait_alias(obligation, &mut candidates);\n-\n-        // Other bounds. Consider both in-scope bounds from fn decl\n-        // and applicable impls. There is a certain set of precedence rules here.\n-        let def_id = obligation.predicate.def_id();\n-        let lang_items = self.tcx().lang_items();\n-\n-        if lang_items.copy_trait() == Some(def_id) {\n-            debug!(obligation_self_ty = ?obligation.predicate.skip_binder().self_ty());\n-\n-            // User-defined copy impls are permitted, but only for\n-            // structs and enums.\n+        // The only way to prove a NotImplemented(T: Foo) predicate is via a negative impl.\n+        // There are no compiler built-in rules for this.\n+        if obligation.polarity() == ty::ImplPolarity::Negative {\n+            self.assemble_candidates_for_trait_alias(obligation, &mut candidates);\n             self.assemble_candidates_from_impls(obligation, &mut candidates);\n-\n-            // For other types, we'll use the builtin rules.\n-            let copy_conditions = self.copy_clone_conditions(obligation);\n-            self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates);\n-        } else if lang_items.discriminant_kind_trait() == Some(def_id) {\n-            // `DiscriminantKind` is automatically implemented for every type.\n-            candidates.vec.push(DiscriminantKindCandidate);\n-        } else if lang_items.pointee_trait() == Some(def_id) {\n-            // `Pointee` is automatically implemented for every type.\n-            candidates.vec.push(PointeeCandidate);\n-        } else if lang_items.sized_trait() == Some(def_id) {\n-            // Sized is never implementable by end-users, it is\n-            // always automatically computed.\n-            let sized_conditions = self.sized_conditions(obligation);\n-            self.assemble_builtin_bound_candidates(sized_conditions, &mut candidates);\n-        } else if lang_items.unsize_trait() == Some(def_id) {\n-            self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n-        } else if lang_items.drop_trait() == Some(def_id)\n-            && obligation.predicate.skip_binder().constness == ty::BoundConstness::ConstIfConst\n-        {\n-            if self.is_in_const_context {\n-                self.assemble_const_drop_candidates(obligation, &mut candidates)?;\n-            } else {\n-                debug!(\"passing ~const Drop bound; in non-const context\");\n-                // `~const Drop` when we are not in a const context has no effect.\n-                candidates.vec.push(ConstDropCandidate)\n-            }\n         } else {\n-            if lang_items.clone_trait() == Some(def_id) {\n-                // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n-                // for `Copy` also has builtin support for `Clone`, and tuples/arrays of `Clone`\n-                // types have builtin support for `Clone`.\n-                let clone_conditions = self.copy_clone_conditions(obligation);\n-                self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates);\n-            }\n+            self.assemble_candidates_for_trait_alias(obligation, &mut candidates);\n+\n+            // Other bounds. Consider both in-scope bounds from fn decl\n+            // and applicable impls. There is a certain set of precedence rules here.\n+            let def_id = obligation.predicate.def_id();\n+            let lang_items = self.tcx().lang_items();\n+\n+            if lang_items.copy_trait() == Some(def_id) {\n+                debug!(obligation_self_ty = ?obligation.predicate.skip_binder().self_ty());\n+\n+                // User-defined copy impls are permitted, but only for\n+                // structs and enums.\n+                self.assemble_candidates_from_impls(obligation, &mut candidates);\n+\n+                // For other types, we'll use the builtin rules.\n+                let copy_conditions = self.copy_clone_conditions(obligation);\n+                self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates);\n+            } else if lang_items.discriminant_kind_trait() == Some(def_id) {\n+                // `DiscriminantKind` is automatically implemented for every type.\n+                candidates.vec.push(DiscriminantKindCandidate);\n+            } else if lang_items.pointee_trait() == Some(def_id) {\n+                // `Pointee` is automatically implemented for every type.\n+                candidates.vec.push(PointeeCandidate);\n+            } else if lang_items.sized_trait() == Some(def_id) {\n+                // Sized is never implementable by end-users, it is\n+                // always automatically computed.\n+                let sized_conditions = self.sized_conditions(obligation);\n+                self.assemble_builtin_bound_candidates(sized_conditions, &mut candidates);\n+            } else if lang_items.unsize_trait() == Some(def_id) {\n+                self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n+            } else if lang_items.drop_trait() == Some(def_id)\n+                && obligation.predicate.skip_binder().constness == ty::BoundConstness::ConstIfConst\n+            {\n+                if self.is_in_const_context {\n+                    self.assemble_const_drop_candidates(obligation, &mut candidates)?;\n+                } else {\n+                    debug!(\"passing ~const Drop bound; in non-const context\");\n+                    // `~const Drop` when we are not in a const context has no effect.\n+                    candidates.vec.push(ConstDropCandidate)\n+                }\n+            } else {\n+                if lang_items.clone_trait() == Some(def_id) {\n+                    // Same builtin conditions as `Copy`, i.e., every type which has builtin support\n+                    // for `Copy` also has builtin support for `Clone`, and tuples/arrays of `Clone`\n+                    // types have builtin support for `Clone`.\n+                    let clone_conditions = self.copy_clone_conditions(obligation);\n+                    self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates);\n+                }\n \n-            self.assemble_generator_candidates(obligation, &mut candidates);\n-            self.assemble_closure_candidates(obligation, &mut candidates);\n-            self.assemble_fn_pointer_candidates(obligation, &mut candidates);\n-            self.assemble_candidates_from_impls(obligation, &mut candidates);\n-            self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n-        }\n+                self.assemble_generator_candidates(obligation, &mut candidates);\n+                self.assemble_closure_candidates(obligation, &mut candidates);\n+                self.assemble_fn_pointer_candidates(obligation, &mut candidates);\n+                self.assemble_candidates_from_impls(obligation, &mut candidates);\n+                self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n+            }\n \n-        self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n-        self.assemble_candidates_from_caller_bounds(stack, &mut candidates)?;\n-        // Auto implementations have lower priority, so we only\n-        // consider triggering a default if there is no other impl that can apply.\n-        if candidates.vec.is_empty() {\n-            self.assemble_candidates_from_auto_impls(obligation, &mut candidates);\n+            self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n+            self.assemble_candidates_from_caller_bounds(stack, &mut candidates)?;\n+            // Auto implementations have lower priority, so we only\n+            // consider triggering a default if there is no other impl that can apply.\n+            if candidates.vec.is_empty() {\n+                self.assemble_candidates_from_auto_impls(obligation, &mut candidates);\n+            }\n         }\n         debug!(\"candidate list size: {}\", candidates.vec.len());\n         Ok(candidates)\n@@ -376,7 +385,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         for bound in matching_bounds {\n             let wc = self.evaluate_where_clause(stack, bound.value)?;\n             if wc.may_apply() {\n-                candidates.vec.push(ParamCandidate(bound));\n+                candidates.vec.push(ParamCandidate((bound, stack.obligation.polarity())));\n             }\n         }\n \n@@ -913,6 +922,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         substs: self.tcx().mk_substs_trait(ty, &[]),\n                     },\n                     constness: ty::BoundConstness::NotConst,\n+                    polarity: ty::ImplPolarity::Positive,\n                 }));\n             copy_obligation.recursion_depth = depth + 1;\n             self.assemble_candidates_from_impls(&copy_obligation, &mut copy_candidates);"}, {"sha": "84721922c8dd738493f79e10186638894a32c9a4", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -58,8 +58,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ParamCandidate(param) => {\n-                let obligations = self.confirm_param_candidate(obligation, param.value);\n-                Ok(ImplSource::Param(obligations, param.constness))\n+                let obligations = self.confirm_param_candidate(obligation, param.0.value);\n+                Ok(ImplSource::Param(obligations, param.0.constness))\n             }\n \n             ImplCandidate(impl_def_id) => {"}, {"sha": "43ffa285b8f0209614cdf0c93392aef707bc5f3e", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 137, "deletions": 87, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -20,7 +20,7 @@ use super::ObligationCauseCode;\n use super::Selection;\n use super::SelectionResult;\n use super::TraitQueryMode;\n-use super::{ErrorReporting, Overflow, SelectionError, Unimplemented};\n+use super::{ErrorReporting, Overflow, SelectionError};\n use super::{ObligationCause, PredicateObligation, TraitObligation};\n \n use crate::infer::{InferCtxt, InferOk, TypeFreshener};\n@@ -709,7 +709,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?fresh_trait_ref);\n \n-        if let Some(result) = self.check_evaluation_cache(obligation.param_env, fresh_trait_ref) {\n+        if let Some(result) = self.check_evaluation_cache(\n+            obligation.param_env,\n+            fresh_trait_ref,\n+            obligation.polarity(),\n+        ) {\n             debug!(?result, \"CACHE HIT\");\n             return Ok(result);\n         }\n@@ -739,12 +743,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let reached_depth = stack.reached_depth.get();\n         if reached_depth >= stack.depth {\n             debug!(?result, \"CACHE MISS\");\n-            self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n+            self.insert_evaluation_cache(\n+                obligation.param_env,\n+                fresh_trait_ref,\n+                obligation.polarity(),\n+                dep_node,\n+                result,\n+            );\n \n             stack.cache().on_completion(stack.dfn, |fresh_trait_ref, provisional_result| {\n                 self.insert_evaluation_cache(\n                     obligation.param_env,\n                     fresh_trait_ref,\n+                    obligation.polarity(),\n                     dep_node,\n                     provisional_result.max(result),\n                 );\n@@ -855,34 +866,39 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // precise still.\n         let unbound_input_types =\n             stack.fresh_trait_ref.value.skip_binder().substs.types().any(|ty| ty.is_fresh());\n-        // This check was an imperfect workaround for a bug in the old\n-        // intercrate mode; it should be removed when that goes away.\n-        if unbound_input_types && self.intercrate {\n-            debug!(\"evaluate_stack --> unbound argument, intercrate -->  ambiguous\",);\n-            // Heuristics: show the diagnostics when there are no candidates in crate.\n-            if self.intercrate_ambiguity_causes.is_some() {\n-                debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n-                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n-                    if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n-                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n-                        let self_ty = trait_ref.self_ty();\n-                        let cause =\n-                            with_no_trimmed_paths(|| IntercrateAmbiguityCause::DownstreamCrate {\n-                                trait_desc: trait_ref.print_only_trait_path().to_string(),\n-                                self_desc: if self_ty.has_concrete_skeleton() {\n-                                    Some(self_ty.to_string())\n-                                } else {\n-                                    None\n-                                },\n+\n+        if stack.obligation.polarity() != ty::ImplPolarity::Negative {\n+            // This check was an imperfect workaround for a bug in the old\n+            // intercrate mode; it should be removed when that goes away.\n+            if unbound_input_types && self.intercrate {\n+                debug!(\"evaluate_stack --> unbound argument, intercrate -->  ambiguous\",);\n+                // Heuristics: show the diagnostics when there are no candidates in crate.\n+                if self.intercrate_ambiguity_causes.is_some() {\n+                    debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n+                    if let Ok(candidate_set) = self.assemble_candidates(stack) {\n+                        if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n+                            let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                            let self_ty = trait_ref.self_ty();\n+                            let cause = with_no_trimmed_paths(|| {\n+                                IntercrateAmbiguityCause::DownstreamCrate {\n+                                    trait_desc: trait_ref.print_only_trait_path().to_string(),\n+                                    self_desc: if self_ty.has_concrete_skeleton() {\n+                                        Some(self_ty.to_string())\n+                                    } else {\n+                                        None\n+                                    },\n+                                }\n                             });\n \n-                        debug!(?cause, \"evaluate_stack: pushing cause\");\n-                        self.intercrate_ambiguity_causes.as_mut().unwrap().push(cause);\n+                            debug!(?cause, \"evaluate_stack: pushing cause\");\n+                            self.intercrate_ambiguity_causes.as_mut().unwrap().push(cause);\n+                        }\n                     }\n                 }\n+                return Ok(EvaluatedToAmbig);\n             }\n-            return Ok(EvaluatedToAmbig);\n         }\n+\n         if unbound_input_types\n             && stack.iter().skip(1).any(|prev| {\n                 stack.obligation.param_env == prev.obligation.param_env\n@@ -977,6 +993,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         trait_ref: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n+        polarity: ty::ImplPolarity,\n     ) -> Option<EvaluationResult> {\n         // Neither the global nor local cache is aware of intercrate\n         // mode, so don't do any caching. In particular, we might\n@@ -988,17 +1005,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let tcx = self.tcx();\n         if self.can_use_global_caches(param_env) {\n-            if let Some(res) = tcx.evaluation_cache.get(&param_env.and(trait_ref), tcx) {\n+            if let Some(res) = tcx.evaluation_cache.get(&(param_env.and(trait_ref), polarity), tcx)\n+            {\n                 return Some(res);\n             }\n         }\n-        self.infcx.evaluation_cache.get(&param_env.and(trait_ref), tcx)\n+        self.infcx.evaluation_cache.get(&(param_env.and(trait_ref), polarity), tcx)\n     }\n \n     fn insert_evaluation_cache(\n         &mut self,\n         param_env: ty::ParamEnv<'tcx>,\n         trait_ref: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n+        polarity: ty::ImplPolarity,\n         dep_node: DepNodeIndex,\n         result: EvaluationResult,\n     ) {\n@@ -1023,13 +1042,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // FIXME: Due to #50507 this overwrites the different values\n                 // This should be changed to use HashMapExt::insert_same\n                 // when that is fixed\n-                self.tcx().evaluation_cache.insert(param_env.and(trait_ref), dep_node, result);\n+                self.tcx().evaluation_cache.insert(\n+                    (param_env.and(trait_ref), polarity),\n+                    dep_node,\n+                    result,\n+                );\n                 return;\n             }\n         }\n \n         debug!(?trait_ref, ?result, \"insert_evaluation_cache\");\n-        self.infcx.evaluation_cache.insert(param_env.and(trait_ref), dep_node, result);\n+        self.infcx.evaluation_cache.insert((param_env.and(trait_ref), polarity), dep_node, result);\n     }\n \n     /// For various reasons, it's possible for a subobligation\n@@ -1094,75 +1117,97 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         (result, dep_node)\n     }\n \n+    /// filter_impls filters constant trait obligations and candidates that have a positive impl\n+    /// for a negative goal and a negative impl for a positive goal\n     #[instrument(level = \"debug\", skip(self))]\n     fn filter_impls(\n         &mut self,\n-        candidate: SelectionCandidate<'tcx>,\n+        candidates: Vec<SelectionCandidate<'tcx>>,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+    ) -> Vec<SelectionCandidate<'tcx>> {\n         let tcx = self.tcx();\n-        // Respect const trait obligations\n-        if self.is_trait_predicate_const(obligation.predicate.skip_binder()) {\n-            match candidate {\n-                // const impl\n-                ImplCandidate(def_id) if tcx.impl_constness(def_id) == hir::Constness::Const => {}\n-                // const param\n-                ParamCandidate(ty::ConstnessAnd {\n-                    constness: ty::BoundConstness::ConstIfConst,\n-                    ..\n-                }) => {}\n-                // auto trait impl\n-                AutoImplCandidate(..) => {}\n-                // generator, this will raise error in other places\n-                // or ignore error with const_async_blocks feature\n-                GeneratorCandidate => {}\n-                // FnDef where the function is const\n-                FnPointerCandidate { is_const: true } => {}\n-                ConstDropCandidate => {}\n-                _ => {\n-                    // reject all other types of candidates\n-                    return Err(Unimplemented);\n+        let mut result = Vec::with_capacity(candidates.len());\n+\n+        for candidate in candidates {\n+            // Respect const trait obligations\n+            if self.is_trait_predicate_const(obligation.predicate.skip_binder()) {\n+                match candidate {\n+                    // const impl\n+                    ImplCandidate(def_id)\n+                        if tcx.impl_constness(def_id) == hir::Constness::Const => {}\n+                    // const param\n+                    ParamCandidate((\n+                        ty::ConstnessAnd { constness: ty::BoundConstness::ConstIfConst, .. },\n+                        _,\n+                    )) => {}\n+                    // auto trait impl\n+                    AutoImplCandidate(..) => {}\n+                    // generator, this will raise error in other places\n+                    // or ignore error with const_async_blocks feature\n+                    GeneratorCandidate => {}\n+                    // FnDef where the function is const\n+                    FnPointerCandidate { is_const: true } => {}\n+                    ConstDropCandidate => {}\n+                    _ => {\n+                        // reject all other types of candidates\n+                        continue;\n+                    }\n+                }\n+            }\n+\n+            if let ImplCandidate(def_id) = candidate {\n+                if ty::ImplPolarity::Reservation == tcx.impl_polarity(def_id)\n+                    || obligation.polarity() == tcx.impl_polarity(def_id)\n+                    || self.allow_negative_impls\n+                {\n+                    result.push(candidate);\n                 }\n+            } else {\n+                result.push(candidate);\n             }\n         }\n-        // Treat negative impls as unimplemented, and reservation impls as ambiguity.\n+\n+        result\n+    }\n+\n+    /// filter_reservation_impls filter reservation impl for any goal as ambiguous\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn filter_reservation_impls(\n+        &mut self,\n+        candidate: SelectionCandidate<'tcx>,\n+        obligation: &TraitObligation<'tcx>,\n+    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        let tcx = self.tcx();\n+        // Treat reservation impls as ambiguity.\n         if let ImplCandidate(def_id) = candidate {\n-            match tcx.impl_polarity(def_id) {\n-                ty::ImplPolarity::Negative if !self.allow_negative_impls => {\n-                    return Err(Unimplemented);\n-                }\n-                ty::ImplPolarity::Reservation => {\n-                    if let Some(intercrate_ambiguity_clauses) =\n-                        &mut self.intercrate_ambiguity_causes\n-                    {\n-                        let attrs = tcx.get_attrs(def_id);\n-                        let attr = tcx.sess.find_by_name(&attrs, sym::rustc_reservation_impl);\n-                        let value = attr.and_then(|a| a.value_str());\n-                        if let Some(value) = value {\n-                            debug!(\n-                                \"filter_impls: \\\n+            if let ty::ImplPolarity::Reservation = tcx.impl_polarity(def_id) {\n+                if let Some(intercrate_ambiguity_clauses) = &mut self.intercrate_ambiguity_causes {\n+                    let attrs = tcx.get_attrs(def_id);\n+                    let attr = tcx.sess.find_by_name(&attrs, sym::rustc_reservation_impl);\n+                    let value = attr.and_then(|a| a.value_str());\n+                    if let Some(value) = value {\n+                        debug!(\n+                            \"filter_reservation_impls: \\\n                                  reservation impl ambiguity on {:?}\",\n-                                def_id\n-                            );\n-                            intercrate_ambiguity_clauses.push(\n-                                IntercrateAmbiguityCause::ReservationImpl {\n-                                    message: value.to_string(),\n-                                },\n-                            );\n-                        }\n+                            def_id\n+                        );\n+                        intercrate_ambiguity_clauses.push(\n+                            IntercrateAmbiguityCause::ReservationImpl {\n+                                message: value.to_string(),\n+                            },\n+                        );\n                     }\n-                    return Ok(None);\n                 }\n-                _ => {}\n-            };\n+                return Ok(None);\n+            }\n         }\n         Ok(Some(candidate))\n     }\n \n     fn is_knowable<'o>(&mut self, stack: &TraitObligationStack<'o, 'tcx>) -> Option<Conflict> {\n         debug!(\"is_knowable(intercrate={:?})\", self.intercrate);\n \n-        if !self.intercrate {\n+        if !self.intercrate || stack.obligation.polarity() == ty::ImplPolarity::Negative {\n             return None;\n         }\n \n@@ -1219,14 +1264,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if self.can_use_global_caches(param_env) {\n             if let Some(res) = tcx\n                 .selection_cache\n-                .get(&param_env.and(trait_ref).with_constness(pred.constness), tcx)\n+                .get(&(param_env.and(trait_ref).with_constness(pred.constness), pred.polarity), tcx)\n             {\n                 return Some(res);\n             }\n         }\n         self.infcx\n             .selection_cache\n-            .get(&param_env.and(trait_ref).with_constness(pred.constness), tcx)\n+            .get(&(param_env.and(trait_ref).with_constness(pred.constness), pred.polarity), tcx)\n     }\n \n     /// Determines whether can we safely cache the result\n@@ -1286,7 +1331,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     debug!(?trait_ref, ?candidate, \"insert_candidate_cache global\");\n                     // This may overwrite the cache with the same value.\n                     tcx.selection_cache.insert(\n-                        param_env.and(trait_ref).with_constness(pred.constness),\n+                        (param_env.and(trait_ref).with_constness(pred.constness), pred.polarity),\n                         dep_node,\n                         candidate,\n                     );\n@@ -1297,7 +1342,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?trait_ref, ?candidate, \"insert_candidate_cache local\");\n         self.infcx.selection_cache.insert(\n-            param_env.and(trait_ref).with_constness(pred.constness),\n+            (param_env.and(trait_ref).with_constness(pred.constness), pred.polarity),\n             dep_node,\n             candidate,\n         );\n@@ -1523,10 +1568,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | ConstDropCandidate,\n             ) => false,\n \n-            (ParamCandidate(other), ParamCandidate(victim)) => {\n+            (\n+                ParamCandidate((other, other_polarity)),\n+                ParamCandidate((victim, victim_polarity)),\n+            ) => {\n                 let same_except_bound_vars = other.value.skip_binder()\n                     == victim.value.skip_binder()\n                     && other.constness == victim.constness\n+                    && other_polarity == victim_polarity\n                     && !other.value.skip_binder().has_escaping_bound_vars();\n                 if same_except_bound_vars {\n                     // See issue #84398. In short, we can generate multiple ParamCandidates which are\n@@ -1537,6 +1586,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     other.value.bound_vars().len() <= victim.value.bound_vars().len()\n                 } else if other.value == victim.value\n                     && victim.constness == ty::BoundConstness::NotConst\n+                    && other_polarity == victim_polarity\n                 {\n                     // Drop otherwise equivalent non-const candidates in favor of const candidates.\n                     true\n@@ -1566,11 +1616,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | TraitAliasCandidate(..)\n                 | ObjectCandidate(_)\n                 | ProjectionCandidate(_),\n-            ) => !is_global(&cand.value),\n+            ) => !is_global(&cand.0.value),\n             (ObjectCandidate(_) | ProjectionCandidate(_), ParamCandidate(ref cand)) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n-                is_global(&cand.value)\n+                is_global(&cand.0.value)\n             }\n             (\n                 ImplCandidate(_)\n@@ -1586,7 +1636,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n-                is_global(&cand.value) && other.evaluation.must_apply_modulo_regions()\n+                is_global(&cand.0.value) && other.evaluation.must_apply_modulo_regions()\n             }\n \n             (ProjectionCandidate(i), ProjectionCandidate(j))"}, {"sha": "c17c42c497fb36e9223b85a87ee5f4158749728d", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -531,6 +531,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         substs: self.infcx.tcx.mk_substs_trait(outer_ty, &[]),\n                                     },\n                                     constness: t.constness,\n+                                    polarity: t.polarity,\n                                 }));\n                             let obl = Obligation::new(\n                                 o.cause.clone(),"}, {"sha": "4fb422c801b1def85f9c2ae9609eed393584704b", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -382,6 +382,7 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n         ty::PredicateKind::Trait(ty::TraitPredicate {\n             trait_ref,\n             constness: ty::BoundConstness::NotConst,\n+            polarity: _,\n         }) => {\n             if !matches!(\n                 trait_predicate_kind(tcx, predicate),\n@@ -413,6 +414,7 @@ fn trait_predicate_kind<'tcx>(\n         ty::PredicateKind::Trait(ty::TraitPredicate {\n             trait_ref,\n             constness: ty::BoundConstness::NotConst,\n+            polarity: _,\n         }) => Some(tcx.trait_def(trait_ref.def_id).specialization_kind),\n         ty::PredicateKind::Trait(_)\n         | ty::PredicateKind::RegionOutlives(_)"}, {"sha": "43806cb995c0309aff489147db0e6b5d3cc2e265", "filename": "src/test/ui/coherence/auxiliary/error_lib.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Ferror_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Ferror_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Ferror_lib.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -0,0 +1,5 @@\n+#![crate_type = \"lib\"]\n+#![feature(negative_impls)]\n+\n+pub trait Error {}\n+impl !Error for &str {}"}, {"sha": "16ace450b06d546a9430aa2363a8cae5d7163ea1", "filename": "src/test/ui/coherence/coherence-overlap-negate-alias-strict.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -0,0 +1,19 @@\n+#![feature(negative_impls)]\n+#![feature(rustc_attrs)]\n+#![feature(trait_alias)]\n+\n+trait A {}\n+trait B {}\n+trait AB = A + B;\n+\n+impl !A for u32 {}\n+\n+trait C {}\n+#[rustc_strict_coherence]\n+impl<T: AB> C for T {}\n+#[rustc_strict_coherence]\n+impl C for u32 {}\n+//~^ ERROR: conflicting implementations of trait `C` for type `u32` [E0119]\n+// FIXME this should work, we should implement an `assemble_neg_candidates` fn\n+\n+fn main() {}"}, {"sha": "5e436223119b997f48618992c47c33de3ba0ad5a", "filename": "src/test/ui/coherence/coherence-overlap-negate-alias-strict.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-alias-strict.stderr?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -0,0 +1,12 @@\n+error[E0119]: conflicting implementations of trait `C` for type `u32`\n+  --> $DIR/coherence-overlap-negate-alias-strict.rs:15:1\n+   |\n+LL | impl<T: AB> C for T {}\n+   | ------------------- first implementation here\n+LL | #[rustc_strict_coherence]\n+LL | impl C for u32 {}\n+   | ^^^^^^^^^^^^^^ conflicting implementation for `u32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "a067736f63a248d5167006c42bc53dc6efcafc1f", "filename": "src/test/ui/coherence/coherence-overlap-negate-not-use-feature-gate.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-not-use-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-not-use-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-not-use-feature-gate.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -0,0 +1,8 @@\n+use std::ops::DerefMut;\n+\n+trait Foo {}\n+impl<T: DerefMut> Foo for T {}\n+impl<U> Foo for &U {}\n+//~^ ERROR: conflicting implementations of trait `Foo` for type `&_` [E0119]\n+\n+fn main() {}"}, {"sha": "4b55001ecc0e102d55ee36bdea4f5a824ae8be58", "filename": "src/test/ui/coherence/coherence-overlap-negate-not-use-feature-gate.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-not-use-feature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-not-use-feature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-not-use-feature-gate.stderr?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -0,0 +1,11 @@\n+error[E0119]: conflicting implementations of trait `Foo` for type `&_`\n+  --> $DIR/coherence-overlap-negate-not-use-feature-gate.rs:5:1\n+   |\n+LL | impl<T: DerefMut> Foo for T {}\n+   | --------------------------- first implementation here\n+LL | impl<U> Foo for &U {}\n+   | ^^^^^^^^^^^^^^^^^^ conflicting implementation for `&_`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "b3ae9a7bf78555897583563f8ff75ce4365c40dc", "filename": "src/test/ui/coherence/coherence-overlap-negate-strict.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-strict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-strict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-strict.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+#![feature(negative_impls)]\n+#![feature(rustc_attrs)]\n+#![feature(trait_alias)]\n+\n+trait A {}\n+trait B {}\n+\n+impl !A for u32 {}\n+\n+trait C {}\n+#[rustc_strict_coherence]\n+impl<T: A + B> C for T {}\n+#[rustc_strict_coherence]\n+impl C for u32 {}\n+\n+fn main() {}"}, {"sha": "e024eae9819abcda58765cabedbea3e957a9d360", "filename": "src/test/ui/coherence/coherence-overlap-negate-use-feature-gate.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-use-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-use-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negate-use-feature-gate.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+#![feature(negative_impls)]\n+\n+use std::ops::DerefMut;\n+\n+trait Foo {}\n+impl<T: DerefMut> Foo for T {}\n+impl<U> Foo for &U {}\n+\n+fn main() {}"}, {"sha": "ab65163bea4424945fac4ed2d2faf108e3687214", "filename": "src/test/ui/coherence/coherence-overlap-negative-trait.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+// aux-build:error_lib.rs\n+//\n+// Check that if we promise to not impl what would overlap it doesn't actually overlap\n+\n+#![feature(negative_impls)]\n+\n+extern crate error_lib as lib;\n+use lib::Error;\n+\n+trait From<T> {}\n+\n+impl From<&str> for Box<dyn Error> {}\n+impl<E> From<E> for Box<dyn Error> where E: Error {}\n+\n+fn main() {}"}, {"sha": "45b2f0863055bb027f4a871168d450225dd86c3b", "filename": "src/test/ui/coherence/coherence-overlap-trait-alias.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -0,0 +1,20 @@\n+#![feature(rustc_attrs)]\n+#![feature(trait_alias)]\n+\n+trait A {}\n+trait B {}\n+trait AB = A + B;\n+\n+impl A for u32 {}\n+impl B for u32 {}\n+\n+trait C {}\n+#[rustc_strict_coherence]\n+impl<T: AB> C for T {}\n+#[rustc_strict_coherence]\n+impl C for u32 {}\n+//~^ ERROR\n+// FIXME it's giving an ungreat error but unsure if we care given that it's using an internal rustc\n+// attribute and an artificial code path for testing purposes\n+\n+fn main() {}"}, {"sha": "e2e8ad54beb1b58faab865446e38f34a9dd9c920", "filename": "src/test/ui/coherence/coherence-overlap-trait-alias.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-trait-alias.stderr?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -0,0 +1,16 @@\n+error[E0283]: type annotations needed\n+  --> $DIR/coherence-overlap-trait-alias.rs:15:6\n+   |\n+LL | impl C for u32 {}\n+   |      ^ cannot infer type for type `u32`\n+   |\n+   = note: cannot satisfy `u32: C`\n+note: required by a bound in `C`\n+  --> $DIR/coherence-overlap-trait-alias.rs:11:1\n+   |\n+LL | trait C {}\n+   | ^^^^^^^ required by this bound in `C`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "c36ac08579b7798a85b8a935bd1e48acc5ee3c48", "filename": "src/test/ui/traits/cache-reached-depth-ice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -41,5 +41,5 @@ fn test<X: ?Sized + Send>() {}\n \n fn main() {\n     test::<A>();\n-    //~^ ERROR evaluate(Binder(TraitPredicate(<A as std::marker::Send>), [])) = Ok(EvaluatedToOk)\n+    //~^ ERROR evaluate(Binder(TraitPredicate(<A as std::marker::Send>, polarity:Positive), [])) = Ok(EvaluatedToOk)\n }"}, {"sha": "082aa0f5cd93ef74d663f9537b343acc88994c3a", "filename": "src/test/ui/traits/cache-reached-depth-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.stderr?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -1,4 +1,4 @@\n-error: evaluate(Binder(TraitPredicate(<A as std::marker::Send>), [])) = Ok(EvaluatedToOk)\n+error: evaluate(Binder(TraitPredicate(<A as std::marker::Send>, polarity:Positive), [])) = Ok(EvaluatedToOk)\n   --> $DIR/cache-reached-depth-ice.rs:43:5\n    |\n LL | fn test<X: ?Sized + Send>() {}"}, {"sha": "3cd68ff6f060e9ef6cc64c8ad71f69c9a3b91a16", "filename": "src/test/ui/traits/issue-83538-tainted-cache-after-cycle.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -57,10 +57,10 @@ fn main() {\n     // Key is that Vec<First> is \"ok\" and Third<'_, Ty> is \"ok modulo regions\":\n \n     forward();\n-    //~^ ERROR evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>), [])) = Ok(EvaluatedToOk)\n-    //~| ERROR evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>), [])) = Ok(EvaluatedToOkModuloRegions)\n+    //~^ ERROR evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOk)\n+    //~| ERROR evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOkModuloRegions)\n \n     reverse();\n-    //~^ ERROR evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>), [])) = Ok(EvaluatedToOk)\n-    //~| ERROR evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>), [])) = Ok(EvaluatedToOkModuloRegions)\n+    //~^ ERROR evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOk)\n+    //~| ERROR evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOkModuloRegions)\n }"}, {"sha": "7c4041144a4d24092de52942fea93da67ea48317", "filename": "src/test/ui/traits/issue-83538-tainted-cache-after-cycle.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.stderr?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -1,4 +1,4 @@\n-error: evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>), [])) = Ok(EvaluatedToOk)\n+error: evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOk)\n   --> $DIR/issue-83538-tainted-cache-after-cycle.rs:59:5\n    |\n LL |     Vec<First>: Unpin,\n@@ -7,7 +7,7 @@ LL |     Vec<First>: Unpin,\n LL |     forward();\n    |     ^^^^^^^\n \n-error: evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>), [])) = Ok(EvaluatedToOkModuloRegions)\n+error: evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOkModuloRegions)\n   --> $DIR/issue-83538-tainted-cache-after-cycle.rs:59:5\n    |\n LL |     Third<'a, Ty>: Unpin,\n@@ -16,7 +16,7 @@ LL |     Third<'a, Ty>: Unpin,\n LL |     forward();\n    |     ^^^^^^^\n \n-error: evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>), [])) = Ok(EvaluatedToOkModuloRegions)\n+error: evaluate(Binder(TraitPredicate(<Third<'_, Ty> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOkModuloRegions)\n   --> $DIR/issue-83538-tainted-cache-after-cycle.rs:63:5\n    |\n LL |     Third<'a, Ty>: Unpin,\n@@ -25,7 +25,7 @@ LL |     Third<'a, Ty>: Unpin,\n LL |     reverse();\n    |     ^^^^^^^\n \n-error: evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>), [])) = Ok(EvaluatedToOk)\n+error: evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>, polarity:Positive), [])) = Ok(EvaluatedToOk)\n   --> $DIR/issue-83538-tainted-cache-after-cycle.rs:63:5\n    |\n LL |     Vec<First>: Unpin,"}, {"sha": "119ac05c33e4b4442ee9c47b0c2baedbd87af17d", "filename": "src/test/ui/traits/negative-impls/rely-on-negative-impl-in-coherence.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Frely-on-negative-impl-in-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5740c715001f981515ed46faaddebf67cb9539/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Frely-on-negative-impl-in-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Frely-on-negative-impl-in-coherence.rs?ref=aa5740c715001f981515ed46faaddebf67cb9539", "patch": "@@ -1,3 +1,5 @@\n+// check-pass\n+\n #![feature(negative_impls)]\n \n // aux-build: foreign_trait.rs\n@@ -16,6 +18,6 @@ use foreign_trait::ForeignTrait;\n \n trait LocalTrait { }\n impl<T: ForeignTrait> LocalTrait for T { }\n-impl LocalTrait for String { } //~ ERROR conflicting implementations\n+impl LocalTrait for String { }\n \n fn main() { }"}, {"sha": "b970ad762088d9880641bbab7c58a2115465633a", "filename": "src/test/ui/traits/negative-impls/rely-on-negative-impl-in-coherence.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/55ccbd090d96ec3bb28dbcb383e65bbfa3c293ff/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Frely-on-negative-impl-in-coherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/55ccbd090d96ec3bb28dbcb383e65bbfa3c293ff/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Frely-on-negative-impl-in-coherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Frely-on-negative-impl-in-coherence.stderr?ref=55ccbd090d96ec3bb28dbcb383e65bbfa3c293ff", "patch": "@@ -1,11 +0,0 @@\n-error[E0119]: conflicting implementations of trait `LocalTrait` for type `std::string::String`\n-  --> $DIR/rely-on-negative-impl-in-coherence.rs:19:1\n-   |\n-LL | impl<T: ForeignTrait> LocalTrait for T { }\n-   | -------------------------------------- first implementation here\n-LL | impl LocalTrait for String { }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `std::string::String`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0119`."}]}