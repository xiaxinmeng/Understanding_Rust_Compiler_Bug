{"sha": "e51f259ff02b566ed5ca55b0fe76bd452fbf0400", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1MWYyNTlmZjAyYjU2NmVkNWNhNTViMGZlNzZiZDQ1MmZiZjA0MDA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-11T18:22:40Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-11T18:23:14Z"}, "message": "rustc: Add some more checks to coherence", "tree": {"sha": "fbd94328dfa83f7232aab5f3020f9999e3199caf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbd94328dfa83f7232aab5f3020f9999e3199caf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e51f259ff02b566ed5ca55b0fe76bd452fbf0400", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e51f259ff02b566ed5ca55b0fe76bd452fbf0400", "html_url": "https://github.com/rust-lang/rust/commit/e51f259ff02b566ed5ca55b0fe76bd452fbf0400", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e51f259ff02b566ed5ca55b0fe76bd452fbf0400/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1806707dcb170a77139e11fc67898a01607d50dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/1806707dcb170a77139e11fc67898a01607d50dd", "html_url": "https://github.com/rust-lang/rust/commit/1806707dcb170a77139e11fc67898a01607d50dd"}], "stats": {"total": 206, "additions": 197, "deletions": 9}, "files": [{"sha": "09dbd77e9bc22ce279b04c3239d274e5ce921962", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 197, "deletions": 9, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/e51f259ff02b566ed5ca55b0fe76bd452fbf0400/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e51f259ff02b566ed5ca55b0fe76bd452fbf0400/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=e51f259ff02b566ed5ca55b0fe76bd452fbf0400", "patch": "@@ -11,16 +11,20 @@ import middle::ty::{ty_fn, ty_trait, ty_tup, ty_var, ty_var_integral};\n import middle::ty::{ty_param, ty_self, ty_constr, ty_type, ty_opaque_box};\n import middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, new_ty_hash};\n import middle::ty::{subst};\n-import middle::typeck::infer::{infer_ctxt, mk_eqty, new_infer_ctxt};\n-import syntax::ast::{crate, def_id, item, item_impl, method, region_param};\n-import syntax::ast::{trait_ref};\n+import middle::typeck::infer::{infer_ctxt, mk_subty, new_infer_ctxt};\n+import syntax::ast::{crate, def_id, item, item_class, item_const, item_enum};\n+import syntax::ast::{item_fn, item_foreign_mod, item_impl, item_mac};\n+import syntax::ast::{item_mod, item_trait, item_ty, local_crate, method};\n+import syntax::ast::{node_id, region_param, rp_none, rp_self, trait_ref};\n import syntax::ast_util::{def_id_of_def, new_def_hash};\n-import syntax::visit::{default_simple_visitor, mk_simple_visitor};\n-import syntax::visit::{visit_crate};\n+import syntax::visit::{default_simple_visitor, default_visitor};\n+import syntax::visit::{mk_simple_visitor, mk_vt, visit_crate, visit_item};\n+import syntax::visit::{visit_mod};\n+import util::ppaux::ty_to_str;\n \n import dvec::{dvec, extensions};\n import result::{extensions};\n-import std::map::hashmap;\n+import std::map::{hashmap, int_hash};\n import uint::range;\n \n class CoherenceInfo {\n@@ -43,10 +47,26 @@ class CoherenceChecker {\n     let inference_context: infer_ctxt;\n     let info: @CoherenceInfo;\n \n+    // A mapping from implementations to the corresponding base type\n+    // definition ID.\n+    let base_type_def_ids: hashmap<node_id,def_id>;\n+\n+    // A set of implementations in privileged scopes; i.e. those\n+    // implementations that are defined in the same scope as their base types.\n+    let privileged_implementations: hashmap<node_id,()>;\n+\n+    // The set of types that we are currently in the privileged scope of. This\n+    // is used while we traverse the AST while checking privileged scopes.\n+    let privileged_types: hashmap<def_id,()>;\n+\n     new(crate_context: @crate_ctxt) {\n         self.crate_context = crate_context;\n         self.inference_context = new_infer_ctxt(crate_context.tcx);\n         self.info = @CoherenceInfo();\n+\n+        self.base_type_def_ids = int_hash();\n+        self.privileged_implementations = int_hash();\n+        self.privileged_types = new_def_hash();\n     }\n \n     fn check_coherence(crate: @crate) {\n@@ -71,6 +91,9 @@ class CoherenceChecker {\n         for self.info.extension_methods.each |def_id, items| {\n             self.check_implementation_coherence(def_id, items);\n         }\n+\n+        // Check whether traits with base types are in privileged scopes.\n+        self.check_privileged_scopes(crate);\n     }\n \n     fn check_implementation(item: @item,\n@@ -121,6 +144,17 @@ class CoherenceChecker {\n                 implementation_list.push(item);\n             }\n         }\n+\n+        // Add the implementation to the mapping from implementation to base\n+        // type def ID, if there is a base type for this implementation.\n+        alt self.get_base_type_def_id(self_type.ty) {\n+            none {\n+                // Nothing to do.\n+            }\n+            some(base_type_def_id) {\n+                self.base_type_def_ids.insert(item.id, base_type_def_id);\n+            }\n+        }\n     }\n \n     fn get_base_type(original_type: t) -> option<t> {\n@@ -147,6 +181,26 @@ class CoherenceChecker {\n         }\n     }\n \n+    // Returns the def ID of the base type.\n+    fn get_base_type_def_id(original_type: t) -> option<def_id> {\n+        alt self.get_base_type(original_type) {\n+            none {\n+                ret none;\n+            }\n+            some(base_type) {\n+                alt get(base_type).struct {\n+                    ty_enum(def_id, _) | ty_class(def_id, _) {\n+                        ret some(def_id);\n+                    }\n+                    _ {\n+                        fail \"get_base_type() returned a type that wasn't an \\\n+                              enum or class\";\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn check_implementation_coherence(_trait_def_id: def_id,\n                                       implementations: @dvec<@item>) {\n \n@@ -177,18 +231,19 @@ class CoherenceChecker {\n \n         let monotype_a = self.universally_quantify_polytype(polytype_a);\n         let monotype_b = self.universally_quantify_polytype(polytype_b);\n-        ret mk_eqty(self.inference_context, monotype_a, monotype_b).is_ok();\n+        ret mk_subty(self.inference_context, monotype_a, monotype_b).is_ok()\n+         || mk_subty(self.inference_context, monotype_b, monotype_a).is_ok();\n     }\n \n     // Converts a polytype to a monotype by replacing all parameters with\n     // type variables.\n     fn universally_quantify_polytype(polytype: ty_param_bounds_and_ty) -> t {\n         let self_region;\n         alt polytype.rp {\n-            ast::rp_none {\n+            rp_none {\n                 self_region = none;\n             }\n-            ast::rp_self {\n+            rp_self {\n                 self_region = some(self.inference_context.next_region_var())\n             }\n         };\n@@ -220,6 +275,139 @@ class CoherenceChecker {\n             }\n         }\n     }\n+\n+    // Privileged scope checking\n+\n+    fn check_privileged_scopes(crate: @crate) {\n+        visit_crate(*crate, (), mk_vt(@{\n+            visit_item: |item, _context, visitor| {\n+                alt item.node {\n+                    item_mod(module) {\n+                        // First, gather up all privileged types.\n+                        let privileged_types =\n+                            self.gather_privileged_types(module.items);\n+                        for privileged_types.each |privileged_type| {\n+                            #debug(\"(checking privileged scopes) entering \\\n+                                    privileged scope of %d:%d\",\n+                                   privileged_type.crate,\n+                                   privileged_type.node);\n+\n+                            self.privileged_types.insert(privileged_type, ());\n+                        }\n+\n+                        // Then visit the module items.\n+                        visit_mod(module, item.span, item.id, (), visitor);\n+\n+                        // Finally, remove privileged types from the map.\n+                        for privileged_types.each |privileged_type| {\n+                            self.privileged_types.remove(privileged_type);\n+                        }\n+                    }\n+                    item_impl(_, _, optional_trait_ref, _, _) {\n+                        alt self.base_type_def_ids.find(item.id) {\n+                            none {\n+                                // Nothing to do.\n+                            }\n+                            some(base_type_def_id) {\n+                                // Check to see whether the implementation is\n+                                // in the scope of its base type.\n+\n+                                let privileged_types = &self.privileged_types;\n+                                if privileged_types.\n+                                        contains_key(base_type_def_id) {\n+\n+                                    // Record that this implementation is OK.\n+                                    self.privileged_implementations.insert\n+                                        (item.id, ());\n+                                } else {\n+                                    // This implementation is not in scope of\n+                                    // its base type. This still might be OK\n+                                    // if the trait is defined in the same\n+                                    // crate.\n+\n+                                    alt optional_trait_ref {\n+                                        none {\n+                                            // There is no trait to implement,\n+                                            // so this is an error.\n+\n+                                            let session =\n+                                                self.crate_context.tcx.sess;\n+                                            session.span_warn(item.span,\n+                                                              \"cannot \\\n+                                                               implement \\\n+                                                               inherent \\\n+                                                               methods for a \\\n+                                                               type outside \\\n+                                                               the scope the \\\n+                                                               type was \\\n+                                                               defined in; \\\n+                                                               define and \\\n+                                                               implement a \\\n+                                                               trait \\\n+                                                               instead\");\n+                                        }\n+                                        some(trait_ref) {\n+                                            // This is OK if and only if the\n+                                            // trait was defined in this\n+                                            // crate.\n+\n+                                            let def_map = self.crate_context\n+                                                .tcx.def_map;\n+                                            let trait_def =\n+                                                def_map.get(trait_ref.id);\n+                                            let trait_id =\n+                                                def_id_of_def(trait_def);\n+                                            if trait_id.crate != local_crate {\n+                                                let session = self\n+                                                    .crate_context.tcx.sess;\n+                                                session.span_warn(item.span,\n+                                                                  \"cannot \\\n+                                                                   provide \\\n+                                                                   an \\\n+                                                                   extension \\\n+                                                                   implement\\\n+                                                                      ation \\\n+                                                                   for a \\\n+                                                                   trait not \\\n+                                                                   defined \\\n+                                                                   in this \\\n+                                                                   crate\");\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                        visit_item(item, (), visitor);\n+                    }\n+                    _ {\n+                        visit_item(item, (), visitor);\n+                    }\n+                }\n+            }\n+            with *default_visitor()\n+        }));\n+    }\n+\n+    fn gather_privileged_types(items: ~[@item]) -> @dvec<def_id> {\n+        let results = @dvec();\n+        for items.each |item| {\n+            alt item.node {\n+                item_class(*) | item_enum(*) {\n+                    results.push(local_def(item.id));\n+                }\n+\n+                item_const(*) | item_fn(*) | item_mod(*) |\n+                item_foreign_mod(*) | item_ty(*) | item_trait(*) |\n+                item_impl(*) | item_mac(*) {\n+                    // Nothing to do.\n+                }\n+            }\n+        }\n+\n+        ret results;\n+    }\n }\n \n fn check_coherence(crate_context: @crate_ctxt, crate: @crate) {"}]}