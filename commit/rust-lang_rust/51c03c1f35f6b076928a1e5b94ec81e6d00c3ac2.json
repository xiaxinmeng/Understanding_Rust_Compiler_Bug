{"sha": "51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxYzAzYzFmMzVmNmIwNzY5MjhhMWU1Yjk0ZWM4MWU2ZDAwYzNhYzI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-15T08:42:21Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-25T03:59:54Z"}, "message": "green: Properly wait for main before shutdown\n\nThere was a race in the code previously where schedulers would *immediately*\nshut down after spawning the main task (because the global task count would\nstill be 0). This fixes the logic by blocking the sched pool task in receving on\na port instead of spawning a task into the pool to receive on a port.\n\nThe modifications necessary were to have a \"simple task\" running by the time the\ncode is executing, but this is a simple enough thing to implement and I forsee\nthis being necessary to have implemented in the future anyway.", "tree": {"sha": "5503ef16e6be59f8a0c8948fe347d48be9267a47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5503ef16e6be59f8a0c8948fe347d48be9267a47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2", "html_url": "https://github.com/rust-lang/rust/commit/51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "282f3d99a5ad85acbc58c03b5dfcdabf649c0c85", "url": "https://api.github.com/repos/rust-lang/rust/commits/282f3d99a5ad85acbc58c03b5dfcdabf649c0c85", "html_url": "https://github.com/rust-lang/rust/commit/282f3d99a5ad85acbc58c03b5dfcdabf649c0c85"}], "stats": {"total": 188, "additions": 143, "deletions": 45}, "files": [{"sha": "7318eaaf6799b1ef43adb6d5f19268eac6f90f3b", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2", "patch": "@@ -33,22 +33,24 @@\n \n use std::os;\n use std::rt::crate_map;\n+use std::rt::local::Local;\n use std::rt::rtio;\n+use std::rt::task::Task;\n use std::rt::thread::Thread;\n use std::rt;\n use std::sync::atomics::{SeqCst, AtomicUint, INIT_ATOMIC_UINT};\n use std::sync::deque;\n use std::task::TaskOpts;\n use std::util;\n use std::vec;\n-use stdtask = std::rt::task;\n \n use sched::{Shutdown, Scheduler, SchedHandle, TaskFromFriend, NewNeighbor};\n use sleeper_list::SleeperList;\n use stack::StackPool;\n use task::GreenTask;\n \n mod macros;\n+mod simple;\n \n pub mod basic;\n pub mod context;\n@@ -61,16 +63,20 @@ pub mod task;\n #[lang = \"start\"]\n pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n     use std::cast;\n-    do start(argc, argv) {\n-        let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n-        main();\n-    }\n+    let mut ret = None;\n+    simple::task().run(|| {\n+        ret = Some(do start(argc, argv) {\n+            let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n+            main();\n+        })\n+    });\n+    ret.unwrap()\n }\n \n /// Set up a default runtime configuration, given compiler-supplied arguments.\n ///\n-/// This function will block the current thread of execution until the entire\n-/// pool of M:N schedulers have exited.\n+/// This function will block until the entire pool of M:N schedulers have\n+/// exited. This function also requires a local task to be available.\n ///\n /// # Arguments\n ///\n@@ -95,24 +101,37 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n \n /// Execute the main function in a pool of M:N schedulers.\n ///\n-/// Configures the runtime according to the environment, by default\n-/// using a task scheduler with the same number of threads as cores.\n-/// Returns a process exit code.\n+/// Configures the runtime according to the environment, by default using a task\n+/// scheduler with the same number of threads as cores.  Returns a process exit\n+/// code.\n ///\n /// This function will not return until all schedulers in the associated pool\n /// have returned.\n pub fn run(main: proc()) -> int {\n+    // Create a scheduler pool and spawn the main task into this pool. We will\n+    // get notified over a channel when the main task exits.\n     let mut pool = SchedPool::new(PoolConfig::new());\n     let (port, chan) = Chan::new();\n     let mut opts = TaskOpts::new();\n     opts.notify_chan = Some(chan);\n     pool.spawn(opts, main);\n-    do pool.spawn(TaskOpts::new()) {\n-        if port.recv().is_err() {\n-            os::set_exit_status(rt::DEFAULT_ERROR_CODE);\n-        }\n+\n+    // Wait for the main task to return, and set the process error code\n+    // appropriately.\n+    if port.recv().is_err() {\n+        os::set_exit_status(rt::DEFAULT_ERROR_CODE);\n     }\n-    unsafe { stdtask::wait_for_completion(); }\n+\n+    // Once the main task has exited and we've set our exit code, wait for all\n+    // spawned sub-tasks to finish running. This is done to allow all schedulers\n+    // to remain active while there are still tasks possibly running.\n+    unsafe {\n+        let mut task = Local::borrow(None::<Task>);\n+        task.get().wait_for_other_tasks();\n+    }\n+\n+    // Now that we're sure all tasks are dead, shut down the pool of schedulers,\n+    // waiting for them all to return.\n     pool.shutdown();\n     os::get_exit_status()\n }"}, {"sha": "6fd2c436b2e5f5ff1a44ff67dd0734a5b716760c", "filename": "src/libgreen/simple.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A small module implementing a simple \"runtime\" used for bootstrapping a rust\n+//! scheduler pool and then interacting with it.\n+\n+use std::cast;\n+use std::rt::Runtime;\n+use std::task::TaskOpts;\n+use std::rt::rtio;\n+use std::rt::local::Local;\n+use std::rt::task::{Task, BlockedTask};\n+use std::unstable::sync::LittleLock;\n+\n+struct SimpleTask {\n+    lock: LittleLock,\n+}\n+\n+impl Runtime for SimpleTask {\n+    // Implement the simple tasks of descheduling and rescheduling, but only in\n+    // a simple number of cases.\n+    fn deschedule(mut ~self, times: uint, mut cur_task: ~Task,\n+                  f: |BlockedTask| -> Result<(), BlockedTask>) {\n+        assert!(times == 1);\n+\n+        let my_lock: *mut LittleLock = &mut self.lock;\n+        cur_task.put_runtime(self as ~Runtime);\n+\n+        unsafe {\n+            let cur_task_dupe = *cast::transmute::<&~Task, &uint>(&cur_task);\n+            let task = BlockedTask::block(cur_task);\n+\n+            let mut guard = (*my_lock).lock();\n+            match f(task) {\n+                Ok(()) => guard.wait(),\n+                Err(task) => { cast::forget(task.wake()); }\n+            }\n+            drop(guard);\n+            cur_task = cast::transmute::<uint, ~Task>(cur_task_dupe);\n+        }\n+        Local::put(cur_task);\n+    }\n+    fn reawaken(mut ~self, mut to_wake: ~Task) {\n+        let lock: *mut LittleLock = &mut self.lock;\n+        to_wake.put_runtime(self as ~Runtime);\n+        unsafe {\n+            cast::forget(to_wake);\n+            let _l = (*lock).lock();\n+            (*lock).signal();\n+        }\n+    }\n+\n+    // These functions are all unimplemented and fail as a result. This is on\n+    // purpose. A \"simple task\" is just that, a very simple task that can't\n+    // really do a whole lot. The only purpose of the task is to get us off our\n+    // feet and running.\n+    fn yield_now(~self, _cur_task: ~Task) { fail!() }\n+    fn maybe_yield(~self, _cur_task: ~Task) { fail!() }\n+    fn spawn_sibling(~self, _cur_task: ~Task, _opts: TaskOpts, _f: proc()) {\n+        fail!()\n+    }\n+    fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> { None }\n+    fn wrap(~self) -> ~Any { fail!() }\n+}\n+\n+pub fn task() -> ~Task {\n+    let mut task = ~Task::new();\n+    task.put_runtime(~SimpleTask { lock: LittleLock::new() } as ~Runtime);\n+    return task;\n+}"}, {"sha": "60ae239ee9788a0ddde585d7bef88868f105ebb0", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2", "patch": "@@ -33,15 +33,16 @@\n //    answer is that you don't need them)\n \n use std::os;\n+use std::rt::local::Local;\n+use std::rt::task::Task;\n use std::rt;\n-use stdtask = std::rt::task;\n \n pub mod io;\n pub mod task;\n \n \n // XXX: this should not exist here\n-#[cfg(stage0, notready)]\n+#[cfg(stage0)]\n #[lang = \"start\"]\n pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n     use std::cast;\n@@ -72,21 +73,25 @@ pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n /// exited.\n pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n     rt::init(argc, argv);\n-    let exit_code = run(main);\n+    let mut exit_code = None;\n+    let mut main = Some(main);\n+    task::new().run(|| {\n+        exit_code = Some(run(main.take_unwrap()));\n+    });\n     unsafe { rt::cleanup(); }\n-    return exit_code;\n+    return exit_code.unwrap();\n }\n \n /// Executes a procedure on the current thread in a Rust task context.\n ///\n /// This function has all of the same details as `start` except for a different\n /// number of arguments.\n pub fn run(main: proc()) -> int {\n-    // Create a task, run the procedure in it, and then wait for everything.\n-    task::run(task::new(), main);\n-\n-    // Block this OS task waiting for everything to finish.\n-    unsafe { stdtask::wait_for_completion() }\n-\n+    // Run the main procedure and then wait for everything to finish\n+    main();\n+    unsafe {\n+        let mut task = Local::borrow(None::<Task>);\n+        task.get().wait_for_other_tasks();\n+    }\n     os::get_exit_status()\n }"}, {"sha": "0d5e08979caa493542c519a1821b4dbdc538c57f", "filename": "src/libnative/task.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2", "patch": "@@ -77,17 +77,11 @@ pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n             stack::record_stack_bounds(my_stack - stack + 1024, my_stack);\n         }\n \n-        run(task, f);\n+        let mut f = Some(f);\n+        task.run(|| { f.take_unwrap()() });\n     })\n }\n \n-/// Runs a task once, consuming the task. The given procedure is run inside of\n-/// the task.\n-pub fn run(t: ~Task, f: proc()) {\n-    let mut f = Some(f);\n-    t.run(|| { f.take_unwrap()(); });\n-}\n-\n // This structure is the glue between channels and the 1:1 scheduling mode. This\n // structure is allocated once per task.\n struct Ops {"}, {"sha": "765f0b427cd54632ca8b3f4ca8d4f41e1ecc57f4", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=51c03c1f35f6b076928a1e5b94ec81e6d00c3ac2", "patch": "@@ -292,6 +292,21 @@ impl Task {\n     pub fn local_io<'a>(&'a mut self) -> Option<LocalIo<'a>> {\n         self.imp.get_mut_ref().local_io()\n     }\n+\n+    /// The main function of all rust executables will by default use this\n+    /// function. This function will *block* the OS thread (hence the `unsafe`)\n+    /// waiting for all known tasks to complete. Once this function has\n+    /// returned, it is guaranteed that no more user-defined code is still\n+    /// running.\n+    pub unsafe fn wait_for_other_tasks(&mut self) {\n+        TASK_COUNT.fetch_sub(1, SeqCst); // don't count ourselves\n+        TASK_LOCK.lock();\n+        while TASK_COUNT.load(SeqCst) > 0 {\n+            TASK_LOCK.wait();\n+        }\n+        TASK_LOCK.unlock();\n+        TASK_COUNT.fetch_add(1, SeqCst); // add ourselves back in\n+    }\n }\n \n impl Drop for Task {\n@@ -396,18 +411,6 @@ impl Drop for Death {\n     }\n }\n \n-/// The main function of all rust executables will by default use this function.\n-/// This function will *block* the OS thread (hence the `unsafe`) waiting for\n-/// all known tasks to complete. Once this function has returned, it is\n-/// guaranteed that no more user-defined code is still running.\n-pub unsafe fn wait_for_completion() {\n-    TASK_LOCK.lock();\n-    while TASK_COUNT.load(SeqCst) > 0 {\n-        TASK_LOCK.wait();\n-    }\n-    TASK_LOCK.unlock();\n-}\n-\n #[cfg(test)]\n mod test {\n     use super::*;"}]}