{"sha": "348d770fedcddad7d814bd41072efc0602c739c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0OGQ3NzBmZWRjZGRhZDdkODE0YmQ0MTA3MmVmYzA2MDJjNzM5Yzg=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-01-31T23:56:12Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-02-01T04:13:56Z"}, "message": "copy oldsmallintmap.rs to smallintmap.rs", "tree": {"sha": "4e7ad04d0373337814034eaa7901846102ebc8c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e7ad04d0373337814034eaa7901846102ebc8c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/348d770fedcddad7d814bd41072efc0602c739c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/348d770fedcddad7d814bd41072efc0602c739c8", "html_url": "https://github.com/rust-lang/rust/commit/348d770fedcddad7d814bd41072efc0602c739c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/348d770fedcddad7d814bd41072efc0602c739c8/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70855f5a07bb17e6690c32832dec452cb211b18a", "url": "https://api.github.com/repos/rust-lang/rust/commits/70855f5a07bb17e6690c32832dec452cb211b18a", "html_url": "https://github.com/rust-lang/rust/commit/70855f5a07bb17e6690c32832dec452cb211b18a"}], "stats": {"total": 237, "additions": 237, "deletions": 0}, "files": [{"sha": "431775b17d67048ddeaed50814e1ec00a4d70b3a", "filename": "src/libstd/smallintmap.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/348d770fedcddad7d814bd41072efc0602c739c8/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348d770fedcddad7d814bd41072efc0602c739c8/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=348d770fedcddad7d814bd41072efc0602c739c8", "patch": "@@ -0,0 +1,237 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * A simple map based on a vector for small integer keys. Space requirements\n+ * are O(highest integer key).\n+ */\n+#[forbid(deprecated_mode)];\n+\n+use core::container::{Container, Mutable, Map, Set};\n+use core::dvec::DVec;\n+use core::ops;\n+use core::option::{Some, None};\n+use core::option;\n+use core::prelude::*;\n+\n+// FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n+// requires this to be.\n+struct SmallIntMap_<T> {\n+    v: DVec<Option<T>>,\n+}\n+\n+pub enum SmallIntMap<T> {\n+    SmallIntMap_(@SmallIntMap_<T>)\n+}\n+\n+/// Create a smallintmap\n+pub fn mk<T: Copy>() -> SmallIntMap<T> {\n+    let v = DVec();\n+    SmallIntMap_(@SmallIntMap_ { v: v } )\n+}\n+\n+/**\n+ * Add a value to the map. If the map already contains a value for\n+ * the specified key then the original value is replaced.\n+ */\n+#[inline(always)]\n+pub fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, val: T) {\n+    //io::println(fmt!(\"%?\", key));\n+    self.v.grow_set_elt(key, &None, Some(val));\n+}\n+\n+/**\n+ * Get the value for the specified key. If the key does not exist\n+ * in the map then returns none\n+ */\n+pub pure fn find<T: Copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n+    if key < self.v.len() { return self.v.get_elt(key); }\n+    return None::<T>;\n+}\n+\n+/**\n+ * Get the value for the specified key\n+ *\n+ * # Failure\n+ *\n+ * If the key does not exist in the map\n+ */\n+pub pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n+    match find(self, key) {\n+      None => {\n+        error!(\"smallintmap::get(): key not present\");\n+        fail;\n+      }\n+      Some(move v) => return v\n+    }\n+}\n+\n+/// Returns true if the map contains a value for the specified key\n+pub pure fn contains_key<T: Copy>(self: SmallIntMap<T>, key: uint) -> bool {\n+    return !find(self, key).is_none();\n+}\n+\n+impl<V> SmallIntMap<V>: Container {\n+    /// Return the number of elements in the map\n+    pure fn len(&self) -> uint {\n+        let mut sz = 0u;\n+        for self.v.each |item| {\n+            match *item {\n+              Some(_) => sz += 1u,\n+              _ => ()\n+            }\n+        }\n+        sz\n+    }\n+\n+    /// Return true if the map contains no elements\n+    pure fn is_empty(&self) -> bool { self.len() == 0 }\n+}\n+\n+impl<V> SmallIntMap<V>: Mutable {\n+    fn clear(&mut self) { self.v.set(~[]) }\n+}\n+\n+/// Implements the map::map interface for smallintmap\n+impl<V: Copy> SmallIntMap<V> {\n+    #[inline(always)]\n+    fn insert(key: uint, value: V) -> bool {\n+        let exists = contains_key(self, key);\n+        insert(self, key, value);\n+        return !exists;\n+    }\n+    fn remove(key: uint) -> bool {\n+        if key >= self.v.len() {\n+            return false;\n+        }\n+        let old = self.v.get_elt(key);\n+        self.v.set_elt(key, None);\n+        old.is_some()\n+    }\n+    pure fn contains_key(key: uint) -> bool {\n+        contains_key(self, key)\n+    }\n+    pure fn contains_key_ref(key: &uint) -> bool {\n+        contains_key(self, *key)\n+    }\n+    pure fn get(key: uint) -> V { get(self, key) }\n+    pure fn find(key: uint) -> Option<V> { find(self, key) }\n+\n+    fn update_with_key(key: uint, val: V, ff: fn(uint, V, V) -> V) -> bool {\n+        match self.find(key) {\n+            None            => return self.insert(key, val),\n+            Some(copy orig) => return self.insert(key, ff(key, orig, val)),\n+        }\n+    }\n+\n+    fn update(key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n+        return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n+    }\n+\n+    pure fn each(it: fn(key: uint, value: V) -> bool) {\n+        self.each_ref(|k, v| it(*k, *v))\n+    }\n+    pure fn each_key(it: fn(key: uint) -> bool) {\n+        self.each_ref(|k, _v| it(*k))\n+    }\n+    pure fn each_value(it: fn(value: V) -> bool) {\n+        self.each_ref(|_k, v| it(*v))\n+    }\n+    pure fn each_ref(it: fn(key: &uint, value: &V) -> bool) {\n+        let mut idx = 0u, l = self.v.len();\n+        while idx < l {\n+            match self.v.get_elt(idx) {\n+              Some(ref elt) => if !it(&idx, elt) { break },\n+              None => ()\n+            }\n+            idx += 1u;\n+        }\n+    }\n+    pure fn each_key_ref(blk: fn(key: &uint) -> bool) {\n+        self.each_ref(|k, _v| blk(k))\n+    }\n+    pure fn each_value_ref(blk: fn(value: &V) -> bool) {\n+        self.each_ref(|_k, v| blk(v))\n+    }\n+}\n+\n+impl<V: Copy> SmallIntMap<V>: ops::Index<uint, V> {\n+    pure fn index(&self, key: uint) -> V {\n+        unsafe {\n+            get(*self, key)\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{mk, SmallIntMap};\n+\n+    use core::option::None;\n+\n+    #[test]\n+    fn test_len() {\n+        let mut map = mk();\n+        assert map.len() == 0;\n+        assert map.is_empty();\n+        map.insert(5, 20);\n+        assert map.len() == 1;\n+        assert !map.is_empty();\n+        map.insert(11, 12);\n+        assert map.len() == 2;\n+        assert !map.is_empty();\n+        map.insert(14, 22);\n+        assert map.len() == 3;\n+        assert !map.is_empty();\n+    }\n+\n+    #[test]\n+    fn test_clear() {\n+        let mut map = mk();\n+        map.insert(5, 20);\n+        map.insert(11, 12);\n+        map.insert(14, 22);\n+        map.clear();\n+        assert map.is_empty();\n+        assert map.find(5).is_none();\n+        assert map.find(11).is_none();\n+        assert map.find(14).is_none();\n+    }\n+\n+    #[test]\n+    fn test_insert_with_key() {\n+        let map: SmallIntMap<uint> = mk();\n+\n+        // given a new key, initialize it with this new count, given\n+        // given an existing key, add more to its count\n+        fn addMoreToCount(_k: uint, v0: uint, v1: uint) -> uint {\n+            v0 + v1\n+        }\n+\n+        fn addMoreToCount_simple(v0: uint, v1: uint) -> uint {\n+            v0 + v1\n+        }\n+\n+        // count integers\n+        map.update(3, 1, addMoreToCount_simple);\n+        map.update_with_key(9, 1, addMoreToCount);\n+        map.update(3, 7, addMoreToCount_simple);\n+        map.update_with_key(5, 3, addMoreToCount);\n+        map.update_with_key(3, 2, addMoreToCount);\n+\n+        // check the total counts\n+        assert map.find(3).get() == 10;\n+        assert map.find(5).get() == 3;\n+        assert map.find(9).get() == 1;\n+\n+        // sadly, no sevens were counted\n+        assert None == map.find(7);\n+    }\n+}"}]}