{"sha": "0ee230a09453451791105670aab769464c4a9270", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZTIzMGEwOTQ1MzQ1MTc5MTEwNTY3MGFhYjc2OTQ2NGM0YTkyNzA=", "commit": {"author": {"name": "Bryce Van Dyk", "email": "bryce@vandyk.net.nz", "date": "2015-11-23T09:03:52Z"}, "committer": {"name": "Bryce Van Dyk", "email": "bryce@vandyk.net.nz", "date": "2015-12-03T06:27:59Z"}, "message": "libterm: bring across changes from term\n\nThis brings across changes made to the term library to libterm. This\nincludes removing instances or unwrap, fixing format string handling, and\nremoving a TODO.\n\nThis fix does not bring all changes across, as term now relies on cargo\ndeps that cannot be brought into the rust build at this stage, but has\nattempted as best to cross port changes not relying on this. This notably\nlimits extra functionality since implemented int he Terminal trait in\nTerm.\n\nThis is in partly in response to rust issue #29992.", "tree": {"sha": "65fc60d1048c82ce567a2fd77176671273bfa3f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65fc60d1048c82ce567a2fd77176671273bfa3f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ee230a09453451791105670aab769464c4a9270", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ee230a09453451791105670aab769464c4a9270", "html_url": "https://github.com/rust-lang/rust/commit/0ee230a09453451791105670aab769464c4a9270", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ee230a09453451791105670aab769464c4a9270/comments", "author": {"login": "SingingTree", "id": 3637370, "node_id": "MDQ6VXNlcjM2MzczNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/3637370?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SingingTree", "html_url": "https://github.com/SingingTree", "followers_url": "https://api.github.com/users/SingingTree/followers", "following_url": "https://api.github.com/users/SingingTree/following{/other_user}", "gists_url": "https://api.github.com/users/SingingTree/gists{/gist_id}", "starred_url": "https://api.github.com/users/SingingTree/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SingingTree/subscriptions", "organizations_url": "https://api.github.com/users/SingingTree/orgs", "repos_url": "https://api.github.com/users/SingingTree/repos", "events_url": "https://api.github.com/users/SingingTree/events{/privacy}", "received_events_url": "https://api.github.com/users/SingingTree/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SingingTree", "id": 3637370, "node_id": "MDQ6VXNlcjM2MzczNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/3637370?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SingingTree", "html_url": "https://github.com/SingingTree", "followers_url": "https://api.github.com/users/SingingTree/followers", "following_url": "https://api.github.com/users/SingingTree/following{/other_user}", "gists_url": "https://api.github.com/users/SingingTree/gists{/gist_id}", "starred_url": "https://api.github.com/users/SingingTree/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SingingTree/subscriptions", "organizations_url": "https://api.github.com/users/SingingTree/orgs", "repos_url": "https://api.github.com/users/SingingTree/repos", "events_url": "https://api.github.com/users/SingingTree/events{/privacy}", "received_events_url": "https://api.github.com/users/SingingTree/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f95de3b3b99954f48f189bcca195eb43c67844e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f95de3b3b99954f48f189bcca195eb43c67844e", "html_url": "https://github.com/rust-lang/rust/commit/2f95de3b3b99954f48f189bcca195eb43c67844e"}], "stats": {"total": 1243, "additions": 545, "deletions": 698}, "files": [{"sha": "b854a2f2a0a1730fe09667d3fcb9f8be1e4fd3d6", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ee230a09453451791105670aab769464c4a9270/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee230a09453451791105670aab769464c4a9270/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=0ee230a09453451791105670aab769464c4a9270", "patch": "@@ -20,7 +20,7 @@ use std::cell::{RefCell, Cell};\n use std::{cmp, error, fmt};\n use std::io::prelude::*;\n use std::io;\n-use term::{self, WriterWrapper};\n+use term;\n \n /// maximum number of lines we will print for each error; arbitrary.\n const MAX_LINES: usize = 6;\n@@ -318,7 +318,7 @@ pub struct EmitterWriter {\n }\n \n enum Destination {\n-    Terminal(Box<term::Terminal<WriterWrapper> + Send>),\n+    Terminal(Box<term::StderrTerminal>),\n     Raw(Box<Write + Send>),\n }\n \n@@ -365,7 +365,7 @@ impl EmitterWriter {\n \n     fn print_maybe_styled(&mut self,\n                           args: fmt::Arguments,\n-                          color: term::attr::Attr,\n+                          color: term::Attr,\n                           print_newline_at_end: bool) -> io::Result<()> {\n         match self.dst {\n             Terminal(ref mut t) => {\n@@ -408,13 +408,13 @@ impl EmitterWriter {\n             try!(write!(&mut self.dst, \"{} \", topic));\n         }\n \n-        try!(print_maybe_styled!(self, term::attr::ForegroundColor(lvl.color()),\n+        try!(print_maybe_styled!(self, term::Attr::ForegroundColor(lvl.color()),\n                                  \"{}: \", lvl.to_string()));\n-        try!(print_maybe_styled!(self, term::attr::Bold, \"{}\", msg));\n+        try!(print_maybe_styled!(self, term::Attr::Bold, \"{}\", msg));\n \n         match code {\n             Some(code) => {\n-                let style = term::attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n+                let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n                 try!(print_maybe_styled!(self, style, \" [{}]\", code.clone()));\n             }\n             None => ()\n@@ -646,7 +646,7 @@ impl EmitterWriter {\n                     s.pop();\n                 }\n \n-                try!(println_maybe_styled!(self, term::attr::ForegroundColor(lvl.color()),\n+                try!(println_maybe_styled!(self, term::Attr::ForegroundColor(lvl.color()),\n                                            \"{}\", s));\n             }\n         }\n@@ -719,7 +719,7 @@ impl EmitterWriter {\n             }\n         }\n         s.push('^');\n-        println_maybe_styled!(self, term::attr::ForegroundColor(lvl.color()),\n+        println_maybe_styled!(self, term::Attr::ForegroundColor(lvl.color()),\n                               \"{}\", s)\n     }\n "}, {"sha": "69ad55d79089931d4302dd92fd7fa5623ad7873d", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 72, "deletions": 94, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/0ee230a09453451791105670aab769464c4a9270/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee230a09453451791105670aab769464c4a9270/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=0ee230a09453451791105670aab769464c4a9270", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,29 +11,28 @@\n //! Terminal formatting library.\n //!\n //! This crate provides the `Terminal` trait, which abstracts over an [ANSI\n-//! Terminal][ansi] to provide color printing, among other things. There are two implementations,\n-//! the `TerminfoTerminal`, which uses control characters from a\n-//! [terminfo][ti] database, and `WinConsole`, which uses the [Win32 Console\n+//! Terminal][ansi] to provide color printing, among other things. There are two\n+//! implementations, the `TerminfoTerminal`, which uses control characters from\n+//! a [terminfo][ti] database, and `WinConsole`, which uses the [Win32 Console\n //! API][win].\n //!\n //! # Examples\n //!\n //! ```no_run\n //! # #![feature(rustc_private)]\n //! extern crate term;\n-//!\n //! use std::io::prelude::*;\n //!\n //! fn main() {\n //!     let mut t = term::stdout().unwrap();\n //!\n //!     t.fg(term::color::GREEN).unwrap();\n-//!     (write!(t, \"hello, \")).unwrap();\n+//!     write!(t, \"hello, \").unwrap();\n //!\n //!     t.fg(term::color::RED).unwrap();\n-//!     (writeln!(t, \"world!\")).unwrap();\n+//!     writeln!(t, \"world!\").unwrap();\n //!\n-//!     t.reset().unwrap();\n+//!     assert!(t.reset().unwrap());\n //! }\n //! ```\n //!\n@@ -58,84 +57,60 @@\n #![deny(missing_docs)]\n \n #![feature(box_syntax)]\n-#![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(str_char)]\n-#![feature(vec_push_all)]\n #![cfg_attr(windows, feature(libc))]\n // Handle rustfmt skips\n #![feature(custom_attribute)]\n #![allow(unused_attributes)]\n \n-#[macro_use]\n-extern crate log;\n+use std::io::prelude::*;\n \n pub use terminfo::TerminfoTerminal;\n #[cfg(windows)]\n pub use win::WinConsole;\n \n-use std::io::prelude::*;\n-use std::io;\n+use std::io::{self, Stdout, Stderr};\n \n pub mod terminfo;\n \n #[cfg(windows)]\n mod win;\n \n-/// A hack to work around the fact that `Box<Write + Send>` does not\n-/// currently implement `Write`.\n-pub struct WriterWrapper {\n-    wrapped: Box<Write + Send>,\n-}\n-\n-impl Write for WriterWrapper {\n-    #[inline]\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.wrapped.write(buf)\n-    }\n-\n-    #[inline]\n-    fn flush(&mut self) -> io::Result<()> {\n-        self.wrapped.flush()\n-    }\n-}\n+/// Alias for stdout terminals.\n+pub type StdoutTerminal = Terminal<Output=Stdout> + Send;\n+/// Alias for stderr terminals.\n+pub type StderrTerminal = Terminal<Output=Stderr> + Send;\n \n #[cfg(not(windows))]\n /// Return a Terminal wrapping stdout, or None if a terminal couldn't be\n /// opened.\n-pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n-    TerminfoTerminal::new(WriterWrapper { wrapped: box std::io::stdout() })\n+pub fn stdout() -> Option<Box<StdoutTerminal>> {\n+    TerminfoTerminal::new(io::stdout()).map(|t| Box::new(t) as Box<StdoutTerminal>)\n }\n \n #[cfg(windows)]\n /// Return a Terminal wrapping stdout, or None if a terminal couldn't be\n /// opened.\n-pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n-    let ti = TerminfoTerminal::new(WriterWrapper { wrapped: box std::io::stdout() });\n-\n-    match ti {\n-        Some(t) => Some(t),\n-        None => WinConsole::new(WriterWrapper { wrapped: box std::io::stdout() }),\n-    }\n+pub fn stdout() -> Option<Box<StdoutTerminal>> {\n+    TerminfoTerminal::new(io::stdout())\n+        .map(|t| Box::new(t) as Box<StdoutTerminal>)\n+        .or_else(|| WinConsole::new(io::stdout()).ok().map(|t| Box::new(t) as Box<StdoutTerminal>))\n }\n \n #[cfg(not(windows))]\n /// Return a Terminal wrapping stderr, or None if a terminal couldn't be\n /// opened.\n-pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n-    TerminfoTerminal::new(WriterWrapper { wrapped: box std::io::stderr() })\n+pub fn stderr() -> Option<Box<StderrTerminal>> {\n+    TerminfoTerminal::new(io::stderr()).map(|t| Box::new(t) as Box<StderrTerminal>)\n }\n \n #[cfg(windows)]\n /// Return a Terminal wrapping stderr, or None if a terminal couldn't be\n /// opened.\n-pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n-    let ti = TerminfoTerminal::new(WriterWrapper { wrapped: box std::io::stderr() });\n-\n-    match ti {\n-        Some(t) => Some(t),\n-        None => WinConsole::new(WriterWrapper { wrapped: box std::io::stderr() }),\n-    }\n+pub fn stderr() -> Option<Box<StderrTerminal>> {\n+    TerminfoTerminal::new(io::stderr())\n+        .map(|t| Box::new(t) as Box<StderrTerminal>)\n+        .or_else(|| WinConsole::new(io::stderr()).ok().map(|t| Box::new(t) as Box<StderrTerminal>))\n }\n \n \n@@ -164,43 +139,41 @@ pub mod color {\n     pub const BRIGHT_WHITE: Color = 15;\n }\n \n-/// Terminal attributes\n-pub mod attr {\n-    pub use self::Attr::*;\n-\n-    /// Terminal attributes for use with term.attr().\n-    ///\n-    /// Most attributes can only be turned on and must be turned off with term.reset().\n-    /// The ones that can be turned off explicitly take a boolean value.\n-    /// Color is also represented as an attribute for convenience.\n-    #[derive(Copy, Clone)]\n-    pub enum Attr {\n-        /// Bold (or possibly bright) mode\n-        Bold,\n-        /// Dim mode, also called faint or half-bright. Often not supported\n-        Dim,\n-        /// Italics mode. Often not supported\n-        Italic(bool),\n-        /// Underline mode\n-        Underline(bool),\n-        /// Blink mode\n-        Blink,\n-        /// Standout mode. Often implemented as Reverse, sometimes coupled with Bold\n-        Standout(bool),\n-        /// Reverse mode, inverts the foreground and background colors\n-        Reverse,\n-        /// Secure mode, also called invis mode. Hides the printed text\n-        Secure,\n-        /// Convenience attribute to set the foreground color\n-        ForegroundColor(super::color::Color),\n-        /// Convenience attribute to set the background color\n-        BackgroundColor(super::color::Color),\n-    }\n+/// Terminal attributes for use with term.attr().\n+///\n+/// Most attributes can only be turned on and must be turned off with term.reset().\n+/// The ones that can be turned off explicitly take a boolean value.\n+/// Color is also represented as an attribute for convenience.\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+pub enum Attr {\n+    /// Bold (or possibly bright) mode\n+    Bold,\n+    /// Dim mode, also called faint or half-bright. Often not supported\n+    Dim,\n+    /// Italics mode. Often not supported\n+    Italic(bool),\n+    /// Underline mode\n+    Underline(bool),\n+    /// Blink mode\n+    Blink,\n+    /// Standout mode. Often implemented as Reverse, sometimes coupled with Bold\n+    Standout(bool),\n+    /// Reverse mode, inverts the foreground and background colors\n+    Reverse,\n+    /// Secure mode, also called invis mode. Hides the printed text\n+    Secure,\n+    /// Convenience attribute to set the foreground color\n+    ForegroundColor(color::Color),\n+    /// Convenience attribute to set the background color\n+    BackgroundColor(color::Color),\n }\n \n /// A terminal with similar capabilities to an ANSI Terminal\n /// (foreground/background colors etc).\n-pub trait Terminal<T: Write>: Write {\n+pub trait Terminal: Write {\n+    /// The terminal's output writer type.\n+    type Output: Write;\n+\n     /// Sets the foreground color to the given color.\n     ///\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n@@ -222,24 +195,29 @@ pub trait Terminal<T: Write>: Write {\n     /// Sets the given terminal attribute, if supported.  Returns `Ok(true)`\n     /// if the attribute was supported, `Ok(false)` otherwise, and `Err(e)` if\n     /// there was an I/O error.\n-    fn attr(&mut self, attr: attr::Attr) -> io::Result<bool>;\n+    fn attr(&mut self, attr: Attr) -> io::Result<bool>;\n \n     /// Returns whether the given terminal attribute is supported.\n-    fn supports_attr(&self, attr: attr::Attr) -> bool;\n+    fn supports_attr(&self, attr: Attr) -> bool;\n \n-    /// Resets all terminal attributes and color to the default.\n-    /// Returns `Ok()`.\n-    fn reset(&mut self) -> io::Result<()>;\n+    /// Resets all terminal attributes and colors to their defaults.\n+    ///\n+    /// Returns `Ok(true)` if the terminal was reset, `Ok(false)` otherwise, and `Err(e)` if there\n+    /// was an I/O error.\n+    ///\n+    /// *Note: This does not flush.*\n+    ///\n+    /// That means the reset command may get buffered so, if you aren't planning on doing anything\n+    /// else that might flush stdout's buffer (e.g. writing a line of text), you should flush after\n+    /// calling reset.\n+    fn reset(&mut self) -> io::Result<bool>;\n \n     /// Gets an immutable reference to the stream inside\n-    fn get_ref<'a>(&'a self) -> &'a T;\n+    fn get_ref<'a>(&'a self) -> &'a Self::Output;\n \n     /// Gets a mutable reference to the stream inside\n-    fn get_mut<'a>(&'a mut self) -> &'a mut T;\n-}\n+    fn get_mut<'a>(&'a mut self) -> &'a mut Self::Output;\n \n-/// A terminal which can be unwrapped.\n-pub trait UnwrappableTerminal<T: Write>: Terminal<T> {\n     /// Returns the contained stream, destroying the `Terminal`\n-    fn unwrap(self) -> T;\n+    fn into_inner(self) -> Self::Output where Self: Sized;\n }"}, {"sha": "a4e5d00ee7a77646e68082cde6c28a5e1e8e7413", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 153, "deletions": 119, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/0ee230a09453451791105670aab769464c4a9270/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee230a09453451791105670aab769464c4a9270/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=0ee230a09453451791105670aab769464c4a9270", "patch": "@@ -12,16 +12,20 @@\n \n use std::collections::HashMap;\n use std::env;\n+use std::error;\n+use std::fmt;\n+use std::fs::File;\n use std::io::prelude::*;\n use std::io;\n+use std::io::BufReader;\n+use std::path::Path;\n \n-use attr;\n+use Attr;\n use color;\n use Terminal;\n-use UnwrappableTerminal;\n-use self::searcher::open;\n+use self::searcher::get_dbpath_for_term;\n use self::parser::compiled::{parse, msys_terminfo};\n-use self::parm::{expand, Number, Variables};\n+use self::parm::{expand, Variables, Param};\n \n \n /// A parsed terminfo database entry.\n@@ -37,6 +41,80 @@ pub struct TermInfo {\n     pub strings: HashMap<String, Vec<u8>>,\n }\n \n+/// A terminfo creation error.\n+#[derive(Debug)]\n+pub enum Error {\n+    /// TermUnset Indicates that the environment doesn't include enough information to find\n+    /// the terminfo entry.\n+    TermUnset,\n+    /// MalformedTerminfo indicates that parsing the terminfo entry failed.\n+    MalformedTerminfo(String),\n+    /// io::Error forwards any io::Errors encountered when finding or reading the terminfo entry.\n+    IoError(io::Error),\n+}\n+\n+impl error::Error for Error {\n+    fn description(&self) -> &str {\n+        \"failed to create TermInfo\"\n+    }\n+\n+    fn cause(&self) -> Option<&error::Error> {\n+        use self::Error::*;\n+        match self {\n+            &IoError(ref e) => Some(e),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        use self::Error::*;\n+        match self {\n+            &TermUnset => Ok(()),\n+            &MalformedTerminfo(ref e) => e.fmt(f),\n+            &IoError(ref e) => e.fmt(f),\n+        }\n+    }\n+}\n+\n+impl TermInfo {\n+    /// Create a TermInfo based on current environment.\n+    pub fn from_env() -> Result<TermInfo, Error> {\n+        let term = match env::var(\"TERM\") {\n+            Ok(name) => TermInfo::from_name(&name),\n+            Err(..) => return Err(Error::TermUnset),\n+        };\n+\n+        if term.is_err() && env::var(\"MSYSCON\").ok().map_or(false, |s| \"mintty.exe\" == s) {\n+            // msys terminal\n+            Ok(msys_terminfo())\n+        } else {\n+            term\n+        }\n+    }\n+\n+    /// Create a TermInfo for the named terminal.\n+    pub fn from_name(name: &str) -> Result<TermInfo, Error> {\n+        get_dbpath_for_term(name)\n+            .ok_or_else(|| {\n+                Error::IoError(io::Error::new(io::ErrorKind::NotFound, \"terminfo file not found\"))\n+            })\n+            .and_then(|p| TermInfo::from_path(&(*p)))\n+    }\n+\n+    /// Parse the given TermInfo.\n+    pub fn from_path<P: AsRef<Path>>(path: P) -> Result<TermInfo, Error> {\n+        Self::_from_path(path.as_ref())\n+    }\n+    // Keep the metadata small\n+    fn _from_path(path: &Path) -> Result<TermInfo, Error> {\n+        let file = try!(File::open(path).map_err(|e| Error::IoError(e)));\n+        let mut reader = BufReader::new(file);\n+        parse(&mut reader, false).map_err(|e| Error::MalformedTerminfo(e))\n+    }\n+}\n+\n pub mod searcher;\n \n /// TermInfo format parsing.\n@@ -47,21 +125,21 @@ pub mod parser {\n pub mod parm;\n \n \n-fn cap_for_attr(attr: attr::Attr) -> &'static str {\n+fn cap_for_attr(attr: Attr) -> &'static str {\n     match attr {\n-        attr::Bold => \"bold\",\n-        attr::Dim => \"dim\",\n-        attr::Italic(true) => \"sitm\",\n-        attr::Italic(false) => \"ritm\",\n-        attr::Underline(true) => \"smul\",\n-        attr::Underline(false) => \"rmul\",\n-        attr::Blink => \"blink\",\n-        attr::Standout(true) => \"smso\",\n-        attr::Standout(false) => \"rmso\",\n-        attr::Reverse => \"rev\",\n-        attr::Secure => \"invis\",\n-        attr::ForegroundColor(_) => \"setaf\",\n-        attr::BackgroundColor(_) => \"setab\",\n+        Attr::Bold => \"bold\",\n+        Attr::Dim => \"dim\",\n+        Attr::Italic(true) => \"sitm\",\n+        Attr::Italic(false) => \"ritm\",\n+        Attr::Underline(true) => \"smul\",\n+        Attr::Underline(false) => \"rmul\",\n+        Attr::Blink => \"blink\",\n+        Attr::Standout(true) => \"smso\",\n+        Attr::Standout(false) => \"rmso\",\n+        Attr::Reverse => \"rev\",\n+        Attr::Secure => \"invis\",\n+        Attr::ForegroundColor(_) => \"setaf\",\n+        Attr::BackgroundColor(_) => \"setab\",\n     }\n }\n \n@@ -70,89 +148,61 @@ fn cap_for_attr(attr: attr::Attr) -> &'static str {\n pub struct TerminfoTerminal<T> {\n     num_colors: u16,\n     out: T,\n-    ti: Box<TermInfo>,\n+    ti: TermInfo,\n }\n \n-impl<T: Write+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n+impl<T: Write+Send> Terminal for TerminfoTerminal<T> {\n+    type Output = T;\n     fn fg(&mut self, color: color::Color) -> io::Result<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n-            let s = expand(self.ti\n-                               .strings\n-                               .get(\"setaf\")\n-                               .unwrap(),\n-                           &[Number(color as isize)],\n-                           &mut Variables::new());\n-            if s.is_ok() {\n-                try!(self.out.write_all(&s.unwrap()));\n-                return Ok(true);\n-            }\n+            return self.apply_cap(\"setaf\", &[Param::Number(color as i32)]);\n         }\n         Ok(false)\n     }\n \n     fn bg(&mut self, color: color::Color) -> io::Result<bool> {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n-            let s = expand(self.ti\n-                               .strings\n-                               .get(\"setab\")\n-                               .unwrap(),\n-                           &[Number(color as isize)],\n-                           &mut Variables::new());\n-            if s.is_ok() {\n-                try!(self.out.write_all(&s.unwrap()));\n-                return Ok(true);\n-            }\n+            return self.apply_cap(\"setab\", &[Param::Number(color as i32)]);\n         }\n         Ok(false)\n     }\n \n-    fn attr(&mut self, attr: attr::Attr) -> io::Result<bool> {\n+    fn attr(&mut self, attr: Attr) -> io::Result<bool> {\n         match attr {\n-            attr::ForegroundColor(c) => self.fg(c),\n-            attr::BackgroundColor(c) => self.bg(c),\n-            _ => {\n-                let cap = cap_for_attr(attr);\n-                let parm = self.ti.strings.get(cap);\n-                if parm.is_some() {\n-                    let s = expand(parm.unwrap(), &[], &mut Variables::new());\n-                    if s.is_ok() {\n-                        try!(self.out.write_all(&s.unwrap()));\n-                        return Ok(true);\n-                    }\n-                }\n-                Ok(false)\n-            }\n+            Attr::ForegroundColor(c) => self.fg(c),\n+            Attr::BackgroundColor(c) => self.bg(c),\n+            _ => self.apply_cap(cap_for_attr(attr), &[]),\n         }\n     }\n \n-    fn supports_attr(&self, attr: attr::Attr) -> bool {\n+    fn supports_attr(&self, attr: Attr) -> bool {\n         match attr {\n-            attr::ForegroundColor(_) | attr::BackgroundColor(_) => self.num_colors > 0,\n+            Attr::ForegroundColor(_) | Attr::BackgroundColor(_) => self.num_colors > 0,\n             _ => {\n                 let cap = cap_for_attr(attr);\n                 self.ti.strings.get(cap).is_some()\n             }\n         }\n     }\n \n-    fn reset(&mut self) -> io::Result<()> {\n-        let mut cap = self.ti.strings.get(\"sgr0\");\n-        if cap.is_none() {\n-            // are there any terminals that have color/attrs and not sgr0?\n-            // Try falling back to sgr, then op\n-            cap = self.ti.strings.get(\"sgr\");\n-            if cap.is_none() {\n-                cap = self.ti.strings.get(\"op\");\n+    fn reset(&mut self) -> io::Result<bool> {\n+        // are there any terminals that have color/attrs and not sgr0?\n+        // Try falling back to sgr, then op\n+        let cmd = match [\"sg0\", \"sgr\", \"op\"]\n+                            .iter()\n+                            .filter_map(|cap| self.ti.strings.get(*cap))\n+                            .next() {\n+            Some(op) => {\n+                match expand(&op, &[], &mut Variables::new()) {\n+                    Ok(cmd) => cmd,\n+                    Err(e) => return Err(io::Error::new(io::ErrorKind::InvalidData, e)),\n+                }\n             }\n-        }\n-        let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_owned()),\n-                           |op| expand(op, &[], &mut Variables::new()));\n-        if s.is_ok() {\n-            return self.out.write_all(&s.unwrap());\n-        }\n-        Ok(())\n+            None => return Ok(false),\n+        };\n+        self.out.write_all(&cmd).and(Ok(true))\n     }\n \n     fn get_ref<'a>(&'a self) -> &'a T {\n@@ -162,64 +212,36 @@ impl<T: Write+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n     fn get_mut<'a>(&'a mut self) -> &'a mut T {\n         &mut self.out\n     }\n-}\n \n-impl<T: Write+Send+'static> UnwrappableTerminal<T> for TerminfoTerminal<T> {\n-    fn unwrap(self) -> T {\n+    fn into_inner(self) -> T\n+        where Self: Sized\n+    {\n         self.out\n     }\n }\n \n-impl<T: Write+Send+'static> TerminfoTerminal<T> {\n-    /// Returns `None` whenever the terminal cannot be created for some\n-    /// reason.\n-    pub fn new(out: T) -> Option<Box<Terminal<T> + Send + 'static>> {\n-        let term = match env::var(\"TERM\") {\n-            Ok(t) => t,\n-            Err(..) => {\n-                debug!(\"TERM environment variable not defined\");\n-                return None;\n-            }\n-        };\n-\n-        let mut file = match open(&term[..]) {\n-            Ok(f) => f,\n-            Err(err) => {\n-                return match env::var(\"MSYSCON\") {\n-                    Ok(ref val) if &val[..] == \"mintty.exe\" => {\n-                        // msys terminal\n-                        Some(box TerminfoTerminal {\n-                            out: out,\n-                            ti: msys_terminfo(),\n-                            num_colors: 8,\n-                        })\n-                    }\n-                    _ => {\n-                        debug!(\"error finding terminfo entry: {:?}\", err);\n-                        None\n-                    }\n-                };\n-            }\n-        };\n-\n-        let ti = parse(&mut file, false);\n-        if ti.is_err() {\n-            debug!(\"error parsing terminfo entry: {:?}\", ti.err().unwrap());\n-            return None;\n-        }\n-\n-        let inf = ti.unwrap();\n-        let nc = if inf.strings.get(\"setaf\").is_some() && inf.strings.get(\"setab\").is_some() {\n-            inf.numbers.get(\"colors\").map_or(0, |&n| n)\n+impl<T: Write+Send> TerminfoTerminal<T> {\n+    /// Create a new TerminfoTerminal with the given TermInfo and Write.\n+    pub fn new_with_terminfo(out: T, terminfo: TermInfo) -> TerminfoTerminal<T> {\n+        let nc = if terminfo.strings.contains_key(\"setaf\") &&\n+                    terminfo.strings.contains_key(\"setab\") {\n+            terminfo.numbers.get(\"colors\").map_or(0, |&n| n)\n         } else {\n             0\n         };\n \n-        Some(box TerminfoTerminal {\n+        TerminfoTerminal {\n             out: out,\n-            ti: inf,\n+            ti: terminfo,\n             num_colors: nc,\n-        })\n+        }\n+    }\n+\n+    /// Create a new TerminfoTerminal for the current environment with the given Write.\n+    ///\n+    /// Returns `None` when the terminfo cannot be found or parsed.\n+    pub fn new(out: T) -> Option<TerminfoTerminal<T>> {\n+        TermInfo::from_env().map(move |ti| TerminfoTerminal::new_with_terminfo(out, ti)).ok()\n     }\n \n     fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n@@ -229,6 +251,18 @@ impl<T: Write+Send+'static> TerminfoTerminal<T> {\n             color\n         }\n     }\n+\n+    fn apply_cap(&mut self, cmd: &str, params: &[Param]) -> io::Result<bool> {\n+        match self.ti.strings.get(cmd) {\n+            Some(cmd) => {\n+                match expand(&cmd, params, &mut Variables::new()) {\n+                    Ok(s) => self.out.write_all(&s).and(Ok(true)),\n+                    Err(e) => Err(io::Error::new(io::ErrorKind::InvalidData, e)),\n+                }\n+            }\n+            None => Ok(false),\n+        }\n+    }\n }\n \n "}, {"sha": "aceaa0c10bcce847e22fbbd7a25224561c6a0098", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 156, "deletions": 292, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/0ee230a09453451791105670aab769464c4a9270/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee230a09453451791105670aab769464c4a9270/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=0ee230a09453451791105670aab769464c4a9270", "patch": "@@ -10,15 +10,14 @@\n \n //! Parameterized string expansion\n \n-pub use self::Param::*;\n+use self::Param::*;\n use self::States::*;\n use self::FormatState::*;\n use self::FormatOp::*;\n-use std::ascii::AsciiExt;\n-use std::mem::replace;\n+\n use std::iter::repeat;\n \n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Clone, Copy, PartialEq)]\n enum States {\n     Nothing,\n     Percent,\n@@ -27,15 +26,15 @@ enum States {\n     PushParam,\n     CharConstant,\n     CharClose,\n-    IntConstant(isize),\n+    IntConstant(i32),\n     FormatPattern(Flags, FormatState),\n-    SeekIfElse(isize),\n-    SeekIfElsePercent(isize),\n-    SeekIfEnd(isize),\n-    SeekIfEndPercent(isize),\n+    SeekIfElse(usize),\n+    SeekIfElsePercent(usize),\n+    SeekIfEnd(usize),\n+    SeekIfEndPercent(usize),\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, PartialEq, Clone)]\n enum FormatState {\n     FormatStateFlags,\n     FormatStateWidth,\n@@ -47,7 +46,7 @@ enum FormatState {\n #[derive(Clone)]\n pub enum Param {\n     Words(String),\n-    Number(isize),\n+    Number(i32),\n }\n \n /// Container for static and dynamic variable arrays\n@@ -94,11 +93,11 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n     // Copy parameters into a local vector for mutability\n     let mut mparams = [Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n                        Number(0), Number(0), Number(0)];\n-    for (dst, src) in mparams.iter_mut().zip(params) {\n+    for (dst, src) in mparams.iter_mut().zip(params.iter()) {\n         *dst = (*src).clone();\n     }\n \n-    for &c in cap {\n+    for &c in cap.iter() {\n         let cur = c as char;\n         let mut old_state = state;\n         match state {\n@@ -116,20 +115,13 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                         state = Nothing\n                     }\n                     'c' => {\n-                        if !stack.is_empty() {\n-                            match stack.pop().unwrap() {\n-                                // if c is 0, use 0200 (128) for ncurses compatibility\n-                                Number(c) => {\n-                                    output.push(if c == 0 {\n-                                        128\n-                                    } else {\n-                                        c as u8\n-                                    })\n-                                }\n-                                _ => return Err(\"a non-char was used with %c\".to_owned()),\n-                            }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n+                        match stack.pop() {\n+                            // if c is 0, use 0200 (128) for ncurses compatibility\n+                            Some(Number(0)) => output.push(128u8),\n+                            // Don't check bounds. ncurses just casts and truncates.\n+                            Some(Number(c)) => output.push(c as u8),\n+                            Some(_) => return Err(\"a non-char was used with %c\".to_string()),\n+                            None => return Err(\"stack is empty\".to_string()),\n                         }\n                     }\n                     'p' => state = PushParam,\n@@ -138,208 +130,89 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                     '\\'' => state = CharConstant,\n                     '{' => state = IntConstant(0),\n                     'l' => {\n-                        if !stack.is_empty() {\n-                            match stack.pop().unwrap() {\n-                                Words(s) => stack.push(Number(s.len() as isize)),\n-                                _ => return Err(\"a non-str was used with %l\".to_owned()),\n-                            }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n-                        }\n-                    }\n-                    '+' => {\n-                        if stack.len() > 1 {\n-                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                                (Number(y), Number(x)) => stack.push(Number(x + y)),\n-                                _ => return Err(\"non-numbers on stack with +\".to_owned()),\n-                            }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n-                        }\n-                    }\n-                    '-' => {\n-                        if stack.len() > 1 {\n-                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                                (Number(y), Number(x)) => stack.push(Number(x - y)),\n-                                _ => return Err(\"non-numbers on stack with -\".to_owned()),\n-                            }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n-                        }\n-                    }\n-                    '*' => {\n-                        if stack.len() > 1 {\n-                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                                (Number(y), Number(x)) => stack.push(Number(x * y)),\n-                                _ => return Err(\"non-numbers on stack with *\".to_owned()),\n-                            }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n-                        }\n-                    }\n-                    '/' => {\n-                        if stack.len() > 1 {\n-                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                                (Number(y), Number(x)) => stack.push(Number(x / y)),\n-                                _ => return Err(\"non-numbers on stack with /\".to_owned()),\n-                            }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n-                        }\n-                    }\n-                    'm' => {\n-                        if stack.len() > 1 {\n-                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                                (Number(y), Number(x)) => stack.push(Number(x % y)),\n-                                _ => return Err(\"non-numbers on stack with %\".to_owned()),\n-                            }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n-                        }\n-                    }\n-                    '&' => {\n-                        if stack.len() > 1 {\n-                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                                (Number(y), Number(x)) => stack.push(Number(x & y)),\n-                                _ => return Err(\"non-numbers on stack with &\".to_owned()),\n-                            }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n-                        }\n-                    }\n-                    '|' => {\n-                        if stack.len() > 1 {\n-                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                                (Number(y), Number(x)) => stack.push(Number(x | y)),\n-                                _ => return Err(\"non-numbers on stack with |\".to_owned()),\n-                            }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n-                        }\n-                    }\n-                    '^' => {\n-                        if stack.len() > 1 {\n-                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                                (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n-                                _ => return Err(\"non-numbers on stack with ^\".to_owned()),\n-                            }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n+                        match stack.pop() {\n+                            Some(Words(s)) => stack.push(Number(s.len() as i32)),\n+                            Some(_) => return Err(\"a non-str was used with %l\".to_string()),\n+                            None => return Err(\"stack is empty\".to_string()),\n                         }\n                     }\n-                    '=' => {\n-                        if stack.len() > 1 {\n-                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                                (Number(y), Number(x)) => {\n-                                    stack.push(Number(if x == y {\n-                                        1\n-                                    } else {\n-                                        0\n-                                    }))\n-                                }\n-                                _ => return Err(\"non-numbers on stack with =\".to_owned()),\n+                    '+' | '-' | '/' | '*' | '^' | '&' | '|' | 'm' => {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Some(Number(y)), Some(Number(x))) => {\n+                                stack.push(Number(match cur {\n+                                    '+' => x + y,\n+                                    '-' => x - y,\n+                                    '*' => x * y,\n+                                    '/' => x / y,\n+                                    '|' => x | y,\n+                                    '&' => x & y,\n+                                    '^' => x ^ y,\n+                                    'm' => x % y,\n+                                    _ => unreachable!(\"All cases handled\"),\n+                                }))\n                             }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n-                        }\n-                    }\n-                    '>' => {\n-                        if stack.len() > 1 {\n-                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                                (Number(y), Number(x)) => {\n-                                    stack.push(Number(if x > y {\n-                                        1\n-                                    } else {\n-                                        0\n-                                    }))\n-                                }\n-                                _ => return Err(\"non-numbers on stack with >\".to_owned()),\n+                            (Some(_), Some(_)) => {\n+                                return Err(format!(\"non-numbers on stack with {}\", cur))\n                             }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n+                            _ => return Err(\"stack is empty\".to_string()),\n                         }\n                     }\n-                    '<' => {\n-                        if stack.len() > 1 {\n-                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                                (Number(y), Number(x)) => {\n-                                    stack.push(Number(if x < y {\n-                                        1\n-                                    } else {\n-                                        0\n-                                    }))\n-                                }\n-                                _ => return Err(\"non-numbers on stack with <\".to_owned()),\n+                    '=' | '>' | '<' | 'A' | 'O' => {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Some(Number(y)), Some(Number(x))) => {\n+                                stack.push(Number(if match cur {\n+                                    '=' => x == y,\n+                                    '<' => x < y,\n+                                    '>' => x > y,\n+                                    'A' => x > 0 && y > 0,\n+                                    'O' => x > 0 || y > 0,\n+                                    _ => unreachable!(),\n+                                } {\n+                                    1\n+                                } else {\n+                                    0\n+                                }))\n                             }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n-                        }\n-                    }\n-                    'A' => {\n-                        if stack.len() > 1 {\n-                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                                (Number(0), Number(_)) => stack.push(Number(0)),\n-                                (Number(_), Number(0)) => stack.push(Number(0)),\n-                                (Number(_), Number(_)) => stack.push(Number(1)),\n-                                _ => return Err(\"non-numbers on stack with logical and\".to_owned()),\n+                            (Some(_), Some(_)) => {\n+                                return Err(format!(\"non-numbers on stack with {}\", cur))\n                             }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n+                            _ => return Err(\"stack is empty\".to_string()),\n                         }\n                     }\n-                    'O' => {\n-                        if stack.len() > 1 {\n-                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                                (Number(0), Number(0)) => stack.push(Number(0)),\n-                                (Number(_), Number(_)) => stack.push(Number(1)),\n-                                _ => return Err(\"non-numbers on stack with logical or\".to_owned()),\n+                    '!' | '~' => {\n+                        match stack.pop() {\n+                            Some(Number(x)) => {\n+                                stack.push(Number(match cur {\n+                                    '!' if x > 0 => 0,\n+                                    '!' => 1,\n+                                    '~' => !x,\n+                                    _ => unreachable!(),\n+                                }))\n                             }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n-                        }\n-                    }\n-                    '!' => {\n-                        if !stack.is_empty() {\n-                            match stack.pop().unwrap() {\n-                                Number(0) => stack.push(Number(1)),\n-                                Number(_) => stack.push(Number(0)),\n-                                _ => return Err(\"non-number on stack with logical not\".to_owned()),\n-                            }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n-                        }\n-                    }\n-                    '~' => {\n-                        if !stack.is_empty() {\n-                            match stack.pop().unwrap() {\n-                                Number(x) => stack.push(Number(!x)),\n-                                _ => return Err(\"non-number on stack with %~\".to_owned()),\n-                            }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n+                            Some(_) => return Err(format!(\"non-numbers on stack with {}\", cur)),\n+                            None => return Err(\"stack is empty\".to_string()),\n                         }\n                     }\n                     'i' => {\n-                        match (mparams[0].clone(), mparams[1].clone()) {\n-                            (Number(x), Number(y)) => {\n+                        match (&mparams[0], &mparams[1]) {\n+                            (&Number(x), &Number(y)) => {\n                                 mparams[0] = Number(x + 1);\n                                 mparams[1] = Number(y + 1);\n                             }\n-                            (_, _) => return Err(\"first two params not numbers with %i\".to_owned()),\n+                            (_, _) => {\n+                                return Err(\"first two params not numbers with %i\".to_string())\n+                            }\n                         }\n                     }\n \n                     // printf-style support for %doxXs\n                     'd' | 'o' | 'x' | 'X' | 's' => {\n-                        if !stack.is_empty() {\n+                        if let Some(arg) = stack.pop() {\n                             let flags = Flags::new();\n-                            let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), flags);\n-                            if res.is_err() {\n-                                return res;\n-                            }\n-                            output.push_all(&res.unwrap())\n+                            let res = try!(format(arg, FormatOp::from_char(cur), flags));\n+                            output.extend(res.iter().map(|x| *x));\n                         } else {\n-                            return Err(\"stack is empty\".to_owned());\n+                            return Err(\"stack is empty\".to_string());\n                         }\n                     }\n                     ':' | '#' | ' ' | '.' | '0'...'9' => {\n@@ -362,47 +235,45 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                     // conditionals\n                     '?' => (),\n                     't' => {\n-                        if !stack.is_empty() {\n-                            match stack.pop().unwrap() {\n-                                Number(0) => state = SeekIfElse(0),\n-                                Number(_) => (),\n-                                _ => return Err(\"non-number on stack with conditional\".to_owned()),\n+                        match stack.pop() {\n+                            Some(Number(0)) => state = SeekIfElse(0),\n+                            Some(Number(_)) => (),\n+                            Some(_) => {\n+                                return Err(\"non-number on stack with conditional\".to_string())\n                             }\n-                        } else {\n-                            return Err(\"stack is empty\".to_owned());\n+                            None => return Err(\"stack is empty\".to_string()),\n                         }\n                     }\n                     'e' => state = SeekIfEnd(0),\n                     ';' => (),\n-\n-                    _ => return Err(format!(\"unrecognized format option {:?}\", cur)),\n+                    _ => return Err(format!(\"unrecognized format option {}\", cur)),\n                 }\n             }\n             PushParam => {\n                 // params are 1-indexed\n                 stack.push(mparams[match cur.to_digit(10) {\n                                Some(d) => d as usize - 1,\n-                               None => return Err(\"bad param number\".to_owned()),\n+                               None => return Err(\"bad param number\".to_string()),\n                            }]\n                            .clone());\n             }\n             SetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n-                    if !stack.is_empty() {\n+                    if let Some(arg) = stack.pop() {\n                         let idx = (cur as u8) - b'A';\n-                        vars.sta[idx as usize] = stack.pop().unwrap();\n+                        vars.sta[idx as usize] = arg;\n                     } else {\n-                        return Err(\"stack is empty\".to_owned());\n+                        return Err(\"stack is empty\".to_string());\n                     }\n                 } else if cur >= 'a' && cur <= 'z' {\n-                    if !stack.is_empty() {\n+                    if let Some(arg) = stack.pop() {\n                         let idx = (cur as u8) - b'a';\n-                        vars.dyn[idx as usize] = stack.pop().unwrap();\n+                        vars.dyn[idx as usize] = arg;\n                     } else {\n-                        return Err(\"stack is empty\".to_owned());\n+                        return Err(\"stack is empty\".to_string());\n                     }\n                 } else {\n-                    return Err(\"bad variable name in %P\".to_owned());\n+                    return Err(\"bad variable name in %P\".to_string());\n                 }\n             }\n             GetVar => {\n@@ -413,47 +284,45 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                     let idx = (cur as u8) - b'a';\n                     stack.push(vars.dyn[idx as usize].clone());\n                 } else {\n-                    return Err(\"bad variable name in %g\".to_owned());\n+                    return Err(\"bad variable name in %g\".to_string());\n                 }\n             }\n             CharConstant => {\n-                stack.push(Number(c as isize));\n+                stack.push(Number(c as i32));\n                 state = CharClose;\n             }\n             CharClose => {\n                 if cur != '\\'' {\n-                    return Err(\"malformed character constant\".to_owned());\n+                    return Err(\"malformed character constant\".to_string());\n                 }\n             }\n             IntConstant(i) => {\n-                match cur {\n-                    '}' => {\n-                        stack.push(Number(i));\n-                        state = Nothing;\n-                    }\n-                    '0'...'9' => {\n-                        state = IntConstant(i * 10 + (cur as isize - '0' as isize));\n-                        old_state = Nothing;\n+                if cur == '}' {\n+                    stack.push(Number(i));\n+                    state = Nothing;\n+                } else if let Some(digit) = cur.to_digit(10) {\n+                    match i.checked_mul(10).and_then(|i_ten| i_ten.checked_add(digit as i32)) {\n+                        Some(i) => {\n+                            state = IntConstant(i);\n+                            old_state = Nothing;\n+                        }\n+                        None => return Err(\"int constant too large\".to_string()),\n                     }\n-                    _ => return Err(\"bad isize constant\".to_owned()),\n+                } else {\n+                    return Err(\"bad int constant\".to_string());\n                 }\n             }\n             FormatPattern(ref mut flags, ref mut fstate) => {\n                 old_state = Nothing;\n                 match (*fstate, cur) {\n                     (_, 'd') | (_, 'o') | (_, 'x') | (_, 'X') | (_, 's') => {\n-                        if !stack.is_empty() {\n-                            let res = format(stack.pop().unwrap(),\n-                                             FormatOp::from_char(cur),\n-                                             *flags);\n-                            if res.is_err() {\n-                                return res;\n-                            }\n-                            output.push_all(&res.unwrap());\n+                        if let Some(arg) = stack.pop() {\n+                            let res = try!(format(arg, FormatOp::from_char(cur), *flags));\n+                            output.extend(res.iter().map(|x| *x));\n                             // will cause state to go to Nothing\n                             old_state = FormatPattern(*flags, *fstate);\n                         } else {\n-                            return Err(\"stack is empty\".to_owned());\n+                            return Err(\"stack is empty\".to_string());\n                         }\n                     }\n                     (FormatStateFlags, '#') => {\n@@ -479,7 +348,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                         let old = flags.width;\n                         flags.width = flags.width * 10 + (cur as usize - '0' as usize);\n                         if flags.width < old {\n-                            return Err(\"format width overflow\".to_owned());\n+                            return Err(\"format width overflow\".to_string());\n                         }\n                     }\n                     (FormatStateWidth, '.') => {\n@@ -489,10 +358,10 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                         let old = flags.precision;\n                         flags.precision = flags.precision * 10 + (cur as usize - '0' as usize);\n                         if flags.precision < old {\n-                            return Err(\"format precision overflow\".to_owned());\n+                            return Err(\"format precision overflow\".to_string());\n                         }\n                     }\n-                    _ => return Err(\"invalid format specifier\".to_owned()),\n+                    _ => return Err(\"invalid format specifier\".to_string()),\n                 }\n             }\n             SeekIfElse(level) => {\n@@ -543,7 +412,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n     Ok(output)\n }\n \n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, PartialEq, Clone)]\n struct Flags {\n     width: usize,\n     precision: usize,\n@@ -600,61 +469,55 @@ impl FormatOp {\n fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n     let mut s = match val {\n         Number(d) => {\n-            let s = match (op, flags.sign) {\n-                (FormatDigit, true) => format!(\"{:+}\", d).into_bytes(),\n-                (FormatDigit, false) => format!(\"{}\", d).into_bytes(),\n-                (FormatOctal, _) => format!(\"{:o}\", d).into_bytes(),\n-                (FormatHex, _) => format!(\"{:x}\", d).into_bytes(),\n-                (FormatHEX, _) => format!(\"{:X}\", d).into_bytes(),\n-                (FormatString, _) => return Err(\"non-number on stack with %s\".to_owned()),\n-            };\n-            let mut s: Vec<u8> = s.into_iter().collect();\n-            if flags.precision > s.len() {\n-                let mut s_ = Vec::with_capacity(flags.precision);\n-                let n = flags.precision - s.len();\n-                s_.extend(repeat(b'0').take(n));\n-                s_.extend(s);\n-                s = s_;\n-            }\n-            assert!(!s.is_empty(), \"string conversion produced empty result\");\n             match op {\n                 FormatDigit => {\n-                    if flags.space && !(s[0] == b'-' || s[0] == b'+') {\n-                        s.insert(0, b' ');\n+                    if flags.sign {\n+                        format!(\"{:+01$}\", d, flags.precision)\n+                    } else if d < 0 {\n+                        // C doesn't take sign into account in precision calculation.\n+                        format!(\"{:01$}\", d, flags.precision + 1)\n+                    } else if flags.space {\n+                        format!(\" {:01$}\", d, flags.precision)\n+                    } else {\n+                        format!(\"{:01$}\", d, flags.precision)\n                     }\n                 }\n                 FormatOctal => {\n-                    if flags.alternate && s[0] != b'0' {\n-                        s.insert(0, b'0');\n+                    if flags.alternate {\n+                        // Leading octal zero counts against precision.\n+                        format!(\"0{:01$o}\", d, flags.precision.saturating_sub(1))\n+                    } else {\n+                        format!(\"{:01$o}\", d, flags.precision)\n                     }\n                 }\n                 FormatHex => {\n-                    if flags.alternate {\n-                        let s_ = replace(&mut s, vec![b'0', b'x']);\n-                        s.extend(s_);\n+                    if flags.alternate && d != 0 {\n+                        format!(\"0x{:01$x}\", d, flags.precision)\n+                    } else {\n+                        format!(\"{:01$x}\", d, flags.precision)\n                     }\n                 }\n                 FormatHEX => {\n-                    s = s.to_ascii_uppercase();\n-                    if flags.alternate {\n-                        let s_ = replace(&mut s, vec![b'0', b'X']);\n-                        s.extend(s_);\n+                    if flags.alternate && d != 0 {\n+                        format!(\"0X{:01$X}\", d, flags.precision)\n+                    } else {\n+                        format!(\"{:01$X}\", d, flags.precision)\n                     }\n                 }\n-                FormatString => unreachable!(),\n+                FormatString => return Err(\"non-number on stack with %s\".to_string()),\n             }\n-            s\n+            .into_bytes()\n         }\n         Words(s) => {\n             match op {\n                 FormatString => {\n-                    let mut s = s.as_bytes().to_vec();\n+                    let mut s = s.into_bytes();\n                     if flags.precision > 0 && flags.precision < s.len() {\n                         s.truncate(flags.precision);\n                     }\n                     s\n                 }\n-                _ => return Err(format!(\"non-string on stack with %{:?}\", op.to_char())),\n+                _ => return Err(format!(\"non-string on stack with %{}\", op.to_char())),\n             }\n         }\n     };\n@@ -665,16 +528,17 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n         } else {\n             let mut s_ = Vec::with_capacity(flags.width);\n             s_.extend(repeat(b' ').take(n));\n-            s_.extend(s);\n+            s_.extend(s.into_iter());\n             s = s_;\n         }\n     }\n     Ok(s)\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::{expand, Param, Words, Variables, Number};\n+mod test {\n+    use super::{expand, Variables};\n+    use super::Param::{self, Words, Number};\n     use std::result::Result::Ok;\n \n     #[test]\n@@ -711,12 +575,12 @@ mod tests {\n                    vars: &mut Variables)\n                    -> Result<Vec<u8>, String> {\n             let mut u8v: Vec<_> = fmt.bytes().collect();\n-            u8v.extend(cap.bytes());\n+            u8v.extend(cap.as_bytes().iter().map(|&b| b));\n             expand(&u8v, params, vars)\n         }\n \n         let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n-        for &cap in &caps {\n+        for &cap in caps.iter() {\n             let res = get_res(\"\", cap, &[], vars);\n             assert!(res.is_err(),\n                     \"Op {} succeeded incorrectly with 0 stack entries\",\n@@ -733,7 +597,7 @@ mod tests {\n                     res.err().unwrap());\n         }\n         let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n-        for &cap in &caps {\n+        for &cap in caps.iter() {\n             let res = expand(cap.as_bytes(), &[], vars);\n             assert!(res.is_err(),\n                     \"Binop {} succeeded incorrectly with 0 stack entries\",\n@@ -744,7 +608,7 @@ mod tests {\n                     cap);\n             let res = get_res(\"%{1}%{2}\", cap, &[], vars);\n             assert!(res.is_ok(),\n-                    \"Binop {} failed with 2 stack entries: {:?}\",\n+                    \"Binop {} failed with 2 stack entries: {}\",\n                     cap,\n                     res.err().unwrap());\n         }\n@@ -757,20 +621,20 @@ mod tests {\n \n     #[test]\n     fn test_comparison_ops() {\n-        let v = [('<', [1, 0, 0]), ('=', [0, 1, 0]), ('>', [0, 0, 1])];\n-        for &(op, bs) in &v {\n+        let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n+        for &(op, bs) in v.iter() {\n             let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n             let res = expand(s.as_bytes(), &[], &mut Variables::new());\n             assert!(res.is_ok(), res.err().unwrap());\n-            assert_eq!(res.unwrap(), [b'0' + bs[0]]);\n+            assert_eq!(res.unwrap(), vec![b'0' + bs[0]]);\n             let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n             let res = expand(s.as_bytes(), &[], &mut Variables::new());\n             assert!(res.is_ok(), res.err().unwrap());\n-            assert_eq!(res.unwrap(), [b'0' + bs[1]]);\n+            assert_eq!(res.unwrap(), vec![b'0' + bs[1]]);\n             let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n             let res = expand(s.as_bytes(), &[], &mut Variables::new());\n             assert!(res.is_ok(), res.err().unwrap());\n-            assert_eq!(res.unwrap(), [b'0' + bs[2]]);\n+            assert_eq!(res.unwrap(), vec![b'0' + bs[2]]);\n         }\n     }\n \n@@ -800,7 +664,7 @@ mod tests {\n                             Words(\"foo\".to_string())],\n                           vars),\n                    Ok(\"foofoo ffo\".bytes().collect::<Vec<_>>()));\n-        assert_eq!(expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_owned())], vars),\n+        assert_eq!(expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_string())], vars),\n                    Ok(\"fo  \".bytes().collect::<Vec<_>>()));\n \n         assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", &[Number(1)], vars),"}, {"sha": "558d35c2ae27b9844e9b2105eb4cdcc6cb6d9802", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 114, "deletions": 125, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/0ee230a09453451791105670aab769464c4a9270/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee230a09453451791105670aab769464c4a9270/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=0ee230a09453451791105670aab769464c4a9270", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_upper_case_globals)]\n+#![allow(non_upper_case_globals, missing_docs)]\n \n //! ncurses-compatible compiled terminfo format parsing (term(5))\n \n@@ -20,7 +20,6 @@ use super::super::TermInfo;\n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n \n #[rustfmt_skip]\n-#[allow(missing_docs)]\n pub static boolfnames: &'static[&'static str] = &[\"auto_left_margin\", \"auto_right_margin\",\n     \"no_esc_ctlc\", \"ceol_standout_glitch\", \"eat_newline_glitch\", \"erase_overstrike\", \"generic_type\",\n     \"hard_copy\", \"has_meta_key\", \"has_status_line\", \"insert_null_glitch\", \"memory_above\",\n@@ -34,14 +33,12 @@ pub static boolfnames: &'static[&'static str] = &[\"auto_left_margin\", \"auto_righ\n     \"return_does_clr_eol\"];\n \n #[rustfmt_skip]\n-#[allow(missing_docs)]\n pub static boolnames: &'static[&'static str] = &[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\",\n     \"gn\", \"hc\", \"km\", \"hs\", \"in\", \"db\", \"da\", \"mir\", \"msgr\", \"os\", \"eslok\", \"xt\", \"hz\", \"ul\", \"xon\",\n     \"nxon\", \"mc5i\", \"chts\", \"nrrmc\", \"npc\", \"ndscr\", \"ccc\", \"bce\", \"hls\", \"xhpa\", \"crxm\", \"daisy\",\n     \"xvpa\", \"sam\", \"cpix\", \"lpix\", \"OTbs\", \"OTns\", \"OTnc\", \"OTMT\", \"OTNL\", \"OTpt\", \"OTxr\"];\n \n #[rustfmt_skip]\n-#[allow(missing_docs)]\n pub static numfnames: &'static[&'static str] = &[ \"columns\", \"init_tabs\", \"lines\",\n     \"lines_of_memory\", \"magic_cookie_glitch\", \"padding_baud_rate\", \"virtual_terminal\",\n     \"width_status_line\", \"num_labels\", \"label_height\", \"label_width\", \"max_attributes\",\n@@ -53,14 +50,12 @@ pub static numfnames: &'static[&'static str] = &[ \"columns\", \"init_tabs\", \"lines\n     \"new_line_delay\", \"backspace_delay\", \"horizontal_tab_delay\", \"number_of_function_keys\"];\n \n #[rustfmt_skip]\n-#[allow(missing_docs)]\n pub static numnames: &'static[&'static str] = &[ \"cols\", \"it\", \"lines\", \"lm\", \"xmc\", \"pb\",\n     \"vt\", \"wsl\", \"nlab\", \"lh\", \"lw\", \"ma\", \"wnum\", \"colors\", \"pairs\", \"ncv\", \"bufsz\", \"spinv\",\n     \"spinh\", \"maddr\", \"mjump\", \"mcs\", \"mls\", \"npins\", \"orc\", \"orl\", \"orhi\", \"orvi\", \"cps\", \"widcs\",\n     \"btns\", \"bitwin\", \"bitype\", \"UTug\", \"OTdC\", \"OTdN\", \"OTdB\", \"OTdT\", \"OTkn\"];\n \n #[rustfmt_skip]\n-#[allow(missing_docs)]\n pub static stringfnames: &'static[&'static str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n     \"change_scroll_region\", \"clear_all_tabs\", \"clear_screen\", \"clr_eol\", \"clr_eos\",\n     \"column_address\", \"command_character\", \"cursor_address\", \"cursor_down\", \"cursor_home\",\n@@ -135,7 +130,6 @@ pub static stringfnames: &'static[&'static str] = &[ \"back_tab\", \"bell\", \"carria\n     \"acs_plus\", \"memory_lock\", \"memory_unlock\", \"box_chars_1\"];\n \n #[rustfmt_skip]\n-#[allow(missing_docs)]\n pub static stringnames: &'static[&'static str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tbc\", \"clear\",\n     \"_\", \"_\", \"hpa\", \"cmdch\", \"cup\", \"cud1\", \"home\", \"civis\", \"cub1\", \"mrcup\", \"cnorm\", \"cuf1\",\n     \"ll\", \"cuu1\", \"cvvis\", \"dch1\", \"dl1\", \"dsl\", \"hd\", \"smacs\", \"blink\", \"bold\", \"smcup\", \"smdc\",\n@@ -170,114 +164,132 @@ pub static stringnames: &'static[&'static str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tb\n     \"OTG3\", \"OTG1\", \"OTG4\", \"OTGR\", \"OTGL\", \"OTGU\", \"OTGD\", \"OTGH\", \"OTGV\", \"OTGC\", \"meml\", \"memu\",\n     \"box1\"];\n \n-/// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n-pub fn parse(file: &mut Read, longnames: bool) -> Result<Box<TermInfo>, String> {\n-    macro_rules! try { ($e:expr) => (\n+fn read_le_u16(r: &mut io::Read) -> io::Result<u16> {\n+    let mut b = [0; 2];\n+    let mut amt = 0;\n+    while amt < b.len() {\n+        match try!(r.read(&mut b[amt..])) {\n+            0 => return Err(io::Error::new(io::ErrorKind::Other, \"end of file\")),\n+            n => amt += n,\n+        }\n+    }\n+    Ok((b[0] as u16) | ((b[1] as u16) << 8))\n+}\n+\n+fn read_byte(r: &mut io::Read) -> io::Result<u8> {\n+    match r.bytes().next() {\n+        Some(s) => s,\n+        None => Err(io::Error::new(io::ErrorKind::Other, \"end of file\")),\n+    }\n+}\n+\n+/// Parse a compiled terminfo entry, using long capability names if `longnames`\n+/// is true\n+pub fn parse(file: &mut io::Read, longnames: bool) -> Result<TermInfo, String> {\n+    macro_rules! try( ($e:expr) => (\n         match $e {\n             Ok(e) => e,\n-            Err(e) => return Err(format!(\"{:?}\", e))\n+            Err(e) => return Err(format!(\"{}\", e))\n         }\n-    ) }\n+    ) );\n \n-    let bnames;\n-    let snames;\n-    let nnames;\n-\n-    if longnames {\n-        bnames = boolfnames;\n-        snames = stringfnames;\n-        nnames = numfnames;\n+    let (bnames, snames, nnames) = if longnames {\n+        (boolfnames, stringfnames, numfnames)\n     } else {\n-        bnames = boolnames;\n-        snames = stringnames;\n-        nnames = numnames;\n-    }\n+        (boolnames, stringnames, numnames)\n+    };\n \n     // Check magic number\n     let magic = try!(read_le_u16(file));\n     if magic != 0x011A {\n         return Err(format!(\"invalid magic number: expected {:x}, found {:x}\",\n-                           0x011A_usize,\n-                           magic as usize));\n+                           0x011A,\n+                           magic));\n     }\n \n-    let names_bytes = try!(read_le_u16(file)) as isize;\n-    let bools_bytes = try!(read_le_u16(file)) as isize;\n-    let numbers_count = try!(read_le_u16(file)) as isize;\n-    let string_offsets_count = try!(read_le_u16(file)) as isize;\n-    let string_table_bytes = try!(read_le_u16(file)) as isize;\n+    // According to the spec, these fields must be >= -1 where -1 means that the feature is not\n+    // supported. Using 0 instead of -1 works because we skip sections with length 0.\n+    macro_rules! read_nonneg {\n+        () => {{\n+            match try!(read_le_u16(file)) as i16 {\n+                n if n >= 0 => n as usize,\n+                -1 => 0,\n+                _ => return Err(\"incompatible file: length fields must be  >= -1\".to_string()),\n+            }\n+        }}\n+    }\n+\n+    let names_bytes = read_nonneg!();\n+    let bools_bytes = read_nonneg!();\n+    let numbers_count = read_nonneg!();\n+    let string_offsets_count = read_nonneg!();\n+    let string_table_bytes = read_nonneg!();\n \n-    assert!(names_bytes > 0);\n+    if names_bytes == 0 {\n+        return Err(\"incompatible file: names field must be at least 1 byte wide\".to_string());\n+    }\n \n-    if (bools_bytes as usize) > boolnames.len() {\n-        return Err(\"incompatible file: more booleans than expected\".to_owned());\n+    if bools_bytes > boolnames.len() {\n+        return Err(\"incompatible file: more booleans than expected\".to_string());\n     }\n \n-    if (numbers_count as usize) > numnames.len() {\n-        return Err(\"incompatible file: more numbers than expected\".to_owned());\n+    if numbers_count > numnames.len() {\n+        return Err(\"incompatible file: more numbers than expected\".to_string());\n     }\n \n-    if (string_offsets_count as usize) > stringnames.len() {\n-        return Err(\"incompatible file: more string offsets than expected\".to_owned());\n+    if string_offsets_count > stringnames.len() {\n+        return Err(\"incompatible file: more string offsets than expected\".to_string());\n     }\n \n     // don't read NUL\n-    let bytes = try!(read_exact(file, names_bytes as usize - 1));\n+    let mut bytes = Vec::new();\n+    try!(file.take((names_bytes - 1) as u64).read_to_end(&mut bytes));\n     let names_str = match String::from_utf8(bytes) {\n         Ok(s) => s,\n-        Err(_) => return Err(\"input not utf-8\".to_owned()),\n+        Err(_) => return Err(\"input not utf-8\".to_string()),\n     };\n \n     let term_names: Vec<String> = names_str.split('|')\n-                                           .map(str::to_owned)\n+                                           .map(|s| s.to_string())\n                                            .collect();\n-\n-    try!(read_byte(file)); // consume NUL\n-\n-    let mut bools_map = HashMap::new();\n-    if bools_bytes != 0 {\n-        for i in 0..bools_bytes {\n-            let b = try!(read_byte(file));\n-            if b == 1 {\n-                bools_map.insert(bnames[i as usize].to_owned(), true);\n-            }\n-        }\n+    // consume NUL\n+    if try!(read_byte(file)) != b'\\0' {\n+        return Err(\"incompatible file: missing null terminator for names section\".to_string());\n     }\n \n+    let bools_map: HashMap<String, bool> = try! {\n+        (0..bools_bytes).filter_map(|i| match read_byte(file) {\n+            Err(e) => Some(Err(e)),\n+            Ok(1) => Some(Ok((bnames[i].to_string(), true))),\n+            Ok(_) => None\n+        }).collect()\n+    };\n+\n     if (bools_bytes + names_bytes) % 2 == 1 {\n         try!(read_byte(file)); // compensate for padding\n     }\n \n-    let mut numbers_map = HashMap::new();\n-    if numbers_count != 0 {\n-        for i in 0..numbers_count {\n-            let n = try!(read_le_u16(file));\n-            if n != 0xFFFF {\n-                numbers_map.insert(nnames[i as usize].to_owned(), n);\n-            }\n-        }\n-    }\n-\n-    let mut string_map = HashMap::new();\n-\n-    if string_offsets_count != 0 {\n-        let mut string_offsets = Vec::with_capacity(10);\n-        for _ in 0..string_offsets_count {\n-            string_offsets.push(try!(read_le_u16(file)));\n-        }\n+    let numbers_map: HashMap<String, u16> = try! {\n+        (0..numbers_count).filter_map(|i| match read_le_u16(file) {\n+            Ok(0xFFFF) => None,\n+            Ok(n) => Some(Ok((nnames[i].to_string(), n))),\n+            Err(e) => Some(Err(e))\n+        }).collect()\n+    };\n \n-        let string_table = try!(read_exact(file, string_table_bytes as usize));\n+    let string_map: HashMap<String, Vec<u8>> = if string_offsets_count > 0 {\n+        let string_offsets: Vec<u16> = try!((0..string_offsets_count)\n+                                                .map(|_| read_le_u16(file))\n+                                                .collect());\n \n-        if string_table.len() != string_table_bytes as usize {\n-            return Err(\"error: hit EOF before end of string table\".to_owned());\n-        }\n+        let mut string_table = Vec::new();\n+        try!(file.take(string_table_bytes as u64).read_to_end(&mut string_table));\n \n-        for (i, v) in string_offsets.iter().enumerate() {\n-            let offset = *v;\n-            if offset == 0xFFFF {\n-                // non-entry\n-                continue;\n-            }\n+        try!(string_offsets.into_iter().enumerate().filter(|&(_, offset)| {\n+            // non-entry\n+            offset != 0xFFFF\n+        }).map(|(i, offset)| {\n+            let offset = offset as usize;\n \n             let name = if snames[i] == \"_\" {\n                 stringfnames[i]\n@@ -288,73 +300,50 @@ pub fn parse(file: &mut Read, longnames: bool) -> Result<Box<TermInfo>, String>\n             if offset == 0xFFFE {\n                 // undocumented: FFFE indicates cap@, which means the capability is not present\n                 // unsure if the handling for this is correct\n-                string_map.insert(name.to_owned(), Vec::new());\n-                continue;\n+                return Ok((name.to_string(), Vec::new()));\n             }\n \n-\n             // Find the offset of the NUL we want to go to\n-            let nulpos = string_table[offset as usize..string_table_bytes as usize]\n-                             .iter()\n-                             .position(|&b| b == 0);\n+            let nulpos = string_table[offset..string_table_bytes].iter().position(|&b| b == 0);\n             match nulpos {\n-                Some(len) => {\n-                    string_map.insert(name.to_string(),\n-                                      string_table[offset as usize..(offset as usize + len)]\n-                                          .to_vec())\n-                }\n-                None => {\n-                    return Err(\"invalid file: missing NUL in string_table\".to_owned());\n-                }\n-            };\n-        }\n-    }\n+                Some(len) => Ok((name.to_string(), string_table[offset..offset + len].to_vec())),\n+                None => Err(\"invalid file: missing NUL in string_table\".to_string()),\n+            }\n+        }).collect())\n+    } else {\n+        HashMap::new()\n+    };\n \n     // And that's all there is to it\n-    Ok(box TermInfo {\n+    Ok(TermInfo {\n         names: term_names,\n         bools: bools_map,\n         numbers: numbers_map,\n         strings: string_map,\n     })\n }\n \n-fn read_le_u16<R: Read + ?Sized>(r: &mut R) -> io::Result<u16> {\n-    let mut b = [0; 2];\n-    assert_eq!(try!(r.read(&mut b)), 2);\n-    Ok((b[0] as u16) | ((b[1] as u16) << 8))\n-}\n-\n-fn read_byte<R: Read + ?Sized>(r: &mut R) -> io::Result<u8> {\n-    let mut b = [0; 1];\n-    assert_eq!(try!(r.read(&mut b)), 1);\n-    Ok(b[0])\n-}\n-\n-fn read_exact<R: Read + ?Sized>(r: &mut R, sz: usize) -> io::Result<Vec<u8>> {\n-    let mut v = Vec::with_capacity(sz);\n-    try!(r.take(sz as u64).read_to_end(&mut v));\n-    assert_eq!(v.len(), sz);\n-    Ok(v)\n-}\n-\n /// Create a dummy TermInfo struct for msys terminals\n-pub fn msys_terminfo() -> Box<TermInfo> {\n+pub fn msys_terminfo() -> TermInfo {\n     let mut strings = HashMap::new();\n-    strings.insert(\"sgr0\".to_owned(), b\"\\x1B[0m\".to_vec());\n-    strings.insert(\"bold\".to_owned(), b\"\\x1B[1m\".to_vec());\n-    strings.insert(\"setaf\".to_owned(), b\"\\x1B[3%p1%dm\".to_vec());\n-    strings.insert(\"setab\".to_owned(), b\"\\x1B[4%p1%dm\".to_vec());\n-    box TermInfo {\n-        names: vec![\"cygwin\".to_owned()], // msys is a fork of an older cygwin version\n+    strings.insert(\"sgr0\".to_string(), b\"\\x1B[0m\".to_vec());\n+    strings.insert(\"bold\".to_string(), b\"\\x1B[1m\".to_vec());\n+    strings.insert(\"setaf\".to_string(), b\"\\x1B[3%p1%dm\".to_vec());\n+    strings.insert(\"setab\".to_string(), b\"\\x1B[4%p1%dm\".to_vec());\n+\n+    let mut numbers = HashMap::new();\n+    numbers.insert(\"colors\".to_string(), 8u16);\n+\n+    TermInfo {\n+        names: vec![\"cygwin\".to_string()], // msys is a fork of an older cygwin version\n         bools: HashMap::new(),\n-        numbers: HashMap::new(),\n+        numbers: numbers,\n         strings: strings,\n     }\n }\n \n #[cfg(test)]\n-mod tests {\n+mod test {\n \n     use super::{boolnames, boolfnames, numnames, numfnames, stringnames, stringfnames};\n "}, {"sha": "e869c5083373ca4fa577e860cd40c8232d6de176", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 24, "deletions": 44, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0ee230a09453451791105670aab769464c4a9270/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee230a09453451791105670aab769464c4a9270/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=0ee230a09453451791105670aab769464c4a9270", "patch": "@@ -13,29 +13,26 @@\n //! Does not support hashed database, only filesystem!\n \n use std::env;\n-use std::fs::File;\n-use std::io::prelude::*;\n+use std::fs;\n use std::path::PathBuf;\n \n /// Return path to database entry for `term`\n #[allow(deprecated)]\n-pub fn get_dbpath_for_term(term: &str) -> Option<Box<PathBuf>> {\n-    if term.is_empty() {\n-        return None;\n-    }\n-\n-    let homedir = env::home_dir();\n-\n+pub fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n     let mut dirs_to_search = Vec::new();\n-    let first_char = term.char_at(0);\n+    let first_char = match term.chars().next() {\n+        Some(c) => c,\n+        None => return None,\n+    };\n \n     // Find search directory\n     match env::var_os(\"TERMINFO\") {\n         Some(dir) => dirs_to_search.push(PathBuf::from(dir)),\n         None => {\n-            if homedir.is_some() {\n+            if let Some(mut homedir) = env::home_dir() {\n                 // ncurses compatibility;\n-                dirs_to_search.push(homedir.unwrap().join(\".terminfo\"))\n+                homedir.push(\".terminfo\");\n+                dirs_to_search.push(homedir)\n             }\n             match env::var(\"TERMINFO_DIRS\") {\n                 Ok(dirs) => {\n@@ -61,35 +58,26 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<PathBuf>> {\n     };\n \n     // Look for the terminal in all of the search directories\n-    for p in &dirs_to_search {\n-        if p.exists() {\n-            let f = first_char.to_string();\n-            let newp = p.join(&f).join(term);\n-            if newp.exists() {\n-                return Some(box newp);\n+    for mut p in dirs_to_search {\n+        if fs::metadata(&p).is_ok() {\n+            p.push(&first_char.to_string());\n+            p.push(&term);\n+            if fs::metadata(&p).is_ok() {\n+                return Some(p);\n             }\n-            // on some installations the dir is named after the hex of the char (e.g. OS X)\n-            let f = format!(\"{:x}\", first_char as usize);\n-            let newp = p.join(&f).join(term);\n-            if newp.exists() {\n-                return Some(box newp);\n-            }\n-        }\n-    }\n-    None\n-}\n+            p.pop();\n+            p.pop();\n \n-/// Return open file for `term`\n-pub fn open(term: &str) -> Result<File, String> {\n-    match get_dbpath_for_term(term) {\n-        Some(x) => {\n-            match File::open(&*x) {\n-                Ok(file) => Ok(file),\n-                Err(e) => Err(format!(\"error opening file: {:?}\", e)),\n+            // on some installations the dir is named after the hex of the char\n+            // (e.g. OS X)\n+            p.push(&format!(\"{:x}\", first_char as usize));\n+            p.push(term);\n+            if fs::metadata(&p).is_ok() {\n+                return Some(p);\n             }\n         }\n-        None => Err(format!(\"could not find terminfo entry for {:?}\", term)),\n     }\n+    None\n }\n \n #[test]\n@@ -109,11 +97,3 @@ fn test_get_dbpath_for_term() {\n     assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n     env::remove_var(\"TERMINFO_DIRS\");\n }\n-\n-#[test]\n-#[ignore(reason = \"see test_get_dbpath_for_term\")]\n-fn test_open() {\n-    open(\"screen\").unwrap();\n-    let t = open(\"nonexistent terminal that hopefully does not exist\");\n-    assert!(t.is_err());\n-}"}, {"sha": "2cb7018669d3daacdfd212f2efc70d32cc3e004f", "filename": "src/libterm/win.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0ee230a09453451791105670aab769464c4a9270/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee230a09453451791105670aab769464c4a9270/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=0ee230a09453451791105670aab769464c4a9270", "patch": "@@ -17,9 +17,9 @@ extern crate libc;\n use std::io;\n use std::io::prelude::*;\n \n-use attr;\n+use Attr;\n use color;\n-use {Terminal, UnwrappableTerminal};\n+use Terminal;\n \n /// A Terminal implementation which uses the Win32 Console API.\n pub struct WinConsole<T> {\n@@ -115,7 +115,7 @@ impl<T: Write+Send+'static> WinConsole<T> {\n \n     /// Returns `None` whenever the terminal cannot be created for some\n     /// reason.\n-    pub fn new(out: T) -> Option<Box<Terminal<T> + Send + 'static>> {\n+    pub fn new(out: T) -> io::Result<WinConsole<T>> {\n         let fg;\n         let bg;\n         unsafe {\n@@ -128,7 +128,7 @@ impl<T: Write+Send+'static> WinConsole<T> {\n                 bg = color::BLACK;\n             }\n         }\n-        Some(box WinConsole {\n+        Ok(WinConsole {\n             buf: out,\n             def_foreground: fg,\n             def_background: bg,\n@@ -148,7 +148,9 @@ impl<T: Write> Write for WinConsole<T> {\n     }\n }\n \n-impl<T: Write+Send+'static> Terminal<T> for WinConsole<T> {\n+impl<T: Write+Send+'static> Terminal for WinConsole<T> {\n+    type Output = T;\n+\n     fn fg(&mut self, color: color::Color) -> io::Result<bool> {\n         self.foreground = color;\n         self.apply();\n@@ -163,14 +165,14 @@ impl<T: Write+Send+'static> Terminal<T> for WinConsole<T> {\n         Ok(true)\n     }\n \n-    fn attr(&mut self, attr: attr::Attr) -> io::Result<bool> {\n+    fn attr(&mut self, attr: Attr) -> io::Result<bool> {\n         match attr {\n-            attr::ForegroundColor(f) => {\n+            Attr::ForegroundColor(f) => {\n                 self.foreground = f;\n                 self.apply();\n                 Ok(true)\n             }\n-            attr::BackgroundColor(b) => {\n+            Attr::BackgroundColor(b) => {\n                 self.background = b;\n                 self.apply();\n                 Ok(true)\n@@ -179,21 +181,21 @@ impl<T: Write+Send+'static> Terminal<T> for WinConsole<T> {\n         }\n     }\n \n-    fn supports_attr(&self, attr: attr::Attr) -> bool {\n+    fn supports_attr(&self, attr: Attr) -> bool {\n         // it claims support for underscore and reverse video, but I can't get\n         // it to do anything -cmr\n         match attr {\n-            attr::ForegroundColor(_) | attr::BackgroundColor(_) => true,\n+            Attr::ForegroundColor(_) | Attr::BackgroundColor(_) => true,\n             _ => false,\n         }\n     }\n \n-    fn reset(&mut self) -> io::Result<()> {\n+    fn reset(&mut self) -> io::Result<bool> {\n         self.foreground = self.def_foreground;\n         self.background = self.def_background;\n         self.apply();\n \n-        Ok(())\n+        Ok(true)\n     }\n \n     fn get_ref<'a>(&'a self) -> &'a T {\n@@ -203,10 +205,10 @@ impl<T: Write+Send+'static> Terminal<T> for WinConsole<T> {\n     fn get_mut<'a>(&'a mut self) -> &'a mut T {\n         &mut self.buf\n     }\n-}\n \n-impl<T: Write+Send+'static> UnwrappableTerminal<T> for WinConsole<T> {\n-    fn unwrap(self) -> T {\n+    fn into_inner(self) -> T\n+        where Self: Sized\n+    {\n         self.buf\n     }\n }"}, {"sha": "71eddd80c74c84c381a15cf45e1b6cc7508dc1fd", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ee230a09453451791105670aab769464c4a9270/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee230a09453451791105670aab769464c4a9270/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=0ee230a09453451791105670aab769464c4a9270", "patch": "@@ -428,7 +428,7 @@ pub enum TestResult {\n unsafe impl Send for TestResult {}\n \n enum OutputLocation<T> {\n-    Pretty(Box<term::Terminal<term::WriterWrapper> + Send>),\n+    Pretty(Box<term::StdoutTerminal>),\n     Raw(T),\n }\n "}]}