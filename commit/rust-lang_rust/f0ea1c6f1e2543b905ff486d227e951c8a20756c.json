{"sha": "f0ea1c6f1e2543b905ff486d227e951c8a20756c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZWExYzZmMWUyNTQzYjkwNWZmNDg2ZDIyN2U5NTFjOGEyMDc1NmM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-04T22:11:59Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-18T10:51:40Z"}, "message": "resolve: Improve diagnostics for resolution ambiguities", "tree": {"sha": "3e07d994ea1cbbb79a24acb63660a9988fd62c02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e07d994ea1cbbb79a24acb63660a9988fd62c02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0ea1c6f1e2543b905ff486d227e951c8a20756c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0ea1c6f1e2543b905ff486d227e951c8a20756c", "html_url": "https://github.com/rust-lang/rust/commit/f0ea1c6f1e2543b905ff486d227e951c8a20756c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0ea1c6f1e2543b905ff486d227e951c8a20756c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d7d9ada6d108c113ea8728be97dbc19345e9892", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d7d9ada6d108c113ea8728be97dbc19345e9892", "html_url": "https://github.com/rust-lang/rust/commit/9d7d9ada6d108c113ea8728be97dbc19345e9892"}], "stats": {"total": 1030, "additions": 604, "deletions": 426}, "files": [{"sha": "c5e631ebafab1efcb48602f25b39f06f3a10c764", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -128,14 +128,6 @@ impl PathResolution {\n     pub fn unresolved_segments(&self) -> usize {\n         self.unresolved_segments\n     }\n-\n-    pub fn kind_name(&self) -> &'static str {\n-        if self.unresolved_segments != 0 {\n-            \"associated item\"\n-        } else {\n-            self.base_def.kind_name()\n-        }\n-    }\n }\n \n /// Different kinds of symbols don't influence each other.\n@@ -333,4 +325,12 @@ impl Def {\n             Def::Err => \"unresolved item\",\n         }\n     }\n+\n+    pub fn article(&self) -> &'static str {\n+        match *self {\n+            Def::AssociatedTy(..) | Def::AssociatedConst(..) | Def::AssociatedExistential(..) |\n+            Def::Enum(..) | Def::Existential(..) | Def::Err => \"an\",\n+            _ => \"a\",\n+        }\n+    }\n }"}, {"sha": "bafabe4e9972cf474ff4752f02a89107033730c1", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -298,7 +298,8 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             let label_msg = match pat.node {\n                 PatKind::Path(hir::QPath::Resolved(None, ref path))\n                         if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n-                    format!(\"interpreted as a {} pattern, not new variable\", path.def.kind_name())\n+                    format!(\"interpreted as {} {} pattern, not new variable\",\n+                            path.def.article(), path.def.kind_name())\n                 }\n                 _ => format!(\"pattern `{}` not covered\", pattern_string),\n             };"}, {"sha": "864aa7f6dc4f84e5bcee5ba75531c6d0e08abe52", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -347,6 +347,23 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 let used = self.process_legacy_macro_imports(item, module, &parent_scope);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.arenas);\n+                let directive = self.arenas.alloc_import_directive(ImportDirective {\n+                    root_id: item.id,\n+                    id: item.id,\n+                    parent_scope,\n+                    imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n+                    subclass: ImportDirectiveSubclass::ExternCrate {\n+                        source: orig_name,\n+                        target: ident,\n+                    },\n+                    root_span: item.span,\n+                    span: item.span,\n+                    module_path: Vec::new(),\n+                    vis: Cell::new(vis),\n+                    used: Cell::new(used),\n+                });\n+                self.potentially_unused_imports.push(directive);\n+                let imported_binding = self.import(binding, directive);\n                 if ptr::eq(self.current_module, self.graph_root) {\n                     if let Some(entry) = self.extern_prelude.get(&ident.modern()) {\n                         if expansion != Mark::root() && orig_name.is_some() &&\n@@ -361,28 +378,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         extern_crate_item: None,\n                         introduced_by_item: true,\n                     });\n-                    entry.extern_crate_item = Some(binding);\n+                    entry.extern_crate_item = Some(imported_binding);\n                     if orig_name.is_some() {\n                         entry.introduced_by_item = true;\n                     }\n                 }\n-                let directive = self.arenas.alloc_import_directive(ImportDirective {\n-                    root_id: item.id,\n-                    id: item.id,\n-                    parent_scope,\n-                    imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n-                    subclass: ImportDirectiveSubclass::ExternCrate {\n-                        source: orig_name,\n-                        target: ident,\n-                    },\n-                    root_span: item.span,\n-                    span: item.span,\n-                    module_path: Vec::new(),\n-                    vis: Cell::new(vis),\n-                    used: Cell::new(used),\n-                });\n-                self.potentially_unused_imports.push(directive);\n-                let imported_binding = self.import(binding, directive);\n                 self.define(parent, ident, TypeNS, imported_binding);\n             }\n "}, {"sha": "23fff0d0126f966123e407a0d2ab00c2e17f7cf8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 144, "deletions": 40, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -391,14 +391,13 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             err\n         }\n         ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, name, binding) => {\n-            let shadows_what = PathResolution::new(binding.def()).kind_name();\n-            let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0530,\n-                                           \"{}s cannot shadow {}s\", what_binding, shadows_what);\n-            err.span_label(span, format!(\"cannot be named the same as a {}\", shadows_what));\n+            let (shadows_what, article) = (binding.descr(), binding.article());\n+            let mut err = struct_span_err!(resolver.session, span, E0530, \"{}s cannot shadow {}s\",\n+                                           what_binding, shadows_what);\n+            err.span_label(span, format!(\"cannot be named the same as {} {}\",\n+                                         article, shadows_what));\n             let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n-            let msg = format!(\"a {} `{}` is {} here\", shadows_what, name, participle);\n+            let msg = format!(\"{} {} `{}` is {} here\", article, shadows_what, name, participle);\n             err.span_label(binding.span, msg);\n             err\n         }\n@@ -1195,6 +1194,7 @@ enum NameBindingKind<'a> {\n         used: Cell<bool>,\n     },\n     Ambiguity {\n+        kind: AmbiguityKind,\n         b1: &'a NameBinding<'a>,\n         b2: &'a NameBinding<'a>,\n     }\n@@ -1212,10 +1212,61 @@ struct UseError<'a> {\n     better: bool,\n }\n \n+#[derive(Clone, Copy, PartialEq, Debug)]\n+enum AmbiguityKind {\n+    Import,\n+    BuiltinAttr,\n+    DeriveHelper,\n+    LegacyHelperVsPrelude,\n+    LegacyVsModern,\n+    GlobVsOuter,\n+    GlobVsGlob,\n+    GlobVsExpanded,\n+    MoreExpandedVsOuter,\n+}\n+\n+impl AmbiguityKind {\n+    fn descr(self) -> &'static str {\n+        match self {\n+            AmbiguityKind::Import =>\n+                \"name vs any other name during import resolution\",\n+            AmbiguityKind::BuiltinAttr =>\n+                \"built-in attribute vs any other name\",\n+            AmbiguityKind::DeriveHelper =>\n+                \"derive helper attribute vs any other name\",\n+            AmbiguityKind::LegacyHelperVsPrelude =>\n+                \"legacy plugin helper attribute vs name from prelude\",\n+            AmbiguityKind::LegacyVsModern =>\n+                \"`macro_rules` vs non-`macro_rules` from other module\",\n+            AmbiguityKind::GlobVsOuter =>\n+                \"glob import vs any other name from outer scope during import/macro resolution\",\n+            AmbiguityKind::GlobVsGlob =>\n+                \"glob import vs glob import in the same module\",\n+            AmbiguityKind::GlobVsExpanded =>\n+                \"glob import vs macro-expanded name in the same \\\n+                 module during import/macro resolution\",\n+            AmbiguityKind::MoreExpandedVsOuter =>\n+                \"macro-expanded name vs less macro-expanded name \\\n+                 from outer scope during import/macro resolution\",\n+        }\n+    }\n+}\n+\n+/// Miscellaneous bits of metadata for better ambiguity error reporting.\n+#[derive(Clone, Copy, PartialEq)]\n+enum AmbiguityErrorMisc {\n+    SuggestSelf,\n+    FromPrelude,\n+    None,\n+}\n+\n struct AmbiguityError<'a> {\n+    kind: AmbiguityKind,\n     ident: Ident,\n     b1: &'a NameBinding<'a>,\n     b2: &'a NameBinding<'a>,\n+    misc1: AmbiguityErrorMisc,\n+    misc2: AmbiguityErrorMisc,\n }\n \n impl<'a> NameBinding<'a> {\n@@ -1268,6 +1319,9 @@ impl<'a> NameBinding<'a> {\n                     subclass: ImportDirectiveSubclass::ExternCrate { .. }, ..\n                 }, ..\n             } => true,\n+            NameBindingKind::Module(\n+                &ModuleData { kind: ModuleKind::Def(Def::Mod(def_id), _), .. }\n+            ) => def_id.index == CRATE_DEF_INDEX,\n             _ => false,\n         }\n     }\n@@ -1313,6 +1367,10 @@ impl<'a> NameBinding<'a> {\n         if self.is_extern_crate() { \"extern crate\" } else { self.def().kind_name() }\n     }\n \n+    fn article(&self) -> &'static str {\n+        if self.is_extern_crate() { \"an\" } else { self.def().article() }\n+    }\n+\n     // Suppose that we resolved macro invocation with `invoc_parent_expansion` to binding `binding`\n     // at some expansion round `max(invoc, binding)` when they both emerged from macros.\n     // Then this function returns `true` if `self` may emerge from a macro *after* that\n@@ -1885,8 +1943,12 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 self.record_use(ident, ns, binding)\n             }\n             NameBindingKind::Import { .. } => false,\n-            NameBindingKind::Ambiguity { b1, b2 } => {\n-                self.ambiguity_errors.push(AmbiguityError { ident, b1, b2 });\n+            NameBindingKind::Ambiguity { kind, b1, b2 } => {\n+                self.ambiguity_errors.push(AmbiguityError {\n+                    kind, ident, b1, b2,\n+                    misc1: AmbiguityErrorMisc::None,\n+                    misc2: AmbiguityErrorMisc::None,\n+                });\n                 true\n             }\n             _ => false\n@@ -2024,7 +2086,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n             if ns == TypeNS && is_known_tool(ident.name) {\n                 let binding = (Def::ToolMod, ty::Visibility::Public,\n-                               ident.span, Mark::root()).to_name_binding(self.arenas);\n+                               DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n                 return Some(LexicalScopeBinding::Item(binding));\n             }\n             if let Some(prelude) = self.prelude {\n@@ -4631,37 +4693,79 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         }\n     }\n \n-    fn report_ambiguity_error(&self, ident: Ident, b1: &NameBinding, b2: &NameBinding) {\n-        let participle = |is_import: bool| if is_import { \"imported\" } else { \"defined\" };\n-        let msg1 =\n-            format!(\"`{}` could refer to the name {} here\", ident, participle(b1.is_import()));\n-        let msg2 =\n-            format!(\"`{}` could also refer to the name {} here\", ident, participle(b2.is_import()));\n-        let note = if b1.expansion != Mark::root() {\n-            Some(if let Def::Macro(..) = b1.def() {\n-                format!(\"macro-expanded {} do not shadow\",\n-                        if b1.is_import() { \"macro imports\" } else { \"macros\" })\n-            } else {\n-                format!(\"macro-expanded {} do not shadow when used in a macro invocation path\",\n-                        if b1.is_import() { \"imports\" } else { \"items\" })\n-            })\n-        } else if b1.is_glob_import() {\n-            Some(format!(\"consider adding an explicit import of `{}` to disambiguate\", ident))\n+    fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError) {\n+        let AmbiguityError { kind, ident, b1, b2, misc1, misc2 } = *ambiguity_error;\n+        let (b1, b2, misc1, misc2, swapped) = if b2.span.is_dummy() && !b1.span.is_dummy() {\n+            // We have to print the span-less alternative first, otherwise formatting looks bad.\n+            (b2, b1, misc2, misc1, true)\n         } else {\n-            None\n+            (b1, b2, misc1, misc2, false)\n         };\n \n-        let mut err = struct_span_err!(self.session, ident.span, E0659, \"`{}` is ambiguous\", ident);\n+        let mut err = struct_span_err!(self.session, ident.span, E0659,\n+                                       \"`{ident}` is ambiguous ({why})\",\n+                                       ident = ident, why = kind.descr());\n         err.span_label(ident.span, \"ambiguous name\");\n-        err.span_note(b1.span, &msg1);\n-        match b2.def() {\n-            Def::Macro(..) if b2.span.is_dummy() =>\n-                err.note(&format!(\"`{}` is also a builtin macro\", ident)),\n-            _ => err.span_note(b2.span, &msg2),\n+\n+        let mut could_refer_to = |b: &NameBinding, misc: AmbiguityErrorMisc, also: &str| {\n+            let what = if b.span.is_dummy() {\n+                let add_built_in = match b.def() {\n+                    // These already contain the \"built-in\" prefix or look bad with it.\n+                    Def::NonMacroAttr(..) | Def::PrimTy(..) | Def::ToolMod => false,\n+                    _ => true,\n+                };\n+                let (built_in, from) = if misc == AmbiguityErrorMisc::FromPrelude {\n+                    (\"\", \" from prelude\")\n+                } else if b.is_extern_crate() && !b.is_import() &&\n+                          self.session.opts.externs.get(&ident.as_str()).is_some() {\n+                    (\"\", \" passed with `--extern`\")\n+                } else if add_built_in {\n+                    (\" built-in\", \"\")\n+                } else {\n+                    (\"\", \"\")\n+                };\n+\n+                let article = if built_in.is_empty() { b.article() } else { \"a\" };\n+                format!(\"{a}{built_in} {thing}{from}\",\n+                        a = article, thing = b.descr(), built_in = built_in, from = from)\n+            } else {\n+                let participle = if b.is_import() { \"imported\" } else { \"defined\" };\n+                format!(\"the {thing} {introduced} here\",\n+                        thing = b.descr(), introduced = participle)\n+            };\n+            let note_msg = format!(\"`{ident}` could{also} refer to {what}\",\n+                                   ident = ident, also = also, what = what);\n+\n+            let mut help_msgs = Vec::new();\n+            if b.is_glob_import() && (kind == AmbiguityKind::GlobVsGlob ||\n+                                      kind == AmbiguityKind::GlobVsExpanded ||\n+                                      kind == AmbiguityKind::GlobVsOuter &&\n+                                      swapped != also.is_empty()) {\n+                help_msgs.push(format!(\"consider adding an explicit import of \\\n+                                        `{ident}` to disambiguate\", ident = ident))\n+            }\n+            if b.is_extern_crate() && self.session.rust_2018() {\n+                help_msgs.push(format!(\"use `::{ident}` to refer to the {thing} unambiguously\",\n+                                       ident = ident, thing = b.descr()))\n+            }\n+            if misc == AmbiguityErrorMisc::SuggestSelf {\n+                help_msgs.push(format!(\"use `self::{ident}` to refer to the {thing} unambiguously\",\n+                                       ident = ident, thing = b.descr()))\n+            }\n+\n+            if b.span.is_dummy() {\n+                err.note(&note_msg);\n+            } else {\n+                err.span_note(b.span, &note_msg);\n+            }\n+            for (i, help_msg) in help_msgs.iter().enumerate() {\n+                let or = if i == 0 { \"\" } else { \"or \" };\n+                err.help(&format!(\"{}{}\", or, help_msg));\n+            }\n         };\n-        if let Some(note) = note {\n-            err.note(&note);\n-        }\n+\n+        could_refer_to(b1, misc1, \"\");\n+        could_refer_to(b2, misc2, \" also\");\n         err.emit();\n     }\n \n@@ -4680,9 +4784,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             );\n         }\n \n-        for &AmbiguityError { ident, b1, b2 } in &self.ambiguity_errors {\n-            if reported_spans.insert(ident.span) {\n-                self.report_ambiguity_error(ident, b1, b2);\n+        for ambiguity_error in &self.ambiguity_errors {\n+            if reported_spans.insert(ambiguity_error.ident.span) {\n+                self.report_ambiguity_error(ambiguity_error);\n             }\n         }\n \n@@ -4860,7 +4964,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 };\n                 let crate_root = self.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX });\n                 self.populate_module_if_necessary(&crate_root);\n-                Some((crate_root, ty::Visibility::Public, ident.span, Mark::root())\n+                Some((crate_root, ty::Visibility::Public, DUMMY_SP, Mark::root())\n                     .to_name_binding(self.arenas))\n             }\n         })"}, {"sha": "e38ffaca324b8beb6b107ec79cbced115c9eeed1", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 81, "deletions": 41, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {AmbiguityError, CrateLint, Resolver, ResolutionError, is_known_tool, resolve_error};\n-use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, Segment, ToNameBinding};\n+use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n+use {CrateLint, Resolver, ResolutionError, is_known_tool, resolve_error};\n+use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, ToNameBinding};\n use ModuleOrUniformRoot;\n use Namespace::{self, *};\n use build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n@@ -597,10 +598,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         bitflags! {\n             struct Flags: u8 {\n-                const DERIVE_HELPERS = 1 << 0;\n-                const MACRO_RULES    = 1 << 1;\n-                const MODULE         = 1 << 2;\n-                const PRELUDE        = 1 << 3;\n+                const MACRO_RULES       = 1 << 0;\n+                const MODULE            = 1 << 1;\n+                const PRELUDE           = 1 << 2;\n+                const MISC_SUGGEST_SELF = 1 << 3;\n+                const MISC_FROM_PRELUDE = 1 << 4;\n             }\n         }\n \n@@ -619,7 +621,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // }\n         // So we have to save the innermost solution and continue searching in outer scopes\n         // to detect potential ambiguities.\n-        let mut innermost_result: Option<(&NameBinding, Flags, /* conflicts with */ Flags)> = None;\n+        let mut innermost_result: Option<(&NameBinding, Flags)> = None;\n \n         // Go through all the scopes and try to resolve the name.\n         let mut where_to_resolve = WhereToResolve::DeriveHelpers;\n@@ -638,7 +640,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                         (Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n                                         ty::Visibility::Public, derive.span, Mark::root())\n                                         .to_name_binding(self.arenas);\n-                                    result = Ok((binding, Flags::DERIVE_HELPERS, Flags::all()));\n+                                    result = Ok((binding, Flags::empty()));\n                                     break;\n                                 }\n                             }\n@@ -648,7 +650,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 }\n                 WhereToResolve::MacroRules(legacy_scope) => match legacy_scope {\n                     LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n-                        Ok((legacy_binding.binding, Flags::MACRO_RULES, Flags::empty())),\n+                        Ok((legacy_binding.binding, Flags::MACRO_RULES)),\n                     _ => Err(Determinacy::Determined),\n                 }\n                 WhereToResolve::Module(module) => {\n@@ -662,29 +664,34 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         path_span,\n                     );\n                     self.current_module = orig_current_module;\n-                    binding.map(|binding| (binding, Flags::MODULE, Flags::empty()))\n+                    let misc_flags = if module.is_normal() {\n+                        Flags::MISC_SUGGEST_SELF\n+                    } else {\n+                        Flags::empty()\n+                    };\n+                    binding.map(|binding| (binding, Flags::MODULE | misc_flags))\n                 }\n                 WhereToResolve::MacroUsePrelude => {\n                     let mut result = Err(Determinacy::Determined);\n                     if use_prelude || self.session.rust_2015() {\n                         if let Some(binding) = self.macro_use_prelude.get(&ident.name).cloned() {\n-                            result = Ok((binding, Flags::PRELUDE, Flags::empty()));\n+                            result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n                         }\n                     }\n                     result\n                 }\n                 WhereToResolve::BuiltinMacros => {\n                     match self.builtin_macros.get(&ident.name).cloned() {\n-                        Some(binding) => Ok((binding, Flags::PRELUDE, Flags::empty())),\n+                        Some(binding) => Ok((binding, Flags::PRELUDE)),\n                         None => Err(Determinacy::Determined),\n                     }\n                 }\n                 WhereToResolve::BuiltinAttrs => {\n                     if is_builtin_attr_name(ident.name) {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),\n-                                       ty::Visibility::Public, ident.span, Mark::root())\n+                                       ty::Visibility::Public, DUMMY_SP, Mark::root())\n                                        .to_name_binding(self.arenas);\n-                        Ok((binding, Flags::PRELUDE, Flags::all()))\n+                        Ok((binding, Flags::PRELUDE))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -694,9 +701,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                        self.session.plugin_attributes.borrow().iter()\n                                                      .any(|(name, _)| ident.name == &**name) {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper),\n-                                       ty::Visibility::Public, ident.span, Mark::root())\n+                                       ty::Visibility::Public, DUMMY_SP, Mark::root())\n                                        .to_name_binding(self.arenas);\n-                        Ok((binding, Flags::PRELUDE, Flags::PRELUDE))\n+                        Ok((binding, Flags::PRELUDE))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -706,16 +713,16 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     if use_prelude {\n                         if let Some(binding) = self.extern_prelude_get(ident, !record_used,\n                                                                        innermost_result.is_some()) {\n-                            result = Ok((binding, Flags::PRELUDE, Flags::empty()));\n+                            result = Ok((binding, Flags::PRELUDE));\n                         }\n                     }\n                     result\n                 }\n                 WhereToResolve::ToolPrelude => {\n                     if use_prelude && is_known_tool(ident.name) {\n                         let binding = (Def::ToolMod, ty::Visibility::Public,\n-                                       ident.span, Mark::root()).to_name_binding(self.arenas);\n-                        Ok((binding, Flags::PRELUDE, Flags::empty()))\n+                                       DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n+                        Ok((binding, Flags::PRELUDE))\n                     } else {\n                         Err(Determinacy::Determined)\n                     }\n@@ -732,7 +739,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                 false,\n                                 path_span,\n                             ) {\n-                                result = Ok((binding, Flags::PRELUDE, Flags::empty()));\n+                                result = Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE));\n                             }\n                         }\n                     }\n@@ -742,8 +749,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     match self.primitive_type_table.primitive_types.get(&ident.name).cloned() {\n                         Some(prim_ty) => {\n                             let binding = (Def::PrimTy(prim_ty), ty::Visibility::Public,\n-                                           ident.span, Mark::root()).to_name_binding(self.arenas);\n-                            Ok((binding, Flags::PRELUDE, Flags::empty()))\n+                                           DUMMY_SP, Mark::root()).to_name_binding(self.arenas);\n+                            Ok((binding, Flags::PRELUDE))\n                         }\n                         None => Err(Determinacy::Determined)\n                     }\n@@ -793,7 +800,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }}\n \n             match result {\n-                Ok((binding, flags, ambig_flags)) => {\n+                Ok((binding, flags)) => {\n                     if sub_namespace_mismatch(macro_kind, binding.macro_kind()) {\n                         continue_search!();\n                     }\n@@ -802,28 +809,61 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         return Ok(binding);\n                     }\n \n-                    if let Some((innermost_binding, innermost_flags, innermost_ambig_flags))\n-                            = innermost_result {\n+                    if let Some((innermost_binding, innermost_flags)) = innermost_result {\n                         // Found another solution, if the first one was \"weak\", report an error.\n-                        if binding.def() != innermost_binding.def() &&\n-                           (is_import ||\n-                            innermost_binding.is_glob_import() ||\n-                            innermost_binding.may_appear_after(parent_scope.expansion, binding) ||\n-                            innermost_flags.intersects(ambig_flags) ||\n-                            flags.intersects(innermost_ambig_flags) ||\n-                            (innermost_flags.contains(Flags::MACRO_RULES) &&\n-                             flags.contains(Flags::MODULE) &&\n-                             !self.disambiguate_legacy_vs_modern(innermost_binding, binding))) {\n-                            self.ambiguity_errors.push(AmbiguityError {\n-                                ident,\n-                                b1: innermost_binding,\n-                                b2: binding,\n-                            });\n-                            return Ok(innermost_binding);\n+                        let (def, innermost_def) = (binding.def(), innermost_binding.def());\n+                        if def != innermost_def {\n+                            let builtin = Def::NonMacroAttr(NonMacroAttrKind::Builtin);\n+                            let derive_helper = Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n+                            let legacy_helper =\n+                                Def::NonMacroAttr(NonMacroAttrKind::LegacyPluginHelper);\n+\n+                            let ambiguity_error_kind = if is_import {\n+                                Some(AmbiguityKind::Import)\n+                            } else if innermost_def == builtin || def == builtin {\n+                                Some(AmbiguityKind::BuiltinAttr)\n+                            } else if innermost_def == derive_helper || def == derive_helper {\n+                                Some(AmbiguityKind::DeriveHelper)\n+                            } else if innermost_def == legacy_helper &&\n+                                      flags.contains(Flags::PRELUDE) ||\n+                                      def == legacy_helper &&\n+                                      innermost_flags.contains(Flags::PRELUDE) {\n+                                Some(AmbiguityKind::LegacyHelperVsPrelude)\n+                            } else if innermost_flags.contains(Flags::MACRO_RULES) &&\n+                                      flags.contains(Flags::MODULE) &&\n+                                      !self.disambiguate_legacy_vs_modern(innermost_binding,\n+                                                                          binding) {\n+                                Some(AmbiguityKind::LegacyVsModern)\n+                            } else if innermost_binding.is_glob_import() {\n+                                Some(AmbiguityKind::GlobVsOuter)\n+                            } else if innermost_binding.may_appear_after(parent_scope.expansion,\n+                                                                         binding) {\n+                                Some(AmbiguityKind::MoreExpandedVsOuter)\n+                            } else {\n+                                None\n+                            };\n+                            if let Some(kind) = ambiguity_error_kind {\n+                                let misc = |f: Flags| if f.contains(Flags::MISC_SUGGEST_SELF) {\n+                                    AmbiguityErrorMisc::SuggestSelf\n+                                } else if f.contains(Flags::MISC_FROM_PRELUDE) {\n+                                    AmbiguityErrorMisc::FromPrelude\n+                                } else {\n+                                    AmbiguityErrorMisc::None\n+                                };\n+                                self.ambiguity_errors.push(AmbiguityError {\n+                                    kind,\n+                                    ident,\n+                                    b1: innermost_binding,\n+                                    b2: binding,\n+                                    misc1: misc(innermost_flags),\n+                                    misc2: misc(flags),\n+                                });\n+                                return Ok(innermost_binding);\n+                            }\n                         }\n                     } else {\n                         // Found the first solution.\n-                        innermost_result = Some((binding, flags, ambig_flags));\n+                        innermost_result = Some((binding, flags));\n                     }\n \n                     continue_search!();"}, {"sha": "890655c398c3d81abe01aee718d85bb979f9d6bf", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -10,7 +10,8 @@\n \n use self::ImportDirectiveSubclass::*;\n \n-use {AmbiguityError, CrateLint, Module, ModuleOrUniformRoot, PerNS};\n+use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n+use {CrateLint, Module, ModuleOrUniformRoot, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use {Resolver, Segment};\n@@ -219,7 +220,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 };\n                 self.populate_module_if_necessary(crate_root);\n                 let binding = (crate_root, ty::Visibility::Public,\n-                               ident.span, Mark::root()).to_name_binding(self.arenas);\n+                               crate_root.span, Mark::root()).to_name_binding(self.arenas);\n                 return Ok(binding);\n             }\n         };\n@@ -244,12 +245,14 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                     // Forbid expanded shadowing to avoid time travel.\n                     if restricted_shadowing &&\n                        binding.expansion != Mark::root() &&\n-                       ns != MacroNS && // In MacroNS, `try_define` always forbids this shadowing\n                        binding.def() != shadowed_glob.def() {\n                         self.ambiguity_errors.push(AmbiguityError {\n+                            kind: AmbiguityKind::GlobVsExpanded,\n                             ident,\n                             b1: binding,\n                             b2: shadowed_glob,\n+                            misc1: AmbiguityErrorMisc::None,\n+                            misc2: AmbiguityErrorMisc::None,\n                         });\n                     }\n                 }\n@@ -471,38 +474,48 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         self.set_binding_parent_module(binding, module);\n         self.update_resolution(module, ident, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n-                if binding.is_glob_import() {\n-                    if !old_binding.is_glob_import() &&\n-                       !(ns == MacroNS && old_binding.expansion != Mark::root()) {\n-                        resolution.shadowed_glob = Some(binding);\n-                    } else if binding.def() != old_binding.def() {\n-                        resolution.binding = Some(this.ambiguity(old_binding, binding));\n-                    } else if !old_binding.vis.is_at_least(binding.vis, &*this) {\n-                        // We are glob-importing the same item but with greater visibility.\n-                        resolution.binding = Some(binding);\n+                match (old_binding.is_glob_import(), binding.is_glob_import()) {\n+                    (true, true) => {\n+                        if binding.def() != old_binding.def() {\n+                            resolution.binding = Some(this.ambiguity(AmbiguityKind::GlobVsGlob,\n+                                                                     old_binding, binding));\n+                        } else if !old_binding.vis.is_at_least(binding.vis, &*this) {\n+                            // We are glob-importing the same item but with greater visibility.\n+                            resolution.binding = Some(binding);\n+                        }\n                     }\n-                } else if old_binding.is_glob_import() {\n-                    if ns == MacroNS && binding.expansion != Mark::root() &&\n-                       binding.def() != old_binding.def() {\n-                        resolution.binding = Some(this.ambiguity(binding, old_binding));\n-                    } else {\n-                        resolution.binding = Some(binding);\n-                        resolution.shadowed_glob = Some(old_binding);\n+                    (old_glob @ true, false) | (old_glob @ false, true) => {\n+                        let (glob_binding, nonglob_binding) = if old_glob {\n+                            (old_binding, binding)\n+                        } else {\n+                            (binding, old_binding)\n+                        };\n+                        if glob_binding.def() != nonglob_binding.def() &&\n+                           ns == MacroNS && nonglob_binding.expansion != Mark::root() {\n+                            resolution.binding = Some(this.ambiguity(AmbiguityKind::GlobVsExpanded,\n+                                                                    nonglob_binding, glob_binding));\n+                        } else {\n+                            resolution.binding = Some(nonglob_binding);\n+                            resolution.shadowed_glob = Some(glob_binding);\n+                        }\n+                    }\n+                    (false, false) => {\n+                        if let (&NameBindingKind::Def(_, true), &NameBindingKind::Def(_, true)) =\n+                               (&old_binding.kind, &binding.kind) {\n+\n+                            this.session.buffer_lint_with_diagnostic(\n+                                DUPLICATE_MACRO_EXPORTS,\n+                                CRATE_NODE_ID,\n+                                binding.span,\n+                                &format!(\"a macro named `{}` has already been exported\", ident),\n+                                BuiltinLintDiagnostics::DuplicatedMacroExports(\n+                                    ident, old_binding.span, binding.span));\n+\n+                            resolution.binding = Some(binding);\n+                        } else {\n+                            return Err(old_binding);\n+                        }\n                     }\n-                } else if let (&NameBindingKind::Def(_, true), &NameBindingKind::Def(_, true)) =\n-                        (&old_binding.kind, &binding.kind) {\n-\n-                    this.session.buffer_lint_with_diagnostic(\n-                        DUPLICATE_MACRO_EXPORTS,\n-                        CRATE_NODE_ID,\n-                        binding.span,\n-                        &format!(\"a macro named `{}` has already been exported\", ident),\n-                        BuiltinLintDiagnostics::DuplicatedMacroExports(\n-                            ident, old_binding.span, binding.span));\n-\n-                    resolution.binding = Some(binding);\n-                } else {\n-                    return Err(old_binding);\n                 }\n             } else {\n                 resolution.binding = Some(binding);\n@@ -512,10 +525,10 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         })\n     }\n \n-    pub fn ambiguity(&self, b1: &'a NameBinding<'a>, b2: &'a NameBinding<'a>)\n+    fn ambiguity(&self, kind: AmbiguityKind, b1: &'a NameBinding<'a>, b2: &'a NameBinding<'a>)\n                      -> &'a NameBinding<'a> {\n         self.arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Ambiguity { b1, b2 },\n+            kind: NameBindingKind::Ambiguity { kind, b1, b2 },\n             vis: if b1.vis.is_at_least(b2.vis, self) { b1.vis } else { b2.vis },\n             span: b1.span,\n             expansion: Mark::root(),"}, {"sha": "fc55dc1eef67a967d5818169aaaeff6bd34f612e", "filename": "src/test/ui-fulldeps/custom-derive/helper-attr-blocked-by-import-ambig.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,19 +1,20 @@\n-error[E0659]: `helper` is ambiguous\n+error[E0659]: `helper` is ambiguous (derive helper attribute vs any other name)\n   --> $DIR/helper-attr-blocked-by-import-ambig.rs:10:3\n    |\n LL | #[helper] //~ ERROR `helper` is ambiguous\n    |   ^^^^^^ ambiguous name\n    |\n-note: `helper` could refer to the name defined here\n+note: `helper` could refer to the derive helper attribute defined here\n   --> $DIR/helper-attr-blocked-by-import-ambig.rs:9:10\n    |\n LL | #[derive(WithHelper)]\n    |          ^^^^^^^^^^\n-note: `helper` could also refer to the name imported here\n+note: `helper` could also refer to the attribute macro imported here\n   --> $DIR/helper-attr-blocked-by-import-ambig.rs:7:5\n    |\n LL | use plugin::helper;\n    |     ^^^^^^^^^^^^^^\n+   = help: use `self::helper` to refer to the attribute macro unambiguously\n \n error: aborting due to previous error\n "}, {"sha": "00f5cfc2613a087427c5f969d9682b7b45e922ee", "filename": "src/test/ui-fulldeps/proc-macro/ambiguous-builtin-attrs.stderr", "status": "modified", "additions": 20, "deletions": 40, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fambiguous-builtin-attrs.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -4,95 +4,75 @@ error[E0425]: cannot find value `NonExistent` in this scope\n LL |     NonExistent; //~ ERROR cannot find value `NonExistent` in this scope\n    |     ^^^^^^^^^^^ not found in this scope\n \n-error[E0659]: `repr` is ambiguous\n+error[E0659]: `repr` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:9:3\n    |\n LL | #[repr(C)] //~ ERROR `repr` is ambiguous\n    |   ^^^^ ambiguous name\n    |\n-note: `repr` could refer to the name imported here\n+   = note: `repr` could refer to a built-in attribute\n+note: `repr` could also refer to the attribute macro imported here\n   --> $DIR/ambiguous-builtin-attrs.rs:7:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-note: `repr` could also refer to the name defined here\n-  --> $DIR/ambiguous-builtin-attrs.rs:9:3\n-   |\n-LL | #[repr(C)] //~ ERROR `repr` is ambiguous\n-   |   ^^^^\n-   = note: consider adding an explicit import of `repr` to disambiguate\n+   = help: use `self::repr` to refer to the attribute macro unambiguously\n \n-error[E0659]: `repr` is ambiguous\n+error[E0659]: `repr` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:11:19\n    |\n LL | #[cfg_attr(all(), repr(C))] //~ ERROR `repr` is ambiguous\n    |                   ^^^^ ambiguous name\n    |\n-note: `repr` could refer to the name imported here\n+   = note: `repr` could refer to a built-in attribute\n+note: `repr` could also refer to the attribute macro imported here\n   --> $DIR/ambiguous-builtin-attrs.rs:7:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-note: `repr` could also refer to the name defined here\n-  --> $DIR/ambiguous-builtin-attrs.rs:11:19\n-   |\n-LL | #[cfg_attr(all(), repr(C))] //~ ERROR `repr` is ambiguous\n-   |                   ^^^^\n-   = note: consider adding an explicit import of `repr` to disambiguate\n+   = help: use `self::repr` to refer to the attribute macro unambiguously\n \n-error[E0659]: `repr` is ambiguous\n+error[E0659]: `repr` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:20:34\n    |\n LL | fn non_macro_expanded_location<#[repr(C)] T>() { //~ ERROR `repr` is ambiguous\n    |                                  ^^^^ ambiguous name\n    |\n-note: `repr` could refer to the name imported here\n+   = note: `repr` could refer to a built-in attribute\n+note: `repr` could also refer to the attribute macro imported here\n   --> $DIR/ambiguous-builtin-attrs.rs:7:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-note: `repr` could also refer to the name defined here\n-  --> $DIR/ambiguous-builtin-attrs.rs:20:34\n-   |\n-LL | fn non_macro_expanded_location<#[repr(C)] T>() { //~ ERROR `repr` is ambiguous\n-   |                                  ^^^^\n-   = note: consider adding an explicit import of `repr` to disambiguate\n+   = help: use `self::repr` to refer to the attribute macro unambiguously\n \n-error[E0659]: `repr` is ambiguous\n+error[E0659]: `repr` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:22:11\n    |\n LL |         #[repr(C)] //~ ERROR `repr` is ambiguous\n    |           ^^^^ ambiguous name\n    |\n-note: `repr` could refer to the name imported here\n+   = note: `repr` could refer to a built-in attribute\n+note: `repr` could also refer to the attribute macro imported here\n   --> $DIR/ambiguous-builtin-attrs.rs:7:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-note: `repr` could also refer to the name defined here\n-  --> $DIR/ambiguous-builtin-attrs.rs:22:11\n-   |\n-LL |         #[repr(C)] //~ ERROR `repr` is ambiguous\n-   |           ^^^^\n-   = note: consider adding an explicit import of `repr` to disambiguate\n+   = help: use `self::repr` to refer to the attribute macro unambiguously\n \n-error[E0659]: `feature` is ambiguous\n+error[E0659]: `feature` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:3:4\n    |\n LL | #![feature(decl_macro)] //~ ERROR `feature` is ambiguous\n    |    ^^^^^^^ ambiguous name\n    |\n-note: `feature` could refer to the name imported here\n+   = note: `feature` could refer to a built-in attribute\n+note: `feature` could also refer to the attribute macro imported here\n   --> $DIR/ambiguous-builtin-attrs.rs:7:5\n    |\n LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n-note: `feature` could also refer to the name defined here\n-  --> $DIR/ambiguous-builtin-attrs.rs:3:4\n-   |\n-LL | #![feature(decl_macro)] //~ ERROR `feature` is ambiguous\n-   |    ^^^^^^^\n-   = note: consider adding an explicit import of `feature` to disambiguate\n+   = help: use `self::feature` to refer to the attribute macro unambiguously\n \n error: aborting due to 6 previous errors\n "}, {"sha": "4950b016d37669799849afd78b17f2b759350b8c", "filename": "src/test/ui-fulldeps/proc-macro/derive-helper-shadowing.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,19 +1,20 @@\n-error[E0659]: `my_attr` is ambiguous\n+error[E0659]: `my_attr` is ambiguous (derive helper attribute vs any other name)\n   --> $DIR/derive-helper-shadowing.rs:6:3\n    |\n LL | #[my_attr] //~ ERROR `my_attr` is ambiguous\n    |   ^^^^^^^ ambiguous name\n    |\n-note: `my_attr` could refer to the name defined here\n+note: `my_attr` could refer to the derive helper attribute defined here\n   --> $DIR/derive-helper-shadowing.rs:7:10\n    |\n LL | #[derive(MyTrait)]\n    |          ^^^^^^^\n-note: `my_attr` could also refer to the name imported here\n+note: `my_attr` could also refer to the attribute macro imported here\n   --> $DIR/derive-helper-shadowing.rs:4:5\n    |\n LL | use derive_helper_shadowing::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `self::my_attr` to refer to the attribute macro unambiguously\n \n error: aborting due to previous error\n "}, {"sha": "7bfe159405beae19a5a1c6417aadd8ffe2662198", "filename": "src/test/ui/error-codes/E0659.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Ferror-codes%2FE0659.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Ferror-codes%2FE0659.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0659.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,20 +1,21 @@\n-error[E0659]: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous (glob import vs glob import in the same module)\n   --> $DIR/E0659.rs:25:15\n    |\n LL |     collider::foo(); //~ ERROR E0659\n    |               ^^^ ambiguous name\n    |\n-note: `foo` could refer to the name imported here\n+note: `foo` could refer to the function imported here\n   --> $DIR/E0659.rs:20:13\n    |\n LL |     pub use moon::*;\n    |             ^^^^^^^\n-note: `foo` could also refer to the name imported here\n+   = help: consider adding an explicit import of `foo` to disambiguate\n+note: `foo` could also refer to the function imported here\n   --> $DIR/E0659.rs:21:13\n    |\n LL |     pub use earth::*;\n    |             ^^^^^^^^\n-   = note: consider adding an explicit import of `foo` to disambiguate\n+   = help: consider adding an explicit import of `foo` to disambiguate\n \n error: aborting due to previous error\n "}, {"sha": "f53ba9cd5de8ea5b2c30d7ca1f4baed749096f7d", "filename": "src/test/ui/imports/duplicate.stderr", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fduplicate.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -12,77 +12,81 @@ help: you can use `as` to change the binding name of the import\n LL |     use a::foo as other_foo; //~ ERROR the name `foo` is defined multiple times\n    |         ^^^^^^^^^^^^^^^^^^^\n \n-error[E0659]: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous (glob import vs glob import in the same module)\n   --> $DIR/duplicate.rs:56:15\n    |\n LL |     use self::foo::bar; //~ ERROR `foo` is ambiguous\n    |               ^^^ ambiguous name\n    |\n-note: `foo` could refer to the name imported here\n+note: `foo` could refer to the module imported here\n   --> $DIR/duplicate.rs:53:9\n    |\n LL |     use self::m1::*;\n    |         ^^^^^^^^^^^\n-note: `foo` could also refer to the name imported here\n+   = help: consider adding an explicit import of `foo` to disambiguate\n+note: `foo` could also refer to the module imported here\n   --> $DIR/duplicate.rs:54:9\n    |\n LL |     use self::m2::*;\n    |         ^^^^^^^^^^^\n-   = note: consider adding an explicit import of `foo` to disambiguate\n+   = help: consider adding an explicit import of `foo` to disambiguate\n \n-error[E0659]: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous (glob import vs glob import in the same module)\n   --> $DIR/duplicate.rs:45:8\n    |\n LL |     f::foo(); //~ ERROR `foo` is ambiguous\n    |        ^^^ ambiguous name\n    |\n-note: `foo` could refer to the name imported here\n+note: `foo` could refer to the function imported here\n   --> $DIR/duplicate.rs:34:13\n    |\n LL |     pub use a::*;\n    |             ^^^^\n-note: `foo` could also refer to the name imported here\n+   = help: consider adding an explicit import of `foo` to disambiguate\n+note: `foo` could also refer to the function imported here\n   --> $DIR/duplicate.rs:35:13\n    |\n LL |     pub use b::*;\n    |             ^^^^\n-   = note: consider adding an explicit import of `foo` to disambiguate\n+   = help: consider adding an explicit import of `foo` to disambiguate\n \n-error[E0659]: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous (glob import vs glob import in the same module)\n   --> $DIR/duplicate.rs:46:8\n    |\n LL |     g::foo(); //~ ERROR `foo` is ambiguous\n    |        ^^^ ambiguous name\n    |\n-note: `foo` could refer to the name imported here\n+note: `foo` could refer to the function imported here\n   --> $DIR/duplicate.rs:39:13\n    |\n LL |     pub use a::*;\n    |             ^^^^\n-note: `foo` could also refer to the name imported here\n+   = help: consider adding an explicit import of `foo` to disambiguate\n+note: `foo` could also refer to the unresolved item imported here\n   --> $DIR/duplicate.rs:40:13\n    |\n LL |     pub use f::*;\n    |             ^^^^\n-   = note: consider adding an explicit import of `foo` to disambiguate\n+   = help: consider adding an explicit import of `foo` to disambiguate\n \n-error[E0659]: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous (glob import vs glob import in the same module)\n   --> $DIR/duplicate.rs:59:9\n    |\n LL |         foo::bar(); //~ ERROR `foo` is ambiguous\n    |         ^^^ ambiguous name\n    |\n-note: `foo` could refer to the name imported here\n+note: `foo` could refer to the module imported here\n   --> $DIR/duplicate.rs:53:9\n    |\n LL |     use self::m1::*;\n    |         ^^^^^^^^^^^\n-note: `foo` could also refer to the name imported here\n+   = help: consider adding an explicit import of `foo` to disambiguate\n+note: `foo` could also refer to the module imported here\n   --> $DIR/duplicate.rs:54:9\n    |\n LL |     use self::m2::*;\n    |         ^^^^^^^^^^^\n-   = note: consider adding an explicit import of `foo` to disambiguate\n+   = help: consider adding an explicit import of `foo` to disambiguate\n \n error: aborting due to 5 previous errors\n "}, {"sha": "218dfb796f77ad3964915b2a834875a4c48b00bf", "filename": "src/test/ui/imports/extern-prelude-extern-crate-restricted-shadowing.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-restricted-shadowing.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,19 +1,18 @@\n-error[E0659]: `Vec` is ambiguous\n+error[E0659]: `Vec` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/extern-prelude-extern-crate-restricted-shadowing.rs:15:9\n    |\n LL |         Vec::panic!(); //~ ERROR `Vec` is ambiguous\n    |         ^^^ ambiguous name\n    |\n-note: `Vec` could refer to the name defined here\n+   = note: `Vec` could refer to a struct from prelude\n+note: `Vec` could also refer to the extern crate imported here\n   --> $DIR/extern-prelude-extern-crate-restricted-shadowing.rs:7:9\n    |\n LL |         extern crate std as Vec;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | define_vec!();\n    | -------------- in this macro invocation\n-note: `Vec` could also refer to the name defined here\n-   = note: macro-expanded items do not shadow when used in a macro invocation path\n \n error: aborting due to previous error\n "}, {"sha": "93d3fa969efc30752fabcbbb3a623b80cd10b7d2", "filename": "src/test/ui/imports/glob-shadowing.stderr", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fglob-shadowing.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,48 +1,50 @@\n-error[E0659]: `env` is ambiguous\n+error[E0659]: `env` is ambiguous (glob import vs any other name from outer scope during import/macro resolution)\n   --> $DIR/glob-shadowing.rs:21:17\n    |\n LL |         let x = env!(\"PATH\"); //~ ERROR `env` is ambiguous\n    |                 ^^^ ambiguous name\n    |\n-note: `env` could refer to the name imported here\n+   = note: `env` could refer to a built-in macro\n+note: `env` could also refer to the macro imported here\n   --> $DIR/glob-shadowing.rs:19:9\n    |\n LL |     use m::*;\n    |         ^^^^\n-   = note: `env` is also a builtin macro\n-   = note: consider adding an explicit import of `env` to disambiguate\n+   = help: consider adding an explicit import of `env` to disambiguate\n+   = help: or use `self::env` to refer to the macro unambiguously\n \n-error[E0659]: `env` is ambiguous\n+error[E0659]: `env` is ambiguous (glob import vs any other name from outer scope during import/macro resolution)\n   --> $DIR/glob-shadowing.rs:29:21\n    |\n LL |             let x = env!(\"PATH\"); //~ ERROR `env` is ambiguous\n    |                     ^^^ ambiguous name\n    |\n-note: `env` could refer to the name imported here\n+   = note: `env` could refer to a built-in macro\n+note: `env` could also refer to the macro imported here\n   --> $DIR/glob-shadowing.rs:27:13\n    |\n LL |         use m::*;\n    |             ^^^^\n-   = note: `env` is also a builtin macro\n-   = note: consider adding an explicit import of `env` to disambiguate\n+   = help: consider adding an explicit import of `env` to disambiguate\n \n-error[E0659]: `fenv` is ambiguous\n+error[E0659]: `fenv` is ambiguous (glob import vs any other name from outer scope during import/macro resolution)\n   --> $DIR/glob-shadowing.rs:39:21\n    |\n LL |             let x = fenv!(); //~ ERROR `fenv` is ambiguous\n    |                     ^^^^ ambiguous name\n    |\n-note: `fenv` could refer to the name imported here\n+note: `fenv` could refer to the macro imported here\n   --> $DIR/glob-shadowing.rs:37:13\n    |\n LL |         use m::*;\n    |             ^^^^\n-note: `fenv` could also refer to the name defined here\n+   = help: consider adding an explicit import of `fenv` to disambiguate\n+note: `fenv` could also refer to the macro defined here\n   --> $DIR/glob-shadowing.rs:35:5\n    |\n LL |     pub macro fenv($e: expr) { $e }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: consider adding an explicit import of `fenv` to disambiguate\n+   = help: use `self::fenv` to refer to the macro unambiguously\n \n error: aborting due to 3 previous errors\n "}, {"sha": "9fa438e91cd221226c8a057edf02575f4593367f", "filename": "src/test/ui/imports/issue-53269.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -4,22 +4,23 @@ error[E0432]: unresolved import `nonexistent_module`\n LL |     use nonexistent_module::mac; //~ ERROR unresolved import `nonexistent_module`\n    |         ^^^^^^^^^^^^^^^^^^ Maybe a missing `extern crate nonexistent_module;`?\n \n-error[E0659]: `mac` is ambiguous\n+error[E0659]: `mac` is ambiguous (`macro_rules` vs non-`macro_rules` from other module)\n   --> $DIR/issue-53269.rs:18:5\n    |\n LL |     mac!(); //~ ERROR `mac` is ambiguous\n    |     ^^^ ambiguous name\n    |\n-note: `mac` could refer to the name defined here\n+note: `mac` could refer to the macro defined here\n   --> $DIR/issue-53269.rs:13:1\n    |\n LL | macro_rules! mac { () => () }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: `mac` could also refer to the name imported here\n+note: `mac` could also refer to the unresolved item imported here\n   --> $DIR/issue-53269.rs:16:9\n    |\n LL |     use nonexistent_module::mac; //~ ERROR unresolved import `nonexistent_module`\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `self::mac` to refer to the unresolved item unambiguously\n \n error: aborting due to 2 previous errors\n "}, {"sha": "91e569d1764617a50c5524bc0ce3c3dacf37bdb4", "filename": "src/test/ui/imports/local-modularized-tricky-fail-1.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Flocal-modularized-tricky-fail-1.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,10 +1,10 @@\n-error[E0659]: `exported` is ambiguous\n+error[E0659]: `exported` is ambiguous (glob import vs macro-expanded name in the same module during import/macro resolution)\n   --> $DIR/local-modularized-tricky-fail-1.rs:38:1\n    |\n LL | exported!(); //~ ERROR `exported` is ambiguous\n    | ^^^^^^^^ ambiguous name\n    |\n-note: `exported` could refer to the name defined here\n+note: `exported` could refer to the macro defined here\n   --> $DIR/local-modularized-tricky-fail-1.rs:15:5\n    |\n LL | /     macro_rules! exported {\n@@ -14,20 +14,21 @@ LL | |     }\n ...\n LL |       define_exported!();\n    |       ------------------- in this macro invocation\n-note: `exported` could also refer to the name imported here\n+note: `exported` could also refer to the macro imported here\n   --> $DIR/local-modularized-tricky-fail-1.rs:32:5\n    |\n LL | use inner1::*;\n    |     ^^^^^^^^^\n-   = note: macro-expanded macros do not shadow\n+   = help: consider adding an explicit import of `exported` to disambiguate\n \n-error[E0659]: `include` is ambiguous\n+error[E0659]: `include` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/local-modularized-tricky-fail-1.rs:56:1\n    |\n LL | include!(); //~ ERROR `include` is ambiguous\n    | ^^^^^^^ ambiguous name\n    |\n-note: `include` could refer to the name defined here\n+   = note: `include` could refer to a built-in macro\n+note: `include` could also refer to the macro defined here\n   --> $DIR/local-modularized-tricky-fail-1.rs:27:5\n    |\n LL | /     macro_rules! include {\n@@ -37,16 +38,16 @@ LL | |     }\n ...\n LL |       define_include!();\n    |       ------------------ in this macro invocation\n-   = note: `include` is also a builtin macro\n-   = note: macro-expanded macros do not shadow\n+   = help: use `self::include` to refer to the macro unambiguously\n \n-error[E0659]: `panic` is ambiguous\n+error[E0659]: `panic` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/local-modularized-tricky-fail-1.rs:45:5\n    |\n LL |     panic!(); //~ ERROR `panic` is ambiguous\n    |     ^^^^^ ambiguous name\n    |\n-note: `panic` could refer to the name defined here\n+   = note: `panic` could refer to a macro from prelude\n+note: `panic` could also refer to the macro defined here\n   --> $DIR/local-modularized-tricky-fail-1.rs:21:5\n    |\n LL | /     macro_rules! panic {\n@@ -56,16 +57,16 @@ LL | |     }\n ...\n LL |       define_panic!();\n    |       ---------------- in this macro invocation\n-   = note: `panic` is also a builtin macro\n-   = note: macro-expanded macros do not shadow\n+   = help: use `self::panic` to refer to the macro unambiguously\n \n-error[E0659]: `panic` is ambiguous\n+error[E0659]: `panic` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> <::std::macros::panic macros>:1:13\n    |\n LL | (  ) => ( { panic ! ( \"explicit panic\" ) } ) ; ( $ msg : expr ) => (\n    |             ^^^^^ ambiguous name\n    |\n-note: `panic` could refer to the name defined here\n+   = note: `panic` could refer to a macro from prelude\n+note: `panic` could also refer to the macro defined here\n   --> $DIR/local-modularized-tricky-fail-1.rs:21:5\n    |\n LL | /     macro_rules! panic {\n@@ -75,8 +76,7 @@ LL | |     }\n ...\n LL |       define_panic!();\n    |       ---------------- in this macro invocation\n-   = note: `panic` is also a builtin macro\n-   = note: macro-expanded macros do not shadow\n+   = help: use `self::panic` to refer to the macro unambiguously\n \n error: aborting due to 4 previous errors\n "}, {"sha": "96880492e285f255884626c0bfdde1b736d4c1b5", "filename": "src/test/ui/imports/macro-paths.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fmacro-paths.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,40 +1,40 @@\n-error[E0659]: `bar` is ambiguous\n+error[E0659]: `bar` is ambiguous (glob import vs macro-expanded name in the same module during import/macro resolution)\n   --> $DIR/macro-paths.rs:23:5\n    |\n LL |     bar::m! { //~ ERROR ambiguous\n    |     ^^^ ambiguous name\n    |\n-note: `bar` could refer to the name defined here\n+note: `bar` could refer to the module defined here\n   --> $DIR/macro-paths.rs:24:9\n    |\n LL |         mod bar { pub use two_macros::m; }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: `bar` could also refer to the name imported here\n+note: `bar` could also refer to the module imported here\n   --> $DIR/macro-paths.rs:22:9\n    |\n LL |     use foo::*;\n    |         ^^^^^^\n-   = note: macro-expanded items do not shadow when used in a macro invocation path\n+   = help: consider adding an explicit import of `bar` to disambiguate\n \n-error[E0659]: `baz` is ambiguous\n+error[E0659]: `baz` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/macro-paths.rs:33:5\n    |\n LL |     baz::m! { //~ ERROR ambiguous\n    |     ^^^ ambiguous name\n    |\n-note: `baz` could refer to the name defined here\n+note: `baz` could refer to the module defined here\n   --> $DIR/macro-paths.rs:34:9\n    |\n LL |         mod baz { pub use two_macros::m; }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: `baz` could also refer to the name defined here\n+note: `baz` could also refer to the module defined here\n   --> $DIR/macro-paths.rs:28:1\n    |\n LL | / pub mod baz {\n LL | |     pub use two_macros::m;\n LL | | }\n    | |_^\n-   = note: macro-expanded items do not shadow when used in a macro invocation path\n+   = help: use `self::baz` to refer to the module unambiguously\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ade49e6be2483bd7f377bfafbbfee3e12a8887e4", "filename": "src/test/ui/imports/macros.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,38 +1,38 @@\n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (glob import vs macro-expanded name in the same module during import/macro resolution)\n   --> $DIR/macros.rs:26:5\n    |\n LL |     m! { //~ ERROR ambiguous\n    |     ^ ambiguous name\n    |\n-note: `m` could refer to the name imported here\n+note: `m` could refer to the macro imported here\n   --> $DIR/macros.rs:27:13\n    |\n LL |         use foo::m;\n    |             ^^^^^^\n-note: `m` could also refer to the name imported here\n+note: `m` could also refer to the macro imported here\n   --> $DIR/macros.rs:25:9\n    |\n LL |     use two_macros::*;\n    |         ^^^^^^^^^^^^^\n-   = note: macro-expanded macro imports do not shadow\n+   = help: consider adding an explicit import of `m` to disambiguate\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/macros.rs:39:9\n    |\n LL |         m! { //~ ERROR ambiguous\n    |         ^ ambiguous name\n    |\n-note: `m` could refer to the name imported here\n+note: `m` could refer to the macro imported here\n   --> $DIR/macros.rs:40:17\n    |\n LL |             use two_macros::n as m;\n    |                 ^^^^^^^^^^^^^^^^^^\n-note: `m` could also refer to the name imported here\n+note: `m` could also refer to the macro imported here\n   --> $DIR/macros.rs:32:9\n    |\n LL |     use two_macros::m;\n    |         ^^^^^^^^^^^^^\n-   = note: macro-expanded macro imports do not shadow\n+   = help: use `self::m` to refer to the macro unambiguously\n \n error: aborting due to 2 previous errors\n "}, {"sha": "946dc084cd0f8c4fc6e53893cebe8ab40afc9310", "filename": "src/test/ui/imports/rfc-1560-warning-cycle.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Frfc-1560-warning-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Frfc-1560-warning-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Frfc-1560-warning-cycle.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,20 +1,21 @@\n-error[E0659]: `Foo` is ambiguous\n+error[E0659]: `Foo` is ambiguous (glob import vs glob import in the same module)\n   --> $DIR/rfc-1560-warning-cycle.rs:19:17\n    |\n LL |         fn f(_: Foo) {} //~ ERROR `Foo` is ambiguous\n    |                 ^^^ ambiguous name\n    |\n-note: `Foo` could refer to the name imported here\n+note: `Foo` could refer to the struct imported here\n   --> $DIR/rfc-1560-warning-cycle.rs:17:13\n    |\n LL |         use *;\n    |             ^\n-note: `Foo` could also refer to the name imported here\n+   = help: consider adding an explicit import of `Foo` to disambiguate\n+note: `Foo` could also refer to the struct imported here\n   --> $DIR/rfc-1560-warning-cycle.rs:18:13\n    |\n LL |         use bar::*;\n    |             ^^^^^^\n-   = note: consider adding an explicit import of `Foo` to disambiguate\n+   = help: consider adding an explicit import of `Foo` to disambiguate\n \n error: aborting due to previous error\n "}, {"sha": "4d6c1aa3ea5e7a27bd5695dec1c656fee78925f4", "filename": "src/test/ui/imports/shadow_builtin_macros.stderr", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,65 +1,66 @@\n-error[E0659]: `panic` is ambiguous\n+error[E0659]: `panic` is ambiguous (glob import vs any other name from outer scope during import/macro resolution)\n   --> $DIR/shadow_builtin_macros.rs:25:14\n    |\n LL |     fn f() { panic!(); } //~ ERROR ambiguous\n    |              ^^^^^ ambiguous name\n    |\n-note: `panic` could refer to the name imported here\n+   = note: `panic` could refer to a macro from prelude\n+note: `panic` could also refer to the macro imported here\n   --> $DIR/shadow_builtin_macros.rs:24:9\n    |\n LL |     use foo::*;\n    |         ^^^^^^\n-   = note: `panic` is also a builtin macro\n-   = note: consider adding an explicit import of `panic` to disambiguate\n+   = help: consider adding an explicit import of `panic` to disambiguate\n+   = help: or use `self::panic` to refer to the macro unambiguously\n \n-error[E0659]: `panic` is ambiguous\n+error[E0659]: `panic` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/shadow_builtin_macros.rs:30:14\n    |\n LL |     fn f() { panic!(); } //~ ERROR ambiguous\n    |              ^^^^^ ambiguous name\n    |\n-note: `panic` could refer to the name imported here\n+   = note: `panic` could refer to a macro from prelude\n+note: `panic` could also refer to the macro imported here\n   --> $DIR/shadow_builtin_macros.rs:29:26\n    |\n LL |     ::two_macros::m!(use foo::panic;);\n    |                          ^^^^^^^^^^\n-   = note: `panic` is also a builtin macro\n-   = note: macro-expanded macro imports do not shadow\n+   = help: use `self::panic` to refer to the macro unambiguously\n \n-error[E0659]: `panic` is ambiguous\n+error[E0659]: `panic` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/shadow_builtin_macros.rs:43:5\n    |\n LL |     panic!(); //~ ERROR `panic` is ambiguous\n    |     ^^^^^ ambiguous name\n    |\n-note: `panic` could refer to the name defined here\n+   = note: `panic` could refer to a macro from prelude\n+note: `panic` could also refer to the macro defined here\n   --> $DIR/shadow_builtin_macros.rs:40:9\n    |\n LL |         macro_rules! panic { () => {} }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |     } }\n LL |     m!();\n    |     ----- in this macro invocation\n-   = note: `panic` is also a builtin macro\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `n` is ambiguous\n+error[E0659]: `n` is ambiguous (glob import vs any other name from outer scope during import/macro resolution)\n   --> $DIR/shadow_builtin_macros.rs:59:5\n    |\n LL |     n!(); //~ ERROR ambiguous\n    |     ^ ambiguous name\n    |\n-note: `n` could refer to the name imported here\n+note: `n` could refer to the macro imported here\n   --> $DIR/shadow_builtin_macros.rs:58:9\n    |\n LL |     use bar::*;\n    |         ^^^^^^\n-note: `n` could also refer to the name imported here\n+   = help: consider adding an explicit import of `n` to disambiguate\n+   = help: or use `self::n` to refer to the macro unambiguously\n+note: `n` could also refer to the macro imported here\n   --> $DIR/shadow_builtin_macros.rs:46:13\n    |\n LL | #[macro_use(n)]\n    |             ^\n-   = note: consider adding an explicit import of `n` to disambiguate\n \n error: aborting due to 4 previous errors\n "}, {"sha": "2785594585dd8d85652e6b3f155d0ae10a3047d6", "filename": "src/test/ui/macros/ambiguity-legacy-vs-modern.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fmacros%2Fambiguity-legacy-vs-modern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fmacros%2Fambiguity-legacy-vs-modern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fambiguity-legacy-vs-modern.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,32 +1,32 @@\n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (`macro_rules` vs non-`macro_rules` from other module)\n   --> $DIR/ambiguity-legacy-vs-modern.rs:31:9\n    |\n LL |         m!() //~ ERROR `m` is ambiguous\n    |         ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/ambiguity-legacy-vs-modern.rs:26:5\n    |\n LL |     macro_rules! m { () => (()) }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/ambiguity-legacy-vs-modern.rs:29:9\n    |\n LL |         macro m() { 0 }\n    |         ^^^^^^^^^^^^^^^\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (`macro_rules` vs non-`macro_rules` from other module)\n   --> $DIR/ambiguity-legacy-vs-modern.rs:43:5\n    |\n LL |     m!() //~ ERROR `m` is ambiguous\n    |     ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/ambiguity-legacy-vs-modern.rs:40:9\n    |\n LL |         macro_rules! m { () => (()) }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/ambiguity-legacy-vs-modern.rs:36:5\n    |\n LL |     macro m() { 0 }"}, {"sha": "3e0ea82364265675ac55076e6f29a9d3cb53f545", "filename": "src/test/ui/macros/macro-path-prelude-shadowing.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-shadowing.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,16 +1,17 @@\n-error[E0659]: `std` is ambiguous\n+error[E0659]: `std` is ambiguous (glob import vs any other name from outer scope during import/macro resolution)\n   --> $DIR/macro-path-prelude-shadowing.rs:39:9\n    |\n LL |         std::panic!(); //~ ERROR `std` is ambiguous\n    |         ^^^ ambiguous name\n    |\n-note: `std` could refer to the name imported here\n+   = note: `std` could refer to a built-in extern crate\n+note: `std` could also refer to the module imported here\n   --> $DIR/macro-path-prelude-shadowing.rs:37:9\n    |\n LL |     use m2::*; // glob-import user-defined `std`\n    |         ^^^^^\n-note: `std` could also refer to the name defined here\n-   = note: consider adding an explicit import of `std` to disambiguate\n+   = help: consider adding an explicit import of `std` to disambiguate\n+   = help: or use `self::std` to refer to the module unambiguously\n \n error: aborting due to previous error\n "}, {"sha": "6985dfcc6c27e5518960bef7c25b252850c4fe16", "filename": "src/test/ui/macros/macro-shadowing.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-shadowing.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -9,26 +9,25 @@ LL | m1!();\n    |\n    = note: macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\n \n-error[E0659]: `foo` is ambiguous\n+error[E0659]: `foo` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/macro-shadowing.rs:27:1\n    |\n LL | foo!(); //~ ERROR `foo` is ambiguous\n    | ^^^ ambiguous name\n    |\n-note: `foo` could refer to the name defined here\n+note: `foo` could refer to the macro defined here\n   --> $DIR/macro-shadowing.rs:20:5\n    |\n LL |     macro_rules! foo { () => {} }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | m1!();\n    | ------ in this macro invocation\n-note: `foo` could also refer to the name defined here\n+note: `foo` could also refer to the macro defined here\n   --> $DIR/macro-shadowing.rs:15:1\n    |\n LL | macro_rules! foo { () => {} }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: macro-expanded macros do not shadow\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2135d63c80ec28e4b96e4bde5f07fd1f503cc0eb", "filename": "src/test/ui/macros/restricted-shadowing-legacy.stderr", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-legacy.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,194 +1,186 @@\n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:101:13\n    |\n LL |             m!(); //~ ERROR `m` is ambiguous\n    |             ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:97:9\n    |\n LL |         macro_rules! m { () => {} }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:139:42\n    |\n LL |         macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n    |                                          ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:135:9\n    |\n LL |         macro_rules! m { () => {} }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:148:9\n    |\n LL |         m!(); //~ ERROR `m` is ambiguous\n    |         ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:144:9\n    |\n LL |         macro_rules! m { () => {} }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:164:9\n    |\n LL |         m!(); //~ ERROR `m` is ambiguous\n    |         ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:85:9\n    |\n LL |         macro_rules! m { () => { Wrong } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:180:13\n    |\n LL |             m!(); //~ ERROR `m` is ambiguous\n    |             ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:85:9\n    |\n LL |         macro_rules! m { () => { Wrong } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:218:42\n    |\n LL |         macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n    |                                          ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:85:9\n    |\n LL |         macro_rules! m { () => { Wrong } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:232:9\n    |\n LL |         m!(); //~ ERROR `m` is ambiguous\n    |         ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:227:13\n    |\n LL |             macro_rules! m { () => {} }\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-legacy.rs:262:42\n    |\n LL |         macro_rules! gen_invoc { () => { m!() } } //~ ERROR `m` is ambiguous\n    |                                          ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:88:9\n    |\n LL |         macro_rules! m { () => { Right } }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-legacy.rs:257:13\n    |\n LL |             macro_rules! m { () => {} }\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n error: aborting due to 8 previous errors\n "}, {"sha": "2449e8512d3cd1ed73f82238a75309e9a487f7a0", "filename": "src/test/ui/macros/restricted-shadowing-modern.stderr", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,146 +1,140 @@\n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-modern.rs:106:17\n    |\n LL |                 m!(); //~ ERROR `m` is ambiguous\n    |                 ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n    |\n LL |         macro m() { Right }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:101:9\n    |\n LL |         macro m() {}\n    |         ^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-modern.rs:149:33\n    |\n LL |             macro gen_invoc() { m!() } //~ ERROR `m` is ambiguous\n    |                                 ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n    |\n LL |         macro m() { Right }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:145:9\n    |\n LL |         macro m() {}\n    |         ^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-modern.rs:158:13\n    |\n LL |             m!(); //~ ERROR `m` is ambiguous\n    |             ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n    |\n LL |         macro m() { Right }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:155:9\n    |\n LL |         macro m() {}\n    |         ^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-modern.rs:174:13\n    |\n LL |             m!(); //~ ERROR `m` is ambiguous\n    |             ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n    |\n LL |         macro m() { Right }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:87:9\n    |\n LL |         macro m() { Wrong }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-modern.rs:192:17\n    |\n LL |                 m!(); //~ ERROR `m` is ambiguous\n    |                 ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n    |\n LL |         macro m() { Right }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:87:9\n    |\n LL |         macro m() { Wrong }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n-error[E0659]: `m` is ambiguous\n+error[E0659]: `m` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/restricted-shadowing-modern.rs:235:33\n    |\n LL |             macro gen_invoc() { m!() } //~ ERROR `m` is ambiguous\n    |                                 ^ ambiguous name\n    |\n-note: `m` could refer to the name defined here\n+note: `m` could refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:91:9\n    |\n LL |         macro m() { Right }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-note: `m` could also refer to the name defined here\n+note: `m` could also refer to the macro defined here\n   --> $DIR/restricted-shadowing-modern.rs:87:9\n    |\n LL |         macro m() { Wrong }\n    |         ^^^^^^^^^^^^^^^^^^^\n ...\n LL | include!();\n    | ----------- in this macro invocation\n-   = note: macro-expanded macros do not shadow\n \n error: aborting due to 6 previous errors\n "}, {"sha": "4696e2057282a5f1c1c7576fb8a2bccb25239cd1", "filename": "src/test/ui/out-of-order-shadowing.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fout-of-order-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Fout-of-order-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fout-of-order-shadowing.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,20 +1,19 @@\n-error[E0659]: `bar` is ambiguous\n+error[E0659]: `bar` is ambiguous (macro-expanded name vs less macro-expanded name from outer scope during import/macro resolution)\n   --> $DIR/out-of-order-shadowing.rs:15:1\n    |\n LL | bar!(); //~ ERROR `bar` is ambiguous\n    | ^^^ ambiguous name\n    |\n-note: `bar` could refer to the name defined here\n+note: `bar` could refer to the macro defined here\n   --> $DIR/out-of-order-shadowing.rs:14:1\n    |\n LL | define_macro!(bar);\n    | ^^^^^^^^^^^^^^^^^^^\n-note: `bar` could also refer to the name defined here\n+note: `bar` could also refer to the macro defined here\n   --> $DIR/out-of-order-shadowing.rs:13:1\n    |\n LL | macro_rules! bar { () => {} }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: macro-expanded macros do not shadow\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "4819711115c27a76a5f25123447bd20bf04cb70b", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.rs?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -14,7 +14,7 @@\n \n mod foo {\n     pub use std::io;\n-    //~^ ERROR `std` import is ambiguous\n+    //~^ ERROR `std` is ambiguous\n \n     macro_rules! m {\n         () => {"}, {"sha": "b8cbabeea2c8e71a93570e2c5134ee0e7b476b9b", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros-nested.stderr", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros-nested.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,16 +1,23 @@\n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/ambiguity-macros-nested.rs:16:13\n    |\n-LL |       pub use std::io;\n-   |               ^^^ can refer to external crate `::std`\n-...\n+LL |     pub use std::io;\n+   |             ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to the extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity-macros-nested.rs:21:13\n+   |\n LL | /             mod std {\n LL | |                 pub struct io;\n LL | |             }\n-   | |_____________- may refer to `self::std` in the future\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+   | |_____________^\n+...\n+LL |       m!();\n+   |       ----- in this macro invocation\n+   = help: use `self::std` to refer to the module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "148320de556d30d4633d90afacbccedaf4da14ea", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.rs?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -13,7 +13,7 @@\n // This test is similar to `ambiguity.rs`, but with macros defining local items.\n \n use std::io;\n-//~^ ERROR `std` import is ambiguous\n+//~^ ERROR `std` is ambiguous\n \n macro_rules! m {\n     () => {"}, {"sha": "5c9ab11085454256f02c3e75dde54e329f2f74a7", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-macros.stderr", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-macros.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,16 +1,23 @@\n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/ambiguity-macros.rs:15:5\n    |\n-LL |   use std::io;\n-   |       ^^^ can refer to external crate `::std`\n-...\n+LL | use std::io;\n+   |     ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to the extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity-macros.rs:20:9\n+   |\n LL | /         mod std {\n LL | |             pub struct io;\n LL | |         }\n-   | |_________- may refer to `self::std` in the future\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+   | |_________^\n+...\n+LL |   m!();\n+   |   ----- in this macro invocation\n+   = help: use `self::std` to refer to the module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "2791d4580daf1a476deeff60b98c9cbbe4ab5faf", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.rs?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -14,7 +14,7 @@\n \n mod foo {\n     pub use std::io;\n-    //~^ ERROR `std` import is ambiguous\n+    //~^ ERROR `std` is ambiguous\n \n     mod std {\n         pub struct io;"}, {"sha": "e98b9ad9a2ae6f7140592b82c4ca3345238eceae", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity-nested.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity-nested.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,16 +1,20 @@\n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/ambiguity-nested.rs:16:13\n    |\n-LL |       pub use std::io;\n-   |               ^^^ can refer to external crate `::std`\n-...\n+LL |     pub use std::io;\n+   |             ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to the extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity-nested.rs:19:5\n+   |\n LL | /     mod std {\n LL | |         pub struct io;\n LL | |     }\n-   | |_____- may refer to `self::std` in the future\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+   | |_____^\n+   = help: use `self::std` to refer to the module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "2bfbb6b287153ded300d89545cab2ff528019c5e", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.rs?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -11,7 +11,7 @@\n // edition:2018\n \n use std::io;\n-//~^ ERROR `std` import is ambiguous\n+//~^ ERROR `std` is ambiguous\n \n mod std {\n     pub struct io;"}, {"sha": "75387454015b9f7dab75e8b9a910dbb94f6f1083", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/ambiguity.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fambiguity.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,16 +1,20 @@\n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/ambiguity.rs:13:5\n    |\n-LL |   use std::io;\n-   |       ^^^ can refer to external crate `::std`\n-...\n+LL | use std::io;\n+   |     ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to the extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity.rs:16:1\n+   |\n LL | / mod std {\n LL | |     pub struct io;\n LL | | }\n-   | |_- may refer to `self::std` in the future\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+   | |_^\n+   = help: use `self::std` to refer to the module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "9f440d71fb003c24953214b7889f35dbfed999e3", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -16,7 +16,7 @@\n \n mod foo {\n     pub use std::io;\n-    //~^ ERROR `std` import is ambiguous\n+    //~^ ERROR `std` is ambiguous\n \n     macro_rules! m {\n         () => {"}, {"sha": "f18de7edcdcbc23396a416a7f14e352b6a41d648", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros-nested.stderr", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,16 +1,23 @@\n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/ambiguity-macros-nested.rs:18:13\n    |\n-LL |       pub use std::io;\n-   |               ^^^ can refer to external crate `::std`\n-...\n+LL |     pub use std::io;\n+   |             ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to the extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity-macros-nested.rs:23:13\n+   |\n LL | /             mod std {\n LL | |                 pub struct io;\n LL | |             }\n-   | |_____________- can refer to `self::std`\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+   | |_____________^\n+...\n+LL |       m!();\n+   |       ----- in this macro invocation\n+   = help: use `self::std` to refer to the module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "f1ed48150c0b862eb4bb6bf6aae773a27a9d707d", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -15,7 +15,7 @@\n // This test is similar to `ambiguity.rs`, but with macros defining local items.\n \n use std::io;\n-//~^ ERROR `std` import is ambiguous\n+//~^ ERROR `std` is ambiguous\n \n macro_rules! m {\n     () => {"}, {"sha": "16e083b0980836f32fff005c018b4435e98a1495", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros.stderr", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,16 +1,23 @@\n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/ambiguity-macros.rs:17:5\n    |\n-LL |   use std::io;\n-   |       ^^^ can refer to external crate `::std`\n-...\n+LL | use std::io;\n+   |     ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to the extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity-macros.rs:22:9\n+   |\n LL | /         mod std {\n LL | |             pub struct io;\n LL | |         }\n-   | |_________- can refer to `self::std`\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+   | |_________^\n+...\n+LL |   m!();\n+   |   ----- in this macro invocation\n+   = help: use `self::std` to refer to the module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "0d0d34df1f833e7639ba2c3e6c816c48275552e5", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -16,7 +16,7 @@\n \n mod foo {\n     pub use std::io;\n-    //~^ ERROR `std` import is ambiguous\n+    //~^ ERROR `std` is ambiguous\n \n     mod std {\n         pub struct io;"}, {"sha": "cb38102c5997e1446b2a3dd7f332bce2b967cf0c", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-nested.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,16 +1,20 @@\n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/ambiguity-nested.rs:18:13\n    |\n-LL |       pub use std::io;\n-   |               ^^^ can refer to external crate `::std`\n-...\n+LL |     pub use std::io;\n+   |             ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to the extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity-nested.rs:21:5\n+   |\n LL | /     mod std {\n LL | |         pub struct io;\n LL | |     }\n-   | |_____- can refer to `self::std`\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+   | |_____^\n+   = help: use `self::std` to refer to the module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "259f451e4d22d2275b45cfeea4ef4775f6e207f1", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -13,7 +13,7 @@\n #![feature(uniform_paths)]\n \n use std::io;\n-//~^ ERROR `std` import is ambiguous\n+//~^ ERROR `std` is ambiguous\n \n mod std {\n     pub struct io;"}, {"sha": "ce0c64b226b59200a212f4e403a4b2adc729ab6f", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f0ea1c6f1e2543b905ff486d227e951c8a20756c/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr?ref=f0ea1c6f1e2543b905ff486d227e951c8a20756c", "patch": "@@ -1,16 +1,20 @@\n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/ambiguity.rs:15:5\n    |\n-LL |   use std::io;\n-   |       ^^^ can refer to external crate `::std`\n-...\n+LL | use std::io;\n+   |     ^^^ ambiguous name\n+   |\n+   = note: `std` could refer to a built-in extern crate\n+   = help: use `::std` to refer to the extern crate unambiguously\n+note: `std` could also refer to the module defined here\n+  --> $DIR/ambiguity.rs:18:1\n+   |\n LL | / mod std {\n LL | |     pub struct io;\n LL | | }\n-   | |_- can refer to `self::std`\n-   |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+   | |_^\n+   = help: use `self::std` to refer to the module unambiguously\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0659`."}]}