{"sha": "3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "node_id": "C_kwDOAAsO6NoAKDNkOWM0YTY1NWIwNGU5NjE2ZGVkODM3NGRjNjFjYjkxMDhmNGFlMDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-12T21:04:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-12T21:04:13Z"}, "message": "Auto merge of #7682 - Qwaz:uninit_vec, r=xFrednet\n\nImplement uninit_vec lint\n\nchangelog: add the new lint [`uninit_vec`]\n\nFix #7681", "tree": {"sha": "c8e18dc433ebdd2d078a19cd3a5c18d241452321", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8e18dc433ebdd2d078a19cd3a5c18d241452321"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "html_url": "https://github.com/rust-lang/rust/commit/3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3905af454c640d61b1f4e7d4c29fc568d2fc9cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3905af454c640d61b1f4e7d4c29fc568d2fc9cf", "html_url": "https://github.com/rust-lang/rust/commit/d3905af454c640d61b1f4e7d4c29fc568d2fc9cf"}, {"sha": "4ed3a4fe2f681660cac9a4fad6385c6d92a89de1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ed3a4fe2f681660cac9a4fad6385c6d92a89de1", "html_url": "https://github.com/rust-lang/rust/commit/4ed3a4fe2f681660cac9a4fad6385c6d92a89de1"}], "stats": {"total": 559, "additions": 499, "deletions": 60}, "files": [{"sha": "b9b98ceb4d093d5b81e1745e16a27ffd2b2bfca7", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "patch": "@@ -3039,6 +3039,7 @@ Released 2018-09-13\n [`unicode_not_nfc`]: https://rust-lang.github.io/rust-clippy/master/index.html#unicode_not_nfc\n [`unimplemented`]: https://rust-lang.github.io/rust-clippy/master/index.html#unimplemented\n [`uninit_assumed_init`]: https://rust-lang.github.io/rust-clippy/master/index.html#uninit_assumed_init\n+[`uninit_vec`]: https://rust-lang.github.io/rust-clippy/master/index.html#uninit_vec\n [`unit_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_arg\n [`unit_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_cmp\n [`unit_return_expecting_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#unit_return_expecting_ord"}, {"sha": "4cbb2a786194f1203d2acea35cc6196512d88dae", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "patch": "@@ -279,6 +279,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(types::VEC_BOX),\n     LintId::of(undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n     LintId::of(unicode::INVISIBLE_CHARACTERS),\n+    LintId::of(uninit_vec::UNINIT_VEC),\n     LintId::of(unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n     LintId::of(unit_types::UNIT_ARG),\n     LintId::of(unit_types::UNIT_CMP),"}, {"sha": "94a385dad840e6dda5ab950260a5bce32d0cd733", "filename": "clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "patch": "@@ -64,6 +64,7 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(transmuting_null::TRANSMUTING_NULL),\n     LintId::of(undropped_manually_drops::UNDROPPED_MANUALLY_DROPS),\n     LintId::of(unicode::INVISIBLE_CHARACTERS),\n+    LintId::of(uninit_vec::UNINIT_VEC),\n     LintId::of(unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n     LintId::of(unit_types::UNIT_CMP),\n     LintId::of(unnamed_address::FN_ADDRESS_COMPARISONS),"}, {"sha": "a7a0574661de22afce565264aa45b898dfac3f11", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "patch": "@@ -471,6 +471,7 @@ store.register_lints(&[\n     unicode::INVISIBLE_CHARACTERS,\n     unicode::NON_ASCII_LITERAL,\n     unicode::UNICODE_NOT_NFC,\n+    uninit_vec::UNINIT_VEC,\n     unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD,\n     unit_types::LET_UNIT_VALUE,\n     unit_types::UNIT_ARG,"}, {"sha": "6ab59b1b12fe94caf64aec3706e987dc0666c6f7", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "patch": "@@ -362,6 +362,7 @@ mod types;\n mod undocumented_unsafe_blocks;\n mod undropped_manually_drops;\n mod unicode;\n+mod uninit_vec;\n mod unit_return_expecting_ord;\n mod unit_types;\n mod unnamed_address;\n@@ -519,6 +520,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(blocks_in_if_conditions::BlocksInIfConditions));\n     store.register_late_pass(|| Box::new(collapsible_match::CollapsibleMatch));\n     store.register_late_pass(|| Box::new(unicode::Unicode));\n+    store.register_late_pass(|| Box::new(uninit_vec::UninitVec));\n     store.register_late_pass(|| Box::new(unit_return_expecting_ord::UnitReturnExpectingOrd));\n     store.register_late_pass(|| Box::new(strings::StringAdd));\n     store.register_late_pass(|| Box::new(implicit_return::ImplicitReturn));"}, {"sha": "ce89189bce9779e12305ca5c269ef9c4e359e30d", "filename": "clippy_lints/src/methods/uninit_assumed_init.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funinit_assumed_init.rs?ref=3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "patch": "@@ -1,9 +1,8 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{is_expr_path_def_path, match_def_path, paths};\n+use clippy_utils::{is_expr_path_def_path, paths, ty::is_uninit_value_valid_for_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, Ty};\n \n use super::UNINIT_ASSUMED_INIT;\n \n@@ -13,7 +12,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n         if let hir::ExprKind::Call(callee, args) = recv.kind;\n         if args.is_empty();\n         if is_expr_path_def_path(cx, callee, &paths::MEM_MAYBEUNINIT_UNINIT);\n-        if !is_maybe_uninit_ty_valid(cx, cx.typeck_results().expr_ty_adjusted(expr));\n+        if !is_uninit_value_valid_for_ty(cx, cx.typeck_results().expr_ty_adjusted(expr));\n         then {\n             span_lint(\n                 cx,\n@@ -24,12 +23,3 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n         }\n     }\n }\n-\n-fn is_maybe_uninit_ty_valid(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    match ty.kind() {\n-        ty::Array(component, _) => is_maybe_uninit_ty_valid(cx, component),\n-        ty::Tuple(types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n-        ty::Adt(adt, _) => match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT),\n-        _ => false,\n-    }\n-}"}, {"sha": "f3e8b6881058f93907762baedb2a472ab74fc1bc", "filename": "clippy_lints/src/uninit_vec.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funinit_vec.rs?ref=3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "patch": "@@ -0,0 +1,223 @@\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n+use clippy_utils::higher::{get_vec_init_kind, VecInitKind};\n+use clippy_utils::ty::{is_type_diagnostic_item, is_uninit_value_valid_for_ty};\n+use clippy_utils::{is_lint_allowed, path_to_local_id, peel_hir_expr_while, SpanlessEq};\n+use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, PathSegment, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{sym, Span};\n+\n+// TODO: add `ReadBuf` (RFC 2930) in \"How to fix\" once it is available in std\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `set_len()` call that creates `Vec` with uninitialized elements.\n+    /// This is commonly caused by calling `set_len()` right after allocating or\n+    /// reserving a buffer with `new()`, `default()`, `with_capacity()`, or `reserve()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// It creates a `Vec` with uninitialized data, which leads to\n+    /// undefined behavior with most safe operations. Notably, uninitialized\n+    /// `Vec<u8>` must not be used with generic `Read`.\n+    ///\n+    /// Moreover, calling `set_len()` on a `Vec` created with `new()` or `default()`\n+    /// creates out-of-bound values that lead to heap memory corruption when used.\n+    ///\n+    /// ### Known Problems\n+    /// This lint only checks directly adjacent statements.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+    /// unsafe { vec.set_len(1000); }\n+    /// reader.read(&mut vec); // undefined behavior!\n+    /// ```\n+    ///\n+    /// ### How to fix?\n+    /// 1. Use an initialized buffer:\n+    ///    ```rust,ignore\n+    ///    let mut vec: Vec<u8> = vec![0; 1000];\n+    ///    reader.read(&mut vec);\n+    ///    ```\n+    /// 2. Wrap the content in `MaybeUninit`:\n+    ///    ```rust,ignore\n+    ///    let mut vec: Vec<MaybeUninit<T>> = Vec::with_capacity(1000);\n+    ///    vec.set_len(1000);  // `MaybeUninit` can be uninitialized\n+    ///    ```\n+    /// 3. If you are on nightly, `Vec::spare_capacity_mut()` is available:\n+    ///    ```rust,ignore\n+    ///    let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+    ///    let remaining = vec.spare_capacity_mut();  // `&mut [MaybeUninit<u8>]`\n+    ///    // perform initialization with `remaining`\n+    ///    vec.set_len(...);  // Safe to call `set_len()` on initialized part\n+    ///    ```\n+    pub UNINIT_VEC,\n+    correctness,\n+    \"Vec with uninitialized data\"\n+}\n+\n+declare_lint_pass!(UninitVec => [UNINIT_VEC]);\n+\n+// FIXME: update to a visitor-based implementation.\n+// Threads: https://github.com/rust-lang/rust-clippy/pull/7682#discussion_r710998368\n+impl<'tcx> LateLintPass<'tcx> for UninitVec {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n+        if !in_external_macro(cx.tcx.sess, block.span) {\n+            for w in block.stmts.windows(2) {\n+                if let StmtKind::Expr(expr) | StmtKind::Semi(expr) = w[1].kind {\n+                    handle_uninit_vec_pair(cx, &w[0], expr);\n+                }\n+            }\n+\n+            if let (Some(stmt), Some(expr)) = (block.stmts.last(), block.expr) {\n+                handle_uninit_vec_pair(cx, stmt, expr);\n+            }\n+        }\n+    }\n+}\n+\n+fn handle_uninit_vec_pair(\n+    cx: &LateContext<'tcx>,\n+    maybe_init_or_reserve: &'tcx Stmt<'tcx>,\n+    maybe_set_len: &'tcx Expr<'tcx>,\n+) {\n+    if_chain! {\n+        if let Some(vec) = extract_init_or_reserve_target(cx, maybe_init_or_reserve);\n+        if let Some((set_len_self, call_span)) = extract_set_len_self(cx, maybe_set_len);\n+        if vec.location.eq_expr(cx, set_len_self);\n+        if let ty::Ref(_, vec_ty, _) = cx.typeck_results().expr_ty_adjusted(set_len_self).kind();\n+        if let ty::Adt(_, substs) = vec_ty.kind();\n+        // `#[allow(...)]` attribute can be set on enclosing unsafe block of `set_len()`\n+        if !is_lint_allowed(cx, UNINIT_VEC, maybe_set_len.hir_id);\n+        then {\n+            if vec.has_capacity() {\n+                // with_capacity / reserve -> set_len\n+\n+                // Check T of Vec<T>\n+                if !is_uninit_value_valid_for_ty(cx, substs.type_at(0)) {\n+                    // FIXME: #7698, false positive of the internal lints\n+                    #[allow(clippy::collapsible_span_lint_calls)]\n+                    span_lint_and_then(\n+                        cx,\n+                        UNINIT_VEC,\n+                        vec![call_span, maybe_init_or_reserve.span],\n+                        \"calling `set_len()` immediately after reserving a buffer creates uninitialized values\",\n+                        |diag| {\n+                            diag.help(\"initialize the buffer or wrap the content in `MaybeUninit`\");\n+                        },\n+                    );\n+                }\n+            } else {\n+                // new / default -> set_len\n+                span_lint(\n+                    cx,\n+                    UNINIT_VEC,\n+                    vec![call_span, maybe_init_or_reserve.span],\n+                    \"calling `set_len()` on empty `Vec` creates out-of-bound values\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// The target `Vec` that is initialized or reserved\n+#[derive(Clone, Copy)]\n+struct TargetVec<'tcx> {\n+    location: VecLocation<'tcx>,\n+    /// `None` if `reserve()`\n+    init_kind: Option<VecInitKind>,\n+}\n+\n+impl TargetVec<'_> {\n+    pub fn has_capacity(self) -> bool {\n+        !matches!(self.init_kind, Some(VecInitKind::New | VecInitKind::Default))\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum VecLocation<'tcx> {\n+    Local(HirId),\n+    Expr(&'tcx Expr<'tcx>),\n+}\n+\n+impl<'tcx> VecLocation<'tcx> {\n+    pub fn eq_expr(self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+        match self {\n+            VecLocation::Local(hir_id) => path_to_local_id(expr, hir_id),\n+            VecLocation::Expr(self_expr) => SpanlessEq::new(cx).eq_expr(self_expr, expr),\n+        }\n+    }\n+}\n+\n+/// Finds the target location where the result of `Vec` initialization is stored\n+/// or `self` expression for `Vec::reserve()`.\n+fn extract_init_or_reserve_target<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'tcx>) -> Option<TargetVec<'tcx>> {\n+    match stmt.kind {\n+        StmtKind::Local(local) => {\n+            if_chain! {\n+                if let Some(init_expr) = local.init;\n+                if let PatKind::Binding(_, hir_id, _, None) = local.pat.kind;\n+                if let Some(init_kind) = get_vec_init_kind(cx, init_expr);\n+                then {\n+                    return Some(TargetVec {\n+                        location: VecLocation::Local(hir_id),\n+                        init_kind: Some(init_kind),\n+                    })\n+                }\n+            }\n+        },\n+        StmtKind::Expr(expr) | StmtKind::Semi(expr) => match expr.kind {\n+            ExprKind::Assign(lhs, rhs, _span) => {\n+                if let Some(init_kind) = get_vec_init_kind(cx, rhs) {\n+                    return Some(TargetVec {\n+                        location: VecLocation::Expr(lhs),\n+                        init_kind: Some(init_kind),\n+                    });\n+                }\n+            },\n+            ExprKind::MethodCall(path, _, [self_expr, _], _) if is_reserve(cx, path, self_expr) => {\n+                return Some(TargetVec {\n+                    location: VecLocation::Expr(self_expr),\n+                    init_kind: None,\n+                });\n+            },\n+            _ => (),\n+        },\n+        StmtKind::Item(_) => (),\n+    }\n+    None\n+}\n+\n+fn is_reserve(cx: &LateContext<'_>, path: &PathSegment<'_>, self_expr: &Expr<'_>) -> bool {\n+    is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(self_expr).peel_refs(), sym::Vec)\n+        && path.ident.name.as_str() == \"reserve\"\n+}\n+\n+/// Returns self if the expression is `Vec::set_len()`\n+fn extract_set_len_self(cx: &LateContext<'_>, expr: &'tcx Expr<'_>) -> Option<(&'tcx Expr<'tcx>, Span)> {\n+    // peel unsafe blocks in `unsafe { vec.set_len() }`\n+    let expr = peel_hir_expr_while(expr, |e| {\n+        if let ExprKind::Block(block, _) = e.kind {\n+            // Extract the first statement/expression\n+            match (block.stmts.get(0).map(|stmt| &stmt.kind), block.expr) {\n+                (None, Some(expr)) => Some(expr),\n+                (Some(StmtKind::Expr(expr) | StmtKind::Semi(expr)), _) => Some(expr),\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    });\n+    match expr.kind {\n+        ExprKind::MethodCall(path, _, [self_expr, _], _) => {\n+            let self_type = cx.typeck_results().expr_ty(self_expr).peel_refs();\n+            if is_type_diagnostic_item(cx, self_type, sym::Vec) && path.ident.name.as_str() == \"set_len\" {\n+                Some((self_expr, expr.span))\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}"}, {"sha": "b92b6ca4f4380f981ee9f9ed163d44470994555c", "filename": "clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 6, "deletions": 46, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "patch": "@@ -1,16 +1,14 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher::{get_vec_init_kind, VecInitKind};\n use clippy_utils::source::snippet;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{match_def_path, path_to_local, path_to_local_id, paths};\n+use clippy_utils::{path_to_local, path_to_local_id};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Local, PatKind, QPath, Stmt, StmtKind};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, Local, PatKind, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{symbol::sym, Span};\n-use std::convert::TryInto;\n+use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -41,11 +39,6 @@ pub struct VecInitThenPush {\n     searcher: Option<VecPushSearcher>,\n }\n \n-#[derive(Clone, Copy)]\n-enum VecInitKind {\n-    New,\n-    WithCapacity(u64),\n-}\n struct VecPushSearcher {\n     local_id: HirId,\n     init: VecInitKind,\n@@ -58,7 +51,8 @@ impl VecPushSearcher {\n     fn display_err(&self, cx: &LateContext<'_>) {\n         match self.init {\n             _ if self.found == 0 => return,\n-            VecInitKind::WithCapacity(x) if x > self.found => return,\n+            VecInitKind::WithLiteralCapacity(x) if x > self.found => return,\n+            VecInitKind::WithExprCapacity(_) => return,\n             _ => (),\n         };\n \n@@ -152,37 +146,3 @@ impl LateLintPass<'_> for VecInitThenPush {\n         }\n     }\n }\n-\n-fn get_vec_init_kind<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<VecInitKind> {\n-    if let ExprKind::Call(func, args) = expr.kind {\n-        match func.kind {\n-            ExprKind::Path(QPath::TypeRelative(ty, name))\n-                if is_type_diagnostic_item(cx, cx.typeck_results().node_type(ty.hir_id), sym::Vec) =>\n-            {\n-                if name.ident.name == sym::new {\n-                    return Some(VecInitKind::New);\n-                } else if name.ident.name.as_str() == \"with_capacity\" {\n-                    return args.get(0).and_then(|arg| {\n-                        if_chain! {\n-                            if let ExprKind::Lit(lit) = &arg.kind;\n-                            if let LitKind::Int(num, _) = lit.node;\n-                            then {\n-                                Some(VecInitKind::WithCapacity(num.try_into().ok()?))\n-                            } else {\n-                                None\n-                            }\n-                        }\n-                    });\n-                }\n-            }\n-            ExprKind::Path(QPath::Resolved(_, path))\n-                if match_def_path(cx, path.res.opt_def_id()?, &paths::DEFAULT_TRAIT_METHOD)\n-                    && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Vec) =>\n-            {\n-                return Some(VecInitKind::New);\n-            }\n-            _ => (),\n-        }\n-    }\n-    None\n-}"}, {"sha": "1ff282de9509730c03e738fc4ef0f5e16b8f59ee", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "patch": "@@ -2,13 +2,16 @@\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n+use crate::ty::is_type_diagnostic_item;\n use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitKind};\n use rustc_hir as hir;\n-use rustc_hir::{Arm, Block, BorrowKind, Expr, ExprKind, LoopSource, MatchSource, Node, Pat, StmtKind, UnOp};\n+use rustc_hir::{\n+    Arm, Block, BorrowKind, Expr, ExprKind, HirId, LoopSource, MatchSource, Node, Pat, QPath, StmtKind, UnOp,\n+};\n use rustc_lint::LateContext;\n-use rustc_span::{sym, ExpnKind, Span, Symbol};\n+use rustc_span::{sym, symbol, ExpnKind, Span, Symbol};\n \n /// The essential nodes of a desugared for loop as well as the entire span:\n /// `for pat in arg { body }` becomes `(pat, arg, body)`. Return `(pat, arg, body, span)`.\n@@ -632,3 +635,51 @@ impl PanicExpn<'tcx> {\n         }\n     }\n }\n+\n+/// A parsed `Vec` initialization expression\n+#[derive(Clone, Copy)]\n+pub enum VecInitKind {\n+    /// `Vec::new()`\n+    New,\n+    /// `Vec::default()` or `Default::default()`\n+    Default,\n+    /// `Vec::with_capacity(123)`\n+    WithLiteralCapacity(u64),\n+    /// `Vec::with_capacity(slice.len())`\n+    WithExprCapacity(HirId),\n+}\n+\n+/// Checks if given expression is an initialization of `Vec` and returns its kind.\n+pub fn get_vec_init_kind<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<VecInitKind> {\n+    if let ExprKind::Call(func, args) = expr.kind {\n+        match func.kind {\n+            ExprKind::Path(QPath::TypeRelative(ty, name))\n+                if is_type_diagnostic_item(cx, cx.typeck_results().node_type(ty.hir_id), sym::Vec) =>\n+            {\n+                if name.ident.name == sym::new {\n+                    return Some(VecInitKind::New);\n+                } else if name.ident.name == symbol::kw::Default {\n+                    return Some(VecInitKind::Default);\n+                } else if name.ident.name.as_str() == \"with_capacity\" {\n+                    let arg = args.get(0)?;\n+                    if_chain! {\n+                        if let ExprKind::Lit(lit) = &arg.kind;\n+                        if let LitKind::Int(num, _) = lit.node;\n+                        then {\n+                            return Some(VecInitKind::WithLiteralCapacity(num.try_into().ok()?))\n+                        }\n+                    }\n+                    return Some(VecInitKind::WithExprCapacity(arg.hir_id));\n+                }\n+            }\n+            ExprKind::Path(QPath::Resolved(_, path))\n+                if match_def_path(cx, path.res.opt_def_id()?, &paths::DEFAULT_TRAIT_METHOD)\n+                    && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Vec) =>\n+            {\n+                return Some(VecInitKind::Default);\n+            }\n+            _ => (),\n+        }\n+    }\n+    None\n+}"}, {"sha": "ca64ac7de3eea4b98fd9f609a82d153008dbc9df", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "patch": "@@ -367,3 +367,13 @@ pub fn same_type_and_consts(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         _ => a == b,\n     }\n }\n+\n+/// Checks if a given type looks safe to be uninitialized.\n+pub fn is_uninit_value_valid_for_ty(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n+    match ty.kind() {\n+        ty::Array(component, _) => is_uninit_value_valid_for_ty(cx, component),\n+        ty::Tuple(types) => types.types().all(|ty| is_uninit_value_valid_for_ty(cx, ty)),\n+        ty::Adt(adt, _) => cx.tcx.lang_items().maybe_uninit() == Some(adt.did),\n+        _ => false,\n+    }\n+}"}, {"sha": "dc150cf28f2cce48b79d9df965539d5482cc445f", "filename": "tests/ui/uninit_vec.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/tests%2Fui%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/tests%2Fui%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit_vec.rs?ref=3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "patch": "@@ -0,0 +1,94 @@\n+#![warn(clippy::uninit_vec)]\n+\n+use std::mem::MaybeUninit;\n+\n+#[derive(Default)]\n+struct MyVec {\n+    vec: Vec<u8>,\n+}\n+\n+fn main() {\n+    // with_capacity() -> set_len() should be detected\n+    let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n+    // reserve() -> set_len() should be detected\n+    vec.reserve(1000);\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n+    // new() -> set_len() should be detected\n+    let mut vec: Vec<u8> = Vec::new();\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n+    // default() -> set_len() should be detected\n+    let mut vec: Vec<u8> = Default::default();\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n+    let mut vec: Vec<u8> = Vec::default();\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n+    // test when both calls are enclosed in the same unsafe block\n+    unsafe {\n+        let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+        vec.set_len(200);\n+\n+        vec.reserve(1000);\n+        vec.set_len(200);\n+    }\n+\n+    let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+    unsafe {\n+        // test the case where there are other statements in the following unsafe block\n+        vec.set_len(200);\n+        assert!(vec.len() == 200);\n+    }\n+\n+    // handle vec stored in the field of a struct\n+    let mut my_vec = MyVec::default();\n+    my_vec.vec.reserve(1000);\n+    unsafe {\n+        my_vec.vec.set_len(200);\n+    }\n+\n+    my_vec.vec = Vec::with_capacity(1000);\n+    unsafe {\n+        my_vec.vec.set_len(200);\n+    }\n+\n+    // Test `#[allow(...)]` attributes on inner unsafe block (shouldn't trigger)\n+    let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+    #[allow(clippy::uninit_vec)]\n+    unsafe {\n+        vec.set_len(200);\n+    }\n+\n+    // MaybeUninit-wrapped types should not be detected\n+    unsafe {\n+        let mut vec: Vec<MaybeUninit<u8>> = Vec::with_capacity(1000);\n+        vec.set_len(200);\n+\n+        let mut vec: Vec<(MaybeUninit<u8>, MaybeUninit<bool>)> = Vec::with_capacity(1000);\n+        vec.set_len(200);\n+\n+        let mut vec: Vec<(MaybeUninit<u8>, [MaybeUninit<bool>; 2])> = Vec::with_capacity(1000);\n+        vec.set_len(200);\n+    }\n+\n+    // known false negative\n+    let mut vec1: Vec<u8> = Vec::with_capacity(1000);\n+    let mut vec2: Vec<u8> = Vec::with_capacity(1000);\n+    unsafe {\n+        vec1.set_len(200);\n+        vec2.set_len(200);\n+    }\n+}"}, {"sha": "520bfb26b62e1b7c23c521cb859113fb31aa540e", "filename": "tests/ui/uninit_vec.stderr", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/tests%2Fui%2Funinit_vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3d9c4a655b04e9616ded8374dc61cb9108f4ae06/tests%2Fui%2Funinit_vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit_vec.stderr?ref=3d9c4a655b04e9616ded8374dc61cb9108f4ae06", "patch": "@@ -0,0 +1,105 @@\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:12:5\n+   |\n+LL |     let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::uninit-vec` implied by `-D warnings`\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:18:5\n+   |\n+LL |     vec.reserve(1000);\n+   |     ^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: calling `set_len()` on empty `Vec` creates out-of-bound values\n+  --> $DIR/uninit_vec.rs:24:5\n+   |\n+LL |     let mut vec: Vec<u8> = Vec::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: calling `set_len()` on empty `Vec` creates out-of-bound values\n+  --> $DIR/uninit_vec.rs:30:5\n+   |\n+LL |     let mut vec: Vec<u8> = Default::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: calling `set_len()` on empty `Vec` creates out-of-bound values\n+  --> $DIR/uninit_vec.rs:35:5\n+   |\n+LL |     let mut vec: Vec<u8> = Vec::default();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:49:5\n+   |\n+LL |     let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:58:5\n+   |\n+LL |     my_vec.vec.reserve(1000);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {\n+LL |         my_vec.vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:63:5\n+   |\n+LL |     my_vec.vec = Vec::with_capacity(1000);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     unsafe {\n+LL |         my_vec.vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:42:9\n+   |\n+LL |         let mut vec: Vec<u8> = Vec::with_capacity(1000);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+  --> $DIR/uninit_vec.rs:45:9\n+   |\n+LL |         vec.reserve(1000);\n+   |         ^^^^^^^^^^^^^^^^^^\n+LL |         vec.set_len(200);\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: initialize the buffer or wrap the content in `MaybeUninit`\n+\n+error: aborting due to 10 previous errors\n+"}]}