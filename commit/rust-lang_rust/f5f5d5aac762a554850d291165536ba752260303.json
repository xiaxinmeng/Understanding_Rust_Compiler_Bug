{"sha": "f5f5d5aac762a554850d291165536ba752260303", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZjVkNWFhYzc2MmE1NTQ4NTBkMjkxMTY1NTM2YmE3NTIyNjAzMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-19T05:51:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-19T05:51:31Z"}, "message": "auto merge of #10479 : alexcrichton/rust/native-mutex.rs, r=cmr\n\nThis adds a new `std::unstable::mutex` module which contains bindings to the platform-provided mutexes. This module is pretty much entirely unsafe to use, but is critical for the runtime and dropping our C++ dependency.\r\n\r\nThe actual implementation is to do a compare-and-swap on an initially uninitialized pointer. Pthreads does allow for static initialization, so this wouldn't be necessary if we had all the proper headers and whatnot, but windows it looks like will always require some sort of compare-and-swap operation. For now, I didn't want to have to define all the pthreads headers, so I continue to just malloc the pthreads lock/cvar.\r\n\r\nAfter this, there's only one remaining C++ component of rust, and that's unwinding.", "tree": {"sha": "56afc4b9b834d4496c175a3ab701823dbba72e15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56afc4b9b834d4496c175a3ab701823dbba72e15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5f5d5aac762a554850d291165536ba752260303", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5f5d5aac762a554850d291165536ba752260303", "html_url": "https://github.com/rust-lang/rust/commit/f5f5d5aac762a554850d291165536ba752260303", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5f5d5aac762a554850d291165536ba752260303/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab7fe9dd06e93986f6b11512031c891059474653", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7fe9dd06e93986f6b11512031c891059474653", "html_url": "https://github.com/rust-lang/rust/commit/ab7fe9dd06e93986f6b11512031c891059474653"}, {"sha": "508b7b996e5d557ec1c49e1d11563ecf4fc9d287", "url": "https://api.github.com/repos/rust-lang/rust/commits/508b7b996e5d557ec1c49e1d11563ecf4fc9d287", "html_url": "https://github.com/rust-lang/rust/commit/508b7b996e5d557ec1c49e1d11563ecf4fc9d287"}], "stats": {"total": 1435, "additions": 695, "deletions": 740}, "files": [{"sha": "dc2aefeb8653475587559a1acac443131e9bc2c7", "filename": "mk/clean.mk", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -12,13 +12,19 @@\n # Cleanup\n ######################################################################\n \n-CLEAN_STAGE_RULES =\t\t\t\t\t\t\t\t\\\n- $(foreach stage, $(STAGES),\t\t\t\t\t\\\n-  $(foreach host, $(CFG_HOST),\t\t\\\n+CLEAN_STAGE_RULES :=\t\t\t\t\t\t\t\\\n+ $(foreach stage, $(STAGES),\t\t\t\t\t\t\\\n+  $(foreach host, $(CFG_HOST),\t\t\t\t\t\t\\\n    clean$(stage)_H_$(host)\t\t\t\t\t\t\\\n-   $(foreach target, $(CFG_TARGET),\t\t\\\n+   $(foreach target, $(CFG_TARGET),\t\t\t\t\t\\\n     clean$(stage)_T_$(target)_H_$(host))))\n \n+CLEAN_STAGE_RULES := $(CLEAN_STAGE_RULES)\t\t\t\t\\\n+    $(foreach host, $(CFG_HOST), clean-generic-H-$(host))\n+\n+CLEAN_STAGE_RULES := $(CLEAN_STAGE_RULES)\t\t\t\t\\\n+    $(foreach host, $(CFG_TARGET), clean-generic-T-$(host))\n+\n CLEAN_LLVM_RULES = \t\t\t\t\t\t\t\t\\\n  $(foreach target, $(CFG_HOST),\t\t\\\n   clean-llvm$(target))\n@@ -33,19 +39,6 @@ clean: clean-misc $(CLEAN_STAGE_RULES)\n \n clean-misc:\n \t@$(call E, cleaning)\n-\t$(Q)find $(CFG_BUILD)/rustllvm \\\n-\t         $(CFG_BUILD)/rt \\\n-\t\t $(CFG_BUILD)/test \\\n-         -name '*.[odasS]' -o \\\n-         -name '*.so' -o      \\\n-         -name '*.dylib' -o   \\\n-         -name '*.dll' -o     \\\n-         -name '*.def' -o     \\\n-         -name '*.bc'         \\\n-         | xargs rm -f\n-\t$(Q)find $(CFG_BUILD)\\\n-         -name '*.dSYM'       \\\n-         | xargs rm -Rf\n \t$(Q)rm -f $(RUNTIME_OBJS) $(RUNTIME_DEF)\n \t$(Q)rm -f $(RUSTLLVM_LIB_OBJS) $(RUSTLLVM_OBJS_OBJS) $(RUSTLLVM_DEF)\n \t$(Q)rm -Rf $(DOCS)\n@@ -60,6 +53,27 @@ clean-misc:\n \t$(Q)rm -Rf $(foreach sub, index styles files search javascript, \\\n                  $(wildcard doc/*/$(sub)))\n \n+define CLEAN_GENERIC\n+\n+clean-generic-$(2)-$(1):\n+\t$(Q)find $(1)/rustllvm \\\n+\t         $(1)/rt \\\n+\t\t $(1)/test \\\n+         -name '*.[odasS]' -o \\\n+         -name '*.so' -o      \\\n+         -name '*.dylib' -o   \\\n+         -name '*.dll' -o     \\\n+         -name '*.def' -o     \\\n+         -name '*.bc'         \\\n+         | xargs rm -f\n+\t$(Q)find $(1)\\\n+         -name '*.dSYM'       \\\n+         | xargs rm -Rf\n+endef\n+\n+$(foreach host, $(CFG_HOST), $(eval $(call CLEAN_GENERIC,$(host),H)))\n+$(foreach targ, $(CFG_TARGET), $(eval $(call CLEAN_GENERIC,$(targ),T)))\n+\n define CLEAN_HOST_STAGE_N\n \n clean$(1)_H_$(2):"}, {"sha": "622f85302d3c0d136a56fd929f27edfe220e99a2", "filename": "mk/platform.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -206,7 +206,7 @@ CFG_LIB_GLOB_arm-apple-darwin = lib$(1)-*.dylib\n CFG_LIB_DSYM_GLOB_arm-apple-darwin = lib$(1)-*.dylib.dSYM\n CFG_GCCISH_CFLAGS_arm-apple-darwin := -Wall -Werror -g -fPIC $(CFG_IOS_FLAGS)\n CFG_GCCISH_CXXFLAGS_arm-apple-darwin := -fno-rtti $(CFG_IOS_FLAGS)\n-CFG_GCCISH_LINK_FLAGS_arm-apple-darwin := -dynamiclib -lpthread -framework CoreServices -Wl,-no_compact_unwind \n+CFG_GCCISH_LINK_FLAGS_arm-apple-darwin := -dynamiclib -lpthread -framework CoreServices -Wl,-no_compact_unwind\n CFG_GCCISH_DEF_FLAG_arm-apple-darwin := -Wl,-exported_symbols_list,\n CFG_GCCISH_PRE_LIB_FLAGS_arm-apple-darwin :=\n CFG_GCCISH_POST_LIB_FLAGS_arm-apple-darwin :=\n@@ -506,7 +506,7 @@ define CFG_MAKE_TOOLCHAIN\n         -c -o $$(1) $$(2)\n   CFG_LINK_C_$(1) = $$(CC_$(1)) \\\n         $$(CFG_GCCISH_LINK_FLAGS) -o $$(1)          \\\n-        $$(CFG_GCCISH_LINK_FLAGS_$(1)))             \\\n+        $$(CFG_GCCISH_LINK_FLAGS_$(1))              \\\n         $$(CFG_GCCISH_DEF_FLAG_$(1))$$(3) $$(2)     \\\n         $$(call CFG_INSTALL_NAME_$(1),$$(4))\n   CFG_COMPILE_CXX_$(1) = $$(CXX_$(1)) \\"}, {"sha": "94de05d0eaf11704605574becd366d3c6abcd60a", "filename": "mk/rt.mk", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -90,14 +90,18 @@ endif\n endif\n \n RUNTIME_CXXS_$(1)_$(2) := \\\n-              rt/sync/lock_and_signal.cpp \\\n-              rt/rust_builtin.cpp \\\n-              rt/rust_upcall.cpp \\\n-              rt/miniz.cpp \\\n-              rt/rust_android_dummy.cpp \\\n-              rt/rust_test_helpers.cpp\n+\t      rt/rust_cxx_glue.cpp\n \n-RUNTIME_CS_$(1)_$(2) :=\n+RUNTIME_CS_$(1)_$(2) := \\\n+              rt/rust_builtin.c \\\n+              rt/rust_upcall.c \\\n+              rt/miniz.c \\\n+              rt/rust_android_dummy.c \\\n+              rt/rust_test_helpers.c\n+\n+# stage0 remove this after the next snapshot\n+%.cpp:\n+\t@touch tmp/foo.o\n \n RUNTIME_S_$(1)_$(2) := rt/arch/$$(HOST_$(1))/_context.S \\\n \t\t\trt/arch/$$(HOST_$(1))/record_sp.S\n@@ -115,7 +119,7 @@ ALL_OBJ_FILES += $$(RUNTIME_OBJS_$(1)_$(2))\n MORESTACK_OBJS_$(1)_$(2) := $$(RT_BUILD_DIR_$(1)_$(2))/arch/$$(HOST_$(1))/morestack.o\n ALL_OBJ_FILES += $$(MORESTACK_OBJS_$(1)_$(2))\n \n-$$(RT_BUILD_DIR_$(1)_$(2))/%.o: rt/%.cpp $$(MKFILE_DEPS)\n+$$(RT_BUILD_DIR_$(1)_$(2))/rust_cxx_glue.o: rt/rust_cxx_glue.cpp $$(MKFILE_DEPS)\n \t@$$(call E, compile: $$@)\n \t$$(Q)$$(call CFG_COMPILE_CXX_$(1), $$@, $$(RUNTIME_INCS_$(1)_$(2)) \\\n                  $$(SNAP_DEFINES) $$(RUNTIME_CXXFLAGS_$(1)_$(2))) $$<\n@@ -242,13 +246,13 @@ endif\n UV_SUPPORT_NAME_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),uv_support)\n UV_SUPPORT_DIR_$(1) := $$(RT_OUTPUT_DIR_$(1))/uv_support\n UV_SUPPORT_LIB_$(1) := $$(UV_SUPPORT_DIR_$(1))/$$(UV_SUPPORT_NAME_$(1))\n-UV_SUPPORT_CS_$(1) := rt/rust_uv.cpp\n-UV_SUPPORT_OBJS_$(1) := $$(UV_SUPPORT_CS_$(1):rt/%.cpp=$$(UV_SUPPORT_DIR_$(1))/%.o)\n+UV_SUPPORT_CS_$(1) := rt/rust_uv.c\n+UV_SUPPORT_OBJS_$(1) := $$(UV_SUPPORT_CS_$(1):rt/%.c=$$(UV_SUPPORT_DIR_$(1))/%.o)\n \n-$$(UV_SUPPORT_DIR_$(1))/%.o: rt/%.cpp\n+$$(UV_SUPPORT_DIR_$(1))/%.o: rt/%.c\n \t@$$(call E, compile: $$@)\n \t@mkdir -p $$(@D)\n-\t$$(Q)$$(call CFG_COMPILE_CXX_$(1), $$@, \\\n+\t$$(Q)$$(call CFG_COMPILE_C_$(1), $$@, \\\n \t\t-I $$(S)src/libuv/include \\\n                  $$(RUNTIME_CFLAGS_$(1))) $$<\n "}, {"sha": "3ea6e18f9427c6a4eea973087f59311c08f0c46b", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -138,21 +138,19 @@ Accessing environment variables is not generally threadsafe.\n Serialize access through a global lock.\n */\n fn with_env_lock<T>(f: &fn() -> T) -> T {\n+    use unstable::mutex::{Mutex, MUTEX_INIT};\n     use unstable::finally::Finally;\n \n+    static mut lock: Mutex = MUTEX_INIT;\n+\n     unsafe {\n         return do (|| {\n-            rust_take_env_lock();\n+            lock.lock();\n             f()\n         }).finally {\n-            rust_drop_env_lock();\n+            lock.unlock();\n         };\n     }\n-\n-    extern {\n-        fn rust_take_env_lock();\n-        fn rust_drop_env_lock();\n-    }\n }\n \n /// Returns a vector of (variable, value) pairs for all the environment"}, {"sha": "0d32d2d7dbae0e09eb00200347d9b3ead26decac", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -21,46 +21,60 @@\n //! FIXME #7756: This has a lot of C glue for lack of globals.\n \n use option::Option;\n+#[cfg(test)] use option::{Some, None};\n+#[cfg(test)] use realstd;\n+#[cfg(test)] use realargs = realstd::rt::args;\n \n /// One-time global initialization.\n-pub unsafe fn init(argc: int, argv: **u8) {\n-    imp::init(argc, argv)\n-}\n+#[cfg(not(test))]\n+pub unsafe fn init(argc: int, argv: **u8) { imp::init(argc, argv) }\n+#[cfg(test)]\n+pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }\n \n /// One-time global cleanup.\n-pub fn cleanup() {\n-    imp::cleanup()\n-}\n+#[cfg(not(test))] pub fn cleanup() { imp::cleanup() }\n+#[cfg(test)]      pub fn cleanup() { realargs::cleanup() }\n \n /// Take the global arguments from global storage.\n-pub fn take() -> Option<~[~str]> {\n-    imp::take()\n+#[cfg(not(test))] pub fn take() -> Option<~[~str]> { imp::take() }\n+#[cfg(test)]      pub fn take() -> Option<~[~str]> {\n+    match realargs::take() {\n+        realstd::option::Some(a) => Some(a),\n+        realstd::option::None => None,\n+    }\n }\n \n /// Give the global arguments to global storage.\n ///\n /// It is an error if the arguments already exist.\n-pub fn put(args: ~[~str]) {\n-    imp::put(args)\n-}\n+#[cfg(not(test))] pub fn put(args: ~[~str]) { imp::put(args) }\n+#[cfg(test)]      pub fn put(args: ~[~str]) { realargs::put(args) }\n \n /// Make a clone of the global arguments.\n-pub fn clone() -> Option<~[~str]> {\n-    imp::clone()\n+#[cfg(not(test))] pub fn clone() -> Option<~[~str]> { imp::clone() }\n+#[cfg(test)]      pub fn clone() -> Option<~[~str]> {\n+    match realargs::clone() {\n+        realstd::option::Some(a) => Some(a),\n+        realstd::option::None => None,\n+    }\n }\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"freebsd\")]\n mod imp {\n+    use cast;\n     use libc;\n     use option::{Option, Some, None};\n     use iter::Iterator;\n     use str;\n     use unstable::finally::Finally;\n+    use unstable::mutex::{Mutex, MUTEX_INIT};\n     use util;\n     use vec;\n \n+    static mut global_args_ptr: uint = 0;\n+\n     pub unsafe fn init(argc: int, argv: **u8) {\n         let args = load_argc_and_argv(argc, argv);\n         put(args);\n@@ -94,20 +108,22 @@ mod imp {\n     }\n \n     fn with_lock<T>(f: &fn() -> T) -> T {\n+        static mut lock: Mutex = MUTEX_INIT;\n+\n         do (|| {\n             unsafe {\n-                rust_take_global_args_lock();\n+                lock.lock();\n                 f()\n             }\n         }).finally {\n             unsafe {\n-                rust_drop_global_args_lock();\n+                lock.unlock();\n             }\n         }\n     }\n \n     fn get_global_ptr() -> *mut Option<~~[~str]> {\n-        unsafe { rust_get_global_args_ptr() }\n+        unsafe { cast::transmute(&global_args_ptr) }\n     }\n \n     // Copied from `os`.\n@@ -117,12 +133,6 @@ mod imp {\n         }\n     }\n \n-    extern {\n-        fn rust_take_global_args_lock();\n-        fn rust_drop_global_args_lock();\n-        fn rust_get_global_args_ptr() -> *mut Option<~~[~str]>;\n-    }\n-\n     #[cfg(test)]\n     mod tests {\n         use option::{Some, None};"}, {"sha": "d5d1931a21725595affa8ba3580bf612b12d8f66", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -21,17 +21,23 @@ use ptr;\n use cell::Cell;\n use option::{Option, Some, None};\n use unstable::finally::Finally;\n+use unstable::mutex::{Mutex, MUTEX_INIT};\n use tls = rt::thread_local_storage;\n \n static mut RT_TLS_KEY: tls::Key = -1;\n \n /// Initialize the TLS key. Other ops will fail if this isn't executed first.\n pub fn init_tls_key() {\n+    static mut lock: Mutex = MUTEX_INIT;\n+    static mut initialized: bool = false;\n+\n     unsafe {\n-        rust_initialize_rt_tls_key(&mut RT_TLS_KEY);\n-        extern {\n-            fn rust_initialize_rt_tls_key(key: *mut tls::Key);\n+        lock.lock();\n+        if !initialized {\n+            tls::create(&mut RT_TLS_KEY);\n+            initialized = true;\n         }\n+        lock.unlock();\n     }\n }\n "}, {"sha": "c1a7893f5a5c1c85c59f6382d02c27a58addc6ed", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -14,7 +14,6 @@ use cell::Cell;\n use clone::Clone;\n use container::Container;\n use iter::{Iterator, range};\n-use libc;\n use option::{Some, None};\n use os;\n use path::GenericPath;\n@@ -361,11 +360,16 @@ pub fn cleanup_task(mut task: ~Task) {\n \n /// Get a port number, starting at 9600, for use in tests\n pub fn next_test_port() -> u16 {\n+    use unstable::mutex::{Mutex, MUTEX_INIT};\n+    static mut lock: Mutex = MUTEX_INIT;\n+    static mut next_offset: u16 = 0;\n     unsafe {\n-        return rust_dbg_next_port(base_port() as libc::uintptr_t) as u16;\n-    }\n-    extern {\n-        fn rust_dbg_next_port(base: libc::uintptr_t) -> libc::uintptr_t;\n+        let base = base_port();\n+        lock.lock();\n+        let ret = base + next_offset;\n+        next_offset += 1;\n+        lock.unlock();\n+        return ret;\n     }\n }\n \n@@ -395,13 +399,13 @@ The bots run multiple builds at the same time, and these builds\n all want to use ports. This function figures out which workspace\n it is running in and assigns a port range based on it.\n */\n-fn base_port() -> uint {\n+fn base_port() -> u16 {\n     use os;\n     use str::StrSlice;\n     use vec::ImmutableVector;\n \n-    let base = 9600u;\n-    let range = 1000;\n+    let base = 9600u16;\n+    let range = 1000u16;\n \n     let bases = [\n         (\"32-opt\", base + range * 1),"}, {"sha": "5a2251eaa461e5a446ca37eb9aaa7ba4c881d7a0", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -1141,22 +1141,10 @@ fn test_spawn_sched_childs_on_default_sched() {\n     po.recv();\n }\n \n-#[cfg(test)]\n-mod testrt {\n-    use libc;\n-\n-    extern {\n-        pub fn rust_dbg_lock_create() -> *libc::c_void;\n-        pub fn rust_dbg_lock_destroy(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_lock(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_unlock(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_wait(lock: *libc::c_void);\n-        pub fn rust_dbg_lock_signal(lock: *libc::c_void);\n-    }\n-}\n-\n #[test]\n fn test_spawn_sched_blocking() {\n+    use unstable::mutex::Mutex;\n+\n     unsafe {\n \n         // Testing that a task in one scheduler can block in foreign code\n@@ -1165,16 +1153,18 @@ fn test_spawn_sched_blocking() {\n             let (start_po, start_ch) = stream();\n             let (fin_po, fin_ch) = stream();\n \n-            let lock = testrt::rust_dbg_lock_create();\n+            let mut lock = Mutex::new();\n+            let lock2 = Cell::new(lock.clone());\n \n             do spawn_sched(SingleThreaded) {\n-                testrt::rust_dbg_lock_lock(lock);\n+                let mut lock = lock2.take();\n+                lock.lock();\n \n                 start_ch.send(());\n \n                 // Block the scheduler thread\n-                testrt::rust_dbg_lock_wait(lock);\n-                testrt::rust_dbg_lock_unlock(lock);\n+                lock.wait();\n+                lock.unlock();\n \n                 fin_ch.send(());\n             };\n@@ -1201,11 +1191,11 @@ fn test_spawn_sched_blocking() {\n             let child_ch = setup_po.recv();\n             child_ch.send(20);\n             pingpong(&parent_po, &child_ch);\n-            testrt::rust_dbg_lock_lock(lock);\n-            testrt::rust_dbg_lock_signal(lock);\n-            testrt::rust_dbg_lock_unlock(lock);\n+            lock.lock();\n+            lock.signal();\n+            lock.unlock();\n             fin_po.recv();\n-            testrt::rust_dbg_lock_destroy(lock);\n+            lock.destroy();\n         }\n     }\n }"}, {"sha": "e0d284a32df1ef47524a9bb188378df8b22e6a5a", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -154,14 +154,17 @@ pub mod dl {\n     }\n \n     pub fn check_for_errors_in<T>(f: &fn()->T) -> Result<T, ~str> {\n+        use unstable::mutex::{Mutex, MUTEX_INIT};\n+        static mut lock: Mutex = MUTEX_INIT;\n+\n         unsafe {\n             // dlerror isn't thread safe, so we need to lock around this entire\n             // sequence. `atomically` asserts that we don't do anything that\n             // would cause this task to be descheduled, which could deadlock\n             // the scheduler if it happens while the lock is held.\n             // FIXME #9105 use a Rust mutex instead of C++ mutexes.\n             do atomically {\n-                rust_take_dlerror_lock();\n+                lock.lock();\n                 let _old_error = dlerror();\n \n                 let result = f();\n@@ -172,7 +175,7 @@ pub mod dl {\n                 } else {\n                     Err(str::raw::from_c_str(last_error))\n                 };\n-                rust_drop_dlerror_lock();\n+                lock.unlock();\n                 ret\n             }\n         }\n@@ -192,11 +195,6 @@ pub mod dl {\n         Local = 0,\n     }\n \n-    extern {\n-        fn rust_take_dlerror_lock();\n-        fn rust_drop_dlerror_lock();\n-    }\n-\n     #[link_name = \"dl\"]\n     extern {\n         fn dlopen(filename: *libc::c_char, flag: libc::c_int) -> *libc::c_void;"}, {"sha": "9b8c81979a90e31d98247f171cccc55f853a248c", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -24,6 +24,7 @@ pub mod simd;\n #[cfg(not(test))]\n pub mod lang;\n pub mod sync;\n+pub mod mutex;\n pub mod atomics;\n pub mod raw;\n "}, {"sha": "5be9be7bf8a9907226a720c6442caabfadf005d9", "filename": "src/libstd/unstable/mutex.rs", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -0,0 +1,336 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A native mutex and condition variable type\n+//!\n+//! This module contains bindings to the platform's native mutex/condition\n+//! variable primitives. It provides a single type, `Mutex`, which can be\n+//! statically initialized via the `MUTEX_INIT` value. This object serves as both a\n+//! mutex and a condition variable simultaneously.\n+//!\n+//! The lock is lazily initialized, but it can only be unsafely destroyed. A\n+//! statically initialized lock doesn't necessarily have a time at which it can\n+//! get deallocated. For this reason, there is no `Drop` implementation of the\n+//! mutex, but rather the `destroy()` method must be invoked manually if\n+//! destruction of the mutex is desired.\n+//!\n+//! It is not recommended to use this type for idiomatic rust use. This type is\n+//! appropriate where no other options are available, but other rust concurrency\n+//! primitives should be used before this type.\n+//!\n+//! # Example\n+//!\n+//!     use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+//!\n+//!     // Use a statically initialized mutex\n+//!     static mut lock: Mutex = MUTEX_INIT;\n+//!\n+//!     unsafe {\n+//!         lock.lock();\n+//!         lock.unlock();\n+//!     }\n+//!\n+//!     // Use a normally initialied mutex\n+//!     let mut lock = Mutex::new();\n+//!     unsafe {\n+//!         lock.lock();\n+//!         lock.unlock();\n+//!         lock.destroy();\n+//!     }\n+\n+#[allow(non_camel_case_types)];\n+\n+use libc::c_void;\n+use unstable::atomics;\n+\n+pub struct Mutex {\n+    // pointers for the lock/cond handles, atomically updated\n+    priv lock: atomics::AtomicUint,\n+    priv cond: atomics::AtomicUint,\n+}\n+\n+pub static MUTEX_INIT: Mutex = Mutex {\n+    lock: atomics::INIT_ATOMIC_UINT,\n+    cond: atomics::INIT_ATOMIC_UINT,\n+};\n+\n+impl Mutex {\n+    /// Creates a new mutex, with the lock/condition variable pre-initialized\n+    pub unsafe fn new() -> Mutex {\n+        Mutex {\n+            lock: atomics::AtomicUint::new(imp::init_lock() as uint),\n+            cond: atomics::AtomicUint::new(imp::init_cond() as uint),\n+        }\n+    }\n+\n+    /// Creates a new copy of this mutex. This is an unsafe operation because\n+    /// there is no reference counting performed on this type.\n+    ///\n+    /// This function may only be called on mutexes which have had both the\n+    /// internal condition variable and lock initialized. This means that the\n+    /// mutex must have been created via `new`, or usage of it has already\n+    /// initialized the internal handles.\n+    ///\n+    /// This is a dangerous function to call as both this mutex and the returned\n+    /// mutex will share the same handles to the underlying mutex/condition\n+    /// variable. Care must be taken to ensure that deallocation happens\n+    /// accordingly.\n+    pub unsafe fn clone(&self) -> Mutex {\n+        let lock = self.lock.load(atomics::Relaxed);\n+        let cond = self.cond.load(atomics::Relaxed);\n+        assert!(lock != 0);\n+        assert!(cond != 0);\n+        Mutex {\n+            lock: atomics::AtomicUint::new(lock),\n+            cond: atomics::AtomicUint::new(cond),\n+        }\n+    }\n+\n+    /// Acquires this lock. This assumes that the current thread does not\n+    /// already hold the lock.\n+    pub unsafe fn lock(&mut self) { imp::lock(self.getlock()) }\n+\n+    /// Attempts to acquire the lock. The value returned is whether the lock was\n+    /// acquired or not\n+    pub unsafe fn trylock(&mut self) -> bool { imp::trylock(self.getlock()) }\n+\n+    /// Unlocks the lock. This assumes that the current thread already holds the\n+    /// lock.\n+    pub unsafe fn unlock(&mut self) { imp::unlock(self.getlock()) }\n+\n+    /// Block on the internal condition variable.\n+    ///\n+    /// This function assumes that the lock is already held\n+    pub unsafe fn wait(&mut self) { imp::wait(self.getcond(), self.getlock()) }\n+\n+    /// Signals a thread in `wait` to wake up\n+    pub unsafe fn signal(&mut self) { imp::signal(self.getcond()) }\n+\n+    /// This function is especially unsafe because there are no guarantees made\n+    /// that no other thread is currently holding the lock or waiting on the\n+    /// condition variable contained inside.\n+    pub unsafe fn destroy(&mut self) {\n+        imp::free_lock(self.lock.swap(0, atomics::Relaxed));\n+        imp::free_cond(self.cond.swap(0, atomics::Relaxed));\n+    }\n+\n+    unsafe fn getlock(&mut self) -> *c_void {\n+        match self.lock.load(atomics::Relaxed) {\n+            0 => {}\n+            n => return n as *c_void\n+        }\n+        let lock = imp::init_lock();\n+        match self.lock.compare_and_swap(0, lock, atomics::SeqCst) {\n+            0 => return lock as *c_void,\n+            _ => {}\n+        }\n+        imp::free_lock(lock);\n+        return self.lock.load(atomics::Relaxed) as *c_void;\n+    }\n+\n+    unsafe fn getcond(&mut self) -> *c_void {\n+        match self.cond.load(atomics::Relaxed) {\n+            0 => {}\n+            n => return n as *c_void\n+        }\n+        let cond = imp::init_cond();\n+        match self.cond.compare_and_swap(0, cond, atomics::SeqCst) {\n+            0 => return cond as *c_void,\n+            _ => {}\n+        }\n+        imp::free_cond(cond);\n+        return self.cond.load(atomics::Relaxed) as *c_void;\n+    }\n+}\n+\n+#[cfg(unix)]\n+mod imp {\n+    use libc::c_void;\n+    use libc;\n+    use ptr;\n+\n+    type pthread_mutex_t = libc::c_void;\n+    type pthread_mutexattr_t = libc::c_void;\n+    type pthread_cond_t = libc::c_void;\n+    type pthread_condattr_t = libc::c_void;\n+\n+    pub unsafe fn init_lock() -> uint {\n+        let block = libc::malloc(rust_pthread_mutex_t_size() as libc::size_t);\n+        assert!(!block.is_null());\n+        let n = pthread_mutex_init(block, ptr::null());\n+        assert_eq!(n, 0);\n+        return block as uint;\n+    }\n+\n+    pub unsafe fn init_cond() -> uint {\n+        let block = libc::malloc(rust_pthread_cond_t_size() as libc::size_t);\n+        assert!(!block.is_null());\n+        let n = pthread_cond_init(block, ptr::null());\n+        assert_eq!(n, 0);\n+        return block as uint;\n+    }\n+\n+    pub unsafe fn free_lock(h: uint) {\n+        let block = h as *c_void;\n+        assert_eq!(pthread_mutex_destroy(block), 0);\n+        libc::free(block);\n+    }\n+\n+    pub unsafe fn free_cond(h: uint) {\n+        let block = h as *c_void;\n+        assert_eq!(pthread_cond_destroy(block), 0);\n+        libc::free(block);\n+    }\n+\n+    pub unsafe fn lock(l: *pthread_mutex_t) {\n+        assert_eq!(pthread_mutex_lock(l), 0);\n+    }\n+\n+    pub unsafe fn trylock(l: *c_void) -> bool {\n+        pthread_mutex_trylock(l) == 0\n+    }\n+\n+    pub unsafe fn unlock(l: *pthread_mutex_t) {\n+        assert_eq!(pthread_mutex_unlock(l), 0);\n+    }\n+\n+    pub unsafe fn wait(cond: *pthread_cond_t, m: *pthread_mutex_t) {\n+        assert_eq!(pthread_cond_wait(cond, m), 0);\n+    }\n+\n+    pub unsafe fn signal(cond: *pthread_cond_t) {\n+        assert_eq!(pthread_cond_signal(cond), 0);\n+    }\n+\n+    extern {\n+        fn rust_pthread_mutex_t_size() -> libc::c_int;\n+        fn rust_pthread_cond_t_size() -> libc::c_int;\n+    }\n+\n+    extern {\n+        fn pthread_mutex_init(lock: *pthread_mutex_t,\n+                              attr: *pthread_mutexattr_t) -> libc::c_int;\n+        fn pthread_mutex_destroy(lock: *pthread_mutex_t) -> libc::c_int;\n+        fn pthread_cond_init(cond: *pthread_cond_t,\n+                              attr: *pthread_condattr_t) -> libc::c_int;\n+        fn pthread_cond_destroy(cond: *pthread_cond_t) -> libc::c_int;\n+        fn pthread_mutex_lock(lock: *pthread_mutex_t) -> libc::c_int;\n+        fn pthread_mutex_trylock(lock: *pthread_mutex_t) -> libc::c_int;\n+        fn pthread_mutex_unlock(lock: *pthread_mutex_t) -> libc::c_int;\n+\n+        fn pthread_cond_wait(cond: *pthread_cond_t,\n+                             lock: *pthread_mutex_t) -> libc::c_int;\n+        fn pthread_cond_signal(cond: *pthread_cond_t) -> libc::c_int;\n+    }\n+}\n+\n+#[cfg(windows)]\n+mod imp {\n+    use libc;\n+    use libc::{HANDLE, BOOL, LPSECURITY_ATTRIBUTES, c_void, DWORD, LPCSTR};\n+    use ptr;\n+    type LPCRITICAL_SECTION = *c_void;\n+    static SPIN_COUNT: DWORD = 4000;\n+\n+    pub unsafe fn init_lock() -> uint {\n+        let block = libc::malloc(rust_crit_section_size() as libc::size_t);\n+        assert!(!block.is_null());\n+        InitializeCriticalSectionAndSpinCount(block, SPIN_COUNT);\n+        return block as uint;\n+    }\n+\n+    pub unsafe fn init_cond() -> uint {\n+        return CreateEventA(ptr::mut_null(), libc::FALSE, libc::FALSE,\n+                            ptr::null()) as uint;\n+    }\n+\n+    pub unsafe fn free_lock(h: uint) {\n+        DeleteCriticalSection(h as LPCRITICAL_SECTION);\n+        libc::free(h as *c_void);\n+    }\n+\n+    pub unsafe fn free_cond(h: uint) {\n+        let block = h as HANDLE;\n+        libc::CloseHandle(block);\n+    }\n+\n+    pub unsafe fn lock(l: *c_void) {\n+        EnterCriticalSection(l as LPCRITICAL_SECTION)\n+    }\n+\n+    pub unsafe fn trylock(l: *c_void) -> bool {\n+        TryEnterCriticalSection(l as LPCRITICAL_SECTION) != 0\n+    }\n+\n+    pub unsafe fn unlock(l: *c_void) {\n+        LeaveCriticalSection(l as LPCRITICAL_SECTION)\n+    }\n+\n+    pub unsafe fn wait(cond: *c_void, m: *c_void) {\n+        unlock(m);\n+        WaitForSingleObject(cond as HANDLE, 0);\n+        lock(m);\n+    }\n+\n+    pub unsafe fn signal(cond: *c_void) {\n+        assert!(SetEvent(cond as HANDLE) != 0);\n+    }\n+\n+    extern {\n+        fn rust_crit_section_size() -> libc::c_int;\n+    }\n+\n+    extern \"system\" {\n+        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n+                        bManualReset: BOOL,\n+                        bInitialState: BOOL,\n+                        lpName: LPCSTR) -> HANDLE;\n+        fn InitializeCriticalSectionAndSpinCount(\n+                        lpCriticalSection: LPCRITICAL_SECTION,\n+                        dwSpinCount: DWORD) -> BOOL;\n+        fn DeleteCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n+        fn EnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n+        fn LeaveCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);\n+        fn TryEnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) -> BOOL;\n+        fn SetEvent(hEvent: HANDLE) -> BOOL;\n+        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::{Mutex, MUTEX_INIT};\n+    use rt::thread::Thread;\n+\n+    #[test]\n+    fn somke_lock() {\n+        static mut lock: Mutex = MUTEX_INIT;\n+        unsafe {\n+            lock.lock();\n+            lock.unlock();\n+        }\n+    }\n+\n+    #[test]\n+    fn somke_cond() {\n+        static mut lock: Mutex = MUTEX_INIT;\n+        unsafe {\n+            let t = do Thread::start {\n+                lock.lock();\n+                lock.signal();\n+                lock.unlock();\n+            };\n+            lock.lock();\n+            lock.wait();\n+            lock.unlock();\n+            t.join();\n+        }\n+    }\n+}"}, {"sha": "3423b995fda7854918b8aa03e962868d1b6df82e", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -11,12 +11,12 @@\n use cast;\n use cell::Cell;\n use comm;\n-use libc;\n use ptr;\n use option::{Option,Some,None};\n use task;\n use unstable::atomics::{AtomicOption,AtomicUint,Acquire,Release,Relaxed,SeqCst};\n use unstable::finally::Finally;\n+use unstable::mutex::Mutex;\n use ops::Drop;\n use clone::Clone;\n use kinds::Send;\n@@ -319,17 +319,14 @@ pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n     }\n }\n \n-#[allow(non_camel_case_types)] // runtime type\n-type rust_little_lock = *libc::c_void;\n-\n pub struct LittleLock {\n-    priv l: rust_little_lock,\n+    priv l: Mutex,\n }\n \n impl Drop for LittleLock {\n     fn drop(&mut self) {\n         unsafe {\n-            rust_destroy_little_lock(self.l);\n+            self.l.destroy();\n         }\n     }\n }\n@@ -338,29 +335,31 @@ impl LittleLock {\n     pub fn new() -> LittleLock {\n         unsafe {\n             LittleLock {\n-                l: rust_create_little_lock()\n+                l: Mutex::new()\n             }\n         }\n     }\n \n     pub unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n+        let this = cast::transmute_mut(self);\n         do atomically {\n-            rust_lock_little_lock(self.l);\n+            this.l.lock();\n             do (|| {\n                 f()\n             }).finally {\n-                rust_unlock_little_lock(self.l);\n+                this.l.unlock();\n             }\n         }\n     }\n \n     pub unsafe fn try_lock<T>(&self, f: &fn() -> T) -> Option<T> {\n+        let this = cast::transmute_mut(self);\n         do atomically {\n-            if rust_trylock_little_lock(self.l) {\n+            if this.l.trylock() {\n                 Some(do (|| {\n                     f()\n                 }).finally {\n-                    rust_unlock_little_lock(self.l);\n+                    this.l.unlock();\n                 })\n             } else {\n                 None\n@@ -369,18 +368,20 @@ impl LittleLock {\n     }\n \n     pub unsafe fn signal(&self) {\n-        rust_signal_little_lock(self.l);\n+        let this = cast::transmute_mut(self);\n+        this.l.signal();\n     }\n \n     pub unsafe fn lock_and_wait(&self, f: &fn() -> bool) {\n+        let this = cast::transmute_mut(self);\n         do atomically {\n-            rust_lock_little_lock(self.l);\n+            this.l.lock();\n             do (|| {\n                 if f() {\n-                    rust_wait_little_lock(self.l);\n+                    this.l.wait();\n                 }\n             }).finally {\n-                rust_unlock_little_lock(self.l);\n+                this.l.unlock();\n             }\n         }\n     }\n@@ -489,16 +490,6 @@ impl<T:Send> Exclusive<T> {\n     }\n }\n \n-extern {\n-    fn rust_create_little_lock() -> rust_little_lock;\n-    fn rust_destroy_little_lock(lock: rust_little_lock);\n-    fn rust_trylock_little_lock(lock: rust_little_lock) -> bool;\n-    fn rust_lock_little_lock(lock: rust_little_lock);\n-    fn rust_unlock_little_lock(lock: rust_little_lock);\n-    fn rust_signal_little_lock(lock: rust_little_lock);\n-    fn rust_wait_little_lock(lock: rust_little_lock);\n-}\n-\n #[cfg(test)]\n mod tests {\n     use cell::Cell;"}, {"sha": "2b803b06d099394684d3ce4527dcae77db91b669", "filename": "src/rt/miniz.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Fminiz.c", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Fminiz.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fminiz.c?ref=f5f5d5aac762a554850d291165536ba752260303", "previous_filename": "src/rt/miniz.cpp"}, {"sha": "9d91b99507336cf822f3430e72c6377fc6d23c7f", "filename": "src/rt/rust_android_dummy.c", "status": "renamed", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frust_android_dummy.c", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frust_android_dummy.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_android_dummy.c?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -14,92 +14,92 @@ char **backtrace_symbols(void *const *array, int size) { return 0; }\n \n void backtrace_symbols_fd (void *const *array, int size, int fd) {}\n \n-extern \"C\" volatile int* __errno_location() {\n+volatile int* __errno_location() {\n     return &errno;\n }\n \n-extern \"C\" float log2f(float f)\n+float log2f(float f)\n {\n     return logf( f ) / logf( 2 );\n }\n \n-extern \"C\" double log2( double n )\n+double log2( double n )\n {\n     return log( n ) / log( 2 );\n }\n \n-extern \"C\" void telldir()\n+void telldir()\n {\n }\n \n-extern \"C\" void seekdir()\n+void seekdir()\n {\n }\n \n-extern \"C\" void mkfifo()\n+void mkfifo()\n {\n }\n \n-extern \"C\" void abs()\n+void abs()\n {\n }\n \n-extern \"C\" void labs()\n+void labs()\n {\n }\n \n-extern \"C\" void rand()\n+void rand()\n {\n }\n \n-extern \"C\" void srand()\n+void srand()\n {\n }\n \n-extern \"C\" void atof()\n+void atof()\n {\n }\n \n-extern \"C\" int glob(const char *pattern,\n+int glob(const char *pattern,\n                     int flags,\n                     int (*errfunc) (const char *epath, int eerrno),\n                     glob_t *pglob)\n {\n     return 0;\n }\n \n-extern \"C\" void globfree(glob_t *pglob)\n+void globfree(glob_t *pglob)\n {\n }\n \n-extern \"C\" int pthread_atfork(void (*prefork)(void),\n+int pthread_atfork(void (*prefork)(void),\n                               void (*postfork_parent)(void),\n                               void (*postfork_child)(void))\n {\n     return 0;\n }\n \n-extern \"C\" int mlockall(int flags)\n+int mlockall(int flags)\n {\n     return 0;\n }\n \n-extern \"C\" int munlockall(void)\n+int munlockall(void)\n {\n     return 0;\n }\n \n-extern \"C\" int shm_open(const char *name, int oflag, mode_t mode)\n+int shm_open(const char *name, int oflag, mode_t mode)\n {\n     return 0;\n }\n \n-extern \"C\" int shm_unlink(const char *name)\n+int shm_unlink(const char *name)\n {\n     return 0;\n }\n \n-extern \"C\" int posix_madvise(void *addr, size_t len, int advice)\n+int posix_madvise(void *addr, size_t len, int advice)\n {\n     return 0;\n }", "previous_filename": "src/rt/rust_android_dummy.cpp"}, {"sha": "c8ed61bfc41a91bc51f1116ce6f93242b54cabb1", "filename": "src/rt/rust_builtin.c", "status": "renamed", "additions": 74, "deletions": 177, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -10,7 +10,7 @@\n \n /* Foreign builtins. */\n \n-#include \"sync/lock_and_signal.h\"\n+#include \"rust_globals.h\"\n #include \"vg/valgrind.h\"\n \n #include <time.h>\n@@ -58,12 +58,12 @@ timegm(struct tm *tm)\n #endif\n \n #if defined(__WIN32__)\n-extern \"C\" CDECL char**\n+char**\n rust_env_pairs() {\n     return 0;\n }\n #else\n-extern \"C\" CDECL char**\n+char**\n rust_env_pairs() {\n #if defined(__APPLE__) && !(TARGET_OS_IPHONE)\n     char **environ = *_NSGetEnviron();\n@@ -72,18 +72,18 @@ rust_env_pairs() {\n }\n #endif\n \n-extern \"C\" CDECL char*\n+char*\n #if defined(__WIN32__)\n rust_list_dir_val(WIN32_FIND_DATA* entry_ptr) {\n     return entry_ptr->cFileName;\n }\n #else\n-rust_list_dir_val(dirent* entry_ptr) {\n+rust_list_dir_val(struct dirent* entry_ptr) {\n     return entry_ptr->d_name;\n }\n #endif\n \n-extern \"C\" CDECL size_t\n+size_t\n #if defined(__WIN32__)\n rust_list_dir_wfd_size() {\n     return sizeof(WIN32_FIND_DATAW);\n@@ -94,7 +94,7 @@ rust_list_dir_wfd_size() {\n }\n #endif\n \n-extern \"C\" CDECL void*\n+void*\n #if defined(__WIN32__)\n rust_list_dir_wfd_fp_buf(WIN32_FIND_DATAW* wfd) {\n     if(wfd == NULL) {\n@@ -110,7 +110,7 @@ rust_list_dir_wfd_fp_buf(void* wfd) {\n }\n #endif\n \n-extern \"C\" CDECL int\n+int\n rust_path_is_dir(const char *path) {\n     struct stat buf;\n     if (stat(path, &buf)) {\n@@ -119,7 +119,7 @@ rust_path_is_dir(const char *path) {\n     return S_ISDIR(buf.st_mode);\n }\n \n-extern \"C\" CDECL int\n+int\n #if defined(__WIN32__)\n rust_path_is_dir_u16(const wchar_t *path) {\n     struct _stat buf;\n@@ -137,7 +137,7 @@ rust_path_is_dir_u16(const void *path) {\n }\n #endif\n \n-extern \"C\" CDECL int\n+int\n rust_path_exists(const char *path) {\n     struct stat buf;\n     if (stat(path, &buf)) {\n@@ -146,7 +146,7 @@ rust_path_exists(const char *path) {\n     return 1;\n }\n \n-extern \"C\" CDECL int\n+int\n #if defined(__WIN32__)\n rust_path_exists_u16(const wchar_t *path) {\n     struct _stat buf;\n@@ -162,12 +162,12 @@ rust_path_exists_u16(const void *path) {\n }\n #endif\n \n-extern \"C\" CDECL FILE* rust_get_stdin() {return stdin;}\n-extern \"C\" CDECL FILE* rust_get_stdout() {return stdout;}\n-extern \"C\" CDECL FILE* rust_get_stderr() {return stderr;}\n+FILE* rust_get_stdin() {return stdin;}\n+FILE* rust_get_stdout() {return stdout;}\n+FILE* rust_get_stderr() {return stderr;}\n \n #if defined(__WIN32__)\n-extern \"C\" CDECL void\n+void\n rust_get_time(int64_t *sec, int32_t *nsec) {\n     FILETIME fileTime;\n     GetSystemTimeAsFileTime(&fileTime);\n@@ -186,15 +186,15 @@ rust_get_time(int64_t *sec, int32_t *nsec) {\n     *nsec = (ns_since_1970 % 1000000) * 1000;\n }\n #else\n-extern \"C\" CDECL void\n+void\n rust_get_time(int64_t *sec, int32_t *nsec) {\n #ifdef __APPLE__\n     struct timeval tv;\n     gettimeofday(&tv, NULL);\n     *sec = tv.tv_sec;\n     *nsec = tv.tv_usec * 1000;\n #else\n-    timespec ts;\n+    struct timespec ts;\n     clock_gettime(CLOCK_REALTIME, &ts);\n     *sec = ts.tv_sec;\n     *nsec = ts.tv_nsec;\n@@ -204,7 +204,7 @@ rust_get_time(int64_t *sec, int32_t *nsec) {\n \n const int64_t ns_per_s = 1000000000LL;\n \n-extern \"C\" CDECL void\n+void\n rust_precise_time_ns(uint64_t *ns) {\n \n #ifdef __APPLE__\n@@ -227,23 +227,22 @@ rust_precise_time_ns(uint64_t *ns) {\n     assert(query_result);\n     *ns = (uint64_t)((ticks.QuadPart * ns_per_s) / ticks_per_s.QuadPart);\n #else\n-    timespec ts;\n+    struct timespec ts;\n     clock_gettime(CLOCK_MONOTONIC, &ts);\n     *ns = (uint64_t)(ts.tv_sec * ns_per_s + ts.tv_nsec);\n #endif\n }\n \n-struct\n-rust_vec\n+typedef struct\n {\n     size_t fill;    // in bytes; if zero, heapified\n     size_t alloc;   // in bytes\n     uint8_t data[0];\n-};\n+} rust_vec;\n \n typedef rust_vec rust_str;\n \n-struct rust_tm {\n+typedef struct {\n     int32_t tm_sec;\n     int32_t tm_min;\n     int32_t tm_hour;\n@@ -256,10 +255,10 @@ struct rust_tm {\n     int32_t tm_gmtoff;\n     rust_str *tm_zone;\n     int32_t tm_nsec;\n-};\n+} rust_tm;\n \n-void rust_tm_to_tm(rust_tm* in_tm, tm* out_tm) {\n-    memset(out_tm, 0, sizeof(tm));\n+void rust_tm_to_tm(rust_tm* in_tm, struct tm* out_tm) {\n+    memset(out_tm, 0, sizeof(struct tm));\n     out_tm->tm_sec = in_tm->tm_sec;\n     out_tm->tm_min = in_tm->tm_min;\n     out_tm->tm_hour = in_tm->tm_hour;\n@@ -271,7 +270,7 @@ void rust_tm_to_tm(rust_tm* in_tm, tm* out_tm) {\n     out_tm->tm_isdst = in_tm->tm_isdst;\n }\n \n-void tm_to_rust_tm(tm* in_tm, rust_tm* out_tm, int32_t gmtoff,\n+void tm_to_rust_tm(struct tm* in_tm, rust_tm* out_tm, int32_t gmtoff,\n                    const char *zone, int32_t nsec) {\n     out_tm->tm_sec = in_tm->tm_sec;\n     out_tm->tm_min = in_tm->tm_min;\n@@ -300,13 +299,13 @@ void tm_to_rust_tm(tm* in_tm, rust_tm* out_tm, int32_t gmtoff,\n #define LOCALTIME(clock, result) localtime_s((result), (clock))\n #define TIMEGM(result) _mkgmtime64(result)\n #else\n-struct tm* GMTIME(const time_t *clock, tm *result) {\n+struct tm* GMTIME(const time_t *clock, struct tm *result) {\n     struct tm* t = gmtime(clock);\n     if (t == NULL || result == NULL) { return NULL; }\n     *result = *t;\n     return result;\n }\n-struct tm* LOCALTIME(const time_t *clock, tm *result) {\n+struct tm* LOCALTIME(const time_t *clock, struct tm *result) {\n     struct tm* t = localtime(clock);\n     if (t == NULL || result == NULL) { return NULL; }\n     *result = *t;\n@@ -321,23 +320,23 @@ struct tm* LOCALTIME(const time_t *clock, tm *result) {\n #define TIMEGM(result) timegm(result)\n #endif\n \n-extern \"C\" CDECL void\n+void\n rust_tzset() {\n     TZSET();\n }\n \n-extern \"C\" CDECL void\n+void\n rust_gmtime(int64_t sec, int32_t nsec, rust_tm *timeptr) {\n-    tm tm;\n+    struct tm tm;\n     time_t s = sec;\n     GMTIME(&s, &tm);\n \n     tm_to_rust_tm(&tm, timeptr, 0, \"UTC\", nsec);\n }\n \n-extern \"C\" CDECL void\n+void\n rust_localtime(int64_t sec, int32_t nsec, rust_tm *timeptr) {\n-    tm tm;\n+    struct tm tm;\n     time_t s = sec;\n     LOCALTIME(&s, &tm);\n \n@@ -365,128 +364,47 @@ rust_localtime(int64_t sec, int32_t nsec, rust_tm *timeptr) {\n     tm_to_rust_tm(&tm, timeptr, gmtoff, zone, nsec);\n }\n \n-extern \"C\" CDECL int64_t\n+int64_t\n rust_timegm(rust_tm* timeptr) {\n-    tm t;\n+    struct tm t;\n     rust_tm_to_tm(timeptr, &t);\n     return TIMEGM(&t);\n }\n \n-extern \"C\" CDECL int64_t\n+int64_t\n rust_mktime(rust_tm* timeptr) {\n-    tm t;\n+    struct tm t;\n     rust_tm_to_tm(timeptr, &t);\n     return mktime(&t);\n }\n \n-extern \"C\" lock_and_signal*\n-rust_create_little_lock() {\n-    return new lock_and_signal();\n-}\n-\n-extern \"C\" void\n-rust_destroy_little_lock(lock_and_signal *lock) {\n-    delete lock;\n-}\n-\n-extern \"C\" void\n-rust_lock_little_lock(lock_and_signal *lock) {\n-    lock->lock();\n-}\n-\n-extern \"C\" bool\n-rust_trylock_little_lock(lock_and_signal *lock) {\n-    return lock->try_lock();\n-}\n-\n-extern \"C\" void\n-rust_unlock_little_lock(lock_and_signal *lock) {\n-    lock->unlock();\n-}\n-\n-extern \"C\" void\n-rust_wait_little_lock(lock_and_signal *lock) {\n-    lock->wait();\n-}\n-\n-extern \"C\" void\n-rust_signal_little_lock(lock_and_signal *lock) {\n-    lock->signal();\n-}\n-\n #ifndef _WIN32\n #include <sys/types.h>\n #include <dirent.h>\n \n-extern \"C\" DIR*\n+DIR*\n rust_opendir(char *dirname) {\n     return opendir(dirname);\n }\n \n-extern \"C\" dirent*\n+struct dirent*\n rust_readdir(DIR *dirp) {\n     return readdir(dirp);\n }\n \n #else\n \n-extern \"C\" void\n+void\n rust_opendir() {\n }\n \n-extern \"C\" void\n+void\n rust_readdir() {\n }\n \n #endif\n \n-#ifndef _WIN32\n-typedef pthread_key_t tls_key;\n-#else\n-typedef DWORD tls_key;\n-#endif\n-\n-// Initialize the TLS key used by the new scheduler\n-extern \"C\" CDECL void\n-rust_initialize_rt_tls_key(tls_key *key) {\n-\n-    static lock_and_signal init_lock;\n-    static bool initialized = false;\n-\n-    scoped_lock with(init_lock);\n-\n-    if (!initialized) {\n-\n-#ifndef _WIN32\n-        assert(!pthread_key_create(key, NULL));\n-#else\n-        *key = TlsAlloc();\n-        assert(*key != TLS_OUT_OF_INDEXES);\n-#endif\n-\n-        initialized = true;\n-    }\n-}\n-\n-typedef void *(rust_try_fn)(void*, void*);\n-\n-extern \"C\" CDECL uintptr_t\n-rust_try(rust_try_fn f, void *fptr, void *env) {\n-    try {\n-        f(fptr, env);\n-    } catch (uintptr_t token) {\n-        assert(token != 0);\n-        return token;\n-    }\n-    return 0;\n-}\n-\n-extern \"C\" CDECL void\n-rust_begin_unwind(uintptr_t token) {\n-    throw token;\n-}\n-\n-extern \"C\" CDECL uintptr_t\n+uintptr_t\n rust_running_on_valgrind() {\n     return RUNNING_ON_VALGRIND;\n }\n@@ -533,66 +451,24 @@ get_num_cpus() {\n }\n #endif\n \n-extern \"C\" CDECL uintptr_t\n+uintptr_t\n rust_get_num_cpus() {\n     return get_num_cpus();\n }\n \n-static lock_and_signal global_args_lock;\n-static uintptr_t global_args_ptr = 0;\n-\n-extern \"C\" CDECL void\n-rust_take_global_args_lock() {\n-    global_args_lock.lock();\n-}\n-\n-extern \"C\" CDECL void\n-rust_drop_global_args_lock() {\n-    global_args_lock.unlock();\n-}\n-\n-extern \"C\" CDECL uintptr_t*\n-rust_get_global_args_ptr() {\n-    return &global_args_ptr;\n-}\n-\n-static lock_and_signal env_lock;\n-\n-extern \"C\" CDECL void\n-rust_take_env_lock() {\n-    env_lock.lock();\n-}\n-\n-extern \"C\" CDECL void\n-rust_drop_env_lock() {\n-    env_lock.unlock();\n-}\n-\n-static lock_and_signal dlerror_lock;\n-\n-extern \"C\" CDECL void\n-rust_take_dlerror_lock() {\n-    dlerror_lock.lock();\n-}\n-\n-extern \"C\" CDECL void\n-rust_drop_dlerror_lock() {\n-    dlerror_lock.unlock();\n-}\n-\n-extern \"C\" CDECL unsigned int\n+unsigned int\n rust_valgrind_stack_register(void *start, void *end) {\n   return VALGRIND_STACK_REGISTER(start, end);\n }\n \n-extern \"C\" CDECL void\n+void\n rust_valgrind_stack_deregister(unsigned int id) {\n   VALGRIND_STACK_DEREGISTER(id);\n }\n \n #if defined(__WIN32__)\n \n-extern \"C\" CDECL void\n+void\n rust_unset_sigprocmask() {\n     // empty stub for windows to keep linker happy\n }\n@@ -602,7 +478,7 @@ rust_unset_sigprocmask() {\n #include <signal.h>\n #include <unistd.h>\n \n-extern \"C\" CDECL void\n+void\n rust_unset_sigprocmask() {\n     // this can't be safely converted to rust code because the\n     // representation of sigset_t is platform-dependent\n@@ -631,7 +507,7 @@ win32_require(LPCTSTR fn, BOOL ok) {\n     }\n }\n \n-extern \"C\" CDECL void\n+void\n rust_win32_rand_acquire(HCRYPTPROV* phProv) {\n     win32_require\n         (_T(\"CryptAcquireContext\"),\n@@ -641,12 +517,12 @@ rust_win32_rand_acquire(HCRYPTPROV* phProv) {\n                              CRYPT_VERIFYCONTEXT|CRYPT_SILENT));\n \n }\n-extern \"C\" CDECL void\n+void\n rust_win32_rand_gen(HCRYPTPROV hProv, DWORD dwLen, BYTE* pbBuffer) {\n     win32_require\n         (_T(\"CryptGenRandom\"), CryptGenRandom(hProv, dwLen, pbBuffer));\n }\n-extern \"C\" CDECL void\n+void\n rust_win32_rand_release(HCRYPTPROV hProv) {\n     win32_require\n         (_T(\"CryptReleaseContext\"), CryptReleaseContext(hProv, 0));\n@@ -657,20 +533,41 @@ rust_win32_rand_release(HCRYPTPROV hProv) {\n // these symbols are listed in rustrt.def.in, so they need to exist; but they\n // should never be called.\n \n-extern \"C\" CDECL void\n+void\n rust_win32_rand_acquire() {\n     abort();\n }\n-extern \"C\" CDECL void\n+void\n rust_win32_rand_gen() {\n     abort();\n }\n-extern \"C\" CDECL void\n+void\n rust_win32_rand_release() {\n     abort();\n }\n \n #endif\n+\n+#if defined(__WIN32__)\n+\n+int\n+rust_crit_section_size() { return sizeof(CRITICAL_SECTION); }\n+int\n+rust_pthread_mutex_t_size() { return 0; }\n+int\n+rust_pthread_cond_t_size() { return 0; }\n+\n+#else\n+\n+int\n+rust_crit_section_size() { return 0; }\n+int\n+rust_pthread_mutex_t_size() { return sizeof(pthread_mutex_t); }\n+int\n+rust_pthread_cond_t_size() { return sizeof(pthread_cond_t); }\n+\n+#endif\n+\n //\n // Local Variables:\n // mode: C++", "previous_filename": "src/rt/rust_builtin.cpp"}, {"sha": "b44d29642c4b7a820810f8d62cb4395375995965", "filename": "src/rt/rust_cxx_glue.cpp", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frust_cxx_glue.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frust_cxx_glue.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cxx_glue.cpp?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/* Foreign builtins which require C++ */\n+\n+#include \"rust_globals.h\"\n+\n+typedef void *(rust_try_fn)(void*, void*);\n+\n+extern \"C\" CDECL uintptr_t\n+rust_try(rust_try_fn f, void *fptr, void *env) {\n+    try {\n+        f(fptr, env);\n+    } catch (uintptr_t token) {\n+        assert(token != 0);\n+        return token;\n+    }\n+    return 0;\n+}\n+\n+extern \"C\" CDECL void\n+rust_begin_unwind(uintptr_t token) {\n+    throw token;\n+}"}, {"sha": "317f8af237fa186241c20fc978d592b8427bf53b", "filename": "src/rt/rust_globals.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frust_globals.h", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frust_globals.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_globals.h?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -39,6 +39,10 @@\n #define __STDC_FORMAT_MACROS 1\n #endif\n \n+#ifndef _GNU_SOURCE\n+#define _GNU_SOURCE 1\n+#endif\n+\n #define ERROR 0\n \n #include <stdlib.h>\n@@ -62,11 +66,15 @@\n #ifndef NOMINMAX\n #define NOMINMAX\n #endif\n+#if defined(__cplusplus)\n extern \"C\" {\n+#endif\n #include <windows.h>\n #include <tchar.h>\n #include <wincrypt.h>\n+#if defined(__cplusplus)\n }\n+#endif\n #elif defined(__GNUC__)\n #include <unistd.h>\n #include <dlfcn.h>"}, {"sha": "d2b69337e7251332d06583564e39e0b13d7fcd52", "filename": "src/rt/rust_test_helpers.c", "status": "renamed", "additions": 35, "deletions": 81, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.c?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -10,89 +10,54 @@\n \n // Helper functions used only in tests\n \n-#include \"sync/lock_and_signal.h\"\n+#include \"rust_globals.h\"\n \n // These functions are used in the unit tests for C ABI calls.\n \n-extern \"C\" CDECL uint32_t\n+uint32_t\n rust_dbg_extern_identity_u32(uint32_t u) {\n     return u;\n }\n \n-extern \"C\" CDECL uint64_t\n+uint64_t\n rust_dbg_extern_identity_u64(uint64_t u) {\n     return u;\n }\n \n-extern \"C\" CDECL double\n+double\n rust_dbg_extern_identity_double(double u) {\n     return u;\n }\n \n-extern \"C\" CDECL char\n+char\n rust_dbg_extern_identity_u8(char u) {\n     return u;\n }\n \n-extern \"C\" CDECL lock_and_signal *\n-rust_dbg_lock_create() {\n-    return new lock_and_signal();\n-}\n-\n-extern \"C\" CDECL void\n-rust_dbg_lock_destroy(lock_and_signal *lock) {\n-    assert(lock);\n-    delete lock;\n-}\n-\n-extern \"C\" CDECL void\n-rust_dbg_lock_lock(lock_and_signal *lock) {\n-    assert(lock);\n-    lock->lock();\n-}\n-\n-extern \"C\" CDECL void\n-rust_dbg_lock_unlock(lock_and_signal *lock) {\n-    assert(lock);\n-    lock->unlock();\n-}\n-\n-extern \"C\" CDECL void\n-rust_dbg_lock_wait(lock_and_signal *lock) {\n-    assert(lock);\n-    lock->wait();\n-}\n-\n-extern \"C\" CDECL void\n-rust_dbg_lock_signal(lock_and_signal *lock) {\n-    assert(lock);\n-    lock->signal();\n-}\n-\n typedef void *(*dbg_callback)(void*);\n \n-extern \"C\" CDECL void *\n+void *\n rust_dbg_call(dbg_callback cb, void *data) {\n     return cb(data);\n }\n \n-extern \"C\" CDECL void rust_dbg_do_nothing() { }\n+void rust_dbg_do_nothing() { }\n \n struct TwoU8s {\n     uint8_t one;\n     uint8_t two;\n };\n \n-extern \"C\" CDECL TwoU8s\n+struct TwoU8s\n rust_dbg_extern_return_TwoU8s() {\n     struct TwoU8s s;\n     s.one = 10;\n     s.two = 20;\n     return s;\n }\n \n-extern \"C\" CDECL TwoU8s\n-rust_dbg_extern_identity_TwoU8s(TwoU8s u) {\n+struct TwoU8s\n+rust_dbg_extern_identity_TwoU8s(struct TwoU8s u) {\n     return u;\n }\n \n@@ -101,16 +66,16 @@ struct TwoU16s {\n     uint16_t two;\n };\n \n-extern \"C\" CDECL TwoU16s\n+struct TwoU16s\n rust_dbg_extern_return_TwoU16s() {\n     struct TwoU16s s;\n     s.one = 10;\n     s.two = 20;\n     return s;\n }\n \n-extern \"C\" CDECL TwoU16s\n-rust_dbg_extern_identity_TwoU16s(TwoU16s u) {\n+struct TwoU16s\n+rust_dbg_extern_identity_TwoU16s(struct TwoU16s u) {\n     return u;\n }\n \n@@ -119,16 +84,16 @@ struct TwoU32s {\n     uint32_t two;\n };\n \n-extern \"C\" CDECL TwoU32s\n+struct TwoU32s\n rust_dbg_extern_return_TwoU32s() {\n     struct TwoU32s s;\n     s.one = 10;\n     s.two = 20;\n     return s;\n }\n \n-extern \"C\" CDECL TwoU32s\n-rust_dbg_extern_identity_TwoU32s(TwoU32s u) {\n+struct TwoU32s\n+rust_dbg_extern_identity_TwoU32s(struct TwoU32s u) {\n     return u;\n }\n \n@@ -137,16 +102,16 @@ struct TwoU64s {\n     uint64_t two;\n };\n \n-extern \"C\" CDECL TwoU64s\n+struct TwoU64s\n rust_dbg_extern_return_TwoU64s() {\n     struct TwoU64s s;\n     s.one = 10;\n     s.two = 20;\n     return s;\n }\n \n-extern \"C\" CDECL TwoU64s\n-rust_dbg_extern_identity_TwoU64s(TwoU64s u) {\n+struct TwoU64s\n+rust_dbg_extern_identity_TwoU64s(struct TwoU64s u) {\n     return u;\n }\n \n@@ -155,23 +120,12 @@ struct TwoDoubles {\n     double two;\n };\n \n-extern \"C\" CDECL TwoDoubles\n-rust_dbg_extern_identity_TwoDoubles(TwoDoubles u) {\n+struct TwoDoubles\n+rust_dbg_extern_identity_TwoDoubles(struct TwoDoubles u) {\n     return u;\n }\n \n-// Generates increasing port numbers for network testing\n-extern \"C\" CDECL uintptr_t\n-rust_dbg_next_port(uintptr_t base_port) {\n-  static lock_and_signal dbg_port_lock;\n-  static uintptr_t next_offset = 0;\n-  scoped_lock with(dbg_port_lock);\n-  uintptr_t this_port = base_port + next_offset;\n-  next_offset += 1;\n-  return this_port;\n-}\n-\n-extern \"C\" CDECL intptr_t\n+intptr_t\n rust_get_test_int() {\n   return 1;\n }\n@@ -195,29 +149,29 @@ struct floats {\n     double c;\n };\n \n-extern \"C\" quad\n-rust_dbg_abi_1(quad q) {\n-    quad qq = { q.c + 1,\n-                q.d - 1,\n-                q.a + 1,\n-                q.b - 1 };\n+struct quad\n+rust_dbg_abi_1(struct quad q) {\n+    struct quad qq = { q.c + 1,\n+                       q.d - 1,\n+                       q.a + 1,\n+                       q.b - 1 };\n     return qq;\n }\n \n-extern \"C\" floats\n-rust_dbg_abi_2(floats f) {\n-    floats ff = { f.c + 1.0,\n-                  0xff,\n-                  f.a - 1.0 };\n+struct floats\n+rust_dbg_abi_2(struct floats f) {\n+    struct floats ff = { f.c + 1.0,\n+                         0xff,\n+                         f.a - 1.0 };\n     return ff;\n }\n \n-extern \"C\" int\n+int\n rust_dbg_static_mut;\n \n int rust_dbg_static_mut = 3;\n \n-extern \"C\" void\n+void\n rust_dbg_static_mut_check_four() {\n     assert(rust_dbg_static_mut == 4);\n }", "previous_filename": "src/rt/rust_test_helpers.cpp"}, {"sha": "16621d29d4a38621eeeb4c5c2f53de3891899f23", "filename": "src/rt/rust_upcall.c", "status": "renamed", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frust_upcall.c", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frust_upcall.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.c?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -35,24 +35,24 @@ struct _Unwind_Exception;\n #  endif\n #endif\n \n-extern \"C\" _Unwind_Reason_Code\n+_Unwind_Reason_Code\n PERSONALITY_FUNC(int version,\n                      _Unwind_Action actions,\n                      uint64_t exception_class,\n-                     _Unwind_Exception *ue_header,\n-                     _Unwind_Context *context);\n+                     struct _Unwind_Exception *ue_header,\n+                     struct _Unwind_Context *context);\n \n struct s_rust_personality_args {\n     _Unwind_Reason_Code retval;\n     int version;\n     _Unwind_Action actions;\n     uint64_t exception_class;\n-    _Unwind_Exception *ue_header;\n-    _Unwind_Context *context;\n+    struct _Unwind_Exception *ue_header;\n+    struct _Unwind_Context *context;\n };\n \n-extern \"C\" void\n-upcall_s_rust_personality(s_rust_personality_args *args) {\n+void\n+upcall_s_rust_personality(struct s_rust_personality_args *args) {\n     args->retval = PERSONALITY_FUNC(args->version,\n                                     args->actions,\n                                     args->exception_class,\n@@ -65,15 +65,15 @@ upcall_s_rust_personality(s_rust_personality_args *args) {\n    out what to do with each landing pad. Just a stack-switching\n    wrapper around the C++ personality function.\n */\n-extern \"C\" _Unwind_Reason_Code\n+_Unwind_Reason_Code\n upcall_rust_personality(int version,\n                         _Unwind_Action actions,\n                         uint64_t exception_class,\n-                        _Unwind_Exception *ue_header,\n-                        _Unwind_Context *context) {\n-    s_rust_personality_args args = {(_Unwind_Reason_Code)0,\n-                                    version, actions, exception_class,\n-                                    ue_header, context};\n+                        struct _Unwind_Exception *ue_header,\n+                        struct _Unwind_Context *context) {\n+    struct s_rust_personality_args args = {(_Unwind_Reason_Code)0,\n+                                           version, actions, exception_class,\n+                                           ue_header, context};\n     upcall_s_rust_personality(&args);\n     return args.retval;\n }\n@@ -82,7 +82,7 @@ upcall_rust_personality(int version,\n // correct limit into TLS.\n // NB: This must run on the Rust stack because it\n // needs to acquire the value of the stack pointer\n-extern \"C\" CDECL void\n+void\n upcall_reset_stack_limit() {\n }\n ", "previous_filename": "src/rt/rust_upcall.cpp"}, {"sha": "9c9f7d14e5a3091d7872b05ad9ca020fe5c95bf8", "filename": "src/rt/rust_uv.c", "status": "renamed", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frust_uv.c", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frust_uv.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.c?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -22,7 +22,7 @@\n \n #include \"rust_globals.h\"\n \n-extern \"C\" void*\n+void*\n rust_uv_loop_new() {\n // XXX libuv doesn't always ignore SIGPIPE even though we don't need it.\n #ifndef __WIN32__\n@@ -31,67 +31,67 @@ rust_uv_loop_new() {\n     return (void*)uv_loop_new();\n }\n \n-extern \"C\" void\n+void\n rust_uv_loop_set_data(uv_loop_t* loop, void* data) {\n     loop->data = data;\n }\n \n-extern \"C\" uv_udp_t*\n+uv_udp_t*\n rust_uv_get_udp_handle_from_send_req(uv_udp_send_t* send_req) {\n     return send_req->handle;\n }\n \n-extern \"C\" uv_stream_t*\n+uv_stream_t*\n rust_uv_get_stream_handle_from_connect_req(uv_connect_t* connect) {\n     return connect->handle;\n }\n-extern \"C\" uv_stream_t*\n+uv_stream_t*\n rust_uv_get_stream_handle_from_write_req(uv_write_t* write_req) {\n     return write_req->handle;\n }\n \n-extern \"C\" uv_loop_t*\n+uv_loop_t*\n rust_uv_get_loop_for_uv_handle(uv_handle_t* handle) {\n     return handle->loop;\n }\n \n-extern \"C\" void*\n+void*\n rust_uv_get_data_for_uv_loop(uv_loop_t* loop) {\n     return loop->data;\n }\n \n-extern \"C\" void\n+void\n rust_uv_set_data_for_uv_loop(uv_loop_t* loop,\n         void* data) {\n     loop->data = data;\n }\n \n-extern \"C\" void*\n+void*\n rust_uv_get_data_for_uv_handle(uv_handle_t* handle) {\n     return handle->data;\n }\n \n-extern \"C\" void\n+void\n rust_uv_set_data_for_uv_handle(uv_handle_t* handle, void* data) {\n     handle->data = data;\n }\n \n-extern \"C\" void*\n+void*\n rust_uv_get_data_for_req(uv_req_t* req) {\n     return req->data;\n }\n \n-extern \"C\" void\n+void\n rust_uv_set_data_for_req(uv_req_t* req, void* data) {\n     req->data = data;\n }\n \n-extern \"C\" int\n+int\n rust_sockaddr_size() {\n     return sizeof(struct sockaddr_storage);\n }\n \n-extern \"C\" struct sockaddr*\n+struct sockaddr*\n rust_malloc_ip4_addr(char *name, int port) {\n     struct sockaddr_in *addr = (struct sockaddr_in*) calloc(1, rust_sockaddr_size());\n     assert(addr != NULL);\n@@ -101,7 +101,7 @@ rust_malloc_ip4_addr(char *name, int port) {\n     return (struct sockaddr*) addr;\n }\n \n-extern \"C\" struct sockaddr*\n+struct sockaddr*\n rust_malloc_ip6_addr(char *name, int port) {\n     struct sockaddr_in6 *addr = (struct sockaddr_in6*) calloc(1, rust_sockaddr_size());\n     assert(addr != NULL);\n@@ -111,58 +111,58 @@ rust_malloc_ip6_addr(char *name, int port) {\n     return (struct sockaddr*) addr;\n }\n \n-extern \"C\" unsigned int\n+unsigned int\n rust_ip4_port(struct sockaddr_in* src) {\n     return ntohs(src->sin_port);\n }\n-extern \"C\" unsigned int\n+unsigned int\n rust_ip6_port(struct sockaddr_in6* src) {\n     return ntohs(src->sin6_port);\n }\n \n-extern \"C\" int\n-rust_is_ipv4_sockaddr(sockaddr* addr) {\n+int\n+rust_is_ipv4_sockaddr(struct sockaddr* addr) {\n     return addr->sa_family == AF_INET;\n }\n \n-extern \"C\" int\n-rust_is_ipv6_sockaddr(sockaddr* addr) {\n+int\n+rust_is_ipv6_sockaddr(struct sockaddr* addr) {\n     return addr->sa_family == AF_INET6;\n }\n \n-extern \"C\" uintptr_t\n+uintptr_t\n rust_uv_handle_type_max() {\n   return UV_HANDLE_TYPE_MAX;\n }\n \n-extern \"C\" uintptr_t\n+uintptr_t\n rust_uv_req_type_max() {\n   return UV_REQ_TYPE_MAX;\n }\n \n-extern \"C\" int\n+int\n rust_uv_get_result_from_fs_req(uv_fs_t* req) {\n   return req->result;\n }\n-extern \"C\" const char*\n+const char*\n rust_uv_get_path_from_fs_req(uv_fs_t* req) {\n   return req->path;\n }\n-extern \"C\" void*\n+void*\n rust_uv_get_ptr_from_fs_req(uv_fs_t* req) {\n   return req->ptr;\n }\n-extern \"C\" uv_loop_t*\n+uv_loop_t*\n rust_uv_get_loop_from_fs_req(uv_fs_t* req) {\n   return req->loop;\n }\n \n-extern \"C\" uv_loop_t*\n+uv_loop_t*\n rust_uv_get_loop_from_getaddrinfo_req(uv_getaddrinfo_t* req) {\n   return req->loop;\n }\n \n-extern \"C\" void\n+void\n rust_uv_populate_uv_stat(uv_fs_t* req_in, uv_stat_t* stat_out) {\n   stat_out->st_dev = req_in->statbuf.st_dev;\n   stat_out->st_mode = req_in->statbuf.st_mode;\n@@ -186,27 +186,27 @@ rust_uv_populate_uv_stat(uv_fs_t* req_in, uv_stat_t* stat_out) {\n   stat_out->st_birthtim.tv_nsec = req_in->statbuf.st_birthtim.tv_nsec;\n }\n \n-extern \"C\" void\n+void\n rust_set_stdio_container_flags(uv_stdio_container_t *c, int flags) {\n   c->flags = (uv_stdio_flags) flags;\n }\n \n-extern \"C\" void\n+void\n rust_set_stdio_container_fd(uv_stdio_container_t *c, int fd) {\n   c->data.fd = fd;\n }\n \n-extern \"C\" void\n+void\n rust_set_stdio_container_stream(uv_stdio_container_t *c, uv_stream_t *stream) {\n   c->data.stream = stream;\n }\n \n-extern \"C\" int\n+int\n rust_uv_process_pid(uv_process_t* p) {\n   return p->pid;\n }\n \n-extern \"C\" int\n+int\n rust_uv_guess_handle(int fd) {\n   return uv_guess_handle(fd);\n }", "previous_filename": "src/rt/rust_uv.cpp"}, {"sha": "c5b5e7f2c467a374c970b2d11e69d58331d8f425", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/f5f5d5aac762a554850d291165536ba752260303/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=f5f5d5aac762a554850d291165536ba752260303", "patch": "@@ -26,21 +26,8 @@ rust_win32_rand_gen\n rust_win32_rand_release\n upcall_rust_personality\n upcall_reset_stack_limit\n-rust_dbg_lock_create\n-rust_dbg_lock_destroy\n-rust_dbg_lock_lock\n-rust_dbg_lock_unlock\n-rust_dbg_lock_wait\n-rust_dbg_lock_signal\n rust_dbg_call\n rust_dbg_do_nothing\n-rust_create_little_lock\n-rust_destroy_little_lock\n-rust_lock_little_lock\n-rust_trylock_little_lock\n-rust_unlock_little_lock\n-rust_signal_little_lock\n-rust_wait_little_lock\n tdefl_compress_mem_to_heap\n tinfl_decompress_mem_to_heap\n rust_swap_registers\n@@ -59,19 +46,13 @@ rust_dbg_extern_return_TwoU32s\n rust_dbg_extern_return_TwoU64s\n rust_dbg_extern_identity_double\n rust_dbg_extern_identity_u8\n-rust_initialize_rt_tls_key\n-rust_dbg_next_port\n rust_try\n rust_begin_unwind\n rust_valgrind_stack_register\n rust_valgrind_stack_deregister\n-rust_take_env_lock\n-rust_drop_env_lock\n rust_running_on_valgrind\n rust_get_num_cpus\n-rust_get_global_args_ptr\n-rust_take_global_args_lock\n-rust_drop_global_args_lock\n rust_get_test_int\n-rust_take_dlerror_lock\n-rust_drop_dlerror_lock\n+rust_pthread_mutex_t_size\n+rust_pthread_cond_t_size\n+rust_crit_section_size"}, {"sha": "fcf8ab5d88b390f98729aafb5e4f0f7f7c5440d8", "filename": "src/rt/sync/lock_and_signal.cpp", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/ab7fe9dd06e93986f6b11512031c891059474653/src%2Frt%2Fsync%2Flock_and_signal.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ab7fe9dd06e93986f6b11512031c891059474653/src%2Frt%2Fsync%2Flock_and_signal.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.cpp?ref=ab7fe9dd06e93986f6b11512031c891059474653", "patch": "@@ -1,205 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#include \"../rust_globals.h\"\n-#include \"lock_and_signal.h\"\n-\n-/*\n- * A \"lock-and-signal\" pair. These are necessarily coupled on pthreads\n- * systems, and artificially coupled (by this file) on win32. Put\n- * together here to minimize ifdefs elsewhere; you must use them as\n- * if you're using a pthreads cvar+mutex pair.\n- */\n-\n-// FIXME (#2683): This is not a portable way of specifying an invalid\n-// pthread_t\n-#define INVALID_THREAD 0\n-\n-\n-#if defined(__WIN32__)\n-lock_and_signal::lock_and_signal()\n-#if defined(DEBUG_LOCKS)\n-    : _holding_thread(INVALID_THREAD)\n-#endif\n-{\n-    _event = CreateEvent(NULL, FALSE, FALSE, NULL);\n-\n-    // If a CRITICAL_SECTION is not initialized with a spin count, it will\n-    // default to 0, even on multi-processor systems. MSDN suggests using\n-    // 4000. On single-processor systems, the spin count parameter is ignored\n-    // and the critical section's spin count defaults to 0.\n-    const DWORD SPIN_COUNT = 4000;\n-    CHECKED(!InitializeCriticalSectionAndSpinCount(&_cs, SPIN_COUNT));\n-\n-    // FIXME #2893 Consider checking\n-    // GetProcAddress(\"InitializeCriticalSectionEx\")\n-    // so Windows >= Vista we can use CRITICAL_SECTION_NO_DEBUG_INFO to avoid\n-    // allocating CRITICAL_SECTION debug info that is never released. See:\n-    // http://stackoverflow.com/questions/804848/\n-    //        critical-sections-leaking-memory-on-vista-win2008#889853\n-}\n-\n-#else\n-lock_and_signal::lock_and_signal()\n-#if defined(DEBUG_LOCKS)\n-    : _holding_thread(INVALID_THREAD)\n-#endif\n-{\n-    CHECKED(pthread_cond_init(&_cond, NULL));\n-    CHECKED(pthread_mutex_init(&_mutex, NULL));\n-}\n-#endif\n-\n-lock_and_signal::~lock_and_signal() {\n-#if defined(__WIN32__)\n-    CloseHandle(_event);\n-    DeleteCriticalSection(&_cs);\n-#else\n-    CHECKED(pthread_cond_destroy(&_cond));\n-    CHECKED(pthread_mutex_destroy(&_mutex));\n-#endif\n-}\n-\n-void lock_and_signal::lock() {\n-    must_not_have_lock();\n-#if defined(__WIN32__)\n-    EnterCriticalSection(&_cs);\n-#if defined(DEBUG_LOCKS)\n-    _holding_thread = GetCurrentThreadId();\n-#endif\n-#else\n-    CHECKED(pthread_mutex_lock(&_mutex));\n-#if defined(DEBUG_LOCKS)\n-    _holding_thread = pthread_self();\n-#endif\n-#endif\n-}\n-\n-bool lock_and_signal::try_lock() {\n-    must_not_have_lock();\n-#if defined(__WIN32__)\n-    if (TryEnterCriticalSection(&_cs)) {\n-#if defined(DEBUG_LOCKS)\n-        _holding_thread = GetCurrentThreadId();\n-#endif\n-        return true;\n-    }\n-#else // non-windows\n-    int trylock = pthread_mutex_trylock(&_mutex);\n-    if (trylock == 0) {\n-#if defined(DEBUG_LOCKS)\n-        _holding_thread = pthread_self();\n-#endif\n-        return true;\n-    } else if (trylock == EBUSY) {\n-        // EBUSY means lock was already held by someone else\n-        return false;\n-    }\n-    // abort on all other errors\n-    CHECKED(trylock);\n-#endif\n-    return false;\n-}\n-\n-void lock_and_signal::unlock() {\n-    must_have_lock();\n-#if defined(DEBUG_LOCKS)\n-    _holding_thread = INVALID_THREAD;\n-#endif\n-#if defined(__WIN32__)\n-    LeaveCriticalSection(&_cs);\n-#else\n-    CHECKED(pthread_mutex_unlock(&_mutex));\n-#endif\n-}\n-\n-/**\n- * Wait indefinitely until condition is signaled.\n- */\n-void lock_and_signal::wait() {\n-    must_have_lock();\n-#if defined(DEBUG_LOCKS)\n-    _holding_thread = INVALID_THREAD;\n-#endif\n-#if defined(__WIN32__)\n-    LeaveCriticalSection(&_cs);\n-    WaitForSingleObject(_event, INFINITE);\n-    EnterCriticalSection(&_cs);\n-    must_not_be_locked();\n-#if defined(DEBUG_LOCKS)\n-    _holding_thread = GetCurrentThreadId();\n-#endif\n-#else\n-    CHECKED(pthread_cond_wait(&_cond, &_mutex));\n-    must_not_be_locked();\n-#if defined(DEBUG_LOCKS)\n-    _holding_thread = pthread_self();\n-#endif\n-#endif\n-}\n-\n-/**\n- * Signal condition, and resume the waiting thread.\n- */\n-void lock_and_signal::signal() {\n-#if defined(__WIN32__)\n-    SetEvent(_event);\n-#else\n-    CHECKED(pthread_cond_signal(&_cond));\n-#endif\n-}\n-\n-#if defined(DEBUG_LOCKS)\n-bool lock_and_signal::lock_held_by_current_thread()\n-{\n-#if defined(__WIN32__)\n-    return _holding_thread == GetCurrentThreadId();\n-#else\n-    return pthread_equal(_holding_thread, pthread_self());\n-#endif\n-}\n-#endif\n-\n-#if defined(DEBUG_LOCKS)\n-void lock_and_signal::must_have_lock() {\n-    assert(lock_held_by_current_thread() && \"must have lock\");\n-}\n-void lock_and_signal::must_not_have_lock() {\n-    assert(!lock_held_by_current_thread() && \"must not have lock\");\n-}\n-void lock_and_signal::must_not_be_locked() {\n-}\n-#else\n-void lock_and_signal::must_have_lock() { }\n-void lock_and_signal::must_not_have_lock() { }\n-void lock_and_signal::must_not_be_locked() { }\n-#endif\n-\n-scoped_lock::scoped_lock(lock_and_signal &lock)\n-    : lock(lock)\n-{\n-    lock.lock();\n-}\n-\n-scoped_lock::~scoped_lock()\n-{\n-    lock.unlock();\n-}\n-\n-//\n-// Local Variables:\n-// mode: C++\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:"}, {"sha": "45e1f7198516c9cd7537c784e142addfe576d13d", "filename": "src/rt/sync/lock_and_signal.h", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ab7fe9dd06e93986f6b11512031c891059474653/src%2Frt%2Fsync%2Flock_and_signal.h", "raw_url": "https://github.com/rust-lang/rust/raw/ab7fe9dd06e93986f6b11512031c891059474653/src%2Frt%2Fsync%2Flock_and_signal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.h?ref=ab7fe9dd06e93986f6b11512031c891059474653", "patch": "@@ -1,63 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#ifndef LOCK_AND_SIGNAL_H\n-#define LOCK_AND_SIGNAL_H\n-\n-#include \"rust_globals.h\"\n-\n-#ifndef RUST_NDEBUG\n-#define DEBUG_LOCKS\n-#endif\n-\n-class lock_and_signal {\n-#if defined(__WIN32__)\n-    HANDLE _event;\n-    CRITICAL_SECTION _cs;\n-#if defined(DEBUG_LOCKS)\n-    DWORD _holding_thread;\n-#endif\n-#else\n-    pthread_cond_t _cond;\n-    pthread_mutex_t _mutex;\n-#if defined(DEBUG_LOCKS)\n-    pthread_t _holding_thread;\n-#endif\n-#endif\n-\n-#if defined(DEBUG_LOCKS)\n-    bool lock_held_by_current_thread();\n-#endif\n-\n-    void must_not_be_locked();\n-\n-public:\n-    lock_and_signal();\n-    virtual ~lock_and_signal();\n-\n-    void lock();\n-    bool try_lock();\n-    void unlock();\n-    void wait();\n-    void signal();\n-\n-    void must_have_lock();\n-    void must_not_have_lock();\n-};\n-\n-class scoped_lock {\n-  lock_and_signal &lock;\n-\n-public:\n-  scoped_lock(lock_and_signal &lock);\n-  ~scoped_lock();\n-};\n-\n-#endif /* LOCK_AND_SIGNAL_H */"}]}