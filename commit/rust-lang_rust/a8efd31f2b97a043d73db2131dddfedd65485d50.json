{"sha": "a8efd31f2b97a043d73db2131dddfedd65485d50", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZWZkMzFmMmI5N2EwNDNkNzNkYjIxMzFkZGRmZWRkNjU0ODVkNTA=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-23T14:15:49Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-24T18:06:13Z"}, "message": "Add raw address of expressions to the AST and HIR", "tree": {"sha": "d5eef5952391f5bf162f3ce4a4470255157843f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5eef5952391f5bf162f3ce4a4470255157843f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8efd31f2b97a043d73db2131dddfedd65485d50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8efd31f2b97a043d73db2131dddfedd65485d50", "html_url": "https://github.com/rust-lang/rust/commit/a8efd31f2b97a043d73db2131dddfedd65485d50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8efd31f2b97a043d73db2131dddfedd65485d50/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9420ff4c0ebea44b167d530bb59f9d5721d8ff0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9420ff4c0ebea44b167d530bb59f9d5721d8ff0b", "html_url": "https://github.com/rust-lang/rust/commit/9420ff4c0ebea44b167d530bb59f9d5721d8ff0b"}], "stats": {"total": 447, "additions": 308, "deletions": 139}, "files": [{"sha": "a4557a0776ca4dad56f6317cd4554d8722114696", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -1024,7 +1024,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression)\n         }\n-        ExprKind::AddrOf(_, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n+        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n         ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {"}, {"sha": "f8465baeb1305e917a1b4757f2b173fa3163beb0", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -65,9 +65,9 @@ impl LoweringContext<'_> {\n                 let expr = P(self.lower_expr(expr));\n                 hir::ExprKind::Type(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n             }\n-            ExprKind::AddrOf(m, ref ohs) => {\n+            ExprKind::AddrOf(k, m, ref ohs) => {\n                 let ohs = P(self.lower_expr(ohs));\n-                hir::ExprKind::AddrOf(m, ohs)\n+                hir::ExprKind::AddrOf(k, m, ohs)\n             }\n             ExprKind::Let(ref pat, ref scrutinee) => self.lower_expr_let(e.span, pat, scrutinee),\n             ExprKind::If(ref cond, ref then, ref else_opt) => {\n@@ -1339,7 +1339,11 @@ impl LoweringContext<'_> {\n     }\n \n     fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n-        self.expr(span, hir::ExprKind::AddrOf(hir::Mutability::Mutable, e), ThinVec::new())\n+        self.expr(\n+            span,\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mutable, e),\n+            ThinVec::new(),\n+        )\n     }\n \n     fn expr_unit(&mut self, sp: Span) -> hir::Expr {"}, {"sha": "66bb3a8d883a4670136cf944604725aaa1557777", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -21,7 +21,8 @@ use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use syntax::source_map::Spanned;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n-pub use syntax::ast::{Mutability, Constness, Unsafety, Movability, CaptureBy, IsAuto, ImplPolarity};\n+pub use syntax::ast::{Mutability, Constness, Unsafety, Movability, CaptureBy};\n+pub use syntax::ast::{IsAuto, ImplPolarity, BorrowKind};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n use syntax::symbol::{Symbol, kw};\n use syntax::tokenstream::TokenStream;\n@@ -1493,8 +1494,20 @@ impl Expr {\n         }\n     }\n \n-    pub fn is_place_expr(&self) -> bool {\n-         match self.kind {\n+    // Whether this looks like a place expr, without checking for deref\n+    // adjustments.\n+    // This will return `true` in some potentially surprising cases such as\n+    // `CONSTANT.field`.\n+    pub fn is_syntactic_place_expr(&self) -> bool {\n+        self.is_place_expr(|_| true)\n+    }\n+\n+    // Whether this is a place expression.\n+    // `allow_projections_from` should return `true` if indexing a field or\n+    // index expression based on the given expression should be considered a\n+    // place expression.\n+    pub fn is_place_expr(&self, mut allow_projections_from: impl FnMut(&Self) -> bool) -> bool {\n+        match self.kind {\n             ExprKind::Path(QPath::Resolved(_, ref path)) => {\n                 match path.res {\n                     Res::Local(..)\n@@ -1504,14 +1517,19 @@ impl Expr {\n                 }\n             }\n \n+            // Type ascription inherits its place expression kind from its\n+            // operand. See:\n+            // https://github.com/rust-lang/rfcs/blob/master/text/0803-type-ascription.md#type-ascription-and-temporaries\n             ExprKind::Type(ref e, _) => {\n-                e.is_place_expr()\n+                e.is_place_expr(allow_projections_from)\n             }\n \n-            ExprKind::Unary(UnDeref, _) |\n-            ExprKind::Field(..) |\n-            ExprKind::Index(..) => {\n-                true\n+            ExprKind::Unary(UnDeref, _) => true,\n+\n+            ExprKind::Field(ref base, _) |\n+            ExprKind::Index(ref base, _) => {\n+                allow_projections_from(base)\n+                    || base.is_place_expr(allow_projections_from)\n             }\n \n             // Partially qualified paths in expressions can only legally\n@@ -1646,8 +1664,8 @@ pub enum ExprKind {\n     /// Path to a definition, possibly containing lifetime or type parameters.\n     Path(QPath),\n \n-    /// A referencing operation (i.e., `&a` or `&mut a`).\n-    AddrOf(Mutability, P<Expr>),\n+    /// A referencing operation (i.e., `&a`, `&mut a`, `&raw const a`, or `&raw mut a`).\n+    AddrOf(BorrowKind, Mutability, P<Expr>),\n     /// A `break`, with an optional label to break.\n     Break(Destination, Option<P<Expr>>),\n     /// A `continue`, with an optional label."}, {"sha": "a069331582ea67096a8f0c8c34f8aad58e59b045", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -294,16 +294,12 @@ impl<'a> State<'a> {\n             }\n             hir::TyKind::Ptr(ref mt) => {\n                 self.s.word(\"*\");\n-                match mt.mutbl {\n-                    hir::Mutability::Mutable => self.word_nbsp(\"mut\"),\n-                    hir::Mutability::Immutable => self.word_nbsp(\"const\"),\n-                }\n-                self.print_type(&mt.ty);\n+                self.print_mt(mt, true);\n             }\n             hir::TyKind::Rptr(ref lifetime, ref mt) => {\n                 self.s.word(\"&\");\n                 self.print_opt_lifetime(lifetime);\n-                self.print_mt(mt);\n+                self.print_mt(mt, false);\n             }\n             hir::TyKind::Never => {\n                 self.s.word(\"!\");\n@@ -1178,11 +1174,18 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_addr_of(&mut self,\n+                          kind: hir::BorrowKind,\n                           mutability: hir::Mutability,\n                           expr: &hir::Expr)\n-                          {\n+    {\n         self.s.word(\"&\");\n-        self.print_mutability(mutability);\n+        match kind {\n+            hir::BorrowKind::Ref => self.print_mutability(mutability, false),\n+            hir::BorrowKind::Raw => {\n+                self.word_nbsp(\"raw\");\n+                self.print_mutability(mutability, true);\n+            }\n+        }\n         self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n@@ -1225,8 +1228,8 @@ impl<'a> State<'a> {\n             hir::ExprKind::Unary(op, ref expr) => {\n                 self.print_expr_unary(op, &expr);\n             }\n-            hir::ExprKind::AddrOf(m, ref expr) => {\n-                self.print_expr_addr_of(m, &expr);\n+            hir::ExprKind::AddrOf(k, m, ref expr) => {\n+                self.print_expr_addr_of(k, m, &expr);\n             }\n             hir::ExprKind::Lit(ref lit) => {\n                 self.print_literal(&lit);\n@@ -1629,11 +1632,11 @@ impl<'a> State<'a> {\n                 match binding_mode {\n                     hir::BindingAnnotation::Ref => {\n                         self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::Mutability::Immutable);\n+                        self.print_mutability(hir::Mutability::Immutable, false);\n                     }\n                     hir::BindingAnnotation::RefMut => {\n                         self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::Mutability::Mutable);\n+                        self.print_mutability(hir::Mutability::Mutable, false);\n                     }\n                     hir::BindingAnnotation::Unannotated => {}\n                     hir::BindingAnnotation::Mutable => {\n@@ -2060,15 +2063,15 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_mutability(&mut self, mutbl: hir::Mutability) {\n+    pub fn print_mutability(&mut self, mutbl: hir::Mutability, print_const: bool) {\n         match mutbl {\n             hir::Mutability::Mutable => self.word_nbsp(\"mut\"),\n-            hir::Mutability::Immutable => {},\n+            hir::Mutability::Immutable => if print_const { self.word_nbsp(\"const\") },\n         }\n     }\n \n-    pub fn print_mt(&mut self, mt: &hir::MutTy) {\n-        self.print_mutability(mt.mutbl);\n+    pub fn print_mt(&mut self, mt: &hir::MutTy, print_const: bool) {\n+        self.print_mutability(mt.mutbl, print_const);\n         self.print_type(&mt.ty)\n     }\n "}, {"sha": "00bddf50c293e27826662855b2e2b8fe10cd6628", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -276,7 +276,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.consume_exprs(exprs);\n             }\n \n-            hir::ExprKind::AddrOf(m, ref base) => {   // &base\n+            hir::ExprKind::AddrOf(_, m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let bk = ty::BorrowKind::from_mutbl(m);"}, {"sha": "aa6f28398289fa77e55681f568610682d703bae2", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -1241,7 +1241,7 @@ fn resolve_local<'tcx>(\n         blk_id: Option<Scope>,\n     ) {\n         match expr.kind {\n-            hir::ExprKind::AddrOf(_, ref subexpr) => {\n+            hir::ExprKind::AddrOf(_, _, ref subexpr) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n                 record_rvalue_scope(visitor, &subexpr, blk_id);\n             }\n@@ -1301,7 +1301,7 @@ fn resolve_local<'tcx>(\n             visitor.scope_tree.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n \n             match expr.kind {\n-                hir::ExprKind::AddrOf(_, ref subexpr) |\n+                hir::ExprKind::AddrOf(_, _, ref subexpr) |\n                 hir::ExprKind::Unary(hir::UnDeref, ref subexpr) |\n                 hir::ExprKind::Field(ref subexpr, _) |\n                 hir::ExprKind::Index(ref subexpr, _) => {"}, {"sha": "709ccce517a36a2ea70f9c1234e0de7aa05f6fa7", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -409,6 +409,7 @@ E0741: include_str!(\"./error_codes/E0741.md\"),\n E0742: include_str!(\"./error_codes/E0742.md\"),\n E0743: include_str!(\"./error_codes/E0743.md\"),\n E0744: include_str!(\"./error_codes/E0744.md\"),\n+E0745: include_str!(\"./error_codes/E0745.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "7c478a1e0c8b1d0cfb239dff72a970b6a8ffbe17", "filename": "src/librustc_error_codes/error_codes/E0745.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0745.md?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -0,0 +1,20 @@\n+Cannot take address of temporary value.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0745\n+# #![feature(raw_ref_op)]\n+fn temp_address() {\n+    let ptr = &raw const 2;   // ERROR\n+}\n+```\n+\n+To avoid the error, first bind the temporary to a named local variable.\n+\n+```ignore\n+# #![feature(raw_ref_op)]\n+fn temp_address() {\n+    let val = 2;\n+    let ptr = &raw const val;\n+}\n+```"}, {"sha": "afc4e461c0df5c55d5e1366a4e1042085dbd5eaf", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 79, "deletions": 52, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -137,55 +137,8 @@ fn apply_adjustment<'a, 'tcx>(\n                 arg: expr.to_ref(),\n             }\n         }\n-        Adjust::Borrow(AutoBorrow::RawPtr(m)) => {\n-            // Convert this to a suitable `&foo` and\n-            // then an unsafe coercion.\n-            expr = Expr {\n-                temp_lifetime,\n-                ty: cx.tcx.mk_ref(cx.tcx.lifetimes.re_erased,\n-                                  ty::TypeAndMut {\n-                                    ty: expr.ty,\n-                                    mutbl: m,\n-                                  }),\n-                span,\n-                kind: ExprKind::Borrow {\n-                    borrow_kind: m.to_borrow_kind(),\n-                    arg: expr.to_ref(),\n-                },\n-            };\n-            let cast_expr = Expr {\n-                temp_lifetime,\n-                ty: adjustment.target,\n-                span,\n-                kind: ExprKind::Cast { source: expr.to_ref() }\n-            };\n-\n-            // To ensure that both implicit and explicit coercions are\n-            // handled the same way, we insert an extra layer of indirection here.\n-            // For explicit casts (e.g., 'foo as *const T'), the source of the 'Use'\n-            // will be an ExprKind::Hair with the appropriate cast expression. Here,\n-            // we make our Use source the generated Cast from the original coercion.\n-            //\n-            // In both cases, this outer 'Use' ensures that the inner 'Cast' is handled by\n-            // as_operand, not by as_rvalue - causing the cast result to be stored in a temporary.\n-            // Ordinary, this is identical to using the cast directly as an rvalue. However, if the\n-            // source of the cast was previously borrowed as mutable, storing the cast in a\n-            // temporary gives the source a chance to expire before the cast is used. For\n-            // structs with a self-referential *mut ptr, this allows assignment to work as\n-            // expected.\n-            //\n-            // For example, consider the type 'struct Foo { field: *mut Foo }',\n-            // The method 'fn bar(&mut self) { self.field = self }'\n-            // triggers a coercion from '&mut self' to '*mut self'. In order\n-            // for the assignment to be valid, the implicit borrow\n-            // of 'self' involved in the coercion needs to end before the local\n-            // containing the '*mut T' is assigned to 'self.field' - otherwise,\n-            // we end up trying to assign to 'self.field' while we have another mutable borrow\n-            // active.\n-            //\n-            // We only need to worry about this kind of thing for coercions from refs to ptrs,\n-            // since they get rid of a borrow implicitly.\n-            ExprKind::Use { source: cast_expr.to_ref() }\n+        Adjust::Borrow(AutoBorrow::RawPtr(mutbl)) => {\n+            raw_ref_shim(cx, expr.to_ref(), adjustment.target, mutbl, span, temp_lifetime)\n         }\n     };\n \n@@ -302,13 +255,26 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             }\n         }\n \n-        hir::ExprKind::AddrOf(mutbl, ref expr) => {\n+        hir::ExprKind::AddrOf(hir::BorrowKind::Ref, mutbl, ref arg) => {\n             ExprKind::Borrow {\n                 borrow_kind: mutbl.to_borrow_kind(),\n-                arg: expr.to_ref(),\n+                arg: arg.to_ref(),\n             }\n         }\n \n+        hir::ExprKind::AddrOf(hir::BorrowKind::Raw, mutbl, ref arg) => {\n+            cx.tcx.sess\n+                .struct_span_err(\n+                    expr.span,\n+                    \"raw borrows are not yet implemented\"\n+                )\n+                .note(\"for more information, see https://github.com/rust-lang/rust/issues/64490\")\n+                .emit();\n+\n+            // Lower to an approximation to avoid further errors.\n+            raw_ref_shim(cx, arg.to_ref(), expr_ty, mutbl, expr.span, temp_lifetime)\n+        }\n+\n         hir::ExprKind::Block(ref blk, _) => ExprKind::Block { body: &blk },\n \n         hir::ExprKind::Assign(ref lhs, ref rhs) => {\n@@ -742,7 +708,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             let user_provided_types = cx.tables.user_provided_types();\n             let user_ty = user_provided_types.get(ty.hir_id).map(|u_ty| *u_ty);\n             debug!(\"make_mirror_unadjusted: (type) user_ty={:?}\", user_ty);\n-            if source.is_place_expr() {\n+            if source.is_syntactic_place_expr() {\n                 ExprKind::PlaceTypeAscription {\n                     source: source.to_ref(),\n                     user_ty,\n@@ -1123,6 +1089,67 @@ fn convert_var(\n }\n \n \n+/// Fake `&raw [mut|const] expr` using a borrow and a cast until `AddressOf`\n+/// exists in MIR.\n+fn raw_ref_shim<'tcx>(\n+    cx: &mut Cx<'_, 'tcx>,\n+    arg: ExprRef<'tcx>,\n+    ty: Ty<'tcx>,\n+    mutbl: hir::Mutability,\n+    span: Span,\n+    temp_lifetime: Option<region::Scope>,\n+) -> ExprKind<'tcx> {\n+    let arg_tm = if let ty::RawPtr(type_mutbl) = ty.kind {\n+        type_mutbl\n+    } else {\n+        bug!(\"raw_ref_shim called with non-raw pointer type\");\n+    };\n+    // Convert this to a suitable `&foo` and\n+    // then an unsafe coercion.\n+    let borrow_expr = Expr {\n+        temp_lifetime,\n+        ty: cx.tcx.mk_ref(cx.tcx.lifetimes.re_erased, arg_tm),\n+        span,\n+        kind: ExprKind::Borrow {\n+            borrow_kind: mutbl.to_borrow_kind(),\n+            arg,\n+        },\n+    };\n+    let cast_expr = Expr {\n+        temp_lifetime,\n+        ty,\n+        span,\n+        kind: ExprKind::Cast { source: borrow_expr.to_ref() }\n+    };\n+\n+    // To ensure that both implicit and explicit coercions are\n+    // handled the same way, we insert an extra layer of indirection here.\n+    // For explicit casts (e.g., 'foo as *const T'), the source of the 'Use'\n+    // will be an ExprKind::Hair with the appropriate cast expression. Here,\n+    // we make our Use source the generated Cast from the original coercion.\n+    //\n+    // In both cases, this outer 'Use' ensures that the inner 'Cast' is handled by\n+    // as_operand, not by as_rvalue - causing the cast result to be stored in a temporary.\n+    // Ordinary, this is identical to using the cast directly as an rvalue. However, if the\n+    // source of the cast was previously borrowed as mutable, storing the cast in a\n+    // temporary gives the source a chance to expire before the cast is used. For\n+    // structs with a self-referential *mut ptr, this allows assignment to work as\n+    // expected.\n+    //\n+    // For example, consider the type 'struct Foo { field: *mut Foo }',\n+    // The method 'fn bar(&mut self) { self.field = self }'\n+    // triggers a coercion from '&mut self' to '*mut self'. In order\n+    // for the assignment to be valid, the implicit borrow\n+    // of 'self' involved in the coercion needs to end before the local\n+    // containing the '*mut T' is assigned to 'self.field' - otherwise,\n+    // we end up trying to assign to 'self.field' while we have another mutable borrow\n+    // active.\n+    //\n+    // We only need to worry about this kind of thing for coercions from refs to ptrs,\n+    // since they get rid of a borrow implicitly.\n+    ExprKind::Use { source: cast_expr.to_ref() }\n+}\n+\n fn bin_op(op: hir::BinOpKind) -> BinOp {\n     match op {\n         hir::BinOpKind::Add => BinOp::Add,"}, {"sha": "8a79a733c301efff809ef8ac88cc44b1af508ce6", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -726,7 +726,7 @@ impl<'a> Parser<'a> {\n                 let sum_with_parens = pprust::to_string(|s| {\n                     s.s.word(\"&\");\n                     s.print_opt_lifetime(lifetime);\n-                    s.print_mutability(mut_ty.mutbl);\n+                    s.print_mutability(mut_ty.mutbl, false);\n                     s.popen();\n                     s.print_type(&mut_ty.ty);\n                     s.print_type_bounds(\" +\", &bounds);"}, {"sha": "81442143f53120337370c2d43cd53f3671eadaf3", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -442,11 +442,7 @@ impl<'a> Parser<'a> {\n                 (lo.to(span), self.mk_unary(UnOp::Deref, e))\n             }\n             token::BinOp(token::And) | token::AndAnd => {\n-                self.expect_and()?;\n-                let m = self.parse_mutability();\n-                let e = self.parse_prefix_expr(None);\n-                let (span, e) = self.interpolated_or_expr_span(e)?;\n-                (lo.to(span), ExprKind::AddrOf(m, e))\n+                self.parse_address_of(lo)?\n             }\n             token::Ident(..) if self.token.is_keyword(kw::Box) => {\n                 self.bump();\n@@ -596,6 +592,25 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Parse `& mut? <expr>` or `& raw [ const | mut ] <expr>`\n+    fn parse_address_of(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n+        self.expect_and()?;\n+        let (k, m) = if self.check_keyword(kw::Raw)\n+            && self.look_ahead(1, Token::is_mutability)\n+        {\n+            let found_raw = self.eat_keyword(kw::Raw);\n+            assert!(found_raw);\n+            let mutability = self.parse_const_or_mut().unwrap();\n+            self.sess.gated_spans.gate(sym::raw_ref_op, lo.to(self.prev_span));\n+            (ast::BorrowKind::Raw, mutability)\n+        } else {\n+            (ast::BorrowKind::Ref, self.parse_mutability())\n+        };\n+        let e = self.parse_prefix_expr(None);\n+        let (span, e) = self.interpolated_or_expr_span(e)?;\n+        Ok((lo.to(span), ExprKind::AddrOf(k, m, e)))\n+    }\n+\n     /// Parses `a.b` or `a(13)` or `a[4]` or just `a`.\n     fn parse_dot_or_call_expr(\n         &mut self,"}, {"sha": "81a39edf215600cb309c0c229192e239ed5ff8e4", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -1174,7 +1174,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Box(ref e) |\n-            hir::ExprKind::AddrOf(_, ref e) |\n+            hir::ExprKind::AddrOf(_, _, ref e) |\n             hir::ExprKind::Cast(ref e, _) |\n             hir::ExprKind::Type(ref e, _) |\n             hir::ExprKind::DropTemps(ref e) |"}, {"sha": "b0a026b8ccc4dff72cf6fbf0fe488b6f5c32208b", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -484,7 +484,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             },\n-            (hir::ExprKind::AddrOf(_, ref expr), _, &ty::Ref(_, checked, _)) if {\n+            (\n+                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref expr),\n+                _,\n+                &ty::Ref(_, checked, _)\n+            ) if {\n                 self.infcx.can_sub(self.param_env, checked, &expected).is_ok() && !is_macro\n             } => {\n                 // We have `&T`, check if what was expected was `T`. If so,"}, {"sha": "6c24f3184ca141c84a5f60049c23207a066ec9cc", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 61, "deletions": 21, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -238,8 +238,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Unary(unop, ref oprnd) => {\n                 self.check_expr_unary(unop, oprnd, expected, needs, expr)\n             }\n-            ExprKind::AddrOf(mutbl, ref oprnd) => {\n-                self.check_expr_addr_of(mutbl, oprnd, expected, expr)\n+            ExprKind::AddrOf(kind, mutbl, ref oprnd) => {\n+                self.check_expr_addr_of(kind, mutbl, oprnd, expected, expr)\n             }\n             ExprKind::Path(ref qpath) => {\n                 self.check_expr_path(qpath, expr)\n@@ -424,6 +424,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_expr_addr_of(\n         &self,\n+        kind: hir::BorrowKind,\n         mutbl: hir::Mutability,\n         oprnd: &'tcx hir::Expr,\n         expected: Expectation<'tcx>,\n@@ -432,7 +433,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n             match ty.kind {\n                 ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                    if oprnd.is_place_expr() {\n+                    if oprnd.is_syntactic_place_expr() {\n                         // Places may legitimately have unsized types.\n                         // For example, dereferences of a fat pointer and\n                         // the last field of a struct can be unsized.\n@@ -448,24 +449,63 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n \n         let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n-        if tm.ty.references_error() {\n-            self.tcx.types.err\n-        } else {\n-            // Note: at this point, we cannot say what the best lifetime\n-            // is to use for resulting pointer.  We want to use the\n-            // shortest lifetime possible so as to avoid spurious borrowck\n-            // errors.  Moreover, the longest lifetime will depend on the\n-            // precise details of the value whose address is being taken\n-            // (and how long it is valid), which we don't know yet until type\n-            // inference is complete.\n+        match kind {\n+            _ if tm.ty.references_error() => self.tcx.types.err,\n+            hir::BorrowKind::Raw => {\n+                self.check_named_place_expr(oprnd);\n+                self.tcx.mk_ptr(tm)\n+            }\n+            hir::BorrowKind::Ref => {\n+                // Note: at this point, we cannot say what the best lifetime\n+                // is to use for resulting pointer.  We want to use the\n+                // shortest lifetime possible so as to avoid spurious borrowck\n+                // errors.  Moreover, the longest lifetime will depend on the\n+                // precise details of the value whose address is being taken\n+                // (and how long it is valid), which we don't know yet until\n+                // type inference is complete.\n+                //\n+                // Therefore, here we simply generate a region variable. The\n+                // region inferencer will then select a suitable value.\n+                // Finally, borrowck will infer the value of the region again,\n+                // this time with enough precision to check that the value\n+                // whose address was taken can actually be made to live as long\n+                // as it needs to live.\n+                let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n+                self.tcx.mk_ref(region, tm)\n+            }\n+        }\n+    }\n+\n+    /// Does this expression refer to a place that either:\n+    /// * Is based on a local or static.\n+    /// * Contains a dereference\n+    /// Note that the adjustments for the children of `expr` should already\n+    /// have been resolved.\n+    fn check_named_place_expr(&self, oprnd: &'tcx hir::Expr) {\n+        let is_named = oprnd.is_place_expr(|base| {\n+            // Allow raw borrows if there are any deref adjustments.\n             //\n-            // Therefore, here we simply generate a region variable.  The\n-            // region inferencer will then select the ultimate value.\n-            // Finally, borrowck is charged with guaranteeing that the\n-            // value whose address was taken can actually be made to live\n-            // as long as it needs to live.\n-            let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n-            self.tcx.mk_ref(region, tm)\n+            // const VAL: (i32,) = (0,);\n+            // const REF: &(i32,) = &(0,);\n+            //\n+            // &raw const VAL.0;            // ERROR\n+            // &raw const REF.0;            // OK, same as &raw const (*REF).0;\n+            //\n+            // This is maybe too permissive, since it allows\n+            // `let u = &raw const Box::new((1,)).0`, which creates an\n+            // immediately dangling raw pointer.\n+            self.tables.borrow().adjustments().get(base.hir_id).map_or(false, |x| {\n+                x.iter().any(|adj| if let Adjust::Deref(_) = adj.kind {\n+                    true\n+                } else {\n+                    false\n+                })\n+            })\n+        });\n+        if !is_named {\n+            struct_span_err!(self.tcx.sess, oprnd.span, E0745, \"cannot take address of a temporary\")\n+                .span_label(oprnd.span, \"temporary value\")\n+                .emit();\n         }\n     }\n \n@@ -740,7 +780,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.help(msg);\n             }\n             err.emit();\n-        } else if !lhs.is_place_expr() {\n+        } else if !lhs.is_syntactic_place_expr() {\n             struct_span_err!(self.tcx.sess, expr.span, E0070,\n                                 \"invalid left-hand side expression\")\n                 .span_label(expr.span, \"left-hand of expression not valid\")"}, {"sha": "321faa4a3228549e58f0cac3ed2ebee96f9e329c", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return_ty\n         };\n \n-        if !lhs_expr.is_place_expr() {\n+        if !lhs_expr.is_syntactic_place_expr() {\n             struct_span_err!(\n                 self.tcx.sess, lhs_expr.span,\n                 E0067, \"invalid left-hand side expression\")"}, {"sha": "f4fdc2882e7026781bf46f3692284769ca6ab8c5", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -645,7 +645,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprKind::AddrOf(m, ref base) => {\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref base) => {\n                 self.link_addr_of(expr, m, &base);\n \n                 // Require that when you write a `&expr` expression, the"}, {"sha": "dc26929100a6b33cc16d982439bdb60998456a7e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -754,6 +754,21 @@ impl Mutability {\n     }\n }\n \n+/// The kind of borrow in an `AddrOf` expression,\n+/// e.g., `&place` or `&raw const place`.\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+pub enum BorrowKind {\n+    /// A raw borrow, `&raw const $expr` or `&raw mut $expr`.\n+    /// The resulting type is either `*const T` or `*mut T`\n+    /// where `T = typeof($expr)`.\n+    Ref,\n+    /// A normal borrow, `&$expr` or `&mut $expr`.\n+    /// The resulting type is either `&'a T` or `&'a mut T`\n+    /// where `T = typeof($expr)` and `'a` is some lifetime.\n+    Raw,\n+}\n+\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum BinOpKind {\n     /// The `+` operator (addition)\n@@ -1071,7 +1086,7 @@ impl Expr {\n \n             ExprKind::Paren(expr) => expr.to_ty().map(TyKind::Paren)?,\n \n-            ExprKind::AddrOf(mutbl, expr) => expr\n+            ExprKind::AddrOf(BorrowKind::Ref, mutbl, expr) => expr\n                 .to_ty()\n                 .map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?,\n \n@@ -1262,8 +1277,8 @@ pub enum ExprKind {\n     /// Optionally \"qualified\" (e.g., `<Vec<T> as SomeTrait>::SomeType`).\n     Path(Option<QSelf>, Path),\n \n-    /// A referencing operation (`&a` or `&mut a`).\n-    AddrOf(Mutability, P<Expr>),\n+    /// A referencing operation (`&a`, `&mut a`, `&raw const a` or `&raw mut a`).\n+    AddrOf(BorrowKind, Mutability, P<Expr>),\n     /// A `break`, with an optional label to break, and an optional expression.\n     Break(Option<Label>, Option<P<Expr>>),\n     /// A `continue`, with an optional label."}, {"sha": "fbe28215a56c8175b96a527439daf2d33b003468", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -1128,7 +1128,7 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { kind, id, span, attrs }: &mut Expr,\n             vis.visit_expr(expr);\n             vis.visit_ty(ty);\n         }\n-        ExprKind::AddrOf(_m, ohs) => vis.visit_expr(ohs),\n+        ExprKind::AddrOf(_, _, ohs) => vis.visit_expr(ohs),\n         ExprKind::Let(pat, scrutinee) => {\n             vis.visit_pat(pat);\n             vis.visit_expr(scrutinee);"}, {"sha": "0d2e8dddce671dd5a1df766e65c6781c510e1518", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -984,16 +984,12 @@ impl<'a> State<'a> {\n             }\n             ast::TyKind::Ptr(ref mt) => {\n                 self.s.word(\"*\");\n-                match mt.mutbl {\n-                    ast::Mutability::Mutable => self.word_nbsp(\"mut\"),\n-                    ast::Mutability::Immutable => self.word_nbsp(\"const\"),\n-                }\n-                self.print_type(&mt.ty);\n+                self.print_mt(mt, true);\n             }\n             ast::TyKind::Rptr(ref lifetime, ref mt) => {\n                 self.s.word(\"&\");\n                 self.print_opt_lifetime(lifetime);\n-                self.print_mt(mt);\n+                self.print_mt(mt, false);\n             }\n             ast::TyKind::Never => {\n                 self.s.word(\"!\");\n@@ -1974,10 +1970,17 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_addr_of(&mut self,\n+                          kind: ast::BorrowKind,\n                           mutability: ast::Mutability,\n                           expr: &ast::Expr) {\n         self.s.word(\"&\");\n-        self.print_mutability(mutability);\n+        match kind {\n+            ast::BorrowKind::Ref => self.print_mutability(mutability, false),\n+            ast::BorrowKind::Raw => {\n+                self.word_nbsp(\"raw\");\n+                self.print_mutability(mutability, true);\n+            }\n+        }\n         self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n@@ -2028,8 +2031,8 @@ impl<'a> State<'a> {\n             ast::ExprKind::Unary(op, ref expr) => {\n                 self.print_expr_unary(op, expr);\n             }\n-            ast::ExprKind::AddrOf(m, ref expr) => {\n-                self.print_expr_addr_of(m, expr);\n+            ast::ExprKind::AddrOf(k, m, ref expr) => {\n+                self.print_expr_addr_of(k, m, expr);\n             }\n             ast::ExprKind::Lit(ref lit) => {\n                 self.print_literal(lit);\n@@ -2361,7 +2364,7 @@ impl<'a> State<'a> {\n                 match binding_mode {\n                     ast::BindingMode::ByRef(mutbl) => {\n                         self.word_nbsp(\"ref\");\n-                        self.print_mutability(mutbl);\n+                        self.print_mutability(mutbl, false);\n                     }\n                     ast::BindingMode::ByValue(ast::Mutability::Immutable) => {}\n                     ast::BindingMode::ByValue(ast::Mutability::Mutable) => {\n@@ -2504,17 +2507,17 @@ impl<'a> State<'a> {\n     fn print_explicit_self(&mut self, explicit_self: &ast::ExplicitSelf) {\n         match explicit_self.node {\n             SelfKind::Value(m) => {\n-                self.print_mutability(m);\n+                self.print_mutability(m, false);\n                 self.s.word(\"self\")\n             }\n             SelfKind::Region(ref lt, m) => {\n                 self.s.word(\"&\");\n                 self.print_opt_lifetime(lt);\n-                self.print_mutability(m);\n+                self.print_mutability(m, false);\n                 self.s.word(\"self\")\n             }\n             SelfKind::Explicit(ref typ, m) => {\n-                self.print_mutability(m);\n+                self.print_mutability(m, false);\n                 self.s.word(\"self\");\n                 self.word_space(\":\");\n                 self.print_type(typ)\n@@ -2746,15 +2749,15 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_mutability(&mut self, mutbl: ast::Mutability) {\n+    pub fn print_mutability(&mut self, mutbl: ast::Mutability, print_const: bool) {\n         match mutbl {\n             ast::Mutability::Mutable => self.word_nbsp(\"mut\"),\n-            ast::Mutability::Immutable => {},\n+            ast::Mutability::Immutable => if print_const { self.word_nbsp(\"const\"); },\n         }\n     }\n \n-    crate fn print_mt(&mut self, mt: &ast::MutTy) {\n-        self.print_mutability(mt.mutbl);\n+    crate fn print_mt(&mut self, mt: &ast::MutTy, print_const: bool) {\n+        self.print_mutability(mt.mutbl, print_const);\n         self.print_type(&mt.ty)\n     }\n "}, {"sha": "5ff337fb60e284ced465195c4f5338a3397f105b", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -708,7 +708,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression)\n         }\n-        ExprKind::AddrOf(_, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n+        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n         ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {"}, {"sha": "3d082101c41084e1d61cbeee6ac87ef14c94ba0c", "filename": "src/libsyntax_expand/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibsyntax_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Flibsyntax_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fbuild.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -270,7 +270,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Immutable, e))\n+        self.expr(sp, ast::ExprKind::AddrOf(ast::BorrowKind::Ref, ast::Mutability::Immutable, e))\n     }\n \n     pub fn expr_call("}, {"sha": "22de148e4c2e7ca992d6d9b4baa091afd60f8e62", "filename": "src/test/ui/raw-ref-op/raw-ref-temp-deref.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8efd31f2b97a043d73db2131dddfedd65485d50/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw-ref-op%2Fraw-ref-temp-deref.rs?ref=a8efd31f2b97a043d73db2131dddfedd65485d50", "patch": "@@ -0,0 +1,19 @@\n+// Ensure that we don't allow taking the address of temporary values\n+#![feature(raw_ref_op)]\n+\n+const PAIR: (i32, i64) = (1, 2);\n+const PAIR_REF: &(i32, i64) = &(1, 2);\n+\n+const ARRAY: [i32; 2] = [1, 2];\n+const ARRAY_REF: &[i32; 2] = &[3, 4];\n+const SLICE_REF: &[i32] = &[5, 6];\n+\n+fn main() {\n+    // These are all OK, we're not taking the address of the temporary\n+    let deref_ref = &raw const *PAIR_REF;               //~ ERROR not yet implemented\n+    let field_deref_ref = &raw const PAIR_REF.0;        //~ ERROR not yet implemented\n+    let deref_ref = &raw const *ARRAY_REF;              //~ ERROR not yet implemented\n+    let field_deref_ref = &raw const ARRAY_REF[0];      //~ ERROR not yet implemented\n+    let deref_ref = &raw const *SLICE_REF;              //~ ERROR not yet implemented\n+    let field_deref_ref = &raw const SLICE_REF[1];      //~ ERROR not yet implemented\n+}"}]}