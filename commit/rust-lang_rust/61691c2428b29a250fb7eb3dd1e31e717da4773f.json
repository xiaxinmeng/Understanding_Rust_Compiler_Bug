{"sha": "61691c2428b29a250fb7eb3dd1e31e717da4773f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNjkxYzI0MjhiMjlhMjUwZmI3ZWIzZGQxZTMxZTcxN2RhNDc3M2Y=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-28T02:32:45Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-28T02:32:45Z"}, "message": "std: Make merge_sort faster", "tree": {"sha": "72725c81a5d26ed4f41dd064791b7a6a46e23d26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72725c81a5d26ed4f41dd064791b7a6a46e23d26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61691c2428b29a250fb7eb3dd1e31e717da4773f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61691c2428b29a250fb7eb3dd1e31e717da4773f", "html_url": "https://github.com/rust-lang/rust/commit/61691c2428b29a250fb7eb3dd1e31e717da4773f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61691c2428b29a250fb7eb3dd1e31e717da4773f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e4962a26ec783ecb69745d1b109a6a1899a6d47", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e4962a26ec783ecb69745d1b109a6a1899a6d47", "html_url": "https://github.com/rust-lang/rust/commit/9e4962a26ec783ecb69745d1b109a6a1899a6d47"}], "stats": {"total": 42, "additions": 27, "deletions": 15}, "files": [{"sha": "92e037f7f66b2d62346903a095c2d08f5e639ef0", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/61691c2428b29a250fb7eb3dd1e31e717da4773f/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61691c2428b29a250fb7eb3dd1e31e717da4773f/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=61691c2428b29a250fb7eb3dd1e31e717da4773f", "patch": "@@ -3,7 +3,7 @@ Module: sort\n \n Sorting methods\n */\n-import vec::{len, slice};\n+import vec::len;\n \n export merge_sort;\n export quick_sort;\n@@ -21,29 +21,41 @@ Has worst case O(n log n) performance, best case O(n), but\n is not space efficient. This is a stable sort.\n */\n fn merge_sort<T: copy>(le: le<T>, v: [const T]) -> [T] {\n+    type slice = (uint, uint);\n+\n+    ret merge_sort_(le, v, (0u, len(v)));\n+\n+    fn merge_sort_<T: copy>(le: le<T>, v: [const T], slice: slice) -> [T] {\n+        let begin = tuple::first(slice);\n+        let end = tuple::second(slice);\n+\n+        let v_len = end - begin;\n+        if v_len == 0u { ret []; }\n+        if v_len == 1u { ret [v[begin]]; }\n+\n+        let mid = v_len / 2u + begin;\n+        let a = (begin, mid);\n+        let b = (mid, end);\n+        ret merge(le, merge_sort_(le, v, a), merge_sort_(le, v, b));\n+    }\n+\n     fn merge<T: copy>(le: le<T>, a: [T], b: [T]) -> [T] {\n-        let rs: [T] = [];\n-        let a_len: uint = len::<T>(a);\n-        let a_ix: uint = 0u;\n-        let b_len: uint = len::<T>(b);\n-        let b_ix: uint = 0u;\n+        let rs = [];\n+        vec::reserve(rs, len(a) + len(b));\n+        let a_len = len(a);\n+        let a_ix = 0u;\n+        let b_len = len(b);\n+        let b_ix = 0u;\n         while a_ix < a_len && b_ix < b_len {\n             if le(a[a_ix], b[b_ix]) {\n                 rs += [a[a_ix]];\n                 a_ix += 1u;\n             } else { rs += [b[b_ix]]; b_ix += 1u; }\n         }\n-        rs += slice::<T>(a, a_ix, a_len);\n-        rs += slice::<T>(b, b_ix, b_len);\n+        rs += vec::slice(a, a_ix, a_len);\n+        rs += vec::slice(b, b_ix, b_len);\n         ret rs;\n     }\n-    let v_len: uint = len::<T>(v);\n-    if v_len == 0u { ret []; }\n-    if v_len == 1u { ret [v[0]]; }\n-    let mid: uint = v_len / 2u;\n-    let a: [T] = slice::<T>(v, 0u, mid);\n-    let b: [T] = slice::<T>(v, mid, v_len);\n-    ret merge::<T>(le, merge_sort::<T>(le, a), merge_sort::<T>(le, b));\n }\n \n fn part<T: copy>(compare_func: le<T>, arr: [mutable T], left: uint,"}]}