{"sha": "5600c6282e699ad77d0303456fa068aa649b7007", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MDBjNjI4MmU2OTlhZDc3ZDAzMDM0NTZmYTA2OGFhNjQ5YjcwMDc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-09-04T17:52:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-01T14:37:19Z"}, "message": "move direct accesses of `node` to go through `as_local_node_id`, unless\nthey are being used as an opaque \"position identifier\"", "tree": {"sha": "df54d9d308b9521c27064dbaedbcd1d206ddb612", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df54d9d308b9521c27064dbaedbcd1d206ddb612"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5600c6282e699ad77d0303456fa068aa649b7007", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5600c6282e699ad77d0303456fa068aa649b7007", "html_url": "https://github.com/rust-lang/rust/commit/5600c6282e699ad77d0303456fa068aa649b7007", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5600c6282e699ad77d0303456fa068aa649b7007/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa40a1cad0f359bfc799545e70bb5c7c9e72ba93", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa40a1cad0f359bfc799545e70bb5c7c9e72ba93", "html_url": "https://github.com/rust-lang/rust/commit/aa40a1cad0f359bfc799545e70bb5c7c9e72ba93"}], "stats": {"total": 1219, "additions": 652, "deletions": 567}, "files": [{"sha": "b8d96cd3ba72b0e184e10fea95c21f042ae06965", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -274,7 +274,7 @@ impl<'ast> Map<'ast> {\n \n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n-            Some(def_id.node)\n+            Some(def_id.xxx_node)\n         } else {\n             None\n         }\n@@ -301,6 +301,10 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n+    pub fn get_if_local(&self, id: DefId) -> Option<Node<'ast>> {\n+        self.as_local_node_id(id).map(|id| self.get(id))\n+    }\n+\n     /// Retrieve the Node corresponding to `id`, returning None if\n     /// cannot be found.\n     pub fn find(&self, id: NodeId) -> Option<Node<'ast>> {\n@@ -609,9 +613,13 @@ impl<'ast> Map<'ast> {\n             .unwrap_or_else(|| panic!(\"AstMap.span: could not find span for id {:?}\", id))\n     }\n \n+    pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n+        self.as_local_node_id(id).map(|id| self.span(id))\n+    }\n+\n     pub fn def_id_span(&self, def_id: DefId, fallback: Span) -> Span {\n-        if def_id.is_local() {\n-            self.opt_span(def_id.node).unwrap_or(fallback)\n+        if let Some(node_id) = self.as_local_node_id(def_id) {\n+            self.opt_span(node_id).unwrap_or(fallback)\n         } else {\n             fallback\n         }"}, {"sha": "70a969e4d8221142fe79f35a9505c7fd2dac32e0", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -33,7 +33,7 @@ pub struct MethodInfo {\n \n pub fn get_symbol(cstore: &cstore::CStore, def: DefId) -> String {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_symbol(&cdata, def.node)\n+    decoder::get_symbol(&cdata, def.xxx_node)\n }\n \n /// Iterates over all the language items in the given crate.\n@@ -59,7 +59,7 @@ pub fn each_child_of_item<F>(cstore: &cstore::CStore,\n     };\n     decoder::each_child_of_item(cstore.intr.clone(),\n                                 &*crate_data,\n-                                def_id.node,\n+                                def_id.xxx_node,\n                                 get_crate_data,\n                                 callback)\n }\n@@ -83,7 +83,7 @@ pub fn each_top_level_item_of_crate<F>(cstore: &cstore::CStore,\n pub fn get_item_path(tcx: &ty::ctxt, def: DefId) -> Vec<ast_map::PathElem> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    let path = decoder::get_item_path(&*cdata, def.node);\n+    let path = decoder::get_item_path(&*cdata, def.xxx_node);\n \n     cdata.with_local_path(|cpath| {\n         let mut r = Vec::with_capacity(cpath.len() + path.len());\n@@ -96,7 +96,7 @@ pub fn get_item_path(tcx: &ty::ctxt, def: DefId) -> Vec<ast_map::PathElem> {\n pub fn get_item_name(tcx: &ty::ctxt, def: DefId) -> ast::Name {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_item_name(&cstore.intr, &cdata, def.node)\n+    decoder::get_item_name(&cstore.intr, &cdata, def.xxx_node)\n }\n \n pub enum FoundAst<'ast> {\n@@ -113,87 +113,87 @@ pub fn maybe_get_item_ast<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId,\n                                 -> FoundAst<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::maybe_get_item_ast(&*cdata, tcx, def.node, decode_inlined_item)\n+    decoder::maybe_get_item_ast(&*cdata, tcx, def.xxx_node, decode_inlined_item)\n }\n \n /// Returns information about the given implementation.\n pub fn get_impl_items(cstore: &cstore::CStore, impl_def_id: DefId)\n                       -> Vec<ty::ImplOrTraitItemId> {\n     let cdata = cstore.get_crate_data(impl_def_id.krate);\n-    decoder::get_impl_items(&*cdata, impl_def_id.node)\n+    decoder::get_impl_items(&*cdata, impl_def_id.xxx_node)\n }\n \n pub fn get_impl_or_trait_item<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                                     -> ty::ImplOrTraitItem<'tcx> {\n     let cdata = tcx.sess.cstore.get_crate_data(def.krate);\n     decoder::get_impl_or_trait_item(tcx.sess.cstore.intr.clone(),\n                                     &*cdata,\n-                                    def.node,\n+                                    def.xxx_node,\n                                     tcx)\n }\n \n pub fn get_trait_name(cstore: &cstore::CStore, def: DefId) -> ast::Name {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_name(cstore.intr.clone(),\n                             &*cdata,\n-                            def.node)\n+                            def.xxx_node)\n }\n \n pub fn is_static_method(cstore: &cstore::CStore, def: DefId) -> bool {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::is_static_method(&*cdata, def.node)\n+    decoder::is_static_method(&*cdata, def.xxx_node)\n }\n \n pub fn get_trait_item_def_ids(cstore: &cstore::CStore, def: DefId)\n                               -> Vec<ty::ImplOrTraitItemId> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_item_def_ids(&*cdata, def.node)\n+    decoder::get_trait_item_def_ids(&*cdata, def.xxx_node)\n }\n \n pub fn get_item_variances(cstore: &cstore::CStore,\n                           def: DefId) -> ty::ItemVariances {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_item_variances(&*cdata, def.node)\n+    decoder::get_item_variances(&*cdata, def.xxx_node)\n }\n \n pub fn get_provided_trait_methods<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                         def: DefId)\n                                         -> Vec<Rc<ty::Method<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.node, tcx)\n+    decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.xxx_node, tcx)\n }\n \n pub fn get_associated_consts<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                                    -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_associated_consts(cstore.intr.clone(), &*cdata, def.node, tcx)\n+    decoder::get_associated_consts(cstore.intr.clone(), &*cdata, def.xxx_node, tcx)\n }\n \n pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: DefId)\n                           -> Option<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_type_name_if_impl(&*cdata, def.node)\n+    decoder::get_type_name_if_impl(&*cdata, def.xxx_node)\n }\n \n pub fn get_methods_if_impl(cstore: &cstore::CStore,\n                                   def: DefId)\n                                -> Option<Vec<MethodInfo> > {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_methods_if_impl(cstore.intr.clone(), &*cdata, def.node)\n+    decoder::get_methods_if_impl(cstore.intr.clone(), &*cdata, def.xxx_node)\n }\n \n pub fn get_item_attrs(cstore: &cstore::CStore,\n                       def_id: DefId)\n                       -> Vec<ast::Attribute> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_item_attrs(&*cdata, def_id.node)\n+    decoder::get_item_attrs(&*cdata, def_id.xxx_node)\n }\n \n pub fn get_struct_field_names(cstore: &cstore::CStore, def: DefId) -> Vec<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_struct_field_names(&cstore.intr, &*cdata, def.node)\n+    decoder::get_struct_field_names(&cstore.intr, &*cdata, def.xxx_node)\n }\n \n pub fn get_struct_field_attrs(cstore: &cstore::CStore, def: DefId) -> FnvHashMap<ast::NodeId,\n@@ -207,35 +207,35 @@ pub fn get_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       -> ty::TypeScheme<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_type(&*cdata, def.node, tcx)\n+    decoder::get_type(&*cdata, def.xxx_node, tcx)\n }\n \n pub fn get_trait_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::TraitDef<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_trait_def(&*cdata, def.node, tcx)\n+    decoder::get_trait_def(&*cdata, def.xxx_node, tcx)\n }\n \n pub fn get_adt_def<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_adt_def(&cstore.intr, &*cdata, def.node, tcx)\n+    decoder::get_adt_def(&cstore.intr, &*cdata, def.xxx_node, tcx)\n }\n \n pub fn get_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                             -> ty::GenericPredicates<'tcx>\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_predicates(&*cdata, def.node, tcx)\n+    decoder::get_predicates(&*cdata, def.xxx_node, tcx)\n }\n \n pub fn get_super_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n                                   -> ty::GenericPredicates<'tcx>\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_super_predicates(&*cdata, def.node, tcx)\n+    decoder::get_super_predicates(&*cdata, def.xxx_node, tcx)\n }\n \n pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n@@ -244,7 +244,7 @@ pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_polarity(&*cdata, def.node)\n+    decoder::get_impl_polarity(&*cdata, def.xxx_node)\n }\n \n pub fn get_custom_coerce_unsized_kind<'tcx>(\n@@ -254,7 +254,7 @@ pub fn get_custom_coerce_unsized_kind<'tcx>(\n {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_custom_coerce_unsized_kind(&*cdata, def.node)\n+    decoder::get_custom_coerce_unsized_kind(&*cdata, def.xxx_node)\n }\n \n // Given a def_id for an impl, return the trait it implements,\n@@ -264,7 +264,7 @@ pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             -> Option<ty::TraitRef<'tcx>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_trait(&*cdata, def.node, tcx)\n+    decoder::get_impl_trait(&*cdata, def.xxx_node, tcx)\n }\n \n pub fn get_native_libraries(cstore: &cstore::CStore, crate_num: ast::CrateNum)\n@@ -279,7 +279,7 @@ pub fn each_inherent_implementation_for_type<F>(cstore: &cstore::CStore,\n     F: FnMut(DefId),\n {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::each_inherent_implementation_for_type(&*cdata, def_id.node, callback)\n+    decoder::each_inherent_implementation_for_type(&*cdata, def_id.xxx_node, callback)\n }\n \n pub fn each_implementation_for_trait<F>(cstore: &cstore::CStore,\n@@ -300,15 +300,15 @@ pub fn get_trait_of_item(cstore: &cstore::CStore,\n                          tcx: &ty::ctxt)\n                          -> Option<DefId> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_trait_of_item(&*cdata, def_id.node, tcx)\n+    decoder::get_trait_of_item(&*cdata, def_id.xxx_node, tcx)\n }\n \n pub fn get_tuple_struct_definition_if_ctor(cstore: &cstore::CStore,\n                                            def_id: DefId)\n     -> Option<DefId>\n {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::get_tuple_struct_definition_if_ctor(&*cdata, def_id.node)\n+    decoder::get_tuple_struct_definition_if_ctor(&*cdata, def_id.xxx_node)\n }\n \n pub fn get_dylib_dependency_formats(cstore: &cstore::CStore,\n@@ -330,7 +330,7 @@ pub fn get_method_arg_names(cstore: &cstore::CStore, did: DefId)\n     -> Vec<String>\n {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::get_method_arg_names(&*cdata, did.node)\n+    decoder::get_method_arg_names(&*cdata, did.xxx_node)\n }\n \n pub fn get_reachable_ids(cstore: &cstore::CStore, cnum: ast::CrateNum)\n@@ -342,24 +342,24 @@ pub fn get_reachable_ids(cstore: &cstore::CStore, cnum: ast::CrateNum)\n \n pub fn is_typedef(cstore: &cstore::CStore, did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_typedef(&*cdata, did.node)\n+    decoder::is_typedef(&*cdata, did.xxx_node)\n }\n \n pub fn is_const_fn(cstore: &cstore::CStore, did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_const_fn(&*cdata, did.node)\n+    decoder::is_const_fn(&*cdata, did.xxx_node)\n }\n \n pub fn is_impl(cstore: &cstore::CStore, did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_impl(&*cdata, did.node)\n+    decoder::is_impl(&*cdata, did.xxx_node)\n }\n \n pub fn get_stability(cstore: &cstore::CStore,\n                      def: DefId)\n                      -> Option<attr::Stability> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_stability(&*cdata, def.node)\n+    decoder::get_stability(&*cdata, def.xxx_node)\n }\n \n pub fn is_staged_api(cstore: &cstore::CStore, krate: ast::CrateNum) -> bool {\n@@ -369,21 +369,21 @@ pub fn is_staged_api(cstore: &cstore::CStore, krate: ast::CrateNum) -> bool {\n pub fn get_repr_attrs(cstore: &cstore::CStore, def: DefId)\n                       -> Vec<attr::ReprAttr> {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_repr_attrs(&*cdata, def.node)\n+    decoder::get_repr_attrs(&*cdata, def.xxx_node)\n }\n \n pub fn is_defaulted_trait(cstore: &cstore::CStore, trait_def_id: DefId) -> bool {\n     let cdata = cstore.get_crate_data(trait_def_id.krate);\n-    decoder::is_defaulted_trait(&*cdata, trait_def_id.node)\n+    decoder::is_defaulted_trait(&*cdata, trait_def_id.xxx_node)\n }\n \n pub fn is_default_impl(cstore: &cstore::CStore, impl_did: DefId) -> bool {\n     let cdata = cstore.get_crate_data(impl_did.krate);\n-    decoder::is_default_impl(&*cdata, impl_did.node)\n+    decoder::is_default_impl(&*cdata, impl_did.xxx_node)\n }\n \n pub fn is_extern_fn(cstore: &cstore::CStore, did: DefId,\n                     tcx: &ty::ctxt) -> bool {\n     let cdata = cstore.get_crate_data(did.krate);\n-    decoder::is_extern_fn(&*cdata, did.node, tcx)\n+    decoder::is_extern_fn(&*cdata, did.xxx_node, tcx)\n }"}, {"sha": "54a815b454aac37d65025837ee3dbffd4987dfad", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -170,7 +170,7 @@ fn item_symbol(item: rbml::Doc) -> String {\n \n fn translated_def_id(cdata: Cmd, d: rbml::Doc) -> DefId {\n     let id = reader::doc_as_u64(d);\n-    let def_id = DefId { krate: (id >> 32) as u32, node: id as u32 };\n+    let def_id = DefId { krate: (id >> 32) as u32, xxx_node: id as u32 };\n     translate_def_id(cdata, def_id)\n }\n \n@@ -378,7 +378,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n         let mut disr_val = 0;\n         reader::tagged_docs(doc, tag_items_data_item_variant).map(|p| {\n             let did = translated_def_id(cdata, p);\n-            let item = cdata.lookup_item(did.node);\n+            let item = cdata.lookup_item(did.xxx_node);\n \n             if let Some(disr) = variant_disr_val(item) {\n                 disr_val = disr;\n@@ -428,7 +428,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n     }\n \n     let doc = cdata.lookup_item(item_id);\n-    let did = DefId { krate: cdata.cnum, node: item_id };\n+    let did = DefId { krate: cdata.cnum, xxx_node: item_id };\n     let (kind, variants) = match item_family(doc) {\n         Enum => (ty::AdtKind::Enum,\n                  get_enum_variants(intr, cdata, doc, tcx)),\n@@ -448,7 +448,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n             // from the ctor.\n             debug!(\"evaluating the ctor-type of {:?}\",\n                    variant.name);\n-            let ctor_ty = get_type(cdata, variant.did.node, tcx).ty;\n+            let ctor_ty = get_type(cdata, variant.did.xxx_node, tcx).ty;\n             debug!(\"evaluating the ctor-type of {:?}.. {:?}\",\n                    variant.name,\n                    ctor_ty);\n@@ -468,7 +468,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n         } else {\n             for field in &variant.fields {\n                 debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n-                let ty = get_type(cdata, field.did.node, tcx).ty;\n+                let ty = get_type(cdata, field.did.xxx_node, tcx).ty;\n                 field.fulfill_ty(ty);\n                 debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n                        variant.name, field.name, ty);\n@@ -501,7 +501,7 @@ pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n                       -> ty::TypeScheme<'tcx>\n {\n     let item_doc = cdata.lookup_item(id);\n-    let t = item_type(DefId { krate: cdata.cnum, node: id }, item_doc, tcx,\n+    let t = item_type(DefId { krate: cdata.cnum, xxx_node: id }, item_doc, tcx,\n                       cdata);\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n     ty::TypeScheme {\n@@ -634,7 +634,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n         };\n \n         // Get the item.\n-        match crate_data.get_item(child_def_id.node) {\n+        match crate_data.get_item(child_def_id.xxx_node) {\n             None => {}\n             Some(child_item_doc) => {\n                 // Hand off the item to the callback.\n@@ -652,12 +652,12 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n     for inherent_impl_def_id_doc in reader::tagged_docs(item_doc,\n                                                              tag_items_data_item_inherent_impl) {\n         let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc, cdata);\n-        if let Some(inherent_impl_doc) = cdata.get_item(inherent_impl_def_id.node) {\n+        if let Some(inherent_impl_doc) = cdata.get_item(inherent_impl_def_id.xxx_node) {\n             for impl_item_def_id_doc in reader::tagged_docs(inherent_impl_doc,\n                                                                  tag_item_impl_item) {\n                 let impl_item_def_id = item_def_id(impl_item_def_id_doc,\n                                                    cdata);\n-                if let Some(impl_method_doc) = cdata.get_item(impl_item_def_id.node) {\n+                if let Some(impl_method_doc) = cdata.get_item(impl_item_def_id.xxx_node) {\n                     if let StaticMethod = item_family(impl_method_doc) {\n                         // Hand off the static method to the callback.\n                         let static_method_name = item_name(&*intr, impl_method_doc);\n@@ -693,7 +693,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n         };\n \n         // Get the item.\n-        if let Some(child_item_doc) = crate_data.get_item(child_def_id.node) {\n+        if let Some(child_item_doc) = crate_data.get_item(child_def_id.xxx_node) {\n             // Hand off the item to the callback.\n             let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n             // These items have a public visibility because they're part of\n@@ -771,7 +771,7 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeI\n         Err(path) => {\n             match item_parent_item(cdata, item_doc) {\n                 Some(did) => {\n-                    let parent_item = cdata.lookup_item(did.node);\n+                    let parent_item = cdata.lookup_item(did.xxx_node);\n                     match decode_inlined_item(cdata, tcx, path, parent_item) {\n                         Ok(ii) => csearch::FoundAst::FoundParent(did, ii),\n                         Err(_) => csearch::FoundAst::NotFound\n@@ -852,7 +852,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n     let def_id = item_def_id(item_doc, cdata);\n \n     let container_id = item_require_parent_item(cdata, item_doc);\n-    let container_doc = cdata.lookup_item(container_id.node);\n+    let container_doc = cdata.lookup_item(container_id.xxx_node);\n     let container = match item_family(container_doc) {\n         Trait => TraitContainer(container_id),\n         _ => ImplContainer(container_id),\n@@ -932,12 +932,12 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n \n     reader::tagged_docs(item, tag_item_trait_item).filter_map(|mth_id| {\n         let did = item_def_id(mth_id, cdata);\n-        let mth = cdata.lookup_item(did.node);\n+        let mth = cdata.lookup_item(did.xxx_node);\n \n         if item_sort(mth) == Some('p') {\n             let trait_item = get_impl_or_trait_item(intr.clone(),\n                                                     cdata,\n-                                                    did.node,\n+                                                    did.xxx_node,\n                                                     tcx);\n             if let ty::MethodTraitItem(ref method) = trait_item {\n                 Some((*method).clone())\n@@ -960,13 +960,13 @@ pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n     [tag_item_trait_item, tag_item_impl_item].iter().flat_map(|&tag| {\n         reader::tagged_docs(item, tag).filter_map(|ac_id| {\n             let did = item_def_id(ac_id, cdata);\n-            let ac_doc = cdata.lookup_item(did.node);\n+            let ac_doc = cdata.lookup_item(did.xxx_node);\n \n             match item_sort(ac_doc) {\n                 Some('C') | Some('c') => {\n                     let trait_item = get_impl_or_trait_item(intr.clone(),\n                                                             cdata,\n-                                                            did.node,\n+                                                            did.xxx_node,\n                                                             tcx);\n                     if let ty::ConstTraitItem(ref ac) = trait_item {\n                         Some((*ac).clone())\n@@ -1011,7 +1011,7 @@ pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n \n     let mut impl_methods = Vec::new();\n     for impl_method_id in impl_method_ids {\n-        let impl_method_doc = cdata.lookup_item(impl_method_id.node);\n+        let impl_method_doc = cdata.lookup_item(impl_method_id.xxx_node);\n         let family = item_family(impl_method_doc);\n         match family {\n             StaticMethod | Method => {\n@@ -1047,7 +1047,7 @@ pub fn get_item_attrs(cdata: Cmd,\n     // we assume that someone passing in a tuple struct ctor is actually wanting to\n     // look at the definition\n     let node_id = get_tuple_struct_definition_if_ctor(cdata, orig_node_id);\n-    let node_id = node_id.map(|x| x.node).unwrap_or(orig_node_id);\n+    let node_id = node_id.map(|x| x.xxx_node).unwrap_or(orig_node_id);\n     let item = cdata.lookup_item(node_id);\n     get_attributes(item)\n }\n@@ -1228,14 +1228,14 @@ pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Write) -> io::Result<()>\n // crate to the correct local crate number.\n pub fn translate_def_id(cdata: Cmd, did: DefId) -> DefId {\n     if did.is_local() {\n-        return DefId { krate: cdata.cnum, node: did.node };\n+        return DefId { krate: cdata.cnum, xxx_node: did.xxx_node };\n     }\n \n     match cdata.cnum_map.borrow().get(&did.krate) {\n         Some(&n) => {\n             DefId {\n                 krate: n,\n-                node: did.node,\n+                xxx_node: did.xxx_node,\n             }\n         }\n         None => panic!(\"didn't find a crate in the cnum_map\")\n@@ -1246,12 +1246,12 @@ pub fn translate_def_id(cdata: Cmd, did: DefId) -> DefId {\n // for an external crate.\n fn reverse_translate_def_id(cdata: Cmd, did: DefId) -> Option<DefId> {\n     if did.krate == cdata.cnum {\n-        return Some(DefId { krate: LOCAL_CRATE, node: did.node });\n+        return Some(DefId { krate: LOCAL_CRATE, xxx_node: did.xxx_node });\n     }\n \n     for (&local, &global) in cdata.cnum_map.borrow().iter() {\n         if global == did.krate {\n-            return Some(DefId { krate: local, node: did.node });\n+            return Some(DefId { krate: local, xxx_node: did.xxx_node });\n         }\n     }\n \n@@ -1277,7 +1277,7 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n     F: FnMut(DefId),\n {\n     if cdata.cnum == def_id.krate {\n-        let item_doc = cdata.lookup_item(def_id.node);\n+        let item_doc = cdata.lookup_item(def_id.xxx_node);\n         for impl_doc in reader::tagged_docs(item_doc, tag_items_data_item_extension_impl) {\n             callback(item_def_id(impl_doc, cdata));\n         }\n@@ -1306,7 +1306,7 @@ pub fn get_trait_of_item(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n         None => return None,\n         Some(item_id) => item_id,\n     };\n-    let parent_item_doc = cdata.lookup_item(parent_item_id.node);\n+    let parent_item_doc = cdata.lookup_item(parent_item_id.xxx_node);\n     match item_family(parent_item_doc) {\n         Trait => Some(item_def_id(parent_item_doc, cdata)),\n         Impl | DefaultImpl => {\n@@ -1404,7 +1404,7 @@ pub fn get_reachable_ids(cdata: Cmd) -> Vec<DefId> {\n     reader::tagged_docs(items, tag_reachable_id).map(|doc| {\n         DefId {\n             krate: cdata.cnum,\n-            node: reader::doc_as_u32(doc),\n+            xxx_node: reader::doc_as_u32(doc),\n         }\n     }).collect()\n }"}, {"sha": "14e5e8b41ffbb9f0e272f1403eb7fa6b69978049", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -75,6 +75,12 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub reachable: &'a NodeSet,\n }\n \n+impl<'a, 'tcx> EncodeContext<'a,'tcx> {\n+    fn local_id(&self, def_id: DefId) -> NodeId {\n+        self.tcx.map.as_local_node_id(def_id).unwrap()\n+    }\n+}\n+\n fn encode_name(rbml_w: &mut Encoder, name: Name) {\n     rbml_w.wr_tagged_str(tag_paths_data_name, &name.as_str());\n }\n@@ -109,11 +115,11 @@ fn encode_family(rbml_w: &mut Encoder, c: char) {\n }\n \n pub fn def_to_u64(did: DefId) -> u64 {\n-    (did.krate as u64) << 32 | (did.node as u64)\n+    (did.krate as u64) << 32 | (did.xxx_node as u64)\n }\n \n pub fn def_to_string(did: DefId) -> String {\n-    format!(\"{}:{}\", did.krate, did.node)\n+    format!(\"{}:{}\", did.krate, did.xxx_node)\n }\n \n fn encode_item_variances(rbml_w: &mut Encoder,\n@@ -281,7 +287,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     let def = ecx.tcx.lookup_adt_def(ecx.tcx.map.local_def_id(id));\n     for variant in &def.variants {\n         let vid = variant.did;\n-        assert!(vid.is_local());\n+        let variant_node_id = ecx.local_id(vid);\n \n         if let ty::VariantKind::Dict = variant.kind() {\n             // tuple-like enum variant fields aren't really items so\n@@ -292,7 +298,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         }\n \n         index.push(IndexEntry {\n-            node: vid.node,\n+            node: vid.xxx_node,\n             pos: rbml_w.mark_stable_position(),\n         });\n         rbml_w.start_tag(tag_items_data_item);\n@@ -319,9 +325,9 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n             encode_disr_val(ecx, rbml_w, specified_disr_val);\n             disr_val = specified_disr_val;\n         }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, vid.node);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, variant_node_id);\n \n-        ecx.tcx.map.with_path(vid.node, |path| encode_path(rbml_w, path));\n+        ecx.tcx.map.with_path(variant_node_id, |path| encode_path(rbml_w, path));\n         rbml_w.end_tag();\n         disr_val = disr_val.wrapping_add(1);\n     }\n@@ -405,8 +411,21 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n                                     rbml_w: &mut Encoder,\n                                     mod_path: PathElems,\n                                     exp: &def::Export) {\n-    if let Some(ast_map::NodeItem(item)) = ecx.tcx.map.find(exp.def_id.node) {\n-        let path_differs = ecx.tcx.map.with_path(exp.def_id.node, |path| {\n+    let exp_node_id = if let Some(n) = ecx.tcx.map.as_local_node_id(exp.def_id) {\n+        n\n+    } else {\n+        // Before the refactor that introducd `as_local_node_id`, we\n+        // were just extracting the node and checking into the\n+        // ast-map. Since the node might have been from another crate,\n+        // this was a tenuous thing to do at best. Anyway, I'm not\n+        // 100% clear on why it's ok to ignore things from other\n+        // crates, but it seems to be what we were doing pre-refactor.\n+        // -nmatsakis\n+        return;\n+    };\n+\n+    if let Some(ast_map::NodeItem(item)) = ecx.tcx.map.find(exp_node_id) {\n+        let path_differs = ecx.tcx.map.with_path(exp_node_id, |path| {\n             let (mut a, mut b) = (path, mod_path.clone());\n             loop {\n                 match (a.next(), b.next()) {\n@@ -476,11 +495,10 @@ fn encode_reexports(ecx: &EncodeContext,\n         Some(exports) => {\n             debug!(\"(encoding info for module) found reexports for {}\", id);\n             for exp in exports {\n-                debug!(\"(encoding info for module) reexport '{}' ({}/{}) for \\\n+                debug!(\"(encoding info for module) reexport '{}' ({:?}) for \\\n                         {}\",\n                        exp.name,\n-                       exp.def_id.krate,\n-                       exp.def_id.node,\n+                       exp.def_id,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n                 rbml_w.wr_tagged_u64(tag_items_data_item_reexport_def_id,\n@@ -615,7 +633,7 @@ fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           field: ty::FieldDef<'tcx>,\n                           global_index: &mut Vec<IndexEntry>) {\n     let nm = field.name;\n-    let id = field.did.node;\n+    let id = ecx.local_id(field.did);\n \n     let pos = rbml_w.mark_stable_position();\n     global_index.push(IndexEntry {\n@@ -792,7 +810,7 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n     encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 'C');\n \n-    encode_bounds_and_type_for_item(rbml_w, ecx, associated_const.def_id.local_id());\n+    encode_bounds_and_type_for_item(rbml_w, ecx, ecx.local_id(associated_const.def_id));\n \n     let stab = stability::lookup(ecx.tcx, associated_const.def_id);\n     encode_stability(rbml_w, stab);\n@@ -831,7 +849,8 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_stability(rbml_w, stab);\n \n     // The type for methods gets encoded twice, which is unfortunate.\n-    encode_bounds_and_type_for_item(rbml_w, ecx, m.def_id.local_id());\n+    let m_node_id = ecx.local_id(m.def_id);\n+    encode_bounds_and_type_for_item(rbml_w, ecx, m_node_id);\n \n     let elem = ast_map::PathName(m.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem)));\n@@ -850,7 +869,8 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             }\n             encode_constness(rbml_w, sig.constness);\n             if !any_types {\n-                encode_symbol(ecx, rbml_w, m.def_id.node);\n+                let m_id = ecx.local_id(m.def_id);\n+                encode_symbol(ecx, rbml_w, m_id);\n             }\n             encode_method_argument_names(rbml_w, &sig.decl);\n         }\n@@ -1166,7 +1186,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         match struct_def.ctor_id {\n             Some(ctor_id) => {\n                 encode_info_for_struct_ctor(ecx, rbml_w, item.name,\n-                                            ctor_id, index, def_id.node);\n+                                            ctor_id, index, item.id);\n             }\n             None => {}\n         }\n@@ -1253,7 +1273,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             };\n \n             index.push(IndexEntry {\n-                node: trait_item_def_id.def_id().node,\n+                node: trait_item_def_id.def_id().xxx_node,\n                 pos: rbml_w.mark_stable_position(),\n             });\n \n@@ -1344,7 +1364,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n \n             index.push(IndexEntry {\n-                node: item_def_id.def_id().node,\n+                node: item_def_id.def_id().xxx_node,\n                 pos: rbml_w.mark_stable_position(),\n             });\n \n@@ -1370,8 +1390,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                     encode_family(rbml_w, 'C');\n \n-                    encode_bounds_and_type_for_item(rbml_w, ecx,\n-                                                    associated_const.def_id.local_id());\n+                    encode_bounds_and_type_for_item(rbml_w,\n+                                                    ecx,\n+                                                    ecx.local_id(associated_const.def_id));\n \n                     is_nonstatic_method = false;\n                 }\n@@ -1394,7 +1415,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                           METHOD_FAMILY);\n                         }\n                     }\n-                    encode_bounds_and_type_for_item(rbml_w, ecx, method_def_id.local_id());\n+                    encode_bounds_and_type_for_item(rbml_w, ecx, ecx.local_id(method_def_id));\n \n                     is_nonstatic_method = method_ty.explicit_self !=\n                         ty::StaticExplicitSelfCategory;\n@@ -1439,8 +1460,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     if is_nonstatic_method {\n                         // FIXME: I feel like there is something funny\n                         // going on.\n-                        encode_bounds_and_type_for_item(rbml_w, ecx,\n-                            item_def_id.def_id().local_id());\n+                        encode_bounds_and_type_for_item(\n+                            rbml_w,\n+                            ecx,\n+                            ecx.local_id(item_def_id.def_id()));\n                     }\n \n                     if body.is_some() {\n@@ -1716,10 +1739,10 @@ fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n \n     for (i, &def_id) in ecx.tcx.lang_items.items() {\n         if let Some(id) = def_id {\n-            if id.is_local() {\n+            if let Some(id) = ecx.tcx.map.as_local_node_id(id) {\n                 rbml_w.start_tag(tag_lang_items_item);\n                 rbml_w.wr_tagged_u32(tag_lang_items_item_id, i as u32);\n-                rbml_w.wr_tagged_u32(tag_lang_items_item_node_id, id.node as u32);\n+                rbml_w.wr_tagged_u32(tag_lang_items_item_node_id, id as u32);\n                 rbml_w.end_tag();\n             }\n         }"}, {"sha": "f023049d78f61bfcd4794259162de85b507d97af", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -209,18 +209,14 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             }\n             'B' => {\n                 assert_eq!(self.next(), '[');\n-                // this is the wrong NodeId, but `param_id` is only accessed\n-                // by the receiver-matching code in collect, which won't\n-                // be going down this code path, and anyway I will kill it\n-                // the moment wfcheck becomes the standard.\n                 let def_id = self.parse_def(NominalType);\n                 let space = self.parse_param_space();\n                 assert_eq!(self.next(), '|');\n                 let index = self.parse_u32();\n                 assert_eq!(self.next(), '|');\n                 let name = token::intern(&self.parse_str(']'));\n                 ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                    param_id: def_id,\n+                    def_id: def_id,\n                     space: space,\n                     index: index,\n                     name: name\n@@ -739,7 +735,7 @@ fn parse_defid(buf: &[u8]) -> DefId {\n         None => panic!(\"internal error: parse_defid: id expected, found {:?}\",\n                        def_part)\n     };\n-    DefId { krate: crate_num, node: def_num }\n+    DefId { krate: crate_num, xxx_node: def_num }\n }\n \n fn parse_unsafety(c: char) -> hir::Unsafety {"}, {"sha": "01e6e30b53f77dbc879e5117fafafe55bf389146", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -250,7 +250,7 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n         }\n         ty::ReEarlyBound(ref data) => {\n             mywrite!(w, \"B[{}|{}|{}|{}]\",\n-                     (cx.ds)(data.param_id),\n+                     (cx.ds)(data.def_id),\n                      data.space.to_uint(),\n                      data.index,\n                      data.name);"}, {"sha": "a06a6b2509af85cc1d4706eabafb519289a7959b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -229,7 +229,7 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     /// refer to the current crate and to the new, inlined node-id.\n     pub fn tr_intern_def_id(&self, did: DefId) -> DefId {\n         assert_eq!(did.krate, LOCAL_CRATE);\n-        DefId { krate: LOCAL_CRATE, node: self.tr_id(did.node) }\n+        DefId { krate: LOCAL_CRATE, xxx_node: self.tr_id(did.xxx_node) }\n     }\n \n     /// Translates a `Span` from an extern crate to the corresponding `Span`\n@@ -951,7 +951,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    let lid = DefId { krate: LOCAL_CRATE, node: id };\n+    let lid = tcx.map.local_def_id(id);\n     if let Some(type_scheme) = tcx.tcache.borrow().get(&lid) {\n         rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n             rbml_w.id(id);\n@@ -1453,7 +1453,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     }\n                     c::tag_table_tcache => {\n                         let type_scheme = val_dsr.read_type_scheme(dcx);\n-                        let lid = DefId { krate: LOCAL_CRATE, node: id };\n+                        let lid = dcx.tcx.map.local_def_id(id);\n                         dcx.tcx.register_item_type(lid, type_scheme);\n                     }\n                     c::tag_table_param_defs => {"}, {"sha": "acb66b8efe7eb059c9ec2a9839b39230a54250ce", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -240,37 +240,43 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                 match self.def_map.borrow().get(&e.id).map(|d| d.base_def) {\n                     Some(DefStatic(def_id, _)) |\n                     Some(DefAssociatedConst(def_id)) |\n-                    Some(DefConst(def_id)) if def_id.is_local() => {\n-                        match self.ast_map.get(def_id.node) {\n-                          ast_map::NodeItem(item) =>\n-                            self.visit_item(item),\n-                          ast_map::NodeTraitItem(item) =>\n-                            self.visit_trait_item(item),\n-                          ast_map::NodeImplItem(item) =>\n-                            self.visit_impl_item(item),\n-                          ast_map::NodeForeignItem(_) => {},\n-                          _ => {\n-                              self.sess.span_bug(\n-                                  e.span,\n-                                  &format!(\"expected item, found {}\",\n-                                           self.ast_map.node_to_string(def_id.node)));\n-                          }\n+                    Some(DefConst(def_id)) => {\n+                        if let Some(node_id) = self.ast_map.as_local_node_id(def_id) {\n+                            match self.ast_map.get(node_id) {\n+                                ast_map::NodeItem(item) =>\n+                                    self.visit_item(item),\n+                                ast_map::NodeTraitItem(item) =>\n+                                    self.visit_trait_item(item),\n+                                ast_map::NodeImplItem(item) =>\n+                                    self.visit_impl_item(item),\n+                                ast_map::NodeForeignItem(_) => {},\n+                                _ => {\n+                                    self.sess.span_bug(\n+                                        e.span,\n+                                        &format!(\"expected item, found {}\",\n+                                                 self.ast_map.node_to_string(node_id)));\n+                                }\n+                            }\n                         }\n                     }\n                     // For variants, we only want to check expressions that\n                     // affect the specific variant used, but we need to check\n                     // the whole enum definition to see what expression that\n                     // might be (if any).\n-                    Some(DefVariant(enum_id, variant_id, false)) if enum_id.is_local() => {\n-                        if let hir::ItemEnum(ref enum_def, ref generics) =\n-                               self.ast_map.expect_item(enum_id.local_id()).node {\n-                            self.populate_enum_discriminants(enum_def);\n-                            let variant = self.ast_map.expect_variant(variant_id.local_id());\n-                            self.visit_variant(variant, generics);\n-                        } else {\n-                            self.sess.span_bug(e.span,\n-                                \"`check_static_recursion` found \\\n-                                 non-enum in DefVariant\");\n+                    Some(DefVariant(enum_id, variant_id, false)) => {\n+                        if let Some(enum_node_id) = self.ast_map.as_local_node_id(enum_id) {\n+                            if let hir::ItemEnum(ref enum_def, ref generics) =\n+                                self.ast_map.expect_item(enum_node_id).node\n+                            {\n+                                self.populate_enum_discriminants(enum_def);\n+                                let variant_id = self.ast_map.as_local_node_id(variant_id).unwrap();\n+                                let variant = self.ast_map.expect_variant(variant_id);\n+                                self.visit_variant(variant, generics);\n+                            } else {\n+                                self.sess.span_bug(e.span,\n+                                                   \"`check_static_recursion` found \\\n+                                                    non-enum in DefVariant\");\n+                            }\n                         }\n                     }\n                     _ => ()"}, {"sha": "00cfbf2dfe2c23a3de222fb2eff75addeb6c9f4f", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -69,12 +69,13 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n         None\n     }\n \n-    if enum_def.is_local() {\n-        match tcx.map.find(enum_def.node) {\n+    if let Some(enum_node_id) = tcx.map.as_local_node_id(enum_def) {\n+        let variant_node_id = tcx.map.as_local_node_id(variant_def).unwrap();\n+        match tcx.map.find(enum_node_id) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 hir::ItemEnum(hir::EnumDef { ref variants }, _) => {\n-                    variant_expr(&variants[..], variant_def.node)\n+                    variant_expr(&variants[..], variant_node_id)\n                 }\n                 _ => None\n             },\n@@ -88,8 +89,11 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n             }\n             None => {}\n         }\n-        let expr_id = match csearch::maybe_get_item_ast(tcx, enum_def,\n-            Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d))) {\n+        let expr_id = match\n+            csearch::maybe_get_item_ast(\n+                tcx, enum_def,\n+                Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d)))\n+        {\n             csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 hir::ItemEnum(hir::EnumDef { .. }, _) => {\n                     tcx.sess.span_bug(\n@@ -111,8 +115,8 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                         def_id: DefId,\n                                         maybe_ref_id: Option<ast::NodeId>)\n                                         -> Option<&'tcx Expr> {\n-    if def_id.is_local() {\n-        match tcx.map.find(def_id.node) {\n+    if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+        match tcx.map.find(node_id) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 hir::ItemConst(_, ref const_expr) => {\n@@ -233,14 +237,14 @@ fn inline_const_fn_from_external_crate(tcx: &ty::ctxt, def_id: DefId)\n pub fn lookup_const_fn_by_id<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: DefId)\n                                    -> Option<FnLikeNode<'tcx>>\n {\n-    let fn_id = if !def_id.is_local() {\n+    let fn_id = if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+        node_id\n+    } else {\n         if let Some(fn_id) = inline_const_fn_from_external_crate(tcx, def_id) {\n             fn_id\n         } else {\n             return None;\n         }\n-    } else {\n-        def_id.node\n     };\n \n     let fn_like = match FnLikeNode::from_node(tcx.map.get(fn_id)) {\n@@ -919,8 +923,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n           let (const_expr, const_ty) = match opt_def {\n               Some(def::DefConst(def_id)) => {\n-                  if def_id.is_local() {\n-                      match tcx.map.find(def_id.node) {\n+                  if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+                      match tcx.map.find(node_id) {\n                           Some(ast_map::NodeItem(it)) => match it.node {\n                               hir::ItemConst(ref ty, ref expr) => {\n                                   (Some(&**expr), Some(&**ty))\n@@ -934,9 +938,9 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                   }\n               }\n               Some(def::DefAssociatedConst(def_id)) => {\n-                  if def_id.is_local() {\n+                  if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n                       match tcx.impl_or_trait_item(def_id).container() {\n-                          ty::TraitContainer(trait_id) => match tcx.map.find(def_id.node) {\n+                          ty::TraitContainer(trait_id) => match tcx.map.find(node_id) {\n                               Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n                                   hir::ConstTraitItem(ref ty, _) => {\n                                       if let ExprTypeChecked = ty_hint {\n@@ -954,7 +958,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                               },\n                               _ => (None, None)\n                           },\n-                          ty::ImplContainer(_) => match tcx.map.find(def_id.node) {\n+                          ty::ImplContainer(_) => match tcx.map.find(node_id) {\n                               Some(ast_map::NodeImplItem(ii)) => match ii.node {\n                                   hir::ConstImplItem(ref ty, ref expr) => {\n                                       (Some(&**expr), Some(&**ty))"}, {"sha": "994311efe79c57e49a0fff606565c098014c05ca", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -29,17 +29,15 @@ use syntax::attr::{self, AttrMetaMethods};\n // explored. For example, if it's a live NodeItem that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n-fn should_explore(tcx: &ty::ctxt, def_id: DefId) -> bool {\n-    if !def_id.is_local() {\n-        return false;\n-    }\n-\n-    match tcx.map.find(def_id.node) {\n-        Some(ast_map::NodeItem(..))\n-        | Some(ast_map::NodeImplItem(..))\n-        | Some(ast_map::NodeForeignItem(..))\n-        | Some(ast_map::NodeTraitItem(..)) => true,\n-        _ => false\n+fn should_explore(tcx: &ty::ctxt, node_id: ast::NodeId) -> bool {\n+    match tcx.map.find(node_id) {\n+        Some(ast_map::NodeItem(..)) |\n+        Some(ast_map::NodeImplItem(..)) |\n+        Some(ast_map::NodeForeignItem(..)) |\n+        Some(ast_map::NodeTraitItem(..)) =>\n+            true,\n+        _ =>\n+            false\n     }\n }\n \n@@ -50,7 +48,7 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     struct_has_extern_repr: bool,\n     ignore_non_const_paths: bool,\n     inherited_pub_visibility: bool,\n-    ignore_variant_stack: Vec<ast::NodeId>,\n+    ignore_variant_stack: Vec<DefId>,\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n@@ -68,10 +66,19 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn check_def_id(&mut self, def_id: DefId) {\n-        if should_explore(self.tcx, def_id) {\n-            self.worklist.push(def_id.node);\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+            if should_explore(self.tcx, node_id) {\n+                self.worklist.push(node_id);\n+            }\n+            self.live_symbols.insert(node_id);\n+        }\n+    }\n+\n+    fn insert_def_id(&mut self, def_id: DefId) {\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+            debug_assert!(!should_explore(self.tcx, node_id));\n+            self.live_symbols.insert(node_id);\n         }\n-        self.live_symbols.insert(def_id.node);\n     }\n \n     fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n@@ -94,7 +101,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 def::DefPrimTy(_) => (),\n                 def::DefVariant(enum_id, variant_id, _) => {\n                     self.check_def_id(enum_id);\n-                    if !self.ignore_variant_stack.contains(&variant_id.node) {\n+                    if !self.ignore_variant_stack.contains(&variant_id) {\n                         self.check_def_id(variant_id);\n                     }\n                 }\n@@ -113,15 +120,15 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n         if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n-            self.live_symbols.insert(def.struct_variant().field_named(name).did.node);\n+            self.insert_def_id(def.struct_variant().field_named(name).did);\n         } else {\n             self.tcx.sess.span_bug(lhs.span, \"named field access on non-struct\")\n         }\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &hir::Expr, idx: usize) {\n         if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n-            self.live_symbols.insert(def.struct_variant().fields[idx].did.node);\n+            self.insert_def_id(def.struct_variant().fields[idx].did);\n         }\n     }\n \n@@ -137,7 +144,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             if let hir::PatWild(hir::PatWildSingle) = pat.node.pat.node {\n                 continue;\n             }\n-            self.live_symbols.insert(variant.field_named(pat.node.name).did.node);\n+            self.insert_def_id(variant.field_named(pat.node.name).did);\n         }\n     }\n \n@@ -469,8 +476,10 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     // `ctor_id`. On the other hand, in a statement like\n     // `type <ident> <generics> = <ty>;` where <ty> refers to a struct_ctor,\n     // DefMap maps <ty> to `id` instead.\n-    fn symbol_is_live(&mut self, id: ast::NodeId,\n-                      ctor_id: Option<ast::NodeId>) -> bool {\n+    fn symbol_is_live(&mut self,\n+                      id: ast::NodeId,\n+                      ctor_id: Option<ast::NodeId>)\n+                      -> bool {\n         if self.live_symbols.contains(&id)\n            || ctor_id.map_or(false,\n                              |ctor| self.live_symbols.contains(&ctor)) {\n@@ -486,9 +495,11 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             Some(impl_list) => {\n                 for impl_did in impl_list.iter() {\n                     for item_did in impl_items.get(impl_did).unwrap().iter() {\n-                        if self.live_symbols.contains(&item_did.def_id()\n-                                                               .node) {\n-                            return true;\n+                        if let Some(item_node_id) =\n+                                self.tcx.map.as_local_node_id(item_did.def_id()) {\n+                            if self.live_symbols.contains(&item_node_id) {\n+                                return true;\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "f8f3412c8bb2c24f84fa9eb9e10b104703b0de70", "filename": "src/librustc/middle/def_id.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef_id.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -17,13 +17,13 @@ use std::fmt;\n            RustcDecodable, Hash, Copy)]\n pub struct DefId {\n     pub krate: CrateNum,\n-    pub node: NodeId,\n+    pub xxx_node: NodeId,\n }\n \n impl fmt::Debug for DefId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"DefId {{ krate: {}, node: {}\",\n-                    self.krate, self.node));\n+                    self.krate, self.xxx_node));\n \n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now\n@@ -42,13 +42,7 @@ impl fmt::Debug for DefId {\n \n impl DefId {\n     pub fn xxx_local(id: NodeId) -> DefId {\n-        DefId { krate: LOCAL_CRATE, node: id }\n-    }\n-\n-    /// Read the node id, asserting that this def-id is krate-local.\n-    pub fn local_id(&self) -> NodeId {\n-        assert_eq!(self.krate, LOCAL_CRATE);\n-        self.node\n+        DefId { krate: LOCAL_CRATE, xxx_node: id }\n     }\n \n     pub fn is_local(&self) -> bool {"}, {"sha": "73313a5c257a6d86663919a55479885004303ac6", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -209,7 +209,7 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n         let crate_store = &self.session.cstore;\n         crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n             each_lang_item(crate_store, crate_number, |node_id, item_index| {\n-                let def_id = DefId { krate: crate_number, node: node_id };\n+                let def_id = DefId { krate: crate_number, xxx_node: node_id };\n                 self.collect_item(item_index, def_id, DUMMY_SP);\n                 true\n             });"}, {"sha": "48550c3d8b2f1a52314d2d4a22361086d046ee14", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -219,7 +219,7 @@ pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> hir::Path {\n }\n \n /// Return variants that are necessary to exist for the pattern to match.\n-pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<ast::NodeId> {\n+pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n     let mut variants = vec![];\n     walk_pat(pat, |p| {\n         match p.node {\n@@ -228,7 +228,7 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<ast::NodeId> {\n             hir::PatStruct(..) => {\n                 match dm.borrow().get(&p.id) {\n                     Some(&PathResolution { base_def: DefVariant(_, id, _), .. }) => {\n-                        variants.push(id.node); // XXX\n+                        variants.push(id);\n                     }\n                     _ => ()\n                 }"}, {"sha": "a89da9704d9fd8d7d845e7b51cb39b474c4b0d6c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -16,7 +16,6 @@\n // reachable as well.\n \n use front::map as ast_map;\n-use metadata::cstore::LOCAL_CRATE;\n use middle::def;\n use middle::def_id::DefId;\n use middle::ty;\n@@ -62,20 +61,15 @@ fn method_might_be_inlined(tcx: &ty::ctxt, sig: &hir::MethodSig,\n         generics_require_inlining(&sig.generics) {\n         return true\n     }\n-    if impl_src.is_local() {\n-        {\n-            match tcx.map.find(impl_src.node) {\n-                Some(ast_map::NodeItem(item)) => {\n-                    item_might_be_inlined(&*item)\n-                }\n-                Some(..) | None => {\n-                    tcx.sess.span_bug(impl_item.span, \"impl did is not an item\")\n-                }\n-            }\n+    if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_src) {\n+        match tcx.map.find(impl_node_id) {\n+            Some(ast_map::NodeItem(item)) =>\n+                item_might_be_inlined(&*item),\n+            Some(..) | None =>\n+                tcx.sess.span_bug(impl_item.span, \"impl did is not an item\")\n         }\n     } else {\n-        tcx.sess.span_bug(impl_item.span, \"found a foreign impl as a parent \\\n-                                           of a local method\")\n+        tcx.sess.span_bug(impl_item.span, \"found a foreign impl as a parent of a local method\")\n     }\n }\n \n@@ -107,22 +101,22 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n                 };\n \n                 let def_id = def.def_id();\n-                if def_id.is_local() {\n+                if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n                     if self.def_id_represents_local_inlined_item(def_id) {\n-                        self.worklist.push(def_id.node)\n+                        self.worklist.push(node_id);\n                     } else {\n                         match def {\n                             // If this path leads to a constant, then we need to\n                             // recurse into the constant to continue finding\n                             // items that are reachable.\n                             def::DefConst(..) | def::DefAssociatedConst(..) => {\n-                                self.worklist.push(def_id.node);\n+                                self.worklist.push(node_id);\n                             }\n \n                             // If this wasn't a static, then the destination is\n                             // surely reachable.\n                             _ => {\n-                                self.reachable_symbols.insert(def_id.node);\n+                                self.reachable_symbols.insert(node_id);\n                             }\n                         }\n                     }\n@@ -133,11 +127,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n                 let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n                 match self.tcx.impl_or_trait_item(def_id).container() {\n                     ty::ImplContainer(_) => {\n-                        if def_id.is_local() {\n+                        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n                             if self.def_id_represents_local_inlined_item(def_id) {\n-                                self.worklist.push(def_id.node)\n+                                self.worklist.push(node_id)\n                             }\n-                            self.reachable_symbols.insert(def_id.node);\n+                            self.reachable_symbols.insert(node_id);\n                         }\n                     }\n                     ty::TraitContainer(_) => {}\n@@ -172,11 +166,11 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n-        if def_id.krate != LOCAL_CRATE {\n-            return false\n-        }\n+        let node_id = match self.tcx.map.as_local_node_id(def_id) {\n+            Some(node_id) => node_id,\n+            None => { return false; }\n+        };\n \n-        let node_id = def_id.node;\n         match self.tcx.map.find(node_id) {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n@@ -205,11 +199,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n-                            assert!(impl_did.is_local());\n-                            match self.tcx\n-                                      .map\n-                                      .expect_item(impl_did.node)\n-                                      .node {\n+                            let impl_node_id = self.tcx.map.as_local_node_id(impl_did).unwrap();\n+                            match self.tcx.map.expect_item(impl_node_id).node {\n                                 hir::ItemImpl(_, _, ref generics, _, _, _) => {\n                                     generics_require_inlining(generics)\n                                 }\n@@ -355,8 +346,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         drop_trait.for_each_impl(self.tcx, |drop_impl| {\n             for destructor in &self.tcx.impl_items.borrow()[&drop_impl] {\n                 let destructor_did = destructor.def_id();\n-                if destructor_did.is_local() {\n-                    self.reachable_symbols.insert(destructor_did.node);\n+                if let Some(destructor_node_id) = self.tcx.map.as_local_node_id(destructor_did) {\n+                    self.reachable_symbols.insert(destructor_node_id);\n                 }\n             }\n         })\n@@ -378,8 +369,10 @@ pub fn find_reachable(tcx: &ty::ctxt,\n     }\n     for (_, item) in tcx.lang_items.items() {\n         match *item {\n-            Some(did) if did.is_local() => {\n-                reachable_context.worklist.push(did.node);\n+            Some(did) => {\n+                if let Some(node_id) = tcx.map.as_local_node_id(did) {\n+                    reachable_context.worklist.push(node_id);\n+                }\n             }\n             _ => {}\n         }"}, {"sha": "15a7dd426fbbecc328b8b3d00294a1cb05ed33b6", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -383,7 +383,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &hir::Item, warn_about_defns: bool,\n                 Some(cnum) => cnum,\n                 None => return,\n             };\n-            let id = DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n+            let id = DefId { krate: cnum, xxx_node: ast::CRATE_NODE_ID };\n             maybe_do_stability_check(tcx, id, item.span, cb);\n         }\n "}, {"sha": "61536934aae13cebbae6cd7a8900f7bee6446f76", "filename": "src/librustc/middle/ty/error.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -302,13 +302,15 @@ impl<'tcx> ty::ctxt<'tcx> {\n                                              expected.ty,\n                                              found.ty));\n \n-                match (expected.def_id.is_local(),\n-                       self.map.opt_span(expected.def_id.node)) {\n-                    (true, Some(span)) => {\n+                match\n+                    self.map.as_local_node_id(expected.def_id)\n+                            .and_then(|node_id| self.map.opt_span(node_id))\n+                {\n+                    Some(span) => {\n                         self.sess.span_note(span,\n                                             &format!(\"a default was defined here...\"));\n                     }\n-                    (_, _) => {\n+                    None => {\n                         self.sess.note(\n                             &format!(\"a default is defined on `{}`\",\n                                      self.item_path_str(expected.def_id)));\n@@ -319,13 +321,15 @@ impl<'tcx> ty::ctxt<'tcx> {\n                     expected.origin_span,\n                     &format!(\"...that was applied to an unconstrained type variable here\"));\n \n-                match (found.def_id.is_local(),\n-                       self.map.opt_span(found.def_id.node)) {\n-                    (true, Some(span)) => {\n+                match\n+                    self.map.as_local_node_id(found.def_id)\n+                            .and_then(|node_id| self.map.opt_span(node_id))\n+                {\n+                    Some(span) => {\n                         self.sess.span_note(span,\n                                             &format!(\"a second default was defined here...\"));\n                     }\n-                    (_, _) => {\n+                    None => {\n                         self.sess.note(\n                             &format!(\"a second default is defined on `{}`\",\n                                      self.item_path_str(found.def_id)));"}, {"sha": "1b334e3772244a2058d7866ed59d6f2829ef3329", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -618,7 +618,7 @@ pub struct RegionParameterDef {\n impl RegionParameterDef {\n     pub fn to_early_bound_region(&self) -> ty::Region {\n         ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            param_id: self.def_id,\n+            def_id: self.def_id,\n             space: self.space,\n             index: self.index,\n             name: self.name,\n@@ -2101,8 +2101,8 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn provided_trait_methods(&self, id: DefId) -> Vec<Rc<Method<'tcx>>> {\n-        if id.is_local() {\n-            if let ItemTrait(_, _, _, ref ms) = self.map.expect_item(id.node).node {\n+        if let Some(id) = self.map.as_local_node_id(id) {\n+            if let ItemTrait(_, _, _, ref ms) = self.map.expect_item(id).node {\n                 ms.iter().filter_map(|ti| {\n                     if let hir::MethodTraitItem(_, Some(_)) = ti.node {\n                         match self.impl_or_trait_item(self.map.local_def_id(ti.id)) {\n@@ -2126,8 +2126,8 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn associated_consts(&self, id: DefId) -> Vec<Rc<AssociatedConst<'tcx>>> {\n-        if id.is_local() {\n-            match self.map.expect_item(id.node).node {\n+        if let Some(id) = self.map.as_local_node_id(id) {\n+            match self.map.expect_item(id).node {\n                 ItemTrait(_, _, _, ref tis) => {\n                     tis.iter().filter_map(|ti| {\n                         if let hir::ConstTraitItem(_, _) = ti.node {\n@@ -2187,8 +2187,8 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn trait_impl_polarity(&self, id: DefId) -> Option<hir::ImplPolarity> {\n-        if id.is_local() {\n-            match self.map.find(id.node) {\n+        if let Some(id) = self.map.as_local_node_id(id) {\n+            match self.map.find(id) {\n                 Some(ast_map::NodeItem(item)) => {\n                     match item.node {\n                         hir::ItemImpl(_, polarity, _, _, _, _) => Some(polarity),\n@@ -2243,9 +2243,9 @@ impl<'tcx> ctxt<'tcx> {\n \n     /// Returns whether this DefId refers to an impl\n     pub fn is_impl(&self, id: DefId) -> bool {\n-        if id.is_local() {\n+        if let Some(id) = self.map.as_local_node_id(id) {\n             if let Some(ast_map::NodeItem(\n-                &hir::Item { node: hir::ItemImpl(..), .. })) = self.map.find(id.node) {\n+                &hir::Item { node: hir::ItemImpl(..), .. })) = self.map.find(id) {\n                 true\n             } else {\n                 false\n@@ -2266,16 +2266,16 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn with_path<T, F>(&self, id: DefId, f: F) -> T where\n         F: FnOnce(ast_map::PathElems) -> T,\n     {\n-        if id.is_local() {\n-            self.map.with_path(id.node, f)\n+        if let Some(id) = self.map.as_local_node_id(id) {\n+            self.map.with_path(id, f)\n         } else {\n             f(csearch::get_item_path(self, id).iter().cloned().chain(LinkedPath::empty()))\n         }\n     }\n \n     pub fn item_name(&self, id: DefId) -> ast::Name {\n-        if id.is_local() {\n-            self.map.get_path_elem(id.node).name()\n+        if let Some(id) = self.map.as_local_node_id(id) {\n+            self.map.get_path_elem(id).name()\n         } else {\n             csearch::get_item_name(self, id)\n         }\n@@ -2335,8 +2335,8 @@ impl<'tcx> ctxt<'tcx> {\n \n     /// Get the attributes of a definition.\n     pub fn get_attrs(&self, did: DefId) -> Cow<'tcx, [ast::Attribute]> {\n-        if did.is_local() {\n-            Cow::Borrowed(self.map.attrs(did.node))\n+        if let Some(id) = self.map.as_local_node_id(did) {\n+            Cow::Borrowed(self.map.attrs(id))\n         } else {\n             Cow::Owned(csearch::get_item_attrs(&self.sess.cstore, did))\n         }"}, {"sha": "c6debc382279b6a41e70046dc4c05cf54fd19f9a", "filename": "src/librustc/middle/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -675,7 +675,7 @@ pub enum Region {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n-    pub param_id: DefId,\n+    pub def_id: DefId,\n     pub space: subst::ParamSpace,\n     pub index: u32,\n     pub name: Name,"}, {"sha": "2e6cc4faff8d03a72a715e365fe4e1a9656ab9ab", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -461,7 +461,7 @@ impl<'tcx> ty::ctxt<'tcx> {\n                     tcx.sess.cstore.get_crate_hash(did.krate)\n                 };\n                 h.as_str().hash(state);\n-                did.node.hash(state);\n+                did.xxx_node.hash(state);\n             };\n             let mt = |state: &mut SipHasher, mt: TypeAndMut| {\n                 mt.mutbl.hash(state);"}, {"sha": "75099ca24bc793218fa4a89fbeec6bbcbd5e3d44", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -309,18 +309,18 @@ impl<'tcx> fmt::Display for ty::TraitTy<'tcx> {\n \n impl<'tcx> fmt::Debug for ty::TypeParameterDef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TypeParameterDef({}, {}:{}, {:?}/{})\",\n+        write!(f, \"TypeParameterDef({}, {:?}, {:?}/{})\",\n                self.name,\n-               self.def_id.krate, self.def_id.node,\n+               self.def_id,\n                self.space, self.index)\n     }\n }\n \n impl fmt::Debug for ty::RegionParameterDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionParameterDef({}, {}:{}, {:?}/{}, {:?})\",\n+        write!(f, \"RegionParameterDef({}, {:?}, {:?}/{}, {:?})\",\n                self.name,\n-               self.def_id.krate, self.def_id.node,\n+               self.def_id,\n                self.space, self.index,\n                self.bounds)\n     }\n@@ -455,7 +455,7 @@ impl fmt::Debug for ty::BoundRegion {\n             BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n             BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n             BrNamed(did, name) => {\n-                write!(f, \"BrNamed({}:{}, {:?})\", did.krate, did.node, name)\n+                write!(f, \"BrNamed({:?}, {:?})\", did, name)\n             }\n             BrEnv => \"BrEnv\".fmt(f),\n         }\n@@ -467,7 +467,7 @@ impl fmt::Debug for ty::Region {\n         match *self {\n             ty::ReEarlyBound(ref data) => {\n                 write!(f, \"ReEarlyBound({:?}, {:?}, {}, {})\",\n-                       data.param_id,\n+                       data.def_id,\n                        data.space,\n                        data.index,\n                        data.name)\n@@ -888,13 +888,13 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyTrait(ref data) => write!(f, \"{}\", data),\n             ty::TyProjection(ref data) => write!(f, \"{}\", data),\n             TyStr => write!(f, \"str\"),\n-            TyClosure(ref did, ref substs) => ty::tls::with(|tcx| {\n+            TyClosure(did, ref substs) => ty::tls::with(|tcx| {\n                 try!(write!(f, \"[closure\"));\n \n-                if did.is_local() {\n-                    try!(write!(f, \"@{:?}\", tcx.map.span(did.node)));\n+                if let Some(node_id) = tcx.map.as_local_node_id(did) {\n+                    try!(write!(f, \"@{:?}\", tcx.map.span(node_id)));\n                     let mut sep = \" \";\n-                    try!(tcx.with_freevars(did.node, |freevars| {\n+                    try!(tcx.with_freevars(node_id, |freevars| {\n                         for (freevar, upvar_ty) in freevars.iter().zip(&substs.upvar_tys) {\n                             let node_id = freevar.def.node_id();\n                             try!(write!(f,"}, {"sha": "175bac01daa71c27e2e313774b6c9c0d3f9d3c96", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -20,7 +20,6 @@ use borrowck::LoanPathKind::{LpVar, LpUpvar, LpDowncast, LpExtend};\n use borrowck::LoanPathElem::{LpDeref, LpInterior};\n use borrowck::move_data::InvalidMovePathIndex;\n use borrowck::move_data::{MoveData, MovePathIndex};\n-use rustc::metadata::cstore::LOCAL_CRATE;\n use rustc::middle::def_id::{DefId};\n use rustc::middle::ty;\n use rustc::middle::mem_categorization as mc;\n@@ -134,7 +133,7 @@ pub fn build_unfragmented_map(this: &mut borrowck::BorrowckCtxt,\n     }\n \n     let mut fraginfo_map = this.tcx.fragment_infos.borrow_mut();\n-    let fn_did = DefId { krate: LOCAL_CRATE, node: id };\n+    let fn_did = this.tcx.map.local_def_id(id);\n     let prev = fraginfo_map.insert(fn_did, fragment_infos);\n     assert!(prev.is_none());\n }"}, {"sha": "dc550bb698f16034bdbf124b3389af0138c2e4d2", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -295,7 +295,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     {\n         let name = token::intern(name);\n         ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            param_id: ast::DUMMY_NODE_ID,\n+            def_id: self.infcx.tcx.map.local_def_id(ast::DUMMY_NODE_ID),\n             space: space,\n             index: index,\n             name: name"}, {"sha": "d4cf85d236f7a59498a2c3814b0e382bc8697e5c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -202,10 +202,12 @@ impl LateLintPass for RawPointerDerive {\n             }\n             _ => return,\n         };\n-        if !did.is_local() {\n+        let node_id = if let Some(node_id) = cx.tcx.map.as_local_node_id(did) {\n+            node_id\n+        } else {\n             return;\n-        }\n-        let item = match cx.tcx.map.find(did.node) {\n+        };\n+        let item = match cx.tcx.map.find(node_id) {\n             Some(hir_map::NodeItem(item)) => item,\n             _ => return,\n         };\n@@ -458,13 +460,15 @@ impl LateLintPass for MissingDoc {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n                 let real_trait = cx.tcx.trait_ref_to_def_id(trait_ref);\n-                match cx.tcx.map.find(real_trait.node) {\n-                    Some(hir_map::NodeItem(item)) => if item.vis == hir::Visibility::Inherited {\n-                        for itm in impl_items {\n-                            self.private_traits.insert(itm.id);\n-                        }\n-                    },\n-                    _ => { }\n+                if let Some(node_id) = cx.tcx.map.as_local_node_id(real_trait) {\n+                    match cx.tcx.map.find(node_id) {\n+                        Some(hir_map::NodeItem(item)) => if item.vis == hir::Visibility::Inherited {\n+                            for itm in impl_items {\n+                                self.private_traits.insert(itm.id);\n+                            }\n+                        },\n+                        _ => { }\n+                    }\n                 }\n                 return\n             },\n@@ -629,9 +633,11 @@ impl LateLintPass for MissingDebugImplementations {\n             let debug_def = cx.tcx.lookup_trait_def(debug);\n             let mut impls = NodeSet();\n             debug_def.for_each_impl(cx.tcx, |d| {\n-                if d.is_local() {\n-                    if let Some(ty_def) = cx.tcx.node_id_to_type(d.node).ty_to_def_id() {\n-                        impls.insert(ty_def.node);\n+                if let Some(n) = cx.tcx.map.as_local_node_id(d) {\n+                    if let Some(ty_def) = cx.tcx.node_id_to_type(n).ty_to_def_id() {\n+                        if let Some(node_id) = cx.tcx.map.as_local_node_id(ty_def) {\n+                            impls.insert(node_id);\n+                        }\n                     }\n                 }\n             });\n@@ -956,7 +962,12 @@ impl LateLintPass for UnconditionalRecursion {\n                         traits::Obligation::new(traits::ObligationCause::misc(span, expr_id),\n                                                 trait_ref.to_poly_trait_predicate());\n \n-                    let param_env = ty::ParameterEnvironment::for_item(tcx, method.def_id.node);\n+                    // unwrap() is ok here b/c `method` is the method\n+                    // defined in this crate whose body we are\n+                    // checking, so it's always local\n+                    let node_id = tcx.map.as_local_node_id(method.def_id).unwrap();\n+\n+                    let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n                     let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env), false);\n                     let mut selcx = traits::SelectionContext::new(&infcx);\n                     match selcx.select(&obligation) {"}, {"sha": "f3549e6dda7c19ca203a8d10b36d99cd9951d2c1", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -139,8 +139,8 @@ impl LateLintPass for UnusedResults {\n             ty::TyBool => return,\n             ty::TyStruct(def, _) |\n             ty::TyEnum(def, _) => {\n-                if def.did.is_local() {\n-                    if let hir_map::NodeItem(it) = cx.tcx.map.get(def.did.node) {\n+                if let Some(def_node_id) = cx.tcx.map.as_local_node_id(def.did) {\n+                    if let hir_map::NodeItem(it) = cx.tcx.map.get(def_node_id) {\n                         check_must_use(cx, &it.attrs, s.span)\n                     } else {\n                         false"}, {"sha": "baa3346f83193bd9080b3227af2d1b95f6075448", "filename": "src/librustc_mir/tcx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -817,7 +817,7 @@ fn capture_freevar<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n                                freevar: &ty::Freevar,\n                                freevar_ty: Ty<'tcx>)\n                                -> ExprRef<Cx<'a,'tcx>> {\n-    let id_var = freevar.def.def_id().node;\n+    let id_var = freevar.def.node_id();\n     let upvar_id = ty::UpvarId { var_id: id_var, closure_expr_id: closure_expr.id };\n     let upvar_capture = cx.tcx.upvar_capture(upvar_id).unwrap();\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(closure_expr.id);"}, {"sha": "13b9b16e6ca45997b884d779e0fcd451bf250874", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 59, "deletions": 37, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -265,17 +265,23 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                             def::DefPrimTy(..) => true,\n                             def => {\n                                 let did = def.def_id();\n-                                !did.is_local() ||\n-                                 self.exported_items.contains(&did.node)\n+                                if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+                                    self.exported_items.contains(&node_id)\n+                                } else {\n+                                    true\n+                                }\n                             }\n                         }\n                     }\n                     _ => true,\n                 };\n                 let tr = self.tcx.impl_trait_ref(self.tcx.map.local_def_id(item.id));\n                 let public_trait = tr.clone().map_or(false, |tr| {\n-                    !tr.def_id.is_local() ||\n-                     self.exported_items.contains(&tr.def_id.node)\n+                    if let Some(node_id) = self.tcx.map.as_local_node_id(tr.def_id) {\n+                        self.exported_items.contains(&node_id)\n+                    } else {\n+                        true\n+                    }\n                 });\n \n                 if public_ty || public_trait {\n@@ -334,8 +340,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                         def::DefPrimTy(..) | def::DefTyParam(..) => {},\n                         def => {\n                             let did = def.def_id();\n-                            if did.is_local() {\n-                                self.exported_items.insert(did.node);\n+                            if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+                                self.exported_items.insert(node_id);\n                             }\n                         }\n                     }\n@@ -363,8 +369,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         if self.prev_exported {\n             assert!(self.export_map.contains_key(&id), \"wut {}\", id);\n             for export in self.export_map.get(&id).unwrap() {\n-                if export.def_id.is_local() {\n-                    self.reexports.insert(export.def_id.node);\n+                if let Some(node_id) = self.tcx.map.as_local_node_id(export.def_id) {\n+                    self.reexports.insert(node_id);\n                 }\n             }\n         }\n@@ -404,7 +410,9 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // Determines whether the given definition is public from the point of view\n     // of the current item.\n     fn def_privacy(&self, did: DefId) -> PrivacyResult {\n-        if !did.is_local() {\n+        let node_id = if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+            node_id\n+        } else {\n             if self.external_exports.contains(&did) {\n                 debug!(\"privacy - {:?} was externally exported\", did);\n                 return Allowable;\n@@ -496,19 +504,19 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                     ExternallyDenied\n                 }\n             };\n-        }\n+        };\n \n         debug!(\"privacy - local {} not public all the way down\",\n-               self.tcx.map.node_to_string(did.node));\n+               self.tcx.map.node_to_string(node_id));\n         // return quickly for things in the same module\n-        if self.parents.get(&did.node) == self.parents.get(&self.curitem) {\n+        if self.parents.get(&node_id) == self.parents.get(&self.curitem) {\n             debug!(\"privacy - same parent, we're done here\");\n             return Allowable;\n         }\n \n         // We now know that there is at least one private member between the\n         // destination and the root.\n-        let mut closest_private_id = did.node;\n+        let mut closest_private_id = node_id;\n         loop {\n             debug!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n             let vis = match self.tcx.map.find(closest_private_id) {\n@@ -578,6 +586,15 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         }\n     }\n \n+    /// True if `id` is both local and private-accessible\n+    fn local_private_accessible(&self, did: DefId) -> bool {\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+            self.private_accessible(node_id)\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// For a local private node in the AST, this function will determine\n     /// whether the node is accessible by the current module that iteration is\n     /// inside.\n@@ -639,11 +656,15 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             DisallowedBy(id) => id,\n         };\n \n-        // If we're disallowed by a particular id, then we attempt to give a\n-        // nice error message to say why it was disallowed. It was either\n-        // because the item itself is private or because its parent is private\n-        // and its parent isn't in our ancestry.\n-        let (err_span, err_msg) = if id == source_did.unwrap_or(to_check).node {\n+        // If we're disallowed by a particular id, then we attempt to\n+        // give a nice error message to say why it was disallowed. It\n+        // was either because the item itself is private or because\n+        // its parent is private and its parent isn't in our\n+        // ancestry. (Both the item being checked and its parent must\n+        // be local.)\n+        let def_id = source_did.unwrap_or(to_check);\n+        let node_id = self.tcx.map.as_local_node_id(def_id).unwrap();\n+        let (err_span, err_msg) = if id == node_id {\n             return Some((span, format!(\"{} is private\", msg), None));\n         } else {\n             (span, format!(\"{} is inaccessible\", msg))\n@@ -663,8 +684,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                         };\n                         let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n                         let did = def.def_id();\n-                        assert!(did.is_local());\n-                        match self.tcx.map.get(did.node) {\n+                        let node_id = self.tcx.map.as_local_node_id(did).unwrap();\n+                        match self.tcx.map.get(node_id) {\n                             ast_map::NodeItem(item) => item,\n                             _ => self.tcx.sess.span_bug(item.span,\n                                                         \"path is not an item\")\n@@ -699,9 +720,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             }\n             UnnamedField(idx) => &v.fields[idx]\n         };\n-        if field.vis == hir::Public ||\n-            (field.did.is_local() && self.private_accessible(field.did.node)) {\n-            return\n+        if field.vis == hir::Public || self.local_private_accessible(field.did) {\n+            return;\n         }\n \n         let struct_desc = match def.adt_kind() {\n@@ -891,11 +911,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         _ => expr_ty\n                     }.ty_adt_def().unwrap();\n                     let any_priv = def.struct_variant().fields.iter().any(|f| {\n-                        f.vis != hir::Public && (\n-                            !f.did.is_local() ||\n-                                    !self.private_accessible(f.did.node))\n-                        });\n-\n+                        f.vis != hir::Public && !self.local_private_accessible(f.did)\n+                    });\n                     if any_priv {\n                         span_err!(self.tcx.sess, expr.span, E0450,\n                                   \"cannot invoke tuple struct constructor with private \\\n@@ -1134,18 +1151,19 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n             None | Some(def::DefPrimTy(..)) => return false,\n             Some(def) => def.def_id(),\n         };\n+\n         // A path can only be private if:\n         // it's in this crate...\n-        if !did.is_local() {\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+            // .. and it corresponds to a private type in the AST (this returns\n+            // None for type parameters)\n+            match self.tcx.map.find(node_id) {\n+                Some(ast_map::NodeItem(ref item)) => item.vis != hir::Public,\n+                Some(_) | None => false,\n+            }\n+        } else {\n             return false\n         }\n-\n-        // .. and it corresponds to a private type in the AST (this returns\n-        // None for type parameters)\n-        match self.tcx.map.find(did.node) {\n-            Some(ast_map::NodeItem(ref item)) => item.vis != hir::Public,\n-            Some(_) | None => false,\n-        }\n     }\n \n     fn trait_is_public(&self, trait_id: ast::NodeId) -> bool {\n@@ -1245,7 +1263,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                                               |tr| {\n                         let did = self.tcx.trait_ref_to_def_id(tr);\n \n-                        !did.is_local() || self.trait_is_public(did.node)\n+                        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+                            self.trait_is_public(node_id)\n+                        } else {\n+                            true // external traits must be public\n+                        }\n                     });\n \n                 // `true` iff this is a trait impl or at least one method is public."}, {"sha": "3a53c8b4d8c6c8897c5ae8fdf351200ccbc555c7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -387,7 +387,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             ItemExternCrate(_) => {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 if let Some(crate_id) = self.session.cstore.find_extern_mod_stmt_cnum(item.id) {\n-                    let def_id = DefId { krate: crate_id, node: 0 };\n+                    let def_id = DefId { krate: crate_id, xxx_node: 0 };\n                     self.external_exports.insert(def_id);\n                     let parent_link = ModuleParentLink(Rc::downgrade(parent), name);\n                     let external_module = Rc::new(Module::new(parent_link,\n@@ -409,7 +409,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateModules, sp);\n \n                 let parent_link = self.get_parent_link(parent, name);\n-                let def_id = DefId { krate: 0, node: item.id };\n+                let def_id = self.ast_map.local_def_id(item.id);\n                 name_bindings.define_module(parent_link,\n                                             Some(def_id),\n                                             NormalModuleKind,"}, {"sha": "e828c319a2b94ff5fabb04633d0a90841902edf6", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -65,7 +65,7 @@ use rustc::util::nodemap::{NodeMap, DefIdSet, FnvHashMap};\n use rustc::util::lev_distance::lev_distance;\n \n use syntax::ast;\n-use syntax::ast::{Ident, Name, NodeId, CrateNum, TyIs, TyI8, TyI16, TyI32, TyI64};\n+use syntax::ast::{CRATE_NODE_ID, Ident, Name, NodeId, CrateNum, TyIs, TyI8, TyI16, TyI32, TyI64};\n use syntax::ast::{TyUs, TyU8, TyU16, TyU32, TyU64, TyF64, TyF32};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n@@ -1188,8 +1188,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n            make_glob_map: MakeGlobMap) -> Resolver<'a, 'tcx> {\n         let graph_root = NameBindings::new();\n \n+        let root_def_id = ast_map.local_def_id(CRATE_NODE_ID);\n         graph_root.define_module(NoParentLink,\n-                                 Some(DefId { krate: 0, node: 0 }),\n+                                 Some(root_def_id),\n                                  NormalModuleKind,\n                                  false,\n                                  true,\n@@ -1257,8 +1258,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn get_trait_name(&self, did: DefId) -> Name {\n-        if did.is_local() {\n-            self.ast_map.expect_item(did.node).name\n+        if let Some(node_id) = self.ast_map.as_local_node_id(did) {\n+            self.ast_map.expect_item(node_id).name\n         } else {\n             csearch::get_trait_name(&self.session.cstore, did)\n         }\n@@ -3498,8 +3499,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         fn is_static_method(this: &Resolver, did: DefId) -> bool {\n-            if did.is_local() {\n-                let sig = match this.ast_map.get(did.node) {\n+            if let Some(node_id) = this.ast_map.as_local_node_id(did) {\n+                let sig = match this.ast_map.get(node_id) {\n                     hir_map::NodeTraitItem(trait_item) => match trait_item.node {\n                         hir::MethodTraitItem(ref sig, _) => sig,\n                         _ => return false\n@@ -3846,9 +3847,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         fn add_trait_info(found_traits: &mut Vec<DefId>,\n                           trait_def_id: DefId,\n                           name: Name) {\n-            debug!(\"(adding trait info) found trait {}:{} for method '{}'\",\n-                trait_def_id.krate,\n-                trait_def_id.node,\n+            debug!(\"(adding trait info) found trait {:?} for method '{}'\",\n+                trait_def_id,\n                 name);\n             found_traits.push(trait_def_id);\n         }"}, {"sha": "0eb1e2cc06f613c2b550d8abc9c7bcda03de404d", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -102,9 +102,9 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         self.add_exports_for_module(&mut exports, module_);\n         match module_.def_id.get() {\n             Some(def_id) => {\n-                self.export_map.insert(def_id.node, exports); // XXX\n-                debug!(\"(computing exports) writing exports for {} (some)\",\n-                       def_id.node);\n+                let node_id = self.ast_map.as_local_node_id(def_id).unwrap();\n+                self.export_map.insert(node_id, exports);\n+                debug!(\"(computing exports) writing exports for {} (some)\", node_id);\n             }\n             None => {}\n         }"}, {"sha": "9f963d54dc54f719ba32003e43613f217d6bdbd5", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use metadata::cstore::LOCAL_CRATE;\n use middle::ty;\n use middle::def;\n use middle::def_id::DefId;\n@@ -350,8 +349,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let qualname = match self.tcx.impl_of_method(self.tcx.map.local_def_id(id)) {\n-            Some(impl_id) => match self.tcx.map.get(impl_id.node) {\n-                NodeItem(item) => {\n+            Some(impl_id) => match self.tcx.map.get_if_local(impl_id) {\n+                Some(NodeItem(item)) => {\n                     match item.node {\n                         hir::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from(\"<\");\n@@ -370,27 +369,27 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         }\n                         _ => {\n                             self.tcx.sess.span_bug(span,\n-                                &format!(\"Container {} for method {} not an impl?\",\n-                                         impl_id.node, id));\n+                                &format!(\"Container {:?} for method {} not an impl?\",\n+                                         impl_id, id));\n                         }\n                     }\n                 }\n-                _ => {\n+                r => {\n                     self.tcx.sess.span_bug(span,\n-                        &format!(\"Container {} for method {} is not a node item {:?}\",\n-                                 impl_id.node, id, self.tcx.map.get(impl_id.node)));\n-                }\n+                        &format!(\"Container {:?} for method {} is not a node item {:?}\",\n+                                 impl_id, id, r));\n+                },\n             },\n             None => match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n                 Some(def_id) => {\n-                    match self.tcx.map.get(def_id.node) {\n-                        NodeItem(_) => {\n+                    match self.tcx.map.get_if_local(def_id) {\n+                        Some(NodeItem(_)) => {\n                             format!(\"::{}\", self.tcx.item_path_str(def_id))\n                         }\n-                        _ => {\n+                        r => {\n                             self.tcx.sess.span_bug(span,\n-                                &format!(\"Could not find container {} for method {}\",\n-                                         def_id.node, id));\n+                                &format!(\"Could not find container {:?} for method {}, got {:?}\",\n+                                         def_id, id, r));\n                         }\n                     }\n                 }\n@@ -408,7 +407,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             self.tcx.trait_item_of_item(def_id)\n             .and_then(|new_id| {\n                 let new_def_id = new_id.def_id();\n-                if new_def_id.node != 0 && new_def_id != def_id {\n+                if new_def_id != def_id {\n                     Some(new_def_id)\n                 } else {\n                     None\n@@ -598,13 +597,13 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     fn trait_method_has_body(&self, mr: &ty::ImplOrTraitItem) -> bool {\n         let def_id = mr.def_id();\n-        if def_id.krate != LOCAL_CRATE {\n-            return false;\n-        }\n-\n-        let trait_item = self.tcx.map.expect_trait_item(def_id.node);\n-        if let hir::TraitItem_::MethodTraitItem(_, Some(_)) = trait_item.node {\n-            true\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+            let trait_item = self.tcx.map.expect_trait_item(node_id);\n+            if let hir::TraitItem_::MethodTraitItem(_, Some(_)) = trait_item.node {\n+                true\n+            } else {\n+                false\n+            }\n         } else {\n             false\n         }"}, {"sha": "769c124299899fb2936918ecbfcf498be55de2ec", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -21,7 +21,7 @@ use syntax::ast;\n use syntax::ast::NodeId;\n use syntax::codemap::*;\n \n-const ZERO_DEF_ID: DefId = DefId { node: 0, krate: 0 };\n+const ZERO_DEF_ID: DefId = DefId { xxx_node: 0, krate: 0 };\n \n pub struct Recorder {\n     // output file\n@@ -381,7 +381,7 @@ impl<'a> FmtStrs<'a> {\n                       decl_id: Option<DefId>,\n                       scope_id: NodeId) {\n         let values = match decl_id {\n-            Some(decl_id) => svec!(id, name, decl_id.node, decl_id.krate, scope_id),\n+            Some(decl_id) => svec!(id, name, decl_id.xxx_node, decl_id.krate, scope_id),\n             None => svec!(id, name, \"\", \"\", scope_id),\n         };\n         self.check_and_record(Function,\n@@ -442,9 +442,9 @@ impl<'a> FmtStrs<'a> {\n                               span,\n                               sub_span,\n                               svec!(id,\n-                                    ref_id.node,\n+                                    ref_id.xxx_node,\n                                     ref_id.krate,\n-                                    trait_id.node,\n+                                    trait_id.xxx_node,\n                                     trait_id.krate,\n                                     scope_id));\n     }\n@@ -470,7 +470,7 @@ impl<'a> FmtStrs<'a> {\n                          name: &str,\n                          parent: NodeId) {\n         let (mod_node, mod_crate) = match mod_id {\n-            Some(mod_id) => (mod_id.node, mod_id.krate),\n+            Some(mod_id) => (mod_id.xxx_node, mod_id.krate),\n             None => (0, 0),\n         };\n         self.check_and_record(UseAlias,\n@@ -513,7 +513,7 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(Inheritance,\n                               span,\n                               sub_span,\n-                              svec!(base_id.node,\n+                              svec!(base_id.xxx_node,\n                                     base_id.krate,\n                                     deriv_id,\n                                     0));\n@@ -527,7 +527,7 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(FnCall,\n                               span,\n                               sub_span,\n-                              svec!(id.node, id.krate, \"\", scope_id));\n+                              svec!(id.xxx_node, id.krate, \"\", scope_id));\n     }\n \n     pub fn meth_call_str(&mut self,\n@@ -537,11 +537,11 @@ impl<'a> FmtStrs<'a> {\n                          declid: Option<DefId>,\n                          scope_id: NodeId) {\n         let (dfn, dfk) = match defid {\n-            Some(defid) => (defid.node, defid.krate),\n+            Some(defid) => (defid.xxx_node, defid.krate),\n             None => (0, 0),\n         };\n         let (dcn, dck) = match declid {\n-            Some(declid) => (s!(declid.node), s!(declid.krate)),\n+            Some(declid) => (s!(declid.xxx_node), s!(declid.krate)),\n             None => (\"\".to_string(), \"\".to_string()),\n         };\n         self.check_and_record(MethodCall,\n@@ -600,6 +600,6 @@ impl<'a> FmtStrs<'a> {\n         self.check_and_record(kind,\n                               span,\n                               sub_span,\n-                              svec!(id.node, id.krate, \"\", scope_id));\n+                              svec!(id.xxx_node, id.krate, \"\", scope_id));\n     }\n }"}, {"sha": "61244e32c7d9896dafc02ef0bf11c1a280731877", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -35,7 +35,6 @@ use lint;\n use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n use llvm;\n use metadata::{csearch, encoder, loader};\n-use metadata::cstore::LOCAL_CRATE;\n use middle::astencode;\n use middle::cfg;\n use middle::def_id::DefId;\n@@ -1287,7 +1286,7 @@ pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n \n     // Create the drop-flag hints for every unfragmented path in the function.\n     let tcx = fcx.ccx.tcx();\n-    let fn_did = DefId { krate: LOCAL_CRATE, node: fcx.id };\n+    let fn_did = tcx.map.local_def_id(fcx.id);\n     let mut hints = fcx.lldropflag_hints.borrow_mut();\n     let fragment_infos = tcx.fragment_infos.borrow();\n \n@@ -2254,13 +2253,14 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n                     Ok(id) => id,\n                     Err(s) => { ccx.sess().fatal(&s[..]); }\n                 };\n-                let start_fn = if start_def_id.is_local() {\n-                    get_item_val(ccx, start_def_id.node)\n-                } else {\n-                    let start_fn_type = csearch::get_type(ccx.tcx(),\n-                                                          start_def_id).ty;\n-                    trans_external_path(ccx, start_def_id, start_fn_type)\n-                };\n+                let start_fn =\n+                    if let Some(start_node_id) = ccx.tcx().map.as_local_node_id(start_def_id) {\n+                        get_item_val(ccx, start_node_id)\n+                    } else {\n+                        let start_fn_type = csearch::get_type(ccx.tcx(),\n+                                                              start_def_id).ty;\n+                        trans_external_path(ccx, start_def_id, start_fn_type)\n+                    };\n \n                 let args = {\n                     let opaque_rust_main = llvm::LLVMBuildPointerCast(bld,"}, {"sha": "df9dd8feafa75b3fed7c7aa5369536dfddc2ac74", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -140,8 +140,10 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n         match def {\n             def::DefFn(did, _) if {\n                 let maybe_def_id = inline::get_local_instance(bcx.ccx(), did);\n-                let maybe_ast_node = maybe_def_id.and_then(|def_id| bcx.tcx().map\n-                                                                             .find(def_id.node));\n+                let maybe_ast_node = maybe_def_id.and_then(|def_id| {\n+                    let node_id = bcx.tcx().map.as_local_node_id(def_id).unwrap();\n+                    bcx.tcx().map.find(node_id)\n+                });\n                 match maybe_ast_node {\n                     Some(hir_map::NodeStructCtor(_)) => true,\n                     _ => false\n@@ -162,7 +164,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n                                                     ExprId(ref_expr.id),\n                                                     bcx.fcx.param_substs);\n                 let def_id = inline::maybe_instantiate_inline(bcx.ccx(), did);\n-                Callee { bcx: bcx, data: Intrinsic(def_id.node, substs), ty: expr_ty }\n+                let node_id = bcx.tcx().map.as_local_node_id(def_id).unwrap();\n+                Callee { bcx: bcx, data: Intrinsic(node_id, substs), ty: expr_ty }\n             }\n             def::DefFn(did, _) => {\n                 fn_callee(bcx, trans_fn_ref(bcx.ccx(), did, ExprId(ref_expr.id),\n@@ -404,10 +407,13 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     let def_id = inline::maybe_instantiate_inline(ccx, def_id);\n \n     fn is_named_tuple_constructor(tcx: &ty::ctxt, def_id: DefId) -> bool {\n-        if !def_id.is_local() { return false; }\n+        let node_id = match tcx.map.as_local_node_id(def_id) {\n+            Some(n) => n,\n+            None => { return false; }\n+        };\n         let map_node = session::expect(\n             &tcx.sess,\n-            tcx.map.find(def_id.node),\n+            tcx.map.find(node_id),\n             || \"local item should be in ast map\".to_string());\n \n         match map_node {\n@@ -465,9 +471,9 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n \n     // Find the actual function pointer.\n     let mut val = {\n-        if def_id.is_local() {\n+        if let Some(node_id) = ccx.tcx().map.as_local_node_id(def_id) {\n             // Internal reference.\n-            get_item_val(ccx, def_id.node)\n+            get_item_val(ccx, node_id)\n         } else {\n             // External reference.\n             trans_external_path(ccx, def_id, fn_type)"}, {"sha": "48fbbfffef656787464f484ee07e34767f6a34ce", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -44,8 +44,7 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Special case for small by-value selfs.\n     let closure_id = bcx.tcx().map.local_def_id(bcx.fcx.id);\n-    let self_type = self_type_for_closure(bcx.ccx(), closure_id,\n-                                                  node_id_type(bcx, closure_id.node));\n+    let self_type = self_type_for_closure(bcx.ccx(), closure_id, node_id_type(bcx, bcx.fcx.id));\n     let kind = kind_for_closure(bcx.ccx(), closure_id);\n     let llenv = if kind == ty::FnOnceClosureKind &&\n             !arg_is_indirect(bcx.ccx(), self_type) {\n@@ -70,7 +69,7 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     for (i, freevar) in freevars.iter().enumerate() {\n         let upvar_id = ty::UpvarId { var_id: freevar.def.node_id(),\n-                                     closure_expr_id: closure_id.node };\n+                                     closure_expr_id: bcx.fcx.id };\n         let upvar_capture = bcx.tcx().upvar_capture(upvar_id).unwrap();\n         let mut upvar_ptr = StructGEP(bcx, llenv, i);\n         let captured_by_ref = match upvar_capture {\n@@ -80,21 +79,21 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 true\n             }\n         };\n-        let def_id = freevar.def.def_id();\n-        bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvar_ptr);\n+        let node_id = freevar.def.node_id();\n+        bcx.fcx.llupvars.borrow_mut().insert(node_id, upvar_ptr);\n \n         if kind == ty::FnOnceClosureKind && !captured_by_ref {\n             let hint = bcx.fcx.lldropflag_hints.borrow().hint_datum(upvar_id.var_id);\n             bcx.fcx.schedule_drop_mem(arg_scope_id,\n                                       upvar_ptr,\n-                                      node_id_type(bcx, def_id.node),\n+                                      node_id_type(bcx, node_id),\n                                       hint)\n         }\n \n         if let Some(env_pointer_alloca) = env_pointer_alloca {\n             debuginfo::create_captured_var_metadata(\n                 bcx,\n-                def_id.node,\n+                node_id,\n                 env_pointer_alloca,\n                 i,\n                 captured_by_ref,\n@@ -133,6 +132,8 @@ pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                    closure_id: DefId,\n                                                    substs: &ty::ClosureSubsts<'tcx>)\n                                                    -> ValueRef {\n+    let closure_node_id = ccx.tcx().map.as_local_node_id(closure_id).unwrap();\n+\n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n     let substs = ccx.tcx().erase_regions(substs);\n@@ -147,7 +148,7 @@ pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return llfn;\n     }\n \n-    let symbol = ccx.tcx().map.with_path(closure_id.node, |path| {\n+    let symbol = ccx.tcx().map.with_path(closure_node_id, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n "}, {"sha": "c7777c103e5100b00e7189b96d14e8db595544d3", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -960,6 +960,9 @@ fn get_static_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             did: DefId,\n                             ty: Ty<'tcx>)\n                             -> ValueRef {\n-    if did.is_local() { return base::get_item_val(ccx, did.node) }\n-    base::trans_external_path(ccx, did, ty)\n+    if let Some(node_id) = ccx.tcx().map.as_local_node_id(did) {\n+        base::get_item_val(ccx, node_id)\n+    } else {\n+        base::trans_external_path(ccx, did, ty)\n+    }\n }"}, {"sha": "94c93a636a12c9f26258016ec3db747833e19a49", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -324,8 +324,8 @@ impl<'tcx> TypeMap<'tcx> {\n                                             output: &mut String) {\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n-            let source_def_id = if def_id.is_local() {\n-                match cx.external_srcs().borrow().get(&def_id.node).cloned() {\n+            let source_def_id = if let Some(node_id) = cx.tcx().map.as_local_node_id(def_id) {\n+                match cx.external_srcs().borrow().get(&node_id).cloned() {\n                     Some(source_def_id) => {\n                         // The given def_id identifies the inlined copy of a\n                         // type definition, let's take the source of the copy.\n@@ -346,7 +346,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n             output.push_str(crate_hash.as_str());\n             output.push_str(\"/\");\n-            output.push_str(&format!(\"{:x}\", def_id.node));\n+            output.push_str(&format!(\"{:x}\", def_id.xxx_node));\n \n             // Maybe check that there is no self type here.\n "}, {"sha": "276f9936ac52ad36ff5e129cf3f84390f14b191c", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -99,12 +99,9 @@ pub fn assert_type_for_node_id(cx: &CrateContext,\n pub fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: DefId)\n                                    -> (DIScope, Span) {\n     let containing_scope = namespace_for_item(cx, def_id).scope;\n-    let definition_span = if def_id.is_local() {\n-        cx.tcx().map.span(def_id.node)\n-    } else {\n-        // For external items there is no span information\n-        codemap::DUMMY_SP\n-    };\n+    let definition_span = cx.tcx().map.def_id_span(def_id, codemap::DUMMY_SP /* (1) */ );\n+\n+    // (1) For external items there is no span information\n \n     (containing_scope, definition_span)\n }"}, {"sha": "365caadeccbc4ce4e989a3e9346014538919a131", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -923,13 +923,13 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let const_ty = expr_ty(bcx, ref_expr);\n \n             // For external constants, we don't inline.\n-            let val = if did.is_local() {\n+            let val = if let Some(node_id) = bcx.tcx().map.as_local_node_id(did) {\n                 // Case 1.\n \n                 // The LLVM global has the type of its initializer,\n                 // which may not be equal to the enum's type for\n                 // non-C-like enums.\n-                let val = base::get_item_val(bcx.ccx(), did.node);\n+                let val = base::get_item_val(bcx.ccx(), node_id);\n                 let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n                 PointerCast(bcx, val, pty)\n             } else {"}, {"sha": "67abca78c6eb35e18c38759c302e8561cfed0433", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -193,7 +193,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n \n pub fn get_local_instance(ccx: &CrateContext, fn_id: DefId)\n     -> Option<DefId> {\n-    if fn_id.is_local() {\n+    if let Some(_) = ccx.tcx().map.as_local_node_id(fn_id) {\n         Some(fn_id)\n     } else {\n         instantiate_inline(ccx, fn_id)"}, {"sha": "39f3a29c785f4827585feb2e69a5ce9c7d6303b9", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -38,7 +38,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: DefId,\n                                 psubsts: &'tcx subst::Substs<'tcx>,\n                                 ref_id: Option<ast::NodeId>)\n-    -> (ValueRef, Ty<'tcx>, bool) {\n+                                -> (ValueRef, Ty<'tcx>, bool) {\n     debug!(\"monomorphic_fn(\\\n             fn_id={:?}, \\\n             real_substs={:?}, \\\n@@ -49,6 +49,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     assert!(!psubsts.types.needs_infer() && !psubsts.types.has_param_types());\n \n+    // we can only monomorphize things in this crate (or inlined into it)\n+    let fn_node_id = ccx.tcx().map.as_local_node_id(fn_id).unwrap();\n+\n     let _icx = push_ctxt(\"monomorphic_fn\");\n \n     let hash_id = MonoId {\n@@ -82,7 +85,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let map_node = session::expect(\n         ccx.sess(),\n-        ccx.tcx().map.find(fn_id.node),\n+        ccx.tcx().map.find(fn_node_id),\n         || {\n             format!(\"while monomorphizing {:?}, couldn't find it in \\\n                      the item map (may have attempted to monomorphize \\\n@@ -91,10 +94,10 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         });\n \n     if let hir_map::NodeForeignItem(_) = map_node {\n-        let abi = ccx.tcx().map.get_foreign_abi(fn_id.node);\n+        let abi = ccx.tcx().map.get_foreign_abi(fn_node_id);\n         if abi != abi::RustIntrinsic && abi != abi::PlatformIntrinsic {\n             // Foreign externs don't have to be monomorphized.\n-            return (get_item_val(ccx, fn_id.node), mono_ty, true);\n+            return (get_item_val(ccx, fn_node_id), mono_ty, true);\n         }\n     }\n \n@@ -111,7 +114,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // recursively more than thirty times can probably safely be assumed\n         // to be causing an infinite expansion.\n         if depth > ccx.sess().recursion_limit.get() {\n-            ccx.sess().span_fatal(ccx.tcx().map.span(fn_id.node),\n+            ccx.sess().span_fatal(ccx.tcx().map.span(fn_node_id),\n                 \"reached the recursion limit during monomorphization\");\n         }\n \n@@ -125,7 +128,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         mono_ty.hash(&mut state);\n \n         hash = format!(\"h{}\", state.finish());\n-        ccx.tcx().map.with_path(fn_id.node, |path| {\n+        ccx.tcx().map.with_path(fn_node_id, |path| {\n             exported_name(path, &hash[..])\n         })\n     };\n@@ -136,7 +139,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mut hash_id = Some(hash_id);\n     let mut mk_lldecl = |abi: abi::Abi| {\n         let lldecl = if abi != abi::Rust {\n-            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s[..])\n+            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s)\n         } else {\n             // FIXME(nagisa): perhaps needs a more fine grained selection? See\n             // setup_lldecl below.\n@@ -178,10 +181,10 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   if needs_body {\n                       if abi != abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n-                              ccx, &**decl, &**body, &[], d, psubsts, fn_id.node,\n+                              ccx, &**decl, &**body, &[], d, psubsts, fn_node_id,\n                               Some(&hash[..]));\n                       } else {\n-                          trans_fn(ccx, &**decl, &**body, d, psubsts, fn_id.node, &[]);\n+                          trans_fn(ccx, &**decl, &**body, d, psubsts, fn_node_id, &[]);\n                       }\n                   }\n \n@@ -193,11 +196,11 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         hir_map::NodeVariant(v) => {\n-            let variant = inlined_variant_def(ccx, fn_id.node);\n+            let variant = inlined_variant_def(ccx, fn_node_id);\n             assert_eq!(v.node.name, variant.name);\n             let d = mk_lldecl(abi::Rust);\n             attributes::inline(d, attributes::InlineAttr::Hint);\n-            trans_enum_variant(ccx, fn_id.node, variant.disr_val, psubsts, d);\n+            trans_enum_variant(ccx, fn_node_id, variant.disr_val, psubsts, d);\n             d\n         }\n         hir_map::NodeImplItem(impl_item) => {"}, {"sha": "dd15c132560392d8e60cf7311fd8653b77e23471", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -48,7 +48,6 @@\n //! case but `&a` in the second.  Basically, defaults that appear inside\n //! an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \n-use metadata::cstore::LOCAL_CRATE;\n use middle::astconv_util::{prim_ty_to_ty, prohibit_type_params, prohibit_projection};\n use middle::const_eval::{self, ConstVal};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n@@ -174,7 +173,7 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &hir::Lifetime)\n         Some(&rl::DefEarlyBoundRegion(space, index, id)) => {\n             let def_id = tcx.map.local_def_id(id);\n             ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                param_id: def_id,\n+                def_id: def_id,\n                 space: space,\n                 index: index,\n                 name: lifetime.name\n@@ -1292,9 +1291,9 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             }\n         }\n         (&ty::TyParam(_), def::DefSelfTy(Some(trait_did), None)) => {\n-            assert_eq!(trait_did.krate, LOCAL_CRATE);\n+            let trait_node_id = tcx.map.as_local_node_id(trait_did).unwrap();\n             match find_bound_for_assoc_item(this,\n-                                            trait_did.node,\n+                                            trait_node_id,\n                                             token::special_idents::type_self.name,\n                                             assoc_name,\n                                             span) {\n@@ -1303,9 +1302,9 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             }\n         }\n         (&ty::TyParam(_), def::DefTyParam(_, _, param_did, param_name)) => {\n-            assert_eq!(param_did.krate, LOCAL_CRATE);\n+            let param_node_id = tcx.map.as_local_node_id(param_did).unwrap();\n             match find_bound_for_assoc_item(this,\n-                                            param_did.node,\n+                                            param_node_id,\n                                             param_name,\n                                             assoc_name,\n                                             span) {\n@@ -1326,10 +1325,10 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     let trait_did = bound.0.def_id;\n     let ty = this.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n \n-    let item_did = if trait_did.is_local() {\n+    let item_did = if let Some(trait_id) = tcx.map.as_local_node_id(trait_did) {\n         // `ty::trait_items` used below requires information generated\n         // by type collection, which may be in progress at this point.\n-        match tcx.map.expect_item(trait_did.node).node {\n+        match tcx.map.expect_item(trait_id).node {\n             hir::ItemTrait(_, _, _, ref trait_items) => {\n                 let item = trait_items.iter()\n                                       .find(|i| i.name == assoc_name)\n@@ -1508,11 +1507,12 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             // we don't have the trait information around, which is just sad.\n \n             if !base_segments.is_empty() {\n+                let id_node = tcx.map.as_local_node_id(id).unwrap();\n                 span_err!(tcx.sess,\n                           span,\n                           E0247,\n                           \"found module name used as a type: {}\",\n-                          tcx.map.node_to_string(id.node));\n+                          tcx.map.node_to_user_string(id_node));\n                 return this.tcx().types.err;\n             }\n \n@@ -1522,10 +1522,10 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             prim_ty_to_ty(tcx, base_segments, prim_ty)\n         }\n         _ => {\n-            let node = def.def_id().node;\n+            let id_node = tcx.map.as_local_node_id(def.def_id()).unwrap();\n             span_err!(tcx.sess, span, E0248,\n                       \"found value `{}` used as a type\",\n-                      tcx.map.path_to_string(node));\n+                      tcx.map.path_to_string(id_node));\n             return this.tcx().types.err;\n         }\n     }"}, {"sha": "c46f386af277a7a2886b92d8dddca7338ac8aabb", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -169,8 +169,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // Create a parameter environment that represents the implementation's\n     // method.\n-    let impl_param_env =\n-        ty::ParameterEnvironment::for_item(tcx, impl_m.def_id.node);\n+    let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n+    let impl_param_env = ty::ParameterEnvironment::for_item(tcx, impl_m_node_id);\n \n     // Create mapping from impl to skolemized.\n     let impl_to_skol_substs = &impl_param_env.free_substs;\n@@ -428,8 +428,8 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     // Create a parameter environment that represents the implementation's\n     // method.\n-    let impl_param_env =\n-        ty::ParameterEnvironment::for_item(tcx, impl_c.def_id.node);\n+    let impl_c_node_id = tcx.map.as_local_node_id(impl_c.def_id).unwrap();\n+    let impl_param_env = ty::ParameterEnvironment::for_item(tcx, impl_c_node_id);\n \n     // Create mapping from impl to skolemized.\n     let impl_to_skol_substs = &impl_param_env.free_substs;"}, {"sha": "870a81e510ee709eb8ec1f79a0b362f96a3cd2d3", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -10,7 +10,6 @@\n \n use check::regionck::{self, Rcx};\n \n-use metadata::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use middle::infer;\n@@ -78,11 +77,12 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     drop_impl_ty: &ty::Ty<'tcx>,\n     self_type_did: DefId) -> Result<(), ()>\n {\n-    assert!(drop_impl_did.is_local() && self_type_did.is_local());\n+    let drop_impl_node_id = tcx.map.as_local_node_id(drop_impl_did).unwrap();\n+    let self_type_node_id = tcx.map.as_local_node_id(self_type_did).unwrap();\n \n     // check that the impl type can be made to match the trait type.\n \n-    let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_did.node);\n+    let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n     let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(impl_param_env), true);\n \n     let named_type = tcx.lookup_item_type(self_type_did).ty;\n@@ -97,7 +97,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n                                    named_type, fresh_impl_self_ty) {\n         span_err!(tcx.sess, drop_impl_span, E0366,\n                   \"Implementations of Drop cannot be specialized\");\n-        let item_span = tcx.map.span(self_type_did.node);\n+        let item_span = tcx.map.span(self_type_node_id);\n         tcx.sess.span_note(item_span,\n                            \"Use same sequence of generic type and region \\\n                             parameters that is on the struct/enum definition\");\n@@ -111,7 +111,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     }\n \n     let free_regions = FreeRegionMap::new();\n-    infcx.resolve_regions_and_report_errors(&free_regions, drop_impl_did.node);\n+    infcx.resolve_regions_and_report_errors(&free_regions, drop_impl_node_id);\n     Ok(())\n }\n \n@@ -159,7 +159,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     // absent. So we report an error that the Drop impl injected a\n     // predicate that is not present on the struct definition.\n \n-    assert_eq!(self_type_did.krate, LOCAL_CRATE);\n+    let self_type_node_id = tcx.map.as_local_node_id(self_type_did).unwrap();\n \n     let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n \n@@ -196,7 +196,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // repeated `contains` calls.\n \n         if !assumptions_in_impl_context.contains(&predicate) {\n-            let item_span = tcx.map.span(self_type_did.node);\n+            let item_span = tcx.map.span(self_type_node_id);\n             span_err!(tcx.sess, drop_impl_span, E0367,\n                       \"The requirement `{}` is added only by the Drop impl.\", predicate);\n             tcx.sess.span_note(item_span,"}, {"sha": "e10175c81aa1ff93e0ce6c99caeba1af31d925f4", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -365,13 +365,11 @@ impl PartialOrd for TraitInfo {\n }\n impl Ord for TraitInfo {\n     fn cmp(&self, other: &TraitInfo) -> Ordering {\n-        // accessible traits are more important/relevant than\n-        // inaccessible ones, local crates are more important than\n-        // remote ones (local: cnum == 0), and NodeIds just for\n-        // totality.\n+        // local crates are more important than remote ones (local:\n+        // cnum == 0), and otherwise we throw in the defid for totality\n \n-        let lhs = (other.def_id.krate, other.def_id.node);\n-        let rhs = (self.def_id.krate, self.def_id.node);\n+        let lhs = (other.def_id.krate, other.def_id);\n+        let rhs = (self.def_id.krate, self.def_id);\n         lhs.cmp(&rhs)\n     }\n }"}, {"sha": "7d4101fa243cbac6489761865b633750106e6f0d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -4248,7 +4248,8 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 Some(i) => {\n                     span_err!(ccx.tcx.sess, v.span, E0081,\n                         \"discriminant value `{}` already exists\", disr_vals[i]);\n-                    span_note!(ccx.tcx.sess, ccx.tcx.map.span(variants[i].did.node),\n+                    let variant_i_node_id = ccx.tcx.map.as_local_node_id(variants[i].did).unwrap();\n+                    span_note!(ccx.tcx.sess, ccx.tcx.map.span(variant_i_node_id),\n                         \"conflicting discriminant here\")\n                 }\n                 None => {}\n@@ -4275,8 +4276,8 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         }\n     }\n \n-    let hint = *ccx.tcx.lookup_repr_hints(DefId { krate: LOCAL_CRATE, node: id })\n-        .get(0).unwrap_or(&attr::ReprAny);\n+    let def_id = ccx.tcx.map.local_def_id(id);\n+    let hint = *ccx.tcx.lookup_repr_hints(def_id).get(0).unwrap_or(&attr::ReprAny);\n \n     if hint != attr::ReprAny && vs.len() <= 1 {\n         if vs.len() == 1 {"}, {"sha": "0024b51ae0f9194db05d49318c726296c0eb3336", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -235,16 +235,16 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n         tcx.with_freevars(closure_id, |freevars| {\n             freevars.iter()\n                     .map(|freevar| {\n-                        let freevar_def_id = freevar.def.def_id();\n-                        let freevar_ty = self.fcx.node_ty(freevar_def_id.node);\n+                        let freevar_node_id = freevar.def.node_id();\n+                        let freevar_ty = self.fcx.node_ty(freevar_node_id);\n                         let upvar_id = ty::UpvarId {\n-                            var_id: freevar_def_id.node,\n+                            var_id: freevar_node_id,\n                             closure_expr_id: closure_id\n                         };\n                         let capture = self.fcx.infcx().upvar_capture(upvar_id).unwrap();\n \n-                        debug!(\"freevar_def_id={:?} freevar_ty={:?} capture={:?}\",\n-                               freevar_def_id, freevar_ty, capture);\n+                        debug!(\"freevar_node_id={:?} freevar_ty={:?} capture={:?}\",\n+                               freevar_node_id, freevar_ty, capture);\n \n                         match capture {\n                             ty::UpvarCapture::ByValue => freevar_ty,"}, {"sha": "16884e76a8ec72279169d32edb71323b969905d7", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -388,8 +388,8 @@ impl ResolveReason {\n                 tcx.expr_span(upvar_id.closure_expr_id)\n             }\n             ResolvingClosure(did) => {\n-                if did.is_local() {\n-                    tcx.expr_span(did.node)\n+                if let Some(node_id) = tcx.map.as_local_node_id(did) {\n+                    tcx.expr_span(node_id)\n                 } else {\n                     DUMMY_SP\n                 }"}, {"sha": "b3ec10a8941dc753e69b3f72344cecfbdb2ba5bd", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -16,7 +16,6 @@\n // mappings. That mapping code resides here.\n \n \n-use metadata::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;\n use middle::lang_items::UnsizeTraitLangItem;\n use middle::subst::{self, Subst};\n@@ -247,17 +246,15 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 }\n                 _ => {\n                     // Destructors only work on nominal types.\n-                    if impl_did.is_local() {\n-                        {\n-                            match tcx.map.find(impl_did.node) {\n-                                Some(hir_map::NodeItem(item)) => {\n-                                    span_err!(tcx.sess, item.span, E0120,\n-                                        \"the Drop trait may only be implemented on structures\");\n-                                }\n-                                _ => {\n-                                    tcx.sess.bug(\"didn't find impl in ast \\\n-                                                  map\");\n-                                }\n+                    if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_did) {\n+                        match tcx.map.find(impl_node_id) {\n+                            Some(hir_map::NodeItem(item)) => {\n+                                span_err!(tcx.sess, item.span, E0120,\n+                                          \"the Drop trait may only be implemented on structures\");\n+                            }\n+                            _ => {\n+                                tcx.sess.bug(\"didn't find impl in ast \\\n+                                              map\");\n                             }\n                         }\n                     } else {\n@@ -283,18 +280,20 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_copy: impl_did={:?}\",\n                    impl_did);\n \n-            if impl_did.krate != LOCAL_CRATE {\n+            let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n+                n\n+            } else {\n                 debug!(\"check_implementations_of_copy(): impl not in this \\\n                         crate\");\n                 return\n-            }\n+            };\n \n             let self_type = tcx.lookup_item_type(impl_did);\n             debug!(\"check_implementations_of_copy: self_type={:?} (bound)\",\n                    self_type);\n \n-            let span = tcx.map.span(impl_did.node);\n-            let param_env = ParameterEnvironment::for_item(tcx, impl_did.node);\n+            let span = tcx.map.span(impl_node_id);\n+            let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n             let self_type = self_type.ty.subst(tcx, &param_env.free_substs);\n             assert!(!self_type.has_escaping_regions());\n \n@@ -352,20 +351,22 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_coerce_unsized: impl_did={:?}\",\n                    impl_did);\n \n-            if impl_did.krate != LOCAL_CRATE {\n+            let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n+                n\n+            } else {\n                 debug!(\"check_implementations_of_coerce_unsized(): impl not \\\n                         in this crate\");\n                 return;\n-            }\n+            };\n \n             let source = tcx.lookup_item_type(impl_did).ty;\n             let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n             let target = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n                    source, target);\n \n-            let span = tcx.map.span(impl_did.node);\n-            let param_env = ParameterEnvironment::for_item(tcx, impl_did.node);\n+            let span = tcx.map.span(impl_node_id);\n+            let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n             let source = source.subst(tcx, &param_env.free_substs);\n             let target = target.subst(tcx, &param_env.free_substs);\n             assert!(!source.has_escaping_regions());\n@@ -465,7 +466,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n \n             // Register an obligation for `A: Trait<B>`.\n-            let cause = traits::ObligationCause::misc(span, impl_did.node);\n+            let cause = traits::ObligationCause::misc(span, impl_node_id);\n             let predicate = traits::predicate_for_trait_def(tcx, cause, trait_def_id,\n                                                             0, source, vec![target]);\n             fulfill_cx.register_predicate_obligation(&infcx, predicate);\n@@ -479,7 +480,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             let mut free_regions = FreeRegionMap::new();\n             free_regions.relate_free_regions_from_predicates(tcx, &infcx.parameter_environment\n                                                                         .caller_bounds);\n-            infcx.resolve_regions_and_report_errors(&free_regions, impl_did.node);\n+            infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n \n             if let Some(kind) = kind {\n                 tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);"}, {"sha": "706f28f9fe4b03af30b7f358de1fec029007e17a", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -112,7 +112,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n             }\n         } else if impl2_def_id.krate != LOCAL_CRATE {\n             Some((impl1_def_id, impl2_def_id))\n-        } else if impl1_def_id.node < impl2_def_id.node {\n+        } else if impl1_def_id < impl2_def_id {\n             Some((impl1_def_id, impl2_def_id))\n         } else {\n             Some((impl2_def_id, impl1_def_id))\n@@ -165,8 +165,8 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     }\n \n     fn span_of_impl(&self, impl_did: DefId) -> Span {\n-        assert_eq!(impl_did.krate, LOCAL_CRATE);\n-        self.tcx.map.span(impl_did.node)\n+        let node_id = self.tcx.map.as_local_node_id(impl_did).unwrap();\n+        self.tcx.map.span(node_id)\n     }\n }\n "}, {"sha": "39805bfc8a3e270eeaae5df8d2cdc4b4b71c2d80", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -65,7 +65,6 @@ There are some shortcomings in this design:\n */\n \n use astconv::{self, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n-use metadata::cstore::LOCAL_CRATE;\n use middle::def;\n use middle::def_id::DefId;\n use constrained_type_params as ctp;\n@@ -317,16 +316,16 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n     {\n         let tcx = self.tcx;\n \n-        if trait_id.krate != LOCAL_CRATE {\n-            return tcx.lookup_trait_def(trait_id)\n-        }\n-\n-        let item = match tcx.map.get(trait_id.node) {\n-            hir_map::NodeItem(item) => item,\n-            _ => tcx.sess.bug(&format!(\"get_trait_def({:?}): not an item\", trait_id))\n-        };\n+        if let Some(trait_id) = tcx.map.as_local_node_id(trait_id) {\n+            let item = match tcx.map.get(trait_id) {\n+                hir_map::NodeItem(item) => item,\n+                _ => tcx.sess.bug(&format!(\"get_trait_def({:?}): not an item\", trait_id))\n+            };\n \n-        trait_def_of_item(self, &*item)\n+            trait_def_of_item(self, &*item)\n+        } else {\n+            tcx.lookup_trait_def(trait_id)\n+        }\n     }\n \n     /// Ensure that the (transitive) super predicates for\n@@ -403,8 +402,8 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n                                            assoc_name: ast::Name)\n                                            -> bool\n     {\n-        if trait_def_id.is_local() {\n-            trait_defines_associated_type_named(self.ccx, trait_def_id.node, assoc_name)\n+        if let Some(trait_id) = self.tcx().map.as_local_node_id(trait_def_id) {\n+            trait_defines_associated_type_named(self.ccx, trait_id, assoc_name)\n         } else {\n             let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n             trait_def.associated_type_names.contains(&assoc_name)\n@@ -558,8 +557,8 @@ fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if let hir::TyPath(None, _) = ast_ty.node {\n         let path_res = *tcx.def_map.borrow().get(&ast_ty.id).unwrap();\n         match path_res.base_def {\n-            def::DefSelfTy(Some(def_id), None) => { // XXX\n-                path_res.depth == 0 && def_id.node == param_id\n+            def::DefSelfTy(Some(def_id), None) => {\n+                path_res.depth == 0 && def_id == tcx.map.local_def_id(param_id)\n             }\n             def::DefTyParam(_, _, def_id, _) => {\n                 path_res.depth == 0 && def_id == tcx.map.local_def_id(param_id)\n@@ -1271,19 +1270,19 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n \n     debug!(\"ensure_super_predicates_step(trait_def_id={:?})\", trait_def_id);\n \n-    if trait_def_id.krate != LOCAL_CRATE {\n+    let trait_node_id = if let Some(n) = tcx.map.as_local_node_id(trait_def_id) {\n+        n\n+    } else {\n         // If this trait comes from an external crate, then all of the\n         // supertraits it may depend on also must come from external\n         // crates, and hence all of them already have their\n         // super-predicates \"converted\" (and available from crate\n         // meta-data), so there is no need to transitively test them.\n         return Vec::new();\n-    }\n+    };\n \n     let superpredicates = tcx.super_predicates.borrow().get(&trait_def_id).cloned();\n     let superpredicates = superpredicates.unwrap_or_else(|| {\n-        let trait_node_id = trait_def_id.node;\n-\n         let item = match ccx.tcx.map.get(trait_node_id) {\n             hir_map::NodeItem(item) => item,\n             _ => ccx.tcx.sess.bug(&format!(\"trait_node_id {} is not an item\", trait_node_id))\n@@ -1412,15 +1411,12 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             generics.lifetimes\n                     .iter()\n                     .enumerate()\n-                    .map(|(i, def)| {\n-                        let def_id = tcx.map.local_def_id(def.lifetime.id);\n-                        ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                            param_id: def_id,\n-                            space: TypeSpace,\n-                            index: i as u32,\n-                            name: def.lifetime.name\n-                        })\n-                    })\n+                    .map(|(i, def)| ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                        def_id: tcx.map.local_def_id(def.lifetime.id),\n+                        space: TypeSpace,\n+                        index: i as u32,\n+                        name: def.lifetime.name\n+                    }))\n                     .collect();\n \n         // Start with the generics in the type parameters...\n@@ -1540,23 +1536,23 @@ fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                   def_id: DefId)\n                                   -> ty::TypeScheme<'tcx>\n {\n-    if def_id.krate != LOCAL_CRATE {\n-        return ccx.tcx.lookup_item_type(def_id);\n-    }\n-\n-    match ccx.tcx.map.find(def_id.node) {\n-        Some(hir_map::NodeItem(item)) => {\n-            type_scheme_of_item(ccx, &*item)\n-        }\n-        Some(hir_map::NodeForeignItem(foreign_item)) => {\n-            let abi = ccx.tcx.map.get_foreign_abi(def_id.node);\n-            type_scheme_of_foreign_item(ccx, &*foreign_item, abi)\n-        }\n-        x => {\n-            ccx.tcx.sess.bug(&format!(\"unexpected sort of node \\\n-                                            in get_item_type_scheme(): {:?}\",\n-                                       x));\n+    if let Some(node_id) = ccx.tcx.map.as_local_node_id(def_id) {\n+        match ccx.tcx.map.find(node_id) {\n+            Some(hir_map::NodeItem(item)) => {\n+                type_scheme_of_item(ccx, &*item)\n+            }\n+            Some(hir_map::NodeForeignItem(foreign_item)) => {\n+                let abi = ccx.tcx.map.get_foreign_abi(node_id);\n+                type_scheme_of_foreign_item(ccx, &*foreign_item, abi)\n+            }\n+            x => {\n+                ccx.tcx.sess.bug(&format!(\"unexpected sort of node \\\n+                                           in get_item_type_scheme(): {:?}\",\n+                                          x));\n+            }\n         }\n+    } else {\n+        ccx.tcx.lookup_item_type(def_id)\n     }\n }\n \n@@ -1894,7 +1890,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         let def_id = tcx.map.local_def_id(param.lifetime.id);\n         let region =\n             ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                param_id: def_id,\n+                def_id: def_id,\n                 space: space,\n                 index: index,\n                 name: param.lifetime.name\n@@ -2392,9 +2388,10 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         tcx.fold_regions(value, &mut false, |region, _| {\n             match region {\n                 ty::ReEarlyBound(data) => {\n-                    let def_id = data.param_id;\n-                    ty::ReFree(ty::FreeRegion { scope: scope,\n-                                                bound_region: ty::BrNamed(def_id, data.name) })\n+                    ty::ReFree(ty::FreeRegion {\n+                        scope: scope,\n+                        bound_region: ty::BrNamed(data.def_id, data.name)\n+                    })\n                 }\n                 _ => region\n             }\n@@ -2453,7 +2450,7 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     for (index, lifetime_def) in ast_generics.lifetimes.iter().enumerate() {\n         let def_id = tcx.map.local_def_id(lifetime_def.lifetime.id);\n-        let region = ty::EarlyBoundRegion { param_id: def_id,\n+        let region = ty::EarlyBoundRegion { def_id: def_id,\n                                             space: TypeSpace,\n                                             index: index as u32,\n                                             name: lifetime_def.lifetime.name };"}, {"sha": "8152e685d8d831819bf6cff30884061247cf2ced", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -266,7 +266,6 @@ use self::ParamKind::*;\n \n use arena;\n use arena::TypedArena;\n-use metadata::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;\n use middle::resolve_lifetime as rl;\n use middle::subst;\n@@ -404,10 +403,10 @@ fn lang_items(tcx: &ty::ctxt) -> Vec<(ast::NodeId,Vec<ty::Variance>)> {\n \n         ];\n \n-    all.into_iter()\n+    all.into_iter() // iterating over (Option<DefId>, Variance)\n        .filter(|&(ref d,_)| d.is_some())\n-       .filter(|&(ref d,_)| d.as_ref().unwrap().is_local())\n-       .map(|(d, v)| (d.unwrap().node, v))\n+       .map(|(d, v)| (d.unwrap(), v)) // (DefId, Variance)\n+       .filter_map(|(d, v)| tcx.map.as_local_node_id(d).map(|n| (n, v))) // (NodeId, Variance)\n        .collect()\n }\n \n@@ -741,11 +740,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                          -> VarianceTermPtr<'a> {\n         assert_eq!(param_def_id.krate, item_def_id.krate);\n \n-        if param_def_id.is_local() {\n+        if let Some(param_node_id) = self.tcx().map.as_local_node_id(param_def_id) {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic\n             // variance.\n-            let InferredIndex(index) = self.inferred_index(param_def_id.node);\n+            let InferredIndex(index) = self.inferred_index(param_node_id);\n             self.terms_cx.inferred_infos[index].term\n         } else {\n             // Parameter on an item defined within another crate:\n@@ -924,8 +923,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyParam(ref data) => {\n                 let def_id = generics.types.get(data.space, data.idx as usize).def_id;\n-                assert_eq!(def_id.krate, LOCAL_CRATE);\n-                match self.terms_cx.inferred_map.get(&def_id.node) {\n+                let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n+                match self.terms_cx.inferred_map.get(&node_id) {\n                     Some(&index) => {\n                         self.add_constraint(index, variance);\n                     }\n@@ -1013,7 +1012,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    variance: VarianceTermPtr<'a>) {\n         match region {\n             ty::ReEarlyBound(ref data) => {\n-                let node_id = self.tcx().map.as_local_node_id(data.param_id).unwrap();\n+                let node_id = self.tcx().map.as_local_node_id(data.def_id).unwrap();\n                 if self.is_to_be_inferred(node_id) {\n                     let index = self.inferred_index(node_id);\n                     self.add_constraint(index, variance);"}, {"sha": "344008b904eb94b7e258b3555ed316dd9600b751", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -36,7 +36,6 @@ use syntax::ptr::P;\n \n use rustc_trans::back::link;\n use rustc::metadata::cstore;\n-use rustc::metadata::cstore::LOCAL_CRATE;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n use rustc::middle::def;\n@@ -496,7 +495,7 @@ impl Clean<TyParam> for hir::TyParam {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n         TyParam {\n             name: self.name.clean(cx),\n-            did: DefId { krate: LOCAL_CRATE, node: self.id },\n+            did: cx.map.local_def_id(self.id),\n             bounds: self.bounds.clean(cx),\n             default: self.default.clean(cx),\n         }\n@@ -1138,10 +1137,10 @@ impl<'tcx> Clean<Type> for ty::FnOutput<'tcx> {\n impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n-        let mut names = if did.node != 0 {\n-            csearch::get_method_arg_names(&cx.tcx().sess.cstore, did).into_iter()\n+        let mut names = if let Some(_) = cx.map.as_local_node_id(did) {\n+            vec![].into_iter()\n         } else {\n-            Vec::new().into_iter()\n+            csearch::get_method_arg_names(&cx.tcx().sess.cstore, did).into_iter()\n         }.peekable();\n         if names.peek().map(|s| &**s) == Some(\"self\") {\n             let _ = names.next();\n@@ -1745,7 +1744,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n         let (name, attrs) = if self.name == unnamed_field.name {\n             (None, None)\n         } else {\n-            (Some(self.name), Some(attr_map.get(&self.did.node).unwrap()))\n+            (Some(self.name), Some(attr_map.get(&self.did.xxx_node).unwrap()))\n         };\n \n         Item {"}, {"sha": "c84a7e7c560dd57bd5cd04d3750cb25d62598cee", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -13,9 +13,10 @@ use rustc_lint;\n use rustc_driver::{driver, target_features};\n use rustc::session::{self, config};\n use rustc::middle::def_id::DefId;\n-use rustc::middle::{privacy, ty};\n+use rustc::middle::ty;\n use rustc::front::map as hir_map;\n use rustc::lint;\n+use rustc::util::nodemap::DefIdSet;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_front::lowering::lower_crate;\n@@ -76,8 +77,8 @@ impl<'b, 'tcx> DocContext<'b, 'tcx> {\n }\n \n pub struct CrateAnalysis {\n-    pub exported_items: privacy::ExportedItems,\n-    pub public_items: privacy::PublicItems,\n+    pub exported_items: DefIdSet,\n+    pub public_items: DefIdSet,\n     pub external_paths: ExternalPaths,\n     pub external_typarams: RefCell<Option<HashMap<DefId, String>>>,\n     pub inlined: RefCell<Option<HashSet<DefId>>>,\n@@ -146,6 +147,17 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n                                         |tcx, analysis| {\n         let ty::CrateAnalysis { exported_items, public_items, .. } = analysis;\n \n+        // Convert from a NodeId set to a DefId set since we don't always have easy access\n+        // to the map from defid -> nodeid\n+        let exported_items: DefIdSet =\n+            exported_items.into_iter()\n+                          .map(|n| tcx.map.local_def_id(n))\n+                          .collect();\n+        let public_items: DefIdSet =\n+            public_items.into_iter()\n+                        .map(|n| tcx.map.local_def_id(n))\n+                        .collect();\n+\n         let ctxt = DocContext {\n             map: &tcx.map,\n             maybe_typed: Typed(tcx),"}, {"sha": "6937dbf255e2e7c87dab434d18d2bb936b657ac8", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -387,7 +387,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n         Some(&cnum) => {\n             let path = &m.paths[&DefId {\n                 krate: cnum,\n-                node: ast::CRATE_NODE_ID,\n+                xxx_node: ast::CRATE_NODE_ID,\n             }];\n             let loc = match m.extern_locations[&cnum] {\n                 (_, render::Remote(ref s)) => Some(s.to_string()),"}, {"sha": "708c8f634f55366678528e81a0f8abccad6afe01", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -54,8 +54,8 @@ use externalfiles::ExternalHtml;\n use serialize::json::{self, ToJson};\n use syntax::{abi, ast, attr};\n use rustc::metadata::cstore::LOCAL_CRATE;\n-use rustc::middle::def_id::{DefId, LOCAL_CRATE};\n-use rustc::util::nodemap::NodeSet;\n+use rustc::middle::def_id::DefId;\n+use rustc::util::nodemap::DefIdSet;\n use rustc_front::hir;\n \n use clean::{self, SelfTy};\n@@ -206,7 +206,7 @@ pub struct Cache {\n     search_index: Vec<IndexItem>,\n     privmod: bool,\n     remove_priv: bool,\n-    public_items: NodeSet,\n+    public_items: DefIdSet,\n     deref_trait_did: Option<DefId>,\n \n     // In rare case where a structure is defined in one module but implemented\n@@ -378,7 +378,7 @@ pub fn run(mut krate: clean::Crate,\n     let analysis = ::ANALYSISKEY.with(|a| a.clone());\n     let analysis = analysis.borrow();\n     let public_items = analysis.as_ref().map(|a| a.public_items.clone());\n-    let public_items = public_items.unwrap_or(NodeSet());\n+    let public_items = public_items.unwrap_or(DefIdSet());\n     let paths: HashMap<DefId, (Vec<String>, ItemType)> =\n       analysis.as_ref().map(|a| {\n         let paths = a.external_paths.borrow_mut().take().unwrap();\n@@ -413,7 +413,7 @@ pub fn run(mut krate: clean::Crate,\n     for &(n, ref e) in &krate.externs {\n         cache.extern_locations.insert(n, (e.name.clone(),\n                                           extern_location(e, &cx.dst)));\n-        let did = DefId { krate: n, node: ast::CRATE_NODE_ID };\n+        let did = DefId { krate: n, xxx_node: ast::CRATE_NODE_ID };\n         cache.paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n     }\n \n@@ -994,10 +994,11 @@ impl DocFolder for Cache {\n                 // `public_items` map, so we can skip inserting into the\n                 // paths map if there was already an entry present and we're\n                 // not a public item.\n-                let id = item.def_id.node;\n-                if !self.paths.contains_key(&item.def_id) ||\n-                   !item.def_id.is_local() ||\n-                   self.public_items.contains(&id) {\n+                if\n+                    !self.paths.contains_key(&item.def_id) ||\n+                    !item.def_id.is_local() ||\n+                    self.public_items.contains(&item.def_id)\n+                {\n                     self.paths.insert(item.def_id,\n                                       (self.stack.clone(), shortty(&item)));\n                 }\n@@ -1079,7 +1080,7 @@ impl DocFolder for Cache {\n                                 t.primitive_type().and_then(|t| {\n                                     self.primitive_locations.get(&t).map(|n| {\n                                         let id = t.to_node_id();\n-                                        DefId { krate: *n, node: id }\n+                                        DefId { krate: *n, xxx_node: id }\n                                     })\n                                 })\n                             }\n@@ -1420,7 +1421,7 @@ impl<'a> Item<'a> {\n                          root = root,\n                          path = path[..path.len() - 1].join(\"/\"),\n                          file = item_path(self.item),\n-                         goto = self.item.def_id.node))\n+                         goto = self.item.def_id.xxx_node))\n         }\n     }\n }\n@@ -1480,7 +1481,7 @@ impl<'a> fmt::Display for Item<'a> {\n                 Some(l) => {\n                     try!(write!(fmt, \"<a id='src-{}' class='srclink' \\\n                                        href='{}' title='{}'>[src]</a>\",\n-                                self.item.def_id.node, l, \"goto source code\"));\n+                                self.item.def_id.xxx_node, l, \"goto source code\"));\n                 }\n                 None => {}\n             }\n@@ -2336,7 +2337,7 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl) -> f\n         _ => {\n             if let Some(prim) = target.primitive_type() {\n                 if let Some(c) = cache().primitive_locations.get(&prim) {\n-                    let did = DefId { krate: *c, node: prim.to_node_id() };\n+                    let did = DefId { krate: *c, xxx_node: prim.to_node_id() };\n                     try!(render_assoc_items(w, cx, did, what));\n                 }\n             }"}, {"sha": "e7e38220825f7dc042a45714e12c1c62749b0932", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::collections::HashSet;\n-use rustc::util::nodemap::NodeSet;\n+use rustc::util::nodemap::DefIdSet;\n use std::cmp;\n use std::string::String;\n use std::usize;\n-use syntax::ast;\n use rustc_front::hir;\n \n use clean;\n@@ -24,18 +22,18 @@ use fold::DocFolder;\n \n /// Strip items marked `#[doc(hidden)]`\n pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n-    let mut stripped = HashSet::new();\n+    let mut stripped = DefIdSet();\n \n     // strip all #[doc(hidden)] items\n     let krate = {\n         struct Stripper<'a> {\n-            stripped: &'a mut HashSet<ast::NodeId>\n+            stripped: &'a mut DefIdSet\n         };\n         impl<'a> fold::DocFolder for Stripper<'a> {\n             fn fold_item(&mut self, i: Item) -> Option<Item> {\n                 if i.is_hidden_from_doc() {\n                     debug!(\"found one in strip_hidden; removing\");\n-                    self.stripped.insert(i.def_id.node);\n+                    self.stripped.insert(i.def_id);\n \n                     // use a dedicated hidden item for given item type if any\n                     match i.inner {\n@@ -61,7 +59,7 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n     // strip any traits implemented on stripped items\n     let krate = {\n         struct ImplStripper<'a> {\n-            stripped: &'a mut HashSet<ast::NodeId>\n+            stripped: &'a mut DefIdSet\n         };\n         impl<'a> fold::DocFolder for ImplStripper<'a> {\n             fn fold_item(&mut self, i: Item) -> Option<Item> {\n@@ -70,12 +68,12 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n                            ref trait_, ..\n                 }) = i.inner {\n                     // Impls for stripped types don't need to exist\n-                    if self.stripped.contains(&did.node) {\n+                    if self.stripped.contains(&did) {\n                         return None;\n                     }\n                     // Impls of stripped traits also don't need to exist\n                     if let Some(clean::ResolvedPath { did, .. }) = *trait_ {\n-                        if self.stripped.contains(&did.node) {\n+                        if self.stripped.contains(&did) {\n                             return None;\n                         }\n                     }\n@@ -94,7 +92,7 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n /// crate, specified by the `xcrate` flag.\n pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n     // This stripper collects all *retained* nodes.\n-    let mut retained = HashSet::new();\n+    let mut retained = DefIdSet();\n     let analysis = super::ANALYSISKEY.with(|a| a.clone());\n     let analysis = analysis.borrow();\n     let analysis = analysis.as_ref().unwrap();\n@@ -118,8 +116,8 @@ pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n }\n \n struct Stripper<'a> {\n-    retained: &'a mut HashSet<ast::NodeId>,\n-    exported_items: &'a NodeSet,\n+    retained: &'a mut DefIdSet,\n+    exported_items: &'a DefIdSet,\n }\n \n impl<'a> fold::DocFolder for Stripper<'a> {\n@@ -132,7 +130,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::VariantItem(..) | clean::MethodItem(..) |\n             clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) => {\n                 if i.def_id.is_local() {\n-                    if !self.exported_items.contains(&i.def_id.node) {\n+                    if !self.exported_items.contains(&i.def_id) {\n                         return None;\n                     }\n                     // Traits are in exported_items even when they're totally private.\n@@ -143,8 +141,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             }\n \n             clean::ConstantItem(..) => {\n-                if i.def_id.is_local() &&\n-                   !self.exported_items.contains(&i.def_id.node) {\n+                if i.def_id.is_local() && !self.exported_items.contains(&i.def_id) {\n                     return None;\n                 }\n             }\n@@ -171,8 +168,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::ImplItem(clean::Impl{\n                 for_: clean::ResolvedPath{ did, .. }, ..\n             }) => {\n-                if did.is_local() &&\n-                   !self.exported_items.contains(&did.node) {\n+                if did.is_local() && !self.exported_items.contains(&did) {\n                     return None;\n                 }\n             }\n@@ -205,7 +201,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n         };\n \n         let i = if fastreturn {\n-            self.retained.insert(i.def_id.node);\n+            self.retained.insert(i.def_id);\n             return Some(i);\n         } else {\n             self.fold_item_recur(i)\n@@ -220,7 +216,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                            i.doc_value().is_none() => None,\n                     clean::ImplItem(ref i) if i.items.is_empty() => None,\n                     _ => {\n-                        self.retained.insert(i.def_id.node);\n+                        self.retained.insert(i.def_id);\n                         Some(i)\n                     }\n                 }\n@@ -231,14 +227,13 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n }\n \n // This stripper discards all private impls of traits\n-struct ImplStripper<'a>(&'a HashSet<ast::NodeId>);\n+struct ImplStripper<'a>(&'a DefIdSet);\n impl<'a> fold::DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = i.inner {\n             match imp.trait_ {\n                 Some(clean::ResolvedPath{ did, .. }) => {\n-                    let ImplStripper(s) = *self;\n-                    if did.is_local() && !s.contains(&did.node) {\n+                    if did.is_local() && !self.0.contains(&did) {\n                         return None;\n                     }\n                 }"}, {"sha": "9972ede8b8f9fb8dd2fbc75577bdcbf321c1fc14", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5600c6282e699ad77d0303456fa068aa649b7007/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=5600c6282e699ad77d0303456fa068aa649b7007", "patch": "@@ -205,16 +205,18 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             None => return false\n         };\n         let def = tcx.def_map.borrow()[&id].def_id();\n-        if !def.is_local() { return false }\n+        let def_node_id = match tcx.map.as_local_node_id(def) {\n+            Some(n) => n, None => return false\n+        };\n         let analysis = match self.analysis {\n             Some(analysis) => analysis, None => return false\n         };\n-        if !please_inline && analysis.public_items.contains(&def.node) {\n+        if !please_inline && analysis.public_items.contains(&def) {\n             return false\n         }\n-        if !self.view_item_stack.insert(def.node) { return false }\n+        if !self.view_item_stack.insert(def_node_id) { return false }\n \n-        let ret = match tcx.map.get(def.node) {\n+        let ret = match tcx.map.get(def_node_id) {\n             hir_map::NodeItem(it) => {\n                 if glob {\n                     let prev = mem::replace(&mut self.inlining_from_glob, true);\n@@ -235,7 +237,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             }\n             _ => false,\n         };\n-        self.view_item_stack.remove(&id);\n+        self.view_item_stack.remove(&def_node_id);\n         return ret;\n     }\n "}]}