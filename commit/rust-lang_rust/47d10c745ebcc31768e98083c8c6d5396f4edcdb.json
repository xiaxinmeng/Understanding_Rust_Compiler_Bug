{"sha": "47d10c745ebcc31768e98083c8c6d5396f4edcdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZDEwYzc0NWViY2MzMTc2OGU5ODA4M2M4YzZkNTM5NmY0ZWRjZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-11T18:36:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-11T18:36:18Z"}, "message": "auto merge of #10891 : chris-morgan/rust/macroize-(or-should-that-be-macroify)-syntax--parse--token-so-that-we-don't-make-mistakes-and-to-reduce-the-maintenance-burden, r=huonw\n\nI also renumbered things at the same time; ``in`` was shifted into its\r\nalphabetical position and the reserved keywords were reordered (a couple\r\nof them were out of order).\r\n\r\nUnused special identifiers are also removed in the second part.", "tree": {"sha": "037278162c53e782c5c68860a54080031abca96c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/037278162c53e782c5c68860a54080031abca96c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47d10c745ebcc31768e98083c8c6d5396f4edcdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47d10c745ebcc31768e98083c8c6d5396f4edcdb", "html_url": "https://github.com/rust-lang/rust/commit/47d10c745ebcc31768e98083c8c6d5396f4edcdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47d10c745ebcc31768e98083c8c6d5396f4edcdb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f41b4e351b4fface2ad3c4b74912837c4059d56a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f41b4e351b4fface2ad3c4b74912837c4059d56a", "html_url": "https://github.com/rust-lang/rust/commit/f41b4e351b4fface2ad3c4b74912837c4059d56a"}, {"sha": "dd042efa7e109dee88241358f88a0c8bb57e9269", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd042efa7e109dee88241358f88a0c8bb57e9269", "html_url": "https://github.com/rust-lang/rust/commit/dd042efa7e109dee88241358f88a0c8bb57e9269"}], "stats": {"total": 432, "additions": 161, "deletions": 271}, "files": [{"sha": "a49f423c408750d86535a18f896bef271f675024", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 161, "deletions": 271, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/47d10c745ebcc31768e98083c8c6d5396f4edcdb/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47d10c745ebcc31768e98083c8c6d5396f4edcdb/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=47d10c745ebcc31768e98083c8c6d5396f4edcdb", "patch": "@@ -316,72 +316,166 @@ pub fn is_bar(t: &Token) -> bool {\n     match *t { BINOP(OR) | OROR => true, _ => false }\n }\n \n-pub mod special_idents {\n-    use ast::Ident;\n-\n-    pub static underscore : Ident = Ident { name: 0, ctxt: 0}; // apparently unused?\n-    pub static anon : Ident = Ident { name: 1, ctxt: 0};\n-    pub static invalid : Ident = Ident { name: 2, ctxt: 0}; // ''\n-    pub static unary : Ident = Ident { name: 3, ctxt: 0}; // apparently unused?\n-    pub static not_fn : Ident = Ident { name: 4, ctxt: 0}; // apparently unused?\n-    pub static idx_fn : Ident = Ident { name: 5, ctxt: 0}; // apparently unused?\n-    pub static unary_minus_fn : Ident = Ident { name: 6, ctxt: 0}; // apparently unused?\n-    pub static clownshoes_extensions : Ident = Ident { name: 7, ctxt: 0};\n-\n-    pub static self_ : Ident = Ident { name: super::SELF_KEYWORD_NAME, ctxt: 0}; // 'self'\n-\n-    /* for matcher NTs */\n-    // none of these appear to be used, but perhaps references to\n-    // these are artificially fabricated by the macro system....\n-    pub static item : Ident = Ident { name: 9, ctxt: 0};\n-    pub static block : Ident = Ident { name: 10, ctxt: 0};\n-    pub static stmt : Ident = Ident { name: 11, ctxt: 0};\n-    pub static pat : Ident = Ident { name: 12, ctxt: 0};\n-    pub static expr : Ident = Ident { name: 13, ctxt: 0};\n-    pub static ty : Ident = Ident { name: 14, ctxt: 0};\n-    pub static ident : Ident = Ident { name: 15, ctxt: 0};\n-    pub static path : Ident = Ident { name: 16, ctxt: 0};\n-    pub static tt : Ident = Ident { name: 17, ctxt: 0};\n-    pub static matchers : Ident = Ident { name: 18, ctxt: 0};\n-\n-    pub static str : Ident = Ident { name: 19, ctxt: 0}; // for the type // apparently unused?\n-\n-    /* outside of libsyntax */\n-    pub static arg : Ident = Ident { name: 20, ctxt: 0};\n-    pub static descrim : Ident = Ident { name: 21, ctxt: 0};\n-    pub static clownshoe_abi : Ident = Ident { name: 22, ctxt: 0};\n-    pub static clownshoe_stack_shim : Ident = Ident { name: 23, ctxt: 0};\n-    pub static main : Ident = Ident { name: 24, ctxt: 0};\n-    pub static opaque : Ident = Ident { name: 25, ctxt: 0};\n-    pub static blk : Ident = Ident { name: 26, ctxt: 0};\n-    pub static statik : Ident = Ident { name: super::STATIC_KEYWORD_NAME, ctxt: 0};\n-    pub static clownshoes_foreign_mod: Ident = Ident { name: 28, ctxt: 0};\n-    pub static unnamed_field: Ident = Ident { name: 29, ctxt: 0};\n-    pub static c_abi: Ident = Ident { name: 30, ctxt: 0}; // apparently unused?\n-    pub static type_self: Ident = Ident { name: 31, ctxt: 0};    // `Self`\n-}\n-\n-// here are the ones that actually occur in the source. Maybe the rest\n-// should be removed?\n-/*\n-special_idents::anon\n-special_idents::arg\n-special_idents::blk\n-special_idents::clownshoe_abi\n-special_idents::clownshoe_stack_shim\n-special_idents::clownshoes_extensions\n-special_idents::clownshoes_foreign_mod\n-special_idents::descrim\n-special_idents::invalid\n-special_idents::main\n-special_idents::matchers\n-special_idents::opaque\n-special_idents::self_\n-special_idents::statik\n-special_idents::tt\n-special_idents::type_self\n-special_idents::unnamed_field\n-*/\n+// Get the first \"argument\"\n+macro_rules! first {\n+    ( $first:expr, $( $remainder:expr, )* ) => ( $first )\n+}\n+\n+// Get the last \"argument\" (has to be done recursively to avoid phoney local ambiguity error)\n+macro_rules! last {\n+    ( $first:expr, $( $remainder:expr, )+ ) => ( last!( $( $remainder, )+ ) );\n+    ( $first:expr, ) => ( $first )\n+}\n+\n+// In this macro, there is the requirement that the name (the number) must be monotonically\n+// increasing by one in the special identifiers, starting at 0; the same holds for the keywords,\n+// except starting from the next number instead of zero, and with the additional exception that\n+// special identifiers are *also* allowed (they are deduplicated in the important place, the\n+// interner), an exception which is demonstrated by \"static\" and \"self\".\n+macro_rules! declare_special_idents_and_keywords {(\n+    // So now, in these rules, why is each definition parenthesised?\n+    // Answer: otherwise we get a spurious local ambiguity bug on the \"}\"\n+    pub mod special_idents {\n+        $( ($si_name:expr, $si_static:ident, $si_str:expr); )*\n+    }\n+\n+    pub mod keywords {\n+        'strict:\n+        $( ($sk_name:expr, $sk_variant:ident, $sk_str:expr); )*\n+        'reserved:\n+        $( ($rk_name:expr, $rk_variant:ident, $rk_str:expr); )*\n+    }\n+) => {\n+    static STRICT_KEYWORD_START: Name = first!($( $sk_name, )*);\n+    static STRICT_KEYWORD_FINAL: Name = last!($( $sk_name, )*);\n+    static RESERVED_KEYWORD_START: Name = first!($( $rk_name, )*);\n+    static RESERVED_KEYWORD_FINAL: Name = last!($( $rk_name, )*);\n+\n+    pub mod special_idents {\n+        use ast::Ident;\n+        $( pub static $si_static: Ident = Ident { name: $si_name, ctxt: 0 }; )*\n+    }\n+\n+    /**\n+     * All the valid words that have meaning in the Rust language.\n+     *\n+     * Rust keywords are either 'strict' or 'reserved'.  Strict keywords may not\n+     * appear as identifiers at all. Reserved keywords are not used anywhere in\n+     * the language and may not appear as identifiers.\n+     */\n+    pub mod keywords {\n+        use ast::Ident;\n+\n+        pub enum Keyword {\n+            $( $sk_variant, )*\n+            $( $rk_variant, )*\n+        }\n+\n+        impl Keyword {\n+            pub fn to_ident(&self) -> Ident {\n+                match *self {\n+                    $( $sk_variant => Ident { name: $sk_name, ctxt: 0 }, )*\n+                    $( $rk_variant => Ident { name: $rk_name, ctxt: 0 }, )*\n+                }\n+            }\n+        }\n+    }\n+\n+    fn mk_fresh_ident_interner() -> @ident_interner {\n+        // The indices here must correspond to the numbers in\n+        // special_idents, in Keyword to_ident(), and in static\n+        // constants below.\n+        let init_vec = ~[\n+            $( $si_str, )*\n+            $( $sk_str, )*\n+            $( $rk_str, )*\n+        ];\n+\n+        @interner::StrInterner::prefill(init_vec)\n+    }\n+}}\n+\n+// If the special idents get renumbered, remember to modify these two as appropriate\n+static SELF_KEYWORD_NAME: Name = 3;\n+static STATIC_KEYWORD_NAME: Name = 10;\n+\n+declare_special_idents_and_keywords! {\n+    pub mod special_idents {\n+        // These ones are statics\n+\n+        (0,                          anon,                   \"anon\");\n+        (1,                          invalid,                \"\");       // ''\n+        (2,                          clownshoes_extensions,  \"__extensions__\");\n+\n+        (super::SELF_KEYWORD_NAME,   self_,                  \"self\"); // 'self'\n+\n+        // for matcher NTs\n+        (4,                          tt,                     \"tt\");\n+        (5,                          matchers,               \"matchers\");\n+\n+        // outside of libsyntax\n+        (6,                          arg,                    \"arg\");\n+        (7,                          clownshoe_abi,          \"__rust_abi\");\n+        (8,                          main,                   \"main\");\n+        (9,                          opaque,                 \"<opaque>\");\n+        (super::STATIC_KEYWORD_NAME, statik,                 \"static\");\n+        (11,                         clownshoes_foreign_mod, \"__foreign_mod__\");\n+        (12,                         unnamed_field,          \"<unnamed_field>\");\n+        (13,                         type_self,              \"Self\"); // `Self`\n+    }\n+\n+    pub mod keywords {\n+        // These ones are variants of the Keyword enum\n+\n+        'strict:\n+        (14,                         As,         \"as\");\n+        (15,                         Break,      \"break\");\n+        (16,                         Const,      \"const\");\n+        (17,                         Do,         \"do\");\n+        (18,                         Else,       \"else\");\n+        (19,                         Enum,       \"enum\");\n+        (20,                         Extern,     \"extern\");\n+        (21,                         False,      \"false\");\n+        (22,                         Fn,         \"fn\");\n+        (23,                         For,        \"for\");\n+        (24,                         If,         \"if\");\n+        (25,                         Impl,       \"impl\");\n+        (26,                         In,         \"in\");\n+        (27,                         Let,        \"let\");\n+        (28,                         __LogLevel, \"__log_level\");\n+        (29,                         Loop,       \"loop\");\n+        (30,                         Match,      \"match\");\n+        (31,                         Mod,        \"mod\");\n+        (32,                         Mut,        \"mut\");\n+        (33,                         Once,       \"once\");\n+        (34,                         Priv,       \"priv\");\n+        (35,                         Pub,        \"pub\");\n+        (36,                         Ref,        \"ref\");\n+        (37,                         Return,     \"return\");\n+        // Static and Self are also special idents (prefill de-dupes)\n+        (super::STATIC_KEYWORD_NAME, Static,     \"static\");\n+        (super::SELF_KEYWORD_NAME,   Self,       \"self\");\n+        (38,                         Struct,     \"struct\");\n+        (39,                         Super,      \"super\");\n+        (40,                         True,       \"true\");\n+        (41,                         Trait,      \"trait\");\n+        (42,                         Type,       \"type\");\n+        (43,                         Unsafe,     \"unsafe\");\n+        (44,                         Use,        \"use\");\n+        (45,                         While,      \"while\");\n+        (46,                         Continue,   \"continue\");\n+        (47,                         Proc,       \"proc\");\n+\n+        'reserved:\n+        (48,                         Alignof,    \"alignof\");\n+        (49,                         Be,         \"be\");\n+        (50,                         Offsetof,   \"offsetof\");\n+        (51,                         Pure,       \"pure\");\n+        (52,                         Sizeof,     \"sizeof\");\n+        (53,                         Typeof,     \"typeof\");\n+        (54,                         Yield,      \"yield\");\n+    }\n+}\n \n /**\n  * Maps a token to a record specifying the corresponding binary\n@@ -414,101 +508,6 @@ pub fn token_to_binop(tok: &Token) -> Option<ast::BinOp> {\n // looks like we can get rid of this completely...\n pub type ident_interner = StrInterner;\n \n-// return a fresh interner, preloaded with special identifiers.\n-fn mk_fresh_ident_interner() -> @ident_interner {\n-    // The indices here must correspond to the numbers in\n-    // special_idents, in Keyword to_ident(), and in static\n-    // constants below.\n-    let init_vec = ~[\n-        \"_\",                  // 0\n-        \"anon\",               // 1\n-        \"\",                   // 2\n-        \"unary\",              // 3\n-        \"!\",                  // 4\n-        \"[]\",                 // 5\n-        \"unary-\",             // 6\n-        \"__extensions__\",     // 7\n-        \"self\",               // 8\n-        \"item\",               // 9\n-        \"block\",              // 10\n-        \"stmt\",               // 11\n-        \"pat\",                // 12\n-        \"expr\",               // 13\n-        \"ty\",                 // 14\n-        \"ident\",              // 15\n-        \"path\",               // 16\n-        \"tt\",                 // 17\n-        \"matchers\",           // 18\n-        \"str\",                // 19\n-        \"arg\",                // 20\n-        \"descrim\",            // 21\n-        \"__rust_abi\",         // 22\n-        \"__rust_stack_shim\",  // 23\n-        \"main\",               // 24\n-        \"<opaque>\",           // 25\n-        \"blk\",                // 26\n-        \"static\",             // 27\n-        \"__foreign_mod__\",    // 28\n-        \"<unnamed_field>\",    // 29\n-        \"C\",                  // 30\n-        \"Self\",               // 31\n-\n-        \"as\",                 // 32\n-        \"break\",              // 33\n-        \"const\",              // 34\n-        \"do\",                 // 35\n-        \"else\",               // 36\n-        \"enum\",               // 37\n-        \"extern\",             // 38\n-        \"false\",              // 39\n-        \"fn\",                 // 40\n-        \"for\",                // 41\n-        \"if\",                 // 42\n-        \"impl\",               // 43\n-        \"let\",                // 44\n-        \"__log_level\",        // 45\n-        \"loop\",               // 46\n-        \"match\",              // 47\n-        \"mod\",                // 48\n-        \"mut\",                // 49\n-        \"once\",               // 50\n-        \"priv\",               // 51\n-        \"pub\",                // 52\n-        \"ref\",                // 53\n-        \"return\",             // 54\n-        \"static\",             // 27 -- also a special ident (prefill de-dupes)\n-        \"self\",               //  8 -- also a special ident (prefill de-dupes)\n-        \"struct\",             // 55\n-        \"super\",              // 56\n-        \"true\",               // 57\n-        \"trait\",              // 58\n-        \"type\",               // 59\n-        \"unsafe\",             // 60\n-        \"use\",                // 61\n-        \"while\",              // 62\n-        \"in\",                 // 63\n-        \"continue\",           // 64\n-        \"proc\",               // 65\n-\n-        \"be\",                 // 66\n-        \"pure\",               // 67\n-        \"yield\",              // 68\n-        \"typeof\",             // 69\n-        \"alignof\",            // 70\n-        \"offsetof\",           // 71\n-        \"sizeof\",             // 72\n-    ];\n-\n-    @interner::StrInterner::prefill(init_vec)\n-}\n-\n-static SELF_KEYWORD_NAME: Name = 8;\n-static STATIC_KEYWORD_NAME: Name = 27;\n-static STRICT_KEYWORD_START: Name = 32;\n-static STRICT_KEYWORD_FINAL: Name = 65;\n-static RESERVED_KEYWORD_START: Name = 66;\n-static RESERVED_KEYWORD_FINAL: Name = 72;\n-\n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n pub fn get_ident_interner() -> @ident_interner {\n@@ -601,116 +600,7 @@ pub fn fresh_mark() -> Mrk {\n     gensym(\"mark\")\n }\n \n-/**\n- * All the valid words that have meaning in the Rust language.\n- *\n- * Rust keywords are either 'strict' or 'reserved'.  Strict keywords may not\n- * appear as identifiers at all. Reserved keywords are not used anywhere in\n- * the language and may not appear as identifiers.\n- */\n-pub mod keywords {\n-    use ast::Ident;\n-\n-    pub enum Keyword {\n-        // Strict keywords\n-        As,\n-        Break,\n-        Const,\n-        Do,\n-        Else,\n-        Enum,\n-        Extern,\n-        False,\n-        Fn,\n-        For,\n-        If,\n-        Impl,\n-        In,\n-        Let,\n-        __LogLevel,\n-        Loop,\n-        Match,\n-        Mod,\n-        Mut,\n-        Once,\n-        Priv,\n-        Pub,\n-        Ref,\n-        Return,\n-        Static,\n-        Self,\n-        Struct,\n-        Super,\n-        True,\n-        Trait,\n-        Type,\n-        Unsafe,\n-        Use,\n-        While,\n-        Continue,\n-        Proc,\n-\n-        // Reserved keywords\n-        Alignof,\n-        Be,\n-        Offsetof,\n-        Pure,\n-        Sizeof,\n-        Typeof,\n-        Yield,\n-    }\n-\n-    impl Keyword {\n-        pub fn to_ident(&self) -> Ident {\n-            match *self {\n-                As => Ident { name: 32, ctxt: 0 },\n-                Break => Ident { name: 33, ctxt: 0 },\n-                Const => Ident { name: 34, ctxt: 0 },\n-                Do => Ident { name: 35, ctxt: 0 },\n-                Else => Ident { name: 36, ctxt: 0 },\n-                Enum => Ident { name: 37, ctxt: 0 },\n-                Extern => Ident { name: 38, ctxt: 0 },\n-                False => Ident { name: 39, ctxt: 0 },\n-                Fn => Ident { name: 40, ctxt: 0 },\n-                For => Ident { name: 41, ctxt: 0 },\n-                If => Ident { name: 42, ctxt: 0 },\n-                Impl => Ident { name: 43, ctxt: 0 },\n-                In => Ident { name: 63, ctxt: 0 },\n-                Let => Ident { name: 44, ctxt: 0 },\n-                __LogLevel => Ident { name: 45, ctxt: 0 },\n-                Loop => Ident { name: 46, ctxt: 0 },\n-                Match => Ident { name: 47, ctxt: 0 },\n-                Mod => Ident { name: 48, ctxt: 0 },\n-                Mut => Ident { name: 49, ctxt: 0 },\n-                Once => Ident { name: 50, ctxt: 0 },\n-                Priv => Ident { name: 51, ctxt: 0 },\n-                Pub => Ident { name: 52, ctxt: 0 },\n-                Ref => Ident { name: 53, ctxt: 0 },\n-                Return => Ident { name: 54, ctxt: 0 },\n-                Static => Ident { name: super::STATIC_KEYWORD_NAME, ctxt: 0 },\n-                Self => Ident { name: super::SELF_KEYWORD_NAME, ctxt: 0 },\n-                Struct => Ident { name: 55, ctxt: 0 },\n-                Super => Ident { name: 56, ctxt: 0 },\n-                True => Ident { name: 57, ctxt: 0 },\n-                Trait => Ident { name: 58, ctxt: 0 },\n-                Type => Ident { name: 59, ctxt: 0 },\n-                Unsafe => Ident { name: 60, ctxt: 0 },\n-                Use => Ident { name: 61, ctxt: 0 },\n-                While => Ident { name: 62, ctxt: 0 },\n-                Continue => Ident { name: 64, ctxt: 0 },\n-                Proc => Ident { name: 65, ctxt: 0 },\n-\n-                Alignof => Ident { name: 70, ctxt: 0 },\n-                Be => Ident { name: 66, ctxt: 0 },\n-                Offsetof => Ident { name: 71, ctxt: 0 },\n-                Pure => Ident { name: 67, ctxt: 0 },\n-                Sizeof => Ident { name: 72, ctxt: 0 },\n-                Typeof => Ident { name: 69, ctxt: 0 },\n-                Yield => Ident { name: 68, ctxt: 0 },\n-            }\n-        }\n-    }\n-}\n+// See the macro above about the types of keywords\n \n pub fn is_keyword(kw: keywords::Keyword, tok: &Token) -> bool {\n     match *tok {"}]}