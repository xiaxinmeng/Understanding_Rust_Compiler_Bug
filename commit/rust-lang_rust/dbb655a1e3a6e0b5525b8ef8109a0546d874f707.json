{"sha": "dbb655a1e3a6e0b5525b8ef8109a0546d874f707", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYjY1NWExZTNhNmUwYjU1MjViOGVmODEwOWEwNTQ2ZDg3NGY3MDc=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-06-13T16:36:01Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2017-06-13T16:36:01Z"}, "message": "Change the for-loop desugar so the `break` does not affect type inference. Fixes #42618", "tree": {"sha": "6b584f92862e824e4f4eab357132537b7595dac6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b584f92862e824e4f4eab357132537b7595dac6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbb655a1e3a6e0b5525b8ef8109a0546d874f707", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbb655a1e3a6e0b5525b8ef8109a0546d874f707", "html_url": "https://github.com/rust-lang/rust/commit/dbb655a1e3a6e0b5525b8ef8109a0546d874f707", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbb655a1e3a6e0b5525b8ef8109a0546d874f707/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f8b93693da78c2cfe1d7f1dc6834c5ba61e0cc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f8b93693da78c2cfe1d7f1dc6834c5ba61e0cc0", "html_url": "https://github.com/rust-lang/rust/commit/3f8b93693da78c2cfe1d7f1dc6834c5ba61e0cc0"}], "stats": {"total": 43, "additions": 31, "deletions": 12}, "files": [{"sha": "c91fd16391aafc0b11e6fa783fe6fd595dcbc203", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dbb655a1e3a6e0b5525b8ef8109a0546d874f707/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb655a1e3a6e0b5525b8ef8109a0546d874f707/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=dbb655a1e3a6e0b5525b8ef8109a0546d874f707", "patch": "@@ -191,10 +191,12 @@\n //! {\n //!     let result = match IntoIterator::into_iter(values) {\n //!         mut iter => loop {\n-//!             let x = match iter.next() {\n-//!                 Some(val) => val,\n+//!             let next;\n+//!             match iter.next() {\n+//!                 Some(val) => next = val,\n //!                 None => break,\n //!             };\n+//!             let x = next;\n //!             let () = { println!(\"{}\", x); };\n //!         },\n //!     };"}, {"sha": "1283d136d32877a4c3af437568c0f9aefda8ca5d", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dbb655a1e3a6e0b5525b8ef8109a0546d874f707/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbb655a1e3a6e0b5525b8ef8109a0546d874f707/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=dbb655a1e3a6e0b5525b8ef8109a0546d874f707", "patch": "@@ -2170,11 +2170,13 @@ impl<'a> LoweringContext<'a> {\n                 //     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n                 //       mut iter => {\n                 //         [opt_ident]: loop {\n-                //           let <pat> = match ::std::iter::Iterator::next(&mut iter) {\n-                //             ::std::option::Option::Some(val) => val,\n+                //           let next;\n+                //           match ::std::iter::Iterator::next(&mut iter) {\n+                //             ::std::option::Option::Some(val) => next = val,\n                 //             ::std::option::Option::None => break\n                 //           };\n-                //           SemiExpr(<body>);\n+                //           let <pat> = next;\n+                //           StmtExpr(<body>);\n                 //         }\n                 //       }\n                 //     };\n@@ -2186,13 +2188,18 @@ impl<'a> LoweringContext<'a> {\n \n                 let iter = self.str_to_ident(\"iter\");\n \n-                // `::std::option::Option::Some(val) => val`\n+                let next_ident = self.str_to_ident(\"next\");\n+                let next_pat = self.pat_ident(e.span, next_ident);\n+                \n+                // `::std::option::Option::Some(val) => next = val`\n                 let pat_arm = {\n                     let val_ident = self.str_to_ident(\"val\");\n                     let val_pat = self.pat_ident(e.span, val_ident);\n                     let val_expr = P(self.expr_ident(e.span, val_ident, val_pat.id));\n+                    let next_expr = P(self.expr_ident(e.span, next_ident, next_pat.id));\n+                    let assign = P(self.expr(e.span, hir::ExprAssign(next_expr, val_expr), ThinVec::new()));\n                     let some_pat = self.pat_some(e.span, val_pat);\n-                    self.arm(hir_vec![some_pat], val_expr)\n+                    self.arm(hir_vec![some_pat], assign)\n                 };\n \n                 // `::std::option::Option::None => break`\n@@ -2222,10 +2229,20 @@ impl<'a> LoweringContext<'a> {\n                                                hir::MatchSource::ForLoopDesugar),\n                                 ThinVec::new()))\n                 };\n+                let match_stmt = respan(e.span, hir::StmtExpr(match_expr, self.next_id()));\n+\n+                let next_expr = P(self.expr_ident(e.span, next_ident, next_pat.id));\n+                \n+                // `let next`\n+                let next_let = self.stmt_let_pat(e.span,\n+                    None,\n+                    next_pat,\n+                    hir::LocalSource::ForLoopDesugar);\n \n+                // `let <pat> = next`\n                 let pat = self.lower_pat(pat);\n                 let pat_let = self.stmt_let_pat(e.span,\n-                    match_expr,\n+                    Some(next_expr),\n                     pat,\n                     hir::LocalSource::ForLoopDesugar);\n \n@@ -2234,7 +2251,7 @@ impl<'a> LoweringContext<'a> {\n                 let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n                 let body_stmt = respan(e.span, hir::StmtExpr(body_expr, self.next_id()));\n \n-                let loop_block = P(self.block_all(e.span, hir_vec![pat_let, body_stmt], None));\n+                let loop_block = P(self.block_all(e.span, hir_vec![next_let, match_stmt, pat_let, body_stmt], None));\n \n                 // `[opt_ident]: loop { ... }`\n                 let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident),\n@@ -2601,14 +2618,14 @@ impl<'a> LoweringContext<'a> {\n \n     fn stmt_let_pat(&mut self,\n                     sp: Span,\n-                    ex: P<hir::Expr>,\n+                    ex: Option<P<hir::Expr>>,\n                     pat: P<hir::Pat>,\n                     source: hir::LocalSource)\n                     -> hir::Stmt {\n         let local = P(hir::Local {\n             pat: pat,\n             ty: None,\n-            init: Some(ex),\n+            init: ex,\n             id: self.next_id(),\n             span: sp,\n             attrs: ThinVec::new(),\n@@ -2626,7 +2643,7 @@ impl<'a> LoweringContext<'a> {\n             self.pat_ident(sp, ident)\n         };\n         let pat_id = pat.id;\n-        (self.stmt_let_pat(sp, ex, pat, hir::LocalSource::Normal), pat_id)\n+        (self.stmt_let_pat(sp, Some(ex), pat, hir::LocalSource::Normal), pat_id)\n     }\n \n     fn block_expr(&mut self, expr: P<hir::Expr>) -> hir::Block {"}]}