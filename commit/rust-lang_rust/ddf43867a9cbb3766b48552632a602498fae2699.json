{"sha": "ddf43867a9cbb3766b48552632a602498fae2699", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkZjQzODY3YTljYmIzNzY2YjQ4NTUyNjMyYTYwMjQ5OGZhZTI2OTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-26T12:34:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-26T12:34:54Z"}, "message": "Auto merge of #64515 - varkor:kindedterm, r=oli-obk\n\nRename `subst::Kind` to `subst::GenericArg`\n\nAnd `subst::UnpackedKind` to `subst::GenericArgKind`. Individual variable names (e.g. `kind`) are not renamed, which would be an infeasible mission.\n\nFixes https://github.com/rust-lang/rust/issues/64352.\n\nr? @eddyb", "tree": {"sha": "8bc475f0aea8c2d41b84fe038a3fc0b5ce2d0f70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bc475f0aea8c2d41b84fe038a3fc0b5ce2d0f70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddf43867a9cbb3766b48552632a602498fae2699", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddf43867a9cbb3766b48552632a602498fae2699", "html_url": "https://github.com/rust-lang/rust/commit/ddf43867a9cbb3766b48552632a602498fae2699", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddf43867a9cbb3766b48552632a602498fae2699/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "134004f74db3b4626bde37cc068d9ae6dedd2d38", "url": "https://api.github.com/repos/rust-lang/rust/commits/134004f74db3b4626bde37cc068d9ae6dedd2d38", "html_url": "https://github.com/rust-lang/rust/commit/134004f74db3b4626bde37cc068d9ae6dedd2d38"}, {"sha": "e3fb05dc3c32160e89ad354297b168fae11ffba1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3fb05dc3c32160e89ad354297b168fae11ffba1", "html_url": "https://github.com/rust-lang/rust/commit/e3fb05dc3c32160e89ad354297b168fae11ffba1"}], "stats": {"total": 694, "additions": 357, "deletions": 337}, "files": [{"sha": "56b15607729976889c33863f8be3806ecaf03154", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -56,7 +56,7 @@ where\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::subst::Kind<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::subst::GenericArg<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {"}, {"sha": "2ea1317a94fd952ddbae9b1e1a98fbdaaf40e055", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -13,7 +13,7 @@ use crate::infer::InferCtxt;\n use crate::mir::interpret::ConstValue;\n use std::sync::atomic::Ordering;\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n-use crate::ty::subst::Kind;\n+use crate::ty::subst::GenericArg;\n use crate::ty::{self, BoundVar, InferConst, List, Ty, TyCtxt, TypeFlags};\n use crate::ty::flags::FlagComputation;\n \n@@ -282,7 +282,7 @@ struct Canonicalizer<'cx, 'tcx> {\n     query_state: &'cx mut OriginalQueryValues<'tcx>,\n     // Note that indices is only used once `var_values` is big enough to be\n     // heap-allocated.\n-    indices: FxHashMap<Kind<'tcx>, BoundVar>,\n+    indices: FxHashMap<GenericArg<'tcx>, BoundVar>,\n     canonicalize_region_mode: &'cx dyn CanonicalizeRegionMode,\n     needs_canonical_flags: TypeFlags,\n \n@@ -566,7 +566,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n     /// or returns an existing variable if `kind` has already been\n     /// seen. `kind` is expected to be an unbound variable (or\n     /// potentially a free region).\n-    fn canonical_var(&mut self, info: CanonicalVarInfo, kind: Kind<'tcx>) -> BoundVar {\n+    fn canonical_var(&mut self, info: CanonicalVarInfo, kind: GenericArg<'tcx>) -> BoundVar {\n         let Canonicalizer {\n             variables,\n             query_state,"}, {"sha": "4e442608f0e7e3211f76abe5a9f01d29af3308ad", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -32,7 +32,7 @@ use smallvec::SmallVec;\n use std::ops::Index;\n use syntax::source_map::Span;\n use crate::ty::fold::TypeFoldable;\n-use crate::ty::subst::Kind;\n+use crate::ty::subst::GenericArg;\n use crate::ty::{self, BoundVar, InferConst, Lift, List, Region, TyCtxt};\n \n mod canonicalizer;\n@@ -66,7 +66,7 @@ impl<'tcx> UseSpecializedDecodable for CanonicalVarInfos<'tcx> {}\n /// canonicalized query response.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub struct CanonicalVarValues<'tcx> {\n-    pub var_values: IndexVec<BoundVar, Kind<'tcx>>,\n+    pub var_values: IndexVec<BoundVar, GenericArg<'tcx>>,\n }\n \n /// When we canonicalize a value to form a query, we wind up replacing\n@@ -83,7 +83,7 @@ pub struct OriginalQueryValues<'tcx> {\n \n     /// This is equivalent to `CanonicalVarValues`, but using a\n     /// `SmallVec` yields a significant performance win.\n-    pub var_values: SmallVec<[Kind<'tcx>; 8]>,\n+    pub var_values: SmallVec<[GenericArg<'tcx>; 8]>,\n }\n \n impl Default for OriginalQueryValues<'tcx> {\n@@ -308,7 +308,7 @@ impl<'tcx, V> Canonical<'tcx, V> {\n }\n \n pub type QueryOutlivesConstraint<'tcx> =\n-    ty::Binder<ty::OutlivesPredicate<Kind<'tcx>, Region<'tcx>>>;\n+    ty::Binder<ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Creates a substitution S for the canonical value with fresh\n@@ -359,7 +359,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         variables: &List<CanonicalVarInfo>,\n         universe_map: impl Fn(ty::UniverseIndex) -> ty::UniverseIndex,\n     ) -> CanonicalVarValues<'tcx> {\n-        let var_values: IndexVec<BoundVar, Kind<'tcx>> = variables\n+        let var_values: IndexVec<BoundVar, GenericArg<'tcx>> = variables\n             .iter()\n             .map(|info| self.instantiate_canonical_var(span, *info, &universe_map))\n             .collect();\n@@ -376,7 +376,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         span: Span,\n         cv_info: CanonicalVarInfo,\n         universe_map: impl Fn(ty::UniverseIndex) -> ty::UniverseIndex,\n-    ) -> Kind<'tcx> {\n+    ) -> GenericArg<'tcx> {\n         match cv_info.kind {\n             CanonicalVarKind::Ty(ty_kind) => {\n                 let ty = match ty_kind {\n@@ -495,19 +495,19 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n     /// we'll return a substitution `subst` with:\n     /// `subst.var_values == [Type(^0), Lifetime(^1), Type(^2)]`.\n     pub fn make_identity(&self, tcx: TyCtxt<'tcx>) -> Self {\n-        use crate::ty::subst::UnpackedKind;\n+        use crate::ty::subst::GenericArgKind;\n \n         CanonicalVarValues {\n             var_values: self.var_values.iter()\n                 .zip(0..)\n                 .map(|(kind, i)| match kind.unpack() {\n-                    UnpackedKind::Type(..) => tcx.mk_ty(\n+                    GenericArgKind::Type(..) => tcx.mk_ty(\n                         ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())\n                     ).into(),\n-                    UnpackedKind::Lifetime(..) => tcx.mk_region(\n+                    GenericArgKind::Lifetime(..) => tcx.mk_region(\n                         ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(i))\n                     ).into(),\n-                    UnpackedKind::Const(ct) => {\n+                    GenericArgKind::Const(ct) => {\n                         tcx.mk_const(ty::Const {\n                             ty: ct.ty,\n                             val: ConstValue::Infer(\n@@ -522,8 +522,8 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n }\n \n impl<'a, 'tcx> IntoIterator for &'a CanonicalVarValues<'tcx> {\n-    type Item = Kind<'tcx>;\n-    type IntoIter = ::std::iter::Cloned<::std::slice::Iter<'a, Kind<'tcx>>>;\n+    type Item = GenericArg<'tcx>;\n+    type IntoIter = ::std::iter::Cloned<::std::slice::Iter<'a, GenericArg<'tcx>>>;\n \n     fn into_iter(self) -> Self::IntoIter {\n         self.var_values.iter().cloned()\n@@ -570,9 +570,9 @@ BraceStructLiftImpl! {\n }\n \n impl<'tcx> Index<BoundVar> for CanonicalVarValues<'tcx> {\n-    type Output = Kind<'tcx>;\n+    type Output = GenericArg<'tcx>;\n \n-    fn index(&self, value: BoundVar) -> &Kind<'tcx> {\n+    fn index(&self, value: BoundVar) -> &GenericArg<'tcx> {\n         &self.var_values[value]\n     }\n }"}, {"sha": "18c1b41d5bb4c785ed86163e76abd283c4665c34", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -25,7 +25,7 @@ use crate::traits::query::{Fallible, NoSolution};\n use crate::traits::TraitEngine;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use crate::ty::fold::TypeFoldable;\n-use crate::ty::subst::{Kind, UnpackedKind};\n+use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::{self, BoundVar, InferConst, Ty, TyCtxt};\n use crate::util::captures::Captures;\n \n@@ -298,11 +298,14 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                 &v.var_values[BoundVar::new(index)]\n             });\n             match (original_value.unpack(), result_value.unpack()) {\n-                (UnpackedKind::Lifetime(ty::ReErased), UnpackedKind::Lifetime(ty::ReErased)) => {\n-                    // no action needed\n+                (\n+                    GenericArgKind::Lifetime(ty::ReErased),\n+                    GenericArgKind::Lifetime(ty::ReErased),\n+                ) => {\n+                    // No action needed.\n                 }\n \n-                (UnpackedKind::Lifetime(v_o), UnpackedKind::Lifetime(v_r)) => {\n+                (GenericArgKind::Lifetime(v_o), GenericArgKind::Lifetime(v_r)) => {\n                     // To make `v_o = v_r`, we emit `v_o: v_r` and `v_r: v_o`.\n                     if v_o != v_r {\n                         output_query_region_constraints\n@@ -314,12 +317,12 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                     }\n                 }\n \n-                (UnpackedKind::Type(v1), UnpackedKind::Type(v2)) => {\n+                (GenericArgKind::Type(v1), GenericArgKind::Type(v2)) => {\n                     let ok = self.at(cause, param_env).eq(v1, v2)?;\n                     obligations.extend(ok.into_obligations());\n                 }\n \n-                (UnpackedKind::Const(v1), UnpackedKind::Const(v2)) => {\n+                (GenericArgKind::Const(v1), GenericArgKind::Const(v2)) => {\n                     let ok = self.at(cause, param_env).eq(v1, v2)?;\n                     obligations.extend(ok.into_obligations());\n                 }\n@@ -462,14 +465,14 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         // is directly equal to one of the canonical variables in the\n         // result, then we can type the corresponding value from the\n         // input. See the example above.\n-        let mut opt_values: IndexVec<BoundVar, Option<Kind<'tcx>>> =\n+        let mut opt_values: IndexVec<BoundVar, Option<GenericArg<'tcx>>> =\n             IndexVec::from_elem_n(None, query_response.variables.len());\n \n         // In terms of our example above, we are iterating over pairs like:\n         // [(?A, Vec<?0>), ('static, '?1), (?B, ?0)]\n         for (original_value, result_value) in original_values.var_values.iter().zip(result_values) {\n             match result_value.unpack() {\n-                UnpackedKind::Type(result_value) => {\n+                GenericArgKind::Type(result_value) => {\n                     // e.g., here `result_value` might be `?0` in the example above...\n                     if let ty::Bound(debruijn, b) = result_value.kind {\n                         // ...in which case we would set `canonical_vars[0]` to `Some(?U)`.\n@@ -479,7 +482,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                         opt_values[b.var] = Some(*original_value);\n                     }\n                 }\n-                UnpackedKind::Lifetime(result_value) => {\n+                GenericArgKind::Lifetime(result_value) => {\n                     // e.g., here `result_value` might be `'?1` in the example above...\n                     if let &ty::RegionKind::ReLateBound(debruijn, br) = result_value {\n                         // ... in which case we would set `canonical_vars[0]` to `Some('static)`.\n@@ -489,7 +492,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                         opt_values[br.assert_bound_var()] = Some(*original_value);\n                     }\n                 }\n-                UnpackedKind::Const(result_value) => {\n+                GenericArgKind::Const(result_value) => {\n                     if let ty::Const {\n                         val: ConstValue::Infer(InferConst::Canonical(debrujin, b)),\n                         ..\n@@ -553,7 +556,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         // canonical variable; this is taken from\n         // `query_response.var_values` after applying the substitution\n         // `result_subst`.\n-        let substituted_query_response = |index: BoundVar| -> Kind<'tcx> {\n+        let substituted_query_response = |index: BoundVar| -> GenericArg<'tcx> {\n             query_response.substitute_projected(self.tcx, &result_subst, |v| &v.var_values[index])\n         };\n \n@@ -586,17 +589,17 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                     cause.clone(),\n                     param_env,\n                     match k1.unpack() {\n-                        UnpackedKind::Lifetime(r1) => ty::Predicate::RegionOutlives(\n+                        GenericArgKind::Lifetime(r1) => ty::Predicate::RegionOutlives(\n                             ty::Binder::bind(\n                                 ty::OutlivesPredicate(r1, r2)\n                             )\n                         ),\n-                        UnpackedKind::Type(t1) => ty::Predicate::TypeOutlives(\n+                        GenericArgKind::Type(t1) => ty::Predicate::TypeOutlives(\n                             ty::Binder::bind(\n                                 ty::OutlivesPredicate(t1, r2)\n                             )\n                         ),\n-                        UnpackedKind::Const(..) => {\n+                        GenericArgKind::Const(..) => {\n                             // Consts cannot outlive one another, so we don't expect to\n                             // ecounter this branch.\n                             span_bug!(cause.span, \"unexpected const outlives {:?}\", constraint);\n@@ -613,29 +616,29 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         variables1: &OriginalQueryValues<'tcx>,\n-        variables2: impl Fn(BoundVar) -> Kind<'tcx>,\n+        variables2: impl Fn(BoundVar) -> GenericArg<'tcx>,\n     ) -> InferResult<'tcx, ()> {\n         self.commit_if_ok(|_| {\n             let mut obligations = vec![];\n             for (index, value1) in variables1.var_values.iter().enumerate() {\n                 let value2 = variables2(BoundVar::new(index));\n \n                 match (value1.unpack(), value2.unpack()) {\n-                    (UnpackedKind::Type(v1), UnpackedKind::Type(v2)) => {\n+                    (GenericArgKind::Type(v1), GenericArgKind::Type(v2)) => {\n                         obligations\n                             .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n                     }\n                     (\n-                        UnpackedKind::Lifetime(ty::ReErased),\n-                        UnpackedKind::Lifetime(ty::ReErased),\n+                        GenericArgKind::Lifetime(ty::ReErased),\n+                        GenericArgKind::Lifetime(ty::ReErased),\n                     ) => {\n                         // no action needed\n                     }\n-                    (UnpackedKind::Lifetime(v1), UnpackedKind::Lifetime(v2)) => {\n+                    (GenericArgKind::Lifetime(v1), GenericArgKind::Lifetime(v2)) => {\n                         obligations\n                             .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n                     }\n-                    (UnpackedKind::Const(v1), UnpackedKind::Const(v2)) => {\n+                    (GenericArgKind::Const(v1), GenericArgKind::Const(v2)) => {\n                         let ok = self.at(cause, param_env).eq(v1, v2)?;\n                         obligations.extend(ok.into_obligations());\n                     }"}, {"sha": "4f5bb09c9167a339afb9ef29ee327f9746a12229", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -8,7 +8,7 @@\n \n use crate::infer::canonical::{Canonical, CanonicalVarValues};\n use crate::ty::fold::TypeFoldable;\n-use crate::ty::subst::UnpackedKind;\n+use crate::ty::subst::GenericArgKind;\n use crate::ty::{self, TyCtxt};\n \n impl<'tcx, V> Canonical<'tcx, V> {\n@@ -58,21 +58,21 @@ where\n     } else {\n         let fld_r = |br: ty::BoundRegion| {\n             match var_values.var_values[br.assert_bound_var()].unpack() {\n-                UnpackedKind::Lifetime(l) => l,\n+                GenericArgKind::Lifetime(l) => l,\n                 r => bug!(\"{:?} is a region but value is {:?}\", br, r),\n             }\n         };\n \n         let fld_t = |bound_ty: ty::BoundTy| {\n             match var_values.var_values[bound_ty.var].unpack() {\n-                UnpackedKind::Type(ty) => ty,\n+                GenericArgKind::Type(ty) => ty,\n                 r => bug!(\"{:?} is a type but value is {:?}\", bound_ty, r),\n             }\n         };\n \n         let fld_c = |bound_ct: ty::BoundVar, _| {\n             match var_values.var_values[bound_ct].unpack() {\n-                UnpackedKind::Const(ct) => ct,\n+                GenericArgKind::Const(ct) => ct,\n                 c => bug!(\"{:?} is a const but value is {:?}\", bound_ct, c),\n             }\n         };"}, {"sha": "f28a52a1d8d7d47e0f14651f2ba85ba0418a5dc3", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -464,7 +464,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         use hir::def_id::CrateNum;\n         use hir::map::DisambiguatedDefPathData;\n         use ty::print::Printer;\n-        use ty::subst::Kind;\n+        use ty::subst::GenericArg;\n \n         struct AbsolutePathPrinter<'tcx> {\n             tcx: TyCtxt<'tcx>,\n@@ -548,7 +548,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             fn path_generic_args(\n                 self,\n                 print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-                _args: &[Kind<'tcx>],\n+                _args: &[GenericArg<'tcx>],\n             ) -> Result<Self::Path, Self::Error> {\n                 print_prefix(self)\n             }"}, {"sha": "ca07496afed0824e432d76ac872a4d516693c4c9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -20,7 +20,7 @@ use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n use crate::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use crate::ty::fold::{TypeFolder, TypeFoldable};\n use crate::ty::relate::RelateResult;\n-use crate::ty::subst::{Kind, InternalSubsts, SubstsRef};\n+use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt, InferConst};\n use crate::ty::{FloatVid, IntVid, TyVid, ConstVid};\n use crate::util::nodemap::FxHashMap;\n@@ -1110,7 +1110,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.next_region_var_in_universe(RegionVariableOrigin::NLL(origin), universe)\n     }\n \n-    pub fn var_for_def(&self, span: Span, param: &ty::GenericParamDef) -> Kind<'tcx> {\n+    pub fn var_for_def(&self, span: Span, param: &ty::GenericParamDef) -> GenericArg<'tcx> {\n         match param.kind {\n             GenericParamDefKind::Lifetime => {\n                 // Create a region inference variable for the given"}, {"sha": "47e5c2b59ef36916dc9c9a02d64d6d8befe2b910", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -26,7 +26,7 @@ use crate::traits::DomainGoal;\n use crate::ty::error::TypeError;\n use crate::ty::fold::{TypeFoldable, TypeVisitor};\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use crate::ty::subst::Kind;\n+use crate::ty::subst::GenericArg;\n use crate::ty::{self, Ty, TyCtxt, InferConst};\n use crate::mir::interpret::ConstValue;\n use rustc_data_structures::fx::FxHashMap;\n@@ -124,7 +124,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n #[derive(Clone, Debug)]\n struct ScopesAndKind<'tcx> {\n     scopes: Vec<BoundRegionScope<'tcx>>,\n-    kind: Kind<'tcx>,\n+    kind: GenericArg<'tcx>,\n }\n \n #[derive(Clone, Debug, Default)]"}, {"sha": "0b746e5dfb6239ca8a5bcad0a76b00cbb55a8d84", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -7,7 +7,7 @@ use crate::middle::region;\n use crate::mir::interpret::ConstValue;\n use crate::traits::{self, PredicateObligation};\n use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n-use crate::ty::subst::{InternalSubsts, Kind, SubstsRef, UnpackedKind};\n+use crate::ty::subst::{InternalSubsts, GenericArg, SubstsRef, GenericArgKind};\n use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n use crate::util::nodemap::DefIdMap;\n use errors::DiagnosticBuilder;\n@@ -570,7 +570,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // `impl Trait` return type, resulting in the parameters\n         // shifting.\n         let id_substs = InternalSubsts::identity_for_item(gcx, def_id);\n-        let map: FxHashMap<Kind<'tcx>, Kind<'tcx>> = opaque_defn\n+        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> = opaque_defn\n             .substs\n             .iter()\n             .enumerate()\n@@ -759,7 +759,7 @@ struct ReverseMapper<'tcx> {\n     tainted_by_errors: bool,\n \n     opaque_type_def_id: DefId,\n-    map: FxHashMap<Kind<'tcx>, Kind<'tcx>>,\n+    map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n     map_missing_regions_to_empty: bool,\n \n     /// initially `Some`, set to `None` once error has been reported\n@@ -774,7 +774,7 @@ impl ReverseMapper<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         tainted_by_errors: bool,\n         opaque_type_def_id: DefId,\n-        map: FxHashMap<Kind<'tcx>, Kind<'tcx>>,\n+        map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n         hidden_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Self {\n@@ -789,15 +789,18 @@ impl ReverseMapper<'tcx> {\n         }\n     }\n \n-    fn fold_kind_mapping_missing_regions_to_empty(&mut self, kind: Kind<'tcx>) -> Kind<'tcx> {\n+    fn fold_kind_mapping_missing_regions_to_empty(\n+        &mut self,\n+        kind: GenericArg<'tcx>,\n+    ) -> GenericArg<'tcx> {\n         assert!(!self.map_missing_regions_to_empty);\n         self.map_missing_regions_to_empty = true;\n         let kind = kind.fold_with(self);\n         self.map_missing_regions_to_empty = false;\n         kind\n     }\n \n-    fn fold_kind_normally(&mut self, kind: Kind<'tcx>) -> Kind<'tcx> {\n+    fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n         assert!(!self.map_missing_regions_to_empty);\n         kind.fold_with(self)\n     }\n@@ -822,7 +825,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n \n         let generics = self.tcx().generics_of(self.opaque_type_def_id);\n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n-            Some(UnpackedKind::Lifetime(r1)) => r1,\n+            Some(GenericArgKind::Lifetime(r1)) => r1,\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n             None if generics.parent.is_some() => {\n                 if !self.map_missing_regions_to_empty && !self.tainted_by_errors {\n@@ -919,7 +922,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 match self.map.get(&ty.into()).map(|k| k.unpack()) {\n                     // Found it in the substitution list; replace with the parameter from the\n                     // opaque type.\n-                    Some(UnpackedKind::Type(t1)) => t1,\n+                    Some(GenericArgKind::Type(t1)) => t1,\n                     Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n                     None => {\n                         self.tcx.sess\n@@ -949,7 +952,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 match self.map.get(&ct.into()).map(|k| k.unpack()) {\n                     // Found it in the substitution list, replace with the parameter from the\n                     // opaque type.\n-                    Some(UnpackedKind::Const(c1)) => c1,\n+                    Some(GenericArgKind::Const(c1)) => c1,\n                     Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n                     None => {\n                         self.tcx.sess"}, {"sha": "f7806188775fa80f37a956f40961128925789f66", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -67,7 +67,7 @@ use crate::hir;\n use crate::traits::ObligationCause;\n use crate::ty::outlives::Component;\n use crate::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n-use crate::ty::subst::UnpackedKind;\n+use crate::ty::subst::GenericArgKind;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Registers that the given region obligation must be resolved\n@@ -433,13 +433,13 @@ where\n \n             for k in projection_ty.substs {\n                 match k.unpack() {\n-                    UnpackedKind::Lifetime(lt) => {\n+                    GenericArgKind::Lifetime(lt) => {\n                         self.delegate.push_sub_region_constraint(origin.clone(), region, lt);\n                     }\n-                    UnpackedKind::Type(ty) => {\n+                    GenericArgKind::Type(ty) => {\n                         self.type_must_outlive(origin.clone(), ty, region);\n                     }\n-                    UnpackedKind::Const(_) => {\n+                    GenericArgKind::Const(_) => {\n                         // Const parameters don't impose constraints.\n                     }\n                 }"}, {"sha": "3483efbd8408f26be6c983ab84ace908803dcf55", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -27,7 +27,7 @@ use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n use crate::middle::privacy::AccessLevels;\n use crate::session::{config, early_error, Session};\n-use crate::ty::{self, print::Printer, subst::Kind, TyCtxt, Ty};\n+use crate::ty::{self, print::Printer, subst::GenericArg, TyCtxt, Ty};\n use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n use crate::util::nodemap::FxHashMap;\n use crate::util::common::time;\n@@ -882,7 +882,7 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n             fn path_generic_args(\n                 self,\n                 print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-                _args: &[Kind<'tcx>],\n+                _args: &[GenericArg<'tcx>],\n             ) -> Result<Self::Path, Self::Error> {\n                 print_prefix(self)\n             }"}, {"sha": "cd58396d95c62b6dcdea6607a6eb653a709e3093", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -109,7 +109,7 @@ pub use self::pointer::{Pointer, PointerArithmetic, CheckInAllocMsg};\n \n use crate::mir;\n use crate::hir::def_id::DefId;\n-use crate::ty::{self, TyCtxt, Instance, subst::UnpackedKind};\n+use crate::ty::{self, TyCtxt, Instance, subst::GenericArgKind};\n use crate::ty::codec::TyDecoder;\n use crate::ty::layout::{self, Size};\n use std::io;\n@@ -426,7 +426,7 @@ impl<'tcx> AllocMap<'tcx> {\n         // this for generic functions.  Lifetime parameters are ignored.\n         let is_generic = instance.substs.into_iter().any(|kind| {\n             match kind.unpack() {\n-                UnpackedKind::Lifetime(_) => false,\n+                GenericArgKind::Lifetime(_) => false,\n                 _ => true,\n             }\n         });"}, {"sha": "c3c43132d85403ce24c2f1454a3f9c0f2bf3b69d", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -3,7 +3,7 @@ use crate::infer::InferOk;\n use crate::infer::canonical::OriginalQueryValues;\n use std::iter::FromIterator;\n use syntax::source_map::Span;\n-use crate::ty::subst::Kind;\n+use crate::ty::subst::GenericArg;\n use crate::ty::{self, Ty, TyCtxt};\n \n impl<'cx, 'tcx> At<'cx, 'tcx> {\n@@ -24,7 +24,7 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n     ///\n     /// [#1238]: https://github.com/rust-lang/rfcs/blob/master/text/1238-nonparametric-dropck.md\n     /// [#1327]: https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md\n-    pub fn dropck_outlives(&self, ty: Ty<'tcx>) -> InferOk<'tcx, Vec<Kind<'tcx>>> {\n+    pub fn dropck_outlives(&self, ty: Ty<'tcx>) -> InferOk<'tcx, Vec<GenericArg<'tcx>>> {\n         debug!(\n             \"dropck_outlives(ty={:?}, param_env={:?})\",\n             ty, self.param_env,\n@@ -80,7 +80,7 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n \n #[derive(Clone, Debug, Default)]\n pub struct DropckOutlivesResult<'tcx> {\n-    pub kinds: Vec<Kind<'tcx>>,\n+    pub kinds: Vec<GenericArg<'tcx>>,\n     pub overflows: Vec<Ty<'tcx>>,\n }\n \n@@ -104,7 +104,7 @@ impl<'tcx> DropckOutlivesResult<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         span: Span,\n         ty: Ty<'tcx>,\n-    ) -> Vec<Kind<'tcx>> {\n+    ) -> Vec<GenericArg<'tcx>> {\n         self.report_overflows(tcx, span, ty);\n         let DropckOutlivesResult { kinds, overflows: _ } = self;\n         kinds\n@@ -117,7 +117,7 @@ impl<'tcx> DropckOutlivesResult<'tcx> {\n pub struct DtorckConstraint<'tcx> {\n     /// Types that are required to be alive in order for this\n     /// type to be valid for destruction.\n-    pub outlives: Vec<ty::subst::Kind<'tcx>>,\n+    pub outlives: Vec<ty::subst::GenericArg<'tcx>>,\n \n     /// Types that could not be resolved: projections and params.\n     pub dtorck_types: Vec<Ty<'tcx>>,"}, {"sha": "6a99d12d1a425e258767ff4eb2907cd755bda081", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -7,7 +7,7 @@ use crate::hir::def_id::DefId;\n use crate::traits::specialize::specialization_graph::NodeItem;\n use crate::ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n use crate::ty::outlives::Component;\n-use crate::ty::subst::{Kind, Subst, SubstsRef};\n+use crate::ty::subst::{GenericArg, Subst, SubstsRef};\n use crate::util::nodemap::FxHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n@@ -551,7 +551,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                                    trait_def_id: DefId,\n                                    recursion_depth: usize,\n                                    self_ty: Ty<'tcx>,\n-                                   params: &[Kind<'tcx>])\n+                                   params: &[GenericArg<'tcx>])\n         -> PredicateObligation<'tcx>\n     {\n         let trait_ref = ty::TraitRef {"}, {"sha": "6c3bb3ebb779529ef5c8b9c384aa425756ea82c0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -23,7 +23,7 @@ use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n use crate::mir::{Body, interpret, ProjectionKind, Promoted};\n use crate::mir::interpret::{ConstValue, Allocation, Scalar};\n-use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, Subst};\n+use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n use crate::traits;\n use crate::traits::{Clause, Clauses, GoalKind, Goal, Goals};\n@@ -39,7 +39,7 @@ use crate::ty::GenericParamDefKind;\n use crate::ty::layout::{LayoutDetails, TargetDataLayout, VariantIdx};\n use crate::ty::query;\n use crate::ty::steal::Steal;\n-use crate::ty::subst::{UserSubsts, UnpackedKind};\n+use crate::ty::subst::{UserSubsts, GenericArgKind};\n use crate::ty::{BoundVar, BindingMode};\n use crate::ty::CanonicalPolyFnSig;\n use crate::util::common::ErrorReported;\n@@ -132,13 +132,13 @@ impl<'tcx> CtxtInterners<'tcx> {\n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline(never)]\n     fn intern_ty(&self,\n-        st: TyKind<'tcx>\n+        kind: TyKind<'tcx>\n     ) -> Ty<'tcx> {\n-        self.type_.intern(st, |st| {\n-            let flags = super::flags::FlagComputation::for_sty(&st);\n+        self.type_.intern(kind, |kind| {\n+            let flags = super::flags::FlagComputation::for_kind(&kind);\n \n             let ty_struct = TyS {\n-                kind: st,\n+                kind,\n                 flags: flags.flags,\n                 outer_exclusive_binder: flags.outer_exclusive_binder,\n             };\n@@ -828,7 +828,7 @@ impl CanonicalUserType<'tcx> {\n \n                 user_substs.substs.iter().zip(BoundVar::new(0)..).all(|(kind, cvar)| {\n                     match kind.unpack() {\n-                        UnpackedKind::Type(ty) => match ty.kind {\n+                        GenericArgKind::Type(ty) => match ty.kind {\n                             ty::Bound(debruijn, b) => {\n                                 // We only allow a `ty::INNERMOST` index in substitutions.\n                                 assert_eq!(debruijn, ty::INNERMOST);\n@@ -837,7 +837,7 @@ impl CanonicalUserType<'tcx> {\n                             _ => false,\n                         },\n \n-                        UnpackedKind::Lifetime(r) => match r {\n+                        GenericArgKind::Lifetime(r) => match r {\n                             ty::ReLateBound(debruijn, br) => {\n                                 // We only allow a `ty::INNERMOST` index in substitutions.\n                                 assert_eq!(*debruijn, ty::INNERMOST);\n@@ -846,7 +846,7 @@ impl CanonicalUserType<'tcx> {\n                             _ => false,\n                         },\n \n-                        UnpackedKind::Const(ct) => match ct.val {\n+                        GenericArgKind::Const(ct) => match ct.val {\n                             ConstValue::Infer(InferConst::Canonical(debruijn, b)) => {\n                                 // We only allow a `ty::INNERMOST` index in substitutions.\n                                 assert_eq!(debruijn, ty::INNERMOST);\n@@ -1701,7 +1701,7 @@ nop_list_lift!{CanonicalVarInfo => CanonicalVarInfo}\n nop_list_lift!{ProjectionKind => ProjectionKind}\n \n // This is the impl for `&'a InternalSubsts<'a>`.\n-nop_list_lift!{Kind<'a> => Kind<'tcx>}\n+nop_list_lift!{GenericArg<'a> => GenericArg<'tcx>}\n \n pub mod tls {\n     use super::{GlobalCtxt, TyCtxt, ptr_eq};\n@@ -2129,8 +2129,8 @@ impl<'tcx> Borrow<[CanonicalVarInfo]> for Interned<'tcx, List<CanonicalVarInfo>>\n     }\n }\n \n-impl<'tcx> Borrow<[Kind<'tcx>]> for Interned<'tcx, InternalSubsts<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a [Kind<'tcx>] {\n+impl<'tcx> Borrow<[GenericArg<'tcx>]> for Interned<'tcx, InternalSubsts<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a [GenericArg<'tcx>] {\n         &self.0[..]\n     }\n }\n@@ -2250,7 +2250,7 @@ slice_interners!(\n     existential_predicates: _intern_existential_predicates(ExistentialPredicate<'tcx>),\n     predicates: _intern_predicates(Predicate<'tcx>),\n     type_list: _intern_type_list(Ty<'tcx>),\n-    substs: _intern_substs(Kind<'tcx>),\n+    substs: _intern_substs(GenericArg<'tcx>),\n     clauses: _intern_clauses(Clause<'tcx>),\n     goal_list: _intern_goals(Goal<'tcx>),\n     projs: _intern_projs(ProjectionKind)\n@@ -2452,13 +2452,13 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn intern_tup(self, ts: &[Ty<'tcx>]) -> Ty<'tcx> {\n-        let kinds: Vec<_> = ts.into_iter().map(|&t| Kind::from(t)).collect();\n+        let kinds: Vec<_> = ts.into_iter().map(|&t| GenericArg::from(t)).collect();\n         self.mk_ty(Tuple(self.intern_substs(&kinds)))\n     }\n \n     pub fn mk_tup<I: InternAs<[Ty<'tcx>], Ty<'tcx>>>(self, iter: I) -> I::Output {\n         iter.intern_with(|ts| {\n-            let kinds: Vec<_> = ts.into_iter().map(|&t| Kind::from(t)).collect();\n+            let kinds: Vec<_> = ts.into_iter().map(|&t| GenericArg::from(t)).collect();\n             self.mk_ty(Tuple(self.intern_substs(&kinds)))\n         })\n     }\n@@ -2592,7 +2592,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n \n-    pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> Kind<'tcx> {\n+    pub fn mk_param_from_def(self, param: &ty::GenericParamDef) -> GenericArg<'tcx> {\n         match param.kind {\n             GenericParamDefKind::Lifetime => {\n                 self.mk_region(ty::ReEarlyBound(param.to_early_bound_region_data())).into()\n@@ -2637,7 +2637,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn intern_substs(self, ts: &[Kind<'tcx>]) -> &'tcx List<Kind<'tcx>> {\n+    pub fn intern_substs(self, ts: &[GenericArg<'tcx>]) -> &'tcx List<GenericArg<'tcx>> {\n         if ts.len() == 0 {\n             List::empty()\n         } else {\n@@ -2710,14 +2710,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         iter.intern_with(|xs| self.intern_type_list(xs))\n     }\n \n-    pub fn mk_substs<I: InternAs<[Kind<'tcx>],\n-                     &'tcx List<Kind<'tcx>>>>(self, iter: I) -> I::Output {\n+    pub fn mk_substs<I: InternAs<[GenericArg<'tcx>],\n+                     &'tcx List<GenericArg<'tcx>>>>(self, iter: I) -> I::Output {\n         iter.intern_with(|xs| self.intern_substs(xs))\n     }\n \n     pub fn mk_substs_trait(self,\n                      self_ty: Ty<'tcx>,\n-                     rest: &[Kind<'tcx>])\n+                     rest: &[GenericArg<'tcx>])\n                     -> SubstsRef<'tcx>\n     {\n         self.mk_substs(iter::once(self_ty.into()).chain(rest.iter().cloned()))"}, {"sha": "6e43aa6a25d555bc366fca718cae5140bdb6cf42", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -1,4 +1,4 @@\n-use crate::ty::subst::{SubstsRef, UnpackedKind};\n+use crate::ty::subst::{SubstsRef, GenericArgKind};\n use crate::ty::{self, Ty, TypeFlags, InferConst};\n use crate::mir::interpret::ConstValue;\n \n@@ -19,9 +19,9 @@ impl FlagComputation {\n     }\n \n     #[allow(rustc::usage_of_ty_tykind)]\n-    pub fn for_sty(st: &ty::TyKind<'_>) -> FlagComputation {\n+    pub fn for_kind(kind: &ty::TyKind<'_>) -> FlagComputation {\n         let mut result = FlagComputation::new();\n-        result.add_sty(st);\n+        result.add_kind(kind);\n         result\n     }\n \n@@ -63,8 +63,8 @@ impl FlagComputation {\n     }\n \n     #[allow(rustc::usage_of_ty_tykind)]\n-    fn add_sty(&mut self, st: &ty::TyKind<'_>) {\n-        match st {\n+    fn add_kind(&mut self, kind: &ty::TyKind<'_>) {\n+        match kind {\n             &ty::Bool |\n             &ty::Char |\n             &ty::Int(_) |\n@@ -266,9 +266,9 @@ impl FlagComputation {\n     fn add_substs(&mut self, substs: SubstsRef<'_>) {\n         for kind in substs {\n             match kind.unpack() {\n-                UnpackedKind::Type(ty) => self.add_ty(ty),\n-                UnpackedKind::Lifetime(lt) => self.add_region(lt),\n-                UnpackedKind::Const(ct) => self.add_const(ct),\n+                GenericArgKind::Type(ty) => self.add_ty(ty),\n+                GenericArgKind::Lifetime(lt) => self.add_region(lt),\n+                GenericArgKind::Const(ct) => self.add_const(ct),\n             }\n         }\n     }"}, {"sha": "d216c81f8a6c2dd4a10e1cefa910c3938ff2cc9d", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -1,7 +1,7 @@\n use crate::hir::map::{DefPathData, DisambiguatedDefPathData};\n use crate::hir::def_id::{CrateNum, DefId};\n use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n-use crate::ty::subst::{Kind, Subst};\n+use crate::ty::subst::{GenericArg, Subst};\n \n use rustc_data_structures::fx::FxHashSet;\n \n@@ -43,15 +43,15 @@ pub trait Printer<'tcx>: Sized {\n     fn print_def_path(\n         self,\n         def_id: DefId,\n-        substs: &'tcx [Kind<'tcx>],\n+        substs: &'tcx [GenericArg<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         self.default_print_def_path(def_id, substs)\n     }\n \n     fn print_impl_path(\n         self,\n         impl_def_id: DefId,\n-        substs: &'tcx [Kind<'tcx>],\n+        substs: &'tcx [GenericArg<'tcx>],\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n@@ -106,15 +106,15 @@ pub trait Printer<'tcx>: Sized {\n     fn path_generic_args(\n         self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        args: &[Kind<'tcx>],\n+        args: &[GenericArg<'tcx>],\n     ) -> Result<Self::Path, Self::Error>;\n \n     // Defaults (should not be overriden):\n \n     fn default_print_def_path(\n         self,\n         def_id: DefId,\n-        substs: &'tcx [Kind<'tcx>],\n+        substs: &'tcx [GenericArg<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         debug!(\"default_print_def_path: def_id={:?}, substs={:?}\", def_id, substs);\n         let key = self.tcx().def_key(def_id);\n@@ -189,8 +189,8 @@ pub trait Printer<'tcx>: Sized {\n     fn generic_args_to_print(\n         &self,\n         generics: &'tcx ty::Generics,\n-        substs: &'tcx [Kind<'tcx>],\n-    ) -> &'tcx [Kind<'tcx>] {\n+        substs: &'tcx [GenericArg<'tcx>],\n+    ) -> &'tcx [GenericArg<'tcx>] {\n         let mut own_params = generics.parent_count..generics.count();\n \n         // Don't print args for `Self` parameters (of traits).\n@@ -203,7 +203,7 @@ pub trait Printer<'tcx>: Sized {\n             match param.kind {\n                 ty::GenericParamDefKind::Lifetime => false,\n                 ty::GenericParamDefKind::Type { has_default, .. } => {\n-                    has_default && substs[param.index as usize] == Kind::from(\n+                    has_default && substs[param.index as usize] == GenericArg::from(\n                         self.tcx().type_of(param.def_id).subst(self.tcx(), substs)\n                     )\n                 }\n@@ -217,7 +217,7 @@ pub trait Printer<'tcx>: Sized {\n     fn default_print_impl_path(\n         self,\n         impl_def_id: DefId,\n-        _substs: &'tcx [Kind<'tcx>],\n+        _substs: &'tcx [GenericArg<'tcx>],\n         self_ty: Ty<'tcx>,\n         impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {"}, {"sha": "2bc87d6b8ba5edba35c61c58f95878a76b1aa56f", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -5,7 +5,7 @@ use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n use crate::middle::region;\n use crate::ty::{self, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n-use crate::ty::subst::{Kind, Subst, UnpackedKind};\n+use crate::ty::subst::{GenericArg, Subst, GenericArgKind};\n use crate::ty::layout::{Integer, IntegerExt, Size};\n use crate::mir::interpret::{ConstValue, sign_extend, Scalar, truncate};\n \n@@ -183,7 +183,7 @@ pub trait PrettyPrinter<'tcx>:\n     fn print_value_path(\n         self,\n         def_id: DefId,\n-        substs: &'tcx [Kind<'tcx>],\n+        substs: &'tcx [GenericArg<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         self.print_def_path(def_id, substs)\n     }\n@@ -764,13 +764,13 @@ pub trait PrettyPrinter<'tcx>:\n                 // Don't print `'_` if there's no unerased regions.\n                 let print_regions = args.iter().any(|arg| {\n                     match arg.unpack() {\n-                        UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                        GenericArgKind::Lifetime(r) => *r != ty::ReErased,\n                         _ => false,\n                     }\n                 });\n                 let mut args = args.iter().cloned().filter(|arg| {\n                     match arg.unpack() {\n-                        UnpackedKind::Lifetime(_) => print_regions,\n+                        GenericArgKind::Lifetime(_) => print_regions,\n                         _ => true,\n                     }\n                 });\n@@ -1081,7 +1081,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n     fn print_def_path(\n         mut self,\n         def_id: DefId,\n-        substs: &'tcx [Kind<'tcx>],\n+        substs: &'tcx [GenericArg<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         define_scoped_cx!(self);\n \n@@ -1245,20 +1245,20 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n     fn path_generic_args(\n         mut self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        args: &[Kind<'tcx>],\n+        args: &[GenericArg<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         self = print_prefix(self)?;\n \n         // Don't print `'_` if there's no unerased regions.\n         let print_regions = args.iter().any(|arg| {\n             match arg.unpack() {\n-                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                GenericArgKind::Lifetime(r) => *r != ty::ReErased,\n                 _ => false,\n             }\n         });\n         let args = args.iter().cloned().filter(|arg| {\n             match arg.unpack() {\n-                UnpackedKind::Lifetime(_) => print_regions,\n+                GenericArgKind::Lifetime(_) => print_regions,\n                 _ => true,\n             }\n         });\n@@ -1282,7 +1282,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n     fn print_value_path(\n         mut self,\n         def_id: DefId,\n-        substs: &'tcx [Kind<'tcx>],\n+        substs: &'tcx [GenericArg<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         let was_in_value = std::mem::replace(&mut self.in_value, true);\n         self = self.print_def_path(def_id, substs)?;\n@@ -1778,11 +1778,11 @@ define_print_and_forward_display! {\n         }\n     }\n \n-    Kind<'tcx> {\n+    GenericArg<'tcx> {\n         match self.unpack() {\n-            UnpackedKind::Lifetime(lt) => p!(print(lt)),\n-            UnpackedKind::Type(ty) => p!(print(ty)),\n-            UnpackedKind::Const(ct) => p!(print(ct)),\n+            GenericArgKind::Lifetime(lt) => p!(print(lt)),\n+            GenericArgKind::Type(ty) => p!(print(ty)),\n+            GenericArgKind::Const(ct) => p!(print(ct)),\n         }\n     }\n }"}, {"sha": "2af6963f7122a9b8f8baed618826ae1f1ce25d16", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -5,7 +5,7 @@\n //! subtyping, type equality, etc.\n \n use crate::hir::def_id::DefId;\n-use crate::ty::subst::{Kind, UnpackedKind, SubstsRef};\n+use crate::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::error::{ExpectedFound, TypeError};\n use crate::mir::interpret::{ConstValue, Scalar};\n@@ -711,29 +711,29 @@ impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Box<T> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for Kind<'tcx> {\n+impl<'tcx> Relate<'tcx> for GenericArg<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &Kind<'tcx>,\n-        b: &Kind<'tcx>,\n-    ) -> RelateResult<'tcx, Kind<'tcx>> {\n+        a: &GenericArg<'tcx>,\n+        b: &GenericArg<'tcx>,\n+    ) -> RelateResult<'tcx, GenericArg<'tcx>> {\n         match (a.unpack(), b.unpack()) {\n-            (UnpackedKind::Lifetime(a_lt), UnpackedKind::Lifetime(b_lt)) => {\n+            (GenericArgKind::Lifetime(a_lt), GenericArgKind::Lifetime(b_lt)) => {\n                 Ok(relation.relate(&a_lt, &b_lt)?.into())\n             }\n-            (UnpackedKind::Type(a_ty), UnpackedKind::Type(b_ty)) => {\n+            (GenericArgKind::Type(a_ty), GenericArgKind::Type(b_ty)) => {\n                 Ok(relation.relate(&a_ty, &b_ty)?.into())\n             }\n-            (UnpackedKind::Const(a_ct), UnpackedKind::Const(b_ct)) => {\n+            (GenericArgKind::Const(a_ct), GenericArgKind::Const(b_ct)) => {\n                 Ok(relation.relate(&a_ct, &b_ct)?.into())\n             }\n-            (UnpackedKind::Lifetime(unpacked), x) => {\n+            (GenericArgKind::Lifetime(unpacked), x) => {\n                 bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n             }\n-            (UnpackedKind::Type(unpacked), x) => {\n+            (GenericArgKind::Type(unpacked), x) => {\n                 bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n             }\n-            (UnpackedKind::Const(unpacked), x) => {\n+            (GenericArgKind::Const(unpacked), x) => {\n                 bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n             }\n         }"}, {"sha": "91479751ef41d3544f3ae85d719477e832fef5a5", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -10,7 +10,7 @@ use crate::middle::region;\n use polonius_engine::Atom;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_macros::HashStable;\n-use crate::ty::subst::{InternalSubsts, Subst, SubstsRef, Kind, UnpackedKind};\n+use crate::ty::subst::{InternalSubsts, Subst, SubstsRef, GenericArg, GenericArgKind};\n use crate::ty::{self, AdtDef, Discr, DefIdTree, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use crate::ty::{List, TyS, ParamEnvAnd, ParamEnv};\n use crate::ty::layout::VariantIdx;\n@@ -320,7 +320,7 @@ pub struct ClosureSubsts<'tcx> {\n struct SplitClosureSubsts<'tcx> {\n     closure_kind_ty: Ty<'tcx>,\n     closure_sig_ty: Ty<'tcx>,\n-    upvar_kinds: &'tcx [Kind<'tcx>],\n+    upvar_kinds: &'tcx [GenericArg<'tcx>],\n }\n \n impl<'tcx> ClosureSubsts<'tcx> {\n@@ -345,7 +345,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         let SplitClosureSubsts { upvar_kinds, .. } = self.split(def_id, tcx);\n         upvar_kinds.iter().map(|t| {\n-            if let UnpackedKind::Type(ty) = t.unpack() {\n+            if let GenericArgKind::Type(ty) = t.unpack() {\n                 ty\n             } else {\n                 bug!(\"upvar should be type\")\n@@ -402,7 +402,7 @@ struct SplitGeneratorSubsts<'tcx> {\n     yield_ty: Ty<'tcx>,\n     return_ty: Ty<'tcx>,\n     witness: Ty<'tcx>,\n-    upvar_kinds: &'tcx [Kind<'tcx>],\n+    upvar_kinds: &'tcx [GenericArg<'tcx>],\n }\n \n impl<'tcx> GeneratorSubsts<'tcx> {\n@@ -434,7 +434,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     ) -> impl Iterator<Item = Ty<'tcx>> + 'tcx {\n         let SplitGeneratorSubsts { upvar_kinds, .. } = self.split(def_id, tcx);\n         upvar_kinds.iter().map(|t| {\n-            if let UnpackedKind::Type(ty) = t.unpack() {\n+            if let GenericArgKind::Type(ty) = t.unpack() {\n                 ty\n             } else {\n                 bug!(\"upvar should be type\")\n@@ -584,7 +584,7 @@ impl<'tcx> UpvarSubsts<'tcx> {\n             UpvarSubsts::Generator(substs) => substs.split(def_id, tcx).upvar_kinds,\n         };\n         upvar_kinds.iter().map(|t| {\n-            if let UnpackedKind::Type(ty) = t.unpack() {\n+            if let GenericArgKind::Type(ty) = t.unpack() {\n                 ty\n             } else {\n                 bug!(\"upvar should be type\")"}, {"sha": "e5bee3cfbd06e6717ff9cb9c40af2af53c12189e", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 82, "deletions": 72, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -20,11 +20,11 @@ use std::num::NonZeroUsize;\n \n /// An entity in the Rust type system, which can be one of\n /// several kinds (types, lifetimes, and consts).\n-/// To reduce memory usage, a `Kind` is a interned pointer,\n+/// To reduce memory usage, a `GenericArg` is a interned pointer,\n /// with the lowest 2 bits being reserved for a tag to\n /// indicate the type (`Ty`, `Region`, or `Const`) it points to.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Kind<'tcx> {\n+pub struct GenericArg<'tcx> {\n     ptr: NonZeroUsize,\n     marker: PhantomData<(Ty<'tcx>, ty::Region<'tcx>, &'tcx ty::Const<'tcx>)>\n }\n@@ -35,33 +35,33 @@ const REGION_TAG: usize = 0b01;\n const CONST_TAG: usize = 0b10;\n \n #[derive(Debug, RustcEncodable, RustcDecodable, PartialEq, Eq, PartialOrd, Ord, HashStable)]\n-pub enum UnpackedKind<'tcx> {\n+pub enum GenericArgKind<'tcx> {\n     Lifetime(ty::Region<'tcx>),\n     Type(Ty<'tcx>),\n     Const(&'tcx ty::Const<'tcx>),\n }\n \n-impl<'tcx> UnpackedKind<'tcx> {\n-    fn pack(self) -> Kind<'tcx> {\n+impl<'tcx> GenericArgKind<'tcx> {\n+    fn pack(self) -> GenericArg<'tcx> {\n         let (tag, ptr) = match self {\n-            UnpackedKind::Lifetime(lt) => {\n+            GenericArgKind::Lifetime(lt) => {\n                 // Ensure we can use the tag bits.\n                 assert_eq!(mem::align_of_val(lt) & TAG_MASK, 0);\n                 (REGION_TAG, lt as *const _ as usize)\n             }\n-            UnpackedKind::Type(ty) => {\n+            GenericArgKind::Type(ty) => {\n                 // Ensure we can use the tag bits.\n                 assert_eq!(mem::align_of_val(ty) & TAG_MASK, 0);\n                 (TYPE_TAG, ty as *const _ as usize)\n             }\n-            UnpackedKind::Const(ct) => {\n+            GenericArgKind::Const(ct) => {\n                 // Ensure we can use the tag bits.\n                 assert_eq!(mem::align_of_val(ct) & TAG_MASK, 0);\n                 (CONST_TAG, ct as *const _ as usize)\n             }\n         };\n \n-        Kind {\n+        GenericArg {\n             ptr: unsafe {\n                 NonZeroUsize::new_unchecked(ptr | tag)\n             },\n@@ -70,115 +70,115 @@ impl<'tcx> UnpackedKind<'tcx> {\n     }\n }\n \n-impl fmt::Debug for Kind<'tcx> {\n+impl fmt::Debug for GenericArg<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.unpack() {\n-            UnpackedKind::Lifetime(lt) => lt.fmt(f),\n-            UnpackedKind::Type(ty) => ty.fmt(f),\n-            UnpackedKind::Const(ct) => ct.fmt(f),\n+            GenericArgKind::Lifetime(lt) => lt.fmt(f),\n+            GenericArgKind::Type(ty) => ty.fmt(f),\n+            GenericArgKind::Const(ct) => ct.fmt(f),\n         }\n     }\n }\n \n-impl<'tcx> Ord for Kind<'tcx> {\n-    fn cmp(&self, other: &Kind<'_>) -> Ordering {\n+impl<'tcx> Ord for GenericArg<'tcx> {\n+    fn cmp(&self, other: &GenericArg<'_>) -> Ordering {\n         self.unpack().cmp(&other.unpack())\n     }\n }\n \n-impl<'tcx> PartialOrd for Kind<'tcx> {\n-    fn partial_cmp(&self, other: &Kind<'_>) -> Option<Ordering> {\n+impl<'tcx> PartialOrd for GenericArg<'tcx> {\n+    fn partial_cmp(&self, other: &GenericArg<'_>) -> Option<Ordering> {\n         Some(self.cmp(&other))\n     }\n }\n \n-impl<'tcx> From<ty::Region<'tcx>> for Kind<'tcx> {\n-    fn from(r: ty::Region<'tcx>) -> Kind<'tcx> {\n-        UnpackedKind::Lifetime(r).pack()\n+impl<'tcx> From<ty::Region<'tcx>> for GenericArg<'tcx> {\n+    fn from(r: ty::Region<'tcx>) -> GenericArg<'tcx> {\n+        GenericArgKind::Lifetime(r).pack()\n     }\n }\n \n-impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n-    fn from(ty: Ty<'tcx>) -> Kind<'tcx> {\n-        UnpackedKind::Type(ty).pack()\n+impl<'tcx> From<Ty<'tcx>> for GenericArg<'tcx> {\n+    fn from(ty: Ty<'tcx>) -> GenericArg<'tcx> {\n+        GenericArgKind::Type(ty).pack()\n     }\n }\n \n-impl<'tcx> From<&'tcx ty::Const<'tcx>> for Kind<'tcx> {\n-    fn from(c: &'tcx ty::Const<'tcx>) -> Kind<'tcx> {\n-        UnpackedKind::Const(c).pack()\n+impl<'tcx> From<&'tcx ty::Const<'tcx>> for GenericArg<'tcx> {\n+    fn from(c: &'tcx ty::Const<'tcx>) -> GenericArg<'tcx> {\n+        GenericArgKind::Const(c).pack()\n     }\n }\n \n-impl<'tcx> Kind<'tcx> {\n+impl<'tcx> GenericArg<'tcx> {\n     #[inline]\n-    pub fn unpack(self) -> UnpackedKind<'tcx> {\n+    pub fn unpack(self) -> GenericArgKind<'tcx> {\n         let ptr = self.ptr.get();\n         unsafe {\n             match ptr & TAG_MASK {\n-                REGION_TAG => UnpackedKind::Lifetime(&*((ptr & !TAG_MASK) as *const _)),\n-                TYPE_TAG => UnpackedKind::Type(&*((ptr & !TAG_MASK) as *const _)),\n-                CONST_TAG => UnpackedKind::Const(&*((ptr & !TAG_MASK) as *const _)),\n+                REGION_TAG => GenericArgKind::Lifetime(&*((ptr & !TAG_MASK) as *const _)),\n+                TYPE_TAG => GenericArgKind::Type(&*((ptr & !TAG_MASK) as *const _)),\n+                CONST_TAG => GenericArgKind::Const(&*((ptr & !TAG_MASK) as *const _)),\n                 _ => intrinsics::unreachable()\n             }\n         }\n     }\n \n-    /// Unpack the `Kind` as a type when it is known certainly to be a type.\n+    /// Unpack the `GenericArg` as a type when it is known certainly to be a type.\n     /// This is true in cases where `Substs` is used in places where the kinds are known\n     /// to be limited (e.g. in tuples, where the only parameters are type parameters).\n     pub fn expect_ty(self) -> Ty<'tcx> {\n         match self.unpack() {\n-            UnpackedKind::Type(ty) => ty,\n+            GenericArgKind::Type(ty) => ty,\n             _ => bug!(\"expected a type, but found another kind\"),\n         }\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for Kind<'a> {\n-    type Lifted = Kind<'tcx>;\n+impl<'a, 'tcx> Lift<'tcx> for GenericArg<'a> {\n+    type Lifted = GenericArg<'tcx>;\n \n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self.unpack() {\n-            UnpackedKind::Lifetime(lt) => tcx.lift(&lt).map(|lt| lt.into()),\n-            UnpackedKind::Type(ty) => tcx.lift(&ty).map(|ty| ty.into()),\n-            UnpackedKind::Const(ct) => tcx.lift(&ct).map(|ct| ct.into()),\n+            GenericArgKind::Lifetime(lt) => tcx.lift(&lt).map(|lt| lt.into()),\n+            GenericArgKind::Type(ty) => tcx.lift(&ty).map(|ty| ty.into()),\n+            GenericArgKind::Const(ct) => tcx.lift(&ct).map(|ct| ct.into()),\n         }\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Kind<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for GenericArg<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match self.unpack() {\n-            UnpackedKind::Lifetime(lt) => lt.fold_with(folder).into(),\n-            UnpackedKind::Type(ty) => ty.fold_with(folder).into(),\n-            UnpackedKind::Const(ct) => ct.fold_with(folder).into(),\n+            GenericArgKind::Lifetime(lt) => lt.fold_with(folder).into(),\n+            GenericArgKind::Type(ty) => ty.fold_with(folder).into(),\n+            GenericArgKind::Const(ct) => ct.fold_with(folder).into(),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match self.unpack() {\n-            UnpackedKind::Lifetime(lt) => lt.visit_with(visitor),\n-            UnpackedKind::Type(ty) => ty.visit_with(visitor),\n-            UnpackedKind::Const(ct) => ct.visit_with(visitor),\n+            GenericArgKind::Lifetime(lt) => lt.visit_with(visitor),\n+            GenericArgKind::Type(ty) => ty.visit_with(visitor),\n+            GenericArgKind::Const(ct) => ct.visit_with(visitor),\n         }\n     }\n }\n \n-impl<'tcx> Encodable for Kind<'tcx> {\n+impl<'tcx> Encodable for GenericArg<'tcx> {\n     fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         self.unpack().encode(e)\n     }\n }\n \n-impl<'tcx> Decodable for Kind<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Kind<'tcx>, D::Error> {\n-        Ok(UnpackedKind::decode(d)?.pack())\n+impl<'tcx> Decodable for GenericArg<'tcx> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<GenericArg<'tcx>, D::Error> {\n+        Ok(GenericArgKind::decode(d)?.pack())\n     }\n }\n \n /// A substitution mapping generic parameters to new values.\n-pub type InternalSubsts<'tcx> = List<Kind<'tcx>>;\n+pub type InternalSubsts<'tcx> = List<GenericArg<'tcx>>;\n \n pub type SubstsRef<'tcx> = &'tcx InternalSubsts<'tcx>;\n \n@@ -232,7 +232,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n     /// substitute defaults of generic parameters.\n     pub fn for_item<F>(tcx: TyCtxt<'tcx>, def_id: DefId, mut mk_kind: F) -> SubstsRef<'tcx>\n     where\n-        F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>,\n+        F: FnMut(&ty::GenericParamDef, &[GenericArg<'tcx>]) -> GenericArg<'tcx>,\n     {\n         let defs = tcx.generics_of(def_id);\n         let count = defs.count();\n@@ -243,7 +243,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n \n     pub fn extend_to<F>(&self, tcx: TyCtxt<'tcx>, def_id: DefId, mut mk_kind: F) -> SubstsRef<'tcx>\n     where\n-        F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>,\n+        F: FnMut(&ty::GenericParamDef, &[GenericArg<'tcx>]) -> GenericArg<'tcx>,\n     {\n         Self::for_item(tcx, def_id, |param, substs| {\n             self.get(param.index as usize)\n@@ -253,12 +253,12 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n     }\n \n     fn fill_item<F>(\n-        substs: &mut SmallVec<[Kind<'tcx>; 8]>,\n+        substs: &mut SmallVec<[GenericArg<'tcx>; 8]>,\n         tcx: TyCtxt<'tcx>,\n         defs: &ty::Generics,\n         mk_kind: &mut F,\n     ) where\n-        F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>,\n+        F: FnMut(&ty::GenericParamDef, &[GenericArg<'tcx>]) -> GenericArg<'tcx>,\n     {\n         if let Some(def_id) = defs.parent {\n             let parent_defs = tcx.generics_of(def_id);\n@@ -267,10 +267,10 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n         Self::fill_single(substs, defs, mk_kind)\n     }\n \n-    fn fill_single<F>(substs: &mut SmallVec<[Kind<'tcx>; 8]>,\n+    fn fill_single<F>(substs: &mut SmallVec<[GenericArg<'tcx>; 8]>,\n                       defs: &ty::Generics,\n                       mk_kind: &mut F)\n-    where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n+    where F: FnMut(&ty::GenericParamDef, &[GenericArg<'tcx>]) -> GenericArg<'tcx>\n     {\n         substs.reserve(defs.params.len());\n         for param in &defs.params {\n@@ -287,7 +287,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n     #[inline]\n     pub fn types(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {\n         self.iter().filter_map(|k| {\n-            if let UnpackedKind::Type(ty) = k.unpack() {\n+            if let GenericArgKind::Type(ty) = k.unpack() {\n                 Some(ty)\n             } else {\n                 None\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n     #[inline]\n     pub fn regions(&'a self) -> impl DoubleEndedIterator<Item = ty::Region<'tcx>> + 'a {\n         self.iter().filter_map(|k| {\n-            if let UnpackedKind::Lifetime(lt) = k.unpack() {\n+            if let GenericArgKind::Lifetime(lt) = k.unpack() {\n                 Some(lt)\n             } else {\n                 None\n@@ -309,7 +309,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n     #[inline]\n     pub fn consts(&'a self) -> impl DoubleEndedIterator<Item = &'tcx ty::Const<'tcx>> + 'a {\n         self.iter().filter_map(|k| {\n-            if let UnpackedKind::Const(ct) = k.unpack() {\n+            if let GenericArgKind::Const(ct) = k.unpack() {\n                 Some(ct)\n             } else {\n                 None\n@@ -320,18 +320,18 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n     #[inline]\n     pub fn non_erasable_generics(\n         &'a self\n-    ) -> impl DoubleEndedIterator<Item = UnpackedKind<'tcx>> + 'a {\n+    ) -> impl DoubleEndedIterator<Item = GenericArgKind<'tcx>> + 'a {\n         self.iter().filter_map(|k| {\n             match k.unpack() {\n-                UnpackedKind::Lifetime(_) => None,\n+                GenericArgKind::Lifetime(_) => None,\n                 generic => Some(generic),\n             }\n         })\n     }\n \n     #[inline]\n     pub fn type_at(&self, i: usize) -> Ty<'tcx> {\n-        if let UnpackedKind::Type(ty) = self[i].unpack() {\n+        if let GenericArgKind::Type(ty) = self[i].unpack() {\n             ty\n         } else {\n             bug!(\"expected type for param #{} in {:?}\", i, self);\n@@ -340,7 +340,7 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n \n     #[inline]\n     pub fn region_at(&self, i: usize) -> ty::Region<'tcx> {\n-        if let UnpackedKind::Lifetime(lt) = self[i].unpack() {\n+        if let GenericArgKind::Lifetime(lt) = self[i].unpack() {\n             lt\n         } else {\n             bug!(\"expected region for param #{} in {:?}\", i, self);\n@@ -349,15 +349,15 @@ impl<'a, 'tcx> InternalSubsts<'tcx> {\n \n     #[inline]\n     pub fn const_at(&self, i: usize) -> &'tcx ty::Const<'tcx> {\n-        if let UnpackedKind::Const(ct) = self[i].unpack() {\n+        if let GenericArgKind::Const(ct) = self[i].unpack() {\n             ct\n         } else {\n             bug!(\"expected const for param #{} in {:?}\", i, self);\n         }\n     }\n \n     #[inline]\n-    pub fn type_for_def(&self, def: &ty::GenericParamDef) -> Kind<'tcx> {\n+    pub fn type_for_def(&self, def: &ty::GenericParamDef) -> GenericArg<'tcx> {\n         self.type_at(def.index as usize).into()\n     }\n \n@@ -409,15 +409,25 @@ impl<'tcx> rustc_serialize::UseSpecializedDecodable for SubstsRef<'tcx> {}\n // there is more information available (for better errors).\n \n pub trait Subst<'tcx>: Sized {\n-    fn subst(&self, tcx: TyCtxt<'tcx>, substs: &[Kind<'tcx>]) -> Self {\n+    fn subst(&self, tcx: TyCtxt<'tcx>, substs: &[GenericArg<'tcx>]) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n-    fn subst_spanned(&self, tcx: TyCtxt<'tcx>, substs: &[Kind<'tcx>], span: Option<Span>) -> Self;\n+    fn subst_spanned(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        substs: &[GenericArg<'tcx>],\n+        span: Option<Span>,\n+    ) -> Self;\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for T {\n-    fn subst_spanned(&self, tcx: TyCtxt<'tcx>, substs: &[Kind<'tcx>], span: Option<Span>) -> T {\n+    fn subst_spanned(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        substs: &[GenericArg<'tcx>],\n+        span: Option<Span>,\n+    ) -> T {\n         let mut folder = SubstFolder { tcx,\n                                        substs,\n                                        span,\n@@ -433,7 +443,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for T {\n \n struct SubstFolder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    substs: &'a [Kind<'tcx>],\n+    substs: &'a [GenericArg<'tcx>],\n \n     /// The location for which the substitution is performed, if available.\n     span: Option<Span>,\n@@ -468,7 +478,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n             ty::ReEarlyBound(data) => {\n                 let rk = self.substs.get(data.index as usize).map(|k| k.unpack());\n                 match rk {\n-                    Some(UnpackedKind::Lifetime(lt)) => {\n+                    Some(GenericArgKind::Lifetime(lt)) => {\n                         self.shift_region_through_binders(lt)\n                     }\n                     _ => {\n@@ -537,7 +547,7 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n         let opt_ty = self.substs.get(p.index as usize).map(|k| k.unpack());\n         let ty = match opt_ty {\n-            Some(UnpackedKind::Type(ty)) => ty,\n+            Some(GenericArgKind::Type(ty)) => ty,\n             Some(kind) => {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n                 span_bug!(\n@@ -578,7 +588,7 @@ impl<'a, 'tcx> SubstFolder<'a, 'tcx> {\n         // Look up the const in the substitutions. It really should be in there.\n         let opt_ct = self.substs.get(p.index as usize).map(|k| k.unpack());\n         let ct = match opt_ct {\n-            Some(UnpackedKind::Const(ct)) => ct,\n+            Some(GenericArgKind::Const(ct)) => ct,\n             Some(kind) => {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n                 span_bug!("}, {"sha": "c4d8e452441cb71bf749a8cb63df40441da2c930", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -8,7 +8,7 @@ use crate::mir::interpret::{sign_extend, truncate};\n use crate::ich::NodeIdHashingMode;\n use crate::traits::{self, ObligationCause};\n use crate::ty::{self, DefIdTree, Ty, TyCtxt, GenericParamDefKind, TypeFoldable};\n-use crate::ty::subst::{Subst, InternalSubsts, SubstsRef, UnpackedKind};\n+use crate::ty::subst::{Subst, InternalSubsts, SubstsRef, GenericArgKind};\n use crate::ty::query::TyCtxtAt;\n use crate::ty::TyKind::*;\n use crate::ty::layout::{Integer, IntegerExt};\n@@ -510,7 +510,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// destructor of `def` itself. For the destructors of the\n     /// contents, you need `adt_dtorck_constraint`.\n     pub fn destructor_constraints(self, def: &'tcx ty::AdtDef)\n-                                  -> Vec<ty::subst::Kind<'tcx>>\n+                                  -> Vec<ty::subst::GenericArg<'tcx>>\n     {\n         let dtor = match def.destructor(self) {\n             None => {\n@@ -557,23 +557,23 @@ impl<'tcx> TyCtxt<'tcx> {\n         let result = item_substs.iter().zip(impl_substs.iter())\n             .filter(|&(_, &k)| {\n                 match k.unpack() {\n-                    UnpackedKind::Lifetime(&ty::RegionKind::ReEarlyBound(ref ebr)) => {\n+                    GenericArgKind::Lifetime(&ty::RegionKind::ReEarlyBound(ref ebr)) => {\n                         !impl_generics.region_param(ebr, self).pure_wrt_drop\n                     }\n-                    UnpackedKind::Type(&ty::TyS {\n+                    GenericArgKind::Type(&ty::TyS {\n                         kind: ty::Param(ref pt), ..\n                     }) => {\n                         !impl_generics.type_param(pt, self).pure_wrt_drop\n                     }\n-                    UnpackedKind::Const(&ty::Const {\n+                    GenericArgKind::Const(&ty::Const {\n                         val: ConstValue::Param(ref pc),\n                         ..\n                     }) => {\n                         !impl_generics.const_param(pc, self).pure_wrt_drop\n                     }\n-                    UnpackedKind::Lifetime(_) |\n-                    UnpackedKind::Type(_) |\n-                    UnpackedKind::Const(_) => {\n+                    GenericArgKind::Lifetime(_) |\n+                    GenericArgKind::Type(_) |\n+                    GenericArgKind::Const(_) => {\n                         // Not a type, const or region param: this should be reported\n                         // as an error.\n                         false"}, {"sha": "71a6067fd48a14f89f8d58fb67bcc80aa084d398", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -324,15 +324,15 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         use syntax::ast::UintTy::*;\n         use rustc::ty::{Int, Uint};\n \n-        let new_sty = match ty.kind {\n+        let new_kind = match ty.kind {\n             Int(Isize) => Int(self.tcx.sess.target.isize_ty),\n             Uint(Usize) => Uint(self.tcx.sess.target.usize_ty),\n             ref t @ Uint(_) | ref t @ Int(_) => t.clone(),\n             _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\")\n         };\n \n         let name = match oop {\n-            OverflowOp::Add => match new_sty {\n+            OverflowOp::Add => match new_kind {\n                 Int(I8) => \"llvm.sadd.with.overflow.i8\",\n                 Int(I16) => \"llvm.sadd.with.overflow.i16\",\n                 Int(I32) => \"llvm.sadd.with.overflow.i32\",\n@@ -347,7 +347,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n                 _ => unreachable!(),\n             },\n-            OverflowOp::Sub => match new_sty {\n+            OverflowOp::Sub => match new_kind {\n                 Int(I8) => \"llvm.ssub.with.overflow.i8\",\n                 Int(I16) => \"llvm.ssub.with.overflow.i16\",\n                 Int(I32) => \"llvm.ssub.with.overflow.i32\",\n@@ -362,7 +362,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n                 _ => unreachable!(),\n             },\n-            OverflowOp::Mul => match new_sty {\n+            OverflowOp::Mul => match new_kind {\n                 Int(I8) => \"llvm.smul.with.overflow.i8\",\n                 Int(I16) => \"llvm.smul.with.overflow.i16\",\n                 Int(I32) => \"llvm.smul.with.overflow.i32\","}, {"sha": "1696e56c01eff9953402fffedbb4daf61b6395b8", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -30,7 +30,7 @@ use rustc::ty::Instance;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, Integer, IntegerExt, LayoutOf,\n                         PrimitiveExt, Size, TyLayout, VariantIdx};\n-use rustc::ty::subst::UnpackedKind;\n+use rustc::ty::subst::GenericArgKind;\n use rustc::session::config::{self, DebugInfo};\n use rustc::util::nodemap::FxHashMap;\n use rustc_fs_util::path_to_c_string;\n@@ -2096,7 +2096,7 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'\n             let generics = cx.tcx.generics_of(def.did);\n             let names = get_parameter_names(cx, generics);\n             let template_params: Vec<_> = substs.iter().zip(names).filter_map(|(kind, name)| {\n-                if let UnpackedKind::Type(ty) = kind.unpack() {\n+                if let GenericArgKind::Type(ty) = kind.unpack() {\n                     let actual_type = cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n                     let actual_type_metadata =\n                         type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);"}, {"sha": "4efa1993d432273476bffdee22109b491ac18acb", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -15,7 +15,7 @@ use crate::llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilder, DISubprogram, D\n     DISPFlags, DILexicalBlock};\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n-use rustc::ty::subst::{SubstsRef, UnpackedKind};\n+use rustc::ty::subst::{SubstsRef, GenericArgKind};\n \n use crate::abi::Abi;\n use crate::common::CodegenCx;\n@@ -460,7 +460,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             let template_params: Vec<_> = if cx.sess().opts.debuginfo == DebugInfo::Full {\n                 let names = get_parameter_names(cx, generics);\n                 substs.iter().zip(names).filter_map(|(kind, name)| {\n-                    if let UnpackedKind::Type(ty) = kind.unpack() {\n+                    if let GenericArgKind::Type(ty) = kind.unpack() {\n                         let actual_type =\n                             cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n                         let actual_type_metadata ="}, {"sha": "277aa2db33a1bcc09162538af605e852a128ef3a", "filename": "src/librustc_codegen_utils/symbol_names/legacy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Flegacy.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -3,7 +3,7 @@ use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n use rustc::ich::NodeIdHashingMode;\n use rustc::mir::interpret::{ConstValue, Scalar};\n use rustc::ty::print::{PrettyPrinter, Printer, Print};\n-use rustc::ty::subst::{Kind, UnpackedKind};\n+use rustc::ty::subst::{GenericArg, GenericArgKind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Instance};\n use rustc::util::common::record_time;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -341,13 +341,13 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n     fn path_generic_args(\n         mut self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        args: &[Kind<'tcx>],\n+        args: &[GenericArg<'tcx>],\n     )  -> Result<Self::Path, Self::Error> {\n         self = print_prefix(self)?;\n \n         let args = args.iter().cloned().filter(|arg| {\n             match arg.unpack() {\n-                UnpackedKind::Lifetime(_) => false,\n+                GenericArgKind::Lifetime(_) => false,\n                 _ => true,\n             }\n         });"}, {"sha": "a63236305dc11f30f74ef67d1aea11ffcc10ed85", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -3,7 +3,7 @@ use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Instance};\n use rustc::ty::print::{Printer, Print};\n-use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n+use rustc::ty::subst::{GenericArg, Subst, GenericArgKind};\n use rustc_data_structures::base_n;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_target::spec::abi::Abi;\n@@ -56,7 +56,7 @@ struct CompressionCaches<'tcx> {\n     start_offset: usize,\n \n     // The values are start positions in `out`, in bytes.\n-    paths: FxHashMap<(DefId, &'tcx [Kind<'tcx>]), usize>,\n+    paths: FxHashMap<(DefId, &'tcx [GenericArg<'tcx>]), usize>,\n     types: FxHashMap<Ty<'tcx>, usize>,\n     consts: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n }\n@@ -234,7 +234,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n     fn print_def_path(\n         mut self,\n         def_id: DefId,\n-        substs: &'tcx [Kind<'tcx>],\n+        substs: &'tcx [GenericArg<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         if let Some(&i) = self.compress.as_ref().and_then(|c| c.paths.get(&(def_id, substs))) {\n             return self.print_backref(i);\n@@ -256,7 +256,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n     fn print_impl_path(\n         self,\n         impl_def_id: DefId,\n-        substs: &'tcx [Kind<'tcx>],\n+        substs: &'tcx [GenericArg<'tcx>],\n         mut self_ty: Ty<'tcx>,\n         mut impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n@@ -619,18 +619,18 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n     fn path_generic_args(\n         mut self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        args: &[Kind<'tcx>],\n+        args: &[GenericArg<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         // Don't print any regions if they're all erased.\n         let print_regions = args.iter().any(|arg| {\n             match arg.unpack() {\n-                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                GenericArgKind::Lifetime(r) => *r != ty::ReErased,\n                 _ => false,\n             }\n         });\n         let args = args.iter().cloned().filter(|arg| {\n             match arg.unpack() {\n-                UnpackedKind::Lifetime(_) => print_regions,\n+                GenericArgKind::Lifetime(_) => print_regions,\n                 _ => true,\n             }\n         });\n@@ -643,13 +643,13 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         self = print_prefix(self)?;\n         for arg in args {\n             match arg.unpack() {\n-                UnpackedKind::Lifetime(lt) => {\n+                GenericArgKind::Lifetime(lt) => {\n                     self = lt.print(self)?;\n                 }\n-                UnpackedKind::Type(ty) => {\n+                GenericArgKind::Type(ty) => {\n                     self = ty.print(self)?;\n                 }\n-                UnpackedKind::Const(c) => {\n+                GenericArgKind::Const(c) => {\n                     self.push(\"K\");\n                     // FIXME(const_generics) implement `ty::print::Print` on `ty::Const`.\n                     // self = c.print(self)?;"}, {"sha": "90e5480d2fb79704a52d5444f006eb4a419716e6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -12,7 +12,7 @@ use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::mir::Body;\n-use rustc::ty::subst::{SubstsRef, UnpackedKind};\n+use rustc::ty::subst::{SubstsRef, GenericArgKind};\n use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n use rustc::ty::print::RegionHighlightMode;\n use rustc_errors::DiagnosticBuilder;\n@@ -667,24 +667,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<&'hir hir::Lifetime> {\n         for (kind, hir_arg) in substs.iter().zip(&args.args) {\n             match (kind.unpack(), hir_arg) {\n-                (UnpackedKind::Lifetime(r), hir::GenericArg::Lifetime(lt)) => {\n+                (GenericArgKind::Lifetime(r), hir::GenericArg::Lifetime(lt)) => {\n                     if r.to_region_vid() == needle_fr {\n                         return Some(lt);\n                     }\n                 }\n \n-                (UnpackedKind::Type(ty), hir::GenericArg::Type(hir_ty)) => {\n+                (GenericArgKind::Type(ty), hir::GenericArg::Type(hir_ty)) => {\n                     search_stack.push((ty, hir_ty));\n                 }\n \n-                (UnpackedKind::Const(_ct), hir::GenericArg::Const(_hir_ct)) => {\n+                (GenericArgKind::Const(_ct), hir::GenericArg::Const(_hir_ct)) => {\n                     // Lifetimes cannot be found in consts, so we don't need\n                     // to search anything here.\n                 }\n \n-                (UnpackedKind::Lifetime(_), _)\n-                | (UnpackedKind::Type(_), _)\n-                | (UnpackedKind::Const(_), _) => {\n+                (GenericArgKind::Lifetime(_), _)\n+                | (GenericArgKind::Type(_), _)\n+                | (GenericArgKind::Const(_), _) => {\n                     // I *think* that HIR lowering should ensure this\n                     // doesn't happen, even in erroneous\n                     // programs. Else we should use delay-span-bug."}, {"sha": "c88f1cac350401f045e2ed655bb54c9c89272ec3", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -10,7 +10,7 @@ use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n use rustc::infer::{self, InferCtxt, SubregionOrigin};\n use rustc::mir::ConstraintCategory;\n-use rustc::ty::subst::UnpackedKind;\n+use rustc::ty::subst::GenericArgKind;\n use rustc::ty::{self, TyCtxt};\n use syntax_pos::DUMMY_SP;\n \n@@ -101,13 +101,13 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             });\n \n         match k1.unpack() {\n-            UnpackedKind::Lifetime(r1) => {\n+            GenericArgKind::Lifetime(r1) => {\n                 let r1_vid = self.to_region_vid(r1);\n                 let r2_vid = self.to_region_vid(r2);\n                 self.add_outlives(r1_vid, r2_vid);\n             }\n \n-            UnpackedKind::Type(t1) => {\n+            GenericArgKind::Type(t1) => {\n                 // we don't actually use this for anything, but\n                 // the `TypeOutlives` code needs an origin.\n                 let origin = infer::RelateParamBound(DUMMY_SP, t1);\n@@ -121,7 +121,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n                 ).type_must_outlive(origin, t1, r2);\n             }\n \n-            UnpackedKind::Const(_) => {\n+            GenericArgKind::Const(_) => {\n                 // Consts cannot outlive one another, so we\n                 // don't need to handle any relations here.\n             }"}, {"sha": "e37ddbda4be02ef69947f343b76f965af83fe571", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/polonius.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpolonius.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -4,7 +4,7 @@ use crate::dataflow::move_paths::{LookupResult, MoveData};\n use crate::util::liveness::{categorize, DefUse};\n use rustc::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n use rustc::mir::{Body, Local, Location, Place};\n-use rustc::ty::subst::Kind;\n+use rustc::ty::subst::GenericArg;\n use rustc::ty::Ty;\n \n use super::TypeChecker;\n@@ -125,7 +125,7 @@ pub(super) fn populate_access_facts(\n pub(super) fn add_var_drops_regions(\n     typeck: &mut TypeChecker<'_, 'tcx>,\n     local: Local,\n-    kind: &Kind<'tcx>,\n+    kind: &GenericArg<'tcx>,\n ) {\n     debug!(\"add_var_drops_region(local={:?}, kind={:?}\", local, kind);\n     let tcx = typeck.tcx();"}, {"sha": "e3e509799c936cba33b09e62b9772b335cad8483", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -36,7 +36,7 @@ use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{self, ObligationCause, PredicateObligations};\n use rustc::ty::adjustment::{PointerCast};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::{Subst, SubstsRef, UnpackedKind, UserSubsts};\n+use rustc::ty::subst::{Subst, SubstsRef, GenericArgKind, UserSubsts};\n use rustc::ty::{\n     self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, UserType,\n     CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n@@ -2575,7 +2575,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         });\n \n                     match k1.unpack() {\n-                        UnpackedKind::Lifetime(r1) => {\n+                        GenericArgKind::Lifetime(r1) => {\n                             // constraint is r1: r2\n                             let r1_vid = self.borrowck_context.universal_regions.to_region_vid(r1);\n                             let r2_vid = self.borrowck_context.universal_regions.to_region_vid(r2);\n@@ -2589,7 +2589,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 ),\n                             ))\n                         }\n-                        UnpackedKind::Type(_) | UnpackedKind::Const(_) => None,\n+                        GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n                     }\n                 })\n                 .collect();"}, {"sha": "676827d3b3eba44a5041ba960b466d2b4acf5232", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -12,7 +12,7 @@ use rustc::middle::region;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::subst::{Kind, InternalSubsts};\n+use rustc::ty::subst::{GenericArg, InternalSubsts};\n use rustc::ty::layout::VariantIdx;\n use syntax::ast;\n use syntax::attr;\n@@ -169,7 +169,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n                         trait_def_id: DefId,\n                         method_name: Symbol,\n                         self_ty: Ty<'tcx>,\n-                        params: &[Kind<'tcx>])\n+                        params: &[GenericArg<'tcx>])\n                         -> &'tcx ty::Const<'tcx> {\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {"}, {"sha": "e42f6125f21d9ccd7855358f90e516bc79cdaee4", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::interpret::{GlobalId, ConstValue, sign_extend, AllocId, Pointer}\n use rustc::traits::{ObligationCause, PredicateObligation};\n use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, UserType, DefIdTree};\n use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations};\n-use rustc::ty::subst::{SubstsRef, Kind};\n+use rustc::ty::subst::{SubstsRef, GenericArg};\n use rustc::ty::layout::{VariantIdx, Size};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{CtorOf, Res, DefKind, CtorKind};\n@@ -1357,7 +1357,7 @@ macro_rules! CloneImpls {\n CloneImpls!{ <'tcx>\n     Span, Field, Mutability, ast::Name, hir::HirId, usize, ty::Const<'tcx>,\n     Region<'tcx>, Ty<'tcx>, BindingMode, &'tcx AdtDef,\n-    SubstsRef<'tcx>, &'tcx Kind<'tcx>, UserType<'tcx>,\n+    SubstsRef<'tcx>, &'tcx GenericArg<'tcx>, UserType<'tcx>,\n     UserTypeProjection, PatternTypeProjection<'tcx>\n }\n "}, {"sha": "a8b4d65e7d4b02e3f5a1ade8075db360f8a5768f", "filename": "src/librustc_mir/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -1,6 +1,6 @@\n use rustc::ty::{\n     TyCtxt, Ty,\n-    subst::{UnpackedKind, Kind},\n+    subst::{GenericArgKind, GenericArg},\n     print::{Printer, PrettyPrinter, Print},\n     self,\n };\n@@ -156,12 +156,12 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n     fn path_generic_args(\n         mut self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-        args: &[Kind<'tcx>],\n+        args: &[GenericArg<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n         self = print_prefix(self)?;\n         let args = args.iter().cloned().filter(|arg| {\n             match arg.unpack() {\n-                UnpackedKind::Lifetime(_) => false,\n+                GenericArgKind::Lifetime(_) => false,\n                 _ => true,\n             }\n         });"}, {"sha": "06c1df70287c9dfd5337318db5f527e0662f9405", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -36,7 +36,7 @@ use rustc::traits::{\n use rustc::ty::{self, TyCtxt, InferConst};\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::{Kind, UnpackedKind};\n+use rustc::ty::subst::{GenericArg, GenericArgKind};\n use rustc::mir::interpret::ConstValue;\n use syntax_pos::DUMMY_SP;\n \n@@ -64,7 +64,7 @@ crate struct ChalkInferenceContext<'cx, 'tcx> {\n #[derive(Copy, Clone, Debug)]\n crate struct UniverseMap;\n \n-crate type RegionConstraint<'tcx> = ty::OutlivesPredicate<Kind<'tcx>, ty::Region<'tcx>>;\n+crate type RegionConstraint<'tcx> = ty::OutlivesPredicate<GenericArg<'tcx>, ty::Region<'tcx>>;\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n crate struct ConstrainedSubst<'tcx> {\n@@ -109,7 +109,7 @@ impl context::Context for ChalkArenas<'tcx> {\n \n     type BindersGoal = ty::Binder<Goal<'tcx>>;\n \n-    type Parameter = Kind<'tcx>;\n+    type Parameter = GenericArg<'tcx>;\n \n     type ProgramClause = Clause<'tcx>;\n \n@@ -271,21 +271,21 @@ impl context::ContextOps<ChalkArenas<'tcx>> for ChalkContext<'tcx> {\n         subst.var_values\n             .iter_enumerated()\n             .all(|(cvar, kind)| match kind.unpack() {\n-                UnpackedKind::Lifetime(r) => match r {\n+                GenericArgKind::Lifetime(r) => match r {\n                     &ty::ReLateBound(debruijn, br) => {\n                         debug_assert_eq!(debruijn, ty::INNERMOST);\n                         cvar == br.assert_bound_var()\n                     }\n                     _ => false,\n                 },\n-                UnpackedKind::Type(ty) => match ty.kind {\n+                GenericArgKind::Type(ty) => match ty.kind {\n                     ty::Bound(debruijn, bound_ty) => {\n                         debug_assert_eq!(debruijn, ty::INNERMOST);\n                         cvar == bound_ty.var\n                     }\n                     _ => false,\n                 },\n-                UnpackedKind::Const(ct) => match ct.val {\n+                GenericArgKind::Const(ct) => match ct.val {\n                     ConstValue::Infer(InferConst::Canonical(debruijn, bound_ct)) => {\n                         debug_assert_eq!(debruijn, ty::INNERMOST);\n                         cvar == bound_ct\n@@ -454,8 +454,8 @@ impl context::UnificationOps<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n         &mut self,\n         environment: &Environment<'tcx>,\n         variance: ty::Variance,\n-        a: &Kind<'tcx>,\n-        b: &Kind<'tcx>,\n+        a: &GenericArg<'tcx>,\n+        b: &GenericArg<'tcx>,\n     ) -> Fallible<UnificationResult<'tcx>> {\n         self.infcx.commit_if_ok(|_| {\n             unify(self.infcx, *environment, variance, a, b)"}, {"sha": "6790f14f69bbd0cd8584dbc3d1770fb793ad7f5a", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -5,7 +5,7 @@ use rustc::traits::{\n     ProgramClauseCategory,\n };\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::subst::{Kind, InternalSubsts, Subst};\n+use rustc::ty::subst::{GenericArg, InternalSubsts, Subst};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use crate::lowering::Lower;\n@@ -17,7 +17,7 @@ use crate::generic_types;\n fn builtin_impl_clause(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n-    nested: &[Kind<'tcx>],\n+    nested: &[GenericArg<'tcx>],\n     trait_def_id: DefId,\n ) -> ProgramClause<'tcx> {\n     ProgramClause {\n@@ -124,7 +124,7 @@ crate fn assemble_builtin_sized_impls<'tcx>(\n     ty: Ty<'tcx>,\n     clauses: &mut Vec<Clause<'tcx>>,\n ) {\n-    let mut push_builtin_impl = |ty: Ty<'tcx>, nested: &[Kind<'tcx>]| {\n+    let mut push_builtin_impl = |ty: Ty<'tcx>, nested: &[GenericArg<'tcx>]| {\n         let clause = builtin_impl_clause(tcx, ty, nested, sized_def_id);\n         // Bind innermost bound vars that may exist in `ty` and `nested`.\n         clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n@@ -185,7 +185,7 @@ crate fn assemble_builtin_sized_impls<'tcx>(\n             let adt = tcx.mk_ty(ty::Adt(adt_def, substs));\n             let sized_constraint = adt_def.sized_constraint(tcx)\n                 .iter()\n-                .map(|ty| Kind::from(ty.subst(tcx, substs)))\n+                .map(|ty| GenericArg::from(ty.subst(tcx, substs)))\n                 .collect::<Vec<_>>();\n             push_builtin_impl(adt, &sized_constraint);\n         }\n@@ -228,7 +228,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n     ty: Ty<'tcx>,\n     clauses: &mut Vec<Clause<'tcx>>,\n ) {\n-    let mut push_builtin_impl = |ty: Ty<'tcx>, nested: &[Kind<'tcx>]| {\n+    let mut push_builtin_impl = |ty: Ty<'tcx>, nested: &[GenericArg<'tcx>]| {\n         let clause = builtin_impl_clause(tcx, ty, nested, trait_def_id);\n         // Bind innermost bound vars that may exist in `ty` and `nested`.\n         clauses.push(Clause::ForAll(ty::Binder::bind(clause)));\n@@ -255,7 +255,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n             let element_ty = generic_types::bound(tcx, 0);\n             push_builtin_impl(\n                 tcx.mk_ty(ty::Array(element_ty, length)),\n-                &[Kind::from(element_ty)],\n+                &[GenericArg::from(element_ty)],\n             );\n         }\n         &ty::Tuple(type_list) => {\n@@ -266,7 +266,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n             let closure_ty = generic_types::closure(tcx, def_id);\n             let upvar_tys: Vec<_> = match &closure_ty.kind {\n                 ty::Closure(_, substs) => {\n-                    substs.upvar_tys(def_id, tcx).map(|ty| Kind::from(ty)).collect()\n+                    substs.upvar_tys(def_id, tcx).map(|ty| GenericArg::from(ty)).collect()\n                 },\n                 _ => bug!(),\n             };"}, {"sha": "8facec1e9e35f54328dc81c633c940af0838df97", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -17,7 +17,7 @@ use rustc::traits::{\n     InEnvironment,\n };\n use rustc::ty::{self, Ty, TyCtxt, InferConst};\n-use rustc::ty::subst::Kind;\n+use rustc::ty::subst::GenericArg;\n use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc::mir::interpret::ConstValue;\n use syntax_pos::DUMMY_SP;\n@@ -151,7 +151,7 @@ impl AnswerSubstitutor<'cx, 'tcx> {\n     fn unify_free_answer_var(\n         &mut self,\n         answer_var: ty::BoundVar,\n-        pending: Kind<'tcx>\n+        pending: GenericArg<'tcx>\n     ) -> RelateResult<'tcx, ()> {\n         let answer_param = &self.answer_subst.var_values[answer_var];\n         let pending = &ty::fold::shift_out_vars("}, {"sha": "e4d15a35137cc127822913d4f385ecc520595072", "filename": "src/librustc_traits/generic_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_traits%2Fgeneric_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_traits%2Fgeneric_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fgeneric_types.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -1,7 +1,7 @@\n //! Utilities for creating generic types with bound vars in place of parameter values.\n \n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::subst::{Kind, SubstsRef, InternalSubsts};\n+use rustc::ty::subst::{GenericArg, SubstsRef, InternalSubsts};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc_target::spec::abi;\n@@ -49,7 +49,7 @@ crate fn type_list(tcx: TyCtxt<'tcx>, arity: usize) -> SubstsRef<'tcx> {\n         (0..arity).into_iter()\n             .map(|i| ty::BoundVar::from(i))\n             .map(|var| tcx.mk_ty(ty::Bound(ty::INNERMOST, var.into())))\n-            .map(|ty| Kind::from(ty))\n+            .map(|ty| GenericArg::from(ty))\n     )\n }\n "}, {"sha": "fa36908a1612bf259a8995c15e5fad49185efae0", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -13,7 +13,7 @@ use rustc::traits::{\n     Normalized, Obligation, ObligationCause, TraitEngine, TraitEngineExt,\n };\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::{Kind, Subst, UserSubsts, UserSelfTy};\n+use rustc::ty::subst::{GenericArg, Subst, UserSubsts, UserSelfTy};\n use rustc::ty::{\n     FnSig, Lift, ParamEnv, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable, Variance,\n };\n@@ -98,7 +98,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn subst<T>(&self, value: T, substs: &[Kind<'tcx>]) -> T\n+    fn subst<T>(&self, value: T, substs: &[GenericArg<'tcx>]) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "339045a4bad8e7d828a464d5e4db7663aa3d58db", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -16,7 +16,7 @@ use rustc::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n use rustc::traits;\n use rustc::ty::{self, DefIdTree, Ty, TyCtxt, Const, ToPredicate, TypeFoldable};\n use rustc::ty::{GenericParamDef, GenericParamDefKind};\n-use rustc::ty::subst::{Kind, Subst, InternalSubsts, SubstsRef};\n+use rustc::ty::subst::{self, Subst, InternalSubsts, SubstsRef};\n use rustc::ty::wf::object_region_bounds;\n use rustc::mir::interpret::ConstValue;\n use rustc_target::spec::abi;\n@@ -465,18 +465,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ///   `[T]`. The boolean value indicates whether to infer values\n     ///   for arguments whose values were not explicitly provided.\n     /// - `provided_kind`: given the generic parameter and the value from `args_for_def_id`,\n-    ///   instantiate a `Kind`.\n+    ///   instantiate a `GenericArg`.\n     /// - `inferred_kind`: if no parameter was provided, and inference is enabled, then\n     ///   creates a suitable inference variable.\n     pub fn create_substs_for_generic_args<'b>(\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n-        parent_substs: &[Kind<'tcx>],\n+        parent_substs: &[subst::GenericArg<'tcx>],\n         has_self: bool,\n         self_ty: Option<Ty<'tcx>>,\n         args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs>, bool),\n-        provided_kind: impl Fn(&GenericParamDef, &GenericArg) -> Kind<'tcx>,\n-        inferred_kind: impl Fn(Option<&[Kind<'tcx>]>, &GenericParamDef, bool) -> Kind<'tcx>,\n+        provided_kind: impl Fn(&GenericParamDef, &GenericArg) -> subst::GenericArg<'tcx>,\n+        inferred_kind: impl Fn(Option<&[subst::GenericArg<'tcx>]>, &GenericParamDef, bool)\n+            -> subst::GenericArg<'tcx>,\n     ) -> SubstsRef<'tcx> {\n         // Collect the segments of the path; we need to substitute arguments\n         // for parameters throughout the entire path (wherever there are\n@@ -492,7 +493,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // We manually build up the substitution, rather than using convenience\n         // methods in `subst.rs`, so that we can iterate over the arguments and\n         // parameters in lock-step linearly, instead of trying to match each pair.\n-        let mut substs: SmallVec<[Kind<'tcx>; 8]> = SmallVec::with_capacity(count);\n+        let mut substs: SmallVec<[subst::GenericArg<'tcx>; 8]> = SmallVec::with_capacity(count);\n \n         // Iterate over each segment of the path.\n         while let Some((def_id, defs)) = stack.pop() {"}, {"sha": "cb03af46f3dbb585c4c6155ad3eccd77c275021c", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -6,7 +6,7 @@ use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::{self, InferOk, SuppressRegionErrors};\n use rustc::middle::region;\n use rustc::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n-use rustc::ty::subst::{Subst, SubstsRef, UnpackedKind};\n+use rustc::ty::subst::{Subst, SubstsRef, GenericArgKind};\n use rustc::ty::{self, Ty, TyCtxt};\n use crate::util::common::ErrorReported;\n \n@@ -308,9 +308,9 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(\n     let kinds = rcx.fcx.register_infer_ok_obligations(infer_ok);\n     for kind in kinds {\n         match kind.unpack() {\n-            UnpackedKind::Lifetime(r) => rcx.sub_regions(origin(), parent_scope, r),\n-            UnpackedKind::Type(ty) => rcx.type_must_outlive(origin(), ty, parent_scope),\n-            UnpackedKind::Const(_) => {\n+            GenericArgKind::Lifetime(r) => rcx.sub_regions(origin(), parent_scope, r),\n+            GenericArgKind::Type(ty) => rcx.type_must_outlive(origin(), ty, parent_scope),\n+            GenericArgKind::Const(_) => {\n                 // Generic consts don't add constraints.\n             }\n         }"}, {"sha": "c1eb65ee956ae05bcab80acd2f8df450dc077e74", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -116,7 +116,9 @@ use rustc::ty::adjustment::{\n };\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::{UnpackedKind, Subst, InternalSubsts, SubstsRef, UserSelfTy, UserSubsts};\n+use rustc::ty::subst::{\n+    GenericArgKind, Subst, InternalSubsts, SubstsRef, UserSelfTy, UserSubsts,\n+};\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n use rustc::ty::layout::VariantIdx;\n use syntax_pos::{self, BytePos, Span, MultiSpan};\n@@ -2213,7 +2215,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n \n     fn ty_infer(&self, param: Option<&ty::GenericParamDef>, span: Span) -> Ty<'tcx> {\n         if let Some(param) = param {\n-            if let UnpackedKind::Type(ty) = self.var_for_def(span, param).unpack() {\n+            if let GenericArgKind::Type(ty) = self.var_for_def(span, param).unpack() {\n                 return ty;\n             }\n             unreachable!()\n@@ -2232,7 +2234,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         span: Span,\n     ) -> &'tcx Const<'tcx> {\n         if let Some(param) = param {\n-            if let UnpackedKind::Const(ct) = self.var_for_def(span, param).unpack() {\n+            if let GenericArgKind::Const(ct) = self.var_for_def(span, param).unpack() {\n                 return ct;\n             }\n             unreachable!()"}, {"sha": "b20b5bb8dc3a2d912abd9c4c4453401d27ae34ed", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -8,7 +8,7 @@ use rustc::hir::ptr::P;\n use rustc::infer;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::ty::{self, Ty, BindingMode, TypeFoldable};\n-use rustc::ty::subst::Kind;\n+use rustc::ty::subst::GenericArg;\n use syntax::ast;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n@@ -797,7 +797,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let max_len = cmp::max(expected_len, elements.len());\n \n         let element_tys_iter = (0..max_len).map(|_| {\n-            Kind::from(self.next_ty_var(\n+            GenericArg::from(self.next_ty_var(\n                 // FIXME: `MiscVariable` for now -- obtaining the span and name information\n                 // from all tuple elements isn't trivial.\n                 TypeVariableOrigin {"}, {"sha": "23280542c2b190f34a9d43c516ec210bbddb6cfa", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -81,7 +81,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::{self, RegionObligation, SuppressRegionErrors};\n use rustc::ty::adjustment;\n-use rustc::ty::subst::{SubstsRef, UnpackedKind};\n+use rustc::ty::subst::{SubstsRef, GenericArgKind};\n use rustc::ty::{self, Ty};\n \n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -1401,14 +1401,14 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n         for kind in substs {\n             match kind.unpack() {\n-                UnpackedKind::Lifetime(lt) => {\n+                GenericArgKind::Lifetime(lt) => {\n                     self.sub_regions(origin.clone(), expr_region, lt);\n                 }\n-                UnpackedKind::Type(ty) => {\n+                GenericArgKind::Type(ty) => {\n                     let ty = self.resolve_type(ty);\n                     self.type_must_outlive(origin.clone(), ty, expr_region);\n                 }\n-                UnpackedKind::Const(_) => {\n+                GenericArgKind::Const(_) => {\n                     // Const parameters don't impose constraints.\n                 }\n             }"}, {"sha": "5b0f32720464506164defa748e146d4ff5deda95", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -656,7 +656,7 @@ fn check_opaque_types<'fcx, 'tcx>(\n                         let mut seen: FxHashMap<_, Vec<_>> = FxHashMap::default();\n                         for (subst, param) in substs.iter().zip(&generics.params) {\n                             match subst.unpack() {\n-                                ty::subst::UnpackedKind::Type(ty) => match ty.kind {\n+                                ty::subst::GenericArgKind::Type(ty) => match ty.kind {\n                                     ty::Param(..) => {}\n                                     // Prevent `fn foo() -> Foo<u32>` from being defining.\n                                     _ => {\n@@ -678,7 +678,7 @@ fn check_opaque_types<'fcx, 'tcx>(\n                                     }\n                                 }\n \n-                                ty::subst::UnpackedKind::Lifetime(region) => {\n+                                ty::subst::GenericArgKind::Lifetime(region) => {\n                                     let param_span = tcx.def_span(param.def_id);\n                                     if let ty::ReStatic = region {\n                                         tcx\n@@ -700,7 +700,7 @@ fn check_opaque_types<'fcx, 'tcx>(\n                                     }\n                                 }\n \n-                                ty::subst::UnpackedKind::Const(ct) => match ct.val {\n+                                ty::subst::GenericArgKind::Const(ct) => match ct.val {\n                                     ConstValue::Param(_) => {}\n                                     _ => {\n                                         tcx.sess"}, {"sha": "82d55e0df599b93887b2b0d3589cab2d66c4712a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -25,7 +25,7 @@ use rustc::ty::query::Providers;\n use rustc::ty::subst::{Subst, InternalSubsts};\n use rustc::ty::util::Discr;\n use rustc::ty::util::IntTypeExt;\n-use rustc::ty::subst::UnpackedKind;\n+use rustc::ty::subst::GenericArgKind;\n use rustc::ty::{self, AdtKind, DefIdTree, ToPolyTraitRef, Ty, TyCtxt, Const};\n use rustc::ty::{ReprOptions, ToPredicate};\n use rustc::util::captures::Captures;\n@@ -1580,7 +1580,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 // Skipping binder is ok, since we only use this to find generic parameters and\n                 // their positions.\n                 for (idx, subst) in substs.iter().enumerate() {\n-                    if let UnpackedKind::Type(ty) = subst.unpack() {\n+                    if let GenericArgKind::Type(ty) = subst.unpack() {\n                         if let ty::Param(p) = ty.kind {\n                             if index_map.insert(p, idx).is_some() {\n                                 // There was already an entry for `p`, meaning a generic parameter"}, {"sha": "88091d0da0e49eec7486abe5de6535fdd8fb0861", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::{self, Node};\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n+use rustc::ty::subst::{GenericArg, Subst, GenericArgKind};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n \n@@ -253,7 +253,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n pub fn check_explicit_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n-    substs: &[Kind<'tcx>],\n+    substs: &[GenericArg<'tcx>],\n     required_predicates: &mut RequiredPredicates<'tcx>,\n     explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n     ignored_self_ty: Option<Ty<'tcx>>,\n@@ -310,7 +310,7 @@ pub fn check_explicit_predicates<'tcx>(\n         // binding) and thus infer an outlives requirement that `X:\n         // 'b`.\n         if let Some(self_ty) = ignored_self_ty {\n-            if let UnpackedKind::Type(ty) = outlives_predicate.0.unpack() {\n+            if let GenericArgKind::Type(ty) = outlives_predicate.0.unpack() {\n                 if ty.walk().any(|ty| ty == self_ty) {\n                     debug!(\"skipping self ty = {:?}\", &ty);\n                     continue;"}, {"sha": "59aac5c7ffd3f4635bcad0aa163544033fb44d8b", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -2,7 +2,7 @@ use hir::Node;\n use rustc::hir;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::UnpackedKind;\n+use rustc::ty::subst::GenericArgKind;\n use rustc::ty::{self, CratePredicatesMap, TyCtxt};\n use syntax::symbol::sym;\n \n@@ -100,17 +100,17 @@ fn inferred_outlives_crate(\n                 .iter()\n                 .filter_map(\n                     |ty::OutlivesPredicate(kind1, region2)| match kind1.unpack() {\n-                        UnpackedKind::Type(ty1) => {\n+                        GenericArgKind::Type(ty1) => {\n                             Some(ty::Predicate::TypeOutlives(ty::Binder::bind(\n                                 ty::OutlivesPredicate(ty1, region2)\n                             )))\n                         }\n-                        UnpackedKind::Lifetime(region1) => {\n+                        GenericArgKind::Lifetime(region1) => {\n                             Some(ty::Predicate::RegionOutlives(\n                                 ty::Binder::bind(ty::OutlivesPredicate(region1, region2))\n                             ))\n                         }\n-                        UnpackedKind::Const(_) => {\n+                        GenericArgKind::Const(_) => {\n                             // Generic consts don't impose any constraints.\n                             None\n                         }"}, {"sha": "d83c97b522c672ee9cad73efe62cb7d086d14319", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -1,18 +1,19 @@\n use rustc::ty::outlives::Component;\n-use rustc::ty::subst::{Kind, UnpackedKind};\n+use rustc::ty::subst::{GenericArg, GenericArgKind};\n use rustc::ty::{self, Region, RegionKind, Ty, TyCtxt};\n use smallvec::smallvec;\n use std::collections::BTreeSet;\n \n /// Tracks the `T: 'a` or `'a: 'a` predicates that we have inferred\n /// must be added to the struct header.\n-pub type RequiredPredicates<'tcx> = BTreeSet<ty::OutlivesPredicate<Kind<'tcx>, ty::Region<'tcx>>>;\n+pub type RequiredPredicates<'tcx> =\n+    BTreeSet<ty::OutlivesPredicate<GenericArg<'tcx>, ty::Region<'tcx>>>;\n \n /// Given a requirement `T: 'a` or `'b: 'a`, deduce the\n /// outlives_component and add it to `required_predicates`\n pub fn insert_outlives_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    kind: Kind<'tcx>,\n+    kind: GenericArg<'tcx>,\n     outlived_region: Region<'tcx>,\n     required_predicates: &mut RequiredPredicates<'tcx>,\n ) {\n@@ -23,7 +24,7 @@ pub fn insert_outlives_predicate<'tcx>(\n     }\n \n     match kind.unpack() {\n-        UnpackedKind::Type(ty) => {\n+        GenericArgKind::Type(ty) => {\n             // `T: 'outlived_region` for some type `T`\n             // But T could be a lot of things:\n             // e.g., if `T = &'b u32`, then `'b: 'outlived_region` is\n@@ -112,14 +113,14 @@ pub fn insert_outlives_predicate<'tcx>(\n             }\n         }\n \n-        UnpackedKind::Lifetime(r) => {\n+        GenericArgKind::Lifetime(r) => {\n             if !is_free_region(tcx, r) {\n                 return;\n             }\n             required_predicates.insert(ty::OutlivesPredicate(kind, outlived_region));\n         }\n \n-        UnpackedKind::Const(_) => {\n+        GenericArgKind::Const(_) => {\n             // Generic consts don't impose any constraints.\n         }\n     }"}, {"sha": "0feaa2566279b0a2e92a54931fc4e3cde0b72534", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -4,7 +4,7 @@\n //! We walk the set of items and, for each member, generate new constraints.\n \n use hir::def_id::DefId;\n-use rustc::ty::subst::{SubstsRef, UnpackedKind};\n+use rustc::ty::subst::{SubstsRef, GenericArgKind};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -232,13 +232,13 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         for k in substs {\n             match k.unpack() {\n-                UnpackedKind::Lifetime(lt) => {\n+                GenericArgKind::Lifetime(lt) => {\n                     self.add_constraints_from_region(current, lt, variance_i)\n                 }\n-                UnpackedKind::Type(ty) => {\n+                GenericArgKind::Type(ty) => {\n                     self.add_constraints_from_ty(current, ty, variance_i)\n                 }\n-                UnpackedKind::Const(_) => {\n+                GenericArgKind::Const(_) => {\n                     // Consts impose no constraints.\n                 }\n             }\n@@ -387,13 +387,13 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                    variance_decl,\n                    variance_i);\n             match k.unpack() {\n-                UnpackedKind::Lifetime(lt) => {\n+                GenericArgKind::Lifetime(lt) => {\n                     self.add_constraints_from_region(current, lt, variance_i)\n                 }\n-                UnpackedKind::Type(ty) => {\n+                GenericArgKind::Type(ty) => {\n                     self.add_constraints_from_ty(current, ty, variance_i)\n                 }\n-                UnpackedKind::Const(_) => {\n+                GenericArgKind::Const(_) => {\n                     // Consts impose no constraints.\n                 }\n             }"}, {"sha": "aad1c80c3dc72c619e6f5929c8ef295b5bee80fb", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf43867a9cbb3766b48552632a602498fae2699/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ddf43867a9cbb3766b48552632a602498fae2699", "patch": "@@ -21,7 +21,7 @@ use rustc::hir;\n use rustc::hir::def::{CtorKind, DefKind, Res};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::ptr::P;\n-use rustc::ty::subst::{InternalSubsts, SubstsRef, UnpackedKind};\n+use rustc::ty::subst::{InternalSubsts, SubstsRef, GenericArgKind};\n use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::ty::fold::TypeFolder;\n use rustc::ty::layout::VariantIdx;\n@@ -1098,27 +1098,27 @@ fn external_generic_args(\n     substs: SubstsRef<'_>,\n ) -> GenericArgs {\n     let mut skip_self = has_self;\n-    let mut ty_sty = None;\n+    let mut ty_kind = None;\n     let args: Vec<_> = substs.iter().filter_map(|kind| match kind.unpack() {\n-        UnpackedKind::Lifetime(lt) => {\n+        GenericArgKind::Lifetime(lt) => {\n             lt.clean(cx).and_then(|lt| Some(GenericArg::Lifetime(lt)))\n         }\n-        UnpackedKind::Type(_) if skip_self => {\n+        GenericArgKind::Type(_) if skip_self => {\n             skip_self = false;\n             None\n         }\n-        UnpackedKind::Type(ty) => {\n-            ty_sty = Some(&ty.kind);\n+        GenericArgKind::Type(ty) => {\n+            ty_kind = Some(&ty.kind);\n             Some(GenericArg::Type(ty.clean(cx)))\n         }\n-        UnpackedKind::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n+        GenericArgKind::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n     }).collect();\n \n     match trait_did {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n         Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n-            assert!(ty_sty.is_some());\n-            let inputs = match ty_sty {\n+            assert!(ty_kind.is_some());\n+            let inputs = match ty_kind {\n                 Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),\n                 _ => return GenericArgs::AngleBracketed { args, bindings },\n             };"}]}