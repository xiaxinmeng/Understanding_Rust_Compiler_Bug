{"sha": "6d6c63ee23c627aa9299cffa738f40189126c08a", "node_id": "C_kwDOAAsO6NoAKDZkNmM2M2VlMjNjNjI3YWE5Mjk5Y2ZmYTczOGY0MDE4OTEyNmMwOGE", "commit": {"author": {"name": "Micha White", "email": "botahamec@outlook.com", "date": "2022-06-09T20:25:48Z"}, "committer": {"name": "Micha White", "email": "botahamec@outlook.com", "date": "2022-06-10T17:11:50Z"}, "message": "Lint single_match with Options, Results, and Cows", "tree": {"sha": "6af6161e5a4c27e39928333f4910c7cf354b4b12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6af6161e5a4c27e39928333f4910c7cf354b4b12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d6c63ee23c627aa9299cffa738f40189126c08a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEGofhdE61kfoixWy+rtlL+hwwE4kFAmKje14ACgkQrtlL+hww\nE4kv0A/9Fz7WJxzuszrMIQL6S8gD9/N5IehZjtJ35lr3+omOyVMtGTOYZn3zozjb\nC1pMtb/eDGM9MzupliPIti2B6Ohd84O6o/7UjGrlYJOjhVxFKbmc2vBruGJNW88w\nqFuAI7VQgVVnifzJS8xjzlZ4Obl4A1wx7W0XXeRsZ7apN0qmcgG2VcCegmrw0l53\nrG1z17VTB1TtOxHqMWcNpG0WGAjsvOkRj16OEkCVlO7sYLED6gF44C22tJSeL0vf\nctV/xR/GEUE3b7KtOXDbBfKPLl/p3BrvTmtw2MyglYfR1z3AiieZE7wOOtn75eoy\nv0SfZ/YeyImCQVskFW4Qv8d6tT2MzKC9la44RdzK4FzPkl1/QwUJmfQ3EMPOo/eq\n87q9h24caOkHsg+sqdyVAP1dX4ZZlSIMCXhnCvDtULqsZjNw36BI0nczYYjBRVIl\n0raDakLQ4SGYNYyZQ6F9hIoAwPsZOuWok+svfd8GYU/blsK6umxB6BfYdXRifQAx\nQj/Q3O5wd8WXnkkA3lJYQbNxxFZ7wpsWrsZ88V8QwdqJpsNmiMckRVyMNKCqbMdH\nbG3sUUluD5IyogCes5A6guIxPZwsioh4Y5V3lQ65Tqo/KYSq8nDmeHk7K4AlIJMP\nLJbBBhGRpUFa5UN2fhwS7kV1v1IXYyWDKTSiiYUjlgAljKHixF0=\n=f5Ej\n-----END PGP SIGNATURE-----", "payload": "tree 6af6161e5a4c27e39928333f4910c7cf354b4b12\nparent b3c94c0828c3746437304e8bc26547486c7a5699\nauthor Micha White <botahamec@outlook.com> 1654806348 -0400\ncommitter Micha White <botahamec@outlook.com> 1654881110 -0400\n\nLint single_match with Options, Results, and Cows\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d6c63ee23c627aa9299cffa738f40189126c08a", "html_url": "https://github.com/rust-lang/rust/commit/6d6c63ee23c627aa9299cffa738f40189126c08a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d6c63ee23c627aa9299cffa738f40189126c08a/comments", "author": {"login": "botahamec", "id": 32026883, "node_id": "MDQ6VXNlcjMyMDI2ODgz", "avatar_url": "https://avatars.githubusercontent.com/u/32026883?v=4", "gravatar_id": "", "url": "https://api.github.com/users/botahamec", "html_url": "https://github.com/botahamec", "followers_url": "https://api.github.com/users/botahamec/followers", "following_url": "https://api.github.com/users/botahamec/following{/other_user}", "gists_url": "https://api.github.com/users/botahamec/gists{/gist_id}", "starred_url": "https://api.github.com/users/botahamec/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/botahamec/subscriptions", "organizations_url": "https://api.github.com/users/botahamec/orgs", "repos_url": "https://api.github.com/users/botahamec/repos", "events_url": "https://api.github.com/users/botahamec/events{/privacy}", "received_events_url": "https://api.github.com/users/botahamec/received_events", "type": "User", "site_admin": false}, "committer": {"login": "botahamec", "id": 32026883, "node_id": "MDQ6VXNlcjMyMDI2ODgz", "avatar_url": "https://avatars.githubusercontent.com/u/32026883?v=4", "gravatar_id": "", "url": "https://api.github.com/users/botahamec", "html_url": "https://github.com/botahamec", "followers_url": "https://api.github.com/users/botahamec/followers", "following_url": "https://api.github.com/users/botahamec/following{/other_user}", "gists_url": "https://api.github.com/users/botahamec/gists{/gist_id}", "starred_url": "https://api.github.com/users/botahamec/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/botahamec/subscriptions", "organizations_url": "https://api.github.com/users/botahamec/orgs", "repos_url": "https://api.github.com/users/botahamec/repos", "events_url": "https://api.github.com/users/botahamec/events{/privacy}", "received_events_url": "https://api.github.com/users/botahamec/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3c94c0828c3746437304e8bc26547486c7a5699", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3c94c0828c3746437304e8bc26547486c7a5699", "html_url": "https://github.com/rust-lang/rust/commit/b3c94c0828c3746437304e8bc26547486c7a5699"}], "stats": {"total": 106, "additions": 82, "deletions": 24}, "files": [{"sha": "b54d4e8a0ee95ca8fdef904490efcb0a96a0fbc1", "filename": "clippy_lints/src/matches/single_match.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6d6c63ee23c627aa9299cffa738f40189126c08a/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d6c63ee23c627aa9299cffa738f40189126c08a/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=6d6c63ee23c627aa9299cffa738f40189126c08a", "patch": "@@ -140,6 +140,23 @@ fn check_opt_like<'a>(\n     ty: Ty<'a>,\n     els: Option<&Expr<'_>>,\n ) {\n+    // We want to suggest to exclude an arm that contains only wildcards or forms the exhaustive\n+    // match with the second branch, without enum variants in matches.\n+    if !contains_only_wilds(arms[1].pat) && !form_exhaustive_matches(cx, ty, arms[0].pat, arms[1].pat) {\n+        return;\n+    }\n+\n+    let mut paths_and_types = Vec::new();\n+    if !collect_pat_paths(&mut paths_and_types, cx, arms[1].pat, ty) {\n+        return;\n+    }\n+\n+    if paths_and_types.iter().all(|info| in_candidate_enum(cx, info)) {\n+        report_single_pattern(cx, ex, arms, expr, els);\n+    }\n+}\n+\n+fn in_candidate_enum<'a>(cx: &LateContext<'a>, path_info: &(String, Ty<'_>)) -> bool {\n     // list of candidate `Enum`s we know will never get any more members\n     let candidates = &[\n         (&paths::COW, \"Borrowed\"),\n@@ -151,29 +168,13 @@ fn check_opt_like<'a>(\n         (&paths::RESULT, \"Ok\"),\n     ];\n \n-    // We want to suggest to exclude an arm that contains only wildcards or forms the exhaustive\n-    // match with the second branch, without enum variants in matches.\n-    if !contains_only_wilds(arms[1].pat) && !form_exhaustive_matches(arms[0].pat, arms[1].pat) {\n-        return;\n-    }\n-\n-    let mut paths_and_types = Vec::new();\n-    if !collect_pat_paths(&mut paths_and_types, cx, arms[1].pat, ty) {\n-        return;\n-    }\n-\n-    let in_candidate_enum = |path_info: &(String, Ty<'_>)| -> bool {\n-        let (path, ty) = path_info;\n-        for &(ty_path, pat_path) in candidates {\n-            if path == pat_path && match_type(cx, *ty, ty_path) {\n-                return true;\n-            }\n+    let (path, ty) = path_info;\n+    for &(ty_path, pat_path) in candidates {\n+        if path == pat_path && match_type(cx, *ty, ty_path) {\n+            return true;\n         }\n-        false\n-    };\n-    if paths_and_types.iter().all(in_candidate_enum) {\n-        report_single_pattern(cx, ex, arms, expr, els);\n     }\n+    false\n }\n \n /// Collects paths and their types from the given patterns. Returns true if the given pattern could\n@@ -218,7 +219,7 @@ fn contains_only_wilds(pat: &Pat<'_>) -> bool {\n \n /// Returns true if the given patterns forms only exhaustive matches that don't contain enum\n /// patterns without a wildcard.\n-fn form_exhaustive_matches(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n+fn form_exhaustive_matches<'a>(cx: &LateContext<'a>, ty: Ty<'a>, left: &Pat<'_>, right: &Pat<'_>) -> bool {\n     match (&left.kind, &right.kind) {\n         (PatKind::Wild, _) | (_, PatKind::Wild) => true,\n         (PatKind::Tuple(left_in, left_pos), PatKind::Tuple(right_in, right_pos)) => {\n@@ -264,6 +265,14 @@ fn form_exhaustive_matches(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n             }\n             true\n         },\n+        (PatKind::TupleStruct(..), PatKind::Path(_) | PatKind::TupleStruct(..)) => {\n+            let mut paths_and_types = Vec::new();\n+            if !collect_pat_paths(&mut paths_and_types, cx, right, ty) {\n+                return false;\n+            }\n+\n+            paths_and_types.iter().all(|info| in_candidate_enum(cx, info))\n+        },\n         _ => false,\n     }\n }"}, {"sha": "4d2b9ec5f903aef7bd0b8486d8ffb1206339d328", "filename": "tests/ui/single_match.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6d6c63ee23c627aa9299cffa738f40189126c08a/tests%2Fui%2Fsingle_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d6c63ee23c627aa9299cffa738f40189126c08a/tests%2Fui%2Fsingle_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match.stderr?ref=6d6c63ee23c627aa9299cffa738f40189126c08a", "patch": "@@ -38,6 +38,15 @@ LL | |         _ => {},\n LL | |     };\n    | |_____^ help: try this: `if let (2..=3, 7..=9) = z { dummy() }`\n \n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:54:5\n+   |\n+LL | /     match x {\n+LL | |         Some(y) => dummy(),\n+LL | |         None => (),\n+LL | |     };\n+   | |_____^ help: try this: `if let Some(y) = x { dummy() }`\n+\n error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:59:5\n    |\n@@ -146,5 +155,5 @@ LL | |         (..) => {},\n LL | |     }\n    | |_____^ help: try this: `if let (.., Some(E::V), _) = (Some(42), Some(E::V), Some(42)) {}`\n \n-error: aborting due to 15 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "dc603578fded1f9d4d99f8768a5f5f1791d8e8ec", "filename": "tests/ui/single_match_else.stderr", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6d6c63ee23c627aa9299cffa738f40189126c08a/tests%2Fui%2Fsingle_match_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d6c63ee23c627aa9299cffa738f40189126c08a/tests%2Fui%2Fsingle_match_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.stderr?ref=6d6c63ee23c627aa9299cffa738f40189126c08a", "patch": "@@ -20,5 +20,45 @@ LL +         None\n LL ~     };\n    |\n \n-error: aborting due to previous error\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:84:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(a) => println!(\"${:?}\", a),\n+LL | |         None => {\n+LL | |             println!(\"else block\");\n+LL | |             return\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n+LL +         println!(\"else block\");\n+LL +         return\n+LL +     }\n+   |\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:93:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(a) => println!(\"${:?}\", a),\n+LL | |         None => {\n+LL | |             println!(\"else block\");\n+LL | |             return;\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n+LL +         println!(\"else block\");\n+LL +         return;\n+LL +     }\n+   |\n+\n+error: aborting due to 3 previous errors\n "}]}