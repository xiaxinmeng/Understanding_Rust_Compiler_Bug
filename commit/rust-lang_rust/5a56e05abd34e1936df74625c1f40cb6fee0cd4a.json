{"sha": "5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNTZlMDVhYmQzNGUxOTM2ZGY3NDYyNWMxZjQwY2I2ZmVlMGNkNGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-20T15:01:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-20T15:01:24Z"}, "message": "Auto merge of #63744 - Centril:rollup-g4l3ra9, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #63216 (avoid unnecessary reservations in std::io::Take::read_to_end)\n - #63265 (Implement `nth_back` for ChunksExactMut)\n - #63691 (Fix bug in iter::Chain::size_hint)\n - #63722 (Don't use stage naming in RUSTFLAGS environment variables)\n - #63723 (Consolidate sigemptyset workarounds)\n - #63736 (Restore the rustc_plugin crate in the sysroot)\n - #63743 (Allow git to merge `Cargo.lock`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "33d5f0b1aec0faad29a18e8d9e40271486d8c59d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33d5f0b1aec0faad29a18e8d9e40271486d8c59d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "html_url": "https://github.com/rust-lang/rust/commit/5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51879c3abaedb926739095d19a2af638ee6a07d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/51879c3abaedb926739095d19a2af638ee6a07d8", "html_url": "https://github.com/rust-lang/rust/commit/51879c3abaedb926739095d19a2af638ee6a07d8"}, {"sha": "218bcf2e01146eb87afbef608f00c8df1e54b415", "url": "https://api.github.com/repos/rust-lang/rust/commits/218bcf2e01146eb87afbef608f00c8df1e54b415", "html_url": "https://github.com/rust-lang/rust/commit/218bcf2e01146eb87afbef608f00c8df1e54b415"}], "stats": {"total": 261, "additions": 198, "deletions": 63}, "files": [{"sha": "a7de7ce85593c140267bd3bafa3812859d8f259f", "filename": ".gitattributes", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "patch": "@@ -8,7 +8,7 @@\n src/etc/installer/gfx/* binary\n *.woff binary\n src/vendor/** -text\n-Cargo.lock -merge linguist-generated=false\n+Cargo.lock linguist-generated=false\n \n # Older git versions try to fix line endings on images, this prevents it.\n *.png binary"}, {"sha": "660f2ba237008f0d42ff1b7d637786edcfe58d42", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "patch": "@@ -3199,6 +3199,7 @@ dependencies = [\n  \"rustc_interface\",\n  \"rustc_metadata\",\n  \"rustc_mir\",\n+ \"rustc_plugin\",\n  \"rustc_plugin_impl\",\n  \"rustc_save_analysis\",\n  \"rustc_target\",\n@@ -3382,6 +3383,13 @@ dependencies = [\n  \"syntax_pos\",\n ]\n \n+[[package]]\n+name = \"rustc_plugin\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_plugin_impl\",\n+]\n+\n [[package]]\n name = \"rustc_plugin_impl\"\n version = \"0.0.0\""}, {"sha": "afde076a35a50a488b34450c2851c88b1bed4677", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "patch": "@@ -859,12 +859,12 @@ impl<'a> Builder<'a> {\n             stage = compiler.stage;\n         }\n \n-        let mut extra_args = env::var(&format!(\"RUSTFLAGS_STAGE_{}\", stage)).unwrap_or_default();\n+        let mut extra_args = String::new();\n         if stage != 0 {\n-            let s = env::var(\"RUSTFLAGS_STAGE_NOT_0\").unwrap_or_default();\n-            if !extra_args.is_empty() {\n-                extra_args.push_str(\" \");\n-            }\n+            let s = env::var(\"RUSTFLAGS_NOT_BOOTSTRAP\").unwrap_or_default();\n+            extra_args.push_str(&s);\n+        } else {\n+            let s = env::var(\"RUSTFLAGS_BOOTSTRAP\").unwrap_or_default();\n             extra_args.push_str(&s);\n         }\n "}, {"sha": "c9612596b1ba0e8c523ecba69b1cbf7271f6a784", "filename": "src/libcore/iter/adapters/chain.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "patch": "@@ -173,17 +173,23 @@ impl<A, B> Iterator for Chain<A, B> where\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (a_lower, a_upper) = self.a.size_hint();\n-        let (b_lower, b_upper) = self.b.size_hint();\n+        match self.state {\n+            ChainState::Both => {\n+                let (a_lower, a_upper) = self.a.size_hint();\n+                let (b_lower, b_upper) = self.b.size_hint();\n \n-        let lower = a_lower.saturating_add(b_lower);\n+                let lower = a_lower.saturating_add(b_lower);\n \n-        let upper = match (a_upper, b_upper) {\n-            (Some(x), Some(y)) => x.checked_add(y),\n-            _ => None\n-        };\n+                let upper = match (a_upper, b_upper) {\n+                    (Some(x), Some(y)) => x.checked_add(y),\n+                    _ => None\n+                };\n \n-        (lower, upper)\n+                (lower, upper)\n+            }\n+            ChainState::Front => self.a.size_hint(),\n+            ChainState::Back => self.b.size_hint(),\n+        }\n     }\n }\n "}, {"sha": "bfbbb15c8d488a232bb7be0ea2cb2eebb5cbbba8", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "patch": "@@ -4637,6 +4637,22 @@ impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n             Some(tail)\n         }\n     }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &mut [];\n+            None\n+        } else {\n+            let start = (len - 1 - n) * self.chunk_size;\n+            let end = start + self.chunk_size;\n+            let (temp, _tail) = mem::replace(&mut self.v, &mut []).split_at_mut(end);\n+            let (head, nth_back) = temp.split_at_mut(start);\n+            self.v = head;\n+            Some(nth_back)\n+        }\n+    }\n }\n \n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]"}, {"sha": "3a4f76852a0d7c384daeae71a76593942df01af4", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "patch": "@@ -152,6 +152,54 @@ fn test_iterator_chain_find() {\n     assert_eq!(iter.next(), None);\n }\n \n+#[test]\n+fn test_iterator_chain_size_hint() {\n+    struct Iter {\n+        is_empty: bool,\n+    }\n+\n+    impl Iterator for Iter {\n+        type Item = ();\n+\n+        // alternates between `None` and `Some(())`\n+        fn next(&mut self) -> Option<Self::Item> {\n+            if self.is_empty {\n+                self.is_empty = false;\n+                None\n+            } else {\n+                self.is_empty = true;\n+                Some(())\n+            }\n+        }\n+\n+        fn size_hint(&self) -> (usize, Option<usize>) {\n+            if self.is_empty {\n+                (0, Some(0))\n+            } else {\n+                (1, Some(1))\n+            }\n+        }\n+    }\n+\n+    impl DoubleEndedIterator for Iter {\n+        fn next_back(&mut self) -> Option<Self::Item> {\n+            self.next()\n+        }\n+    }\n+\n+    // this chains an iterator of length 0 with an iterator of length 1,\n+    // so after calling `.next()` once, the iterator is empty and the\n+    // state is `ChainState::Back`. `.size_hint()` should now disregard\n+    // the size hint of the left iterator\n+    let mut iter = Iter { is_empty: true }.chain(once(()));\n+    assert_eq!(iter.next(), Some(()));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+\n+    let mut iter = once(()).chain(Iter { is_empty: true });\n+    assert_eq!(iter.next_back(), Some(()));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+}\n+\n #[test]\n fn test_zip_nth() {\n     let xs = [0, 1, 2, 4, 5];"}, {"sha": "6609bc3135ae0bfbc64ef0e8684a00b1590b4992", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "patch": "@@ -374,6 +374,25 @@ fn test_chunks_exact_mut_nth() {\n     assert_eq!(c2.next(), None);\n }\n \n+#[test]\n+fn test_chunks_exact_mut_nth_back() {\n+    let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    let mut c = v.chunks_exact_mut(2);\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+    assert_eq!(c.next(), None);\n+\n+    let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let mut c2 = v2.chunks_exact_mut(3);\n+    assert_eq!(c2.nth_back(0).unwrap(), &[0, 1, 2]);\n+    assert_eq!(c2.next(), None);\n+    assert_eq!(c2.next_back(), None);\n+\n+    let v3: &mut [i32] = &mut [0, 1, 2, 3, 4];\n+    let mut c3 = v3.chunks_exact_mut(10);\n+    assert_eq!(c3.nth_back(0), None);\n+}\n+\n #[test]\n fn test_chunks_exact_mut_last() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];"}, {"sha": "b030517e28ec271587ce4f2d915dfed8c3082866", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "patch": "@@ -20,6 +20,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n+rustc_plugin = { path = \"../librustc_plugin/deprecated\" } # To get this in the sysroot\n rustc_plugin_impl = { path = \"../librustc_plugin\" }\n rustc_save_analysis = { path = \"../librustc_save_analysis\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }"}, {"sha": "1d0afe84c25a89913ea844f143836a2e063a4903", "filename": "src/librustc_plugin/deprecated/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fdeprecated%2Flib.rs?ref=5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "patch": "@@ -1,6 +1,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(staged_api)]\n-#![unstable(feature = \"rustc_plugin\", issue = \"29597\")]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n #![rustc_deprecated(since = \"1.38.0\", reason = \"\\\n     import this through `rustc_driver::plugin` instead to make TLS work correctly. \\\n     See https://github.com/rust-lang/rust/issues/62717\")]"}, {"sha": "5060f368229bb848821664e8fe48baadc9a227fe", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "patch": "@@ -353,20 +353,25 @@ fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n // Because we're extending the buffer with uninitialized data for trusted\n // readers, we need to make sure to truncate that if any of this panics.\n fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n-    read_to_end_with_reservation(r, buf, 32)\n+    read_to_end_with_reservation(r, buf, |_| 32)\n }\n \n-fn read_to_end_with_reservation<R: Read + ?Sized>(r: &mut R,\n-                                                  buf: &mut Vec<u8>,\n-                                                  reservation_size: usize) -> Result<usize>\n+fn read_to_end_with_reservation<R, F>(\n+    r: &mut R,\n+    buf: &mut Vec<u8>,\n+    mut reservation_size: F,\n+) -> Result<usize>\n+where\n+    R: Read + ?Sized,\n+    F: FnMut(&R) -> usize,\n {\n     let start_len = buf.len();\n     let mut g = Guard { len: buf.len(), buf: buf };\n     let ret;\n     loop {\n         if g.len == g.buf.len() {\n             unsafe {\n-                g.buf.reserve(reservation_size);\n+                g.buf.reserve(reservation_size(r));\n                 let capacity = g.buf.capacity();\n                 g.buf.set_len(capacity);\n                 r.initializer().initialize(&mut g.buf[g.len..]);\n@@ -2253,9 +2258,10 @@ impl<T: Read> Read for Take<T> {\n     }\n \n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n-        let reservation_size = cmp::min(self.limit, 32) as usize;\n-\n-        read_to_end_with_reservation(self, buf, reservation_size)\n+        // Pass in a reservation_size closure that respects the current value\n+        // of limit for each read. If we hit the read limit, this prevents the\n+        // final zero-byte read from allocating again.\n+        read_to_end_with_reservation(self, buf, |self_| cmp::min(self_.limit, 32) as usize)\n     }\n }\n \n@@ -2378,6 +2384,7 @@ impl<B: BufRead> Iterator for Lines<B> {\n \n #[cfg(test)]\n mod tests {\n+    use crate::cmp;\n     use crate::io::prelude::*;\n     use super::{Cursor, SeekFrom, repeat};\n     use crate::io::{self, IoSlice, IoSliceMut};\n@@ -2651,6 +2658,49 @@ mod tests {\n         Ok(())\n     }\n \n+    // A simple example reader which uses the default implementation of\n+    // read_to_end.\n+    struct ExampleSliceReader<'a> {\n+        slice: &'a [u8],\n+    }\n+\n+    impl<'a> Read for ExampleSliceReader<'a> {\n+        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+            let len = cmp::min(self.slice.len(), buf.len());\n+            buf[..len].copy_from_slice(&self.slice[..len]);\n+            self.slice = &self.slice[len..];\n+            Ok(len)\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_to_end_capacity() -> io::Result<()> {\n+        let input = &b\"foo\"[..];\n+\n+        // read_to_end() generally needs to over-allocate, both for efficiency\n+        // and so that it can distinguish EOF. Assert that this is the case\n+        // with this simple ExampleSliceReader struct, which uses the default\n+        // implementation of read_to_end. Even though vec1 is allocated with\n+        // exactly enough capacity for the read, read_to_end will allocate more\n+        // space here.\n+        let mut vec1 = Vec::with_capacity(input.len());\n+        ExampleSliceReader { slice: input }.read_to_end(&mut vec1)?;\n+        assert_eq!(vec1.len(), input.len());\n+        assert!(vec1.capacity() > input.len(), \"allocated more\");\n+\n+        // However, std::io::Take includes an implementation of read_to_end\n+        // that will not allocate when the limit has already been reached. In\n+        // this case, vec2 never grows.\n+        let mut vec2 = Vec::with_capacity(input.len());\n+        ExampleSliceReader { slice: input }\n+            .take(input.len() as u64)\n+            .read_to_end(&mut vec2)?;\n+        assert_eq!(vec2.len(), input.len());\n+        assert_eq!(vec2.capacity(), input.len(), \"did not allocate more\");\n+\n+        Ok(())\n+    }\n+\n     #[test]\n     fn io_slice_mut_advance() {\n         let mut buf1 = [1; 8];"}, {"sha": "21fca23a8fe9ea98aa4077dcda4e40aa2e3c59a5", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "patch": "@@ -20,6 +20,30 @@ cfg_if::cfg_if! {\n     }\n }\n \n+// Android with api less than 21 define sig* functions inline, so it is not\n+// available for dynamic link. Implementing sigemptyset and sigaddset allow us\n+// to support older Android version (independent of libc version).\n+// The following implementations are based on https://git.io/vSkNf\n+cfg_if::cfg_if! {\n+    if #[cfg(target_os = \"android\")] {\n+        pub unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n+            set.write_bytes(0u8, 1);\n+            return 0;\n+        }\n+        #[allow(dead_code)]\n+        pub unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n+            use crate::{slice, mem};\n+\n+            let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n+            let bit = (signum - 1) as usize;\n+            raw[bit / 8] |= 1 << (bit % 8);\n+            return 0;\n+        }\n+    } else {\n+        pub use libc::{sigemptyset, sigaddset};\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////\n@@ -429,36 +453,6 @@ mod tests {\n         }\n     }\n \n-    // Android with api less than 21 define sig* functions inline, so it is not\n-    // available for dynamic link. Implementing sigemptyset and sigaddset allow us\n-    // to support older Android version (independent of libc version).\n-    // The following implementations are based on https://git.io/vSkNf\n-\n-    #[cfg(not(target_os = \"android\"))]\n-    extern {\n-        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigemptyset14\")]\n-        fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int;\n-\n-        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaddset14\")]\n-        fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;\n-    }\n-\n-    #[cfg(target_os = \"android\")]\n-    unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n-        set.write_bytes(0u8, 1);\n-        return 0;\n-    }\n-\n-    #[cfg(target_os = \"android\")]\n-    unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n-        use crate::slice;\n-\n-        let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n-        let bit = (signum - 1) as usize;\n-        raw[bit / 8] |= 1 << (bit % 8);\n-        return 0;\n-    }\n-\n     // See #14232 for more information, but it appears that signal delivery to a\n     // newly spawned process may just be raced in the macOS, so to prevent this\n     // test from being flaky we ignore it on macOS."}, {"sha": "a9711c71b7aa36503480f97152227ae9ce6967e5", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a56e05abd34e1936df74625c1f40cb6fee0cd4a/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=5a56e05abd34e1936df74625c1f40cb6fee0cd4a", "patch": "@@ -214,14 +214,7 @@ impl Command {\n             // need to clean things up now to avoid confusing the program\n             // we're about to run.\n             let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n-            if cfg!(target_os = \"android\") {\n-                // Implementing sigemptyset allow us to support older Android\n-                // versions. See the comment about Android and sig* functions in\n-                // process_common.rs\n-                set.as_mut_ptr().write_bytes(0u8, 1);\n-            } else {\n-                cvt(libc::sigemptyset(set.as_mut_ptr()))?;\n-            }\n+            cvt(sigemptyset(set.as_mut_ptr()))?;\n             cvt(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(),\n                                          ptr::null_mut()))?;\n             let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n@@ -363,10 +356,10 @@ impl Command {\n             }\n \n             let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n-            cvt(libc::sigemptyset(set.as_mut_ptr()))?;\n+            cvt(sigemptyset(set.as_mut_ptr()))?;\n             cvt(libc::posix_spawnattr_setsigmask(attrs.0.as_mut_ptr(),\n                                                  set.as_ptr()))?;\n-            cvt(libc::sigaddset(set.as_mut_ptr(), libc::SIGPIPE))?;\n+            cvt(sigaddset(set.as_mut_ptr(), libc::SIGPIPE))?;\n             cvt(libc::posix_spawnattr_setsigdefault(attrs.0.as_mut_ptr(),\n                                                     set.as_ptr()))?;\n "}]}