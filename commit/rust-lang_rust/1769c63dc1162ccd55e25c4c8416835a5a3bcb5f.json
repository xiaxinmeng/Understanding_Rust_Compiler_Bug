{"sha": "1769c63dc1162ccd55e25c4c8416835a5a3bcb5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NjljNjNkYzExNjJjY2Q1NWUyNWM0Yzg0MTY4MzVhNWEzYmNiNWY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-11-29T18:50:26Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-05T13:42:34Z"}, "message": "add a comment and assertion explaining everything", "tree": {"sha": "efeb451f38b4c237b4e09142f9b09618220b459a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efeb451f38b4c237b4e09142f9b09618220b459a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1769c63dc1162ccd55e25c4c8416835a5a3bcb5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1769c63dc1162ccd55e25c4c8416835a5a3bcb5f", "html_url": "https://github.com/rust-lang/rust/commit/1769c63dc1162ccd55e25c4c8416835a5a3bcb5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1769c63dc1162ccd55e25c4c8416835a5a3bcb5f/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d38541d3fbc21dfed58877b9181b40169c149a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d38541d3fbc21dfed58877b9181b40169c149a2", "html_url": "https://github.com/rust-lang/rust/commit/9d38541d3fbc21dfed58877b9181b40169c149a2"}], "stats": {"total": 94, "additions": 93, "deletions": 1}, "files": [{"sha": "2ed9ccec604494e9155668e3cf6cdf278e21e99f", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1769c63dc1162ccd55e25c4c8416835a5a3bcb5f/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1769c63dc1162ccd55e25c4c8416835a5a3bcb5f/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=1769c63dc1162ccd55e25c4c8416835a5a3bcb5f", "patch": "@@ -16,13 +16,14 @@ use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause, Re\n use traits::IntercrateMode;\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, Ty, TyCtxt};\n+use ty::fold::TypeFoldable;\n use ty::subst::Subst;\n \n use infer::{InferCtxt, InferOk};\n \n-#[derive(Copy, Clone, Debug)]\n /// Whether we do the orphan check relative to this crate or\n /// to some remote crate.\n+#[derive(Copy, Clone, Debug)]\n enum InCrate {\n     Local,\n     Remote\n@@ -224,6 +225,92 @@ pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     orphan_check_trait_ref(tcx, trait_ref, InCrate::Local)\n }\n \n+/// Check whether a trait-ref is potentially implementable by a crate.\n+///\n+/// The current rule is that a trait-ref orphan checks in a crate C:\n+///\n+/// 1. Order the parameters in the trait-ref in subst order - Self first,\n+///    others linearly (e.g. `<U as Foo<V, W>>` is U < V < W).\n+/// 2. Of these type parameters, there is at least one type parameter\n+///    in which, walking the type as a tree, you can reach a type local\n+///    to C where all types in-between are fundamental types. Call the\n+///    first such parameter the \"local key parameter\".\n+///     - e.g. `Box<LocalType>` is OK, because you can visit LocalType\n+///       going through `Box`, which is fundamental.\n+///     - similarly, `FundamentalPair<Vec<()>, Box<LocalType>>` is OK for\n+///       the same reason.\n+///     - but (knowing that `Vec<T>` is non-fundamental, and assuming it's\n+///       not local), `Vec<LocalType>` is bad, because `Vec<->` is between\n+///       the local type and the type parameter.\n+/// 3. Every type parameter before the local key parameter is fully known in C.\n+///     - e.g. `impl<T> T: Trait<LocalType>` is bad, because `T` might be\n+///       an unknown type.\n+///     - but `impl<T> LocalType: Trait<T>` is OK, because `LocalType`\n+///       occurs before `T`.\n+/// 4. Every type in the local key parameter not known in C, going\n+///    through the parameter's type tree, must appear only as a subtree of\n+///    a type local to C, with only fundamental types between the type\n+///    local to C and the local key parameter.\n+///     - e.g. `Vec<LocalType<T>>>` (or equivalently `Box<Vec<LocalType<T>>>`)\n+///     is bad, because the only local type with `T` as a subtree is\n+///     `LocalType<T>`, and `Vec<->` is between it and the type parameter.\n+///     - similarly, `FundamentalPair<LocalType<T>, T>` is bad, because\n+///     the second occurence of `T` is not a subtree of *any* local type.\n+///     - however, `LocalType<Vec<T>>` is OK, because `T` is a subtree of\n+///     `LocalType<Vec<T>>`, which is local and has no types between it and\n+///     the type parameter.\n+///\n+/// The orphan rules actually serve several different purposes:\n+///\n+/// 1. They enable link-safety - i.e. 2 mutually-unknowing crates (where\n+///    every type local to one crate is unknown in the other) can't implement\n+///    the same trait-ref. This follows because it can be seen that no such\n+///    type can orphan-check in 2 such crates.\n+///\n+///    To check that a local impl follows the orphan rules, we check it in\n+///    InCrate::Local mode, using type parameters for the \"generic\" types.\n+///\n+/// 2. They ground negative reasoning for coherence. If a user wants to\n+///    write both a conditional blanket impl and a specific impl, we need to\n+///    make sure they do not overlap. For example, if we write\n+///    ```\n+///    impl<T> IntoIterator for Vec<T>\n+///    impl<T: Iterator> IntoIterator for T\n+///    ```\n+///    We need to be able to prove that `Option<$0>: !Iterator` for every type $0.\n+///    We can observe that this holds in the current crate, but we need to make\n+///    sure this will also hold in all unknown crates (both \"independent\" crates,\n+///    which we need for link-safety, and also child crates, because we don't want\n+///    child crates to get error for impl conflicts in a *dependency*).\n+///\n+///    For that, we only allow negative reasoning if, for every assignment to the\n+///    inference variables, every unknown crate would get an orphan error if they\n+///    try to implement this trait-ref. To check for this, we use InCrate::Remote\n+///    mode. That is sound because we already know all the impls from known crates.\n+///\n+/// 3. For non-#[fundamental] traits, they guarantee that parent crates can\n+///    add \"non-blanket\" impls without breaking negative reasoning in dependent\n+///    crates. This is the \"rebalancing coherence\" (RFC 1023) restriction.\n+///\n+///    For that, we only a allow crate to perform negative reasoning on\n+///    non-local-non-#[fundamental] only if there's a local key parameter as per (2).\n+///\n+///    Because we never perform negative reasoning generically (coherence does\n+///    not involve type parameters), this can be interpreted as doing the full\n+///    orphan check (using InCrate::Local mode), substituting non-local known\n+///    types for all inference variables.\n+///\n+///    This allows for crates to future-compatibly add impls as long as they\n+///    can't apply to types with a key parameter in a child crate - applying\n+///    the rules, this basically means that every type parameter in the impl\n+///    must appear behind a non-fundamental type (because this is not a\n+///    type-system requirement, crate owners might also go for \"semantic\n+///    future-compatibility\" involving things such as sealed traits, but\n+///    the above requirement is sufficient, and is necessary in \"open world\"\n+///    cases).\n+///\n+/// Note that this function is never called for types that have both type\n+/// parameters and inference variables.\n fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n                                 trait_ref: ty::TraitRef<'tcx>,\n                                 in_crate: InCrate)\n@@ -232,6 +319,11 @@ fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n     debug!(\"orphan_check_trait_ref(trait_ref={:?}, in_crate={:?})\",\n            trait_ref, in_crate);\n \n+    if trait_ref.needs_infer() && trait_ref.needs_subst() {\n+        bug!(\"can't orphan check a trait ref with both params and inference variables {:?}\",\n+             trait_ref);\n+    }\n+\n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n     // Find the first input type that either references a type parameter OR"}]}