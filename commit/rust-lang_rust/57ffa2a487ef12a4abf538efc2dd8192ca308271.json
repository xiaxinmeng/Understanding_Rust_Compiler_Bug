{"sha": "57ffa2a487ef12a4abf538efc2dd8192ca308271", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZmZhMmE0ODdlZjEyYTRhYmY1MzhlZmMyZGQ4MTkyY2EzMDgyNzE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-13T19:30:08Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-13T20:00:13Z"}, "message": "Make the parser more careful about keywords\n\nKeywords are now only recognized in contexts where they are valid. The\nlexer no longer recognizes them, all words are lexed as IDENT tokens,\nthat get interpreted by the parser.", "tree": {"sha": "f3a82a1076c93c6ad6200391cc838cf2e7e6999d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3a82a1076c93c6ad6200391cc838cf2e7e6999d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57ffa2a487ef12a4abf538efc2dd8192ca308271", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57ffa2a487ef12a4abf538efc2dd8192ca308271", "html_url": "https://github.com/rust-lang/rust/commit/57ffa2a487ef12a4abf538efc2dd8192ca308271", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57ffa2a487ef12a4abf538efc2dd8192ca308271/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be9aa1cc5ecb59c62a80db9e5be355deac90d08e", "url": "https://api.github.com/repos/rust-lang/rust/commits/be9aa1cc5ecb59c62a80db9e5be355deac90d08e", "html_url": "https://github.com/rust-lang/rust/commit/be9aa1cc5ecb59c62a80db9e5be355deac90d08e"}], "stats": {"total": 1764, "additions": 612, "deletions": 1152}, "files": [{"sha": "6f93234fa2bdd1ea9705673609971de533d1a4d1", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 1, "deletions": 146, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/57ffa2a487ef12a4abf538efc2dd8192ca308271/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ffa2a487ef12a4abf538efc2dd8192ca308271/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=57ffa2a487ef12a4abf538efc2dd8192ca308271", "patch": "@@ -22,8 +22,6 @@ state type reader = state obj {\n     fn add_str(str) -> token::str_num;\n     fn get_str(token::str_num) -> str;\n     fn get_chpos() -> uint;\n-    fn get_keywords() -> hashmap[str,token::token];\n-    fn get_reserved() -> hashmap[str,()];\n     fn get_filemap() -> codemap::filemap;\n     fn err(str m);\n };\n@@ -39,8 +37,6 @@ fn new_reader(session sess, io::reader rdr,\n                      mutable uint mark_chpos,\n                      mutable uint chpos,\n                      mutable vec[str] strs,\n-                     hashmap[str,token::token] keywords,\n-                     hashmap[str,()] reserved,\n                      codemap::filemap fm) {\n \n         fn is_eof() -> bool {\n@@ -82,10 +78,6 @@ fn new_reader(session sess, io::reader rdr,\n             }\n         }\n \n-        fn get_keywords() -> hashmap[str,token::token] {\n-            ret keywords;\n-        }\n-\n         fn add_str(str s) -> token::str_num {\n             strs += vec(s);\n             ret _vec::len[str](strs) - 1u;\n@@ -95,10 +87,6 @@ fn new_reader(session sess, io::reader rdr,\n             ret strs.(i);\n         }\n \n-        fn get_reserved() -> hashmap[str,()] {\n-            ret reserved;\n-        }\n-\n         fn get_filemap() -> codemap::filemap {\n             ret fm;\n         }\n@@ -111,133 +99,11 @@ fn new_reader(session sess, io::reader rdr,\n     let vec[str] strs = vec();\n     auto rd = reader(sess, file, _str::byte_len(file), 0u, -1 as char,\n                      filemap.start_pos, filemap.start_pos,\n-                     strs, keyword_table(),\n-                     reserved_word_table(),\n-                     filemap);\n+                     strs, filemap);\n     rd.init();\n     ret rd;\n }\n \n-fn keyword_table() -> std::map::hashmap[str, token::token] {\n-    auto keywords = new_str_hash[token::token]();\n-\n-    keywords.insert(\"mod\", token::MOD);\n-    keywords.insert(\"use\", token::USE);\n-    keywords.insert(\"meta\", token::META);\n-    keywords.insert(\"auth\", token::AUTH);\n-\n-    keywords.insert(\"syntax\", token::SYNTAX);\n-\n-    keywords.insert(\"if\", token::IF);\n-    keywords.insert(\"else\", token::ELSE);\n-    keywords.insert(\"while\", token::WHILE);\n-    keywords.insert(\"do\", token::DO);\n-    keywords.insert(\"alt\", token::ALT);\n-    keywords.insert(\"case\", token::CASE);\n-\n-    keywords.insert(\"for\", token::FOR);\n-    keywords.insert(\"each\", token::EACH);\n-    keywords.insert(\"break\", token::BREAK);\n-    keywords.insert(\"cont\", token::CONT);\n-    keywords.insert(\"put\", token::PUT);\n-    keywords.insert(\"ret\", token::RET);\n-    keywords.insert(\"be\", token::BE);\n-\n-    keywords.insert(\"fail\", token::FAIL);\n-    keywords.insert(\"drop\", token::DROP);\n-\n-    keywords.insert(\"type\", token::TYPE);\n-    keywords.insert(\"check\", token::CHECK);\n-    keywords.insert(\"assert\", token::ASSERT);\n-    keywords.insert(\"claim\", token::CLAIM);\n-    keywords.insert(\"prove\", token::PROVE);\n-\n-    keywords.insert(\"state\", token::STATE);\n-    keywords.insert(\"gc\", token::GC);\n-\n-    keywords.insert(\"unsafe\", token::UNSAFE);\n-\n-    keywords.insert(\"native\", token::NATIVE);\n-    keywords.insert(\"mutable\", token::MUTABLE);\n-    keywords.insert(\"auto\", token::AUTO);\n-\n-    keywords.insert(\"fn\", token::FN);\n-    keywords.insert(\"pred\", token::PRED);\n-    keywords.insert(\"iter\", token::ITER);\n-\n-    keywords.insert(\"import\", token::IMPORT);\n-    keywords.insert(\"export\", token::EXPORT);\n-\n-    keywords.insert(\"let\", token::LET);\n-    keywords.insert(\"const\", token::CONST);\n-\n-    keywords.insert(\"log\", token::LOG);\n-    keywords.insert(\"log_err\", token::LOG_ERR);\n-    keywords.insert(\"spawn\", token::SPAWN);\n-    keywords.insert(\"thread\", token::THREAD);\n-    keywords.insert(\"yield\", token::YIELD);\n-    keywords.insert(\"join\", token::JOIN);\n-\n-    keywords.insert(\"bool\", token::BOOL);\n-\n-    keywords.insert(\"int\", token::INT);\n-    keywords.insert(\"uint\", token::UINT);\n-    keywords.insert(\"float\", token::FLOAT);\n-\n-    keywords.insert(\"char\", token::CHAR);\n-    keywords.insert(\"str\", token::STR);\n-\n-\n-    keywords.insert(\"rec\", token::REC);\n-    keywords.insert(\"tup\", token::TUP);\n-    keywords.insert(\"tag\", token::TAG);\n-    keywords.insert(\"vec\", token::VEC);\n-    keywords.insert(\"any\", token::ANY);\n-\n-    keywords.insert(\"obj\", token::OBJ);\n-    keywords.insert(\"self\", token::SELF);\n-\n-    keywords.insert(\"port\", token::PORT);\n-    keywords.insert(\"chan\", token::CHAN);\n-\n-    keywords.insert(\"task\", token::TASK);\n-\n-    keywords.insert(\"true\", token::LIT_BOOL(true));\n-    keywords.insert(\"false\", token::LIT_BOOL(false));\n-\n-    keywords.insert(\"in\", token::IN);\n-\n-    keywords.insert(\"as\", token::AS);\n-    keywords.insert(\"with\", token::WITH);\n-\n-    keywords.insert(\"bind\", token::BIND);\n-\n-    keywords.insert(\"u8\", token::MACH(common::ty_u8));\n-    keywords.insert(\"u16\", token::MACH(common::ty_u16));\n-    keywords.insert(\"u32\", token::MACH(common::ty_u32));\n-    keywords.insert(\"u64\", token::MACH(common::ty_u64));\n-    keywords.insert(\"i8\", token::MACH(common::ty_i8));\n-    keywords.insert(\"i16\", token::MACH(common::ty_i16));\n-    keywords.insert(\"i32\", token::MACH(common::ty_i32));\n-    keywords.insert(\"i64\", token::MACH(common::ty_i64));\n-    keywords.insert(\"f32\", token::MACH(common::ty_f32));\n-    keywords.insert(\"f64\", token::MACH(common::ty_f64));\n-\n-    ret keywords;\n-}\n-\n-fn reserved_word_table() -> std::map::hashmap[str, ()] {\n-    auto reserved = new_str_hash[()]();\n-    reserved.insert(\"f16\", ());  // IEEE 754-2008 'binary16' interchange fmt\n-    reserved.insert(\"f80\", ());  // IEEE 754-1985 'extended'\n-    reserved.insert(\"f128\", ()); // IEEE 754-2008 'binary128'\n-    reserved.insert(\"m32\", ());  // IEEE 754-2008 'decimal32'\n-    reserved.insert(\"m64\", ());  // IEEE 754-2008 'decimal64'\n-    reserved.insert(\"m128\", ()); // IEEE 754-2008 'decimal128'\n-    reserved.insert(\"dec\", ());  // One of m32, m64, m128\n-    ret reserved;\n-}\n-\n fn in_range(char c, char lo, char hi) -> bool {\n     ret lo <= c && c <= hi;\n }\n@@ -604,17 +470,6 @@ fn next_token(reader rdr) -> token::token {\n             ret token::UNDERSCORE;\n         }\n \n-        auto kwds = rdr.get_keywords();\n-        if (kwds.contains_key(accum_str)) {\n-            ret kwds.get(accum_str);\n-        }\n-\n-        auto rsvd = rdr.get_reserved();\n-        if (rsvd.contains_key(accum_str)) {\n-            rdr.err(#fmt(\"reserved keyword: %s\", accum_str));\n-            fail;\n-        }\n-\n         ret token::IDENT(rdr.add_str(accum_str));\n     }\n "}, {"sha": "2cb00bcd86ad9446a20f22abfb37c0cfa3209fe7", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 606, "deletions": 800, "changes": 1406, "blob_url": "https://github.com/rust-lang/rust/blob/57ffa2a487ef12a4abf538efc2dd8192ca308271/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ffa2a487ef12a4abf538efc2dd8192ca308271/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=57ffa2a487ef12a4abf538efc2dd8192ca308271", "patch": "@@ -35,6 +35,7 @@ state type parser =\n           fn get_span() -> common::span;\n           fn get_lo_pos() -> uint;\n           fn get_hi_pos() -> uint;\n+          fn get_last_lo_pos() -> uint;\n           fn next_def_id() -> ast::def_id;\n           fn set_def(ast::def_num);\n           fn get_prec_table() -> vec[op_spec];\n@@ -56,6 +57,7 @@ fn new_parser(session::session sess,\n                            mutable token::token tok,\n                            mutable uint lo,\n                            mutable uint hi,\n+                           mutable uint last_lo,\n                            mutable ast::def_num def,\n                            mutable restriction res,\n                            ast::crate_num crate,\n@@ -70,6 +72,7 @@ fn new_parser(session::session sess,\n             fn bump() {\n                 // log rdr.get_filename()\n                 //   + \":\" + common::istr(lo.line as int);\n+                last_lo = lo;\n                 tok = lexer::next_token(rdr);\n                 lo = rdr.get_mark_chpos();\n                 hi = rdr.get_chpos();\n@@ -94,6 +97,7 @@ fn new_parser(session::session sess,\n             fn get_span() -> common::span { ret rec(lo=lo, hi=hi); }\n             fn get_lo_pos() -> uint { ret lo; }\n             fn get_hi_pos() -> uint { ret hi; }\n+            fn get_last_lo_pos() -> uint { ret last_lo; }\n \n             fn next_def_id() -> ast::def_id {\n                 def += 1;\n@@ -151,8 +155,8 @@ fn new_parser(session::session sess,\n     lexer::consume_any_whitespace(rdr);\n     auto npos = rdr.get_chpos();\n     ret stdio_parser(sess, env, ftype, lexer::next_token(rdr),\n-                     npos, npos, initial_def._1, UNRESTRICTED, initial_def._0,\n-                     rdr, prec_table(), next_ann);\n+                     npos, npos, npos, initial_def._1, UNRESTRICTED,\n+                     initial_def._0, rdr, prec_table(), next_ann);\n }\n \n fn unexpected(parser p, token::token t) {\n@@ -212,6 +216,30 @@ fn parse_str_lit_or_env_ident(parser p) -> ast::ident {\n     }\n }\n \n+fn is_word(&parser p, &str word) -> bool {\n+    ret alt (p.peek()) {\n+        case (token::IDENT(?sid)) { _str::eq(word, p.get_str(sid)) }\n+        case (_) { false }\n+    };\n+}\n+fn eat_word(&parser p, &str word) -> bool {\n+    alt (p.peek()) {\n+        case (token::IDENT(?sid)) {\n+            if (_str::eq(word, p.get_str(sid))) {\n+                p.bump();\n+                ret true;\n+            } else { ret false; }\n+            \n+        }\n+        case (_) { ret false; }\n+    }\n+}\n+fn expect_word(&parser p, &str word) {\n+    if (!eat_word(p, word)) {\n+        p.err(\"expecting \" + word + \", found \" +\n+              token::to_str(p.get_reader(), p.peek()));\n+    }\n+}\n \n fn parse_ty_fn(ast::proto proto, parser p, uint lo)\n     -> ast::ty_ {\n@@ -221,8 +249,7 @@ fn parse_ty_fn(ast::proto proto, parser p, uint lo)\n             p.bump();\n             mode = ast::alias;\n \n-            if (p.peek() == token::MUTABLE) {\n-                p.bump();\n+            if (eat_word(p, \"mutable\")) {\n                 // TODO: handle mutable alias args\n             }\n         } else {\n@@ -261,17 +288,13 @@ fn parse_ty_fn(ast::proto proto, parser p, uint lo)\n }\n \n fn parse_proto(parser p) -> ast::proto {\n-    alt (p.peek()) {\n-        case (token::ITER) { p.bump(); ret ast::proto_iter; }\n-        case (token::FN) { p.bump(); ret ast::proto_fn; }\n-        case (token::PRED) { p.bump(); ret ast::proto_fn; }\n-        case (?t) { unexpected(p, t); }\n-    }\n-    fail;\n+    if      (eat_word(p, \"iter\")) { ret ast::proto_iter; }\n+    else if (eat_word(p, \"fn\"))   { ret ast::proto_fn; }\n+    else if (eat_word(p, \"pred\")) { ret ast::proto_fn; }\n+    else                          { unexpected(p, p.peek()); }\n }\n \n fn parse_ty_obj(parser p, &mutable uint hi) -> ast::ty_ {\n-    expect(p, token::OBJ);\n     fn parse_method_sig(parser p) -> ast::ty_method {\n         auto flo = p.get_lo_pos();\n \n@@ -367,130 +390,105 @@ fn parse_ty(parser p) -> @ast::ty {\n     // FIXME: do something with this\n     let ast::layer lyr = parse_layer(p);\n \n-    alt (p.peek()) {\n-        case (token::BOOL) { p.bump(); t = ast::ty_bool; }\n-        case (token::INT) { p.bump(); t = ast::ty_int; }\n-        case (token::UINT) { p.bump(); t = ast::ty_uint; }\n-        case (token::FLOAT) { p.bump(); t = ast::ty_float; }\n-        case (token::STR) { p.bump(); t = ast::ty_str; }\n-        case (token::CHAR) { p.bump(); t = ast::ty_char; }\n-        case (token::MACH(?tm)) { p.bump(); t = ast::ty_machine(tm); }\n-\n-        case (token::LPAREN) {\n-            p.bump();\n-            alt (p.peek()) {\n-                case (token::RPAREN) {\n-                    hi = p.get_hi_pos();\n-                    p.bump();\n-                    t = ast::ty_nil;\n-                }\n-                case (_) {\n-                    t = parse_ty(p).node;\n-                    hi = p.get_hi_pos();\n-                    expect(p, token::RPAREN);\n-                }\n+    let ast::ty t;\n+    if      (eat_word(p, \"bool\")) { t = ast::ty_bool; }\n+    else if (eat_word(p, \"int\")) { t = ast::ty_int; }\n+    else if (eat_word(p, \"uint\")) { t = ast::ty_uint; }\n+    else if (eat_word(p, \"float\")) { t = ast::ty_float; }\n+    else if (eat_word(p, \"str\")) { t = ast::ty_str; }\n+    else if (eat_word(p, \"char\")) { t = ast::ty_char; }\n+    else if (eat_word(p, \"i8\")) { t = ast::ty_machine(common::ty_i8); }\n+    else if (eat_word(p, \"i16\")) { t = ast::ty_machine(common::ty_i16); }\n+    else if (eat_word(p, \"i32\")) { t = ast::ty_machine(common::ty_i32); }\n+    else if (eat_word(p, \"i64\")) { t = ast::ty_machine(common::ty_i64); }\n+    else if (eat_word(p, \"u8\")) { t = ast::ty_machine(common::ty_u8); }\n+    else if (eat_word(p, \"u16\")) { t = ast::ty_machine(common::ty_u16); }\n+    else if (eat_word(p, \"u32\")) { t = ast::ty_machine(common::ty_u32); }\n+    else if (eat_word(p, \"u64\")) { t = ast::ty_machine(common::ty_u64); }\n+    else if (eat_word(p, \"f32\")) { t = ast::ty_machine(common::ty_f32); }\n+    else if (eat_word(p, \"f64\")) { t = ast::ty_machine(common::ty_f64); }\n+    else if (p.peek() == token::LPAREN) {\n+        p.bump();\n+        alt (p.peek()) {\n+            case (token::RPAREN) {\n+                hi = p.get_hi_pos();\n+                p.bump();\n+                t = ast::ty_nil;\n             }\n-        }\n-\n-        case (token::AT) {\n-            p.bump();\n-            auto mt = parse_mt(p);\n-            hi = mt.ty.span.hi;\n-            t = ast::ty_box(mt);\n-        }\n-\n-        case (token::VEC) {\n-            p.bump();\n-            expect(p, token::LBRACKET);\n-            t = ast::ty_vec(parse_mt(p));\n-            hi = p.get_hi_pos();\n-            expect(p, token::RBRACKET);\n-        }\n-\n-        case (token::TUP) {\n-            p.bump();\n-            auto f = parse_mt; // FIXME: trans_const_lval bug\n-            auto elems = parse_seq[ast::mt] (token::LPAREN,\n-                                            token::RPAREN,\n-                                            some(token::COMMA), f, p);\n-            hi = elems.span.hi;\n-            t = ast::ty_tup(elems.node);\n-        }\n-\n-        case (token::REC) {\n-            p.bump();\n-            auto f = parse_ty_field; // FIXME: trans_const_lval bug\n-            auto elems =\n-                parse_seq[ast::ty_field](token::LPAREN,\n-                                        token::RPAREN,\n-                                        some(token::COMMA),\n-                                        f, p);\n-            hi = elems.span.hi;\n-            t = ast::ty_rec(elems.node);\n-        }\n-\n-        case (token::FN) {\n-            auto flo = p.get_lo_pos();\n-            p.bump();\n-            t = parse_ty_fn(ast::proto_fn, p, flo);\n-            alt (t) {\n-                case (ast::ty_fn(_, _, ?out)) {\n-                    hi = out.span.hi;\n-                }\n+            case (_) {\n+                t = parse_ty(p).node;\n+                hi = p.get_hi_pos();\n+                expect(p, token::RPAREN);\n             }\n         }\n-\n-        case (token::ITER) {\n-            auto flo = p.get_lo_pos();\n-            p.bump();\n-            t = parse_ty_fn(ast::proto_iter, p, flo);\n-            alt (t) {\n-                case (ast::ty_fn(_, _, ?out)) {\n-                    hi = out.span.hi;\n-                }\n+    } else if (p.peek() == token::AT) {\n+        p.bump();\n+        auto mt = parse_mt(p);\n+        hi = mt.ty.span.hi;\n+        t = ast::ty_box(mt);\n+    } else if (eat_word(p, \"vec\")) {\n+        expect(p, token::LBRACKET);\n+        t = ast::ty_vec(parse_mt(p));\n+        hi = p.get_hi_pos();\n+        expect(p, token::RBRACKET);\n+    } else if (eat_word(p, \"tup\")) {\n+        auto f = parse_mt; // FIXME: trans_const_lval bug\n+        auto elems = parse_seq[ast::mt] (token::LPAREN,\n+                                         token::RPAREN,\n+                                         some(token::COMMA), f, p);\n+        hi = elems.span.hi;\n+        t = ast::ty_tup(elems.node);\n+    } else if (eat_word(p, \"rec\")) {\n+        auto f = parse_ty_field; // FIXME: trans_const_lval bug\n+        auto elems =\n+            parse_seq[ast::ty_field](token::LPAREN,\n+                                     token::RPAREN,\n+                                     some(token::COMMA),\n+                                     f, p);\n+        hi = elems.span.hi;\n+        t = ast::ty_rec(elems.node);\n+    } else if (eat_word(p, \"fn\")) {\n+        auto flo = p.get_last_lo_pos();\n+        t = parse_ty_fn(ast::proto_fn, p, flo);\n+        alt (t) {\n+            case (ast::ty_fn(_, _, ?out)) {\n+                hi = out.span.hi;\n             }\n         }\n-\n-        case (token::OBJ) {\n-            t = parse_ty_obj(p, hi);\n-        }\n-\n-        case (token::PORT) {\n-            p.bump();\n-            expect(p, token::LBRACKET);\n-            t = ast::ty_port(parse_ty(p));\n-            hi = p.get_hi_pos();\n-            expect(p, token::RBRACKET);\n-        }\n-\n-        case (token::CHAN) {\n-            p.bump();\n-            expect(p, token::LBRACKET);\n-            t = ast::ty_chan(parse_ty(p));\n-            hi = p.get_hi_pos();\n-            expect(p, token::RBRACKET);\n-        }\n-\n-        case (token::IDENT(_)) {\n-            auto path = parse_path(p);\n-            t = ast::ty_path(path, p.get_ann());\n-            hi = path.span.hi;\n-        }\n-\n-        case (token::MUTABLE) {\n-            p.bump();\n-            p.get_session().span_warn(p.get_span(),\n-                \"ignoring deprecated 'mutable' type constructor\");\n-            auto typ = parse_ty(p);\n-            t = typ.node;\n-            hi = typ.span.hi;\n-        }\n-\n-        case (_) {\n-            p.err(\"expecting type\");\n-            t = ast::ty_nil;\n-            fail;\n+    } else if (eat_word(p, \"iter\")) {\n+        auto flo = p.get_last_lo_pos();\n+        t = parse_ty_fn(ast::proto_iter, p, flo);\n+        alt (t) {\n+            case (ast::ty_fn(_, _, ?out)) {\n+                hi = out.span.hi;\n+            }\n         }\n+    } else if (eat_word(p, \"obj\")) {\n+        t = parse_ty_obj(p, hi);\n+    } else if (eat_word(p, \"port\")) {\n+        expect(p, token::LBRACKET);\n+        t = ast::ty_port(parse_ty(p));\n+        hi = p.get_hi_pos();\n+        expect(p, token::RBRACKET);\n+    } else if (eat_word(p, \"chan\")) {\n+        expect(p, token::LBRACKET);\n+        t = ast::ty_chan(parse_ty(p));\n+        hi = p.get_hi_pos();\n+        expect(p, token::RBRACKET);\n+    } else if (eat_word(p, \"mutable\")) {\n+        p.get_session().span_warn(p.get_span(),\n+            \"ignoring deprecated 'mutable' type constructor\");\n+        auto typ = parse_ty(p);\n+        t = typ.node;\n+        hi = typ.span.hi;\n+    } else if (is_ident(p.peek())) {\n+        auto path = parse_path(p);\n+        t = ast::ty_path(path, p.get_ann());\n+        hi = path.span.hi;\n+    } else {\n+        p.err(\"expecting type\");\n+        t = ast::ty_nil;\n+        fail;\n     }\n \n     ret parse_ty_constrs(@spanned(lo, hi, t), p);\n@@ -502,10 +500,8 @@ fn parse_arg(parser p) -> ast::arg {\n         m = ast::alias;\n         p.bump();\n \n-        if (p.peek() == token::MUTABLE) {\n-            // TODO: handle mutable alias args\n-            p.bump();\n-        }\n+        // TODO: handle mutable alias args\n+        eat_word(p, \"mutable\");\n     }\n     let @ast::ty t = parse_ty(p);\n     let ast::ident i = parse_ident(p);\n@@ -555,41 +551,43 @@ fn parse_seq[T](token::token bra,\n fn parse_lit(parser p) -> ast::lit {\n     auto sp = p.get_span();\n     let ast::lit_ lit = ast::lit_nil;\n-    alt (p.peek()) {\n-        case (token::LIT_INT(?i)) {\n-            p.bump();\n-            lit = ast::lit_int(i);\n-        }\n-        case (token::LIT_UINT(?u)) {\n-            p.bump();\n-            lit = ast::lit_uint(u);\n-        }\n-        case (token::LIT_FLOAT(?s)) {\n-            p.bump();\n-            lit = ast::lit_float(p.get_str(s));\n-        }\n-        case (token::LIT_MACH_INT(?tm, ?i)) {\n-            p.bump();\n-            lit = ast::lit_mach_int(tm, i);\n-        }\n-        case (token::LIT_MACH_FLOAT(?tm, ?s)) {\n-            p.bump();\n-            lit = ast::lit_mach_float(tm, p.get_str(s));\n-        }\n-        case (token::LIT_CHAR(?c)) {\n-            p.bump();\n-            lit = ast::lit_char(c);\n-        }\n-        case (token::LIT_BOOL(?b)) {\n-            p.bump();\n-            lit = ast::lit_bool(b);\n-        }\n-        case (token::LIT_STR(?s)) {\n-            p.bump();\n-            lit = ast::lit_str(p.get_str(s));\n-        }\n-        case (?t) {\n-            unexpected(p, t);\n+    if (eat_word(p, \"true\")) {\n+        lit = ast::lit_bool(true);\n+    } else if (eat_word(p, \"false\")) {\n+        lit = ast::lit_bool(false);\n+    } else {\n+        alt (p.peek()) {\n+            case (token::LIT_INT(?i)) {\n+                p.bump();\n+                lit = ast::lit_int(i);\n+            }\n+            case (token::LIT_UINT(?u)) {\n+                p.bump();\n+                lit = ast::lit_uint(u);\n+            }\n+            case (token::LIT_FLOAT(?s)) {\n+                p.bump();\n+                lit = ast::lit_float(p.get_str(s));\n+            }\n+            case (token::LIT_MACH_INT(?tm, ?i)) {\n+                p.bump();\n+                lit = ast::lit_mach_int(tm, i);\n+            }\n+            case (token::LIT_MACH_FLOAT(?tm, ?s)) {\n+                p.bump();\n+                lit = ast::lit_mach_float(tm, p.get_str(s));\n+            }\n+            case (token::LIT_CHAR(?c)) {\n+                p.bump();\n+                lit = ast::lit_char(c);\n+            }\n+            case (token::LIT_STR(?s)) {\n+                p.bump();\n+                lit = ast::lit_str(p.get_str(s));\n+            }\n+            case (?t) {\n+                unexpected(p, t);\n+            }\n         }\n     }\n     ret rec(node=lit, span=sp);\n@@ -643,8 +641,7 @@ fn parse_path(parser p) -> ast::path {\n }\n \n fn parse_mutability(parser p) -> ast::mutability {\n-    if (p.peek() == token::MUTABLE) {\n-        p.bump();\n+    if (eat_word(p, \"mutable\")) {\n         if (p.peek() == token::QUES) {\n             p.bump();\n             ret ast::maybe_mut;\n@@ -672,259 +669,195 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n     auto lit = @spanned(lo, hi, ast::lit_nil);\n     let ast::expr_ ex = ast::expr_lit(lit, p.get_ann());\n \n-    alt (p.peek()) {\n-\n-        case (token::IDENT(_)) {\n-            auto pth = parse_path(p);\n-            hi = pth.span.hi;\n-            ex = ast::expr_path(pth, p.get_ann());\n-        }\n-\n-        case (token::LPAREN) {\n-            p.bump();\n-            alt (p.peek()) {\n-                case (token::RPAREN) {\n-                    hi = p.get_hi_pos();\n-                    p.bump();\n-                    auto lit = @spanned(lo, hi, ast::lit_nil);\n-                    ret @spanned(lo, hi,\n-                                 ast::expr_lit(lit, p.get_ann()));\n-                }\n-                case (_) { /* fall through */ }\n+    if (p.peek() == token::LPAREN) {\n+        p.bump();\n+        alt (p.peek()) {\n+            case (token::RPAREN) {\n+                hi = p.get_hi_pos();\n+                p.bump();\n+                auto lit = @spanned(lo, hi, ast::lit_nil);\n+                ret @spanned(lo, hi,\n+                             ast::expr_lit(lit, p.get_ann()));\n             }\n+            case (_) { /* fall through */ }\n+        }\n+        auto e = parse_expr(p);\n+        hi = p.get_hi_pos();\n+        expect(p, token::RPAREN);\n+        ret @spanned(lo, hi, e.node);\n+    } else if (eat_word(p, \"tup\")) {\n+        fn parse_elt(parser p) -> ast::elt {\n+            auto m = parse_mutability(p);\n             auto e = parse_expr(p);\n-            hi = p.get_hi_pos();\n-            expect(p, token::RPAREN);\n-            ret @spanned(lo, hi, e.node);\n-        }\n-\n-        case (token::TUP) {\n-            p.bump();\n-            fn parse_elt(parser p) -> ast::elt {\n-                auto m = parse_mutability(p);\n-                auto e = parse_expr(p);\n-                ret rec(mut=m, expr=e);\n-            }\n-            auto pf = parse_elt;\n-            auto es =\n-                parse_seq[ast::elt](token::LPAREN,\n-                                   token::RPAREN,\n-                                   some(token::COMMA),\n-                                   pf, p);\n-            hi = es.span.hi;\n-            ex = ast::expr_tup(es.node, p.get_ann());\n-        }\n-\n-        case (token::VEC) {\n-            p.bump();\n-            auto pf = parse_expr;\n-\n-            expect(p, token::LPAREN);\n-            auto mut = parse_mutability(p);\n-\n-            auto es = parse_seq_to_end[@ast::expr](token::RPAREN,\n-                                                  some(token::COMMA),\n-                                                  pf, hi, p);\n-            ex = ast::expr_vec(es, mut, p.get_ann());\n-        }\n-\n-        case (token::REC) {\n-            p.bump();\n-            expect(p, token::LPAREN);\n-            auto fields = vec(parse_field(p));\n-\n-            auto more = true;\n-            auto base = none[@ast::expr];\n-            while (more) {\n-                alt (p.peek()) {\n-                    case (token::RPAREN) {\n-                        hi = p.get_hi_pos();\n-                        p.bump();\n-                        more = false;\n-                    }\n-                    case (token::WITH) {\n-                        p.bump();\n-                        base = some[@ast::expr](parse_expr(p));\n-                        hi = p.get_hi_pos();\n-                        expect(p, token::RPAREN);\n-                        more = false;\n-                    }\n-                    case (token::COMMA) {\n-                        p.bump();\n-                        fields += vec(parse_field(p));\n-                    }\n-                    case (?t) {\n-                        unexpected(p, t);\n-                    }\n-                }\n-\n-            }\n-\n-            ex = ast::expr_rec(fields, base, p.get_ann());\n-        }\n-\n-        case (token::BIND) {\n-            p.bump();\n-            auto e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n-            fn parse_expr_opt(parser p) -> option::t[@ast::expr] {\n-                alt (p.peek()) {\n-                    case (token::UNDERSCORE) {\n-                        p.bump();\n-                        ret none[@ast::expr];\n-                    }\n-                    case (_) {\n-                        ret some[@ast::expr](parse_expr(p));\n-                    }\n-                }\n+            ret rec(mut=m, expr=e);\n+        }\n+        auto pf = parse_elt;\n+        auto es =\n+            parse_seq[ast::elt](token::LPAREN,\n+                                token::RPAREN,\n+                                some(token::COMMA),\n+                                pf, p);\n+        hi = es.span.hi;\n+        ex = ast::expr_tup(es.node, p.get_ann());\n+    } else if (eat_word(p, \"vec\")) {\n+        auto pf = parse_expr;\n+\n+        expect(p, token::LPAREN);\n+        auto mut = parse_mutability(p);\n+\n+        auto es = parse_seq_to_end[@ast::expr](token::RPAREN,\n+                                               some(token::COMMA),\n+                                               pf, hi, p);\n+        ex = ast::expr_vec(es, mut, p.get_ann());\n+    } else if (eat_word(p, \"rec\")) {\n+        expect(p, token::LPAREN);\n+        auto fields = vec(parse_field(p));\n+\n+        auto more = true;\n+        auto base = none[@ast::expr];\n+        while (more) {\n+            if (p.peek() == token::RPAREN) {\n+                hi = p.get_hi_pos();\n+                p.bump();\n+                more = false;\n+            } else if (eat_word(p, \"with\")) {\n+                base = some[@ast::expr](parse_expr(p));\n+                hi = p.get_hi_pos();\n+                expect(p, token::RPAREN);\n+                more = false;\n+            } else if (p.peek() == token::COMMA) {\n+                p.bump();\n+                fields += vec(parse_field(p));\n+            } else {\n+                unexpected(p, p.peek());\n             }\n \n-            auto pf = parse_expr_opt;\n-            auto es = parse_seq[option::t[@ast::expr]](token::LPAREN,\n-                                                     token::RPAREN,\n-                                                     some(token::COMMA),\n-                                                     pf, p);\n-            hi = es.span.hi;\n-            ex = ast::expr_bind(e, es.node, p.get_ann());\n         }\n \n-        case (token::POUND) {\n-            p.bump();\n-            auto pth = parse_path(p);\n-            auto pf = parse_expr;\n-            auto es = parse_seq[@ast::expr](token::LPAREN,\n-                                           token::RPAREN,\n-                                           some(token::COMMA),\n-                                           pf, p);\n-            hi = es.span.hi;\n-            ex = expand_syntax_ext(p, es.span, pth, es.node,\n-                                   none[str]);\n-        }\n-\n-        case (token::FAIL) {\n-            p.bump();\n-            ex = ast::expr_fail(p.get_ann());\n-        }\n-\n-        case (token::LOG) {\n-            p.bump();\n-            auto e = parse_expr(p);\n-            auto hi = e.span.hi;\n-            ex = ast::expr_log(1, e, p.get_ann());\n-        }\n-\n-        case (token::LOG_ERR) {\n-            p.bump();\n-            auto e = parse_expr(p);\n-            auto hi = e.span.hi;\n-            ex = ast::expr_log(0, e, p.get_ann());\n-        }\n-\n-        case (token::ASSERT) {\n-            p.bump();\n-            auto e = parse_expr(p);\n-            auto hi = e.span.hi;\n-            ex = ast::expr_assert(e, p.get_ann());\n-        }\n-\n-        case (token::CHECK) {\n-            p.bump();\n-            /* Should be a predicate (pure boolean function) applied to \n-             arguments that are all either slot variables or literals.\n-            but the typechecker enforces that. */\n-            auto e = parse_expr(p);\n-            auto hi = e.span.hi;\n-            ex = ast::expr_check(e, p.get_ann());\n-        } \n-\n-        case (token::RET) {\n-            p.bump();\n+        ex = ast::expr_rec(fields, base, p.get_ann());\n+    } else if (eat_word(p, \"bind\")) {\n+        auto e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n+        fn parse_expr_opt(parser p) -> option::t[@ast::expr] {\n             alt (p.peek()) {\n-                case (token::SEMI) {\n-                    ex = ast::expr_ret(none[@ast::expr], p.get_ann());\n+                case (token::UNDERSCORE) {\n+                    p.bump();\n+                    ret none[@ast::expr];\n                 }\n                 case (_) {\n-                    auto e = parse_expr(p);\n-                    hi = e.span.hi;\n-                    ex = ast::expr_ret(some[@ast::expr](e), p.get_ann());\n+                    ret some[@ast::expr](parse_expr(p));\n                 }\n             }\n         }\n \n-        case (token::BREAK) {\n-            p.bump();\n-            ex = ast::expr_break(p.get_ann());\n-        }\n-\n-        case (token::CONT) {\n-            p.bump();\n-            ex = ast::expr_cont(p.get_ann());\n-        }\n-\n-        case (token::PUT) {\n-            p.bump();\n-            alt (p.peek()) {\n-                case (token::SEMI) {\n-                    ex = ast::expr_put(none[@ast::expr], p.get_ann());\n-                }\n-                case (_) {\n-                    auto e = parse_expr(p);\n-                    hi = e.span.hi;\n-                    ex = ast::expr_put(some[@ast::expr](e), p.get_ann());\n-                }\n+        auto pf = parse_expr_opt;\n+        auto es = parse_seq[option::t[@ast::expr]](token::LPAREN,\n+                                                   token::RPAREN,\n+                                                   some(token::COMMA),\n+                                                   pf, p);\n+        hi = es.span.hi;\n+        ex = ast::expr_bind(e, es.node, p.get_ann());\n+    } else if (p.peek() == token::POUND) {\n+        p.bump();\n+        auto pth = parse_path(p);\n+        auto pf = parse_expr;\n+        auto es = parse_seq[@ast::expr](token::LPAREN,\n+                                        token::RPAREN,\n+                                        some(token::COMMA),\n+                                        pf, p);\n+        hi = es.span.hi;\n+        ex = expand_syntax_ext(p, es.span, pth, es.node,\n+                               none[str]);\n+    } else if (eat_word(p, \"fail\")) {\n+        p.bump();\n+        ex = ast::expr_fail(p.get_ann());\n+    } else if (eat_word(p, \"log\")) {\n+        auto e = parse_expr(p);\n+        auto hi = e.span.hi;\n+        ex = ast::expr_log(1, e, p.get_ann());\n+    } else if (eat_word(p, \"log_err\")) {\n+        auto e = parse_expr(p);\n+        auto hi = e.span.hi;\n+        ex = ast::expr_log(0, e, p.get_ann());\n+    } else if (eat_word(p, \"assert\")) {\n+        auto e = parse_expr(p);\n+        auto hi = e.span.hi;\n+        ex = ast::expr_assert(e, p.get_ann());\n+    } else if (eat_word(p, \"check\")) {\n+        /* Should be a predicate (pure boolean function) applied to \n+           arguments that are all either slot variables or literals.\n+           but the typechecker enforces that. */\n+        auto e = parse_expr(p);\n+        auto hi = e.span.hi;\n+        ex = ast::expr_check(e, p.get_ann());\n+    } else if (eat_word(p, \"ret\")) {\n+        alt (p.peek()) {\n+            case (token::SEMI) {\n+                ex = ast::expr_ret(none[@ast::expr], p.get_ann());\n+            }\n+            case (_) {\n+                auto e = parse_expr(p);\n+                hi = e.span.hi;\n+                ex = ast::expr_ret(some[@ast::expr](e), p.get_ann());\n             }\n         }\n-\n-        case (token::BE) {\n-            p.bump();\n-            auto e = parse_expr(p);\n-            // FIXME: Is this the right place for this check?\n-            if /*check*/ (ast::is_call_expr(e)) {\n-                    hi = e.span.hi;\n-                    ex = ast::expr_be(e, p.get_ann());\n+    } else if (eat_word(p, \"break\")) {\n+        ex = ast::expr_break(p.get_ann());\n+    } else if (eat_word(p, \"cont\")) {\n+        ex = ast::expr_cont(p.get_ann());\n+    } else if (eat_word(p, \"put\")) {\n+        alt (p.peek()) {\n+            case (token::SEMI) {\n+                ex = ast::expr_put(none[@ast::expr], p.get_ann());\n             }\n-            else {\n-                p.err(\"Non-call expression in tail call\");\n+            case (_) {\n+                auto e = parse_expr(p);\n+                hi = e.span.hi;\n+                ex = ast::expr_put(some[@ast::expr](e), p.get_ann());\n             }\n         }\n-\n-        case (token::PORT) {\n-            p.bump();\n-            expect(p, token::LPAREN);\n-            expect(p, token::RPAREN);\n-            hi = p.get_hi_pos();\n-            ex = ast::expr_port(p.get_ann());\n-        }\n-\n-        case (token::CHAN) {\n-            p.bump();\n-            expect(p, token::LPAREN);\n-            auto e = parse_expr(p);\n+    } else if (eat_word(p, \"be\")) {\n+        auto e = parse_expr(p);\n+        // FIXME: Is this the right place for this check?\n+        if /*check*/ (ast::is_call_expr(e)) {\n             hi = e.span.hi;\n-            expect(p, token::RPAREN);\n-            ex = ast::expr_chan(e, p.get_ann());\n-        }\n-\n-        case (token::SELF) {\n-            log \"parsing a self-call...\";\n-\n-            p.bump();\n-            expect(p, token::DOT);\n-            // The rest is a call expression.\n-            let @ast::expr f = parse_self_method(p);\n-            auto pf = parse_expr;\n-            auto es = parse_seq[@ast::expr](token::LPAREN,\n-                                           token::RPAREN,\n-                                           some(token::COMMA),\n-                                           pf, p);\n-            hi = es.span.hi;\n-            ex = ast::expr_call(f, es.node, p.get_ann());\n-        }\n-\n-        case (_) {\n-            auto lit = parse_lit(p);\n-            hi = lit.span.hi;\n-            ex = ast::expr_lit(@lit, p.get_ann());\n-        }\n+            ex = ast::expr_be(e, p.get_ann());\n+        }\n+        else {\n+            p.err(\"Non-call expression in tail call\");\n+        }\n+    } else if (eat_word(p, \"port\")) {\n+        expect(p, token::LPAREN);\n+        expect(p, token::RPAREN);\n+        hi = p.get_hi_pos();\n+        ex = ast::expr_port(p.get_ann());\n+    } else if (eat_word(p, \"chan\")) {\n+        expect(p, token::LPAREN);\n+        auto e = parse_expr(p);\n+        hi = e.span.hi;\n+        expect(p, token::RPAREN);\n+        ex = ast::expr_chan(e, p.get_ann());\n+    } else if (eat_word(p, \"self\")) {\n+        log \"parsing a self-call...\";\n+\n+        expect(p, token::DOT);\n+        // The rest is a call expression.\n+        let @ast::expr f = parse_self_method(p);\n+        auto pf = parse_expr;\n+        auto es = parse_seq[@ast::expr](token::LPAREN,\n+                                        token::RPAREN,\n+                                        some(token::COMMA),\n+                                        pf, p);\n+        hi = es.span.hi;\n+        ex = ast::expr_call(f, es.node, p.get_ann());\n+    } else if (is_ident(p.peek()) && !is_word(p, \"true\") &&\n+               !is_word(p, \"false\")) {\n+        auto pth = parse_path(p);\n+        hi = pth.span.hi;\n+        ex = ast::expr_path(pth, p.get_ann());\n+    } else {\n+        auto lit = parse_lit(p);\n+        hi = lit.span.hi;\n+        ex = ast::expr_lit(@lit, p.get_ann());\n     }\n \n     ret @spanned(lo, hi, ex);\n@@ -1031,8 +964,7 @@ fn parse_dot_or_call_expr(parser p) -> @ast::expr {\n \n fn parse_prefix_expr(parser p) -> @ast::expr {\n \n-    if (p.peek() == token::MUTABLE) {\n-        p.bump();\n+    if (eat_word(p, \"mutable\")) {\n         p.get_session().span_warn(p.get_span(),\n             \"ignoring deprecated 'mutable' prefix operator\");\n     }\n@@ -1113,9 +1045,7 @@ fn prec_table() -> vec[op_spec] {\n             rec(tok=token::BINOP(token::AND), op=ast::bitand, prec=8),\n             rec(tok=token::BINOP(token::CARET), op=ast::bitxor, prec=6),\n             rec(tok=token::BINOP(token::OR), op=ast::bitor, prec=6),\n-            // ast::mul is a bogus placeholder here, AS is special\n-            // cased in parse_more_binops\n-            rec(tok=token::AS, op=ast::mul, prec=5),\n+            // 'as' sits between here with 5\n             rec(tok=token::LT, op=ast::lt, prec=4),\n             rec(tok=token::LE, op=ast::le, prec=4),\n             rec(tok=token::GE, op=ast::ge, prec=4),\n@@ -1130,35 +1060,28 @@ fn parse_binops(parser p) -> @ast::expr {\n     ret parse_more_binops(p, parse_prefix_expr(p), 0);\n }\n \n+const int as_prec = 5;\n+\n fn parse_more_binops(parser p, @ast::expr lhs, int min_prec)\n     -> @ast::expr {\n-    // Magic nonsense to work around rustboot bug\n-    fn op_eq(token::token a, token::token b) -> bool {\n-        if (a == b) {ret true;}\n-        else {ret false;}\n-    }\n     auto peeked = p.peek();\n     for (op_spec cur in p.get_prec_table()) {\n-        if (cur.prec > min_prec && op_eq(cur.tok, peeked)) {\n+        if (cur.prec > min_prec && cur.tok == peeked) {\n             p.bump();\n-            alt (cur.tok) {\n-                case (token::AS) {\n-                    auto rhs = parse_ty(p);\n-                    auto _as = ast::expr_cast(lhs, rhs, p.get_ann());\n-                    auto span = @spanned(lhs.span.lo, rhs.span.hi, _as);\n-                    ret parse_more_binops(p, span, min_prec);\n-                }\n-                case (_) {\n-                    auto rhs = parse_more_binops(p, parse_prefix_expr(p),\n-                                                 cur.prec);\n-                    auto bin = ast::expr_binary(cur.op, lhs, rhs,\n-                                               p.get_ann());\n-                    auto span = @spanned(lhs.span.lo, rhs.span.hi, bin);\n-                    ret parse_more_binops(p, span, min_prec);\n-                }\n-            }\n+            auto rhs = parse_more_binops(p, parse_prefix_expr(p),\n+                                         cur.prec);\n+            auto bin = ast::expr_binary(cur.op, lhs, rhs,\n+                                        p.get_ann());\n+            auto span = @spanned(lhs.span.lo, rhs.span.hi, bin);\n+            ret parse_more_binops(p, span, min_prec);\n         }\n     }\n+    if (as_prec > min_prec && eat_word(p, \"as\")) {\n+        auto rhs = parse_ty(p);\n+        auto _as = ast::expr_cast(lhs, rhs, p.get_ann());\n+        auto span = @spanned(lhs.span.lo, rhs.span.hi, _as);\n+        ret parse_more_binops(p, span, min_prec);\n+    }\n     ret lhs;\n }\n \n@@ -1210,45 +1133,37 @@ fn parse_assign_expr(parser p) -> @ast::expr {\n }\n \n fn parse_if_expr(parser p) -> @ast::expr {\n-    auto lo = p.get_lo_pos();\n+    auto lo = p.get_last_lo_pos();\n \n-    expect(p, token::IF);\n     expect(p, token::LPAREN);\n     auto cond = parse_expr(p);\n     expect(p, token::RPAREN);\n     auto thn = parse_block(p);\n     let option::t[@ast::expr] els = none[@ast::expr];\n     auto hi = thn.span.hi;\n-    alt (p.peek()) {\n-        case (token::ELSE) {\n-            auto elexpr = parse_else_expr(p);\n-            els = some(elexpr);\n-            hi = elexpr.span.hi;\n-        }\n-        case (_) { /* fall through */ }\n+    if (eat_word(p, \"else\")) {\n+        auto elexpr = parse_else_expr(p);\n+        els = some(elexpr);\n+        hi = elexpr.span.hi;\n     }\n \n     ret @spanned(lo, hi, ast::expr_if(cond, thn, els, p.get_ann()));\n }\n \n fn parse_else_expr(parser p) -> @ast::expr {\n-    expect(p, token::ELSE);\n-    alt (p.peek()) {\n-        case (token::IF) {\n-            ret parse_if_expr(p);\n-        }\n-        case (_) {\n-            auto blk = parse_block(p);\n-            ret @spanned(blk.span.lo, blk.span.hi,\n-                         ast::expr_block(blk, p.get_ann()));\n-        }\n+    if (eat_word(p, \"if\")) {\n+        ret parse_if_expr(p);\n+    } else {\n+        auto blk = parse_block(p);\n+        ret @spanned(blk.span.lo, blk.span.hi,\n+                     ast::expr_block(blk, p.get_ann()));\n     }\n }\n \n fn parse_head_local(parser p) -> @ast::decl {\n     auto lo = p.get_lo_pos();\n     let @ast::local local;\n-    if (p.peek() == token::AUTO) {\n+    if (is_word(p, \"auto\")) {\n         local = parse_auto_local(p);\n     } else {\n         local = parse_typed_local(p);\n@@ -1259,19 +1174,14 @@ fn parse_head_local(parser p) -> @ast::decl {\n \n \n fn parse_for_expr(parser p) -> @ast::expr {\n-    auto lo = p.get_lo_pos();\n-    auto is_each = false;\n+    auto lo = p.get_last_lo_pos();\n \n-    expect(p, token::FOR);\n-    if (p.peek() == token::EACH) {\n-        is_each = true;\n-        p.bump();\n-    }\n+    auto is_each = eat_word(p, \"each\");\n \n     expect (p, token::LPAREN);\n \n     auto decl = parse_head_local(p);\n-    expect(p, token::IN);\n+    expect_word(p, \"in\");\n \n     auto seq = parse_expr(p);\n     expect(p, token::RPAREN);\n@@ -1288,10 +1198,8 @@ fn parse_for_expr(parser p) -> @ast::expr {\n \n \n fn parse_while_expr(parser p) -> @ast::expr {\n-    auto lo = p.get_lo_pos();\n-\n-    expect(p, token::WHILE);\n-    expect (p, token::LPAREN);\n+    auto lo = p.get_last_lo_pos();\n+    expect(p, token::LPAREN);\n     auto cond = parse_expr(p);\n     expect(p, token::RPAREN);\n     auto body = parse_block(p);\n@@ -1300,11 +1208,9 @@ fn parse_while_expr(parser p) -> @ast::expr {\n }\n \n fn parse_do_while_expr(parser p) -> @ast::expr {\n-    auto lo = p.get_lo_pos();\n-\n-    expect(p, token::DO);\n+    auto lo = p.get_last_lo_pos();\n     auto body = parse_block(p);\n-    expect(p, token::WHILE);\n+    expect_word(p, \"while\");\n     expect (p, token::LPAREN);\n     auto cond = parse_expr(p);\n     expect(p, token::RPAREN);\n@@ -1313,45 +1219,25 @@ fn parse_do_while_expr(parser p) -> @ast::expr {\n }\n \n fn parse_alt_expr(parser p) -> @ast::expr {\n-    auto lo = p.get_lo_pos();\n-    expect(p, token::ALT);\n+    auto lo = p.get_last_lo_pos();\n     expect(p, token::LPAREN);\n     auto discriminant = parse_expr(p);\n     expect(p, token::RPAREN);\n     expect(p, token::LBRACE);\n \n     let vec[ast::arm] arms = vec();\n     while (p.peek() != token::RBRACE) {\n-        alt (p.peek()) {\n-            case (token::CASE) {\n-                p.bump();\n-                expect(p, token::LPAREN);\n-                auto pat = parse_pat(p);\n-                expect(p, token::RPAREN);\n-                auto block = parse_block(p);\n-                arms += vec(rec(pat=pat, block=block));\n-            }\n-\n-            // FIXME: this is a vestigial form left over from\n-            // rustboot, we're keeping it here for source-compat\n-            // for the time being but it should be flushed out\n-            // once we've bootstrapped. When we see 'else {' here,\n-            // we pretend we saw 'case (_) {'. It has the same\n-            // meaning, and only exists due to the cexp/pexp split\n-            // in rustboot, which we're not maintaining.\n-\n-            case (token::ELSE) {\n-                p.bump();\n-                auto hi = p.get_hi_pos();\n-                auto pat = @spanned(lo, hi, ast::pat_wild(p.get_ann()));\n-                auto block = parse_block(p);\n-                arms += vec(rec(pat=pat, block=block));\n-            }\n-            case (token::RBRACE) { /* empty */ }\n-            case (?tok) {\n-                p.err(\"expected 'case' or '}' when parsing 'alt' statement \" +\n-                      \"but found \" + token::to_str(p.get_reader(), tok));\n-            }\n+        if (eat_word(p, \"case\")) {\n+            expect(p, token::LPAREN);\n+            auto pat = parse_pat(p);\n+            expect(p, token::RPAREN);\n+            auto block = parse_block(p);\n+            arms += vec(rec(pat=pat, block=block));\n+        } else if (p.peek() == token::RBRACE) {\n+            /* empty */\n+        } else {\n+            p.err(\"expected 'case' or '}' when parsing 'alt' statement \" +\n+                  \"but found \" + token::to_str(p.get_reader(), p.peek()));\n         }\n     }\n     auto hi = p.get_hi_pos();\n@@ -1362,9 +1248,7 @@ fn parse_alt_expr(parser p) -> @ast::expr {\n }\n \n fn parse_spawn_expr(parser p) -> @ast::expr {\n-    auto lo = p.get_lo_pos();\n-    expect(p, token::SPAWN);\n-\n+    auto lo = p.get_last_lo_pos();\n     // FIXME: Parse domain and name\n     // FIXME: why no full expr?\n     auto fn_expr = parse_bottom_expr(p);\n@@ -1395,34 +1279,24 @@ fn parse_expr_res(parser p, restriction r) -> @ast::expr {\n }\n \n fn parse_expr_inner(parser p) -> @ast::expr {\n-    alt (p.peek()) {\n-        case (token::LBRACE) {\n-            auto blk = parse_block(p);\n-            ret @spanned(blk.span.lo, blk.span.hi,\n-                         ast::expr_block(blk, p.get_ann()));\n-        }\n-        case (token::IF) {\n-            ret parse_if_expr(p);\n-        }\n-        case (token::FOR) {\n-            ret parse_for_expr(p);\n-        }\n-        case (token::WHILE) {\n-            ret parse_while_expr(p);\n-        }\n-        case (token::DO) {\n-            ret parse_do_while_expr(p);\n-        }\n-        case (token::ALT) {\n-            ret parse_alt_expr(p);\n-        }\n-        case (token::SPAWN) {\n-            ret parse_spawn_expr(p);\n-        }\n-        case (_) {\n-            ret parse_assign_expr(p);\n-        }\n-\n+    if (p.peek() == token::LBRACE) {\n+        auto blk = parse_block(p);\n+        ret @spanned(blk.span.lo, blk.span.hi,\n+                     ast::expr_block(blk, p.get_ann()));\n+    } else if (eat_word(p, \"if\")) {\n+        ret parse_if_expr(p);\n+    } else if (eat_word(p, \"for\")) {\n+        ret parse_for_expr(p);\n+    } else if (eat_word(p, \"while\")) {\n+        ret parse_while_expr(p);\n+    } else if (eat_word(p, \"do\")) {\n+        ret parse_do_while_expr(p);\n+    } else if (eat_word(p, \"alt\")) {\n+        ret parse_alt_expr(p);\n+    } else if (eat_word(p, \"spawn\")) {\n+        ret parse_spawn_expr(p);\n+    } else {\n+        ret parse_assign_expr(p);\n     }\n }\n \n@@ -1470,29 +1344,30 @@ fn parse_pat(parser p) -> @ast::pat {\n                 }\n             }\n         }\n-        case (token::IDENT(_)) {\n-            auto tag_path = parse_path(p);\n-            hi = tag_path.span.hi;\n+        case (?tok) {\n+            if (!is_ident(tok) || is_word(p, \"true\") || is_word(p, \"false\")) {\n+                auto lit = parse_lit(p);\n+                hi = lit.span.hi;\n+                pat = ast::pat_lit(@lit, p.get_ann());\n+            } else {\n+                auto tag_path = parse_path(p);\n+                hi = tag_path.span.hi;\n \n-            let vec[@ast::pat] args;\n-            alt (p.peek()) {\n-                case (token::LPAREN) {\n-                    auto f = parse_pat;\n-                    auto a = parse_seq[@ast::pat](token::LPAREN,\n-                                                  token::RPAREN,\n-                                                  some(token::COMMA), f, p);\n-                    args = a.node;\n-                    hi = a.span.hi;\n+                let vec[@ast::pat] args;\n+                alt (p.peek()) {\n+                    case (token::LPAREN) {\n+                        auto f = parse_pat;\n+                        auto a = parse_seq(token::LPAREN,\n+                                           token::RPAREN,\n+                                           some(token::COMMA), f, p);\n+                        args = a.node;\n+                        hi = a.span.hi;\n+                    }\n+                    case (_) { args = vec(); }\n                 }\n-                case (_) { args = vec(); }\n-            }\n \n-            pat = ast::pat_tag(tag_path, args, p.get_ann());\n-        }\n-        case (_) {\n-            auto lit = parse_lit(p);\n-            hi = lit.span.hi;\n-            pat = ast::pat_lit(@lit, p.get_ann());\n+                pat = ast::pat_tag(tag_path, args, p.get_ann());\n+            }\n         }\n     }\n \n@@ -1521,15 +1396,13 @@ fn parse_auto_local(parser p) -> @ast::local {\n }\n \n fn parse_let(parser p) -> @ast::decl {\n-    auto lo = p.get_lo_pos();\n-    expect(p, token::LET);\n+    auto lo = p.get_last_lo_pos();\n     auto local = parse_typed_local(p);\n     ret @spanned(lo, p.get_hi_pos(), ast::decl_local(local));\n }\n \n fn parse_auto(parser p) -> @ast::decl {\n-    auto lo = p.get_lo_pos();\n-    expect(p, token::AUTO);\n+    auto lo = p.get_last_lo_pos();\n     auto local = parse_auto_local(p);\n     ret @spanned(lo, p.get_hi_pos(), ast::decl_local(local));\n }\n@@ -1550,35 +1423,28 @@ fn parse_crate_stmt(parser p) -> @ast::stmt {\n \n fn parse_source_stmt(parser p) -> @ast::stmt {\n     auto lo = p.get_lo_pos();\n-    alt (p.peek()) {\n-\n-        case (token::LET) {\n-            auto decl = parse_let(p);\n-            auto hi = p.get_span();\n-            ret @spanned\n-                (lo, decl.span.hi, ast::stmt_decl(decl, p.get_ann()));\n-        }\n+    if (eat_word(p, \"let\")) {\n+        auto decl = parse_let(p);\n+        auto hi = p.get_span();\n+        ret @spanned\n+            (lo, decl.span.hi, ast::stmt_decl(decl, p.get_ann()));\n+    } else if (eat_word(p, \"auto\")) {\n+        auto decl = parse_auto(p);\n+        auto hi = p.get_span();\n+        ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_ann()));\n+    } else {\n+        if (peeking_at_item(p)) {\n+            // Might be a local item decl.\n+            auto i = parse_item(p);\n+            auto hi = i.span.hi;\n+            auto decl = @spanned(lo, hi, ast::decl_item(i));\n+            ret @spanned(lo, hi, ast::stmt_decl(decl, p.get_ann()));\n \n-        case (token::AUTO) {\n-            auto decl = parse_auto(p);\n+        } else {\n+            // Remainder are line-expr stmts.\n+            auto e = parse_expr(p);\n             auto hi = p.get_span();\n-            ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_ann()));\n-        }\n-\n-        case (_) {\n-            if (peeking_at_item(p)) {\n-                // Might be a local item decl.\n-                auto i = parse_item(p);\n-                auto hi = i.span.hi;\n-                auto decl = @spanned(lo, hi, ast::decl_item(i));\n-                ret @spanned(lo, hi, ast::stmt_decl(decl, p.get_ann()));\n-\n-            } else {\n-                // Remainder are line-expr stmts.\n-                auto e = parse_expr(p);\n-                auto hi = p.get_span();\n-                ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_ann()));\n-            }\n+            ret @spanned(lo, e.span.hi, ast::stmt_expr(e, p.get_ann()));\n         }\n     }\n     p.err(\"expected statement\");\n@@ -1761,9 +1627,9 @@ fn parse_fn_header(parser p)\n     ret tup(id, ty_params);\n }\n \n-fn parse_item_fn_or_iter(parser p, ast::purity purity) -> @ast::item {\n-    auto lo = p.get_lo_pos();\n-    auto proto = parse_proto(p);\n+fn parse_item_fn_or_iter(parser p, ast::purity purity, ast::proto proto)\n+    -> @ast::item {\n+    auto lo = p.get_last_lo_pos();\n     auto t = parse_fn_header(p);\n     auto f = parse_fn(p, proto, purity);\n     auto item = ast::item_fn(t._0, f, t._1,\n@@ -1790,8 +1656,7 @@ fn parse_method(parser p) -> @ast::method {\n }\n \n fn parse_dtor(parser p) -> @ast::method {\n-    auto lo = p.get_lo_pos();\n-    expect(p, token::DROP);\n+    auto lo = p.get_last_lo_pos();\n     let ast::block b = parse_block(p);\n     let vec[ast::arg] inputs = vec();\n     let @ast::ty output = @spanned(lo, lo, ast::ty_nil);\n@@ -1809,8 +1674,7 @@ fn parse_dtor(parser p) -> @ast::method {\n }\n \n fn parse_item_obj(parser p, ast::layer lyr) -> @ast::item {\n-    auto lo = p.get_lo_pos();\n-    expect(p, token::OBJ);\n+    auto lo = p.get_last_lo_pos();\n     auto ident = parse_ident(p);\n     auto ty_params = parse_ty_params(p);\n     auto pf = parse_obj_field;\n@@ -1826,14 +1690,11 @@ fn parse_item_obj(parser p, ast::layer lyr) -> @ast::item {\n \n     expect(p, token::LBRACE);\n     while (p.peek() != token::RBRACE) {\n-        alt (p.peek()) {\n-            case (token::DROP) {\n-                dtor = some[@ast::method](parse_dtor(p));\n-            }\n-            case (_) {\n-                _vec::push[@ast::method](meths,\n-                                       parse_method(p));\n-            }\n+        if (eat_word(p, \"drop\")) {\n+            dtor = some[@ast::method](parse_dtor(p));\n+        } else {\n+            _vec::push[@ast::method](meths,\n+                                     parse_method(p));\n         }\n     }\n     auto hi = p.get_hi_pos();\n@@ -1859,8 +1720,7 @@ fn parse_mod_items(parser p, token::token term) -> ast::_mod {\n }\n \n fn parse_item_const(parser p) -> @ast::item {\n-    auto lo = p.get_lo_pos();\n-    expect(p, token::CONST);\n+    auto lo = p.get_last_lo_pos();\n     auto ty = parse_ty(p);\n     auto id = parse_ident(p);\n     expect(p, token::EQ);\n@@ -1872,8 +1732,7 @@ fn parse_item_const(parser p) -> @ast::item {\n }\n \n fn parse_item_mod(parser p) -> @ast::item {\n-    auto lo = p.get_lo_pos();\n-    expect(p, token::MOD);\n+    auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     expect(p, token::LBRACE);\n     auto m = parse_mod_items(p, token::RBRACE);\n@@ -1892,8 +1751,7 @@ fn parse_item_native_type(parser p) -> @ast::native_item {\n }\n \n fn parse_item_native_fn(parser p) -> @ast::native_item {\n-    auto lo = p.get_lo_pos();\n-    expect(p, token::FN);\n+    auto lo = p.get_last_lo_pos();\n     auto t = parse_fn_header(p);\n     auto decl = parse_fn_decl(p, ast::impure_fn);\n     auto link_name = none[str];\n@@ -1911,17 +1769,13 @@ fn parse_item_native_fn(parser p) -> @ast::native_item {\n \n fn parse_native_item(parser p) -> @ast::native_item {\n     let ast::layer lyr = parse_layer(p);\n-    alt (p.peek()) {\n-        case (token::TYPE) {\n-            ret parse_item_native_type(p);\n-        }\n-        case (token::FN) {\n-            ret parse_item_native_fn(p);\n-        }\n-        case (?t) {\n-            unexpected(p, t);\n-            fail;\n-        }\n+    if (eat_word(p, \"type\")) {\n+        ret parse_item_native_type(p);\n+    } else if (eat_word(p, \"fn\")) {\n+        ret parse_item_native_fn(p);\n+    } else {\n+        unexpected(p, p.peek());\n+        fail;\n     }\n }\n \n@@ -1955,10 +1809,9 @@ fn default_native_name(session::session sess, str id) -> str {\n }\n \n fn parse_item_native_mod(parser p) -> @ast::item {\n-    auto lo = p.get_lo_pos();\n-    expect(p, token::NATIVE);\n+    auto lo = p.get_last_lo_pos();\n     auto abi = ast::native_abi_cdecl;\n-    if (p.peek() != token::MOD) {\n+    if (!is_word(p, \"mod\")) {\n         auto t = parse_str_lit_or_env_ident(p);\n         if (_str::eq(t, \"cdecl\")) {\n         } else if (_str::eq(t, \"rust\")) {\n@@ -1972,7 +1825,7 @@ fn parse_item_native_mod(parser p) -> @ast::item {\n             fail;\n         }\n     }\n-    expect(p, token::MOD);\n+    expect_word(p, \"mod\");\n     auto id = parse_ident(p);\n     auto native_name;\n     if (p.peek() == token::EQ) {\n@@ -1990,8 +1843,7 @@ fn parse_item_native_mod(parser p) -> @ast::item {\n }\n \n fn parse_type_decl(parser p) -> tup(uint, ast::ident) {\n-    auto lo = p.get_lo_pos();\n-    expect(p, token::TYPE);\n+    auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     ret tup(lo, id);\n }\n@@ -2009,8 +1861,7 @@ fn parse_item_type(parser p) -> @ast::item {\n }\n \n fn parse_item_tag(parser p) -> @ast::item {\n-    auto lo = p.get_lo_pos();\n-    expect(p, token::TAG);\n+    auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     auto ty_params = parse_ty_params(p);\n \n@@ -2063,97 +1914,75 @@ fn parse_item_tag(parser p) -> @ast::item {\n \n \n fn parse_layer(parser p) -> ast::layer {\n-    alt (p.peek()) {\n-        case (token::STATE) {\n-            p.bump();\n-            ret ast::layer_state;\n-        }\n-        case (token::GC) {\n-            p.bump();\n-            ret ast::layer_gc;\n-        }\n-        case (_) {\n-            ret ast::layer_value;\n-        }\n+    if (eat_word(p, \"state\")) {\n+        ret ast::layer_state;\n+    } else if (eat_word(p, \"gc\")) {\n+        ret ast::layer_gc;\n+    } else {\n+        ret ast::layer_value;\n     }\n     fail;\n }\n \n \n fn parse_auth(parser p) -> ast::_auth {\n-    alt (p.peek()) {\n-        case (token::UNSAFE) {\n-            p.bump();\n-            ret ast::auth_unsafe;\n-        }\n-        case (?t) {\n-            unexpected(p, t);\n-        }\n+    if (eat_word(p, \"unsafe\")) {\n+        ret ast::auth_unsafe;\n+    } else {\n+        unexpected(p, p.peek());\n     }\n     fail;\n }\n \n fn peeking_at_item(parser p) -> bool {\n     alt (p.peek()) {\n-        case (token::STATE) { ret true; }\n-        case (token::GC) { ret true; }\n-        case (token::CONST) { ret true; }\n-        case (token::FN) { ret true; }\n-        case (token::PRED) { ret true; }\n-        case (token::ITER) { ret true; }\n-        case (token::MOD) { ret true; }\n-        case (token::TYPE) { ret true; }\n-        case (token::TAG) { ret true; }\n-        case (token::OBJ) { ret true; }\n+        case (token::IDENT(?sid)) {\n+            auto st = p.get_str(sid);\n+            ret _str::eq(st, \"state\") ||\n+                _str::eq(st, \"gc\") ||\n+                _str::eq(st, \"const\") ||\n+                _str::eq(st, \"fn\") ||\n+                _str::eq(st, \"pred\") ||\n+                _str::eq(st, \"iter\") ||\n+                _str::eq(st, \"mod\") ||\n+                _str::eq(st, \"type\") ||\n+                _str::eq(st, \"tag\") ||\n+                _str::eq(st, \"obj\");\n+        }\n         case (_) { ret false; }\n     }\n-    ret false;\n }\n \n fn parse_item(parser p) -> @ast::item {\n     let ast::layer lyr = parse_layer(p);\n \n-    alt (p.peek()) {\n-        case (token::CONST) {\n-            assert (lyr == ast::layer_value);\n-            ret parse_item_const(p);\n-        }\n-\n-        case (token::FN) {\n-            assert (lyr == ast::layer_value);\n-            ret parse_item_fn_or_iter(p, ast::impure_fn);\n-        }\n-\n-        case (token::PRED) {\n-            assert (lyr == ast::layer_value);\n-            ret parse_item_fn_or_iter(p, ast::pure_fn);\n-        }\n-\n-        case (token::ITER) {\n-            assert (lyr == ast::layer_value);\n-            ret parse_item_fn_or_iter(p, ast::impure_fn);\n-        }\n-        case (token::MOD) {\n-            assert (lyr == ast::layer_value);\n-            ret parse_item_mod(p);\n-        }\n-        case (token::NATIVE) {\n-            assert (lyr == ast::layer_value);\n-            ret parse_item_native_mod(p);\n-        }\n-        case (token::TYPE) {\n-            ret parse_item_type(p);\n-        }\n-        case (token::TAG) {\n-            ret parse_item_tag(p);\n-        }\n-        case (token::OBJ) {\n-            ret parse_item_obj(p, lyr);\n-        }\n-        case (?t) {\n-            p.err(\"expected item but found \" +\n-                  token::to_str(p.get_reader(), t));\n-        }\n+    if (eat_word(p, \"const\")) {\n+        assert (lyr == ast::layer_value);\n+        ret parse_item_const(p);\n+    } else if (eat_word(p, \"fn\")) {\n+        assert (lyr == ast::layer_value);\n+        ret parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_fn);\n+    } else if (eat_word(p, \"pred\")) {\n+        assert (lyr == ast::layer_value);\n+        ret parse_item_fn_or_iter(p, ast::pure_fn, ast::proto_fn);\n+    } else if (eat_word(p, \"iter\")) {\n+        assert (lyr == ast::layer_value);\n+        ret parse_item_fn_or_iter(p, ast::impure_fn, ast::proto_iter);\n+    } else if (eat_word(p, \"mod\")) {\n+        assert (lyr == ast::layer_value);\n+        ret parse_item_mod(p);\n+    } else if (eat_word(p, \"native\")) {\n+        assert (lyr == ast::layer_value);\n+        ret parse_item_native_mod(p);\n+    } else if (eat_word(p, \"type\")) {\n+        ret parse_item_type(p);\n+    } else if (eat_word(p, \"tag\")) {\n+        ret parse_item_tag(p);\n+    } else if (eat_word(p, \"obj\")) {\n+        ret parse_item_obj(p, lyr);\n+    } else {\n+        p.err(\"expected item but found \" +\n+              token::to_str(p.get_reader(), p.peek()));\n     }\n     fail;\n }\n@@ -2195,8 +2024,7 @@ fn parse_optional_meta(parser p) -> vec[@ast::meta_item] {\n }\n \n fn parse_use(parser p) -> @ast::view_item {\n-    auto lo = p.get_lo_pos();\n-    expect(p, token::USE);\n+    auto lo = p.get_last_lo_pos();\n     auto ident = parse_ident(p);\n     auto metadata = parse_optional_meta(p);\n     auto hi = p.get_hi_pos();\n@@ -2248,7 +2076,6 @@ fn parse_full_import_name(parser p, ast::ident def_ident)\n }\n \n fn parse_import(parser p) -> @ast::view_item {\n-    expect(p, token::IMPORT);\n     alt (p.peek()) {\n         case (token::IDENT(?i)) {\n             p.bump();\n@@ -2271,49 +2098,48 @@ fn parse_import(parser p) -> @ast::view_item {\n }\n \n fn parse_export(parser p) -> @ast::view_item {\n-    auto lo = p.get_lo_pos();\n-    expect(p, token::EXPORT);\n+    auto lo = p.get_last_lo_pos();\n     auto id = parse_ident(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n     ret @spanned(lo, hi, ast::view_item_export(id));\n }\n \n fn parse_view_item(parser p) -> @ast::view_item {\n-    alt (p.peek()) {\n-        case (token::USE) {\n-            ret parse_use(p);\n-        }\n-        case (token::IMPORT) {\n-            ret parse_import(p);\n-        }\n-        case (token::EXPORT) {\n-            ret parse_export(p);\n-        }\n+    if (eat_word(p, \"use\")) {\n+        ret parse_use(p);\n+    } else if (eat_word(p, \"import\")) {\n+        ret parse_import(p);\n+    } else if (eat_word(p, \"export\")) {\n+        ret parse_export(p);\n+    } else {\n+        fail;\n     }\n }\n \n-fn is_view_item(token::token t) -> bool {\n-    alt (t) {\n-        case (token::USE) { ret true; }\n-        case (token::IMPORT) { ret true; }\n-        case (token::EXPORT) { ret true; }\n-        case (_) {}\n+fn is_view_item(&parser p) -> bool {\n+    alt (p.peek()) {\n+        case (token::IDENT(?sid)) {\n+            auto st = p.get_str(sid);\n+            ret _str::eq(st, \"use\") || _str::eq(st, \"import\") ||\n+                _str::eq(st, \"export\");\n+        }\n+        case (_) { ret false; }\n     }\n     ret false;\n }\n \n fn parse_view(parser p) -> vec[@ast::view_item] {\n     let vec[@ast::view_item] items = vec();\n-    while (is_view_item(p.peek())) {\n+    while (is_view_item(p)) {\n         items += vec(parse_view_item(p));\n     }\n     ret items;\n }\n \n fn parse_native_view(parser p) -> vec[@ast::view_item] {\n     let vec[@ast::view_item] items = vec();\n-    while (is_view_item(p.peek())) {\n+    while (is_view_item(p)) {\n         items += vec(parse_view_item(p));\n     }\n     ret items;\n@@ -2337,99 +2163,79 @@ fn parse_crate_from_source_file(parser p) -> @ast::crate {\n fn parse_crate_directive(parser p) -> ast::crate_directive\n {\n     auto lo = p.get_lo_pos();\n-    alt (p.peek()) {\n-        case (token::AUTH) {\n-            p.bump();\n-            auto n = parse_path(p);\n-            expect(p, token::EQ);\n-            auto a = parse_auth(p);\n-            auto hi = p.get_hi_pos();\n-            expect(p, token::SEMI);\n-            ret spanned(lo, hi, ast::cdir_auth(n, a));\n-        }\n-\n-        case (token::META) {\n-            p.bump();\n-            auto mis = parse_meta(p);\n-            auto hi = p.get_hi_pos();\n-            expect(p, token::SEMI);\n-            ret spanned(lo, hi, ast::cdir_meta(mis));\n-        }\n-\n-        case (token::MOD) {\n-            p.bump();\n-            auto id = parse_ident(p);\n-            auto file_opt = none[filename];\n-            alt (p.peek()) {\n-                case (token::EQ) {\n-                    p.bump();\n-                    // FIXME: turn this into parse+eval expr\n-                    file_opt = some[filename](parse_str_lit_or_env_ident(p));\n-                }\n-                case (_) {}\n+    if (eat_word(p, \"auth\")) {\n+        auto n = parse_path(p);\n+        expect(p, token::EQ);\n+        auto a = parse_auth(p);\n+        auto hi = p.get_hi_pos();\n+        expect(p, token::SEMI);\n+        ret spanned(lo, hi, ast::cdir_auth(n, a));\n+    } else if (eat_word(p, \"meta\")) {\n+        auto mis = parse_meta(p);\n+        auto hi = p.get_hi_pos();\n+        expect(p, token::SEMI);\n+        ret spanned(lo, hi, ast::cdir_meta(mis));\n+    } else if (eat_word(p, \"mod\")) {\n+        auto id = parse_ident(p);\n+        auto file_opt = none[filename];\n+        alt (p.peek()) {\n+            case (token::EQ) {\n+                p.bump();\n+                // FIXME: turn this into parse+eval expr\n+                file_opt = some[filename](parse_str_lit_or_env_ident(p));\n             }\n+            case (_) {}\n+        }\n \n \n-            alt (p.peek()) {\n-\n-                // mod x = \"foo.rs\";\n-\n-                case (token::SEMI) {\n-                    auto hi = p.get_hi_pos();\n-                    p.bump();\n-                    ret spanned(lo, hi, ast::cdir_src_mod(id, file_opt));\n-                }\n-\n-                // mod x = \"foo_dir\" { ...directives... }\n+        alt (p.peek()) {\n \n-                case (token::LBRACE) {\n-                    p.bump();\n-                    auto cdirs = parse_crate_directives(p, token::RBRACE);\n-                    auto hi = p.get_hi_pos();\n-                    expect(p, token::RBRACE);\n-                    ret spanned(lo, hi,\n-                                ast::cdir_dir_mod(id, file_opt, cdirs));\n-                }\n+            // mod x = \"foo.rs\";\n \n-                case (?t) {\n-                    unexpected(p, t);\n-                }\n+            case (token::SEMI) {\n+                auto hi = p.get_hi_pos();\n+                p.bump();\n+                ret spanned(lo, hi, ast::cdir_src_mod(id, file_opt));\n             }\n-        }\n-\n-        case (token::LET) {\n-            p.bump();\n-            expect(p, token::LPAREN);\n-            auto id = parse_ident(p);\n-            expect(p, token::EQ);\n-            auto x = parse_expr(p);\n-            expect(p, token::RPAREN);\n-            expect(p, token::LBRACE);\n-            auto v = parse_crate_directives(p, token::RBRACE);\n-            auto hi = p.get_hi_pos();\n-            expect(p, token::RBRACE);\n-            ret spanned(lo, hi, ast::cdir_let(id, x, v));\n-        }\n \n-        case (token::USE) {\n-            auto vi = parse_view_item(p);\n-            ret spanned(lo, vi.span.hi, ast::cdir_view_item(vi));\n-        }\n+            // mod x = \"foo_dir\" { ...directives... }\n \n-        case (token::IMPORT) {\n-            auto vi = parse_view_item(p);\n-            ret spanned(lo, vi.span.hi, ast::cdir_view_item(vi));\n-        }\n-\n-        case (token::EXPORT) {\n-            auto vi = parse_view_item(p);\n-            ret spanned(lo, vi.span.hi, ast::cdir_view_item(vi));\n-        }\n+            case (token::LBRACE) {\n+                p.bump();\n+                auto cdirs = parse_crate_directives(p, token::RBRACE);\n+                auto hi = p.get_hi_pos();\n+                expect(p, token::RBRACE);\n+                ret spanned(lo, hi,\n+                            ast::cdir_dir_mod(id, file_opt, cdirs));\n+            }\n \n-        case (_) {\n-            auto x = parse_expr(p);\n-            ret spanned(lo, x.span.hi, ast::cdir_expr(x));\n+            case (?t) {\n+                unexpected(p, t);\n+            }\n         }\n+    } else if (eat_word(p, \"let\")) {\n+        expect(p, token::LPAREN);\n+        auto id = parse_ident(p);\n+        expect(p, token::EQ);\n+        auto x = parse_expr(p);\n+        expect(p, token::RPAREN);\n+        expect(p, token::LBRACE);\n+        auto v = parse_crate_directives(p, token::RBRACE);\n+        auto hi = p.get_hi_pos();\n+        expect(p, token::RBRACE);\n+        ret spanned(lo, hi, ast::cdir_let(id, x, v));\n+    } else if (is_word(p, \"use\")) {\n+        auto vi = parse_view_item(p);\n+        ret spanned(lo, vi.span.hi, ast::cdir_view_item(vi));\n+    } else if (is_word(p, \"import\")) {\n+        auto vi = parse_view_item(p);\n+        ret spanned(lo, vi.span.hi, ast::cdir_view_item(vi));\n+    } else if (is_word(p, \"export\")) {\n+        auto vi = parse_view_item(p);\n+        ret spanned(lo, vi.span.hi, ast::cdir_view_item(vi));\n+    } else {\n+        auto x = parse_expr(p);\n+        ret spanned(lo, x.span.hi, ast::cdir_expr(x));\n     }\n     fail;\n }"}, {"sha": "171fa5f22c1595d8f63e56748ba182dff07d691f", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 1, "deletions": 201, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/57ffa2a487ef12a4abf538efc2dd8192ca308271/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ffa2a487ef12a4abf538efc2dd8192ca308271/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=57ffa2a487ef12a4abf538efc2dd8192ca308271", "patch": "@@ -38,9 +38,6 @@ tag token {\n     BINOP(binop);\n     BINOPEQ(binop);\n \n-    AS;\n-    WITH;\n-\n     /* Structural symbols */\n     AT;\n     DOT;\n@@ -59,73 +56,8 @@ tag token {\n     LBRACE;\n     RBRACE;\n \n-    /* Module and crate keywords */\n-    MOD;\n-    USE;\n-    AUTH;\n-    META;\n-\n-    /* Metaprogramming keywords */\n-    SYNTAX;\n     POUND;\n \n-    /* Statement keywords */\n-    IF;\n-    ELSE;\n-    DO;\n-    WHILE;\n-    ALT;\n-    CASE;\n-\n-    BREAK;\n-    CONT;\n-\n-    FAIL;\n-    DROP;\n-\n-    IN;\n-    FOR;\n-    EACH;\n-    PUT;\n-    RET;\n-    BE;\n-\n-    /* Type and type-state keywords */\n-    TYPE;\n-    ASSERT;\n-    CHECK;\n-    CLAIM;\n-    PROVE;\n-\n-    /* Layer keywords */\n-    STATE;\n-    GC;\n-\n-    /* Unsafe-block keyword */\n-    UNSAFE;\n-\n-    /* Type qualifiers */\n-    NATIVE;\n-    AUTO;\n-    MUTABLE;\n-\n-    /* Name management */\n-    IMPORT;\n-    EXPORT;\n-\n-    /* Value / stmt declarators */\n-    LET;\n-    CONST;\n-\n-    /* Magic runtime services */\n-    LOG;\n-    LOG_ERR;\n-    SPAWN;\n-    BIND;\n-    THREAD;\n-    YIELD;\n-    JOIN;\n-\n     /* Literals */\n     LIT_INT(int);\n     LIT_UINT(uint);\n@@ -141,36 +73,6 @@ tag token {\n     IDX(int);\n     UNDERSCORE;\n \n-    /* Reserved type names */\n-    BOOL;\n-    INT;\n-    UINT;\n-    FLOAT;\n-    CHAR;\n-    STR;\n-    MACH(ty_mach);\n-\n-    /* Algebraic type constructors */\n-    REC;\n-    TUP;\n-    TAG;\n-    VEC;\n-    ANY;\n-\n-    /* Callable type constructors */\n-    FN;\n-    PRED;\n-    ITER;\n-\n-    /* Object type and related keywords */\n-    OBJ;\n-    SELF;\n-\n-    /* Comm and task types */\n-    CHAN;\n-    PORT;\n-    TASK;\n-\n     BRACEQUOTE(str_num);\n     EOF;\n }\n@@ -209,10 +111,6 @@ fn to_str(lexer::reader r, token t) -> str {\n         case (BINOP(?op)) { ret binop_to_str(op); }\n         case (BINOPEQ(?op)) { ret binop_to_str(op) + \"=\"; }\n \n-        case (AS) { ret \"as\"; }\n-        case (WITH) { ret \"with\"; }\n-\n-\n         /* Structural symbols */\n         case (AT) { ret \"@\"; }\n         case (DOT) { ret \".\"; }\n@@ -231,73 +129,8 @@ fn to_str(lexer::reader r, token t) -> str {\n         case (LBRACE) { ret \"{\"; }\n         case (RBRACE) { ret \"}\"; }\n \n-        /* Module and crate keywords */\n-        case (MOD) { ret \"mod\"; }\n-        case (USE) { ret \"use\"; }\n-        case (AUTH) { ret \"auth\"; }\n-        case (META) { ret \"meta\"; }\n-\n-        /* Metaprogramming keywords */\n-        case (SYNTAX) { ret \"syntax\"; }\n         case (POUND) { ret \"#\"; }\n \n-        /* Statement keywords */\n-        case (IF) { ret \"if\"; }\n-        case (ELSE) { ret \"else\"; }\n-        case (DO) { ret \"do\"; }\n-        case (WHILE) { ret \"while\"; }\n-        case (ALT) { ret \"alt\"; }\n-        case (CASE) { ret \"case\"; }\n-\n-        case (BREAK) { ret \"break\"; }\n-        case (CONT) { ret \"cont\"; }\n-\n-        case (FAIL) { ret \"fail\"; }\n-        case (DROP) { ret \"drop\"; }\n-\n-        case (IN) { ret \"in\"; }\n-        case (FOR) { ret \"for\"; }\n-        case (EACH) { ret \"each\"; }\n-        case (PUT) { ret \"put\"; }\n-        case (RET) { ret \"ret\"; }\n-        case (BE) { ret \"be\"; }\n-\n-        /* Type and type-state keywords */\n-        case (TYPE) { ret \"type\"; }\n-        case (ASSERT) { ret \"assert\"; }\n-        case (CHECK) { ret \"check\"; }\n-        case (CLAIM) { ret \"claim\"; }\n-        case (PROVE) { ret \"prove\"; }\n-\n-        /* Layer keywords */\n-        case (STATE) { ret \"state\"; }\n-        case (GC) { ret \"gc\"; }\n-\n-        /* Unsafe-block keyword */\n-        case (UNSAFE) { ret \"unsafe\"; }\n-\n-        /* Type qualifiers */\n-        case (NATIVE) { ret \"native\"; }\n-        case (AUTO) { ret \"auto\"; }\n-        case (MUTABLE) { ret \"mutable\"; }\n-\n-        /* Name management */\n-        case (IMPORT) { ret \"import\"; }\n-        case (EXPORT) { ret \"export\"; }\n-\n-        /* Value / stmt declarators */\n-        case (LET) { ret \"let\"; }\n-        case (CONST) { ret \"const\"; }\n-\n-        /* Magic runtime services */\n-        case (LOG) { ret \"log\"; }\n-        case (LOG_ERR) { ret \"log_err\"; }\n-        case (SPAWN) { ret \"spawn\"; }\n-        case (BIND) { ret \"bind\"; }\n-        case (THREAD) { ret \"thread\"; }\n-        case (YIELD) { ret \"yield\"; }\n-        case (JOIN) { ret \"join\"; }\n-\n         /* Literals */\n         case (LIT_INT(?i)) { ret _int::to_str(i, 10u); }\n         case (LIT_UINT(?u)) { ret _uint::to_str(u, 10u); }\n@@ -328,44 +161,11 @@ fn to_str(lexer::reader r, token t) -> str {\n \n         /* Name components */\n         case (IDENT(?s)) {\n-            auto si = \"ident:\";\n-            si += r.get_str(s);\n-            ret si;\n+            ret r.get_str(s);\n         }\n         case (IDX(?i)) { ret \"_\" + _int::to_str(i, 10u); }\n         case (UNDERSCORE) { ret \"_\"; }\n \n-        /* Reserved type names */\n-        case (BOOL) { ret \"bool\"; }\n-        case (INT) { ret \"int\"; }\n-        case (UINT) { ret \"uint\"; }\n-        case (FLOAT) { ret \"float\"; }\n-        case (CHAR) { ret \"char\"; }\n-        case (STR) { ret \"str\"; }\n-        case (MACH(?tm)) { ret ty_mach_to_str(tm); }\n-\n-        /* Algebraic type constructors */\n-        case (REC) { ret \"rec\"; }\n-        case (TUP) { ret \"tup\"; }\n-        case (TAG) { ret \"tag\"; }\n-        case (VEC) { ret \"vec\"; }\n-        case (ANY) { ret \"any\"; }\n-\n-        /* Callable type constructors */\n-        case (FN) { ret \"fn\"; }\n-        case (PRED) { ret \"pred\"; }\n-        case (ITER) { ret \"iter\"; }\n-\n-        /* Object type */\n-        case (OBJ) { ret \"obj\"; }\n-        case (SELF) { ret \"self\"; }\n-\n-\n-        /* Comm and task types */\n-        case (CHAN) { ret \"chan\"; }\n-        case (PORT) { ret \"port\"; }\n-        case (TASK) { ret \"task\"; }\n-\n         case (BRACEQUOTE(_)) { ret \"<bracequote>\"; }\n         case (EOF) { ret \"<eof>\"; }\n     }"}, {"sha": "0bdd5c8379fa04a45640eca83ad59fb4c149b38b", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57ffa2a487ef12a4abf538efc2dd8192ca308271/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ffa2a487ef12a4abf538efc2dd8192ca308271/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=57ffa2a487ef12a4abf538efc2dd8192ca308271", "patch": "@@ -9,7 +9,6 @@ import util::common;\n import pp::end; import pp::wrd; import pp::space; import pp::line;\n \n const uint indent_unit = 4u;\n-const int as_prec = 5;\n const uint default_columns = 78u;\n \n type ps = @rec(pp::ps s,\n@@ -494,7 +493,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n             print_literal(s, lit);\n         }\n         case (ast::expr_cast(?expr,?ty,_)) {\n-            print_maybe_parens(s, expr, as_prec);\n+            print_maybe_parens(s, expr, front::parser::as_prec);\n             space(s.s);\n             wrd1(s, \"as\");\n             print_type(s, ty);\n@@ -888,7 +887,7 @@ fn print_maybe_parens(ps s, @ast::expr expr, int outer_prec) {\n             add_them = operator_prec(op) < outer_prec;\n         }\n         case (ast::expr_cast(_,_,_)) {\n-            add_them = as_prec < outer_prec;\n+            add_them = front::parser::as_prec < outer_prec;\n         }\n         case (_) {\n             add_them = false;"}, {"sha": "0267084eefb79a5b3487a4512bc053c3e3f64a39", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57ffa2a487ef12a4abf538efc2dd8192ca308271/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/57ffa2a487ef12a4abf538efc2dd8192ca308271/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=57ffa2a487ef12a4abf538efc2dd8192ca308271", "patch": "@@ -73,7 +73,7 @@ mod lib {\n                 mod llvm;\n             }\n         }\n-        else {\n+        case (_) {\n             let (llvm_lib = \"librustllvm.so\") {\n                 mod llvm;\n             }"}, {"sha": "6e2650e6b8a153f757845a21f621d99fbc44d6ff", "filename": "src/lib/std.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57ffa2a487ef12a4abf538efc2dd8192ca308271/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/57ffa2a487ef12a4abf538efc2dd8192ca308271/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=57ffa2a487ef12a4abf538efc2dd8192ca308271", "patch": "@@ -51,7 +51,7 @@ alt (target_os) {\n     } case (\"macos\") {\n         mod os = \"macos_os.rs\";\n         mod os_fs = \"posix_fs.rs\";\n-    } else {\n+    } case (_) {\n         mod os = \"linux_os.rs\";\n         mod os_fs = \"posix_fs.rs\";\n     }"}]}