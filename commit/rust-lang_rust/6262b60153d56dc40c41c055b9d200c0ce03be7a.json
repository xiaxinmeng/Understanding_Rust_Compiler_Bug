{"sha": "6262b60153d56dc40c41c055b9d200c0ce03be7a", "node_id": "C_kwDOAAsO6NoAKDYyNjJiNjAxNTNkNTZkYzQwYzQxYzA1NWI5ZDIwMGMwY2UwM2JlN2E", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-02T15:48:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-02T15:48:52Z"}, "message": "Auto merge of #12136 - jonas-schievink:lexedstr-converter, r=jonas-schievink\n\ninternal: Add a `Converter` type for token conversion\n\nMakes it easier to produce multiple tokens from a single rustc token, if that's how we want to approach https://github.com/rust-analyzer/rust-analyzer/issues/1109", "tree": {"sha": "cb6aea4a229472b4c98660ac3f9972c93f6cc908", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb6aea4a229472b4c98660ac3f9972c93f6cc908"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6262b60153d56dc40c41c055b9d200c0ce03be7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6262b60153d56dc40c41c055b9d200c0ce03be7a", "html_url": "https://github.com/rust-lang/rust/commit/6262b60153d56dc40c41c055b9d200c0ce03be7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6262b60153d56dc40c41c055b9d200c0ce03be7a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f83dccf5b911d32ad474ccced183995d2ddbfea5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f83dccf5b911d32ad474ccced183995d2ddbfea5", "html_url": "https://github.com/rust-lang/rust/commit/f83dccf5b911d32ad474ccced183995d2ddbfea5"}, {"sha": "1f50e19eb2500a4439302fc409625057f3c4c91b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f50e19eb2500a4439302fc409625057f3c4c91b", "html_url": "https://github.com/rust-lang/rust/commit/1f50e19eb2500a4439302fc409625057f3c4c91b"}], "stats": {"total": 311, "additions": 168, "deletions": 143}, "files": [{"sha": "f4b9988eacb0c25b7d092d83cbddb0f8f020b36e", "filename": "crates/parser/src/lexed_str.rs", "status": "modified", "additions": 168, "deletions": 143, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/6262b60153d56dc40c41c055b9d200c0ce03be7a/crates%2Fparser%2Fsrc%2Flexed_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6262b60153d56dc40c41c055b9d200c0ce03be7a/crates%2Fparser%2Fsrc%2Flexed_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flexed_str.rs?ref=6262b60153d56dc40c41c055b9d200c0ce03be7a", "patch": "@@ -29,29 +29,19 @@ struct LexError {\n \n impl<'a> LexedStr<'a> {\n     pub fn new(text: &'a str) -> LexedStr<'a> {\n-        let mut res = LexedStr { text, kind: Vec::new(), start: Vec::new(), error: Vec::new() };\n-\n-        let mut offset = 0;\n+        let mut conv = Converter::new(text);\n         if let Some(shebang_len) = rustc_lexer::strip_shebang(text) {\n-            res.push(SHEBANG, offset);\n-            offset = shebang_len\n+            conv.res.push(SHEBANG, conv.offset);\n+            conv.offset = shebang_len;\n         };\n-        for token in rustc_lexer::tokenize(&text[offset..]) {\n-            let token_text = &text[offset..][..token.len];\n \n-            let (kind, err) = from_rustc(&token.kind, token_text);\n-            res.push(kind, offset);\n-            offset += token.len;\n+        for token in rustc_lexer::tokenize(&text[conv.offset..]) {\n+            let token_text = &text[conv.offset..][..token.len];\n \n-            if let Some(err) = err {\n-                let token = res.len() as u32;\n-                let msg = err.to_string();\n-                res.error.push(LexError { msg, token });\n-            }\n+            conv.extend_token(&token.kind, token_text);\n         }\n-        res.push(EOF, offset);\n \n-        res\n+        conv.finalize_with_eof()\n     }\n \n     pub fn single_token(text: &'a str) -> Option<(SyntaxKind, Option<String>)> {\n@@ -64,8 +54,12 @@ impl<'a> LexedStr<'a> {\n             return None;\n         }\n \n-        let (kind, err) = from_rustc(&token.kind, text);\n-        Some((kind, err.map(|it| it.to_owned())))\n+        let mut conv = Converter::new(text);\n+        conv.extend_token(&token.kind, text);\n+        match &*conv.res.kind {\n+            [kind] => Some((*kind, conv.res.error.pop().map(|it| it.msg.clone()))),\n+            _ => None,\n+        }\n     }\n \n     pub fn as_str(&self) -> &str {\n@@ -128,148 +122,179 @@ impl<'a> LexedStr<'a> {\n     }\n }\n \n-/// Returns `SyntaxKind` and an optional tokenize error message.\n-fn from_rustc(\n-    kind: &rustc_lexer::TokenKind,\n-    token_text: &str,\n-) -> (SyntaxKind, Option<&'static str>) {\n-    // A note on an intended tradeoff:\n-    // We drop some useful information here (see patterns with double dots `..`)\n-    // Storing that info in `SyntaxKind` is not possible due to its layout requirements of\n-    // being `u16` that come from `rowan::SyntaxKind`.\n-    let mut err = \"\";\n-\n-    let syntax_kind = {\n-        match kind {\n-            rustc_lexer::TokenKind::LineComment { doc_style: _ } => COMMENT,\n-            rustc_lexer::TokenKind::BlockComment { doc_style: _, terminated } => {\n-                if !terminated {\n-                    err = \"Missing trailing `*/` symbols to terminate the block comment\";\n+struct Converter<'a> {\n+    res: LexedStr<'a>,\n+    offset: usize,\n+}\n+\n+impl<'a> Converter<'a> {\n+    fn new(text: &'a str) -> Self {\n+        Self {\n+            res: LexedStr { text, kind: Vec::new(), start: Vec::new(), error: Vec::new() },\n+            offset: 0,\n+        }\n+    }\n+\n+    fn finalize_with_eof(mut self) -> LexedStr<'a> {\n+        self.res.push(EOF, self.offset);\n+        self.res\n+    }\n+\n+    fn push(&mut self, kind: SyntaxKind, len: usize, err: Option<&str>) {\n+        self.res.push(kind, self.offset);\n+        self.offset += len;\n+\n+        if let Some(err) = err {\n+            let token = self.res.len() as u32;\n+            let msg = err.to_string();\n+            self.res.error.push(LexError { msg, token });\n+        }\n+    }\n+\n+    fn extend_token(&mut self, kind: &rustc_lexer::TokenKind, token_text: &str) {\n+        // A note on an intended tradeoff:\n+        // We drop some useful information here (see patterns with double dots `..`)\n+        // Storing that info in `SyntaxKind` is not possible due to its layout requirements of\n+        // being `u16` that come from `rowan::SyntaxKind`.\n+        let mut err = \"\";\n+\n+        let syntax_kind = {\n+            match kind {\n+                rustc_lexer::TokenKind::LineComment { doc_style: _ } => COMMENT,\n+                rustc_lexer::TokenKind::BlockComment { doc_style: _, terminated } => {\n+                    if !terminated {\n+                        err = \"Missing trailing `*/` symbols to terminate the block comment\";\n+                    }\n+                    COMMENT\n                 }\n-                COMMENT\n-            }\n \n-            rustc_lexer::TokenKind::Whitespace => WHITESPACE,\n+                rustc_lexer::TokenKind::Whitespace => WHITESPACE,\n \n-            rustc_lexer::TokenKind::Ident if token_text == \"_\" => UNDERSCORE,\n-            rustc_lexer::TokenKind::Ident => SyntaxKind::from_keyword(token_text).unwrap_or(IDENT),\n+                rustc_lexer::TokenKind::Ident if token_text == \"_\" => UNDERSCORE,\n+                rustc_lexer::TokenKind::Ident => {\n+                    SyntaxKind::from_keyword(token_text).unwrap_or(IDENT)\n+                }\n \n-            rustc_lexer::TokenKind::RawIdent => IDENT,\n-            rustc_lexer::TokenKind::Literal { kind, .. } => return from_rustc_literal(kind),\n+                rustc_lexer::TokenKind::RawIdent => IDENT,\n+                rustc_lexer::TokenKind::Literal { kind, .. } => {\n+                    self.extend_literal(token_text.len(), kind);\n+                    return;\n+                }\n \n-            rustc_lexer::TokenKind::Lifetime { starts_with_number } => {\n-                if *starts_with_number {\n-                    err = \"Lifetime name cannot start with a number\";\n+                rustc_lexer::TokenKind::Lifetime { starts_with_number } => {\n+                    if *starts_with_number {\n+                        err = \"Lifetime name cannot start with a number\";\n+                    }\n+                    LIFETIME_IDENT\n                 }\n-                LIFETIME_IDENT\n-            }\n \n-            rustc_lexer::TokenKind::Semi => T![;],\n-            rustc_lexer::TokenKind::Comma => T![,],\n-            rustc_lexer::TokenKind::Dot => T![.],\n-            rustc_lexer::TokenKind::OpenParen => T!['('],\n-            rustc_lexer::TokenKind::CloseParen => T![')'],\n-            rustc_lexer::TokenKind::OpenBrace => T!['{'],\n-            rustc_lexer::TokenKind::CloseBrace => T!['}'],\n-            rustc_lexer::TokenKind::OpenBracket => T!['['],\n-            rustc_lexer::TokenKind::CloseBracket => T![']'],\n-            rustc_lexer::TokenKind::At => T![@],\n-            rustc_lexer::TokenKind::Pound => T![#],\n-            rustc_lexer::TokenKind::Tilde => T![~],\n-            rustc_lexer::TokenKind::Question => T![?],\n-            rustc_lexer::TokenKind::Colon => T![:],\n-            rustc_lexer::TokenKind::Dollar => T![$],\n-            rustc_lexer::TokenKind::Eq => T![=],\n-            rustc_lexer::TokenKind::Bang => T![!],\n-            rustc_lexer::TokenKind::Lt => T![<],\n-            rustc_lexer::TokenKind::Gt => T![>],\n-            rustc_lexer::TokenKind::Minus => T![-],\n-            rustc_lexer::TokenKind::And => T![&],\n-            rustc_lexer::TokenKind::Or => T![|],\n-            rustc_lexer::TokenKind::Plus => T![+],\n-            rustc_lexer::TokenKind::Star => T![*],\n-            rustc_lexer::TokenKind::Slash => T![/],\n-            rustc_lexer::TokenKind::Caret => T![^],\n-            rustc_lexer::TokenKind::Percent => T![%],\n-            rustc_lexer::TokenKind::Unknown => ERROR,\n-        }\n-    };\n+                rustc_lexer::TokenKind::Semi => T![;],\n+                rustc_lexer::TokenKind::Comma => T![,],\n+                rustc_lexer::TokenKind::Dot => T![.],\n+                rustc_lexer::TokenKind::OpenParen => T!['('],\n+                rustc_lexer::TokenKind::CloseParen => T![')'],\n+                rustc_lexer::TokenKind::OpenBrace => T!['{'],\n+                rustc_lexer::TokenKind::CloseBrace => T!['}'],\n+                rustc_lexer::TokenKind::OpenBracket => T!['['],\n+                rustc_lexer::TokenKind::CloseBracket => T![']'],\n+                rustc_lexer::TokenKind::At => T![@],\n+                rustc_lexer::TokenKind::Pound => T![#],\n+                rustc_lexer::TokenKind::Tilde => T![~],\n+                rustc_lexer::TokenKind::Question => T![?],\n+                rustc_lexer::TokenKind::Colon => T![:],\n+                rustc_lexer::TokenKind::Dollar => T![$],\n+                rustc_lexer::TokenKind::Eq => T![=],\n+                rustc_lexer::TokenKind::Bang => T![!],\n+                rustc_lexer::TokenKind::Lt => T![<],\n+                rustc_lexer::TokenKind::Gt => T![>],\n+                rustc_lexer::TokenKind::Minus => T![-],\n+                rustc_lexer::TokenKind::And => T![&],\n+                rustc_lexer::TokenKind::Or => T![|],\n+                rustc_lexer::TokenKind::Plus => T![+],\n+                rustc_lexer::TokenKind::Star => T![*],\n+                rustc_lexer::TokenKind::Slash => T![/],\n+                rustc_lexer::TokenKind::Caret => T![^],\n+                rustc_lexer::TokenKind::Percent => T![%],\n+                rustc_lexer::TokenKind::Unknown => ERROR,\n+            }\n+        };\n \n-    let err = if err.is_empty() { None } else { Some(err) };\n-    (syntax_kind, err)\n-}\n+        let err = if err.is_empty() { None } else { Some(err) };\n+        self.push(syntax_kind, token_text.len(), err);\n+    }\n \n-fn from_rustc_literal(kind: &rustc_lexer::LiteralKind) -> (SyntaxKind, Option<&'static str>) {\n-    let mut err = \"\";\n+    fn extend_literal(&mut self, len: usize, kind: &rustc_lexer::LiteralKind) {\n+        let mut err = \"\";\n \n-    let syntax_kind = match *kind {\n-        rustc_lexer::LiteralKind::Int { empty_int, base: _ } => {\n-            if empty_int {\n-                err = \"Missing digits after the integer base prefix\";\n+        let syntax_kind = match *kind {\n+            rustc_lexer::LiteralKind::Int { empty_int, base: _ } => {\n+                if empty_int {\n+                    err = \"Missing digits after the integer base prefix\";\n+                }\n+                INT_NUMBER\n             }\n-            INT_NUMBER\n-        }\n-        rustc_lexer::LiteralKind::Float { empty_exponent, base: _ } => {\n-            if empty_exponent {\n-                err = \"Missing digits after the exponent symbol\";\n+            rustc_lexer::LiteralKind::Float { empty_exponent, base: _ } => {\n+                if empty_exponent {\n+                    err = \"Missing digits after the exponent symbol\";\n+                }\n+                FLOAT_NUMBER\n             }\n-            FLOAT_NUMBER\n-        }\n-        rustc_lexer::LiteralKind::Char { terminated } => {\n-            if !terminated {\n-                err = \"Missing trailing `'` symbol to terminate the character literal\";\n+            rustc_lexer::LiteralKind::Char { terminated } => {\n+                if !terminated {\n+                    err = \"Missing trailing `'` symbol to terminate the character literal\";\n+                }\n+                CHAR\n             }\n-            CHAR\n-        }\n-        rustc_lexer::LiteralKind::Byte { terminated } => {\n-            if !terminated {\n-                err = \"Missing trailing `'` symbol to terminate the byte literal\";\n+            rustc_lexer::LiteralKind::Byte { terminated } => {\n+                if !terminated {\n+                    err = \"Missing trailing `'` symbol to terminate the byte literal\";\n+                }\n+                BYTE\n             }\n-            BYTE\n-        }\n-        rustc_lexer::LiteralKind::Str { terminated } => {\n-            if !terminated {\n-                err = \"Missing trailing `\\\"` symbol to terminate the string literal\";\n+            rustc_lexer::LiteralKind::Str { terminated } => {\n+                if !terminated {\n+                    err = \"Missing trailing `\\\"` symbol to terminate the string literal\";\n+                }\n+                STRING\n             }\n-            STRING\n-        }\n-        rustc_lexer::LiteralKind::ByteStr { terminated } => {\n-            if !terminated {\n-                err = \"Missing trailing `\\\"` symbol to terminate the byte string literal\";\n+            rustc_lexer::LiteralKind::ByteStr { terminated } => {\n+                if !terminated {\n+                    err = \"Missing trailing `\\\"` symbol to terminate the byte string literal\";\n+                }\n+                BYTE_STRING\n             }\n-            BYTE_STRING\n-        }\n-        rustc_lexer::LiteralKind::RawStr { err: raw_str_err, .. } => {\n-            if let Some(raw_str_err) = raw_str_err {\n-                err = match raw_str_err {\n-                    rustc_lexer::RawStrError::InvalidStarter { .. } => \"Missing `\\\"` symbol after `#` symbols to begin the raw string literal\",\n-                    rustc_lexer::RawStrError::NoTerminator { expected, found, .. } => if expected == found {\n-                        \"Missing trailing `\\\"` to terminate the raw string literal\"\n-                    } else {\n-                        \"Missing trailing `\\\"` with `#` symbols to terminate the raw string literal\"\n-                    },\n-                    rustc_lexer::RawStrError::TooManyDelimiters { .. } => \"Too many `#` symbols: raw strings may be delimited by up to 65535 `#` symbols\",\n+            rustc_lexer::LiteralKind::RawStr { err: raw_str_err, .. } => {\n+                if let Some(raw_str_err) = raw_str_err {\n+                    err = match raw_str_err {\n+                        rustc_lexer::RawStrError::InvalidStarter { .. } => \"Missing `\\\"` symbol after `#` symbols to begin the raw string literal\",\n+                        rustc_lexer::RawStrError::NoTerminator { expected, found, .. } => if expected == found {\n+                            \"Missing trailing `\\\"` to terminate the raw string literal\"\n+                        } else {\n+                            \"Missing trailing `\\\"` with `#` symbols to terminate the raw string literal\"\n+                        },\n+                        rustc_lexer::RawStrError::TooManyDelimiters { .. } => \"Too many `#` symbols: raw strings may be delimited by up to 65535 `#` symbols\",\n+                    };\n                 };\n-            };\n-            STRING\n-        }\n-        rustc_lexer::LiteralKind::RawByteStr { err: raw_str_err, .. } => {\n-            if let Some(raw_str_err) = raw_str_err {\n-                err = match raw_str_err {\n-                    rustc_lexer::RawStrError::InvalidStarter { .. } => \"Missing `\\\"` symbol after `#` symbols to begin the raw byte string literal\",\n-                    rustc_lexer::RawStrError::NoTerminator { expected, found, .. } => if expected == found {\n-                        \"Missing trailing `\\\"` to terminate the raw byte string literal\"\n-                    } else {\n-                        \"Missing trailing `\\\"` with `#` symbols to terminate the raw byte string literal\"\n-                    },\n-                    rustc_lexer::RawStrError::TooManyDelimiters { .. } => \"Too many `#` symbols: raw byte strings may be delimited by up to 65535 `#` symbols\",\n+                STRING\n+            }\n+            rustc_lexer::LiteralKind::RawByteStr { err: raw_str_err, .. } => {\n+                if let Some(raw_str_err) = raw_str_err {\n+                    err = match raw_str_err {\n+                        rustc_lexer::RawStrError::InvalidStarter { .. } => \"Missing `\\\"` symbol after `#` symbols to begin the raw byte string literal\",\n+                        rustc_lexer::RawStrError::NoTerminator { expected, found, .. } => if expected == found {\n+                            \"Missing trailing `\\\"` to terminate the raw byte string literal\"\n+                        } else {\n+                            \"Missing trailing `\\\"` with `#` symbols to terminate the raw byte string literal\"\n+                        },\n+                        rustc_lexer::RawStrError::TooManyDelimiters { .. } => \"Too many `#` symbols: raw byte strings may be delimited by up to 65535 `#` symbols\",\n+                    };\n                 };\n-            };\n \n-            BYTE_STRING\n-        }\n-    };\n+                BYTE_STRING\n+            }\n+        };\n \n-    let err = if err.is_empty() { None } else { Some(err) };\n-    (syntax_kind, err)\n+        let err = if err.is_empty() { None } else { Some(err) };\n+        self.push(syntax_kind, len, err);\n+    }\n }"}]}