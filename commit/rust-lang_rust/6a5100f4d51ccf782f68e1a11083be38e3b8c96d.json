{"sha": "6a5100f4d51ccf782f68e1a11083be38e3b8c96d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNTEwMGY0ZDUxY2NmNzgyZjY4ZTFhMTEwODNiZTM4ZTNiOGM5NmQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-14T17:49:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-14T17:49:18Z"}, "message": "Merge #2834\n\n2834: refactor(ra_syntax.validation): removed code duplication from validate_literal() r=kiljacken a=Veetaha\n\nHi! This is my first ever contribution to this project.\r\nI've taken some dirty job from issue #223\r\n\r\nThis is a simple atomic PR to remove code duplication according to FIXME comment in the function that is the main focus of the further development.\r\n\r\nI just didn't want to mix refactoring with the implementation of new features...\r\n\r\nI am not sure whether you prefer such atomic PRs here or you'd rather have a single PR that contains all atomic commits inside of it?\r\n\r\nSo if you want me to add all that validation in one PR I'll mark this one as WIP and update it when the work is finished, otherwise, I'll go with the option of creating separate PRs per each feature of validation of strings, numbers, and comments respectively.\r\n\r\n### Comments about refactoring\r\nYeah, reducing the duplication is quite hard here, extracting into stateless functions could be another option but the number of their arguments would be very big and repeated across char and string implementations so that just writing their types and names would become cumbersome.\r\nI tried the option of having everything captured implicitly in the closure but failed since rust doesn't have templated (or generic) closures as C++ does, this is needed because `unescape_byte*()` and `unescape_char|str()` have different return types...\r\nMaybe I am missing something here? I may be wrong because I am not enough experienced in Rust...\r\nWell, I am awaiting any kind of feedback!\n\nCo-authored-by: Veetaha <gerzoh1@gmail.com>", "tree": {"sha": "293c1166513fa5c21f7f359dc65093ff376277e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/293c1166513fa5c21f7f359dc65093ff376277e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a5100f4d51ccf782f68e1a11083be38e3b8c96d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeHf8eCRBK7hj4Ov3rIwAAdHIIAIhlbSYIQMCG+gmhijdn5L3P\nuLvQjCFFkbHyCh/O0jvm1afBh2e6n4M1YCb4FgvcChcd1RrjJRRgG7St02T17Ihr\ngIT/Z7OnzUMV5G6+2pF3ERJEDCXKI1cxzXrKxiqTnkjIWM3NkGtJk+v8ydoqCP/u\n2EFSZ6/vcHZj+aYGHeHPANQeHu1V0N+60Ohh6NYWKqV3vaWvVjJvLhdWs06tx4K1\niawERsL+N0DZhdk+b+RaoTyuOUljIt1FajOwJK6eZYM3SlHj2dCzuOoyvHNF7yNV\nQUJRA/HDhxY35cQrE9PLAE8iGqNLue3Fp7emGxmol6WKZqDaEU2an0Uk4f4Fk/Q=\n=jgOT\n-----END PGP SIGNATURE-----\n", "payload": "tree 293c1166513fa5c21f7f359dc65093ff376277e9\nparent e406f2bed66cbe13ef6441a3fb84791a3ca09299\nparent 60251da204e9b814a2947895851dfc78539e92f3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1579024158 +0000\ncommitter GitHub <noreply@github.com> 1579024158 +0000\n\nMerge #2834\n\n2834: refactor(ra_syntax.validation): removed code duplication from validate_literal() r=kiljacken a=Veetaha\n\nHi! This is my first ever contribution to this project.\r\nI've taken some dirty job from issue #223\r\n\r\nThis is a simple atomic PR to remove code duplication according to FIXME comment in the function that is the main focus of the further development.\r\n\r\nI just didn't want to mix refactoring with the implementation of new features...\r\n\r\nI am not sure whether you prefer such atomic PRs here or you'd rather have a single PR that contains all atomic commits inside of it?\r\n\r\nSo if you want me to add all that validation in one PR I'll mark this one as WIP and update it when the work is finished, otherwise, I'll go with the option of creating separate PRs per each feature of validation of strings, numbers, and comments respectively.\r\n\r\n### Comments about refactoring\r\nYeah, reducing the duplication is quite hard here, extracting into stateless functions could be another option but the number of their arguments would be very big and repeated across char and string implementations so that just writing their types and names would become cumbersome.\r\nI tried the option of having everything captured implicitly in the closure but failed since rust doesn't have templated (or generic) closures as C++ does, this is needed because `unescape_byte*()` and `unescape_char|str()` have different return types...\r\nMaybe I am missing something here? I may be wrong because I am not enough experienced in Rust...\r\nWell, I am awaiting any kind of feedback!\n\nCo-authored-by: Veetaha <gerzoh1@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a5100f4d51ccf782f68e1a11083be38e3b8c96d", "html_url": "https://github.com/rust-lang/rust/commit/6a5100f4d51ccf782f68e1a11083be38e3b8c96d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a5100f4d51ccf782f68e1a11083be38e3b8c96d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e406f2bed66cbe13ef6441a3fb84791a3ca09299", "url": "https://api.github.com/repos/rust-lang/rust/commits/e406f2bed66cbe13ef6441a3fb84791a3ca09299", "html_url": "https://github.com/rust-lang/rust/commit/e406f2bed66cbe13ef6441a3fb84791a3ca09299"}, {"sha": "60251da204e9b814a2947895851dfc78539e92f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/60251da204e9b814a2947895851dfc78539e92f3", "html_url": "https://github.com/rust-lang/rust/commit/60251da204e9b814a2947895851dfc78539e92f3"}], "stats": {"total": 61, "additions": 26, "deletions": 35}, "files": [{"sha": "445e3b3e469e2baa3a514c503a2f432e066c3a56", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6a5100f4d51ccf782f68e1a11083be38e3b8c96d/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5100f4d51ccf782f68e1a11083be38e3b8c96d/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=6a5100f4d51ccf782f68e1a11083be38e3b8c96d", "patch": "@@ -111,55 +111,46 @@ pub(crate) fn validate(root: &SyntaxNode) -> Vec<SyntaxError> {\n     errors\n }\n \n-// FIXME: kill duplication\n fn validate_literal(literal: ast::Literal, acc: &mut Vec<SyntaxError>) {\n+    fn unquote(text: &str, prefix_len: usize, end_delimiter: char) -> Option<&str> {\n+        text.rfind(end_delimiter).and_then(|end| text.get(prefix_len..end))\n+    }\n+\n     let token = literal.token();\n     let text = token.text().as_str();\n+\n+    let mut push_err = |prefix_len, (off, err): (usize, unescape::EscapeError)| {\n+        let off = token.text_range().start() + TextUnit::from_usize(off + prefix_len);\n+        acc.push(SyntaxError::new(err.into(), off));\n+    };\n+\n     match token.kind() {\n         BYTE => {\n-            if let Some(end) = text.rfind('\\'') {\n-                if let Some(without_quotes) = text.get(2..end) {\n-                    if let Err((off, err)) = unescape::unescape_byte(without_quotes) {\n-                        let off = token.text_range().start() + TextUnit::from_usize(off + 2);\n-                        acc.push(SyntaxError::new(err.into(), off))\n-                    }\n-                }\n+            if let Some(Err(e)) = unquote(text, 2, '\\'').map(unescape::unescape_byte) {\n+                push_err(2, e);\n             }\n         }\n         CHAR => {\n-            if let Some(end) = text.rfind('\\'') {\n-                if let Some(without_quotes) = text.get(1..end) {\n-                    if let Err((off, err)) = unescape::unescape_char(without_quotes) {\n-                        let off = token.text_range().start() + TextUnit::from_usize(off + 1);\n-                        acc.push(SyntaxError::new(err.into(), off))\n-                    }\n-                }\n+            if let Some(Err(e)) = unquote(text, 1, '\\'').map(unescape::unescape_char) {\n+                push_err(1, e);\n             }\n         }\n         BYTE_STRING => {\n-            if let Some(end) = text.rfind('\\\"') {\n-                if let Some(without_quotes) = text.get(2..end) {\n-                    unescape::unescape_byte_str(without_quotes, &mut |range, char| {\n-                        if let Err(err) = char {\n-                            let off = range.start;\n-                            let off = token.text_range().start() + TextUnit::from_usize(off + 2);\n-                            acc.push(SyntaxError::new(err.into(), off))\n-                        }\n-                    })\n-                }\n+            if let Some(without_quotes) = unquote(text, 2, '\"') {\n+                unescape::unescape_byte_str(without_quotes, &mut |range, char| {\n+                    if let Err(err) = char {\n+                        push_err(2, (range.start, err));\n+                    }\n+                })\n             }\n         }\n         STRING => {\n-            if let Some(end) = text.rfind('\\\"') {\n-                if let Some(without_quotes) = text.get(1..end) {\n-                    unescape::unescape_str(without_quotes, &mut |range, char| {\n-                        if let Err(err) = char {\n-                            let off = range.start;\n-                            let off = token.text_range().start() + TextUnit::from_usize(off + 1);\n-                            acc.push(SyntaxError::new(err.into(), off))\n-                        }\n-                    })\n-                }\n+            if let Some(without_quotes) = unquote(text, 1, '\"') {\n+                unescape::unescape_str(without_quotes, &mut |range, char| {\n+                    if let Err(err) = char {\n+                        push_err(1, (range.start, err));\n+                    }\n+                })\n             }\n         }\n         _ => (),"}]}