{"sha": "67421bdfdf278f3737595c27a77d90bacd4215f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NDIxYmRmZGYyNzhmMzczNzU5NWMyN2E3N2Q5MGJhY2Q0MjE1ZjM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-11-13T20:10:58Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-11-27T13:15:57Z"}, "message": "rustc_metadata: replace PerDefTable<T> with Table<DefIndex, T>.", "tree": {"sha": "87a34eccbcd79da0de9737c2005f7f7cd25d3fcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87a34eccbcd79da0de9737c2005f7f7cd25d3fcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67421bdfdf278f3737595c27a77d90bacd4215f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67421bdfdf278f3737595c27a77d90bacd4215f3", "html_url": "https://github.com/rust-lang/rust/commit/67421bdfdf278f3737595c27a77d90bacd4215f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67421bdfdf278f3737595c27a77d90bacd4215f3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "876a72a251e0d533f776fa9149b3e4daaeea3a61", "url": "https://api.github.com/repos/rust-lang/rust/commits/876a72a251e0d533f776fa9149b3e4daaeea3a61", "html_url": "https://github.com/rust-lang/rust/commit/876a72a251e0d533f776fa9149b3e4daaeea3a61"}], "stats": {"total": 181, "additions": 68, "deletions": 113}, "files": [{"sha": "47a48c1778666b3fa59fdda5fce631ff3f88abf0", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67421bdfdf278f3737595c27a77d90bacd4215f3/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67421bdfdf278f3737595c27a77d90bacd4215f3/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=67421bdfdf278f3737595c27a77d90bacd4215f3", "patch": "@@ -1,9 +1,9 @@\n // Decoding metadata from a single crate's metadata\n \n use crate::rmeta::*;\n-use crate::rmeta::table::{FixedSizeEncoding, PerDefTable};\n+use crate::rmeta::table::{FixedSizeEncoding, Table};\n \n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_data_structures::sync::{Lrc, Lock, Once, AtomicCell};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir::map::definitions::DefPathTable;\n@@ -341,10 +341,10 @@ impl<'a, 'tcx, T: Encodable> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a,\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<PerDefTable<T>>> for DecodeContext<'a, 'tcx>\n+impl<'a, 'tcx, I: Idx, T> SpecializedDecoder<Lazy<Table<I, T>>> for DecodeContext<'a, 'tcx>\n     where Option<T>: FixedSizeEncoding,\n {\n-    fn specialized_decode(&mut self) -> Result<Lazy<PerDefTable<T>>, Self::Error> {\n+    fn specialized_decode(&mut self) -> Result<Lazy<Table<I, T>>, Self::Error> {\n         let len = self.read_usize()?;\n         self.read_lazy_with_meta(len)\n     }"}, {"sha": "5feb54bb8fa2dd664feebecbb45802a0ec9c082d", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/67421bdfdf278f3737595c27a77d90bacd4215f3/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67421bdfdf278f3737595c27a77d90bacd4215f3/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=67421bdfdf278f3737595c27a77d90bacd4215f3", "patch": "@@ -1,5 +1,5 @@\n use crate::rmeta::*;\n-use crate::rmeta::table::{FixedSizeEncoding, PerDefTable};\n+use crate::rmeta::table::{FixedSizeEncoding, Table};\n \n use rustc::middle::cstore::{LinkagePreference, NativeLibrary,\n                             EncodedMetadata, ForeignModule};\n@@ -8,7 +8,7 @@ use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LocalDefId,\n use rustc::hir::{GenericParamKind, AnonConst};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel,\n                                       metadata_symbol_name};\n@@ -62,26 +62,26 @@ struct EncodeContext<'tcx> {\n \n #[derive(Default)]\n struct PerDefTables<'tcx> {\n-    kind: PerDefTable<Lazy<EntryKind<'tcx>>>,\n-    visibility: PerDefTable<Lazy<ty::Visibility>>,\n-    span: PerDefTable<Lazy<Span>>,\n-    attributes: PerDefTable<Lazy<[ast::Attribute]>>,\n-    children: PerDefTable<Lazy<[DefIndex]>>,\n-    stability: PerDefTable<Lazy<attr::Stability>>,\n-    deprecation: PerDefTable<Lazy<attr::Deprecation>>,\n-\n-    ty: PerDefTable<Lazy<Ty<'tcx>>>,\n-    fn_sig: PerDefTable<Lazy<ty::PolyFnSig<'tcx>>>,\n-    impl_trait_ref: PerDefTable<Lazy<ty::TraitRef<'tcx>>>,\n-    inherent_impls: PerDefTable<Lazy<[DefIndex]>>,\n-    variances: PerDefTable<Lazy<[ty::Variance]>>,\n-    generics: PerDefTable<Lazy<ty::Generics>>,\n-    explicit_predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n-    inferred_outlives: PerDefTable<Lazy<&'tcx [(ty::Predicate<'tcx>, Span)]>>,\n-    super_predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n-\n-    mir: PerDefTable<Lazy<mir::Body<'tcx>>>,\n-    promoted_mir: PerDefTable<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n+    kind: Table<DefIndex, Lazy<EntryKind<'tcx>>>,\n+    visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n+    span: Table<DefIndex, Lazy<Span>>,\n+    attributes: Table<DefIndex, Lazy<[ast::Attribute]>>,\n+    children: Table<DefIndex, Lazy<[DefIndex]>>,\n+    stability: Table<DefIndex, Lazy<attr::Stability>>,\n+    deprecation: Table<DefIndex, Lazy<attr::Deprecation>>,\n+\n+    ty: Table<DefIndex, Lazy<Ty<'tcx>>>,\n+    fn_sig: Table<DefIndex, Lazy<ty::PolyFnSig<'tcx>>>,\n+    impl_trait_ref: Table<DefIndex, Lazy<ty::TraitRef<'tcx>>>,\n+    inherent_impls: Table<DefIndex, Lazy<[DefIndex]>>,\n+    variances: Table<DefIndex, Lazy<[ty::Variance]>>,\n+    generics: Table<DefIndex, Lazy<ty::Generics>>,\n+    explicit_predicates: Table<DefIndex, Lazy<ty::GenericPredicates<'tcx>>>,\n+    inferred_outlives: Table<DefIndex, Lazy<&'tcx [(ty::Predicate<'tcx>, Span)]>>,\n+    super_predicates: Table<DefIndex, Lazy<ty::GenericPredicates<'tcx>>>,\n+\n+    mir: Table<DefIndex, Lazy<mir::Body<'tcx>>>,\n+    promoted_mir: Table<DefIndex, Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n }\n \n macro_rules! encoder_methods {\n@@ -138,10 +138,10 @@ impl<'tcx, T: Encodable> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx, T> SpecializedEncoder<Lazy<PerDefTable<T>>> for EncodeContext<'tcx>\n+impl<'tcx, I: Idx, T> SpecializedEncoder<Lazy<Table<I, T>>> for EncodeContext<'tcx>\n     where Option<T>: FixedSizeEncoding,\n {\n-    fn specialized_encode(&mut self, lazy: &Lazy<PerDefTable<T>>) -> Result<(), Self::Error> {\n+    fn specialized_encode(&mut self, lazy: &Lazy<Table<I, T>>) -> Result<(), Self::Error> {\n         self.emit_usize(lazy.meta)?;\n         self.emit_lazy_distance(*lazy)\n     }\n@@ -307,14 +307,14 @@ impl<I, T: Encodable> EncodeContentsForLazy<[T]> for I\n     }\n }\n \n-// Shorthand for `$self.$tables.$table.set($key, $self.lazy($value))`, which would\n+// Shorthand for `$self.$tables.$table.set($def_id.index, $self.lazy($value))`, which would\n // normally need extra variables to avoid errors about multiple mutable borrows.\n macro_rules! record {\n-    ($self:ident.$tables:ident.$table:ident[$key:expr] <- $value:expr) => {{\n+    ($self:ident.$tables:ident.$table:ident[$def_id:expr] <- $value:expr) => {{\n         {\n             let value = $value;\n             let lazy = $self.lazy(value);\n-            $self.$tables.$table.set($key, lazy);\n+            $self.$tables.$table.set($def_id.index, lazy);\n         }\n     }}\n }"}, {"sha": "3b82b287259e8c7077b595b0c350dc33220c7d80", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/67421bdfdf278f3737595c27a77d90bacd4215f3/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67421bdfdf278f3737595c27a77d90bacd4215f3/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=67421bdfdf278f3737595c27a77d90bacd4215f3", "patch": "@@ -1,5 +1,5 @@\n use decoder::Metadata;\n-use table::PerDefTable;\n+use table::Table;\n \n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n@@ -166,8 +166,7 @@ enum LazyState {\n // manually, instead of relying on the default, to get the correct variance.\n // Only needed when `T` itself contains a parameter (e.g. `'tcx`).\n macro_rules! Lazy {\n-    (Table<$T:ty>) => {Lazy<Table<$T>, usize>};\n-    (PerDefTable<$T:ty>) => {Lazy<PerDefTable<$T>, usize>};\n+    (Table<$I:ty, $T:ty>) => {Lazy<Table<$I, $T>, usize>};\n     ([$T:ty]) => {Lazy<[$T], usize>};\n     ($T:ty) => {Lazy<$T, ()>};\n }\n@@ -234,29 +233,29 @@ crate struct TraitImpls {\n \n #[derive(RustcEncodable, RustcDecodable)]\n crate struct LazyPerDefTables<'tcx> {\n-    kind: Lazy!(PerDefTable<Lazy!(EntryKind<'tcx>)>),\n-    visibility: Lazy!(PerDefTable<Lazy<ty::Visibility>>),\n-    span: Lazy!(PerDefTable<Lazy<Span>>),\n-    attributes: Lazy!(PerDefTable<Lazy<[ast::Attribute]>>),\n-    children: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n-    stability: Lazy!(PerDefTable<Lazy<attr::Stability>>),\n-    deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n-    ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n-    fn_sig: Lazy!(PerDefTable<Lazy!(ty::PolyFnSig<'tcx>)>),\n-    impl_trait_ref: Lazy!(PerDefTable<Lazy!(ty::TraitRef<'tcx>)>),\n-    inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n-    variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n-    generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n-    explicit_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    kind: Lazy!(Table<DefIndex, Lazy!(EntryKind<'tcx>)>),\n+    visibility: Lazy!(Table<DefIndex, Lazy<ty::Visibility>>),\n+    span: Lazy!(Table<DefIndex, Lazy<Span>>),\n+    attributes: Lazy!(Table<DefIndex, Lazy<[ast::Attribute]>>),\n+    children: Lazy!(Table<DefIndex, Lazy<[DefIndex]>>),\n+    stability: Lazy!(Table<DefIndex, Lazy<attr::Stability>>),\n+    deprecation: Lazy!(Table<DefIndex, Lazy<attr::Deprecation>>),\n+    ty: Lazy!(Table<DefIndex, Lazy!(Ty<'tcx>)>),\n+    fn_sig: Lazy!(Table<DefIndex, Lazy!(ty::PolyFnSig<'tcx>)>),\n+    impl_trait_ref: Lazy!(Table<DefIndex, Lazy!(ty::TraitRef<'tcx>)>),\n+    inherent_impls: Lazy!(Table<DefIndex, Lazy<[DefIndex]>>),\n+    variances: Lazy!(Table<DefIndex, Lazy<[ty::Variance]>>),\n+    generics: Lazy!(Table<DefIndex, Lazy<ty::Generics>>),\n+    explicit_predicates: Lazy!(Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>),\n     // FIXME(eddyb) this would ideally be `Lazy<[...]>` but `ty::Predicate`\n     // doesn't handle shorthands in its own (de)serialization impls,\n     // as it's an `enum` for which we want to derive (de)serialization,\n     // so the `ty::codec` APIs handle the whole `&'tcx [...]` at once.\n     // Also, as an optimization, a missing entry indicates an empty `&[]`.\n-    inferred_outlives: Lazy!(PerDefTable<Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>),\n-    super_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n-    mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),\n-    promoted_mir: Lazy!(PerDefTable<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n+    inferred_outlives: Lazy!(Table<DefIndex, Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>),\n+    super_predicates: Lazy!(Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>),\n+    mir: Lazy!(Table<DefIndex, Lazy!(mir::Body<'tcx>)>),\n+    promoted_mir: Lazy!(Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]"}, {"sha": "833d84bfb5d024e24601e48b0cc03b9cb07e0937", "filename": "src/librustc_metadata/rmeta/table.rs", "status": "modified", "additions": 17, "deletions": 61, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/67421bdfdf278f3737595c27a77d90bacd4215f3/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67421bdfdf278f3737595c27a77d90bacd4215f3/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs?ref=67421bdfdf278f3737595c27a77d90bacd4215f3", "patch": "@@ -1,6 +1,6 @@\n use crate::rmeta::*;\n \n-use rustc::hir::def_id::{DefId, DefIndex};\n+use rustc_index::vec::Idx;\n use rustc_serialize::{Encodable, opaque::Encoder};\n use std::convert::TryInto;\n use std::marker::PhantomData;\n@@ -125,14 +125,16 @@ impl<T: Encodable> FixedSizeEncoding for Option<Lazy<[T]>> {\n // FIXME(eddyb) replace `Vec` with `[_]` here, such that `Box<Table<T>>` would be used\n // when building it, and `Lazy<Table<T>>` or `&Table<T>` when reading it.\n // (not sure if that is possible given that the `Vec` is being resized now)\n-pub(super) struct Table<T> where Option<T>: FixedSizeEncoding {\n-    // FIXME(eddyb) store `[u8; <Option<T>>::BYTE_LEN]` instead of `u8` in `Vec`,\n-    // once that starts being allowed by the compiler (i.e. lazy normalization).\n+pub(super) struct Table<I: Idx, T> where Option<T>: FixedSizeEncoding {\n+    // FIXME(eddyb) use `IndexVec<I, [u8; <Option<T>>::BYTE_LEN]>` instead of\n+    // `Vec<u8>`, once that starts working (i.e. lazy normalization).\n+    // Then again, that has the downside of not allowing `Table::encode` to\n+    // obtain a `&[u8]` entirely in safe code, for writing the bytes out.\n     bytes: Vec<u8>,\n-    _marker: PhantomData<T>,\n+    _marker: PhantomData<(fn(&I), T)>,\n }\n \n-impl<T> Default for Table<T> where Option<T>: FixedSizeEncoding {\n+impl<I: Idx, T> Default for Table<I, T> where Option<T>: FixedSizeEncoding {\n     fn default() -> Self {\n         Table {\n             bytes: vec![],\n@@ -141,13 +143,14 @@ impl<T> Default for Table<T> where Option<T>: FixedSizeEncoding {\n     }\n }\n \n-impl<T> Table<T> where Option<T>: FixedSizeEncoding {\n-    fn set(&mut self, i: usize, value: T) {\n+impl<I: Idx, T> Table<I, T> where Option<T>: FixedSizeEncoding {\n+    pub(super) fn set(&mut self, i: I, value: T) {\n         // FIXME(eddyb) investigate more compact encodings for sparse tables.\n         // On the PR @michaelwoerister mentioned:\n         // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n         // > trick (i.e. divide things into buckets of 32 or 64 items and then\n         // > store bit-masks of which item in each bucket is actually serialized).\n+        let i = i.index();\n         let needed = (i + 1) * <Option<T>>::BYTE_LEN;\n         if self.bytes.len() < needed {\n             self.bytes.resize(needed, 0);\n@@ -156,7 +159,7 @@ impl<T> Table<T> where Option<T>: FixedSizeEncoding {\n         Some(value).write_to_bytes_at(&mut self.bytes, i);\n     }\n \n-    fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n+    pub(super) fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n         let pos = buf.position();\n         buf.emit_raw_bytes(&self.bytes);\n         Lazy::from_position_and_meta(\n@@ -166,73 +169,26 @@ impl<T> Table<T> where Option<T>: FixedSizeEncoding {\n     }\n }\n \n-impl<T> LazyMeta for Table<T> where Option<T>: FixedSizeEncoding {\n+impl<I: Idx, T> LazyMeta for Table<I, T> where Option<T>: FixedSizeEncoding {\n     type Meta = usize;\n \n     fn min_size(len: usize) -> usize {\n         len\n     }\n }\n \n-impl<T> Lazy<Table<T>> where Option<T>: FixedSizeEncoding {\n+impl<I: Idx, T> Lazy<Table<I, T>> where Option<T>: FixedSizeEncoding {\n     /// Given the metadata, extract out the value at a particular index (if any).\n     #[inline(never)]\n-    fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n+    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n         &self,\n         metadata: M,\n-        i: usize,\n+        i: I,\n     ) -> Option<T> {\n         debug!(\"Table::lookup: index={:?} len={:?}\", i, self.meta);\n \n         let start = self.position.get();\n         let bytes = &metadata.raw_bytes()[start..start + self.meta];\n-        <Option<T>>::maybe_read_from_bytes_at(bytes, i)?\n-    }\n-}\n-\n-/// Like a `Table` but using `DefIndex` instead of `usize` as keys.\n-// FIXME(eddyb) replace by making `Table` behave like `IndexVec`,\n-// and by using `newtype_index!` to define `DefIndex`.\n-pub(super) struct PerDefTable<T>(Table<T>) where Option<T>: FixedSizeEncoding;\n-\n-impl<T> Default for PerDefTable<T> where Option<T>: FixedSizeEncoding {\n-    fn default() -> Self {\n-        PerDefTable(Table::default())\n-    }\n-}\n-\n-impl<T> PerDefTable<T> where Option<T>: FixedSizeEncoding {\n-    pub(super) fn set(&mut self, def_id: DefId, value: T) {\n-        assert!(def_id.is_local());\n-        self.0.set(def_id.index.index(), value);\n-    }\n-\n-    pub(super) fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n-        let lazy = self.0.encode(buf);\n-        Lazy::from_position_and_meta(lazy.position, lazy.meta)\n-    }\n-}\n-\n-impl<T> LazyMeta for PerDefTable<T> where Option<T>: FixedSizeEncoding {\n-    type Meta = <Table<T> as LazyMeta>::Meta;\n-\n-    fn min_size(meta: Self::Meta) -> usize {\n-        Table::<T>::min_size(meta)\n-    }\n-}\n-\n-impl<T> Lazy<PerDefTable<T>> where Option<T>: FixedSizeEncoding {\n-    fn as_table(&self) -> Lazy<Table<T>> {\n-        Lazy::from_position_and_meta(self.position, self.meta)\n-    }\n-\n-    /// Given the metadata, extract out the value at a particular DefIndex (if any).\n-    #[inline(never)]\n-    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n-        &self,\n-        metadata: M,\n-        def_index: DefIndex,\n-    ) -> Option<T> {\n-        self.as_table().get(metadata, def_index.index())\n+        <Option<T>>::maybe_read_from_bytes_at(bytes, i.index())?\n     }\n }"}]}