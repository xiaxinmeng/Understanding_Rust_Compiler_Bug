{"sha": "28d800ce1cb1636c79efba842a158ff76a0d3921", "node_id": "C_kwDOAAsO6NoAKDI4ZDgwMGNlMWNiMTYzNmM3OWVmYmE4NDJhMTU4ZmY3NmEwZDM5MjE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-05-09T16:45:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-09T16:45:35Z"}, "message": "Rollup merge of #95483 - golddranks:improve_float_docs, r=joshtriplett\n\nImprove floating point documentation\n\nThis is my attempt to improve/solve https://github.com/rust-lang/rust/issues/95468 and https://github.com/rust-lang/rust/issues/73328 .\n\nAdded/refined explanations:\n- Refine the \"NaN as a special value\" top level explanation of f32\n- Refine `const NAN` docstring: add an explanation about there being multitude of NaN bitpatterns and disclaimer about the portability/stability guarantees.\n- Refine `fn is_sign_positive` and `fn is_sign_negative` docstrings: add disclaimer about the sign bit of NaNs.\n- Refine `fn min` and `fn max` docstrings: explain the semantics and their relationship to the standard and libm better.\n- Refine `fn trunc` docstrings: explain the semantics slightly more.\n- Refine `fn powi` docstrings: add disclaimer that the rounding behaviour might be different from `powf`.\n- Refine `fn copysign` docstrings: add disclaimer about payloads of NaNs.\n- Refine `minimum` and `maximum`: add disclaimer that \"propagating NaN\" doesn't mean that propagating the NaN bit patterns is guaranteed.\n- Refine `max` and `min` docstrings: add \"ignoring NaN\" to bring the one-row explanation to parity with `minimum` and `maximum`.\n\nCosmetic changes:\n- Reword `NaN` and `NAN` as plain \"NaN\", unless they refer to the specific `const NAN`.\n- Reword \"a number\" to `self` in function docstrings to clarify.\n- Remove \"Returns NAN if the number is NAN\" from `abs`, as this is told to be the default behavior in the top explanation.", "tree": {"sha": "0612e25242cd73b0ac32e9ed7368ef8cf8d00a6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0612e25242cd73b0ac32e9ed7368ef8cf8d00a6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28d800ce1cb1636c79efba842a158ff76a0d3921", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJieUUwCRBK7hj4Ov3rIwAA/gMIAFGvdrgfuPDK++WpM7SOopKW\nlVzxlHPDU3GYWxkHXcBybSZ7lOJBc4UPNfaquoaYRiN5hBdtTDzxmPXJ7VHvL3eK\nafO6dB9c1WpSp2pb26TnAg9pf0WjiqBflX7WZvOI6mYLy/YYtFvGypuG9f2NW78U\nDSrQCgBj4ZVuPg+fEgr3ebAAX7o9S0PtDB5a5t+iS5aA8iROMZmd9j4dGSYyCjcO\nFqvU6zSEFDNhu579Y11oUYBiWZJeDCHbnVZeBgtfWgfJYA3zUL04+e12oqwpLnov\ngjsTEIMqBKMwi4X6mdjYmeNxhHduPapkPk5dNQIFXWVdIiBwFtnhmcE/IPUMf1Q=\n=LynT\n-----END PGP SIGNATURE-----\n", "payload": "tree 0612e25242cd73b0ac32e9ed7368ef8cf8d00a6c\nparent e013f9e0ca4055930f931a30171c355de42f9f92\nparent dea776512b07469092ee98e8c3d4543c6f377729\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1652114735 +0200\ncommitter GitHub <noreply@github.com> 1652114735 +0200\n\nRollup merge of #95483 - golddranks:improve_float_docs, r=joshtriplett\n\nImprove floating point documentation\n\nThis is my attempt to improve/solve https://github.com/rust-lang/rust/issues/95468 and https://github.com/rust-lang/rust/issues/73328 .\n\nAdded/refined explanations:\n- Refine the \"NaN as a special value\" top level explanation of f32\n- Refine `const NAN` docstring: add an explanation about there being multitude of NaN bitpatterns and disclaimer about the portability/stability guarantees.\n- Refine `fn is_sign_positive` and `fn is_sign_negative` docstrings: add disclaimer about the sign bit of NaNs.\n- Refine `fn min` and `fn max` docstrings: explain the semantics and their relationship to the standard and libm better.\n- Refine `fn trunc` docstrings: explain the semantics slightly more.\n- Refine `fn powi` docstrings: add disclaimer that the rounding behaviour might be different from `powf`.\n- Refine `fn copysign` docstrings: add disclaimer about payloads of NaNs.\n- Refine `minimum` and `maximum`: add disclaimer that \"propagating NaN\" doesn't mean that propagating the NaN bit patterns is guaranteed.\n- Refine `max` and `min` docstrings: add \"ignoring NaN\" to bring the one-row explanation to parity with `minimum` and `maximum`.\n\nCosmetic changes:\n- Reword `NaN` and `NAN` as plain \"NaN\", unless they refer to the specific `const NAN`.\n- Reword \"a number\" to `self` in function docstrings to clarify.\n- Remove \"Returns NAN if the number is NAN\" from `abs`, as this is told to be the default behavior in the top explanation.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28d800ce1cb1636c79efba842a158ff76a0d3921", "html_url": "https://github.com/rust-lang/rust/commit/28d800ce1cb1636c79efba842a158ff76a0d3921", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28d800ce1cb1636c79efba842a158ff76a0d3921/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e013f9e0ca4055930f931a30171c355de42f9f92", "url": "https://api.github.com/repos/rust-lang/rust/commits/e013f9e0ca4055930f931a30171c355de42f9f92", "html_url": "https://github.com/rust-lang/rust/commit/e013f9e0ca4055930f931a30171c355de42f9f92"}, {"sha": "dea776512b07469092ee98e8c3d4543c6f377729", "url": "https://api.github.com/repos/rust-lang/rust/commits/dea776512b07469092ee98e8c3d4543c6f377729", "html_url": "https://github.com/rust-lang/rust/commit/dea776512b07469092ee98e8c3d4543c6f377729"}], "stats": {"total": 250, "additions": 182, "deletions": 68}, "files": [{"sha": "6548ad2e514fbacd9d2f25825c8c5726c7c3a0ff", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 60, "deletions": 19, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/28d800ce1cb1636c79efba842a158ff76a0d3921/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d800ce1cb1636c79efba842a158ff76a0d3921/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=28d800ce1cb1636c79efba842a158ff76a0d3921", "patch": "@@ -393,6 +393,15 @@ impl f32 {\n     pub const MAX_10_EXP: i32 = 38;\n \n     /// Not a Number (NaN).\n+    ///\n+    /// Note that IEEE-745 doesn't define just a single NaN value;\n+    /// a plethora of bit patterns are considered to be NaN.\n+    /// Furthermore, the standard makes a difference\n+    /// between a \"signaling\" and a \"quiet\" NaN,\n+    /// and allows inspecting its \"payload\" (the unspecified bits in the bit pattern).\n+    /// This constant isn't guaranteed to equal to any specific NaN bitpattern,\n+    /// and the stability of its representation over Rust versions\n+    /// and target platforms isn't guaranteed.\n     #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n     pub const NAN: f32 = 0.0_f32 / 0.0_f32;\n     /// Infinity (\u221e).\n@@ -402,7 +411,7 @@ impl f32 {\n     #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n     pub const NEG_INFINITY: f32 = -1.0_f32 / 0.0_f32;\n \n-    /// Returns `true` if this value is `NaN`.\n+    /// Returns `true` if this value is NaN.\n     ///\n     /// ```\n     /// let nan = f32::NAN;\n@@ -455,7 +464,7 @@ impl f32 {\n         (self == f32::INFINITY) | (self == f32::NEG_INFINITY)\n     }\n \n-    /// Returns `true` if this number is neither infinite nor `NaN`.\n+    /// Returns `true` if this number is neither infinite nor NaN.\n     ///\n     /// ```\n     /// let f = 7.0f32;\n@@ -506,7 +515,7 @@ impl f32 {\n     }\n \n     /// Returns `true` if the number is neither zero, infinite,\n-    /// [subnormal], or `NaN`.\n+    /// [subnormal], or NaN.\n     ///\n     /// ```\n     /// let min = f32::MIN_POSITIVE; // 1.17549435e-38f32\n@@ -622,8 +631,12 @@ impl f32 {\n         }\n     }\n \n-    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n-    /// positive sign bit and positive infinity.\n+    /// Returns `true` if `self` has a positive sign, including `+0.0`, NaNs with\n+    /// positive sign bit and positive infinity. Note that IEEE-745 doesn't assign any\n+    /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n+    /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n+    /// `is_sign_positive` on a NaN might produce an unexpected result in some cases.\n+    /// See [explanation of NaN as a special value](f32) for more info.\n     ///\n     /// ```\n     /// let f = 7.0_f32;\n@@ -640,8 +653,12 @@ impl f32 {\n         !self.is_sign_negative()\n     }\n \n-    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n-    /// negative sign bit and negative infinity.\n+    /// Returns `true` if `self` has a negative sign, including `-0.0`, NaNs with\n+    /// negative sign bit and negative infinity. Note that IEEE-745 doesn't assign any\n+    /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n+    /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n+    /// `is_sign_negative` on a NaN might produce an unexpected result in some cases.\n+    /// See [explanation of NaN as a special value](f32) for more info.\n     ///\n     /// ```\n     /// let f = 7.0f32;\n@@ -713,47 +730,47 @@ impl f32 {\n         self * (value / 180.0f32)\n     }\n \n-    /// Returns the maximum of the two numbers.\n+    /// Returns the maximum of the two numbers, ignoring NaN.\n     ///\n-    /// Follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs.\n-    /// This matches the behavior of libm\u2019s fmax.\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    /// This follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs;\n+    /// this function handles all NaNs the same way and avoids maxNum's problems with associativity.\n+    /// This also matches the behavior of libm\u2019s fmax.\n     ///\n     /// ```\n     /// let x = 1.0f32;\n     /// let y = 2.0f32;\n     ///\n     /// assert_eq!(x.max(y), y);\n     /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn max(self, other: f32) -> f32 {\n         intrinsics::maxnumf32(self, other)\n     }\n \n-    /// Returns the minimum of the two numbers.\n+    /// Returns the minimum of the two numbers, ignoring NaN.\n     ///\n-    /// Follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs.\n-    /// This matches the behavior of libm\u2019s fmin.\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    /// This follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs;\n+    /// this function handles all NaNs the same way and avoids minNum's problems with associativity.\n+    /// This also matches the behavior of libm\u2019s fmin.\n     ///\n     /// ```\n     /// let x = 1.0f32;\n     /// let y = 2.0f32;\n     ///\n     /// assert_eq!(x.min(y), x);\n     /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn min(self, other: f32) -> f32 {\n         intrinsics::minnumf32(self, other)\n     }\n \n-    /// Returns the maximum of the two numbers, propagating NaNs.\n+    /// Returns the maximum of the two numbers, propagating NaN.\n     ///\n     /// This returns NaN when *either* argument is NaN, as opposed to\n     /// [`f32::max`] which only returns NaN when *both* arguments are NaN.\n@@ -770,6 +787,9 @@ impl f32 {\n     /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater\n     /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n     /// Note that this follows the semantics specified in IEEE 754-2019.\n+    ///\n+    /// Also note that \"propagation\" of NaNs here doesn't necessarily mean that the bitpattern of a NaN\n+    /// operand is conserved; see [explanation of NaN as a special value](f32) for more info.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n     #[inline]\n@@ -785,7 +805,7 @@ impl f32 {\n         }\n     }\n \n-    /// Returns the minimum of the two numbers, propagating NaNs.\n+    /// Returns the minimum of the two numbers, propagating NaN.\n     ///\n     /// This returns NaN when *either* argument is NaN, as opposed to\n     /// [`f32::min`] which only returns NaN when *both* arguments are NaN.\n@@ -802,6 +822,9 @@ impl f32 {\n     /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser\n     /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n     /// Note that this follows the semantics specified in IEEE 754-2019.\n+    ///\n+    /// Also note that \"propagation\" of NaNs here doesn't necessarily mean that the bitpattern of a NaN\n+    /// operand is conserved; see [explanation of NaN as a special value](f32) for more info.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n     #[inline]\n@@ -1009,6 +1032,9 @@ impl f32 {\n     /// Return the memory representation of this floating point number as a byte array in\n     /// big-endian (network) byte order.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1027,6 +1053,9 @@ impl f32 {\n     /// Return the memory representation of this floating point number as a byte array in\n     /// little-endian byte order.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1051,6 +1080,9 @@ impl f32 {\n     /// [`to_be_bytes`]: f32::to_be_bytes\n     /// [`to_le_bytes`]: f32::to_le_bytes\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1075,6 +1107,9 @@ impl f32 {\n \n     /// Create a floating point value from its representation as a byte array in big endian.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1091,6 +1126,9 @@ impl f32 {\n \n     /// Create a floating point value from its representation as a byte array in little endian.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1114,6 +1152,9 @@ impl f32 {\n     /// [`from_be_bytes`]: f32::from_be_bytes\n     /// [`from_le_bytes`]: f32::from_le_bytes\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "75c92c2f8834a215fcbefa75c4d89f50e7fa79a6", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 60, "deletions": 19, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/28d800ce1cb1636c79efba842a158ff76a0d3921/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d800ce1cb1636c79efba842a158ff76a0d3921/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=28d800ce1cb1636c79efba842a158ff76a0d3921", "patch": "@@ -392,6 +392,15 @@ impl f64 {\n     pub const MAX_10_EXP: i32 = 308;\n \n     /// Not a Number (NaN).\n+    ///\n+    /// Note that IEEE-745 doesn't define just a single NaN value;\n+    /// a plethora of bit patterns are considered to be NaN.\n+    /// Furthermore, the standard makes a difference\n+    /// between a \"signaling\" and a \"quiet\" NaN,\n+    /// and allows inspecting its \"payload\" (the unspecified bits in the bit pattern).\n+    /// This constant isn't guaranteed to equal to any specific NaN bitpattern,\n+    /// and the stability of its representation over Rust versions\n+    /// and target platforms isn't guaranteed.\n     #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n     pub const NAN: f64 = 0.0_f64 / 0.0_f64;\n     /// Infinity (\u221e).\n@@ -401,7 +410,7 @@ impl f64 {\n     #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n     pub const NEG_INFINITY: f64 = -1.0_f64 / 0.0_f64;\n \n-    /// Returns `true` if this value is `NaN`.\n+    /// Returns `true` if this value is NaN.\n     ///\n     /// ```\n     /// let nan = f64::NAN;\n@@ -456,7 +465,7 @@ impl f64 {\n         (self == f64::INFINITY) | (self == f64::NEG_INFINITY)\n     }\n \n-    /// Returns `true` if this number is neither infinite nor `NaN`.\n+    /// Returns `true` if this number is neither infinite nor NaN.\n     ///\n     /// ```\n     /// let f = 7.0f64;\n@@ -507,7 +516,7 @@ impl f64 {\n     }\n \n     /// Returns `true` if the number is neither zero, infinite,\n-    /// [subnormal], or `NaN`.\n+    /// [subnormal], or NaN.\n     ///\n     /// ```\n     /// let min = f64::MIN_POSITIVE; // 2.2250738585072014e-308f64\n@@ -614,8 +623,12 @@ impl f64 {\n         }\n     }\n \n-    /// Returns `true` if `self` has a positive sign, including `+0.0`, `NaN`s with\n-    /// positive sign bit and positive infinity.\n+    /// Returns `true` if `self` has a positive sign, including `+0.0`, NaNs with\n+    /// positive sign bit and positive infinity. Note that IEEE-745 doesn't assign any\n+    /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n+    /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n+    /// `is_sign_positive` on a NaN might produce an unexpected result in some cases.\n+    /// See [explanation of NaN as a special value](f32) for more info.\n     ///\n     /// ```\n     /// let f = 7.0_f64;\n@@ -641,8 +654,12 @@ impl f64 {\n         self.is_sign_positive()\n     }\n \n-    /// Returns `true` if `self` has a negative sign, including `-0.0`, `NaN`s with\n-    /// negative sign bit and negative infinity.\n+    /// Returns `true` if `self` has a negative sign, including `-0.0`, NaNs with\n+    /// negative sign bit and negative infinity. Note that IEEE-745 doesn't assign any\n+    /// meaning to the sign bit in case of a NaN, and as Rust doesn't guarantee that\n+    /// the bit pattern of NaNs are conserved over arithmetic operations, the result of\n+    /// `is_sign_negative` on a NaN might produce an unexpected result in some cases.\n+    /// See [explanation of NaN as a special value](f32) for more info.\n     ///\n     /// ```\n     /// let f = 7.0_f64;\n@@ -724,47 +741,47 @@ impl f64 {\n         self * (value / 180.0)\n     }\n \n-    /// Returns the maximum of the two numbers.\n+    /// Returns the maximum of the two numbers, ignoring NaN.\n     ///\n-    /// Follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs.\n-    /// This matches the behavior of libm\u2019s fmax.\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    /// This follows the IEEE-754 2008 semantics for maxNum, except for handling of signaling NaNs;\n+    /// this function handles all NaNs the same way and avoids maxNum's problems with associativity.\n+    /// This also matches the behavior of libm\u2019s fmax.\n     ///\n     /// ```\n     /// let x = 1.0_f64;\n     /// let y = 2.0_f64;\n     ///\n     /// assert_eq!(x.max(y), y);\n     /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn max(self, other: f64) -> f64 {\n         intrinsics::maxnumf64(self, other)\n     }\n \n-    /// Returns the minimum of the two numbers.\n+    /// Returns the minimum of the two numbers, ignoring NaN.\n     ///\n-    /// Follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs.\n-    /// This matches the behavior of libm\u2019s fmin.\n+    /// If one of the arguments is NaN, then the other argument is returned.\n+    /// This follows the IEEE-754 2008 semantics for minNum, except for handling of signaling NaNs;\n+    /// this function handles all NaNs the same way and avoids minNum's problems with associativity.\n+    /// This also matches the behavior of libm\u2019s fmin.\n     ///\n     /// ```\n     /// let x = 1.0_f64;\n     /// let y = 2.0_f64;\n     ///\n     /// assert_eq!(x.min(y), x);\n     /// ```\n-    ///\n-    /// If one of the arguments is NaN, then the other argument is returned.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn min(self, other: f64) -> f64 {\n         intrinsics::minnumf64(self, other)\n     }\n \n-    /// Returns the maximum of the two numbers, propagating NaNs.\n+    /// Returns the maximum of the two numbers, propagating NaN.\n     ///\n     /// This returns NaN when *either* argument is NaN, as opposed to\n     /// [`f64::max`] which only returns NaN when *both* arguments are NaN.\n@@ -781,6 +798,9 @@ impl f64 {\n     /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the greater\n     /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n     /// Note that this follows the semantics specified in IEEE 754-2019.\n+    ///\n+    /// Also note that \"propagation\" of NaNs here doesn't necessarily mean that the bitpattern of a NaN\n+    /// operand is conserved; see [explanation of NaN as a special value](f32) for more info.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n     #[inline]\n@@ -796,7 +816,7 @@ impl f64 {\n         }\n     }\n \n-    /// Returns the minimum of the two numbers, propagating NaNs.\n+    /// Returns the minimum of the two numbers, propagating NaN.\n     ///\n     /// This returns NaN when *either* argument is NaN, as opposed to\n     /// [`f64::min`] which only returns NaN when *both* arguments are NaN.\n@@ -813,6 +833,9 @@ impl f64 {\n     /// If one of the arguments is NaN, then NaN is returned. Otherwise this returns the lesser\n     /// of the two numbers. For this operation, -0.0 is considered to be less than +0.0.\n     /// Note that this follows the semantics specified in IEEE 754-2019.\n+    ///\n+    /// Also note that \"propagation\" of NaNs here doesn't necessarily mean that the bitpattern of a NaN\n+    /// operand is conserved; see [explanation of NaN as a special value](f32) for more info.\n     #[must_use = \"this returns the result of the comparison, without modifying either input\"]\n     #[unstable(feature = \"float_minimum_maximum\", issue = \"91079\")]\n     #[inline]\n@@ -1007,6 +1030,9 @@ impl f64 {\n     /// Return the memory representation of this floating point number as a byte array in\n     /// big-endian (network) byte order.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1025,6 +1051,9 @@ impl f64 {\n     /// Return the memory representation of this floating point number as a byte array in\n     /// little-endian byte order.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1049,6 +1078,9 @@ impl f64 {\n     /// [`to_be_bytes`]: f64::to_be_bytes\n     /// [`to_le_bytes`]: f64::to_le_bytes\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1073,6 +1105,9 @@ impl f64 {\n \n     /// Create a floating point value from its representation as a byte array in big endian.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1089,6 +1124,9 @@ impl f64 {\n \n     /// Create a floating point value from its representation as a byte array in little endian.\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1112,6 +1150,9 @@ impl f64 {\n     /// [`from_be_bytes`]: f64::from_be_bytes\n     /// [`from_le_bytes`]: f64::from_le_bytes\n     ///\n+    /// See [`from_bits`](Self::from_bits) for some discussion of the\n+    /// portability of this operation (there are almost no issues).\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "ac4e668112b94a1248a4141353e033682123eb14", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/28d800ce1cb1636c79efba842a158ff76a0d3921/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d800ce1cb1636c79efba842a158ff76a0d3921/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=28d800ce1cb1636c79efba842a158ff76a0d3921", "patch": "@@ -977,10 +977,22 @@ mod prim_tuple {}\n ///   like `1.0 / 0.0`.\n /// - [NaN (not a number)](#associatedconstant.NAN): this value results from\n ///   calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected\n-///   behavior: it is unequal to any float, including itself! It is also neither\n-///   smaller nor greater than any float, making it impossible to sort. Lastly,\n-///   it is considered infectious as almost all calculations where one of the\n-///   operands is NaN will also result in NaN.\n+///   behavior:\n+///   - It is unequal to any float, including itself! This is the reason `f32`\n+///     doesn't implement the `Eq` trait.\n+///   - It is also neither smaller nor greater than any float, making it\n+///     impossible to sort by the default comparison operation, which is the\n+///     reason `f32` doesn't implement the `Ord` trait.\n+///   - It is also considered *infectious* as almost all calculations where one\n+///     of the operands is NaN will also result in NaN. The explanations on this\n+///     page only explicitly document behavior on NaN operands if this default\n+///     is deviated from.\n+///   - Lastly, there are multiple bit patterns that are considered NaN.\n+///     Rust does not currently guarantee that the bit patterns of NaN are\n+///     preserved over arithmetic operations, and they are not guaranteed to be\n+///     portable or even fully deterministic! This means that there may be some\n+///     surprising results upon inspecting the bit patterns,\n+///     as the same calculations might produce NaNs with different bit patterns.\n ///\n /// For more information on floating point numbers, see [Wikipedia][wikipedia].\n ///"}, {"sha": "933b52b4dccbb2b4d810b0485a7279590f6aa18a", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/28d800ce1cb1636c79efba842a158ff76a0d3921/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d800ce1cb1636c79efba842a158ff76a0d3921/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=28d800ce1cb1636c79efba842a158ff76a0d3921", "patch": "@@ -29,7 +29,7 @@ pub use core::f32::{\n \n #[cfg(not(test))]\n impl f32 {\n-    /// Returns the largest integer less than or equal to a number.\n+    /// Returns the largest integer less than or equal to `self`.\n     ///\n     /// # Examples\n     ///\n@@ -50,7 +50,7 @@ impl f32 {\n         unsafe { intrinsics::floorf32(self) }\n     }\n \n-    /// Returns the smallest integer greater than or equal to a number.\n+    /// Returns the smallest integer greater than or equal to `self`.\n     ///\n     /// # Examples\n     ///\n@@ -69,7 +69,7 @@ impl f32 {\n         unsafe { intrinsics::ceilf32(self) }\n     }\n \n-    /// Returns the nearest integer to a number. Round half-way cases away from\n+    /// Returns the nearest integer to `self`. Round half-way cases away from\n     /// `0.0`.\n     ///\n     /// # Examples\n@@ -89,7 +89,8 @@ impl f32 {\n         unsafe { intrinsics::roundf32(self) }\n     }\n \n-    /// Returns the integer part of a number.\n+    /// Returns the integer part of `self`.\n+    /// This means that non-integer numbers are always truncated towards zero.\n     ///\n     /// # Examples\n     ///\n@@ -110,7 +111,7 @@ impl f32 {\n         unsafe { intrinsics::truncf32(self) }\n     }\n \n-    /// Returns the fractional part of a number.\n+    /// Returns the fractional part of `self`.\n     ///\n     /// # Examples\n     ///\n@@ -131,8 +132,7 @@ impl f32 {\n         self - self.trunc()\n     }\n \n-    /// Computes the absolute value of `self`. Returns `NAN` if the\n-    /// number is `NAN`.\n+    /// Computes the absolute value of `self`.\n     ///\n     /// # Examples\n     ///\n@@ -160,7 +160,7 @@ impl f32 {\n     ///\n     /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n     /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-    /// - `NAN` if the number is `NAN`\n+    /// - NaN if the number is NaN\n     ///\n     /// # Examples\n     ///\n@@ -184,8 +184,10 @@ impl f32 {\n     /// `sign`.\n     ///\n     /// Equal to `self` if the sign of `self` and `sign` are the same, otherwise\n-    /// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of\n-    /// `sign` is returned.\n+    /// equal to `-self`. If `self` is a NaN, then a NaN with the sign bit of\n+    /// `sign` is returned. Note, however, that conserving the sign bit on NaN\n+    /// across arithmetical operations is not generally guaranteed.\n+    /// See [explanation of NaN as a special value](primitive@f32) for more info.\n     ///\n     /// # Examples\n     ///\n@@ -298,7 +300,9 @@ impl f32 {\n \n     /// Raises a number to an integer power.\n     ///\n-    /// Using this function is generally faster than using `powf`\n+    /// Using this function is generally faster than using `powf`.\n+    /// It might have a different sequence of rounding operations than `powf`,\n+    /// so the results are not guaranteed to agree.\n     ///\n     /// # Examples\n     ///"}, {"sha": "a9aa84f70d19e08fcc4341a2a52ffb984afe43d4", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/28d800ce1cb1636c79efba842a158ff76a0d3921/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d800ce1cb1636c79efba842a158ff76a0d3921/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=28d800ce1cb1636c79efba842a158ff76a0d3921", "patch": "@@ -29,7 +29,7 @@ pub use core::f64::{\n \n #[cfg(not(test))]\n impl f64 {\n-    /// Returns the largest integer less than or equal to a number.\n+    /// Returns the largest integer less than or equal to `self`.\n     ///\n     /// # Examples\n     ///\n@@ -50,7 +50,7 @@ impl f64 {\n         unsafe { intrinsics::floorf64(self) }\n     }\n \n-    /// Returns the smallest integer greater than or equal to a number.\n+    /// Returns the smallest integer greater than or equal to `self`.\n     ///\n     /// # Examples\n     ///\n@@ -69,7 +69,7 @@ impl f64 {\n         unsafe { intrinsics::ceilf64(self) }\n     }\n \n-    /// Returns the nearest integer to a number. Round half-way cases away from\n+    /// Returns the nearest integer to `self`. Round half-way cases away from\n     /// `0.0`.\n     ///\n     /// # Examples\n@@ -89,7 +89,8 @@ impl f64 {\n         unsafe { intrinsics::roundf64(self) }\n     }\n \n-    /// Returns the integer part of a number.\n+    /// Returns the integer part of `self`.\n+    /// This means that non-integer numbers are always truncated towards zero.\n     ///\n     /// # Examples\n     ///\n@@ -110,7 +111,7 @@ impl f64 {\n         unsafe { intrinsics::truncf64(self) }\n     }\n \n-    /// Returns the fractional part of a number.\n+    /// Returns the fractional part of `self`.\n     ///\n     /// # Examples\n     ///\n@@ -131,8 +132,7 @@ impl f64 {\n         self - self.trunc()\n     }\n \n-    /// Computes the absolute value of `self`. Returns `NAN` if the\n-    /// number is `NAN`.\n+    /// Computes the absolute value of `self`.\n     ///\n     /// # Examples\n     ///\n@@ -160,7 +160,7 @@ impl f64 {\n     ///\n     /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n     /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n-    /// - `NAN` if the number is `NAN`\n+    /// - NaN if the number is NaN\n     ///\n     /// # Examples\n     ///\n@@ -184,8 +184,10 @@ impl f64 {\n     /// `sign`.\n     ///\n     /// Equal to `self` if the sign of `self` and `sign` are the same, otherwise\n-    /// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of\n-    /// `sign` is returned.\n+    /// equal to `-self`. If `self` is a NaN, then a NaN with the sign bit of\n+    /// `sign` is returned. Note, however, that conserving the sign bit on NaN\n+    /// across arithmetical operations is not generally guaranteed.\n+    /// See [explanation of NaN as a special value](primitive@f32) for more info.\n     ///\n     /// # Examples\n     ///\n@@ -298,7 +300,9 @@ impl f64 {\n \n     /// Raises a number to an integer power.\n     ///\n-    /// Using this function is generally faster than using `powf`\n+    /// Using this function is generally faster than using `powf`.\n+    /// It might have a different sequence of rounding operations than `powf`,\n+    /// so the results are not guaranteed to agree.\n     ///\n     /// # Examples\n     ///"}, {"sha": "ac4e668112b94a1248a4141353e033682123eb14", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/28d800ce1cb1636c79efba842a158ff76a0d3921/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d800ce1cb1636c79efba842a158ff76a0d3921/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=28d800ce1cb1636c79efba842a158ff76a0d3921", "patch": "@@ -977,10 +977,22 @@ mod prim_tuple {}\n ///   like `1.0 / 0.0`.\n /// - [NaN (not a number)](#associatedconstant.NAN): this value results from\n ///   calculations like `(-1.0).sqrt()`. NaN has some potentially unexpected\n-///   behavior: it is unequal to any float, including itself! It is also neither\n-///   smaller nor greater than any float, making it impossible to sort. Lastly,\n-///   it is considered infectious as almost all calculations where one of the\n-///   operands is NaN will also result in NaN.\n+///   behavior:\n+///   - It is unequal to any float, including itself! This is the reason `f32`\n+///     doesn't implement the `Eq` trait.\n+///   - It is also neither smaller nor greater than any float, making it\n+///     impossible to sort by the default comparison operation, which is the\n+///     reason `f32` doesn't implement the `Ord` trait.\n+///   - It is also considered *infectious* as almost all calculations where one\n+///     of the operands is NaN will also result in NaN. The explanations on this\n+///     page only explicitly document behavior on NaN operands if this default\n+///     is deviated from.\n+///   - Lastly, there are multiple bit patterns that are considered NaN.\n+///     Rust does not currently guarantee that the bit patterns of NaN are\n+///     preserved over arithmetic operations, and they are not guaranteed to be\n+///     portable or even fully deterministic! This means that there may be some\n+///     surprising results upon inspecting the bit patterns,\n+///     as the same calculations might produce NaNs with different bit patterns.\n ///\n /// For more information on floating point numbers, see [Wikipedia][wikipedia].\n ///"}]}