{"sha": "8ae82eb4ab8845e3c247c62d27549f16ecef5360", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZTgyZWI0YWI4ODQ1ZTNjMjQ3YzYyZDI3NTQ5ZjE2ZWNlZjUzNjA=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-24T09:11:46Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-24T09:11:46Z"}, "message": "Merge remote-tracking branch 'origin/master' into 1537-drop_copy", "tree": {"sha": "e96c0df2dac173c7d40e2995e8bfde889f8f5a49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e96c0df2dac173c7d40e2995e8bfde889f8f5a49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ae82eb4ab8845e3c247c62d27549f16ecef5360", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAljU4tYACgkQpp+NIls6\n19lG2A//RqAqo+Zv9vI2kkPazf/9xaj30r8jseymEUXn9u3aIA2FimmTWoeMP6JQ\n+gMt6wqJbRSMCy1fZqBLCe/zbASmo2JjWNSm+e54nwGULmijJcPZO4VvTQO0ndxb\nv/94ZnUOFab/CGAy8bmoKAVdOnwTSUlwXKq1/FfO3vypdVu/zgNHCsxgOnHyaZ3e\nWlQV/9/BfHE8Oxm8bVxq4+aw1X6IPKNWjYC+1Ccfatj+a9bPC6ww/P25KpDm4Bt1\nU1djpYbFMnqCK8+qn/lvaLctX+sT1NaMRLhGc0CJBfPwLXlPHwuPmJcUWSuLKEDT\nL27wEa7uO0jLoIvwI1j/0sBD7ykRf05SPJ55091l0D6L2eo/3p2WSyHCqDorw03B\n9v+bM0cd1IS7q/46TgqH3J8rtakO7GZD5Ha6TMrN1YEPZRYLHHIB5ZuB/tvQyMZF\n8w6Mi3AVHM2MrrxlM2ap8zj3U2VxBZtXdua9oYpc8NFK1wEXs19iKNG4FdDrL7tN\n1H4S/DLYiktiRZkJg8XMLdzyDKCHmwoDFwWjHBfm+RinsuBX3J9hJmasCmrQWSrs\nTZPbOHcuBB1bwypx6mQkLKf1ugL/FEQzGU0nVlDMfCInWXhtuJk2+TtxrvrJiuDF\nf/IiUboKODNX1qAFqRX1LeZwOydy7L+cClOLDu7fYWPOytolfGw=\n=i/Tg\n-----END PGP SIGNATURE-----", "payload": "tree e96c0df2dac173c7d40e2995e8bfde889f8f5a49\nparent d53b878af640a2f6c7b55bcb283052c66ec04d4f\nparent 4f473f7f607b44f894f1c3a18f610d023d2bbddf\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1490346706 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1490346706 +0100\n\nMerge remote-tracking branch 'origin/master' into 1537-drop_copy\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ae82eb4ab8845e3c247c62d27549f16ecef5360", "html_url": "https://github.com/rust-lang/rust/commit/8ae82eb4ab8845e3c247c62d27549f16ecef5360", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ae82eb4ab8845e3c247c62d27549f16ecef5360/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d53b878af640a2f6c7b55bcb283052c66ec04d4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d53b878af640a2f6c7b55bcb283052c66ec04d4f", "html_url": "https://github.com/rust-lang/rust/commit/d53b878af640a2f6c7b55bcb283052c66ec04d4f"}, {"sha": "4f473f7f607b44f894f1c3a18f610d023d2bbddf", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f473f7f607b44f894f1c3a18f610d023d2bbddf", "html_url": "https://github.com/rust-lang/rust/commit/4f473f7f607b44f894f1c3a18f610d023d2bbddf"}], "stats": {"total": 1277, "additions": 713, "deletions": 564}, "files": [{"sha": "4ace142aa76c0e2aed3aba69fb274114844203c1", "filename": "CHANGELOG.md", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -1,6 +1,24 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.121 \u2014 2017-03-21\n+* Rustup to *rustc 1.17.0-nightly (134c4a0f0 2017-03-20)*\n+\n+## 0.0.120 \u2014 2017-03-17\n+* Rustup to *rustc 1.17.0-nightly (0aeb9c129 2017-03-15)*\n+\n+## 0.0.119 \u2014 2017-03-13\n+* Rustup to *rustc 1.17.0-nightly (824c9ebbd 2017-03-12)*\n+\n+## 0.0.118 \u2014 2017-03-05\n+* Rustup to *rustc 1.17.0-nightly (b1e31766d 2017-03-03)*\n+\n+## 0.0.117 \u2014 2017-03-01\n+* Rustup to *rustc 1.17.0-nightly (be760566c 2017-02-28)*\n+\n+## 0.0.116 \u2014 2017-02-28\n+* Fix `cargo clippy` on 64 bit windows systems\n+\n ## 0.0.115 \u2014 2017-02-27\n * Rustup to *rustc 1.17.0-nightly (60a0edc6c 2017-02-26)*\n * New lints: [`zero_ptr`], [`never_loop`], [`mut_from_ref`]\n@@ -65,7 +83,7 @@ All notable changes to this project will be documented in this file.\n * New lint: [`get_unwrap`]\n \n ## 0.0.98 \u2014 2016-11-08\n-* Fixes a an issue due to a change in how cargo handles `--sysroot`, which broke `cargo clippy`\n+* Fixes an issue due to a change in how cargo handles `--sysroot`, which broke `cargo clippy`\n \n ## 0.0.97 \u2014 2016-11-03\n * For convenience, `cargo clippy` defines a `cargo-clippy` feature. This was"}, {"sha": "71a54d85249a569363b6eb95db7bfe416d8082f1", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -35,10 +35,9 @@ T-middle issues can be more involved and require verifying types. The\n lot of methods that are useful, though one of the most useful would be `expr_ty` (gives the type of\n an AST expression). `match_def_path()` in Clippy's `utils` module can also be useful.\n \n-Should you add a lint, try it on clippy itself using `util/dogfood.sh`. You may find that clippy\n-contains some questionable code itself! Also before making a pull request, please run\n-`util/update_lints.py`, which will update `lib.rs` and `README.md` with the lint declarations. Our\n-travis build actually checks for this.\n+Compiling clippy can take almost a minute or more depending on your machine.\n+You can set the environment flag `CARGO_INCREMENTAL=1` to cut down that time to\n+almost a third on average, depending on the influence your change has.\n \n Clippy uses UI tests. UI tests check that the output of the compiler is exactly as expected.\n Of course there's little sense in writing the output yourself or copying it around."}, {"sha": "8ca2e988c882faf4fbdd51bc7883ef0a73e1d3e5", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.115\"\n+version = \"0.0.121\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -30,7 +30,7 @@ test = false\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.115\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.0.121\", path = \"clippy_lints\" }\n # end automatic update\n cargo_metadata = \"0.1.1\"\n "}, {"sha": "1cfc1fafea2f848eac0af82c19c961dd59706417", "filename": "README.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -50,7 +50,7 @@ Then build by enabling the feature: `cargo build --features \"clippy\"`\n \n Instead of adding the `cfg_attr` attributes you can also run clippy on demand:\n `cargo rustc --features clippy -- -Z no-trans -Z extra-plugins=clippy`\n-(the `-Z no trans`, while not neccessary, will stop the compilation process after\n+(the `-Z no trans`, while not necessary, will stop the compilation process after\n typechecking (and lints) have completed, which can significantly reduce the runtime).\n \n ### As a cargo subcommand (`cargo clippy`)\n@@ -191,16 +191,16 @@ name\n [assign_ops](https://github.com/Manishearth/rust-clippy/wiki#assign_ops)                                               | allow   | any compound assignment operation\n [bad_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#bad_bit_mask)                                           | warn    | expressions of the form `_ & mask == select` that will only ever return `true` or `false`\n [blacklisted_name](https://github.com/Manishearth/rust-clippy/wiki#blacklisted_name)                                   | warn    | usage of a blacklisted/placeholder name\n-[block_in_if_condition_expr](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr)               | warn    | braces that can be eliminated in conditions, e.g `if { true } ...`\n+[block_in_if_condition_expr](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr)               | warn    | braces that can be eliminated in conditions, e.g. `if { true } ...`\n [block_in_if_condition_stmt](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_stmt)               | warn    | complex blocks in conditions, e.g. `if { let x = true; x } ...`\n [bool_comparison](https://github.com/Manishearth/rust-clippy/wiki#bool_comparison)                                     | warn    | comparing a variable to a boolean, e.g. `if x == true`\n [box_vec](https://github.com/Manishearth/rust-clippy/wiki#box_vec)                                                     | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n [boxed_local](https://github.com/Manishearth/rust-clippy/wiki#boxed_local)                                             | warn    | using `Box<T>` where unnecessary\n [builtin_type_shadow](https://github.com/Manishearth/rust-clippy/wiki#builtin_type_shadow)                             | warn    | shadowing a builtin type\n-[cast_possible_truncation](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_truncation)                   | allow   | casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\n-[cast_possible_wrap](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_wrap)                               | allow   | casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\n-[cast_precision_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_precision_loss)                             | allow   | casts that cause loss of precision, e.g `x as f32` where `x: u64`\n-[cast_sign_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_sign_loss)                                       | allow   | casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\n+[cast_possible_truncation](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_truncation)                   | allow   | casts that may cause truncation of the value, e.g. `x as u8` where `x: u32`, or `x as i32` where `x: f32`\n+[cast_possible_wrap](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_wrap)                               | allow   | casts that may cause wrapping around the value, e.g. `x as i32` where `x: u32` and `x > i32::MAX`\n+[cast_precision_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_precision_loss)                             | allow   | casts that cause loss of precision, e.g. `x as f32` where `x: u64`\n+[cast_sign_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_sign_loss)                                       | allow   | casts from signed types to unsigned types, e.g. `x as u32` where `x: i32`\n [char_lit_as_u8](https://github.com/Manishearth/rust-clippy/wiki#char_lit_as_u8)                                       | warn    | casting a character literal to u8\n [chars_next_cmp](https://github.com/Manishearth/rust-clippy/wiki#chars_next_cmp)                                       | warn    | using `.chars().next()` to check if a string starts with a char\n [clone_double_ref](https://github.com/Manishearth/rust-clippy/wiki#clone_double_ref)                                   | warn    | using `clone` on `&&T`\n@@ -336,7 +336,7 @@ name\n [should_implement_trait](https://github.com/Manishearth/rust-clippy/wiki#should_implement_trait)                       | warn    | defining a method that should be implementing a std trait\n [similar_names](https://github.com/Manishearth/rust-clippy/wiki#similar_names)                                         | allow   | similarly named items and bindings\n [single_char_pattern](https://github.com/Manishearth/rust-clippy/wiki#single_char_pattern)                             | warn    | using a single-character str where a char could be used, e.g. `_.split(\"x\")`\n-[single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                                           | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) instead of `if let`\n+[single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                                           | warn    | a match statement with a single nontrivial arm (i.e. where the other arm is `_ => {}`) instead of `if let`\n [single_match_else](https://github.com/Manishearth/rust-clippy/wiki#single_match_else)                                 | allow   | a match statement with a two arms where the second arm's pattern is a wildcard instead of `if let`\n [string_add](https://github.com/Manishearth/rust-clippy/wiki#string_add)                                               | allow   | using `x + ..` where x is a `String` instead of `push_str()`\n [string_add_assign](https://github.com/Manishearth/rust-clippy/wiki#string_add_assign)                                 | allow   | using `x = x + ..` where x is a `String` instead of `push_str()`\n@@ -354,7 +354,7 @@ name\n [type_complexity](https://github.com/Manishearth/rust-clippy/wiki#type_complexity)                                     | warn    | usage of very complex types that might be better factored into `type` definitions\n [unicode_not_nfc](https://github.com/Manishearth/rust-clippy/wiki#unicode_not_nfc)                                     | allow   | using a unicode literal not in NFC normal form (see [unicode tr15](http://www.unicode.org/reports/tr15/) for further information)\n [unit_cmp](https://github.com/Manishearth/rust-clippy/wiki#unit_cmp)                                                   | warn    | comparing unit values\n-[unnecessary_cast](https://github.com/Manishearth/rust-clippy/wiki#unnecessary_cast)                                   | warn    | cast to the same type, e.g `x as i32` where `x: i32`\n+[unnecessary_cast](https://github.com/Manishearth/rust-clippy/wiki#unnecessary_cast)                                   | warn    | cast to the same type, e.g. `x as i32` where `x: i32`\n [unnecessary_mut_passed](https://github.com/Manishearth/rust-clippy/wiki#unnecessary_mut_passed)                       | warn    | an argument passed as a mutable reference although the callee only demands an immutable reference\n [unnecessary_operation](https://github.com/Manishearth/rust-clippy/wiki#unnecessary_operation)                         | warn    | outer expressions with no effect\n [unneeded_field_pattern](https://github.com/Manishearth/rust-clippy/wiki#unneeded_field_pattern)                       | warn    | struct fields bound to a wildcard instead of using `..`"}, {"sha": "c17b12a33b3814775f9e103ffd628e2629d5b911", "filename": "appveyor.yml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -4,16 +4,15 @@ environment:\n     matrix:\n         - TARGET: i686-pc-windows-gnu\n           MSYS2_BITS: 32\n-          RUN_CARGO_CLIPPY: true\n         - TARGET: i686-pc-windows-msvc\n           MSYS2_BITS: 32\n-          RUN_CARGO_CLIPPY: true\n         - TARGET: x86_64-pc-windows-gnu\n           MSYS2_BITS: 64\n         - TARGET: x86_64-pc-windows-msvc\n           MSYS2_BITS: 64\n \n install:\n+    - set PATH=C:\\Program Files\\Git\\mingw64\\bin;%PATH%\n     - curl -sSf -o rustup-init.exe https://win.rustup.rs/\n     - rustup-init.exe -y --default-host %TARGET% --default-toolchain nightly\n     - set PATH=%PATH%;C:\\Users\\appveyor\\.cargo\\bin;C:\\Users\\appveyor\\.rustup\\toolchains\\nightly-%TARGET%\\bin\n@@ -29,7 +28,7 @@ test_script:\n     - cargo test --features debugging\n     - copy target\\debug\\cargo-clippy.exe C:\\Users\\appveyor\\.cargo\\bin\\\n     - cargo clippy -- -D clippy\n-    - if defined RUN_CARGO_CLIPPY cd clippy_lints && cargo clippy -- -D clippy && cd ..\n+    - cd clippy_lints && cargo clippy -- -D clippy && cd ..\n \n notifications:\n     - provider: Email"}, {"sha": "8a710bf6291c63debcb747af0ff137fe1a669026", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.115\"\n+version = \"0.0.121\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\","}, {"sha": "dd5baaadca6ce613f147cc6834505c89c6e4c670", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -1,9 +1,8 @@\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::ConstContext;\n-use rustc_const_math::ConstInt;\n+use rustc_const_math::{ConstUsize, ConstIsize, ConstInt};\n use rustc::hir;\n use syntax::ast::RangeLimits;\n use utils::{self, higher};\n@@ -61,11 +60,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n             // Array with known size can be checked statically\n             let ty = cx.tables.expr_ty(array);\n             if let ty::TyArray(_, size) = ty.sty {\n-                let size = ConstInt::Infer(size as u128);\n+                let size = ConstInt::Usize(ConstUsize::new(size as u64, cx.sess().target.uint_type)\n+                    .expect(\"array size is invalid\"));\n                 let constcx = ConstContext::with_tables(cx.tcx, cx.tables);\n \n                 // Index is a constant uint\n-                let const_index = constcx.eval(index, ExprTypeChecked);\n+                let const_index = constcx.eval(index);\n                 if let Ok(ConstVal::Integral(const_index)) = const_index {\n                     if size <= const_index {\n                         utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"const index is out of bounds\");\n@@ -77,10 +77,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n                 // Index is a constant range\n                 if let Some(range) = higher::range(index) {\n                     let start = range.start\n-                        .map(|start| constcx.eval(start, ExprTypeChecked))\n+                        .map(|start| constcx.eval(start))\n                         .map(|v| v.ok());\n                     let end = range.end\n-                        .map(|end| constcx.eval(end, ExprTypeChecked))\n+                        .map(|end| constcx.eval(end))\n                         .map(|v| v.ok());\n \n                     if let Some((start, end)) = to_const_range(&start, &end, range.limits, size) {\n@@ -117,13 +117,31 @@ fn to_const_range(\n     let start = match *start {\n         Some(Some(ConstVal::Integral(x))) => x,\n         Some(_) => return None,\n-        None => ConstInt::Infer(0),\n+        None => ConstInt::U8(0),\n     };\n \n     let end = match *end {\n         Some(Some(ConstVal::Integral(x))) => {\n             if limits == RangeLimits::Closed {\n-                (x + ConstInt::Infer(1)).expect(\"such a big array is not realistic\")\n+                match x {\n+                        ConstInt::U8(_) => (x + ConstInt::U8(1)),\n+                        ConstInt::U16(_) => (x + ConstInt::U16(1)),\n+                        ConstInt::U32(_) => (x + ConstInt::U32(1)),\n+                        ConstInt::U64(_) => (x + ConstInt::U64(1)),\n+                        ConstInt::U128(_) => (x + ConstInt::U128(1)),\n+                        ConstInt::Usize(ConstUsize::Us16(_)) => (x + ConstInt::Usize(ConstUsize::Us16(1))),\n+                        ConstInt::Usize(ConstUsize::Us32(_)) => (x + ConstInt::Usize(ConstUsize::Us32(1))),\n+                        ConstInt::Usize(ConstUsize::Us64(_)) => (x + ConstInt::Usize(ConstUsize::Us64(1))),\n+                        ConstInt::I8(_) => (x + ConstInt::I8(1)),\n+                        ConstInt::I16(_) => (x + ConstInt::I16(1)),\n+                        ConstInt::I32(_) => (x + ConstInt::I32(1)),\n+                        ConstInt::I64(_) => (x + ConstInt::I64(1)),\n+                        ConstInt::I128(_) => (x + ConstInt::I128(1)),\n+                        ConstInt::Isize(ConstIsize::Is16(_)) => (x + ConstInt::Isize(ConstIsize::Is16(1))),\n+                        ConstInt::Isize(ConstIsize::Is32(_)) => (x + ConstInt::Isize(ConstIsize::Is32(1))),\n+                        ConstInt::Isize(ConstIsize::Is64(_)) => (x + ConstInt::Isize(ConstIsize::Is64(1))),\n+                    }\n+                    .expect(\"such a big array is not realistic\")\n             } else {\n                 x\n             }"}, {"sha": "8945e4f6c26f855d5cb173790fb998b58a09d996", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -86,8 +86,8 @@ impl LintPass for AttrPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n     fn check_attribute(&mut self, cx: &LateContext<'a, 'tcx>, attr: &'tcx Attribute) {\n-        if let MetaItemKind::List(ref items) = attr.value.node {\n-            if items.is_empty() || attr.name() != \"deprecated\" {\n+        if let Some(ref items) = attr.meta_item_list() {\n+            if items.is_empty() || attr.name().map_or(true, |n| n != \"deprecated\") {\n                 return;\n             }\n             for item in items {\n@@ -110,31 +110,33 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n             ItemExternCrate(_) |\n             ItemUse(_, _) => {\n                 for attr in &item.attrs {\n-                    if let MetaItemKind::List(ref lint_list) = attr.value.node {\n-                        match &*attr.name().as_str() {\n-                            \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                                // whitelist `unused_imports` and `deprecated`\n-                                for lint in lint_list {\n-                                    if is_word(lint, \"unused_imports\") || is_word(lint, \"deprecated\") {\n-                                        if let ItemUse(_, _) = item.node {\n-                                            return;\n+                    if let Some(ref lint_list) = attr.meta_item_list() {\n+                        if let Some(name) = attr.name() {\n+                            match &*name.as_str() {\n+                                \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n+                                    // whitelist `unused_imports` and `deprecated`\n+                                    for lint in lint_list {\n+                                        if is_word(lint, \"unused_imports\") || is_word(lint, \"deprecated\") {\n+                                            if let ItemUse(_, _) = item.node {\n+                                                return;\n+                                            }\n                                         }\n                                     }\n-                                }\n-                                if let Some(mut sugg) = snippet_opt(cx, attr.span) {\n-                                    if sugg.len() > 1 {\n-                                        span_lint_and_then(cx,\n-                                                           USELESS_ATTRIBUTE,\n-                                                           attr.span,\n-                                                           \"useless lint attribute\",\n-                                                           |db| {\n-                                            sugg.insert(1, '!');\n-                                            db.span_suggestion(attr.span, \"if you just forgot a `!`, use\", sugg);\n-                                        });\n+                                    if let Some(mut sugg) = snippet_opt(cx, attr.span) {\n+                                        if sugg.len() > 1 {\n+                                            span_lint_and_then(cx,\n+                                                               USELESS_ATTRIBUTE,\n+                                                               attr.span,\n+                                                               \"useless lint attribute\",\n+                                                               |db| {\n+                                                sugg.insert(1, '!');\n+                                                db.span_suggestion(attr.span, \"if you just forgot a `!`, use\", sugg);\n+                                            });\n+                                        }\n                                     }\n-                                }\n-                            },\n-                            _ => {},\n+                                },\n+                                _ => {},\n+                            }\n                         }\n                     }\n                 }\n@@ -218,8 +220,8 @@ fn check_attrs(cx: &LateContext, span: Span, name: &Name, attrs: &[Attribute]) {\n     }\n \n     for attr in attrs {\n-        if let MetaItemKind::List(ref values) = attr.value.node {\n-            if values.len() != 1 || attr.name() != \"inline\" {\n+        if let Some(ref values) = attr.meta_item_list() {\n+            if values.len() != 1 || attr.name().map_or(true, |n| n != \"inline\") {\n                 continue;\n             }\n             if is_word(&values[0], \"always\") {"}, {"sha": "789de240d732943b168a5dfab6b9013b22078d23", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -237,6 +237,7 @@ fn check_ineffective_gt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str\n }\n \n fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u128> {\n+    use rustc::ty::subst::Substs;\n     match lit.node {\n         ExprLit(ref lit_ptr) => {\n             if let LitKind::Int(value, _) = lit_ptr.node {\n@@ -248,7 +249,7 @@ fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u128> {\n         ExprPath(ref qpath) => {\n             let def = cx.tables.qpath_def(qpath, lit.id);\n             if let Def::Const(def_id) = def {\n-                lookup_const_by_id(cx.tcx, def_id, None).and_then(|(l, _tab, _ty)| fetch_int_literal(cx, l))\n+                lookup_const_by_id(cx.tcx, def_id, Substs::empty()).and_then(|(l, _ty)| fetch_int_literal(cx, l))\n             } else {\n                 None\n             }"}, {"sha": "f41d29c569d77f88a4b632175a8cf58f4629fc72", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -18,7 +18,7 @@ use utils::*;\n declare_lint! {\n     pub BLOCK_IN_IF_CONDITION_EXPR,\n     Warn,\n-    \"braces that can be eliminated in conditions, e.g `if { true } ...`\"\n+    \"braces that can be eliminated in conditions, e.g. `if { true } ...`\"\n }\n \n /// **What it does:** Checks for `if` conditions that use blocks containing"}, {"sha": "7be6f6bf0d6e365ce3eb4c486c634b5e1541752a", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 59, "deletions": 80, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -3,14 +3,15 @@\n use rustc::lint::LateContext;\n use rustc::hir::def::Def;\n use rustc_const_eval::lookup_const_by_id;\n-use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n+use rustc_const_math::ConstInt;\n use rustc::hir::*;\n+use rustc::ty::{self, TyCtxt};\n use std::cmp::Ordering::{self, Equal};\n use std::cmp::PartialOrd;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::rc::Rc;\n-use syntax::ast::{FloatTy, LitIntType, LitKind, StrStyle, UintTy, IntTy, NodeId};\n+use syntax::ast::{FloatTy, LitKind, StrStyle, NodeId};\n use syntax::ptr::P;\n \n #[derive(Debug, Copy, Clone)]\n@@ -52,21 +53,6 @@ pub enum Constant {\n     Tuple(Vec<Constant>),\n }\n \n-impl Constant {\n-    /// Convert to `u64` if possible.\n-    ///\n-    /// # panics\n-    ///\n-    /// If the constant could not be converted to `u64` losslessly.\n-    fn as_u64(&self) -> u64 {\n-        if let Constant::Int(val) = *self {\n-            val.to_u64().expect(\"negative constant can't be casted to `u64`\")\n-        } else {\n-            panic!(\"Could not convert a `{:?}` to `u64`\", self);\n-        }\n-    }\n-}\n-\n impl PartialEq for Constant {\n     fn eq(&self, other: &Constant) -> bool {\n         match (self, other) {\n@@ -174,28 +160,33 @@ impl PartialOrd for Constant {\n \n /// parse a `LitKind` to a `Constant`\n #[allow(cast_possible_wrap)]\n-pub fn lit_to_constant(lit: &LitKind) -> Constant {\n+pub fn lit_to_constant<'a, 'tcx>(lit: &LitKind, tcx: TyCtxt<'a, 'tcx, 'tcx>, mut ty: ty::Ty<'tcx>) -> Constant {\n+    use syntax::ast::*;\n+    use syntax::ast::LitIntType::*;\n+    use rustc::ty::util::IntTypeExt;\n+\n+    if let ty::TyAdt(adt, _) = ty.sty {\n+        if adt.is_enum() {\n+            ty = adt.repr.discr_type().to_ty(tcx)\n+        }\n+    }\n     match *lit {\n         LitKind::Str(ref is, style) => Constant::Str(is.to_string(), style),\n         LitKind::Byte(b) => Constant::Int(ConstInt::U8(b)),\n         LitKind::ByteStr(ref s) => Constant::Binary(s.clone()),\n         LitKind::Char(c) => Constant::Char(c),\n-        LitKind::Int(value, LitIntType::Unsuffixed) => Constant::Int(ConstInt::Infer(value)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U8)) => Constant::Int(ConstInt::U8(value as u8)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U16)) => Constant::Int(ConstInt::U16(value as u16)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U32)) => Constant::Int(ConstInt::U32(value as u32)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U64)) => Constant::Int(ConstInt::U64(value as u64)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::U128)) => Constant::Int(ConstInt::U128(value as u128)),\n-        LitKind::Int(value, LitIntType::Unsigned(UintTy::Us)) => {\n-            Constant::Int(ConstInt::Usize(ConstUsize::Us32(value as u32)))\n-        },\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I8)) => Constant::Int(ConstInt::I8(value as i8)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I16)) => Constant::Int(ConstInt::I16(value as i16)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I32)) => Constant::Int(ConstInt::I32(value as i32)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I64)) => Constant::Int(ConstInt::I64(value as i64)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::I128)) => Constant::Int(ConstInt::I128(value as i128)),\n-        LitKind::Int(value, LitIntType::Signed(IntTy::Is)) => {\n-            Constant::Int(ConstInt::Isize(ConstIsize::Is32(value as i32)))\n+        LitKind::Int(n, hint) => {\n+            match (&ty.sty, hint) {\n+                (&ty::TyInt(ity), _) |\n+                (_, Signed(ity)) => {\n+                    Constant::Int(ConstInt::new_signed_truncating(n as i128, ity, tcx.sess.target.int_type))\n+                },\n+                (&ty::TyUint(uty), _) |\n+                (_, Unsigned(uty)) => {\n+                    Constant::Int(ConstInt::new_unsigned_truncating(n as u128, uty, tcx.sess.target.uint_type))\n+                },\n+                _ => bug!(),\n+            }\n         },\n         LitKind::Float(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n         LitKind::FloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FloatWidth::Any),\n@@ -231,22 +222,20 @@ fn neg_float_str(s: &str) -> String {\n \n pub fn constant(lcx: &LateContext, e: &Expr) -> Option<(Constant, bool)> {\n     let mut cx = ConstEvalLateContext {\n-        lcx: Some(lcx),\n+        tcx: lcx.tcx,\n+        tables: lcx.tables,\n         needed_resolution: false,\n     };\n     cx.expr(e).map(|cst| (cst, cx.needed_resolution))\n }\n \n-pub fn constant_simple(e: &Expr) -> Option<Constant> {\n-    let mut cx = ConstEvalLateContext {\n-        lcx: None,\n-        needed_resolution: false,\n-    };\n-    cx.expr(e)\n+pub fn constant_simple(lcx: &LateContext, e: &Expr) -> Option<Constant> {\n+    constant(lcx, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n }\n \n-struct ConstEvalLateContext<'c, 'cc: 'c> {\n-    lcx: Option<&'c LateContext<'c, 'cc>>,\n+struct ConstEvalLateContext<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    tables: &'a ty::TypeckTables<'tcx>,\n     needed_resolution: bool,\n }\n \n@@ -257,17 +246,15 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             ExprPath(ref qpath) => self.fetch_path(qpath, e.id),\n             ExprBlock(ref block) => self.block(block),\n             ExprIf(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n-            ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n+            ExprLit(ref lit) => Some(lit_to_constant(&lit.node, self.tcx, self.tables.expr_ty(e))),\n             ExprArray(ref vec) => self.multi(vec).map(Constant::Vec),\n             ExprTup(ref tup) => self.multi(tup).map(Constant::Tuple),\n-            ExprRepeat(ref value, number_id) => {\n-                if let Some(lcx) = self.lcx {\n-                    self.binop_apply(value,\n-                                     &lcx.tcx.hir.body(number_id).value,\n-                                     |v, n| Some(Constant::Repeat(Box::new(v), n.as_u64() as usize)))\n-                } else {\n-                    None\n-                }\n+            ExprRepeat(ref value, _) => {\n+                let n = match self.tables.expr_ty(e).sty {\n+                    ty::TyArray(_, n) => n,\n+                    _ => span_bug!(e.span, \"typeck error\"),\n+                };\n+                self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n             },\n             ExprUnary(op, ref operand) => {\n                 self.expr(operand).and_then(|o| match op {\n@@ -292,24 +279,27 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n \n     /// lookup a possibly constant expression from a ExprPath\n     fn fetch_path(&mut self, qpath: &QPath, id: NodeId) -> Option<Constant> {\n-        if let Some(lcx) = self.lcx {\n-            let def = lcx.tables.qpath_def(qpath, id);\n-            match def {\n-                Def::Const(def_id) |\n-                Def::AssociatedConst(def_id) => {\n-                    let substs = Some(lcx.tables\n-                        .node_id_item_substs(id)\n-                        .unwrap_or_else(|| lcx.tcx.intern_substs(&[])));\n-                    if let Some((const_expr, _tab, _ty)) = lookup_const_by_id(lcx.tcx, def_id, substs) {\n-                        let ret = self.expr(const_expr);\n-                        if ret.is_some() {\n-                            self.needed_resolution = true;\n-                        }\n-                        return ret;\n+        let def = self.tables.qpath_def(qpath, id);\n+        match def {\n+            Def::Const(def_id) |\n+            Def::AssociatedConst(def_id) => {\n+                let substs = self.tables\n+                    .node_id_item_substs(id)\n+                    .unwrap_or_else(|| self.tcx.intern_substs(&[]));\n+                if let Some((const_expr, tables)) = lookup_const_by_id(self.tcx, def_id, substs) {\n+                    let mut cx = ConstEvalLateContext {\n+                        tcx: self.tcx,\n+                        tables: tables,\n+                        needed_resolution: false,\n+                    };\n+                    let ret = cx.expr(const_expr);\n+                    if ret.is_some() {\n+                        self.needed_resolution = true;\n                     }\n-                },\n-                _ => {},\n-            }\n+                    return ret;\n+                }\n+            },\n+            _ => {},\n         }\n         None\n     }\n@@ -369,15 +359,4 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             _ => None,\n         }\n     }\n-\n-\n-    fn binop_apply<F>(&mut self, left: &Expr, right: &Expr, op: F) -> Option<Constant>\n-        where F: Fn(Constant, Constant) -> Option<Constant>\n-    {\n-        if let (Some(lc), Some(rc)) = (self.expr(left), self.expr(right)) {\n-            op(lc, rc)\n-        } else {\n-            None\n-        }\n-    }\n }"}, {"sha": "03882a0acf5bdf7b67c8d475e7f003354e2ad8d6", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -41,12 +41,13 @@ impl LintPass for CyclomaticComplexity {\n }\n \n impl CyclomaticComplexity {\n-    fn check<'a, 'tcx: 'a>(&mut self, cx: &'a LateContext<'a, 'tcx>, expr: &'tcx Expr, span: Span) {\n+    fn check<'a, 'tcx: 'a>(&mut self, cx: &'a LateContext<'a, 'tcx>, body: &'tcx Body, span: Span) {\n         if in_macro(cx, span) {\n             return;\n         }\n \n-        let cfg = CFG::new(cx.tcx, expr);\n+        let cfg = CFG::new(cx.tcx, body);\n+        let expr = &body.value;\n         let n = cfg.graph.len_nodes() as u64;\n         let e = cfg.graph.len_edges() as u64;\n         if e + 2 < n {\n@@ -101,7 +102,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CyclomaticComplexity {\n     ) {\n         let def_id = cx.tcx.hir.local_def_id(node_id);\n         if !cx.tcx.has_attr(def_id, \"test\") {\n-            self.check(cx, &body.value, span);\n+            self.check(cx, body, span);\n         }\n     }\n \n@@ -136,7 +137,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n                 let ty = self.cx.tables.node_id_to_type(callee.id);\n                 match ty.sty {\n                     ty::TyFnDef(_, _, ty) |\n-                    ty::TyFnPtr(ty) if ty.sig.skip_binder().output().sty == ty::TyNever => {\n+                    ty::TyFnPtr(ty) if ty.skip_binder().output().sty == ty::TyNever => {\n                         self.divergence += 1;\n                     },\n                     _ => (),"}, {"sha": "c6f7512f087c359bea6a74d42625721e46b57a2e", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -89,11 +89,9 @@ pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [a\n \n     for attr in attrs {\n         if attr.is_sugared_doc {\n-            if let ast::MetaItemKind::NameValue(ref doc) = attr.value.node {\n-                if let ast::LitKind::Str(ref doc, _) = doc.node {\n-                    let doc = (*doc.as_str()).to_owned();\n-                    docs.extend_from_slice(&strip_doc_comment_decoration((doc, attr.span)));\n-                }\n+            if let Some(ref doc) = attr.value_str() {\n+                let doc = (*doc.as_str()).to_owned();\n+                docs.extend_from_slice(&strip_doc_comment_decoration((doc, attr.span)));\n             }\n         }\n     }"}, {"sha": "4032234ac5cb71607b5b273fed73eb66ccb7ab26", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                 if let Some(body_id) = variant.disr_expr {\n                     use rustc_const_eval::*;\n                     let constcx = ConstContext::new(cx.tcx, body_id);\n-                    let bad = match constcx.eval(&cx.tcx.hir.body(body_id).value, EvalHint::ExprTypeChecked) {\n+                    let bad = match constcx.eval(&cx.tcx.hir.body(body_id).value) {\n                         Ok(ConstVal::Integral(Usize(Us64(i)))) => i as u32 as u64 != i,\n                         Ok(ConstVal::Integral(Isize(Is64(i)))) => i as i32 as i64 != i,\n                         _ => false,"}, {"sha": "d2b07661d5b5b2f82e39b08405c8c88a9ddcf3ee", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -66,7 +66,8 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                 // Is it an unsafe function? They don't implement the closure traits\n                 ty::TyFnDef(_, _, fn_ty) |\n                 ty::TyFnPtr(fn_ty) => {\n-                    if fn_ty.unsafety == Unsafety::Unsafe || fn_ty.sig.skip_binder().output().sty == ty::TyNever {\n+                    if fn_ty.skip_binder().unsafety == Unsafety::Unsafe ||\n+                       fn_ty.skip_binder().output().sty == ty::TyNever {\n                         return;\n                     }\n                 },"}, {"sha": "f07ec7de52b2b7fff971813dc0ace5c1799bdfdf", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n                 match self.cx.tables.expr_ty(func).sty {\n                     ty::TyFnDef(_, _, fn_ty) |\n                     ty::TyFnPtr(fn_ty) => {\n-                        if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&fn_ty.sig).output().sty {\n+                        if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&fn_ty).output().sty {\n                             self.report_diverging_sub_expr(e);\n                         }\n                     },"}, {"sha": "82db13b1025bbfe858fe648d9d52fc51bccbdec1", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -3,7 +3,7 @@ use rustc::lint::*;\n use rustc::hir::*;\n use syntax::codemap::Span;\n use utils::{span_lint, snippet, in_macro};\n-use rustc_const_math::ConstInt;\n+use syntax::attr::IntType::{SignedInt, UnsignedInt};\n \n /// **What it does:** Checks for identity operations, e.g. `x + 0`.\n ///\n@@ -60,11 +60,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n \n \n fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n-    if let Some(v @ Constant::Int(_)) = constant_simple(e) {\n+    if let Some(Constant::Int(v)) = constant_simple(cx, e) {\n         if match m {\n-            0 => v == Constant::Int(ConstInt::Infer(0)),\n-            -1 => v == Constant::Int(ConstInt::InferSigned(-1)),\n-            1 => v == Constant::Int(ConstInt::Infer(1)),\n+            0 => v.to_u128_unchecked() == 0,\n+            -1 => match v.int_type() {\n+                SignedInt(_) => #[allow(cast_possible_wrap)] (v.to_u128_unchecked() as i128  == -1),\n+                UnsignedInt(_) =>  false\n+            },\n+            1 => v.to_u128_unchecked() == 1,\n             _ => unreachable!(),\n         } {\n             span_lint(cx,"}, {"sha": "5789f6a5f80bdc6c3291fa5aa9e041dbc7e8795f", "filename": "clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -58,6 +58,10 @@ impl EarlyLintPass for ItemsAfterStatements {\n                 if in_macro(cx, it.span) {\n                     return;\n                 }\n+                if let ItemKind::MacroDef(..) = it.node {\n+                    // do not lint `macro_rules`, but continue processing further statements\n+                    continue;\n+                }\n                 span_lint(cx,\n                           ITEMS_AFTER_STATEMENTS,\n                           it.span,"}, {"sha": "bfd17d995c8dd8f2080b1531194da68e137b413b", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -2,10 +2,8 @@\n \n use rustc::lint::*;\n use rustc::hir::*;\n-use utils::{span_lint_and_then, snippet_opt};\n-use rustc::ty::layout::TargetDataLayout;\n+use utils::{span_lint_and_then, snippet_opt, type_size};\n use rustc::ty::TypeFoldable;\n-use rustc::traits::Reveal;\n \n /// **What it does:** Checks for large size differences between variants on `enum`s.\n ///\n@@ -55,28 +53,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n             let mut largest_variant: Option<(_, _)> = None;\n \n             for (i, variant) in adt.variants.iter().enumerate() {\n-                let data_layout = TargetDataLayout::parse(cx.sess());\n-                cx.tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-                    let size: u64 = variant.fields\n-                        .iter()\n-                        .map(|f| {\n-                            let ty = cx.tcx.item_type(f.did);\n-                            if ty.needs_subst() {\n-                                0 // we can't reason about generics, so we treat them as zero sized\n-                            } else {\n-                                ty.layout(&infcx)\n-                                    .expect(\"layout should be computable for concrete type\")\n-                                    .size(&data_layout)\n-                                    .bytes()\n-                            }\n-                        })\n-                        .sum();\n+                let size: u64 = variant.fields\n+                    .iter()\n+                    .map(|f| {\n+                        let ty = cx.tcx.item_type(f.did);\n+                        if ty.needs_subst() {\n+                            0 // we can't reason about generics, so we treat them as zero sized\n+                        } else {\n+                            type_size(cx, ty).expect(\"size should be computable for concrete type\")\n+                        }\n+                    })\n+                    .sum();\n \n-                    let grouped = (size, (i, variant));\n+                let grouped = (size, (i, variant));\n \n-                    update_if(&mut smallest_variant, grouped, |a, b| b.0 <= a.0);\n-                    update_if(&mut largest_variant, grouped, |a, b| b.0 >= a.0);\n-                });\n+                update_if(&mut smallest_variant, grouped, |a, b| b.0 <= a.0);\n+                update_if(&mut largest_variant, grouped, |a, b| b.0 >= a.0);\n             }\n \n             if let (Some(smallest), Some(largest)) = (smallest_variant, largest_variant) {"}, {"sha": "03522cc02cd53b12260324e31b77df520291c181", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -186,7 +186,8 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     fn is_is_empty(cx: &LateContext, item: &ty::AssociatedItem) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n             if &*item.name.as_str() == \"is_empty\" {\n-                let ty = cx.tcx.item_type(item.def_id).fn_sig().skip_binder();\n+                let sig = cx.tcx.item_type(item.def_id).fn_sig();\n+                let ty = sig.skip_binder();\n                 ty.inputs().len() == 1\n             } else {\n                 false\n@@ -198,7 +199,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n \n     /// Check the inherent impl's items for an `is_empty(self)` method.\n     fn has_is_empty_impl(cx: &LateContext, id: DefId) -> bool {\n-        cx.tcx.inherent_impls.borrow().get(&id).map_or(false, |impls| {\n+        cx.tcx.maps.inherent_impls.borrow().get(&id).map_or(false, |impls| {\n             impls.iter().any(|imp| cx.tcx.associated_items(*imp).any(|item| is_is_empty(cx, &item)))\n         })\n     }"}, {"sha": "068bc5d2e17411703f2fc4c954846a1f459299d6", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -9,7 +9,6 @@\n #![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n #![feature(conservative_impl_trait)]\n-#![feature(collections_bound)]\n \n #![allow(indexing_slicing, shadow_reuse, unknown_lints, missing_docs_in_private_items)]\n #![allow(needless_lifetimes)]\n@@ -447,14 +446,14 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         misc::REDUNDANT_PATTERN,\n         misc::SHORT_CIRCUIT_STATEMENT,\n         misc::TOPLEVEL_REF_ARG,\n+        misc::ZERO_PTR,\n         misc_early::BUILTIN_TYPE_SHADOW,\n         misc_early::DOUBLE_NEG,\n         misc_early::DUPLICATE_UNDERSCORE_ARGUMENT,\n         misc_early::MIXED_CASE_HEX_LITERALS,\n         misc_early::REDUNDANT_CLOSURE_CALL,\n         misc_early::UNNEEDED_FIELD_PATTERN,\n         misc_early::ZERO_PREFIXED_LITERAL,\n-        misc_early::ZERO_PTR,\n         mut_reference::UNNECESSARY_MUT_PASSED,\n         mutex_atomic::MUTEX_ATOMIC,\n         needless_bool::BOOL_COMPARISON,"}, {"sha": "1571372cefbd9dccd076cdebb936f21c7ac08e4a", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -257,7 +257,7 @@ impl<'v, 't> RefVisitor<'v, 't> {\n                         }\n                     },\n                     Def::Trait(def_id) => {\n-                        let trait_def = self.cx.tcx.trait_defs.borrow()[&def_id];\n+                        let trait_def = self.cx.tcx.maps.trait_def.borrow()[&def_id];\n                         for _ in &self.cx.tcx.item_generics(trait_def.def_id).regions {\n                             self.record(&None);\n                         }"}, {"sha": "8c1f47a2187d4accfe2246a478ba9441216abefd", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -8,7 +8,6 @@ use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::region::CodeExtent;\n use rustc::ty;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::ConstContext;\n use std::collections::HashMap;\n use syntax::ast;\n@@ -596,8 +595,8 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n     if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(arg) {\n         // ...and both sides are compile-time constant integers...\n         let constcx = ConstContext::with_tables(cx.tcx, cx.tables);\n-        if let Ok(start_idx) = constcx.eval(start, ExprTypeChecked) {\n-            if let Ok(end_idx) = constcx.eval(end, ExprTypeChecked) {\n+        if let Ok(start_idx) = constcx.eval(start) {\n+            if let Ok(end_idx) = constcx.eval(end) {\n                 // ...and the start index is greater than the end index,\n                 // this loop will never run. This is often confusing for developers\n                 // who think that this will iterate from the larger value to the"}, {"sha": "8b0f5795845bb68a9978b6a64f4add32e6702cdb", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 35, "deletions": 50, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -2,7 +2,6 @@ use rustc::hir::*;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::ConstContext;\n use rustc_const_math::ConstInt;\n use std::cmp::Ordering;\n@@ -11,7 +10,7 @@ use syntax::ast::LitKind;\n use syntax::codemap::Span;\n use utils::paths;\n use utils::{match_type, snippet, span_note_and_lint, span_lint_and_then, in_external_macro, expr_block, walk_ptrs_ty,\n-            is_expn_of};\n+            is_expn_of, remove_blocks};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for matches with a single arm where an `if let`\n@@ -31,7 +30,7 @@ use utils::sugg::Sugg;\n declare_lint! {\n     pub SINGLE_MATCH,\n     Warn,\n-    \"a match statement with a single nontrivial arm (i.e, where the other arm \\\n+    \"a match statement with a single nontrivial arm (i.e. where the other arm \\\n      is `_ => {}`) instead of `if let`\"\n }\n \n@@ -180,11 +179,12 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if arms.len() == 2 &&\n       arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n       arms[1].pats.len() == 1 && arms[1].guard.is_none() {\n-        let els = if is_unit_expr(&arms[1].body) {\n+        let els = remove_blocks(&arms[1].body);\n+        let els = if is_unit_expr(els) {\n             None\n-        } else if let ExprBlock(_) = arms[1].body.node {\n+        } else if let ExprBlock(_) = els.node {\n             // matches with blocks that contain statements are prettier as `if let + else`\n-            Some(&*arms[1].body)\n+            Some(els)\n         } else {\n             // allow match arms with just expressions\n             return;\n@@ -199,29 +199,33 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n \n fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n     if arms[1].pats[0].node == PatKind::Wild {\n-        let lint = if els.is_some() {\n-            SINGLE_MATCH_ELSE\n-        } else {\n-            SINGLE_MATCH\n-        };\n-        let els_str = els.map_or(String::new(), |els| format!(\" else {}\", expr_block(cx, els, None, \"..\")));\n-        span_lint_and_then(cx,\n-                           lint,\n-                           expr.span,\n-                           \"you seem to be trying to use match for destructuring a single pattern. \\\n-                           Consider using `if let`\",\n-                           |db| {\n-            db.span_suggestion(expr.span,\n-                               \"try this\",\n-                               format!(\"if let {} = {} {}{}\",\n-                                       snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                       snippet(cx, ex.span, \"..\"),\n-                                       expr_block(cx, &arms[0].body, None, \"..\"),\n-                                       els_str));\n-        });\n+        report_single_match_single_pattern(cx, ex, arms, expr, els);\n     }\n }\n \n+fn report_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n+    let lint = if els.is_some() {\n+        SINGLE_MATCH_ELSE\n+    } else {\n+        SINGLE_MATCH\n+    };\n+    let els_str = els.map_or(String::new(), |els| format!(\" else {}\", expr_block(cx, els, None, \"..\")));\n+    span_lint_and_then(cx,\n+                       lint,\n+                       expr.span,\n+                       \"you seem to be trying to use match for destructuring a single pattern. Consider using `if \\\n+                        let`\",\n+                       |db| {\n+        db.span_suggestion(expr.span,\n+                           \"try this\",\n+                           format!(\"if let {} = {} {}{}\",\n+                                   snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                   snippet(cx, ex.span, \"..\"),\n+                                   expr_block(cx, &arms[0].body, None, \"..\"),\n+                                   els_str));\n+    });\n+}\n+\n fn check_single_match_opt_like(\n     cx: &LateContext,\n     ex: &Expr,\n@@ -254,26 +258,7 @@ fn check_single_match_opt_like(\n \n     for &(ty_path, pat_path) in candidates {\n         if &path == pat_path && match_type(cx, ty, ty_path) {\n-            let lint = if els.is_some() {\n-                SINGLE_MATCH_ELSE\n-            } else {\n-                SINGLE_MATCH\n-            };\n-            let els_str = els.map_or(String::new(), |els| format!(\" else {}\", expr_block(cx, els, None, \"..\")));\n-            span_lint_and_then(cx,\n-                               lint,\n-                               expr.span,\n-                               \"you seem to be trying to use match for destructuring a single pattern. Consider \\\n-                                using `if let`\",\n-                               |db| {\n-                db.span_suggestion(expr.span,\n-                                   \"try this\",\n-                                   format!(\"if let {} = {} {}{}\",\n-                                           snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                           snippet(cx, ex.span, \"..\"),\n-                                           expr_block(cx, &arms[0].body, None, \"..\"),\n-                                           els_str));\n-            });\n+            report_single_match_single_pattern(cx, ex, arms, expr, els);\n         }\n     }\n }\n@@ -415,7 +400,7 @@ fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: Match\n }\n \n /// Get all arms that are unbounded `PatRange`s.\n-fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n+fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &[Arm]) -> Vec<SpannedRange<ConstVal<'tcx>>> {\n     let constcx = ConstContext::with_tables(cx.tcx, cx.tables);\n     arms.iter()\n         .flat_map(|arm| {\n@@ -427,8 +412,8 @@ fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n                 .filter_map(|pat| {\n                     if_let_chain! {[\n                     let PatKind::Range(ref lhs, ref rhs, ref range_end) = pat.node,\n-                    let Ok(lhs) = constcx.eval(lhs, ExprTypeChecked),\n-                    let Ok(rhs) = constcx.eval(rhs, ExprTypeChecked)\n+                    let Ok(lhs) = constcx.eval(lhs),\n+                    let Ok(rhs) = constcx.eval(rhs)\n                 ], {\n                     let rhs = match *range_end {\n                         RangeEnd::Included => Bound::Included(rhs),\n@@ -439,7 +424,7 @@ fn all_ranges(cx: &LateContext, arms: &[Arm]) -> Vec<SpannedRange<ConstVal>> {\n \n                     if_let_chain! {[\n                     let PatKind::Lit(ref value) = pat.node,\n-                    let Ok(value) = constcx.eval(value, ExprTypeChecked)\n+                    let Ok(value) = constcx.eval(value)\n                 ], {\n                     return Some(SpannedRange { span: pat.span, node: (value.clone(), Bound::Included(value)) });\n                 }}"}, {"sha": "b43a2473f0df6dfbf18c68344cce5d8dda04337f", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n                     let forgot_ty = cx.tables.expr_ty(&args[0]);\n \n                     if match forgot_ty.ty_adt_def() {\n-                        Some(def) => def.has_dtor(),\n+                        Some(def) => def.has_dtor(cx.tcx),\n                         _ => false,\n                     } {\n                         span_lint(cx, MEM_FORGET, e.span, \"usage of mem::forget on Drop type\");"}, {"sha": "b7416630963bd74ff0cb0f9cf5c4f3b21b4d2e06", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -3,7 +3,6 @@ use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n use rustc::hir::def::Def;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::ConstContext;\n use std::borrow::Cow;\n use std::fmt;\n@@ -1240,7 +1239,7 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n \n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n fn lint_single_char_pattern(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr) {\n-    if let Ok(ConstVal::Str(r)) = ConstContext::with_tables(cx.tcx, cx.tables).eval(arg, ExprTypeChecked) {\n+    if let Ok(ConstVal::Str(r)) = ConstContext::with_tables(cx.tcx, cx.tables).eval(arg) {\n         if r.len() == 1 {\n             let hint = snippet(cx, expr.span, \"..\").replace(&format!(\"\\\"{}\\\"\", r), &format!(\"'{}'\", r));\n             span_lint_and_then(cx,"}, {"sha": "2c6553e90c93de2ad8b73bef87a1366e4debc425", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -65,9 +65,9 @@ fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'\n             let def_id = cx.tables.qpath_def(qpath, path.id).def_id();\n \n             if match_def_path(cx.tcx, def_id, &paths::CMP_MIN) {\n-                fetch_const(args, MinMax::Min)\n+                fetch_const(cx, args, MinMax::Min)\n             } else if match_def_path(cx.tcx, def_id, &paths::CMP_MAX) {\n-                fetch_const(args, MinMax::Max)\n+                fetch_const(cx, args, MinMax::Max)\n             } else {\n                 None\n             }\n@@ -79,18 +79,18 @@ fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'\n     }\n }\n \n-fn fetch_const(args: &[Expr], m: MinMax) -> Option<(MinMax, Constant, &Expr)> {\n+fn fetch_const<'a>(cx: &LateContext, args: &'a [Expr], m: MinMax) -> Option<(MinMax, Constant, &'a Expr)> {\n     if args.len() != 2 {\n         return None;\n     }\n-    if let Some(c) = constant_simple(&args[0]) {\n-        if constant_simple(&args[1]).is_none() {\n+    if let Some(c) = constant_simple(cx, &args[0]) {\n+        if constant_simple(cx, &args[1]).is_none() {\n             // otherwise ignore\n             Some((m, c, &args[1]))\n         } else {\n             None\n         }\n-    } else if let Some(c) = constant_simple(&args[1]) {\n+    } else if let Some(c) = constant_simple(cx, &args[1]) {\n         Some((m, c, &args[0]))\n     } else {\n         None"}, {"sha": "328bba9f6fe7cc7a488f2c8747dd634b223c8b3b", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 104, "deletions": 56, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -4,13 +4,13 @@ use rustc::hir::intravisit::FnKind;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::ConstContext;\n use rustc_const_math::ConstFloat;\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n use utils::{get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path, snippet,\n-            span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment, iter_input_pats};\n+            span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment, iter_input_pats, in_constant};\n use utils::sugg::Sugg;\n+use syntax::ast::LitKind;\n \n /// **What it does:** Checks for function arguments and let bindings denoted as `ref`.\n ///\n@@ -173,6 +173,24 @@ declare_lint! {\n     \"using a short circuit boolean condition as a statement\"\n }\n \n+/// **What it does:** Catch casts from `0` to some pointer type\n+///\n+/// **Why is this bad?** This generally means `null` and is better expressed as\n+/// {`std`, `core`}`::ptr::`{`null`, `null_mut`}.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// 0 as *const u32\n+/// ```\n+declare_lint! {\n+    pub ZERO_PTR,\n+    Warn,\n+    \"using 0 as *{const, mut} T\"\n+}\n+\n #[derive(Copy, Clone)]\n pub struct Pass;\n \n@@ -185,7 +203,8 @@ impl LintPass for Pass {\n                     MODULO_ONE,\n                     REDUNDANT_PATTERN,\n                     USED_UNDERSCORE_BINDING,\n-                    SHORT_CIRCUIT_STATEMENT)\n+                    SHORT_CIRCUIT_STATEMENT,\n+                    ZERO_PTR)\n     }\n }\n \n@@ -264,41 +283,48 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n-            let op = cmp.node;\n-            if op.is_comparison() {\n-                if let ExprPath(QPath::Resolved(_, ref path)) = left.node {\n-                    check_nan(cx, path, expr.span);\n-                }\n-                if let ExprPath(QPath::Resolved(_, ref path)) = right.node {\n-                    check_nan(cx, path, expr.span);\n-                }\n-                check_to_owned(cx, left, right, true, cmp.span);\n-                check_to_owned(cx, right, left, false, cmp.span)\n-            }\n-            if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n-                if is_allowed(cx, left) || is_allowed(cx, right) {\n-                    return;\n+        match expr.node {\n+            ExprCast(ref e, ref ty) => {\n+                check_cast(cx, expr.span, e, ty);\n+                return;\n+            },\n+            ExprBinary(ref cmp, ref left, ref right) => {\n+                let op = cmp.node;\n+                if op.is_comparison() {\n+                    if let ExprPath(QPath::Resolved(_, ref path)) = left.node {\n+                        check_nan(cx, path, expr);\n+                    }\n+                    if let ExprPath(QPath::Resolved(_, ref path)) = right.node {\n+                        check_nan(cx, path, expr);\n+                    }\n+                    check_to_owned(cx, left, right, true, cmp.span);\n+                    check_to_owned(cx, right, left, false, cmp.span)\n                 }\n-                if let Some(name) = get_item_name(cx, expr) {\n-                    let name = &*name.as_str();\n-                    if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") ||\n-                       name.ends_with(\"_eq\") {\n+                if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n+                    if is_allowed(cx, left) || is_allowed(cx, right) {\n                         return;\n                     }\n+                    if let Some(name) = get_item_name(cx, expr) {\n+                        let name = &*name.as_str();\n+                        if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") ||\n+                           name.ends_with(\"_eq\") {\n+                            return;\n+                        }\n+                    }\n+                    span_lint_and_then(cx, FLOAT_CMP, expr.span, \"strict comparison of f32 or f64\", |db| {\n+                        let lhs = Sugg::hir(cx, left, \"..\");\n+                        let rhs = Sugg::hir(cx, right, \"..\");\n+\n+                        db.span_suggestion(expr.span,\n+                                           \"consider comparing them within some error\",\n+                                           format!(\"({}).abs() < error\", lhs - rhs));\n+                        db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n+                    });\n+                } else if op == BiRem && is_integer_literal(right, 1) {\n+                    span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n                 }\n-                span_lint_and_then(cx, FLOAT_CMP, expr.span, \"strict comparison of f32 or f64\", |db| {\n-                    let lhs = Sugg::hir(cx, left, \"..\");\n-                    let rhs = Sugg::hir(cx, right, \"..\");\n-\n-                    db.span_suggestion(expr.span,\n-                                       \"consider comparing them within some error\",\n-                                       format!(\"({}).abs() < error\", lhs - rhs));\n-                    db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n-                });\n-            } else if op == BiRem && is_integer_literal(right, 1) {\n-                span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n-            }\n+            },\n+            _ => {},\n         }\n         if in_attributes_expansion(cx, expr) {\n             // Don't lint things expanded by #[derive(...)], etc\n@@ -350,37 +376,43 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n-    path.segments.last().map(|seg| if &*seg.name.as_str() == \"NAN\" {\n-        span_lint(cx,\n-                  CMP_NAN,\n-                  span,\n-                  \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n-    });\n+fn check_nan(cx: &LateContext, path: &Path, expr: &Expr) {\n+    if !in_constant(cx, expr.id) {\n+        path.segments.last().map(|seg| if &*seg.name.as_str() == \"NAN\" {\n+            span_lint(cx,\n+                      CMP_NAN,\n+                      expr.span,\n+                      \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n+        });\n+    }\n }\n \n fn is_allowed(cx: &LateContext, expr: &Expr) -> bool {\n-    let res = ConstContext::with_tables(cx.tcx, cx.tables).eval(expr, ExprTypeChecked);\n+    let res = ConstContext::with_tables(cx.tcx, cx.tables).eval(expr);\n     if let Ok(ConstVal::Float(val)) = res {\n         use std::cmp::Ordering;\n+        match val {\n+            val @ ConstFloat::F32(_) => {\n+                let zero = ConstFloat::F32(0.0);\n \n-        let zero = ConstFloat::FInfer {\n-            f32: 0.0,\n-            f64: 0.0,\n-        };\n+                let infinity = ConstFloat::F32(::std::f32::INFINITY);\n \n-        let infinity = ConstFloat::FInfer {\n-            f32: ::std::f32::INFINITY,\n-            f64: ::std::f64::INFINITY,\n-        };\n+                let neg_infinity = ConstFloat::F32(::std::f32::NEG_INFINITY);\n \n-        let neg_infinity = ConstFloat::FInfer {\n-            f32: ::std::f32::NEG_INFINITY,\n-            f64: ::std::f64::NEG_INFINITY,\n-        };\n+                val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal) ||\n+                val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n+            },\n+            val @ ConstFloat::F64(_) => {\n+                let zero = ConstFloat::F64(0.0);\n+\n+                let infinity = ConstFloat::F64(::std::f64::INFINITY);\n+\n+                let neg_infinity = ConstFloat::F64(::std::f64::NEG_INFINITY);\n \n-        val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal) ||\n-        val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n+                val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal) ||\n+                val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n+            },\n+        }\n     } else {\n         false\n     }\n@@ -486,3 +518,19 @@ fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n         _ => false,\n     }\n }\n+\n+fn check_cast(cx: &LateContext, span: Span, e: &Expr, ty: &Ty) {\n+    if_let_chain! {[\n+        let TyPtr(MutTy { mutbl, .. }) = ty.node,\n+        let ExprLit(ref lit) = e.node,\n+        let LitKind::Int(value, ..) = lit.node,\n+        value == 0,\n+        !in_constant(cx, e.id)\n+    ], {\n+        let msg = match mutbl {\n+            Mutability::MutMutable => \"`0 as *mut _` detected. Consider using `ptr::null_mut()`\",\n+            Mutability::MutImmutable => \"`0 as *const _` detected. Consider using `ptr::null()`\",\n+        };\n+        span_lint(cx, ZERO_PTR, span, msg);\n+    }}\n+}"}, {"sha": "57c0c637f4111a41b727986fdf58d812c96b1598", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -162,24 +162,6 @@ declare_lint! {\n     \"shadowing a builtin type\"\n }\n \n-/// **What it does:** Catch casts from `0` to some pointer type\n-///\n-/// **Why is this bad?** This generally means `null` and is better expressed as\n-/// {`std`, `core`}`::ptr::`{`null`, `null_mut`}.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// 0 as *const u32\n-/// ```\n-declare_lint! {\n-    pub ZERO_PTR,\n-    Warn,\n-    \"using 0 as *{const, mut} T\"\n-}\n-\n #[derive(Copy, Clone)]\n pub struct MiscEarly;\n \n@@ -192,8 +174,7 @@ impl LintPass for MiscEarly {\n                     MIXED_CASE_HEX_LITERALS,\n                     UNSEPARATED_LITERAL_SUFFIX,\n                     ZERO_PREFIXED_LITERAL,\n-                    BUILTIN_TYPE_SHADOW,\n-                    ZERO_PTR)\n+                    BUILTIN_TYPE_SHADOW)\n     }\n }\n \n@@ -381,9 +362,6 @@ impl EarlyLintPass for MiscEarly {\n                     }\n                 }}\n             },\n-            ExprKind::Cast(ref e, ref ty) => {\n-                check_cast(cx, expr.span, e, ty);\n-            },\n             _ => (),\n         }\n     }\n@@ -412,18 +390,3 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n }\n-\n-fn check_cast(cx: &EarlyContext, span: Span, e: &Expr, ty: &Ty) {\n-    if_let_chain! {[\n-        let TyKind::Ptr(MutTy { mutbl, .. }) = ty.node,\n-        let ExprKind::Lit(ref lit) = e.node,\n-        let LitKind::Int(value, ..) = lit.node,\n-        value == 0\n-    ], {\n-        let msg = match mutbl {\n-            Mutability::Mutable => \"`0 as *mut _` detected. Consider using `ptr::null_mut()`\",\n-            Mutability::Immutable => \"`0 as *const _` detected. Consider using `ptr::null()`\",\n-        };\n-        span_lint(cx, ZERO_PTR, span, msg);\n-    }}\n-}"}, {"sha": "75cc588119f50eccfa1ae4f87399a5baf20e57f7", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -77,7 +77,7 @@ impl MissingDoc {\n             return;\n         }\n \n-        let has_doc = attrs.iter().any(|a| a.is_value_str() && a.name() == \"doc\");\n+        let has_doc = attrs.iter().any(|a| a.is_value_str() && a.name().map_or(false, |n| n == \"doc\"));\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS_IN_PRIVATE_ITEMS,\n                          sp,"}, {"sha": "07c941ecee6b1270d427e7a0635e0c05ed5cc7f1", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -62,7 +62,7 @@ fn check_arguments(cx: &LateContext, arguments: &[Expr], type_definition: &TyS,\n     match type_definition.sty {\n         TypeVariants::TyFnDef(_, _, fn_type) |\n         TypeVariants::TyFnPtr(fn_type) => {\n-            let parameters = fn_type.sig.skip_binder().inputs();\n+            let parameters = fn_type.skip_binder().inputs();\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n                 match parameter.sty {\n                     TypeVariants::TyRef(_, TypeAndMut { mutbl: MutImmutable, .. }) |"}, {"sha": "e25b1dc009312ed5dfe159b02fcbaf9139a7addd", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -41,6 +41,10 @@ impl LintPass for NeedlessPassByValue {\n     }\n }\n \n+macro_rules! need {\n+    ($e: expr) => { if let Some(x) = $e { x } else { return; } };\n+}\n+\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n     fn check_fn(\n         &mut self,\n@@ -55,14 +59,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n             return;\n         }\n \n-        if !matches!(kind, FnKind::ItemFn(..)) {\n-            return;\n+        match kind {\n+            FnKind::ItemFn(.., attrs) => {\n+                for a in attrs {\n+                    if_let_chain!{[\n+                        a.meta_item_list().is_some(),\n+                        let Some(name) = a.name(),\n+                        &*name.as_str() == \"proc_macro_derive\",\n+                    ], {\n+                        return;\n+                    }}\n+                }\n+            },\n+            _ => return,\n         }\n \n         // Allows these to be passed by value.\n-        let fn_trait = cx.tcx.lang_items.fn_trait().expect(\"failed to find `Fn` trait\");\n-        let asref_trait = get_trait_def_id(cx, &paths::ASREF_TRAIT).expect(\"failed to find `AsRef` trait\");\n-        let borrow_trait = get_trait_def_id(cx, &paths::BORROW_TRAIT).expect(\"failed to find `Borrow` trait\");\n+        let fn_trait = need!(cx.tcx.lang_items.fn_trait());\n+        let asref_trait = need!(get_trait_def_id(cx, &paths::ASREF_TRAIT));\n+        let borrow_trait = need!(get_trait_def_id(cx, &paths::BORROW_TRAIT));\n \n         let preds: Vec<ty::Predicate> = {\n             let parameter_env = ty::ParameterEnvironment::for_item(cx.tcx, node_id);\n@@ -85,7 +100,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n         let param_env = ty::ParameterEnvironment::for_item(cx.tcx, node_id);\n         let fn_sig = cx.tcx.item_type(fn_def_id).fn_sig();\n-        let fn_sig = cx.tcx.liberate_late_bound_regions(param_env.free_id_outlive, fn_sig);\n+        let fn_sig = cx.tcx.liberate_late_bound_regions(param_env.free_id_outlive, &fn_sig);\n \n         for ((input, ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n "}, {"sha": "d7437f34cff393bfbb48285032273ee9590ab498", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n fn check_mul(cx: &LateContext, span: Span, lit: &Expr, exp: &Expr) {\n     if_let_chain!([\n         let ExprLit(ref l) = lit.node,\n-        let Constant::Int(ref ci) = consts::lit_to_constant(&l.node),\n+        let Constant::Int(ref ci) = consts::lit_to_constant(&l.node, cx.tcx, cx.tables.expr_ty(lit)),\n         let Some(val) = ci.to_u64(),\n         val == 1,\n         cx.tables.expr_ty(exp).is_integral()"}, {"sha": "279996bfabe77240c8816217097e1f6a07229f1c", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -113,7 +113,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n \n fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n     let fn_def_id = cx.tcx.hir.local_def_id(fn_id);\n-    let fn_ty = cx.tcx.item_type(fn_def_id).fn_sig().skip_binder();\n+    let sig = cx.tcx.item_type(fn_def_id).fn_sig();\n+    let fn_ty = sig.skip_binder();\n \n     for (arg, ty) in decl.inputs.iter().zip(fn_ty.inputs()) {\n         if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = ty.sty {"}, {"sha": "6f22c3cfc7f65adc99b54904b1000c90c712f730", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -2,7 +2,6 @@ use regex_syntax;\n use rustc::hir::*;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::ConstContext;\n use std::collections::HashSet;\n use std::error::Error;\n@@ -151,7 +150,7 @@ fn str_span(base: Span, s: &str, c: usize) -> Span {\n }\n \n fn const_str(cx: &LateContext, e: &Expr) -> Option<InternedString> {\n-    match ConstContext::with_tables(cx.tcx, cx.tables).eval(e, ExprTypeChecked) {\n+    match ConstContext::with_tables(cx.tcx, cx.tables).eval(e) {\n         Ok(ConstVal::Str(r)) => Some(r),\n         _ => None,\n     }"}, {"sha": "031e3f8cf2ca2d0a4580140b6323d7968a1c3ec4", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -150,9 +150,5 @@ impl EarlyLintPass for ReturnPass {\n }\n \n fn attr_is_cfg(attr: &ast::Attribute) -> bool {\n-    if let ast::MetaItemKind::List(_) = attr.value.node {\n-        attr.name() == \"cfg\"\n-    } else {\n-        false\n-    }\n+    attr.meta_item_list().is_some() && attr.name().map_or(false, |n| n == \"cfg\")\n }"}, {"sha": "7ec6931462105e3b8b700a466ca241cc7a42b459", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -5,9 +5,10 @@ use rustc::lint::*;\n use rustc::ty;\n use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n+use syntax::attr::IntType;\n use syntax::codemap::Span;\n use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet, span_help_and_lint, span_lint,\n-            opt_def_id, last_path_segment};\n+            opt_def_id, last_path_segment, type_size};\n use utils::paths;\n \n /// Handles all the linting of funky types\n@@ -310,7 +311,7 @@ pub struct CastPass;\n declare_lint! {\n     pub CAST_PRECISION_LOSS,\n     Allow,\n-    \"casts that cause loss of precision, e.g `x as f32` where `x: u64`\"\n+    \"casts that cause loss of precision, e.g. `x as f32` where `x: u64`\"\n }\n \n /// **What it does:** Checks for casts from a signed to an unsigned numerical\n@@ -331,7 +332,7 @@ declare_lint! {\n declare_lint! {\n     pub CAST_SIGN_LOSS,\n     Allow,\n-    \"casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\"\n+    \"casts from signed types to unsigned types, e.g. `x as u32` where `x: i32`\"\n }\n \n /// **What it does:** Checks for on casts between numerical types that may\n@@ -351,7 +352,7 @@ declare_lint! {\n declare_lint! {\n     pub CAST_POSSIBLE_TRUNCATION,\n     Allow,\n-    \"casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, \\\n+    \"casts that may cause truncation of the value, e.g. `x as u8` where `x: u32`, \\\n      or `x as i32` where `x: f32`\"\n }\n \n@@ -375,7 +376,7 @@ declare_lint! {\n declare_lint! {\n     pub CAST_POSSIBLE_WRAP,\n     Allow,\n-    \"casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` \\\n+    \"casts that may cause wrapping around the value, e.g. `x as i32` where `x: u32` \\\n      and `x > i32::MAX`\"\n }\n \n@@ -392,7 +393,7 @@ declare_lint! {\n declare_lint! {\n     pub UNNECESSARY_CAST,\n     Warn,\n-    \"cast to the same type, e.g `x as i32` where `x: i32`\"\n+    \"cast to the same type, e.g. `x as i32` where `x: i32`\"\n }\n \n /// Returns the size in bits of an integral type.\n@@ -907,7 +908,6 @@ fn detect_absurd_comparison<'a>(\n fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeExpr<'a>> {\n     use rustc::middle::const_val::ConstVal::*;\n     use rustc_const_math::*;\n-    use rustc_const_eval::EvalHint::ExprTypeChecked;\n     use rustc_const_eval::*;\n     use types::ExtremeType::*;\n \n@@ -918,7 +918,7 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n         _ => return None,\n     };\n \n-    let cv = match ConstContext::with_tables(cx.tcx, cx.tables).eval(expr, ExprTypeChecked) {\n+    let cv = match ConstContext::with_tables(cx.tcx, cx.tables).eval(expr) {\n         Ok(val) => val,\n         Err(_) => return None,\n     };\n@@ -1077,7 +1077,13 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n     use std::*;\n \n     if let ExprCast(ref cast_exp, _) = expr.node {\n-        match cx.tables.expr_ty(cast_exp).sty {\n+        let pre_cast_ty = cx.tables.expr_ty(cast_exp);\n+        let cast_ty = cx.tables.expr_ty(expr);\n+        // if it's a cast from i32 to u32 wrapping will invalidate all these checks\n+        if type_size(cx, pre_cast_ty) == type_size(cx, cast_ty) {\n+            return None;\n+        }\n+        match pre_cast_ty.sty {\n             TyInt(int_ty) => {\n                 Some(match int_ty {\n                     IntTy::I8 => (FullInt::S(i8::min_value() as i128), FullInt::S(i8::max_value() as i128)),\n@@ -1107,18 +1113,15 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n \n fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n     use rustc::middle::const_val::ConstVal::*;\n-    use rustc_const_eval::EvalHint::ExprTypeChecked;\n     use rustc_const_eval::ConstContext;\n-    use rustc_const_math::ConstInt;\n \n-    match ConstContext::with_tables(cx.tcx, cx.tables).eval(expr, ExprTypeChecked) {\n+    match ConstContext::with_tables(cx.tcx, cx.tables).eval(expr) {\n         Ok(val) => {\n             if let Integral(const_int) = val {\n-                Some(match const_int.erase_type() {\n-                    ConstInt::InferSigned(x) => FullInt::S(x as i128),\n-                    ConstInt::Infer(x) => FullInt::U(x as u128),\n-                    _ => unreachable!(),\n-                })\n+                match const_int.int_type() {\n+                    IntType::SignedInt(_) => #[allow(cast_possible_wrap)] Some(FullInt::S(const_int.to_u128_unchecked() as i128)),\n+                    IntType::UnsignedInt(_) => Some(FullInt::U(const_int.to_u128_unchecked())),\n+                }\n             } else {\n                 None\n             }"}, {"sha": "a1e132e0f64782a932a6ce7ae851fa4129aeadf8", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -166,6 +166,7 @@ define_Conf! {\n     (\"doc-valid-idents\", doc_valid_idents, [\n         \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\",\n         \"DirectX\",\n+        \"ECMAScript\",\n         \"GPLv2\", \"GPLv3\",\n         \"GitHub\",\n         \"IPv4\", \"IPv6\","}, {"sha": "992fdab80b0ba5e23c616c2fa12cc067d93ccc7b", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -9,6 +9,8 @@ use rustc::traits::Reveal;\n use rustc::traits;\n use rustc::ty::subst::Subst;\n use rustc::ty;\n+use rustc::ty::layout::TargetDataLayout;\n+use rustc::mir::transform::MirSource;\n use rustc_errors;\n use std::borrow::Cow;\n use std::env;\n@@ -97,6 +99,17 @@ pub mod higher;\n pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n     rhs.expn_id != lhs.expn_id\n }\n+\n+pub fn in_constant(cx: &LateContext, id: NodeId) -> bool {\n+    let parent_id = cx.tcx.hir.get_parent(id);\n+    match MirSource::from_node(cx.tcx, parent_id) {\n+        MirSource::Fn(_) => false,\n+        MirSource::Const(_) |\n+        MirSource::Static(..) |\n+        MirSource::Promoted(..) => true,\n+    }\n+}\n+\n /// Returns true if this `expn_info` was expanded by any macro.\n pub fn in_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n     cx.sess().codemap().with_expn_info(span.expn_id, |info| {\n@@ -384,7 +397,7 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n /// snippet(cx, expr.span, \"..\")\n /// ```\n pub fn snippet<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n-    cx.sess().codemap().span_to_snippet(span).map(From::from).unwrap_or_else(|_| Cow::Borrowed(default))\n+    snippet_opt(cx, span).map_or_else(|| Cow::Borrowed(default), From::from)\n }\n \n /// Convert a span to a code snippet. Returns `None` if not available.\n@@ -665,17 +678,13 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n         if attr.is_sugared_doc {\n             continue;\n         }\n-        if let ast::MetaItemKind::NameValue(ref value) = attr.value.node {\n-            if attr.name() == name {\n-                if let LitKind::Str(ref s, _) = value.node {\n-                    if let Ok(value) = FromStr::from_str(&*s.as_str()) {\n-                        attr::mark_used(attr);\n-                        f(value)\n-                    } else {\n-                        sess.span_err(value.span, \"not a number\");\n-                    }\n+        if let Some(ref value) = attr.value_str() {\n+            if attr.name().map_or(false, |n| n == name) {\n+                if let Ok(value) = FromStr::from_str(&*value.as_str()) {\n+                    attr::mark_used(attr);\n+                    f(value)\n                 } else {\n-                    unreachable!()\n+                    sess.span_err(attr.span, \"not a number\");\n                 }\n             }\n         }\n@@ -781,7 +790,7 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> ty::T\n     let parameter_env = ty::ParameterEnvironment::for_item(cx.tcx, fn_item);\n     let fn_def_id = cx.tcx.hir.local_def_id(fn_item);\n     let fn_sig = cx.tcx.item_type(fn_def_id).fn_sig();\n-    let fn_sig = cx.tcx.liberate_late_bound_regions(parameter_env.free_id_outlive, fn_sig);\n+    let fn_sig = cx.tcx.liberate_late_bound_regions(parameter_env.free_id_outlive, &fn_sig);\n     fn_sig.output()\n }\n \n@@ -806,7 +815,7 @@ pub fn same_tys<'a, 'tcx>(\n pub fn type_is_unsafe_function(ty: ty::Ty) -> bool {\n     match ty.sty {\n         ty::TyFnDef(_, _, f) |\n-        ty::TyFnPtr(f) => f.unsafety == Unsafety::Unsafe,\n+        ty::TyFnPtr(f) => f.unsafety() == Unsafety::Unsafe,\n         _ => false,\n     }\n }\n@@ -972,3 +981,9 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n \n     None\n }\n+\n+pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>) -> Option<u64> {\n+    cx.tcx\n+        .infer_ctxt((), Reveal::All)\n+        .enter(|infcx| ty.layout(&infcx).ok().map(|lay| lay.size(&TargetDataLayout::parse(cx.sess())).bytes()))\n+}"}, {"sha": "b21ec0b4ee07670d41010238e3f651b2e5b26a90", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -99,6 +99,7 @@ impl<'a> Sugg<'a> {\n             ast::ExprKind::Block(..) |\n             ast::ExprKind::Break(..) |\n             ast::ExprKind::Call(..) |\n+            ast::ExprKind::Catch(..) |\n             ast::ExprKind::Continue(..) |\n             ast::ExprKind::Field(..) |\n             ast::ExprKind::ForLoop(..) |"}, {"sha": "3b9e38cb66bf113e139ff55d6a9f496e85eda12f", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -1,7 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n use rustc::ty;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::ConstContext;\n use syntax::codemap::Span;\n use utils::{higher, is_copy, snippet, span_lint_and_then};\n@@ -60,7 +59,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n     let snippet = match *vec_args {\n         higher::VecArgs::Repeat(elem, len) => {\n-            if ConstContext::with_tables(cx.tcx, cx.tables).eval(len, ExprTypeChecked).is_ok() {\n+            if ConstContext::with_tables(cx.tcx, cx.tables).eval(len).is_ok() {\n                 format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\")).into()\n             } else {\n                 return;"}, {"sha": "eb298f9bc7b3211d221b72420ec4c2a258ffa97d", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -36,8 +36,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would\n             // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too.\n-            let Some(Constant::Float(ref lhs_value, lhs_width)) = constant_simple(left),\n-            let Some(Constant::Float(ref rhs_value, rhs_width)) = constant_simple(right),\n+            let Some(Constant::Float(ref lhs_value, lhs_width)) = constant_simple(cx, left),\n+            let Some(Constant::Float(ref rhs_value, rhs_width)) = constant_simple(cx, right),\n             let Ok(0.0) = lhs_value.parse(),\n             let Ok(0.0) = rhs_value.parse()\n         ], {"}, {"sha": "1ca0d2b92f3436a4b59b3d7e8a00e8fede048fee", "filename": "src/main.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -89,7 +89,6 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n                                                            lint_groups,\n                                                            llvm_passes,\n                                                            attributes,\n-                                                           mir_passes,\n                                                            .. } = registry;\n                     let sess = &state.session;\n                     let mut ls = sess.lint_store.borrow_mut();\n@@ -105,7 +104,6 @@ impl<'a> CompilerCalls<'a> for ClippyCompilerCalls {\n                     }\n \n                     sess.plugin_llvm_passes.borrow_mut().extend(llvm_passes);\n-                    sess.mir_passes.borrow_mut().extend(mir_passes);\n                     sess.plugin_attributes.borrow_mut().extend(attributes);\n                 }\n                 old(state);\n@@ -244,30 +242,32 @@ pub fn main() {\n                 .expect(\"need to specify SYSROOT env var during clippy compilation, or use rustup or multirust\")\n         };\n \n-        // this conditional check for the --sysroot flag is there so users can call `cargo-clippy` directly\n-        // without having to pass --sysroot or anything\n-        let mut args: Vec<String> = if env::args().any(|s| s == \"--sysroot\") {\n-            env::args().collect()\n-        } else {\n-            env::args().chain(Some(\"--sysroot\".to_owned())).chain(Some(sys_root)).collect()\n-        };\n-\n-        // this check ensures that dependencies are built but not linted and the final crate is\n-        // linted but not built\n-        let clippy_enabled = env::args().any(|s| s == \"-Zno-trans\");\n+        rustc_driver::in_rustc_thread(|| {\n+                // this conditional check for the --sysroot flag is there so users can call `cargo-clippy` directly\n+                // without having to pass --sysroot or anything\n+                let mut args: Vec<String> = if env::args().any(|s| s == \"--sysroot\") {\n+                    env::args().collect()\n+                } else {\n+                    env::args().chain(Some(\"--sysroot\".to_owned())).chain(Some(sys_root)).collect()\n+                };\n \n-        if clippy_enabled {\n-            args.extend_from_slice(&[\"--cfg\".to_owned(), r#\"feature=\"cargo-clippy\"\"#.to_owned()]);\n-        }\n+                // this check ensures that dependencies are built but not linted and the final crate is\n+                // linted but not built\n+                let clippy_enabled = env::args().any(|s| s == \"-Zno-trans\");\n \n-        let mut ccc = ClippyCompilerCalls::new(clippy_enabled);\n-        let (result, _) = rustc_driver::run_compiler(&args, &mut ccc, None, None);\n+                if clippy_enabled {\n+                    args.extend_from_slice(&[\"--cfg\".to_owned(), r#\"feature=\"cargo-clippy\"\"#.to_owned()]);\n+                }\n \n-        if let Err(err_count) = result {\n-            if err_count > 0 {\n-                std::process::exit(1);\n-            }\n-        }\n+                let mut ccc = ClippyCompilerCalls::new(clippy_enabled);\n+                let (result, _) = rustc_driver::run_compiler(&args, &mut ccc, None, None);\n+                if let Err(err_count) = result {\n+                    if err_count > 0 {\n+                        std::process::exit(1);\n+                    }\n+                }\n+            })\n+            .expect(\"rustc_thread failed\");\n     }\n }\n "}, {"sha": "d4a4ef8a3a81255cc239ef72a30e6dc266089d50", "filename": "tests/consts.rs", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/d53b878af640a2f6c7b55bcb283052c66ec04d4f/tests%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53b878af640a2f6c7b55bcb283052c66ec04d4f/tests%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconsts.rs?ref=d53b878af640a2f6c7b55bcb283052c66ec04d4f", "patch": "@@ -1,99 +0,0 @@\n-#![feature(rustc_private)]\n-\n-extern crate clippy_lints;\n-extern crate rustc;\n-extern crate rustc_const_eval;\n-extern crate rustc_const_math;\n-extern crate syntax;\n-\n-use clippy_lints::consts::{constant_simple, Constant, FloatWidth};\n-use rustc_const_math::ConstInt;\n-use rustc::hir::*;\n-use syntax::ast::{LitIntType, LitKind, NodeId, StrStyle};\n-use syntax::codemap::{Spanned, COMMAND_LINE_SP};\n-use syntax::symbol::Symbol;\n-use syntax::ptr::P;\n-use syntax::util::ThinVec;\n-\n-fn spanned<T>(t: T) -> Spanned<T> {\n-    Spanned {\n-        node: t,\n-        span: COMMAND_LINE_SP,\n-    }\n-}\n-\n-fn expr(n: Expr_) -> Expr {\n-    Expr {\n-        id: NodeId::new(1),\n-        node: n,\n-        span: COMMAND_LINE_SP,\n-        attrs: ThinVec::new(),\n-    }\n-}\n-\n-fn lit(l: LitKind) -> Expr {\n-    expr(ExprLit(P(spanned(l))))\n-}\n-\n-fn binop(op: BinOp_, l: Expr, r: Expr) -> Expr {\n-    expr(ExprBinary(spanned(op), P(l), P(r)))\n-}\n-\n-fn check(expect: Constant, expr: &Expr) {\n-    assert_eq!(Some(expect), constant_simple(expr))\n-}\n-\n-const TRUE: Constant = Constant::Bool(true);\n-const FALSE: Constant = Constant::Bool(false);\n-const ZERO: Constant = Constant::Int(ConstInt::Infer(0));\n-const ONE: Constant = Constant::Int(ConstInt::Infer(1));\n-const TWO: Constant = Constant::Int(ConstInt::Infer(2));\n-\n-#[test]\n-fn test_lit() {\n-    check(TRUE, &lit(LitKind::Bool(true)));\n-    check(FALSE, &lit(LitKind::Bool(false)));\n-    check(ZERO, &lit(LitKind::Int(0, LitIntType::Unsuffixed)));\n-    check(Constant::Str(\"cool!\".into(), StrStyle::Cooked),\n-          &lit(LitKind::Str(Symbol::intern(\"cool!\"), StrStyle::Cooked)));\n-}\n-\n-#[test]\n-fn test_ops() {\n-    check(TRUE, &binop(BiOr, lit(LitKind::Bool(false)), lit(LitKind::Bool(true))));\n-    check(FALSE, &binop(BiAnd, lit(LitKind::Bool(false)), lit(LitKind::Bool(true))));\n-\n-    let litzero = lit(LitKind::Int(0, LitIntType::Unsuffixed));\n-    let litone = lit(LitKind::Int(1, LitIntType::Unsuffixed));\n-    check(TRUE, &binop(BiEq, litzero.clone(), litzero.clone()));\n-    check(TRUE, &binop(BiGe, litzero.clone(), litzero.clone()));\n-    check(TRUE, &binop(BiLe, litzero.clone(), litzero.clone()));\n-    check(FALSE, &binop(BiNe, litzero.clone(), litzero.clone()));\n-    check(FALSE, &binop(BiGt, litzero.clone(), litzero.clone()));\n-    check(FALSE, &binop(BiLt, litzero.clone(), litzero.clone()));\n-\n-    check(ZERO, &binop(BiAdd, litzero.clone(), litzero.clone()));\n-    check(TWO, &binop(BiAdd, litone.clone(), litone.clone()));\n-    check(ONE, &binop(BiSub, litone.clone(), litzero.clone()));\n-    check(ONE, &binop(BiMul, litone.clone(), litone.clone()));\n-    check(ONE, &binop(BiDiv, litone.clone(), litone.clone()));\n-\n-    let half_any = Constant::Float(\"0.5\".into(), FloatWidth::Any);\n-    let half32 = Constant::Float(\"0.5\".into(), FloatWidth::F32);\n-    let half64 = Constant::Float(\"0.5\".into(), FloatWidth::F64);\n-    let pos_zero = Constant::Float(\"0.0\".into(), FloatWidth::F64);\n-    let neg_zero = Constant::Float(\"-0.0\".into(), FloatWidth::F64);\n-\n-    assert_eq!(pos_zero, pos_zero);\n-    assert_eq!(neg_zero, neg_zero);\n-    assert_eq!(None, pos_zero.partial_cmp(&neg_zero));\n-\n-    assert_eq!(half_any, half32);\n-    assert_eq!(half_any, half64);\n-    // for transitivity\n-    assert_eq!(half32, half64);\n-\n-    assert_eq!(Constant::Int(ConstInt::Infer(0)), Constant::Int(ConstInt::U8(0)));\n-    assert_eq!(Constant::Int(ConstInt::Infer(0)), Constant::Int(ConstInt::I8(0)));\n-    assert_eq!(Constant::Int(ConstInt::InferSigned(-1)), Constant::Int(ConstInt::I8(-1)));\n-}"}, {"sha": "506926501a2721c9f10180634b736d869732c123", "filename": "tests/matches.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmatches.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -1,5 +1,4 @@\n #![feature(rustc_private)]\n-#![feature(collections_bound)]\n \n extern crate clippy_lints;\n extern crate syntax;"}, {"sha": "d53d3a1cc758f660260567f9d7b86e4aef8b102c", "filename": "tests/run-pass/ice-1588.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Frun-pass%2Fice-1588.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Frun-pass%2Fice-1588.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fice-1588.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -0,0 +1,13 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![allow(clippy)]\n+\n+fn main() {\n+    match 1 {\n+        1 => {}\n+        2 => {\n+            [0; 1];\n+        }\n+        _ => {}\n+    }\n+}"}, {"sha": "9f63a6b2d73223f2fc78e1e4a92c88ec445b5ce1", "filename": "tests/run-pass/mut_mut_macro.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Frun-pass%2Fmut_mut_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Frun-pass%2Fmut_mut_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmut_mut_macro.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -1,12 +1,20 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n+#![deny(mut_mut, zero_ptr, cmp_nan)]\n+#![allow(dead_code)]\n \n #[macro_use]\n extern crate lazy_static;\n \n use std::collections::HashMap;\n \n-#[deny(mut_mut)]\n+// ensure that we don't suggest `is_nan` and `is_null` inside constants\n+// FIXME: once const fn is stable, suggest these functions again in constants\n+const BAA: *const i32 = 0 as *const i32;\n+static mut BAR: *const i32 = BAA;\n+static mut FOO: *const i32 = 0 as *const i32;\n+static mut BUH: bool = 42.0 < std::f32::NAN;\n+\n #[allow(unused_variables, unused_mut)]\n fn main() {\n     lazy_static! {\n@@ -19,4 +27,6 @@ fn main() {\n         static ref MUT_COUNT : usize = MUT_MAP.len();\n     }\n     assert!(*MUT_COUNT == 1);\n+    // FIXME: don't lint in array length, requires `check_body`\n+    //let _ = [\"\"; (42.0 < std::f32::NAN) as usize];\n }"}, {"sha": "fe3cf1ce71f0d8e98e1472130f8813fdddd9d334", "filename": "tests/run-pass/single-match-else.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Frun-pass%2Fsingle-match-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Frun-pass%2Fsingle-match-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsingle-match-else.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -0,0 +1,11 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![warn(single_match_else)]\n+\n+fn main() {\n+    let n = match (42, 43) {\n+        (42, n) => n,\n+        _ => panic!(\"typeck error\"),\n+    };\n+    assert_eq!(n, 43);\n+}"}, {"sha": "c59f04d4f381ca9ef4efcddd855db67ea747de0f", "filename": "tests/ui/invalid_upcast_comparisons.rs", "status": "modified", "additions": 68, "deletions": 22, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Fui%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Fui%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finvalid_upcast_comparisons.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -3,33 +3,79 @@\n \n #![deny(invalid_upcast_comparisons)]\n #![allow(unused, eq_op, no_effect, unnecessary_operation)]\n-fn main() {\n-    let zero: u32 = 0;\n-    let u8_max: u8 = 255;\n \n-    (u8_max as u32) > 300;\n-    (u8_max as u32) > 20;\n+fn mk_value<T>() -> T { unimplemented!() }\n+\n+fn main() {\n+    let u32: u32 = mk_value();\n+    let u8: u8 = mk_value();\n+    let i32: i32 = mk_value();\n+    let i8: i8 = mk_value();\n \n-    (zero as i32) < -5;\n-    (zero as i32) < 10;\n+    // always false, since no u8 can be > 300\n+    (u8 as u32) > 300;\n+    (u8 as i32) > 300;\n+    (u8 as u32) == 300;\n+    (u8 as i32) == 300;\n+    300 < (u8 as u32);\n+    300 < (u8 as i32);\n+    300 == (u8 as u32);\n+    300 == (u8 as i32);\n+    // inverted of the above\n+    (u8 as u32) <= 300;\n+    (u8 as i32) <= 300;\n+    (u8 as u32) != 300;\n+    (u8 as i32) != 300;\n+    300 >= (u8 as u32);\n+    300 >= (u8 as i32);\n+    300 != (u8 as u32);\n+    300 != (u8 as i32);\n \n-    -5 < (zero as i32);\n-    0 <= (zero as i32);\n-    0 < (zero as i32);\n+    // always false, since u8 -> i32 doesn't wrap\n+    (u8 as i32) < 0;\n+    -5 != (u8 as i32);\n+    // inverted of the above\n+    (u8 as i32) >= 0;\n+    -5 == (u8 as i32);\n \n-    -5 > (zero as i32);\n-    -5 >= (u8_max as i32);\n-    1337 == (u8_max as i32);\n+    // always false, since no u8 can be 1337\n+    1337 == (u8 as i32);\n+    1337 == (u8 as u32);\n+    // inverted of the above\n+    1337 != (u8 as i32);\n+    1337 != (u8 as u32);\n \n-    -5 == (zero as i32);\n-    -5 != (u8_max as i32);\n \n     // Those are Ok:\n-    42 == (u8_max as i32);\n-    42 != (u8_max as i32);\n-    42 > (u8_max as i32);\n-    (u8_max as i32) == 42;\n-    (u8_max as i32) != 42;\n-    (u8_max as i32) > 42;\n-    (u8_max as i32) < 42;\n+    (u8 as u32) > 20;\n+    42 == (u8 as i32);\n+    42 != (u8 as i32);\n+    42 > (u8 as i32);\n+    (u8 as i32) == 42;\n+    (u8 as i32) != 42;\n+    (u8 as i32) > 42;\n+    (u8 as i32) < 42;\n+\n+    (u8 as i8) == -1;\n+    (u8 as i8) != -1;\n+    (u8 as i32) > -1;\n+    (u8 as i32) < -1;\n+    (u32 as i32) < -5;\n+    (u32 as i32) < 10;\n+\n+    (i8 as u8) == 1;\n+    (i8 as u8) != 1;\n+    (i8 as u8) < 1;\n+    (i8 as u8) > 1;\n+    (i32 as u32) < 5;\n+    (i32 as u32) < 10;\n+\n+    -5 < (u32 as i32);\n+    0 <= (u32 as i32);\n+    0 < (u32 as i32);\n+\n+    -5 > (u32 as i32);\n+    -5 >= (u8 as i32);\n+\n+    -5 == (u32 as i32);\n }"}, {"sha": "874081c22abea2cebe2b72e7073f7e576755ddf4", "filename": "tests/ui/invalid_upcast_comparisons.stderr", "status": "modified", "additions": 139, "deletions": 31, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Fui%2Finvalid_upcast_comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Fui%2Finvalid_upcast_comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finvalid_upcast_comparisons.stderr?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -1,62 +1,170 @@\n-error: because of the numeric bounds on `u8_max` prior to casting, this expression is always false\n-  --> $DIR/invalid_upcast_comparisons.rs:10:5\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:16:5\n    |\n-10 |     (u8_max as u32) > 300;\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+16 |     (u8 as u32) > 300;\n+   |     ^^^^^^^^^^^^^^^^^\n    |\n note: lint level defined here\n   --> $DIR/invalid_upcast_comparisons.rs:4:9\n    |\n 4  | #![deny(invalid_upcast_comparisons)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `zero` prior to casting, this expression is always false\n-  --> $DIR/invalid_upcast_comparisons.rs:13:5\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:17:5\n    |\n-13 |     (zero as i32) < -5;\n-   |     ^^^^^^^^^^^^^^^^^^\n+17 |     (u8 as i32) > 300;\n+   |     ^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `zero` prior to casting, this expression is always true\n-  --> $DIR/invalid_upcast_comparisons.rs:16:5\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:18:5\n    |\n-16 |     -5 < (zero as i32);\n+18 |     (u8 as u32) == 300;\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `zero` prior to casting, this expression is always true\n-  --> $DIR/invalid_upcast_comparisons.rs:17:5\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:19:5\n    |\n-17 |     0 <= (zero as i32);\n+19 |     (u8 as i32) == 300;\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `zero` prior to casting, this expression is always false\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n   --> $DIR/invalid_upcast_comparisons.rs:20:5\n    |\n-20 |     -5 > (zero as i32);\n-   |     ^^^^^^^^^^^^^^^^^^\n+20 |     300 < (u8 as u32);\n+   |     ^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `u8_max` prior to casting, this expression is always false\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n   --> $DIR/invalid_upcast_comparisons.rs:21:5\n    |\n-21 |     -5 >= (u8_max as i32);\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+21 |     300 < (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `u8_max` prior to casting, this expression is always false\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n   --> $DIR/invalid_upcast_comparisons.rs:22:5\n    |\n-22 |     1337 == (u8_max as i32);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+22 |     300 == (u8 as u32);\n+   |     ^^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `zero` prior to casting, this expression is always false\n-  --> $DIR/invalid_upcast_comparisons.rs:24:5\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:23:5\n    |\n-24 |     -5 == (zero as i32);\n-   |     ^^^^^^^^^^^^^^^^^^^\n+23 |     300 == (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^^\n \n-error: because of the numeric bounds on `u8_max` prior to casting, this expression is always true\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n   --> $DIR/invalid_upcast_comparisons.rs:25:5\n    |\n-25 |     -5 != (u8_max as i32);\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+25 |     (u8 as u32) <= 300;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:26:5\n+   |\n+26 |     (u8 as i32) <= 300;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:27:5\n+   |\n+27 |     (u8 as u32) != 300;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:28:5\n+   |\n+28 |     (u8 as i32) != 300;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:29:5\n+   |\n+29 |     300 >= (u8 as u32);\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:30:5\n+   |\n+30 |     300 >= (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:31:5\n+   |\n+31 |     300 != (u8 as u32);\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:32:5\n+   |\n+32 |     300 != (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:35:5\n+   |\n+35 |     (u8 as i32) < 0;\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:36:5\n+   |\n+36 |     -5 != (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:38:5\n+   |\n+38 |     (u8 as i32) >= 0;\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:39:5\n+   |\n+39 |     -5 == (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:42:5\n+   |\n+42 |     1337 == (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:43:5\n+   |\n+43 |     1337 == (u8 as u32);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:45:5\n+   |\n+45 |     1337 != (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:46:5\n+   |\n+46 |     1337 != (u8 as u32);\n+   |     ^^^^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always true\n+  --> $DIR/invalid_upcast_comparisons.rs:61:5\n+   |\n+61 |     (u8 as i32) > -1;\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:62:5\n+   |\n+62 |     (u8 as i32) < -1;\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: because of the numeric bounds on `u8` prior to casting, this expression is always false\n+  --> $DIR/invalid_upcast_comparisons.rs:78:5\n+   |\n+78 |     -5 >= (u8 as i32);\n+   |     ^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 27 previous errors\n "}, {"sha": "5ba94383cc690a6f35b6480efbb53d7f8ecd2b26", "filename": "tests/ui/item_after_statement.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Fui%2Fitem_after_statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Fui%2Fitem_after_statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fitem_after_statement.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -17,3 +17,14 @@ fn main() {\n     fn foo() { println!(\"foo\"); }\n     foo();\n }\n+\n+fn mac() {\n+    let mut a = 5;\n+    println!(\"{}\", a);\n+    // do not lint this, because it needs to be after `a`\n+    macro_rules! b {\n+        () => {{ a = 6 }}\n+    }\n+    b!();\n+    println!(\"{}\", a);\n+}"}, {"sha": "8322cc40e8ec03c3287f5702f75e3fbab3bed6cb", "filename": "tests/ui/needless_pass_by_value_proc_macro.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Fui%2Fneedless_pass_by_value_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ae82eb4ab8845e3c247c62d27549f16ecef5360/tests%2Fui%2Fneedless_pass_by_value_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value_proc_macro.rs?ref=8ae82eb4ab8845e3c247c62d27549f16ecef5360", "patch": "@@ -0,0 +1,11 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![crate_type = \"proc-macro\"]\n+#![deny(needless_pass_by_value)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(Foo)]\n+pub fn foo(_input: TokenStream) -> TokenStream { unimplemented!() }"}]}