{"sha": "445077963c55297ef1e196a3525723090fe80b22", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NTA3Nzk2M2M1NTI5N2VmMWUxOTZhMzUyNTcyMzA5MGZlODBiMjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-20T21:08:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-20T21:08:28Z"}, "message": "Auto merge of #42780 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 6 pull requests\n\n- Successful merges: #42271, #42717, #42728, #42749, #42756, #42772\n- Failed merges:", "tree": {"sha": "19b62bba2839c59b1e36f3998dff94997a2df797", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19b62bba2839c59b1e36f3998dff94997a2df797"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/445077963c55297ef1e196a3525723090fe80b22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/445077963c55297ef1e196a3525723090fe80b22", "html_url": "https://github.com/rust-lang/rust/commit/445077963c55297ef1e196a3525723090fe80b22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/445077963c55297ef1e196a3525723090fe80b22/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29bce6e220f6fd2292d13d65fe503af7bf4852b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/29bce6e220f6fd2292d13d65fe503af7bf4852b7", "html_url": "https://github.com/rust-lang/rust/commit/29bce6e220f6fd2292d13d65fe503af7bf4852b7"}, {"sha": "58425ef71dd80c9e91adb359085473d66cd7e155", "url": "https://api.github.com/repos/rust-lang/rust/commits/58425ef71dd80c9e91adb359085473d66cd7e155", "html_url": "https://github.com/rust-lang/rust/commit/58425ef71dd80c9e91adb359085473d66cd7e155"}], "stats": {"total": 296, "additions": 278, "deletions": 18}, "files": [{"sha": "8013b4988e1414ad1ee408dd494b84da85edb034", "filename": "src/doc/unstable-book/src/library-features/char-error-internals.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/445077963c55297ef1e196a3525723090fe80b22/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fchar-error-internals.md", "raw_url": "https://github.com/rust-lang/rust/raw/445077963c55297ef1e196a3525723090fe80b22/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fchar-error-internals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fchar-error-internals.md?ref=445077963c55297ef1e196a3525723090fe80b22", "patch": "@@ -0,0 +1,5 @@\n+# `char_error_internals`\n+\n+This feature is internal to the Rust compiler and is not intended for general use.\n+\n+------------------------"}, {"sha": "c9c7a27c614fa08ca42cda12e8d18a2e70208a3e", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/445077963c55297ef1e196a3525723090fe80b22/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445077963c55297ef1e196a3525723090fe80b22/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=445077963c55297ef1e196a3525723090fe80b22", "patch": "@@ -2124,10 +2124,12 @@ impl<T> From<Box<[T]>> for Vec<T> {\n     }\n }\n \n-#[stable(feature = \"box_from_vec\", since = \"1.18.0\")]\n-impl<T> Into<Box<[T]>> for Vec<T> {\n-    fn into(self) -> Box<[T]> {\n-        self.into_boxed_slice()\n+// note: test pulls in libstd, which causes errors here\n+#[cfg(not(test))]\n+#[stable(feature = \"box_from_vec\", since = \"1.20.0\")]\n+impl<T> From<Vec<T>> for Box<[T]> {\n+    fn from(v: Vec<T>) -> Box<[T]> {\n+        v.into_boxed_slice()\n     }\n }\n "}, {"sha": "44f5fdbf4312bcfe92a9ce8a915d03831c334856", "filename": "src/libcore/char.rs", "status": "modified", "additions": 58, "deletions": 1, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/445077963c55297ef1e196a3525723090fe80b22/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445077963c55297ef1e196a3525723090fe80b22/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=445077963c55297ef1e196a3525723090fe80b22", "patch": "@@ -19,7 +19,7 @@ use char_private::is_printable;\n use convert::TryFrom;\n use fmt::{self, Write};\n use slice;\n-use str::from_utf8_unchecked_mut;\n+use str::{from_utf8_unchecked_mut, FromStr};\n use iter::FusedIterator;\n use mem::transmute;\n \n@@ -208,6 +208,63 @@ impl From<u8> for char {\n     }\n }\n \n+\n+/// An error which can be returned when parsing a char.\n+#[stable(feature = \"char_from_str\", since = \"1.19.0\")]\n+#[derive(Clone, Debug)]\n+pub struct ParseCharError {\n+    kind: CharErrorKind,\n+}\n+\n+impl ParseCharError {\n+    #[unstable(feature = \"char_error_internals\",\n+               reason = \"this method should not be available publicly\",\n+               issue = \"0\")]\n+    #[doc(hidden)]\n+    pub fn __description(&self) -> &str {\n+        match self.kind {\n+            CharErrorKind::EmptyString => {\n+                \"cannot parse char from empty string\"\n+            },\n+            CharErrorKind::TooManyChars => \"too many characters in string\"\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum CharErrorKind {\n+    EmptyString,\n+    TooManyChars,\n+}\n+\n+#[stable(feature = \"char_from_str\", since = \"1.19.0\")]\n+impl fmt::Display for ParseCharError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.__description().fmt(f)\n+    }\n+}\n+\n+\n+#[stable(feature = \"char_from_str\", since = \"1.19.0\")]\n+impl FromStr for char {\n+    type Err = ParseCharError;\n+\n+    #[inline]\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        let mut chars = s.chars();\n+        match (chars.next(), chars.next()) {\n+            (None, _) => {\n+                Err(ParseCharError { kind: CharErrorKind::EmptyString })\n+            },\n+            (Some(c), None) => Ok(c),\n+            _ => {\n+                Err(ParseCharError { kind: CharErrorKind::TooManyChars })\n+            }\n+        }\n+    }\n+}\n+\n+\n #[unstable(feature = \"try_from\", issue = \"33417\")]\n impl TryFrom<u32> for char {\n     type Error = CharTryFromError;"}, {"sha": "7c3b90c81536e16a6342d3ada76b9d68832a5306", "filename": "src/libcore/tests/char.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/445077963c55297ef1e196a3525723090fe80b22/src%2Flibcore%2Ftests%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445077963c55297ef1e196a3525723090fe80b22/src%2Flibcore%2Ftests%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fchar.rs?ref=445077963c55297ef1e196a3525723090fe80b22", "patch": "@@ -10,6 +10,7 @@\n \n use std::{char,str};\n use std::convert::TryFrom;\n+use std::str::FromStr;\n \n #[test]\n fn test_convert() {\n@@ -28,6 +29,16 @@ fn test_convert() {\n     assert!(char::try_from(0xFFFF_FFFF_u32).is_err());\n }\n \n+#[test]\n+fn test_from_str() {\n+    assert_eq!(char::from_str(\"a\").unwrap(), 'a');\n+    assert_eq!(char::try_from(\"a\").unwrap(), 'a');\n+    assert_eq!(char::from_str(\"\\0\").unwrap(), '\\0');\n+    assert_eq!(char::from_str(\"\\u{D7FF}\").unwrap(), '\\u{d7FF}');\n+    assert!(char::from_str(\"\").is_err());\n+    assert!(char::from_str(\"abc\").is_err());\n+}\n+\n #[test]\n fn test_is_lowercase() {\n     assert!('a'.is_lowercase());"}, {"sha": "2015cf17a6a2a2280e93d9c57214ba92dbbaf42f", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=445077963c55297ef1e196a3525723090fe80b22", "patch": "@@ -1 +1 @@\n-Subproject commit 03562b0cb26a00f49d4eaf18ca3e49608110b0c8\n+Subproject commit 2015cf17a6a2a2280e93d9c57214ba92dbbaf42f"}, {"sha": "473c0f3ffda86dabafb38632ef43d75b798d0eec", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/445077963c55297ef1e196a3525723090fe80b22/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445077963c55297ef1e196a3525723090fe80b22/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=445077963c55297ef1e196a3525723090fe80b22", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::hir::def_id::DefId;\n use rustc::ty;\n use rustc::ty::adjustment;\n use util::nodemap::FxHashMap;\n@@ -144,20 +145,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             ty::TyTuple(ref tys, _) if tys.is_empty() => return,\n             ty::TyNever => return,\n             ty::TyBool => return,\n-            ty::TyAdt(def, _) => {\n-                let attrs = cx.tcx.get_attrs(def.did);\n-                check_must_use(cx, &attrs, s.span)\n-            }\n+            ty::TyAdt(def, _) => check_must_use(cx, def.did, s.span),\n             _ => false,\n         };\n         if !warned {\n             cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n         }\n \n-        fn check_must_use(cx: &LateContext, attrs: &[ast::Attribute], sp: Span) -> bool {\n-            for attr in attrs {\n+        fn check_must_use(cx: &LateContext, def_id: DefId, sp: Span) -> bool {\n+            for attr in cx.tcx.get_attrs(def_id).iter() {\n                 if attr.check_name(\"must_use\") {\n-                    let mut msg = \"unused result which must be used\".to_string();\n+                    let mut msg = format!(\"unused `{}` which must be used\",\n+                                          cx.tcx.item_path_str(def_id));\n                     // check for #[must_use=\"...\"]\n                     if let Some(s) = attr.value_str() {\n                         msg.push_str(\": \");"}, {"sha": "b97c08b5bded677198cf124bc211d11f9d97937d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/445077963c55297ef1e196a3525723090fe80b22/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445077963c55297ef1e196a3525723090fe80b22/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=445077963c55297ef1e196a3525723090fe80b22", "patch": "@@ -523,7 +523,10 @@ impl<'a> Resolver<'a> {\n         };\n \n         let kind = ModuleKind::Def(Def::Mod(def_id), name);\n-        self.arenas.alloc_module(ModuleData::new(parent, kind, def_id, Mark::root(), DUMMY_SP))\n+        let module =\n+            self.arenas.alloc_module(ModuleData::new(parent, kind, def_id, Mark::root(), DUMMY_SP));\n+        self.extern_module_map.insert((def_id, macros_only), module);\n+        module\n     }\n \n     pub fn macro_def_scope(&mut self, expansion: Mark) -> Module<'a> {"}, {"sha": "770bca7524c2411147b5cc50087238a5cfdc5964", "filename": "src/libstd/env.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/445077963c55297ef1e196a3525723090fe80b22/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445077963c55297ef1e196a3525723090fe80b22/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=445077963c55297ef1e196a3525723090fe80b22", "patch": "@@ -438,6 +438,35 @@ pub struct JoinPathsError {\n ///\n /// # Examples\n ///\n+/// Joining paths on a Unix-like platform:\n+///\n+/// ```\n+/// # if cfg!(unix) {\n+/// use std::env;\n+/// use std::ffi::OsString;\n+/// use std::path::Path;\n+///\n+/// let paths = [Path::new(\"/bin\"), Path::new(\"/usr/bin\")];\n+/// let path_os_string = env::join_paths(paths.iter()).unwrap();\n+/// assert_eq!(path_os_string, OsString::from(\"/bin:/usr/bin\"));\n+/// # }\n+/// ```\n+///\n+/// Joining a path containing a colon on a Unix-like platform results in an error:\n+///\n+/// ```\n+/// # if cfg!(unix) {\n+/// use std::env;\n+/// use std::path::Path;\n+///\n+/// let paths = [Path::new(\"/bin\"), Path::new(\"/usr/bi:n\")];\n+/// assert!(env::join_paths(paths.iter()).is_err());\n+/// # }\n+/// ```\n+///\n+/// Using `env::join_paths` with `env::spit_paths` to append an item to the `PATH` environment\n+/// variable:\n+///\n /// ```\n /// use std::env;\n /// use std::path::PathBuf;"}, {"sha": "4b340f70fbc745089b811af196960db05ab274d1", "filename": "src/libstd/error.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/445077963c55297ef1e196a3525723090fe80b22/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445077963c55297ef1e196a3525723090fe80b22/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=445077963c55297ef1e196a3525723090fe80b22", "patch": "@@ -340,6 +340,14 @@ impl Error for char::CharTryFromError {\n     }\n }\n \n+#[stable(feature = \"char_from_str\", since = \"1.19.0\")]\n+impl Error for char::ParseCharError {\n+    fn description(&self) -> &str {\n+        self.__description()\n+    }\n+}\n+\n+\n // copied from any.rs\n impl Error + 'static {\n     /// Returns true if the boxed type is the same as `T`"}, {"sha": "1a91417ca0e92dcdcb623a5e840e668affb9fd4a", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/445077963c55297ef1e196a3525723090fe80b22/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445077963c55297ef1e196a3525723090fe80b22/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=445077963c55297ef1e196a3525723090fe80b22", "patch": "@@ -152,6 +152,14 @@ pub struct CStr {\n /// in the vector provided.\n ///\n /// [`CString::new`]: struct.CString.html#method.new\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::ffi::{CString, NulError};\n+///\n+/// let _: NulError = CString::new(b\"f\\0oo\".to_vec()).unwrap_err();\n+/// ```\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct NulError(usize, Vec<u8>);\n@@ -160,6 +168,14 @@ pub struct NulError(usize, Vec<u8>);\n /// byte was found too early in the slice provided or one wasn't found at all.\n ///\n /// [`CStr::from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::ffi::{CStr, FromBytesWithNulError};\n+///\n+/// let _: FromBytesWithNulError = CStr::from_bytes_with_nul(b\"f\\0oo\").unwrap_err();\n+/// ```\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n pub struct FromBytesWithNulError {\n@@ -271,6 +287,27 @@ impl CString {\n     /// to undefined behavior or allocator corruption.\n     ///\n     /// [`into_raw`]: #method.into_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// Create a `CString`, pass ownership to an `extern` function (via raw pointer), then retake\n+    /// ownership with `from_raw`:\n+    ///\n+    /// ```no_run\n+    /// use std::ffi::CString;\n+    /// use std::os::raw::c_char;\n+    ///\n+    /// extern {\n+    ///     fn some_extern_function(s: *mut c_char);\n+    /// }\n+    ///\n+    /// let c_string = CString::new(\"Hello!\").unwrap();\n+    /// let raw = c_string.into_raw();\n+    /// unsafe {\n+    ///     some_extern_function(raw);\n+    ///     let c_string = CString::from_raw(raw);\n+    /// }\n+    /// ```\n     #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n     pub unsafe fn from_raw(ptr: *mut c_char) -> CString {\n         let len = libc::strlen(ptr) + 1; // Including the NUL byte\n@@ -412,6 +449,18 @@ impl CString {\n     /// Extracts a [`CStr`] slice containing the entire string.\n     ///\n     /// [`CStr`]: struct.CStr.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(as_c_str)]\n+    ///\n+    /// use std::ffi::{CString, CStr};\n+    ///\n+    /// let c_string = CString::new(b\"foo\".to_vec()).unwrap();\n+    /// let c_str = c_string.as_c_str();\n+    /// assert_eq!(c_str, CStr::from_bytes_with_nul(b\"foo\\0\").unwrap());\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"as_c_str\", issue = \"40380\")]\n     pub fn as_c_str(&self) -> &CStr {\n@@ -421,6 +470,18 @@ impl CString {\n     /// Converts this `CString` into a boxed [`CStr`].\n     ///\n     /// [`CStr`]: struct.CStr.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(into_boxed_c_str)]\n+    ///\n+    /// use std::ffi::{CString, CStr};\n+    ///\n+    /// let c_string = CString::new(b\"foo\".to_vec()).unwrap();\n+    /// let boxed = c_string.into_boxed_c_str();\n+    /// assert_eq!(&*boxed, CStr::from_bytes_with_nul(b\"foo\\0\").unwrap());\n+    /// ```\n     #[unstable(feature = \"into_boxed_c_str\", issue = \"40380\")]\n     pub fn into_boxed_c_str(self) -> Box<CStr> {\n         unsafe { mem::transmute(self.into_inner()) }\n@@ -708,6 +769,24 @@ impl CStr {\n     /// let cstr = CStr::from_bytes_with_nul(b\"hello\\0\");\n     /// assert!(cstr.is_ok());\n     /// ```\n+    ///\n+    /// Creating a `CStr` without a trailing nul byte is an error:\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let c_str = CStr::from_bytes_with_nul(b\"hello\");\n+    /// assert!(c_str.is_err());\n+    /// ```\n+    ///\n+    /// Creating a `CStr` with an interior nul byte is an error:\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let c_str = CStr::from_bytes_with_nul(b\"he\\0llo\\0\");\n+    /// assert!(c_str.is_err());\n+    /// ```\n     #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n     pub fn from_bytes_with_nul(bytes: &[u8])\n                                -> Result<&CStr, FromBytesWithNulError> {\n@@ -800,6 +879,15 @@ impl CStr {\n     /// > **Note**: This method is currently implemented as a 0-cost cast, but\n     /// > it is planned to alter its definition in the future to perform the\n     /// > length calculation whenever this method is called.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").unwrap();\n+    /// assert_eq!(c_str.to_bytes(), b\"foo\");\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_bytes(&self) -> &[u8] {\n@@ -817,6 +905,15 @@ impl CStr {\n     /// > length calculation whenever this method is called.\n     ///\n     /// [`to_bytes`]: #method.to_bytes\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").unwrap();\n+    /// assert_eq!(c_str.to_bytes_with_nul(), b\"foo\\0\");\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_bytes_with_nul(&self) -> &[u8] {\n@@ -834,6 +931,15 @@ impl CStr {\n     /// > check whenever this method is called.\n     ///\n     /// [`&str`]: ../primitive.str.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let c_str = CStr::from_bytes_with_nul(b\"foo\\0\").unwrap();\n+    /// assert_eq!(c_str.to_str(), Ok(\"foo\"));\n+    /// ```\n     #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n     pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n         // NB: When CStr is changed to perform the length check in .to_bytes()\n@@ -857,6 +963,31 @@ impl CStr {\n     ///\n     /// [`Cow`]: ../borrow/enum.Cow.html\n     /// [`str`]: ../primitive.str.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Calling `to_string_lossy` on a `CStr` containing valid UTF-8:\n+    ///\n+    /// ```\n+    /// use std::borrow::Cow;\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let c_str = CStr::from_bytes_with_nul(b\"Hello World\\0\").unwrap();\n+    /// assert_eq!(c_str.to_string_lossy(), Cow::Borrowed(\"Hello World\"));\n+    /// ```\n+    ///\n+    /// Calling `to_string_lossy` on a `CStr` containing invalid UTF-8:\n+    ///\n+    /// ```\n+    /// use std::borrow::Cow;\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let c_str = CStr::from_bytes_with_nul(b\"Hello \\xF0\\x90\\x80World\\0\").unwrap();\n+    /// assert_eq!(\n+    ///     c_str.to_string_lossy(),\n+    ///     Cow::Owned(String::from(\"Hello \ufffdWorld\")) as Cow<str>\n+    /// );\n+    /// ```\n     #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n     pub fn to_string_lossy(&self) -> Cow<str> {\n         String::from_utf8_lossy(self.to_bytes())\n@@ -866,6 +997,18 @@ impl CStr {\n     ///\n     /// [`Box`]: ../boxed/struct.Box.html\n     /// [`CString`]: struct.CString.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(into_boxed_c_str)]\n+    ///\n+    /// use std::ffi::CString;\n+    ///\n+    /// let c_string = CString::new(b\"foo\".to_vec()).unwrap();\n+    /// let boxed = c_string.into_boxed_c_str();\n+    /// assert_eq!(boxed.into_c_string(), CString::new(\"foo\").unwrap());\n+    /// ```\n     #[unstable(feature = \"into_boxed_c_str\", issue = \"40380\")]\n     pub fn into_c_string(self: Box<CStr>) -> CString {\n         unsafe { mem::transmute(self) }"}, {"sha": "bafe23e80a030cfb3758eb43ad213b6473f31a97", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/445077963c55297ef1e196a3525723090fe80b22/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445077963c55297ef1e196a3525723090fe80b22/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=445077963c55297ef1e196a3525723090fe80b22", "patch": "@@ -254,6 +254,7 @@\n #![feature(cfg_target_thread_local)]\n #![feature(cfg_target_vendor)]\n #![feature(char_escape_debug)]\n+#![feature(char_error_internals)]\n #![feature(char_internals)]\n #![feature(collections_range)]\n #![feature(compiler_builtins_lib)]"}, {"sha": "d4d8993efb3160e3b0e69dd2ce6f5d327e6e5739", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/445077963c55297ef1e196a3525723090fe80b22/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445077963c55297ef1e196a3525723090fe80b22/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=445077963c55297ef1e196a3525723090fe80b22", "patch": "@@ -38,6 +38,8 @@ use tables::{conversions, derived_property, general_category, property};\n pub use core::char::{MAX, from_digit, from_u32, from_u32_unchecked};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::char::{EscapeDebug, EscapeDefault, EscapeUnicode};\n+#[stable(feature = \"char_from_str\", since = \"1.19.0\")]\n+pub use core::char::ParseCharError;\n \n // unstable reexports\n #[unstable(feature = \"try_from\", issue = \"33417\")]"}, {"sha": "0c6c7fc5a0d75bacafd543201c0deaeddbc23694", "filename": "src/test/compile-fail/unused-result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/445077963c55297ef1e196a3525723090fe80b22/src%2Ftest%2Fcompile-fail%2Funused-result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/445077963c55297ef1e196a3525723090fe80b22/src%2Ftest%2Fcompile-fail%2Funused-result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-result.rs?ref=445077963c55297ef1e196a3525723090fe80b22", "patch": "@@ -26,8 +26,8 @@ fn qux() -> MustUseMsg { return foo::<MustUseMsg>(); }\n #[allow(unused_results)]\n fn test() {\n     foo::<isize>();\n-    foo::<MustUse>(); //~ ERROR: unused result which must be used\n-    foo::<MustUseMsg>(); //~ ERROR: unused result which must be used: some message\n+    foo::<MustUse>(); //~ ERROR: unused `MustUse` which must be used\n+    foo::<MustUseMsg>(); //~ ERROR: unused `MustUseMsg` which must be used: some message\n }\n \n #[allow(unused_results, unused_must_use)]\n@@ -39,8 +39,8 @@ fn test2() {\n \n fn main() {\n     foo::<isize>(); //~ ERROR: unused result\n-    foo::<MustUse>(); //~ ERROR: unused result which must be used\n-    foo::<MustUseMsg>(); //~ ERROR: unused result which must be used: some message\n+    foo::<MustUse>(); //~ ERROR: unused `MustUse` which must be used\n+    foo::<MustUseMsg>(); //~ ERROR: unused `MustUseMsg` which must be used: some message\n \n     let _ = foo::<isize>();\n     let _ = foo::<MustUse>();"}]}