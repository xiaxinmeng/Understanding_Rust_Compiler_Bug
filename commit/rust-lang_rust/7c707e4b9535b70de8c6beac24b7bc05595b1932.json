{"sha": "7c707e4b9535b70de8c6beac24b7bc05595b1932", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNzA3ZTRiOTUzNWI3MGRlOGM2YmVhYzI0YjdiYzA1NTk1YjE5MzI=", "commit": {"author": {"name": "Commeownist", "email": "commeownist@yandex.ru", "date": "2021-09-05T15:26:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-05T15:26:01Z"}, "message": "Implement basic inline asm support (#72)\n\n* Implement basic support for inline assembly\r\n\r\n* Disable LTO\r\n\r\nWe don't support it yet at all\r\n\r\n* Handle `inout(reg) var` correctly\r\n\r\nTurns out that `+` readwrite output registers cannot be tied with\r\ninput variables.\r\n\r\n* Add limited support for llvm_asm!\r\n\r\n* Handle CHANNEL correctly\r\n\r\n* Add support for arbitrary explicit registers\r\n\r\n* Handle symbols properly\r\n\r\n* Add rudimentary asm tests\r\n\r\n* Exclude llvm_asm! tests from tests runs\r\n\r\n* Insert `__builtin_unreachable()` after diverging asm blocks", "tree": {"sha": "51fb2d99478e1a49545fbb5a2da78b0e8edfde02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51fb2d99478e1a49545fbb5a2da78b0e8edfde02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c707e4b9535b70de8c6beac24b7bc05595b1932", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhNOGJCRBK7hj4Ov3rIwAAmnoIAAGYGbpdS9g8OONTyfb8TCDm\nH3Jjh+19pllw/ecS2kpAm/8A2aep6xgnBuMmKkocPBbYaECYONuHMuJyWjgNnwdq\nvixKm+n0BmHxsF9dkoXOHQdgCvOq1I4Gu2CmQT5pn09t6sh8CAzKjPGJYzWijeW+\nAHAEF/alvzY61w1hlJQOKjVOtg/LVWMMhwqHChuPM7KxYPqHEYCSQNa39kdB6jvt\nvqd95H+UOWjVrJbudOfZQmHZ6n/Qyux/U+UMllfm7TcThsDi9fGQgWoyNmwoWuG5\nqJkMdylOPDcENZmHZhkr+HerxCePVPWxGxaZ/oNoRZRV1Wbi7CeRLqPaLI7BIck=\n=rCNU\n-----END PGP SIGNATURE-----\n", "payload": "tree 51fb2d99478e1a49545fbb5a2da78b0e8edfde02\nparent 5dad13cc3bfbf69f470198860ea905d72fc9fbd3\nauthor Commeownist <commeownist@yandex.ru> 1630855561 +0300\ncommitter GitHub <noreply@github.com> 1630855561 -0400\n\nImplement basic inline asm support (#72)\n\n* Implement basic support for inline assembly\r\n\r\n* Disable LTO\r\n\r\nWe don't support it yet at all\r\n\r\n* Handle `inout(reg) var` correctly\r\n\r\nTurns out that `+` readwrite output registers cannot be tied with\r\ninput variables.\r\n\r\n* Add limited support for llvm_asm!\r\n\r\n* Handle CHANNEL correctly\r\n\r\n* Add support for arbitrary explicit registers\r\n\r\n* Handle symbols properly\r\n\r\n* Add rudimentary asm tests\r\n\r\n* Exclude llvm_asm! tests from tests runs\r\n\r\n* Insert `__builtin_unreachable()` after diverging asm blocks"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c707e4b9535b70de8c6beac24b7bc05595b1932", "html_url": "https://github.com/rust-lang/rust/commit/7c707e4b9535b70de8c6beac24b7bc05595b1932", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c707e4b9535b70de8c6beac24b7bc05595b1932/comments", "author": null, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dad13cc3bfbf69f470198860ea905d72fc9fbd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dad13cc3bfbf69f470198860ea905d72fc9fbd3", "html_url": "https://github.com/rust-lang/rust/commit/5dad13cc3bfbf69f470198860ea905d72fc9fbd3"}], "stats": {"total": 844, "additions": 631, "deletions": 213}, "files": [{"sha": "1e2f9e3aebb2cd83b6ae296b833efc75c3e10f92", "filename": ".gitignore", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c707e4b9535b70de8c6beac24b7bc05595b1932/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/7c707e4b9535b70de8c6beac24b7bc05595b1932/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=7c707e4b9535b70de8c6beac24b7bc05595b1932", "patch": "@@ -7,9 +7,11 @@ perf.data.old\n *.events\n *.string*\n /build_sysroot/sysroot\n+/build_sysroot/sysroot_src\n /build_sysroot/Cargo.lock\n /build_sysroot/test_target/Cargo.lock\n /rust\n+/simple-raytracer\n /regex\n gimple*\n *asm"}, {"sha": "f3e07fd08ee8e278975c98c59e3f0a03e4198d0d", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c707e4b9535b70de8c6beac24b7bc05595b1932/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7c707e4b9535b70de8c6beac24b7bc05595b1932/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7c707e4b9535b70de8c6beac24b7bc05595b1932", "patch": "@@ -56,15 +56,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#0572117c7ffdfcb0e6c6526d45266c3f34796bea\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#54be27e41fff7b6ab532e2e21a82df50a12b9ad3\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#0572117c7ffdfcb0e6c6526d45266c3f34796bea\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#54be27e41fff7b6ab532e2e21a82df50a12b9ad3\"\n dependencies = [\n  \"libc 0.1.12\",\n ]"}, {"sha": "17a0d2ab3f0601f92b56bccff8b7ba0adde227d5", "filename": "build.sh", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c707e4b9535b70de8c6beac24b7bc05595b1932/build.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7c707e4b9535b70de8c6beac24b7bc05595b1932/build.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.sh?ref=7c707e4b9535b70de8c6beac24b7bc05595b1932", "patch": "@@ -3,7 +3,12 @@\n #set -x\n set -e\n \n-export GCC_PATH=$(cat gcc_path)\n+if [ -f ./gcc_path ]; then \n+    export GCC_PATH=$(cat gcc_path)\n+else\n+    echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n+    exit 1\n+fi\n \n export LD_LIBRARY_PATH=\"$GCC_PATH\"\n export LIBRARY_PATH=\"$GCC_PATH\""}, {"sha": "1001c522052c800b15d170971d187b6987092288", "filename": "cargo.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c707e4b9535b70de8c6beac24b7bc05595b1932/cargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7c707e4b9535b70de8c6beac24b7bc05595b1932/cargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo.sh?ref=7c707e4b9535b70de8c6beac24b7bc05595b1932", "patch": "@@ -20,4 +20,4 @@ fi\n cmd=$1\n shift\n \n-RUSTDOCFLAGS=$RUSTFLAGS cargo +${TOOLCHAIN} $cmd --target $TARGET_TRIPLE $@\n+RUSTDOCFLAGS=\"$RUSTFLAGS\" cargo +${TOOLCHAIN} $cmd --target $TARGET_TRIPLE $@"}, {"sha": "98caeb7407e084fc585bd49733b3882a0b6ec104", "filename": "config.sh", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c707e4b9535b70de8c6beac24b7bc05595b1932/config.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7c707e4b9535b70de8c6beac24b7bc05595b1932/config.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.sh?ref=7c707e4b9535b70de8c6beac24b7bc05595b1932", "patch": "@@ -2,7 +2,12 @@ set -e\n \n export CARGO_INCREMENTAL=0\n \n-export GCC_PATH=$(cat gcc_path)\n+if [ -f ./gcc_path ]; then \n+    export GCC_PATH=$(cat gcc_path)\n+else\n+    echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n+    exit 1\n+fi\n \n unamestr=`uname`\n if [[ \"$unamestr\" == 'Linux' ]]; then\n@@ -30,7 +35,7 @@ if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n    fi\n fi\n \n-export RUSTFLAGS=$linker' -Cpanic=abort -Cdebuginfo=2 -Zpanic-abort-tests -Zcodegen-backend='$(pwd)'/target/'$CHANNEL'/librustc_codegen_gcc.'$dylib_ext' --sysroot '$(pwd)'/build_sysroot/sysroot'\n+export RUSTFLAGS=\"$linker -Cpanic=abort -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n \n # FIXME(antoyo): remove once the atomic shim is gone\n if [[ `uname` == 'Darwin' ]]; then"}, {"sha": "512b9f553f5e3fb7326da9e7e46be92f16296760", "filename": "src/asm.rs", "status": "modified", "additions": 519, "deletions": 205, "changes": 724, "blob_url": "https://github.com/rust-lang/rust/blob/7c707e4b9535b70de8c6beac24b7bc05595b1932/src%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c707e4b9535b70de8c6beac24b7bc05595b1932/src%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fasm.rs?ref=7c707e4b9535b70de8c6beac24b7bc05595b1932", "patch": "@@ -1,254 +1,558 @@\n-use gccjit::{RValue, ToRValue, Type};\n+use gccjit::{LValue, RValue, ToRValue, Type};\n use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_codegen_ssa::mir::operand::OperandValue;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{AsmBuilderMethods, AsmMethods, BaseTypeMethods, BuilderMethods, GlobalAsmOperandRef, InlineAsmOperandRef};\n-use rustc_data_structures::fx::FxHashMap;\n+\n use rustc_hir::LlvmInlineAsmInner;\n-use rustc_middle::bug;\n+use rustc_middle::{bug, ty::Instance};\n use rustc_span::Span;\n use rustc_target::asm::*;\n \n+use std::borrow::Cow;\n+\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n \n+\n+// Rust asm! and GCC Extended Asm semantics differ substantially.\n+//\n+// 1. Rust asm operands go along as one list of operands. Operands themselves indicate \n+//    if they're \"in\" or \"out\". \"In\" and \"out\" operands can interleave. One operand can be \n+//    both \"in\" and \"out\" (`inout(reg)`).\n+//\n+//    GCC asm has two different lists for \"in\" and \"out\" operands. In terms of gccjit, \n+//    this means that all \"out\" operands must go before \"in\" operands. \"In\" and \"out\" operands \n+//    cannot interleave.\n+//\n+// 2. Operand lists in both Rust and GCC are indexed. Index starts from 0. Indexes are important \n+//    because the asm template refers to operands by index.\n+//\n+//    Mapping from Rust to GCC index would be 1-1 if it wasn't for...\n+//\n+// 3. Clobbers. GCC has a separate list of clobbers, and clobbers don't have indexes. \n+//    Contrary, Rust expresses clobbers through \"out\" operands that aren't tied to \n+//    a variable (`_`),  and such \"clobbers\" do have index.\n+//\n+// 4. Furthermore, GCC Extended Asm does not support explicit register constraints \n+//    (like `out(\"eax\")`) directly, offering so-called \"local register variables\" \n+//    as a workaround. These variables need to be declared and initialized *before* \n+//    the Extended Asm block but *after* normal local variables \n+//    (see comment in `codegen_inline_asm` for explanation).\n+//\n+// With that in mind, let's see how we translate Rust syntax to GCC \n+// (from now on, `CC` stands for \"constraint code\"):\n+//\n+// * `out(reg_class) var`   -> translated to output operand: `\"=CC\"(var)`\n+// * `inout(reg_class) var` -> translated to output operand: `\"+CC\"(var)`\n+// * `in(reg_class) var`    -> translated to input operand: `\"CC\"(var)`\n+//\n+// * `out(reg_class) _` -> translated to one `=r(tmp)`, where \"tmp\" is a temporary unused variable\n+//\n+// * `out(\"explicit register\") _` -> not translated to any operands, register is simply added to clobbers list\n+//\n+// * `inout(reg_class) in_var => out_var` -> translated to two operands: \n+//                              output: `\"=CC\"(in_var)`\n+//                              input:  `\"num\"(out_var)` where num is the GCC index \n+//                                       of the corresponding output operand\n+//\n+// * `inout(reg_class) in_var => _` -> same as `inout(reg_class) in_var => tmp`, \n+//                                      where \"tmp\" is a temporary unused variable\n+//\n+// * `out/in/inout(\"explicit register\") var` -> translated to one or two operands as described above \n+//                                              with `\"r\"(var)` constraint, \n+//                                              and one register variable assigned to the desired register.\n+// \n+\n+const ATT_SYNTAX_INS: &str = \".att_syntax noprefix\\n\\t\";\n+const INTEL_SYNTAX_INS: &str = \"\\n\\t.intel_syntax noprefix\";\n+\n+\n+struct AsmOutOperand<'a, 'tcx, 'gcc> {\n+    rust_idx: usize,\n+    constraint: &'a str,\n+    late: bool,\n+    readwrite: bool,\n+\n+    tmp_var: LValue<'gcc>,\n+    out_place: Option<PlaceRef<'tcx, RValue<'gcc>>>\n+}\n+\n+struct AsmInOperand<'a, 'tcx> {\n+    rust_idx: usize,\n+    constraint: Cow<'a, str>,\n+    val: RValue<'tcx>\n+}\n+\n+impl AsmOutOperand<'_, '_, '_> {\n+    fn to_constraint(&self) -> String {\n+        let mut res = String::with_capacity(self.constraint.len() + self.late as usize + 1);\n+\n+        let sign = if self.readwrite { '+' } else { '=' };\n+        res.push(sign);\n+        if !self.late {\n+            res.push('&');\n+        }\n+\n+        res.push_str(&self.constraint);\n+        res\n+    }\n+}\n+\n+enum ConstraintOrRegister {\n+    Constraint(&'static str),\n+    Register(&'static str)\n+}\n+\n+\n impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn codegen_llvm_inline_asm(&mut self, _ia: &LlvmInlineAsmInner, _outputs: Vec<PlaceRef<'tcx, RValue<'gcc>>>, mut _inputs: Vec<RValue<'gcc>>, _span: Span) -> bool {\n-        // TODO(antoyo)\n-        return true;\n+    fn codegen_llvm_inline_asm(&mut self, ia: &LlvmInlineAsmInner, outputs: Vec<PlaceRef<'tcx, RValue<'gcc>>>, inputs: Vec<RValue<'gcc>>, span: Span) -> bool {\n+        if ia.asm.as_str().is_empty() && outputs.is_empty() {\n+            // TODO(@Commeownist): there's one use of `llvm_asm` in rustc sysroot we can't get rid of just yet.\n+            // Fortunately, it's used as a simple black box to make sure that inputs are not optimized away.\n+            // Let's just emulate it.\n+            let block = self.llbb();\n+            let extended_asm = block.add_extended_asm(None, \"\");\n+            for input in inputs {\n+                extended_asm.add_input_operand(None, \"r\", input);\n+            }\n+            extended_asm.add_clobber(\"memory\");\n+            extended_asm.set_volatile_flag(true);\n+        } \n+        else {\n+            // TODO(@Commeownist): switch to `struct_span_err_with_code` \n+            // once we get this merged into rustc\n+            self.sess().struct_span_err(span, \"GCC backend does not support `llvm_asm!`\")\n+                .help(\"consider using the `asm!` macro instead\")\n+                .emit();\n+        }\n+\n+        // We return `true` even if we've failed to generate the asm\n+        // because we want to suppress the \"malformed inline assembly\" error\n+        // generated by the frontend.\n+        true\n     }\n \n-    fn codegen_inline_asm(&mut self, template: &[InlineAsmTemplatePiece], operands: &[InlineAsmOperandRef<'tcx, Self>], options: InlineAsmOptions, _span: &[Span]) {\n+    fn codegen_inline_asm(&mut self, template: &[InlineAsmTemplatePiece], rust_operands: &[InlineAsmOperandRef<'tcx, Self>], options: InlineAsmOptions, _span: &[Span]) {\n         let asm_arch = self.tcx.sess.asm_arch.unwrap();\n+        let is_x86 = matches!(asm_arch, InlineAsmArch::X86 | InlineAsmArch::X86_64);\n+        let att_dialect = is_x86 && options.contains(InlineAsmOptions::ATT_SYNTAX);\n+        let intel_dialect = is_x86 && !options.contains(InlineAsmOptions::ATT_SYNTAX);\n \n-        let intel_dialect =\n-            match asm_arch {\n-                InlineAsmArch::X86 | InlineAsmArch::X86_64 if !options.contains(InlineAsmOptions::ATT_SYNTAX) => true,\n-                _ => false,\n-            };\n+        // GCC index of an output operand equals its position in the array \n+        let mut outputs = vec![];\n+\n+        // GCC index of an input operand equals its position in the array\n+        // added to `outputs.len()`\n+        let mut inputs = vec![];\n \n-        // Collect the types of output operands\n-        // FIXME(antoyo): we do this here instead of later because of a bug in libgccjit where creating the\n-        // variable after the extended asm expression causes a segfault:\n-        // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=100380\n-        let mut output_vars = FxHashMap::default();\n-        let mut operand_numbers = FxHashMap::default();\n-        let mut current_number = 0;\n-        for (idx, op) in operands.iter().enumerate() {\n+        // Clobbers collected from `out(\"explicit register\") _` and `inout(\"expl_reg\") var => _`\n+        let mut clobbers = vec![];\n+\n+        // We're trying to preallocate space for the template\n+        let mut constants_len = 0;\n+\n+        // There are rules we must adhere to if we want GCC to do the right thing:\n+        // \n+        // * Every local variable that the asm block uses as an output must be declared *before*\n+        //   the asm block. \n+        // * There must be no instructions whatsoever between the register variables and the asm.\n+        //\n+        // Therefore, the backend must generate the instructions strictly in this order:\n+        //\n+        // 1. Output variables.\n+        // 2. Register variables.\n+        // 3. The asm block.\n+        //\n+        // We also must make sure that no input operands are emitted before output operands.\n+        //\n+        // This is why we work in passes, first emitting local vars, then local register vars.\n+        // Also, we don't emit any asm operands immediately; we save them to \n+        // the one of the buffers to be emitted later.\n+\n+        // 1. Normal variables (and saving operands to buffers).\n+        for (rust_idx, op) in rust_operands.iter().enumerate() {\n             match *op {\n-                InlineAsmOperandRef::Out { place, .. } => {\n-                    let ty =\n-                        match place {\n-                            Some(place) => place.layout.gcc_type(self.cx, false),\n-                            None => {\n-                                // If the output is discarded, we don't really care what\n-                                // type is used. We're just using this to tell GCC to\n-                                // reserve the register.\n-                                //dummy_output_type(self.cx, reg.reg_class())\n-\n-                                // NOTE: if no output value, we should not create one (it will be a\n-                                // clobber).\n-                                continue;\n-                            },\n-                        };\n-                    let var = self.current_func().new_local(None, ty, \"output_register\");\n-                    operand_numbers.insert(idx, current_number);\n-                    current_number += 1;\n-                    output_vars.insert(idx, var);\n+                InlineAsmOperandRef::Out { reg, late, place } => {\n+                    use ConstraintOrRegister::*;\n+\n+                    let (constraint, ty) = match (reg_to_gcc(reg), place) {\n+                        (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx, false)),\n+                        // When `reg` is a class and not an explicit register but the out place is not specified,\n+                        // we need to create an unused output variable to assign the output to. This var\n+                        // needs to be of a type that's \"compatible\" with the register class, but specific type \n+                        // doesn't matter.\n+                        (Constraint(constraint), None) => (constraint, dummy_output_type(self.cx, reg.reg_class())),\n+                        (Register(_), Some(_)) => {\n+                            // left for the next pass\n+                            continue\n+                        },\n+                        (Register(reg_name), None) => {\n+                            clobbers.push(reg_name);\n+                            continue\n+                        }\n+                    };\n+\n+                    let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n+                    outputs.push(AsmOutOperand {\n+                        constraint, \n+                        rust_idx,\n+                        late,\n+                        readwrite: false,\n+                        tmp_var,\n+                        out_place: place\n+                    });\n                 }\n-                InlineAsmOperandRef::InOut { out_place, .. } => {\n-                    let ty =\n-                        match out_place {\n-                            Some(place) => place.layout.gcc_type(self.cx, false),\n-                            None => {\n-                                // NOTE: if no output value, we should not create one.\n-                                continue;\n-                            },\n-                        };\n-                    operand_numbers.insert(idx, current_number);\n-                    current_number += 1;\n-                    let var = self.current_func().new_local(None, ty, \"output_register\");\n-                    output_vars.insert(idx, var);\n+\n+                InlineAsmOperandRef::In { reg, value } => {\n+                    if let ConstraintOrRegister::Constraint(constraint) = reg_to_gcc(reg) {\n+                        inputs.push(AsmInOperand { \n+                            constraint: Cow::Borrowed(constraint), \n+                            rust_idx, \n+                            val: value.immediate()\n+                        });\n+                    } \n+                    else {\n+                        // left for the next pass\n+                        continue\n+                    }\n+                }\n+\n+                InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n+                    let constraint = if let ConstraintOrRegister::Constraint(constraint) = reg_to_gcc(reg) {\n+                        constraint\n+                    } \n+                    else {\n+                        // left for the next pass\n+                        continue\n+                    };\n+\n+                    // Rustc frontend guarantees that input and output types are \"compatible\",\n+                    // so we can just use input var's type for the output variable.\n+                    //\n+                    // This decision is also backed by the fact that LLVM needs in and out \n+                    // values to be of *exactly the same type*, not just \"compatible\". \n+                    // I'm not sure if GCC is so picky too, but better safe than sorry.\n+                    let ty = in_value.layout.gcc_type(self.cx, false);\n+                    let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n+\n+                    // If the out_place is None (i.e `inout(reg) _` syntax was used), we translate\n+                    // it to one \"readwrite (+) output variable\", otherwise we translate it to two \n+                    // \"out and tied in\" vars as described above.\n+                    let readwrite = out_place.is_none();\n+                    outputs.push(AsmOutOperand {\n+                        constraint, \n+                        rust_idx,\n+                        late,\n+                        readwrite,\n+                        tmp_var, \n+                        out_place,\n+                    });\n+\n+                    if !readwrite {\n+                        let out_gcc_idx = outputs.len() - 1;\n+                        let constraint = Cow::Owned(out_gcc_idx.to_string());\n+\n+                        inputs.push(AsmInOperand {\n+                            constraint, \n+                            rust_idx, \n+                            val: in_value.immediate()\n+                        });\n+                    }\n+                }\n+\n+                InlineAsmOperandRef::Const { ref string } => {\n+                    constants_len += string.len() + att_dialect as usize;\n+                }\n+\n+                InlineAsmOperandRef::SymFn { instance } => {\n+                    constants_len += self.tcx.symbol_name(instance).name.len();\n+                }\n+                InlineAsmOperandRef::SymStatic { def_id } => {\n+                    constants_len += self.tcx.symbol_name(Instance::mono(self.tcx, def_id)).name.len();\n                 }\n-                _ => {}\n             }\n         }\n \n-        // All output operands must come before the input operands, hence the 2 loops.\n-        for (idx, op) in operands.iter().enumerate() {\n+        // 2. Register variables.\n+        for (rust_idx, op) in rust_operands.iter().enumerate() {\n             match *op {\n-                InlineAsmOperandRef::In { .. } | InlineAsmOperandRef::InOut { .. } => {\n-                    operand_numbers.insert(idx, current_number);\n-                    current_number += 1;\n-                },\n-                _ => (),\n+                // `out(\"explicit register\") var`\n+                InlineAsmOperandRef::Out { reg, late, place } => {\n+                    if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n+                        let out_place = if let Some(place) = place {\n+                            place\n+                        } \n+                        else {\n+                            // processed in the previous pass\n+                            continue\n+                        };\n+\n+                        let ty = out_place.layout.gcc_type(self.cx, false);\n+                        let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n+                        tmp_var.set_register_name(reg_name);\n+\n+                        outputs.push(AsmOutOperand {\n+                            constraint: \"r\".into(), \n+                            rust_idx,\n+                            late,\n+                            readwrite: false,\n+                            tmp_var,\n+                            out_place: Some(out_place)\n+                        });\n+                    }\n+\n+                    // processed in the previous pass\n+                }\n+\n+                // `in(\"explicit register\") var`\n+                InlineAsmOperandRef::In { reg, value } => {\n+                    if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n+                        let ty = value.layout.gcc_type(self.cx, false);\n+                        let reg_var = self.current_func().new_local(None, ty, \"input_register\");\n+                        reg_var.set_register_name(reg_name);\n+                        self.llbb().add_assignment(None, reg_var, value.immediate());\n+\n+                        inputs.push(AsmInOperand { \n+                            constraint: \"r\".into(), \n+                            rust_idx, \n+                            val: reg_var.to_rvalue()\n+                        });\n+                    }\n+\n+                    // processed in the previous pass\n+                }\n+\n+                // `inout(\"explicit register\") in_var => out_var`\n+                InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n+                    if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n+                        let out_place = if let Some(place) = out_place {\n+                            place\n+                        } \n+                        else {\n+                            // processed in the previous pass\n+                            continue\n+                        };\n+\n+                        // See explanation in the first pass.\n+                        let ty = in_value.layout.gcc_type(self.cx, false);\n+                        let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n+                        tmp_var.set_register_name(reg_name);\n+\n+                        outputs.push(AsmOutOperand {\n+                            constraint: \"r\".into(), \n+                            rust_idx,\n+                            late,\n+                            readwrite: false,\n+                            tmp_var,\n+                            out_place: Some(out_place)\n+                        });\n+\n+                        let constraint = Cow::Owned((outputs.len() - 1).to_string());\n+                        inputs.push(AsmInOperand { \n+                            constraint, \n+                            rust_idx,\n+                            val: in_value.immediate()\n+                        });\n+                    }\n+\n+                    // processed in the previous pass\n+                }\n+\n+                InlineAsmOperandRef::Const { .. } \n+                | InlineAsmOperandRef::SymFn { .. } \n+                | InlineAsmOperandRef::SymStatic { .. } => {\n+                    // processed in the previous pass\n+                }\n             }\n         }\n \n-        // Build the template string\n-        let mut template_str = String::new();\n+        // 3. Build the template string\n+\n+        let mut template_str = String::with_capacity(estimate_template_length(template, constants_len, att_dialect));\n+        if !intel_dialect {\n+            template_str.push_str(ATT_SYNTAX_INS);\n+        }\n+\n         for piece in template {\n             match *piece {\n                 InlineAsmTemplatePiece::String(ref string) => {\n-                    if string.contains('%') {\n-                        for c in string.chars() {\n-                            if c == '%' {\n-                                template_str.push_str(\"%%\");\n-                            }\n-                            else {\n-                                template_str.push(c);\n-                            }\n-                        }\n+                    // TODO(@Commeownist): switch to `Iterator::intersperse` once it's stable\n+                    let mut iter = string.split('%');\n+                    if let Some(s) = iter.next() {\n+                        template_str.push_str(s);\n                     }\n-                    else {\n-                        template_str.push_str(string)\n+\n+                    for s in iter {\n+                        template_str.push_str(\"%%\");\n+                        template_str.push_str(s);\n                     }\n                 }\n                 InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span: _ } => {\n-                    match operands[operand_idx] {\n-                        InlineAsmOperandRef::Out { reg, place: Some(_), ..  } => {\n+                    let mut push_to_template = |modifier, gcc_idx| {\n+                        use std::fmt::Write;\n+\n+                        template_str.push('%');\n+                        if let Some(modifier) = modifier {\n+                            template_str.push(modifier);\n+                        }\n+                        write!(template_str, \"{}\", gcc_idx).expect(\"pushing to string failed\");\n+                    };\n+\n+                    match rust_operands[operand_idx] {\n+                        InlineAsmOperandRef::Out { reg, ..  } => {\n                             let modifier = modifier_to_gcc(asm_arch, reg.reg_class(), modifier);\n-                            if let Some(modifier) = modifier {\n-                                template_str.push_str(&format!(\"%{}{}\", modifier, operand_numbers[&operand_idx]));\n-                            } else {\n-                                template_str.push_str(&format!(\"%{}\", operand_numbers[&operand_idx]));\n-                            }\n-                        },\n-                        InlineAsmOperandRef::Out { place: None, .. } => {\n-                            unimplemented!(\"Out None\");\n-                        },\n-                        InlineAsmOperandRef::In { reg, .. }\n-                        | InlineAsmOperandRef::InOut { reg, .. } => {\n+                            let gcc_index = outputs.iter()\n+                                .position(|op| operand_idx == op.rust_idx)\n+                                .expect(\"wrong rust index\");\n+                            push_to_template(modifier, gcc_index);\n+                        }\n+\n+                        InlineAsmOperandRef::In { reg, .. } => {\n                             let modifier = modifier_to_gcc(asm_arch, reg.reg_class(), modifier);\n-                            if let Some(modifier) = modifier {\n-                                template_str.push_str(&format!(\"%{}{}\", modifier, operand_numbers[&operand_idx]));\n-                            } else {\n-                                template_str.push_str(&format!(\"%{}\", operand_numbers[&operand_idx]));\n-                            }\n+                            let in_gcc_index = inputs.iter()\n+                                .position(|op| operand_idx == op.rust_idx)\n+                                .expect(\"wrong rust index\");\n+                            let gcc_index = in_gcc_index + outputs.len();\n+                            push_to_template(modifier, gcc_index);\n+                        }\n+\n+                        InlineAsmOperandRef::InOut { reg, .. } => {\n+                            let modifier = modifier_to_gcc(asm_arch, reg.reg_class(), modifier);\n+\n+                            // The input register is tied to the output, so we can just use the index of the output register\n+                            let gcc_index = outputs.iter()\n+                                .position(|op| operand_idx == op.rust_idx)\n+                                .expect(\"wrong rust index\");\n+                            push_to_template(modifier, gcc_index);\n                         }\n+\n+                        InlineAsmOperandRef::SymFn { instance } => {\n+                            let name = self.tcx.symbol_name(instance).name;\n+                            template_str.push_str(name);\n+                        }\n+\n+                        InlineAsmOperandRef::SymStatic { def_id } => {\n+                            // TODO(@Commeownist): This may not be sufficient for all kinds of statics.\n+                            // Some statics may need the `@plt` suffix, like thread-local vars.\n+                            let instance = Instance::mono(self.tcx, def_id);\n+                            let name = self.tcx.symbol_name(instance).name;\n+                            template_str.push_str(name);\n+                        }\n+\n                         InlineAsmOperandRef::Const { ref string } => {\n                             // Const operands get injected directly into the template\n+                            if att_dialect {\n+                                template_str.push('$');\n+                            }\n                             template_str.push_str(string);\n                         }\n-                        InlineAsmOperandRef::SymFn { .. }\n-                        | InlineAsmOperandRef::SymStatic { .. } => {\n-                            unimplemented!();\n-                            // Only emit the raw symbol name\n-                            //template_str.push_str(&format!(\"${{{}:c}}\", op_idx[&operand_idx]));\n-                        }\n                     }\n                 }\n             }\n         }\n \n+        if !intel_dialect {\n+            template_str.push_str(INTEL_SYNTAX_INS);\n+        }\n+        \n+        // 4. Generate Extended Asm block\n+\n         let block = self.llbb();\n-        let template_str =\n-            if intel_dialect {\n-                template_str\n-            }\n-            else {\n-                // FIXME(antoyo): this might break the \"m\" memory constraint:\n-                // https://stackoverflow.com/a/9347957/389119\n-                // TODO(antoyo): only set on x86 platforms.\n-                format!(\".att_syntax noprefix\\n\\t{}\\n\\t.intel_syntax noprefix\", template_str)\n-            };\n         let extended_asm = block.add_extended_asm(None, &template_str);\n \n-        // Collect the types of output operands\n-        let mut output_types = vec![];\n-        for (idx, op) in operands.iter().enumerate() {\n-            match *op {\n-                InlineAsmOperandRef::Out { reg, late, place } => {\n-                    let ty =\n-                        match place {\n-                            Some(place) => place.layout.gcc_type(self.cx, false),\n-                            None => {\n-                                // If the output is discarded, we don't really care what\n-                                // type is used. We're just using this to tell GCC to\n-                                // reserve the register.\n-                                dummy_output_type(self.cx, reg.reg_class())\n-                            },\n-                        };\n-                    output_types.push(ty);\n-                    let prefix = if late { \"=\" } else { \"=&\" };\n-                    let constraint = format!(\"{}{}\", prefix, reg_to_gcc(reg));\n+        for op in &outputs {\n+            extended_asm.add_output_operand(None, &op.to_constraint(), op.tmp_var);\n+        }\n \n-                    if place.is_some() {\n-                        let var = output_vars[&idx];\n-                        extended_asm.add_output_operand(None, &constraint, var);\n-                    }\n-                    else {\n-                        // NOTE: reg.to_string() returns the register name with quotes around it so\n-                        // remove them.\n-                        extended_asm.add_clobber(reg.to_string().trim_matches('\"'));\n-                    }\n-                }\n-                InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n-                    let ty =\n-                        match out_place {\n-                            Some(out_place) => out_place.layout.gcc_type(self.cx, false),\n-                            None => dummy_output_type(self.cx, reg.reg_class())\n-                        };\n-                    output_types.push(ty);\n-                    // TODO(antoyo): prefix of \"+\" for reading and writing?\n-                    let prefix = if late { \"=\" } else { \"=&\" };\n-                    let constraint = format!(\"{}{}\", prefix, reg_to_gcc(reg));\n-\n-                    if out_place.is_some() {\n-                        let var = output_vars[&idx];\n-                        // TODO(antoyo): also specify an output operand when out_place is none: that would\n-                        // be the clobber but clobbers do not support general constraint like reg;\n-                        // they only support named registers.\n-                        // Not sure how we can do this. And the LLVM backend does not seem to add a\n-                        // clobber.\n-                        extended_asm.add_output_operand(None, &constraint, var);\n-                    }\n+        for op in &inputs {\n+            extended_asm.add_input_operand(None, &op.constraint, op.val);\n+        }\n \n-                    let constraint = reg_to_gcc(reg);\n-                    extended_asm.add_input_operand(None, &constraint, in_value.immediate());\n-                }\n-                InlineAsmOperandRef::In { reg, value } => {\n-                    let constraint = reg_to_gcc(reg);\n-                    extended_asm.add_input_operand(None, &constraint, value.immediate());\n-                }\n-                _ => {}\n+        for clobber in clobbers.iter() {\n+            extended_asm.add_clobber(clobber);\n+        }\n+\n+        if !options.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n+            // TODO(@Commeownist): I'm not 100% sure this one clobber is sufficient \n+            // on all architectures. For instance, what about FP stack?\n+            extended_asm.add_clobber(\"cc\");\n+        }\n+        if !options.contains(InlineAsmOptions::NOMEM) {\n+            extended_asm.add_clobber(\"memory\");\n+        }\n+        if !options.contains(InlineAsmOptions::PURE) {\n+            extended_asm.set_volatile_flag(true);\n+        }\n+        if !options.contains(InlineAsmOptions::NOSTACK) {\n+            // TODO(@Commeownist): figure out how to align stack\n+        }\n+        if options.contains(InlineAsmOptions::NORETURN) {\n+            let builtin_unreachable = self.context.get_builtin_function(\"__builtin_unreachable\");\n+            let builtin_unreachable: RValue<'gcc> = unsafe { std::mem::transmute(builtin_unreachable) };\n+            self.call(self.type_void(), builtin_unreachable, &[], None);\n+        }\n+\n+        // Write results to outputs. \n+        //\n+        // We need to do this because:\n+        //  1. Turning `PlaceRef` into `RValue` is error-prone and has nasty edge cases \n+        //     (especially with current `rustc_backend_ssa` API).\n+        //  2. Not every output operand has an `out_place`, and it's required by `add_output_operand`.\n+        //\n+        // Instead, we generate a temporary output variable for each output operand, and then this loop,\n+        // generates `out_place = tmp_var;` assignments if out_place exists.\n+        for op in &outputs {\n+            if let Some(place) = op.out_place {\n+                OperandValue::Immediate(op.tmp_var.to_rvalue()).store(self, place);                \n             }\n         }\n \n-        // Write results to outputs\n-        for (idx, op) in operands.iter().enumerate() {\n-            if let InlineAsmOperandRef::Out { place: Some(place), .. }\n-            | InlineAsmOperandRef::InOut { out_place: Some(place), .. } = *op\n-            {\n-                OperandValue::Immediate(output_vars[&idx].to_rvalue()).store(self, place);\n+    }\n+}\n+\n+fn estimate_template_length(template: &[InlineAsmTemplatePiece], constants_len: usize, att_dialect: bool) -> usize {\n+    let len: usize = template.iter().map(|piece| {\n+        match *piece {\n+            InlineAsmTemplatePiece::String(ref string) => {\n+                string.len()\n+            }\n+            InlineAsmTemplatePiece::Placeholder { .. } => {\n+                // '%' + 1 char modifier + 1 char index\n+                3\n             }\n         }\n+    })\n+    .sum();\n+\n+    // increase it by 5% to account for possible '%' signs that'll be duplicated\n+    // I pulled the number out of blue, but should be fair enough\n+    // as the upper bound\n+    let mut res = (len as f32 * 1.05) as usize + constants_len;\n+\n+    if att_dialect {\n+        res += INTEL_SYNTAX_INS.len() + ATT_SYNTAX_INS.len();\n     }\n+    res\n }\n \n /// Converts a register class to a GCC constraint code.\n-// TODO(antoyo): return &'static str instead?\n-fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> String {\n-    match reg {\n+fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n+    let constraint = match reg {\n         // For vector registers LLVM wants the register name to match the type size.\n         InlineAsmRegOrRegClass::Reg(reg) => {\n             // TODO(antoyo): add support for vector register.\n-            let constraint =\n-                match reg.name() {\n-                    \"ax\" => \"a\",\n-                    \"bx\" => \"b\",\n-                    \"cx\" => \"c\",\n-                    \"dx\" => \"d\",\n-                    \"si\" => \"S\",\n-                    \"di\" => \"D\",\n-                    // TODO(antoyo): for registers like r11, we have to create a register variable: https://stackoverflow.com/a/31774784/389119\n-                    // TODO(antoyo): in this case though, it's a clobber, so it should work as r11.\n-                    // Recent nightly supports clobber() syntax, so update to it. It does not seem\n-                    // like it's implemented yet.\n-                    name => name, // FIXME(antoyo): probably wrong.\n-                };\n-            constraint.to_string()\n+            match reg.name() {\n+                \"ax\" => \"a\",\n+                \"bx\" => \"b\",\n+                \"cx\" => \"c\",\n+                \"dx\" => \"d\",\n+                \"si\" => \"S\",\n+                \"di\" => \"D\",\n+                // For registers like r11, we have to create a register variable: https://stackoverflow.com/a/31774784/389119\n+                name => return ConstraintOrRegister::Register(name), \n+            }\n         },\n         InlineAsmRegOrRegClass::RegClass(reg) => match reg {\n             InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => unimplemented!(),\n@@ -278,23 +582,25 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> String {\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => unimplemented!(),\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => unimplemented!(),\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => unimplemented!(),\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::mmx_reg) => unimplemented!(),\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg) => \"r\",\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => unimplemented!(),\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => unimplemented!(),\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => \"Q\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => \"q\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n-            | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => unimplemented!(),\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg) => unimplemented!(),\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => unimplemented!(),\n+            | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => unimplemented!(),\n             InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n+            InlineAsmRegClass::X86(\n+                X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg,\n+            ) => unreachable!(\"clobber-only\"),\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"GCC backend does not support SPIR-V\")\n             }\n             InlineAsmRegClass::Err => unreachable!(),\n         }\n-        .to_string(),\n-    }\n+    };\n+\n+    ConstraintOrRegister::Constraint(constraint)\n }\n \n /// Type to use for outputs that are discarded. It doesn't really matter what\n@@ -379,7 +685,7 @@ impl<'gcc, 'tcx> AsmMethods for CodegenCx<'gcc, 'tcx> {\n                     match operands[operand_idx] {\n                         GlobalAsmOperandRef::Const { ref string } => {\n                             // Const operands get injected directly into the\n-                            // template. Note that we don't need to escape $\n+                            // template. Note that we don't need to escape %\n                             // here unlike normal inline assembly.\n                             template_str.push_str(string);\n                         }\n@@ -431,22 +737,30 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => unimplemented!(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => match modifier {\n-            None if arch == InlineAsmArch::X86_64 => Some('q'),\n-            None => Some('k'),\n+            None => if arch == InlineAsmArch::X86_64 { Some('q') } else { Some('k') },\n             Some('l') => Some('b'),\n             Some('h') => Some('h'),\n             Some('x') => Some('w'),\n             Some('e') => Some('k'),\n             Some('r') => Some('q'),\n             _ => unreachable!(),\n         },\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::mmx_reg) => unimplemented!(),\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => unimplemented!(),\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n-        | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg)\n-        | InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => unimplemented!(),\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg) => unimplemented!(),\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => unimplemented!(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => None,\n+        InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::xmm_reg)\n+        | InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::ymm_reg)\n+        | InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::zmm_reg) => match (reg, modifier) {\n+            (X86InlineAsmRegClass::xmm_reg, None) => Some('x'),\n+            (X86InlineAsmRegClass::ymm_reg, None) => Some('t'),\n+            (X86InlineAsmRegClass::zmm_reg, None) => Some('g'),\n+            (_, Some('x')) => Some('x'),\n+            (_, Some('y')) => Some('t'),\n+            (_, Some('z')) => Some('g'),\n+            _ => unreachable!(),\n+        },\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg) => {\n+            unreachable!(\"clobber-only\")\n+        }\n         InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")"}, {"sha": "114db7d53f5bb3aa05d53009c224aef18f97301a", "filename": "test.sh", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c707e4b9535b70de8c6beac24b7bc05595b1932/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7c707e4b9535b70de8c6beac24b7bc05595b1932/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=7c707e4b9535b70de8c6beac24b7bc05595b1932", "patch": "@@ -4,7 +4,12 @@\n \n set -e\n \n-export GCC_PATH=$(cat gcc_path)\n+if [ -f ./gcc_path ]; then \n+    export GCC_PATH=$(cat gcc_path)\n+else\n+    echo 'Please put the path to your custom build of libgccjit in the file `gcc_path`, see Readme.md for details'\n+    exit 1\n+fi\n \n export LD_LIBRARY_PATH=\"$GCC_PATH\"\n export LIBRARY_PATH=\"$GCC_PATH\"\n@@ -157,7 +162,7 @@ done\n \n git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n \n-rm -r src/test/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,simd*,borrowck/,test*,*lto*.rs} || true\n+rm -r src/test/ui/{abi*,extern/,llvm-asm/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,simd*,borrowck/,test*,*lto*.rs} || true\n for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" src/test/ui); do\n   rm $test\n done"}, {"sha": "9c0055b0b6b5ec36fdbbcfc2d7eda5645a3a7b63", "filename": "tests/run/asm.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/7c707e4b9535b70de8c6beac24b7bc05595b1932/tests%2Frun%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c707e4b9535b70de8c6beac24b7bc05595b1932/tests%2Frun%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fasm.rs?ref=7c707e4b9535b70de8c6beac24b7bc05595b1932", "patch": "@@ -62,5 +62,92 @@ fn main() {\n     }\n     assert_eq!(x, 43);\n \n+    // check inout(reg_class) x \n+    let mut x: u64 = 42;\n+    unsafe {\n+        asm!(\"add {0}, {0}\",\n+            inout(reg) x \n+        );\n+    }\n+    assert_eq!(x, 84);\n+\n+    // check inout(\"reg\") x\n+    let mut x: u64 = 42;\n+    unsafe {\n+        asm!(\"add r11, r11\",\n+            inout(\"r11\") x \n+        );\n+    }\n+    assert_eq!(x, 84);\n+\n+    // check a mix of\n+    // in(\"reg\")\n+    // inout(class) x => y\n+    // inout (class) x\n+    let x: u64 = 702;\n+    let y: u64 = 100;\n+    let res: u64;\n+    let mut rem: u64 = 0;\n+    unsafe {\n+        asm!(\"div r11\",\n+            in(\"r11\") y,\n+            inout(\"eax\") x => res,\n+            inout(\"edx\") rem,\n+        );\n+    }\n+    assert_eq!(res, 7);\n+    assert_eq!(rem, 2);\n+\n+    // check const \n+    let mut x: u64 = 42;\n+    unsafe {\n+        asm!(\"add {}, {}\",\n+            inout(reg) x,\n+            const 1 \n+        );\n+    }\n+    assert_eq!(x, 43);\n+\n+    // check const (ATT syntax)\n+    let mut x: u64 = 42;\n+    unsafe {\n+        asm!(\"add {}, {}\",\n+            const 1,\n+            inout(reg) x,\n+            options(att_syntax)\n+        );\n+    }\n+    assert_eq!(x, 43);\n+\n+    // check sym fn\n+    extern \"C\" fn foo() -> u64 { 42 }\n+    let x: u64;\n+    unsafe {\n+        asm!(\"call {}\", sym foo, lateout(\"rax\") x);\n+    }\n+    assert_eq!(x, 42);\n+\n+    // check sym fn (ATT syntax)\n+    let x: u64;\n+    unsafe {\n+        asm!(\"call {}\", sym foo, lateout(\"rax\") x, options(att_syntax));\n+    }\n+    assert_eq!(x, 42);\n+\n+    // check sym static\n+    static FOO: u64 = 42;\n+    let x: u64;\n+    unsafe {\n+        asm!(\"mov {1}, qword ptr [rip + {0}]\", sym FOO, lateout(reg) x);\n+    }\n+    assert_eq!(x, 42);\n+\n+    // check sym static (ATT syntax)\n+    let x: u64;\n+    unsafe {\n+        asm!(\"movq {0}(%rip), {1}\", sym FOO, lateout(reg) x, options(att_syntax));\n+    }\n+    assert_eq!(x, 42);\n+\n     assert_eq!(unsafe { add_asm(40, 2) }, 42);\n }"}]}