{"sha": "b79d717c9127492073696f40c589ca805ac12e58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3OWQ3MTdjOTEyNzQ5MjA3MzY5NmY0MGM1ODljYTgwNWFjMTJlNTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-19T02:06:20Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-19T02:07:20Z"}, "message": "fix borrowing pats---the id field of cmt was assoc with wrong pat", "tree": {"sha": "376adc7f4504485ee1f2cfd0a82ac1a21c265493", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/376adc7f4504485ee1f2cfd0a82ac1a21c265493"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b79d717c9127492073696f40c589ca805ac12e58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b79d717c9127492073696f40c589ca805ac12e58", "html_url": "https://github.com/rust-lang/rust/commit/b79d717c9127492073696f40c589ca805ac12e58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b79d717c9127492073696f40c589ca805ac12e58/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19ec5a41ed98df980357a93d6938dc253106fd9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/19ec5a41ed98df980357a93d6938dc253106fd9d", "html_url": "https://github.com/rust-lang/rust/commit/19ec5a41ed98df980357a93d6938dc253106fd9d"}], "stats": {"total": 45, "additions": 32, "deletions": 13}, "files": [{"sha": "62eee5c8dd2e909a0cc9e645d06bebceaf692935", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b79d717c9127492073696f40c589ca805ac12e58/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b79d717c9127492073696f40c589ca805ac12e58/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=b79d717c9127492073696f40c589ca805ac12e58", "patch": "@@ -351,6 +351,27 @@ impl methods for gather_loan_ctxt {\n         // been built up and pass it off to guarantee_valid() so that\n         // we can be sure that the binding will remain valid for the\n         // duration of the arm.\n+        //\n+        // The correspondence between the id in the cmt and which\n+        // pattern is being referred to is somewhat...subtle.  In\n+        // general, the id of the cmt is the id of the node that\n+        // produces the value.  For patterns, that's actually the\n+        // *subpattern*, generally speaking.\n+        //\n+        // To see what I mean about ids etc, consider:\n+        //\n+        //     let x = @@3;\n+        //     alt x {\n+        //       @@y { ... }\n+        //     }\n+        //\n+        // Here the cmt for `y` would be something like\n+        //\n+        //     local(x)->@->@\n+        //\n+        // where the id of `local(x)` is the id of the `x` that appears\n+        // in the alt, the id of `local(x)->@` is the `@y` pattern,\n+        // and the id of `local(x)->@->@` is the id of the `y` pattern.\n \n         #debug[\"gather_pat: id=%d pat=%s cmt=%s arm_id=%d alt_id=%d\",\n                pat.id, pprust::pat_to_str(pat),\n@@ -369,7 +390,7 @@ impl methods for gather_loan_ctxt {\n           ast::pat_enum(_, some(subpats)) {\n             // variant(x, y, z)\n             for subpats.each { |subpat|\n-                let subcmt = self.bccx.cat_variant(pat, cmt, subpat);\n+                let subcmt = self.bccx.cat_variant(subpat, cmt);\n                 self.gather_pat(subcmt, subpat, arm_id, alt_id);\n             }\n           }\n@@ -396,23 +417,22 @@ impl methods for gather_loan_ctxt {\n           ast::pat_rec(field_pats, _) {\n             // {f1: p1, ..., fN: pN}\n             for field_pats.each { |fp|\n-                let cmt_field = self.bccx.cat_field(pat, cmt, fp.ident,\n-                                                    tcx.ty(fp.pat));\n+                let cmt_field = self.bccx.cat_field(fp.pat, cmt, fp.ident);\n                 self.gather_pat(cmt_field, fp.pat, arm_id, alt_id);\n             }\n           }\n \n           ast::pat_tup(subpats) {\n             // (p1, ..., pN)\n             for subpats.each { |subpat|\n-                let subcmt = self.bccx.cat_tuple_elt(pat, cmt, subpat);\n+                let subcmt = self.bccx.cat_tuple_elt(subpat, cmt);\n                 self.gather_pat(subcmt, subpat, arm_id, alt_id);\n             }\n           }\n \n           ast::pat_box(subpat) | ast::pat_uniq(subpat) {\n             // @p1, ~p1\n-            alt self.bccx.cat_deref(pat, cmt, 0u, true) {\n+            alt self.bccx.cat_deref(subpat, cmt, 0u, true) {\n               some(subcmt) {\n                 self.gather_pat(subcmt, subpat, arm_id, alt_id);\n               }\n@@ -998,7 +1018,7 @@ impl categorize_methods for borrowck_ctxt {\n \n           ast::expr_field(base, f_name, _) {\n             let base_cmt = self.cat_autoderef(base);\n-            self.cat_field(expr, base_cmt, f_name, expr_ty)\n+            self.cat_field(expr, base_cmt, f_name)\n           }\n \n           ast::expr_index(base, _) {\n@@ -1033,8 +1053,7 @@ impl categorize_methods for borrowck_ctxt {\n         ret @{cat:cat_discr(cmt, alt_id) with *cmt};\n     }\n \n-    fn cat_field<N:ast_node>(node: N, base_cmt: cmt,\n-                             f_name: str, f_ty: ty::t) -> cmt {\n+    fn cat_field<N:ast_node>(node: N, base_cmt: cmt, f_name: str) -> cmt {\n         let f_mutbl = alt field_mutbl(self.tcx, base_cmt.ty, f_name) {\n           some(f_mutbl) { f_mutbl }\n           none {\n@@ -1053,7 +1072,7 @@ impl categorize_methods for borrowck_ctxt {\n         };\n         @{id: node.id(), span: node.span(),\n           cat: cat_comp(base_cmt, comp_field(f_name)), lp:lp,\n-          mutbl: m, ty: f_ty}\n+          mutbl: m, ty: self.tcx.ty(node)}\n     }\n \n     fn cat_deref<N:ast_node>(node: N, base_cmt: cmt, derefs: uint,\n@@ -1141,16 +1160,16 @@ impl categorize_methods for borrowck_ctxt {\n           mutbl:mt.mutbl, ty:mt.ty}\n     }\n \n-    fn cat_variant<N: ast_node>(variant: N, cmt: cmt, arg: N) -> cmt {\n-        @{id: variant.id(), span: variant.span(),\n+    fn cat_variant<N: ast_node>(arg: N, cmt: cmt) -> cmt {\n+        @{id: arg.id(), span: arg.span(),\n           cat: cat_comp(cmt, comp_variant),\n           lp: cmt.lp.map { |l| @lp_comp(l, comp_variant) },\n           mutbl: cmt.mutbl, // imm iff in an immutable context\n           ty: self.tcx.ty(arg)}\n     }\n \n-    fn cat_tuple_elt<N: ast_node>(pat: N, cmt: cmt, elt: N) -> cmt {\n-        @{id: pat.id(), span: pat.span(),\n+    fn cat_tuple_elt<N: ast_node>(elt: N, cmt: cmt) -> cmt {\n+        @{id: elt.id(), span: elt.span(),\n           cat: cat_comp(cmt, comp_tuple),\n           lp: cmt.lp.map { |l| @lp_comp(l, comp_tuple) },\n           mutbl: cmt.mutbl, // imm iff in an immutable context"}]}