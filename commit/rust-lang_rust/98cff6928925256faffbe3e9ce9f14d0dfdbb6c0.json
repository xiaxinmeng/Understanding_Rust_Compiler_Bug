{"sha": "98cff6928925256faffbe3e9ce9f14d0dfdbb6c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4Y2ZmNjkyODkyNTI1NmZhZmZiZTNlOWNlOWYxNGQwZGZkYmI2YzA=", "commit": {"author": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2019-07-30T21:38:02Z"}, "committer": {"name": "Andreas Molzer", "email": "andreas.molzer@gmx.de", "date": "2019-08-17T17:58:15Z"}, "message": "Move copy of undef_mask into allocation\n\nThis also means that the compressed representation chosen may be\noptimized together with any changes to the undef_mask.", "tree": {"sha": "26759b91cb4227bd639fd72542a1022939319c67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26759b91cb4227bd639fd72542a1022939319c67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98cff6928925256faffbe3e9ce9f14d0dfdbb6c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98cff6928925256faffbe3e9ce9f14d0dfdbb6c0", "html_url": "https://github.com/rust-lang/rust/commit/98cff6928925256faffbe3e9ce9f14d0dfdbb6c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98cff6928925256faffbe3e9ce9f14d0dfdbb6c0/comments", "author": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HeroicKatora", "id": 5550310, "node_id": "MDQ6VXNlcjU1NTAzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/5550310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HeroicKatora", "html_url": "https://github.com/HeroicKatora", "followers_url": "https://api.github.com/users/HeroicKatora/followers", "following_url": "https://api.github.com/users/HeroicKatora/following{/other_user}", "gists_url": "https://api.github.com/users/HeroicKatora/gists{/gist_id}", "starred_url": "https://api.github.com/users/HeroicKatora/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HeroicKatora/subscriptions", "organizations_url": "https://api.github.com/users/HeroicKatora/orgs", "repos_url": "https://api.github.com/users/HeroicKatora/repos", "events_url": "https://api.github.com/users/HeroicKatora/events{/privacy}", "received_events_url": "https://api.github.com/users/HeroicKatora/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2228b3f08631b5e9b32e6b6c82e758fe4bcbbd60", "url": "https://api.github.com/repos/rust-lang/rust/commits/2228b3f08631b5e9b32e6b6c82e758fe4bcbbd60", "html_url": "https://github.com/rust-lang/rust/commit/2228b3f08631b5e9b32e6b6c82e758fe4bcbbd60"}], "stats": {"total": 143, "additions": 88, "deletions": 55}, "files": [{"sha": "e0ada7e2f11a3a76abf9fcd9d80406cc9979521d", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/98cff6928925256faffbe3e9ce9f14d0dfdbb6c0/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98cff6928925256faffbe3e9ce9f14d0dfdbb6c0/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=98cff6928925256faffbe3e9ce9f14d0dfdbb6c0", "patch": "@@ -566,6 +566,91 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     }\n }\n \n+/// Run-length encoding of the undef mask.\n+/// Used to copy parts of a mask multiple times to another allocation.\n+pub struct AllocationDefinedness {\n+    ranges: smallvec::SmallVec::<[u64; 1]>,\n+    first: bool,\n+}\n+\n+/// Transferring the definedness mask to other allocations.\n+impl<Tag, Extra> Allocation<Tag, Extra> {\n+    /// Creates a run-length encoding of the undef_mask.\n+    pub fn compress_defined_range(\n+        &self,\n+        src: Pointer<Tag>,\n+        size: Size,\n+    ) -> AllocationDefinedness {\n+        // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n+        // a naive undef mask copying algorithm would repeatedly have to read the undef mask from\n+        // the source and write it to the destination. Even if we optimized the memory accesses,\n+        // we'd be doing all of this `repeat` times.\n+        // Therefor we precompute a compressed version of the undef mask of the source value and\n+        // then write it back `repeat` times without computing any more information from the source.\n+\n+        // a precomputed cache for ranges of defined/undefined bits\n+        // 0000010010001110 will become\n+        // [5, 1, 2, 1, 3, 3, 1]\n+        // where each element toggles the state\n+\n+        let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n+        let first = self.undef_mask.get(src.offset);\n+        let mut cur_len = 1;\n+        let mut cur = first;\n+\n+        for i in 1..size.bytes() {\n+            // FIXME: optimize to bitshift the current undef block's bits and read the top bit\n+            if self.undef_mask.get(src.offset + Size::from_bytes(i)) == cur {\n+                cur_len += 1;\n+            } else {\n+                ranges.push(cur_len);\n+                cur_len = 1;\n+                cur = !cur;\n+            }\n+        }\n+\n+        ranges.push(cur_len);\n+\n+        AllocationDefinedness { ranges, first, }\n+    }\n+\n+    /// Apply multiple instances of the run-length encoding to the undef_mask.\n+    pub fn mark_compressed_range(\n+        &mut self,\n+        defined: &AllocationDefinedness,\n+        dest: Pointer<Tag>,\n+        size: Size,\n+        repeat: u64,\n+    ) {\n+        // an optimization where we can just overwrite an entire range of definedness bits if\n+        // they are going to be uniformly `1` or `0`.\n+        if defined.ranges.len() <= 1 {\n+            self.undef_mask.set_range_inbounds(\n+                dest.offset,\n+                dest.offset + size * repeat,\n+                defined.first,\n+            );\n+            return;\n+        }\n+\n+        for mut j in 0..repeat {\n+            j *= size.bytes();\n+            j += dest.offset.bytes();\n+            let mut cur = defined.first;\n+            for range in &defined.ranges {\n+                let old_j = j;\n+                j += range;\n+                self.undef_mask.set_range_inbounds(\n+                    Size::from_bytes(old_j),\n+                    Size::from_bytes(j),\n+                    cur,\n+                );\n+                cur = !cur;\n+            }\n+        }\n+    }\n+}\n+\n /// Relocations\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Relocations<Tag=(), Id=AllocId>(SortedMap<Size, (Tag, Id)>);"}, {"sha": "f572651f02b56d30a2c0adea77334c096796c8a5", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 55, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/98cff6928925256faffbe3e9ce9f14d0dfdbb6c0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98cff6928925256faffbe3e9ce9f14d0dfdbb6c0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=98cff6928925256faffbe3e9ce9f14d0dfdbb6c0", "patch": "@@ -894,65 +894,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n \n-        let undef_mask = &self.get(src.alloc_id)?.undef_mask;\n-\n-        // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n-        // a naive undef mask copying algorithm would repeatedly have to read the undef mask from\n-        // the source and write it to the destination. Even if we optimized the memory accesses,\n-        // we'd be doing all of this `repeat` times.\n-        // Therefor we precompute a compressed version of the undef mask of the source value and\n-        // then write it back `repeat` times without computing any more information from the source.\n-\n-        // a precomputed cache for ranges of defined/undefined bits\n-        // 0000010010001110 will become\n-        // [5, 1, 2, 1, 3, 3, 1]\n-        // where each element toggles the state\n-        let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n-        let first = undef_mask.get(src.offset);\n-        let mut cur_len = 1;\n-        let mut cur = first;\n-        for i in 1..size.bytes() {\n-            // FIXME: optimize to bitshift the current undef block's bits and read the top bit\n-            if undef_mask.get(src.offset + Size::from_bytes(i)) == cur {\n-                cur_len += 1;\n-            } else {\n-                ranges.push(cur_len);\n-                cur_len = 1;\n-                cur = !cur;\n-            }\n-        }\n+        let src_alloc = self.get(src.alloc_id)?;\n+        let compressed = src_alloc.compress_defined_range(src, size);\n \n         // now fill in all the data\n         let dest_allocation = self.get_mut(dest.alloc_id)?;\n-        // an optimization where we can just overwrite an entire range of definedness bits if\n-        // they are going to be uniformly `1` or `0`.\n-        if ranges.is_empty() {\n-            dest_allocation.undef_mask.set_range_inbounds(\n-                dest.offset,\n-                dest.offset + size * repeat,\n-                first,\n-            );\n-            return Ok(())\n-        }\n+        dest_allocation.mark_compressed_range(&compressed, dest, size, repeat);\n \n-        // remember to fill in the trailing bits\n-        ranges.push(cur_len);\n-\n-        for mut j in 0..repeat {\n-            j *= size.bytes();\n-            j += dest.offset.bytes();\n-            let mut cur = first;\n-            for range in &ranges {\n-                let old_j = j;\n-                j += range;\n-                dest_allocation.undef_mask.set_range_inbounds(\n-                    Size::from_bytes(old_j),\n-                    Size::from_bytes(j),\n-                    cur,\n-                );\n-                cur = !cur;\n-            }\n-        }\n         Ok(())\n     }\n "}]}