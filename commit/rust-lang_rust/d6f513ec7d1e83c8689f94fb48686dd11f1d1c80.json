{"sha": "d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZjUxM2VjN2QxZTgzYzg2ODlmOTRmYjQ4Njg2ZGQxMWYxZDFjODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-18T14:52:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-18T14:52:45Z"}, "message": "Auto merge of #60025 - JohnTitor:rename-files, r=petrochenkov\n\nRename files about error codes\n\nfixes #60017\n\nThis PR will be failed in tidy.\n\n<details>\n<summary>The log is here:</summary>\n\n```\ntidy check\ntidy error: duplicate error code: 411\ntidy error: Documents\\GitHub\\rust\\src\\librustc_resolve\\diagnostics.rs:83:             __diagnostic_used!(E0411);\ntidy error: Documents\\GitHub\\rust\\src\\librustc_resolve\\diagnostics.rs:84:             err.code(DiagnosticId::Error(\"E0411\".to_owned()));\ntidy error: duplicate error code: 424\ntidy error: Documents\\GitHub\\rust\\src\\librustc_resolve\\diagnostics.rs:90:             debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\ntidy error: Documents\\GitHub\\rust\\src\\librustc_resolve\\diagnostics.rs:92:             __diagnostic_used!(E0424);\ntidy error: Documents\\GitHub\\rust\\src\\librustc_resolve\\diagnostics.rs:93:             err.code(DiagnosticId::Error(\"E0424\".to_owned()));\nsome tidy checks failed\n```\n\n</details>\n\nI'd like to fix this but I don't know what to do.\nI will work on later. Please let me know if you have any solutions.\n\nr? @petrochenkov", "tree": {"sha": "ffac5f0c321b75165397cf045d60ed31c171a0fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffac5f0c321b75165397cf045d60ed31c171a0fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "html_url": "https://github.com/rust-lang/rust/commit/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf843eb9c2d48a80a5992a5d60858e27269f9575", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf843eb9c2d48a80a5992a5d60858e27269f9575", "html_url": "https://github.com/rust-lang/rust/commit/bf843eb9c2d48a80a5992a5d60858e27269f9575"}, {"sha": "a1d2f7222cf1f5c4344a918251c7f37d252c2434", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1d2f7222cf1f5c4344a918251c7f37d252c2434", "html_url": "https://github.com/rust-lang/rust/commit/a1d2f7222cf1f5c4344a918251c7f37d252c2434"}], "stats": {"total": 5040, "additions": 2520, "deletions": 2520}, "files": [{"sha": "e3684fc9f320a7c400f0d09f69873c283ff2b4eb", "filename": "src/doc/rustc-ux-guidelines.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -61,17 +61,17 @@ for details on how to format and write long error codes.\n \n * All of them are accessible [online](http://doc.rust-lang.org/error-index.html),\n   which are auto-generated from rustc source code in different places:\n-  [librustc](https://github.com/rust-lang/rust/blob/master/src/librustc/diagnostics.rs),\n-  [libsyntax](https://github.com/rust-lang/rust/blob/master/src/libsyntax/diagnostics.rs),\n-  [librustc_borrowck](https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/diagnostics.rs),\n-  [librustc_metadata](https://github.com/rust-lang/rust/blob/master/src/librustc_metadata/diagnostics.rs),\n-  [librustc_mir](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/diagnostics.rs),\n-  [librustc_passes](https://github.com/rust-lang/rust/blob/master/src/librustc_passes/diagnostics.rs),\n-  [librustc_privacy](https://github.com/rust-lang/rust/blob/master/src/librustc_privacy/diagnostics.rs),\n-  [librustc_resolve](https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/diagnostics.rs),\n-  [librustc_codegen_llvm](https://github.com/rust-lang/rust/blob/master/src/librustc_codegen_llvm/diagnostics.rs),\n-  [librustc_plugin](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/diagnostics.rs),\n-  [librustc_typeck](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/diagnostics.rs).\n+  [librustc](https://github.com/rust-lang/rust/blob/master/src/librustc/error_codes.rs),\n+  [libsyntax](https://github.com/rust-lang/rust/blob/master/src/libsyntax/error_codes.rs),\n+  [librustc_borrowck](https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/error_codes.rs),\n+  [librustc_metadata](https://github.com/rust-lang/rust/blob/master/src/librustc_metadata/error_codes.rs),\n+  [librustc_mir](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/error_codes.rs),\n+  [librustc_passes](https://github.com/rust-lang/rust/blob/master/src/librustc_passes/error_codes.rs),\n+  [librustc_privacy](https://github.com/rust-lang/rust/blob/master/src/librustc_privacy/error_codes.rs),\n+  [librustc_resolve](https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/error_codes.rs),\n+  [librustc_codegen_llvm](https://github.com/rust-lang/rust/blob/master/src/librustc_codegen_llvm/error_codes.rs),\n+  [librustc_plugin](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/error_codes.rs),\n+  [librustc_typeck](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/error_codes.rs).\n * Explanations have full markdown support. Use it, especially to highlight\n code with backticks.\n * When talking about the compiler, call it `the compiler`, not `Rust` or"}, {"sha": "00f9fa3a938d6b7c9bb148152a99f2b96cac1201", "filename": "src/librustc/error_codes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "previous_filename": "src/librustc/diagnostics.rs"}, {"sha": "1bd44b13b669c1044b2c7e768318cef37c9e8f97", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -99,7 +99,7 @@ mod macros;\n \n // N.B., this module needs to be declared first so diagnostics are\n // registered before they are used.\n-pub mod diagnostics;\n+pub mod error_codes;\n \n #[macro_use]\n pub mod query;"}, {"sha": "44d8a23fcb9109776ccf7cbd33b0da44f09a32fe", "filename": "src/librustc_borrowck/error_codes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_borrowck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_borrowck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Ferror_codes.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "previous_filename": "src/librustc_borrowck/diagnostics.rs"}, {"sha": "872fa424e4cfb51128983c95da2a48d12f1e430d", "filename": "src/librustc_codegen_llvm/error_codes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "previous_filename": "src/librustc_codegen_llvm/diagnostics.rs"}, {"sha": "c2eee59fbb0ac0989c32e25b4bf459e3f983078b", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -70,7 +70,7 @@ use rustc_mir::monomorphize;\n use rustc_codegen_ssa::ModuleCodegen;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n \n-mod diagnostics;\n+mod error_codes;\n \n mod back {\n     mod archive;"}, {"sha": "e7ef178cfabfba62793df0d2f37dfffd92ad9fef", "filename": "src/librustc_codegen_ssa/error_codes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "previous_filename": "src/librustc_codegen_ssa/diagnostics.rs"}, {"sha": "49e9f6fe38ad17bbfd3f60ea864f9f36238847ca", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -41,7 +41,7 @@ use syntax_pos::symbol::Symbol;\n \n // N.B., this module needs to be declared first so diagnostics are\n // registered before they are used.\n-mod diagnostics;\n+mod error_codes;\n \n pub mod common;\n pub mod traits;"}, {"sha": "3165673111cca008363c69ef5425f4ffeec33c60", "filename": "src/librustc_lint/error_codes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_lint%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_lint%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ferror_codes.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "previous_filename": "src/librustc_lint/diagnostics.rs"}, {"sha": "3f6348ec8dd75c21dec7a337c584003a46770cb5", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -25,7 +25,7 @@\n #[macro_use]\n extern crate rustc;\n \n-mod diagnostics;\n+mod error_codes;\n mod nonstandard_style;\n pub mod builtin;\n mod types;"}, {"sha": "9ac582ebc42dab1b0cf0133606de3c81d4da7a59", "filename": "src/librustc_metadata/error_codes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_metadata%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_metadata%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ferror_codes.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "previous_filename": "src/librustc_metadata/diagnostics.rs"}, {"sha": "4f84ca69b7f186d76d12298e24f45e6ffd93e12d", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -26,7 +26,7 @@ extern crate rustc;\n #[macro_use]\n extern crate rustc_data_structures;\n \n-mod diagnostics;\n+mod error_codes;\n \n mod index_builder;\n mod index;"}, {"sha": "c8836fe51931ebd9497213e5c3a5e9e7b38485ed", "filename": "src/librustc_mir/error_codes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "previous_filename": "src/librustc_mir/diagnostics.rs"}, {"sha": "d382e53e91846a55e120524e0e6c0944c7540559", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -40,7 +40,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n #[macro_use]\n extern crate syntax;\n \n-mod diagnostics;\n+mod error_codes;\n \n mod borrow_check;\n mod build;"}, {"sha": "e3c6b16703a4ac1a105fdc91812297d5168dff5d", "filename": "src/librustc_passes/error_codes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_passes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_passes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Ferror_codes.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "previous_filename": "src/librustc_passes/diagnostics.rs"}, {"sha": "7c48feecb211096d4b7f822ae4cc3c81ddc89240", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -19,7 +19,7 @@ extern crate rustc;\n \n use rustc::ty::query::Providers;\n \n-mod diagnostics;\n+mod error_codes;\n \n pub mod ast_validation;\n pub mod rvalue_promotion;"}, {"sha": "68462bd83ef60dbd09f46cb338f677d73ed5f040", "filename": "src/librustc_plugin/error_codes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_plugin%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_plugin%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Ferror_codes.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "previous_filename": "src/librustc_plugin/diagnostics.rs"}, {"sha": "3775dbb79c6fde8f409eabbd97e38bf195a29876", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -61,7 +61,7 @@\n \n pub use registry::Registry;\n \n-mod diagnostics;\n+mod error_codes;\n pub mod registry;\n pub mod load;\n pub mod build;"}, {"sha": "fa4df53e47b318146a0c3333bb5c58d5c1d76b52", "filename": "src/librustc_privacy/error_codes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_privacy%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_privacy%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Ferror_codes.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "previous_filename": "src/librustc_privacy/diagnostics.rs"}, {"sha": "edb3efb78a39ceb76beeeec1758cbbe0d7432dd1", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -33,7 +33,7 @@ use syntax_pos::Span;\n use std::{cmp, fmt, mem};\n use std::marker::PhantomData;\n \n-mod diagnostics;\n+mod error_codes;\n \n ////////////////////////////////////////////////////////////////////////////////\n /// Generic infrastructure used to implement specific visitors below."}, {"sha": "9e3894dab0da0b40f1bc418edc006725a9385cd0", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 822, "deletions": 1638, "changes": 2460, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -1,1672 +1,856 @@\n-#![allow(non_snake_case)]\n-\n-use syntax::{register_diagnostic, register_diagnostics, register_long_diagnostics};\n-\n-// Error messages for EXXXX errors.  Each message should start and end with a\n-// new line, and be wrapped to 80 characters.  In vim you can `:set tw=80` and\n-// use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n-register_long_diagnostics! {\n-\n-E0128: r##\"\n-Type parameter defaults can only use parameters that occur before them.\n-Erroneous code example:\n-\n-```compile_fail,E0128\n-struct Foo<T=U, U=()> {\n-    field1: T,\n-    filed2: U,\n-}\n-// error: type parameters with a default cannot use forward declared\n-// identifiers\n-```\n-\n-Since type parameters are evaluated in-order, you may be able to fix this issue\n-by doing:\n-\n-```\n-struct Foo<U=(), T=U> {\n-    field1: T,\n-    filed2: U,\n-}\n-```\n-\n-Please also verify that this wasn't because of a name-clash and rename the type\n-parameter if so.\n-\"##,\n-\n-E0154: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Imports (`use` statements) are not allowed after non-item statements, such as\n-variable declarations and expression statements.\n-\n-Here is an example that demonstrates the error:\n-\n-```\n-fn f() {\n-    // Variable declaration before import\n-    let x = 0;\n-    use std::io::Read;\n-    // ...\n-}\n-```\n-\n-The solution is to declare the imports at the top of the block, function, or\n-file.\n-\n-Here is the previous example again, with the correct order:\n-\n-```\n-fn f() {\n-    use std::io::Read;\n-    let x = 0;\n-    // ...\n-}\n-```\n-\n-See the Declaration Statements section of the reference for more information\n-about what constitutes an Item declaration and what does not:\n-\n-https://doc.rust-lang.org/reference.html#statements\n-\"##,\n-\n-E0251: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Two items of the same name cannot be imported without rebinding one of the\n-items under a new local name.\n-\n-An example of this error:\n-\n-```\n-use foo::baz;\n-use bar::*; // error, do `use foo::baz as quux` instead on the previous line\n-\n-fn main() {}\n-\n-mod foo {\n-    pub struct baz;\n-}\n-\n-mod bar {\n-    pub mod baz {}\n-}\n-```\n-\"##,\n-\n-E0252: r##\"\n-Two items of the same name cannot be imported without rebinding one of the\n-items under a new local name.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0252\n-use foo::baz;\n-use bar::baz; // error, do `use bar::baz as quux` instead\n-\n-fn main() {}\n-\n-mod foo {\n-    pub struct baz;\n-}\n-\n-mod bar {\n-    pub mod baz {}\n-}\n-```\n-\n-You can use aliases in order to fix this error. Example:\n-\n-```\n-use foo::baz as foo_baz;\n-use bar::baz; // ok!\n-\n-fn main() {}\n-\n-mod foo {\n-    pub struct baz;\n-}\n-\n-mod bar {\n-    pub mod baz {}\n-}\n-```\n-\n-Or you can reference the item with its parent:\n-\n-```\n-use bar::baz;\n-\n-fn main() {\n-    let x = foo::baz; // ok!\n-}\n+use std::cmp::Reverse;\n+\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use log::debug;\n+use rustc::hir::def::{self, CtorKind, Namespace::*};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::session::{Session, config::nightly_options};\n+use syntax::ast::{self, Expr, ExprKind, Ident};\n+use syntax::ext::base::MacroKind;\n+use syntax::symbol::{Symbol, keywords};\n+use syntax_pos::{BytePos, Span};\n+\n+type Def = def::Def<ast::NodeId>;\n+\n+use crate::macros::ParentScope;\n+use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n+use crate::{import_candidate_to_enum_paths, is_self_type, is_self_value, path_names_to_string};\n+use crate::{AssocSuggestion, CrateLint, ImportSuggestion, ModuleOrUniformRoot, PathResult,\n+            PathSource, Resolver, Segment, Suggestion};\n+\n+impl<'a> Resolver<'a> {\n+    /// Handles error reporting for `smart_resolve_path_fragment` function.\n+    /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n+    pub(crate) fn smart_resolve_report_errors(\n+        &mut self,\n+        path: &[Segment],\n+        span: Span,\n+        source: PathSource<'_>,\n+        def: Option<Def>,\n+    ) -> (DiagnosticBuilder<'a>, Vec<ImportSuggestion>) {\n+        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n+        let ns = source.namespace();\n+        let is_expected = &|def| source.is_expected(def);\n+        let is_enum_variant = &|def| if let Def::Variant(..) = def { true } else { false };\n+\n+        // Make the base error.\n+        let expected = source.descr_expected();\n+        let path_str = Segment::names_to_string(path);\n+        let item_str = path.last().unwrap().ident;\n+        let code = source.error_code(def.is_some());\n+        let (base_msg, fallback_label, base_span) = if let Some(def) = def {\n+            (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n+                format!(\"not a {}\", expected),\n+                span)\n+        } else {\n+            let item_span = path.last().unwrap().ident.span;\n+            let (mod_prefix, mod_str) = if path.len() == 1 {\n+                (String::new(), \"this scope\".to_string())\n+            } else if path.len() == 2 && path[0].ident.name == keywords::PathRoot.name() {\n+                (String::new(), \"the crate root\".to_string())\n+            } else {\n+                let mod_path = &path[..path.len() - 1];\n+                let mod_prefix = match self.resolve_path_without_parent_scope(\n+                    mod_path, Some(TypeNS), false, span, CrateLint::No\n+                ) {\n+                    PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                        module.def(),\n+                    _ => None,\n+                }.map_or(String::new(), |def| format!(\"{} \", def.kind_name()));\n+                (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n+            };\n+            (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n+                format!(\"not found in {}\", mod_str),\n+                item_span)\n+        };\n+\n+        let code = DiagnosticId::Error(code.into());\n+        let mut err = self.session.struct_span_err_with_code(base_span, &base_msg, code);\n+\n+        // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n+        if [\"this\", \"my\"].contains(&&*item_str.as_str())\n+            && self.self_value_is_available(path[0].ident.span, span) {\n+            err.span_suggestion(\n+                span,\n+                \"did you mean\",\n+                \"self\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n \n-mod foo {\n-    pub struct baz;\n-}\n+        // Emit special messages for unresolved `Self` and `self`.\n+        if is_self_type(path, ns) {\n+            __diagnostic_used!(E0411);\n+            err.code(DiagnosticId::Error(\"E0411\".into()));\n+            err.span_label(span, format!(\"`Self` is only available in impls, traits, \\\n+                                          and type definitions\"));\n+            return (err, Vec::new());\n+        }\n+        if is_self_value(path, ns) {\n+            debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n+\n+            __diagnostic_used!(E0424);\n+            err.code(DiagnosticId::Error(\"E0424\".into()));\n+            err.span_label(span, match source {\n+                PathSource::Pat => {\n+                    format!(\"`self` value is a keyword \\\n+                             and may not be bound to \\\n+                             variables or shadowed\")\n+                }\n+                _ => {\n+                    format!(\"`self` value is a keyword \\\n+                             only available in methods \\\n+                             with `self` parameter\")\n+                }\n+            });\n+            return (err, Vec::new());\n+        }\n \n-mod bar {\n-    pub mod baz {}\n-}\n-```\n-\"##,\n+        // Try to lookup name in more relaxed fashion for better error reporting.\n+        let ident = path.last().unwrap().ident;\n+        let candidates = self.lookup_import_candidates(ident, ns, is_expected)\n+            .drain(..)\n+            .filter(|ImportSuggestion { did, .. }| {\n+                match (did, def.and_then(|def| def.opt_def_id())) {\n+                    (Some(suggestion_did), Some(actual_did)) => *suggestion_did != actual_did,\n+                    _ => true,\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+        if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n+            let enum_candidates =\n+                self.lookup_import_candidates(ident, ns, is_enum_variant);\n+            let mut enum_candidates = enum_candidates.iter()\n+                .map(|suggestion| {\n+                    import_candidate_to_enum_paths(&suggestion)\n+                }).collect::<Vec<_>>();\n+            enum_candidates.sort();\n+\n+            if !enum_candidates.is_empty() {\n+                // Contextualize for E0412 \"cannot find type\", but don't belabor the point\n+                // (that it's a variant) for E0573 \"expected type, found variant\".\n+                let preamble = if def.is_none() {\n+                    let others = match enum_candidates.len() {\n+                        1 => String::new(),\n+                        2 => \" and 1 other\".to_owned(),\n+                        n => format!(\" and {} others\", n)\n+                    };\n+                    format!(\"there is an enum variant `{}`{}; \",\n+                            enum_candidates[0].0, others)\n+                } else {\n+                    String::new()\n+                };\n+                let msg = format!(\"{}try using the variant's enum\", preamble);\n+\n+                err.span_suggestions(\n+                    span,\n+                    &msg,\n+                    enum_candidates.into_iter()\n+                        .map(|(_variant_path, enum_ty_path)| enum_ty_path)\n+                        // Variants re-exported in prelude doesn't mean `prelude::v1` is the\n+                        // type name!\n+                        // FIXME: is there a more principled way to do this that\n+                        // would work for other re-exports?\n+                        .filter(|enum_ty_path| enum_ty_path != \"std::prelude::v1\")\n+                        // Also write `Option` rather than `std::prelude::v1::Option`.\n+                        .map(|enum_ty_path| {\n+                            // FIXME #56861: DRY-er prelude filtering.\n+                            enum_ty_path.trim_start_matches(\"std::prelude::v1::\").to_owned()\n+                        }),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        if path.len() == 1 && self.self_type_is_available(span) {\n+            if let Some(candidate) = self.lookup_assoc_candidate(ident, ns, is_expected) {\n+                let self_is_available = self.self_value_is_available(path[0].ident.span, span);\n+                match candidate {\n+                    AssocSuggestion::Field => {\n+                        err.span_suggestion(\n+                            span,\n+                            \"try\",\n+                            format!(\"self.{}\", path_str),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        if !self_is_available {\n+                            err.span_label(span, format!(\"`self` value is a keyword \\\n+                                                         only available in \\\n+                                                         methods with `self` parameter\"));\n+                        }\n+                    }\n+                    AssocSuggestion::MethodWithSelf if self_is_available => {\n+                        err.span_suggestion(\n+                            span,\n+                            \"try\",\n+                            format!(\"self.{}\", path_str),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                    AssocSuggestion::MethodWithSelf | AssocSuggestion::AssocItem => {\n+                        err.span_suggestion(\n+                            span,\n+                            \"try\",\n+                            format!(\"Self::{}\", path_str),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                }\n+                return (err, candidates);\n+            }\n+        }\n \n-E0253: r##\"\n-Attempt was made to import an unimportable value. This can happen when trying\n-to import a method from a trait.\n+        let mut levenshtein_worked = false;\n+\n+        // Try Levenshtein algorithm.\n+        let suggestion = self.lookup_typo_candidate(path, ns, is_expected, span);\n+        if let Some(suggestion) = suggestion {\n+            let msg = format!(\n+                \"{} {} with a similar name exists\",\n+                suggestion.article, suggestion.kind\n+            );\n+            err.span_suggestion(\n+                ident_span,\n+                &msg,\n+                suggestion.candidate.to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+\n+            levenshtein_worked = true;\n+        }\n \n-Erroneous code example:\n+        // Try context-dependent help if relaxed lookup didn't work.\n+        if let Some(def) = def {\n+            if self.smart_resolve_context_dependent_help(&mut err,\n+                                                         span,\n+                                                         source,\n+                                                         def,\n+                                                         &path_str,\n+                                                         &fallback_label) {\n+                return (err, candidates);\n+            }\n+        }\n \n-```compile_fail,E0253\n-mod foo {\n-    pub trait MyTrait {\n-        fn do_something();\n+        // Fallback label.\n+        if !levenshtein_worked {\n+            err.span_label(base_span, fallback_label);\n+            self.type_ascription_suggestion(&mut err, base_span);\n+        }\n+        (err, candidates)\n     }\n-}\n-\n-use foo::MyTrait::do_something;\n-// error: `do_something` is not directly importable\n-\n-fn main() {}\n-```\n-\n-It's invalid to directly import methods belonging to a trait or concrete type.\n-\"##,\n-\n-E0254: r##\"\n-Attempt was made to import an item whereas an extern crate with this name has\n-already been imported.\n-\n-Erroneous code example:\n \n-```compile_fail,E0254\n-extern crate core;\n-\n-mod foo {\n-    pub trait core {\n-        fn do_something();\n+    /// Provides context-dependent help for errors reported by the `smart_resolve_path_fragment`\n+    /// function.\n+    /// Returns `true` if able to provide context-dependent help.\n+    fn smart_resolve_context_dependent_help(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        span: Span,\n+        source: PathSource<'_>,\n+        def: Def,\n+        path_str: &str,\n+        fallback_label: &str,\n+    ) -> bool {\n+        let ns = source.namespace();\n+        let is_expected = &|def| source.is_expected(def);\n+\n+        let path_sep = |err: &mut DiagnosticBuilder<'_>, expr: &Expr| match expr.node {\n+            ExprKind::Field(_, ident) => {\n+                err.span_suggestion(\n+                    expr.span,\n+                    \"use the path separator to refer to an item\",\n+                    format!(\"{}::{}\", path_str, ident),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n+            ExprKind::MethodCall(ref segment, ..) => {\n+                let span = expr.span.with_hi(segment.ident.span.hi());\n+                err.span_suggestion(\n+                    span,\n+                    \"use the path separator to refer to an item\",\n+                    format!(\"{}::{}\", path_str, segment.ident),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n+            _ => false,\n+        };\n+\n+        match (def, source) {\n+            (Def::Macro(..), _) => {\n+                err.span_suggestion(\n+                    span,\n+                    \"use `!` to invoke the macro\",\n+                    format!(\"{}!\", path_str),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                if path_str == \"try\" && span.rust_2015() {\n+                    err.note(\"if you want the `try` keyword, you need to be in the 2018 edition\");\n+                }\n+            }\n+            (Def::TyAlias(..), PathSource::Trait(_)) => {\n+                err.span_label(span, \"type aliases cannot be used as traits\");\n+                if nightly_options::is_nightly_build() {\n+                    err.note(\"did you mean to use a trait alias?\");\n+                }\n+            }\n+            (Def::Mod(..), PathSource::Expr(Some(parent))) => if !path_sep(err, &parent) {\n+                return false;\n+            },\n+            (Def::Enum(..), PathSource::TupleStruct)\n+                | (Def::Enum(..), PathSource::Expr(..))  => {\n+                if let Some(variants) = self.collect_enum_variants(def) {\n+                    if !variants.is_empty() {\n+                        let msg = if variants.len() == 1 {\n+                            \"try using the enum's variant\"\n+                        } else {\n+                            \"try using one of the enum's variants\"\n+                        };\n+\n+                        err.span_suggestions(\n+                            span,\n+                            msg,\n+                            variants.iter().map(path_names_to_string),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                } else {\n+                    err.note(\"did you mean to use one of the enum's variants?\");\n+                }\n+            },\n+            (Def::Struct(def_id), _) if ns == ValueNS => {\n+                if let Some((ctor_def, ctor_vis))\n+                        = self.struct_constructors.get(&def_id).cloned() {\n+                    let accessible_ctor = self.is_accessible(ctor_vis);\n+                    if is_expected(ctor_def) && !accessible_ctor {\n+                        err.span_label(\n+                            span,\n+                            format!(\"constructor is not visible here due to private fields\"),\n+                        );\n+                    }\n+                } else {\n+                    // HACK(estebank): find a better way to figure out that this was a\n+                    // parser issue where a struct literal is being used on an expression\n+                    // where a brace being opened means a block is being started. Look\n+                    // ahead for the next text to see if `span` is followed by a `{`.\n+                    let sm = self.session.source_map();\n+                    let mut sp = span;\n+                    loop {\n+                        sp = sm.next_point(sp);\n+                        match sm.span_to_snippet(sp) {\n+                            Ok(ref snippet) => {\n+                                if snippet.chars().any(|c| { !c.is_whitespace() }) {\n+                                    break;\n+                                }\n+                            }\n+                            _ => break,\n+                        }\n+                    }\n+                    let followed_by_brace = match sm.span_to_snippet(sp) {\n+                        Ok(ref snippet) if snippet == \"{\" => true,\n+                        _ => false,\n+                    };\n+                    // In case this could be a struct literal that needs to be surrounded\n+                    // by parenthesis, find the appropriate span.\n+                    let mut i = 0;\n+                    let mut closing_brace = None;\n+                    loop {\n+                        sp = sm.next_point(sp);\n+                        match sm.span_to_snippet(sp) {\n+                            Ok(ref snippet) => {\n+                                if snippet == \"}\" {\n+                                    let sp = span.to(sp);\n+                                    if let Ok(snippet) = sm.span_to_snippet(sp) {\n+                                        closing_brace = Some((sp, snippet));\n+                                    }\n+                                    break;\n+                                }\n+                            }\n+                            _ => break,\n+                        }\n+                        i += 1;\n+                        // The bigger the span, the more likely we're incorrect --\n+                        // bound it to 100 chars long.\n+                        if i > 100 {\n+                            break;\n+                        }\n+                    }\n+                    match source {\n+                        PathSource::Expr(Some(parent)) => if !path_sep(err, &parent) {\n+                            err.span_label(\n+                                span,\n+                                format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n+                            );\n+                        }\n+                        PathSource::Expr(None) if followed_by_brace == true => {\n+                            if let Some((sp, snippet)) = closing_brace {\n+                                err.span_suggestion(\n+                                    sp,\n+                                    \"surround the struct literal with parenthesis\",\n+                                    format!(\"({})\", snippet),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            } else {\n+                                err.span_label(\n+                                    span,\n+                                    format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n+                                );\n+                            }\n+                        },\n+                        _ => {\n+                            err.span_label(\n+                                span,\n+                                format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n+                            );\n+                        },\n+                    }\n+                }\n+            }\n+            (Def::Union(..), _) |\n+            (Def::Variant(..), _) |\n+            (Def::Ctor(_, _, CtorKind::Fictive), _) if ns == ValueNS => {\n+                err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str));\n+            }\n+            (Def::SelfTy(..), _) if ns == ValueNS => {\n+                err.span_label(span, fallback_label);\n+                err.note(\"can't use `Self` as a constructor, you must use the implemented struct\");\n+            }\n+            (Def::TyAlias(_), _) | (Def::AssociatedTy(..), _) if ns == ValueNS => {\n+                err.note(\"can't use a type alias as a constructor\");\n+            }\n+            _ => return false,\n+        }\n+        true\n     }\n }\n \n-use foo::core;  // error: an extern crate named `core` has already\n-                //        been imported in this module\n-\n-fn main() {}\n-```\n-\n-To fix this issue, you have to rename at least one of the two imports.\n-Example:\n-\n-```\n-extern crate core as libcore; // ok!\n+impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n+    /// Adds suggestions for a path that cannot be resolved.\n+    pub(crate) fn make_path_suggestion(\n+        &mut self,\n+        span: Span,\n+        mut path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+        debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n+\n+        match (path.get(0), path.get(1)) {\n+            // `{{root}}::ident::...` on both editions.\n+            // On 2015 `{{root}}` is usually added implicitly.\n+            (Some(fst), Some(snd)) if fst.ident.name == keywords::PathRoot.name() &&\n+                                      !snd.ident.is_path_segment_keyword() => {}\n+            // `ident::...` on 2018.\n+            (Some(fst), _) if fst.ident.span.rust_2018() &&\n+                              !fst.ident.is_path_segment_keyword() => {\n+                // Insert a placeholder that's later replaced by `self`/`super`/etc.\n+                path.insert(0, Segment::from_ident(keywords::Invalid.ident()));\n+            }\n+            _ => return None,\n+        }\n \n-mod foo {\n-    pub trait core {\n-        fn do_something();\n+        self.make_missing_self_suggestion(span, path.clone(), parent_scope)\n+            .or_else(|| self.make_missing_crate_suggestion(span, path.clone(), parent_scope))\n+            .or_else(|| self.make_missing_super_suggestion(span, path.clone(), parent_scope))\n+            .or_else(|| self.make_external_crate_suggestion(span, path, parent_scope))\n     }\n-}\n-\n-use foo::core;\n-\n-fn main() {}\n-```\n-\"##,\n-\n-E0255: r##\"\n-You can't import a value whose name is the same as another value defined in the\n-module.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0255\n-use bar::foo; // error: an item named `foo` is already in scope\n-\n-fn foo() {}\n-\n-mod bar {\n-     pub fn foo() {}\n-}\n-\n-fn main() {}\n-```\n-\n-You can use aliases in order to fix this error. Example:\n-\n-```\n-use bar::foo as bar_foo; // ok!\n-\n-fn foo() {}\n-\n-mod bar {\n-     pub fn foo() {}\n-}\n-\n-fn main() {}\n-```\n-\n-Or you can reference the item with its parent:\n-\n-```\n-fn foo() {}\n-\n-mod bar {\n-     pub fn foo() {}\n-}\n-\n-fn main() {\n-    bar::foo(); // we get the item by referring to its parent\n-}\n-```\n-\"##,\n-\n-E0256: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-You can't import a type or module when the name of the item being imported is\n-the same as another type or submodule defined in the module.\n-\n-An example of this error:\n-\n-```compile_fail\n-use foo::Bar; // error\n-\n-type Bar = u32;\n-\n-mod foo {\n-    pub mod Bar { }\n-}\n-\n-fn main() {}\n-```\n-\"##,\n-\n-E0259: r##\"\n-The name chosen for an external crate conflicts with another external crate\n-that has been imported into the current module.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0259\n-extern crate core;\n-extern crate std as core;\n-\n-fn main() {}\n-```\n-\n-The solution is to choose a different name that doesn't conflict with any\n-external crate imported into the current module.\n-\n-Correct example:\n-\n-```\n-extern crate core;\n-extern crate std as other_name;\n-\n-fn main() {}\n-```\n-\"##,\n-\n-E0260: r##\"\n-The name for an item declaration conflicts with an external crate's name.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0260\n-extern crate core;\n-\n-struct core;\n-\n-fn main() {}\n-```\n-\n-There are two possible solutions:\n-\n-Solution #1: Rename the item.\n-\n-```\n-extern crate core;\n-\n-struct xyz;\n-```\n-\n-Solution #2: Import the crate with a different name.\n-\n-```\n-extern crate core as xyz;\n-\n-struct abc;\n-```\n-\n-See the Declaration Statements section of the reference for more information\n-about what constitutes an Item declaration and what does not:\n-\n-https://doc.rust-lang.org/reference.html#statements\n-\"##,\n-\n-E0364: r##\"\n-Private items cannot be publicly re-exported. This error indicates that you\n-attempted to `pub use` a type or value that was not itself public.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-mod foo {\n-    const X: u32 = 1;\n-}\n-\n-pub use foo::X;\n-\n-fn main() {}\n-```\n \n-The solution to this problem is to ensure that the items that you are\n-re-exporting are themselves marked with `pub`:\n-\n-```\n-mod foo {\n-    pub const X: u32 = 1;\n-}\n-\n-pub use foo::X;\n-\n-fn main() {}\n-```\n-\n-See the 'Use Declarations' section of the reference for more information on\n-this topic:\n-\n-https://doc.rust-lang.org/reference.html#use-declarations\n-\"##,\n-\n-E0365: r##\"\n-Private modules cannot be publicly re-exported. This error indicates that you\n-attempted to `pub use` a module that was not itself public.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0365\n-mod foo {\n-    pub const X: u32 = 1;\n-}\n-\n-pub use foo as foo2;\n-\n-fn main() {}\n-```\n-\n-The solution to this problem is to ensure that the module that you are\n-re-exporting is itself marked with `pub`:\n-\n-```\n-pub mod foo {\n-    pub const X: u32 = 1;\n-}\n-\n-pub use foo as foo2;\n-\n-fn main() {}\n-```\n-\n-See the 'Use Declarations' section of the reference for more information\n-on this topic:\n-\n-https://doc.rust-lang.org/reference.html#use-declarations\n-\"##,\n-\n-E0401: r##\"\n-Inner items do not inherit type or const parameters from the functions\n-they are embedded in.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0401\n-fn foo<T>(x: T) {\n-    fn bar(y: T) { // T is defined in the \"outer\" function\n-        // ..\n+    /// Suggest a missing `self::` if that resolves to an correct module.\n+    ///\n+    /// ```\n+    ///    |\n+    /// LL | use foo::Bar;\n+    ///    |     ^^^ did you mean `self::foo`?\n+    /// ```\n+    fn make_missing_self_suggestion(\n+        &mut self,\n+        span: Span,\n+        mut path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+        // Replace first ident with `self` and check if that is valid.\n+        path[0].ident.name = keywords::SelfLower.name();\n+        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+        debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n+        if let PathResult::Module(..) = result {\n+            Some((path, Vec::new()))\n+        } else {\n+            None\n+        }\n     }\n-    bar(x);\n-}\n-```\n \n-Nor will this:\n-\n-```compile_fail,E0401\n-fn foo<T>(x: T) {\n-    type MaybeT = Option<T>;\n-    // ...\n-}\n-```\n-\n-Or this:\n-\n-```compile_fail,E0401\n-fn foo<T>(x: T) {\n-    struct Foo {\n-        x: T,\n+    /// Suggests a missing `crate::` if that resolves to an correct module.\n+    ///\n+    /// ```\n+    ///    |\n+    /// LL | use foo::Bar;\n+    ///    |     ^^^ did you mean `crate::foo`?\n+    /// ```\n+    fn make_missing_crate_suggestion(\n+        &mut self,\n+        span: Span,\n+        mut path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+        // Replace first ident with `crate` and check if that is valid.\n+        path[0].ident.name = keywords::Crate.name();\n+        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+        debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n+        if let PathResult::Module(..) = result {\n+            Some((\n+                path,\n+                vec![\n+                    \"`use` statements changed in Rust 2018; read more at \\\n+                     <https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-\\\n+                     clarity.html>\".to_string()\n+                ],\n+            ))\n+        } else {\n+            None\n+        }\n     }\n-    // ...\n-}\n-```\n-\n-Items inside functions are basically just like top-level items, except\n-that they can only be used from the function they are in.\n-\n-There are a couple of solutions for this.\n \n-If the item is a function, you may use a closure:\n+    /// Suggests a missing `super::` if that resolves to an correct module.\n+    ///\n+    /// ```\n+    ///    |\n+    /// LL | use foo::Bar;\n+    ///    |     ^^^ did you mean `super::foo`?\n+    /// ```\n+    fn make_missing_super_suggestion(\n+        &mut self,\n+        span: Span,\n+        mut path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+        // Replace first ident with `crate` and check if that is valid.\n+        path[0].ident.name = keywords::Super.name();\n+        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+        debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n+        if let PathResult::Module(..) = result {\n+            Some((path, Vec::new()))\n+        } else {\n+            None\n+        }\n+    }\n \n-```\n-fn foo<T>(x: T) {\n-    let bar = |y: T| { // explicit type annotation may not be necessary\n-        // ..\n-    };\n-    bar(x);\n-}\n-```\n+    /// Suggests a missing external crate name if that resolves to an correct module.\n+    ///\n+    /// ```\n+    ///    |\n+    /// LL | use foobar::Baz;\n+    ///    |     ^^^^^^ did you mean `baz::foobar`?\n+    /// ```\n+    ///\n+    /// Used when importing a submodule of an external crate but missing that crate's\n+    /// name as the first part of path.\n+    fn make_external_crate_suggestion(\n+        &mut self,\n+        span: Span,\n+        mut path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n+        if path[1].ident.span.rust_2015() {\n+            return None;\n+        }\n \n-For a generic item, you can copy over the parameters:\n+        // Sort extern crate names in reverse order to get\n+        // 1) some consistent ordering for emitted dignostics, and\n+        // 2) `std` suggestions before `core` suggestions.\n+        let mut extern_crate_names =\n+            self.resolver.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();\n+        extern_crate_names.sort_by_key(|name| Reverse(name.as_str()));\n+\n+        for name in extern_crate_names.into_iter() {\n+            // Replace first ident with a crate name and check if that is valid.\n+            path[0].ident.name = name;\n+            let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n+            debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n+                    name, path, result);\n+            if let PathResult::Module(..) = result {\n+                return Some((path, Vec::new()));\n+            }\n+        }\n \n-```\n-fn foo<T>(x: T) {\n-    fn bar<T>(y: T) {\n-        // ..\n+        None\n     }\n-    bar(x);\n-}\n-```\n \n-```\n-fn foo<T>(x: T) {\n-    type MaybeT<T> = Option<T>;\n-}\n-```\n+    /// Suggests importing a macro from the root of the crate rather than a module within\n+    /// the crate.\n+    ///\n+    /// ```\n+    /// help: a macro with this name exists at the root of the crate\n+    ///    |\n+    /// LL | use issue_59764::makro;\n+    ///    |     ^^^^^^^^^^^^^^^^^^\n+    ///    |\n+    ///    = note: this could be because a macro annotated with `#[macro_export]` will be exported\n+    ///            at the root of the crate instead of the module where it is defined\n+    /// ```\n+    pub(crate) fn check_for_module_export_macro(\n+        &self,\n+        directive: &'b ImportDirective<'b>,\n+        module: ModuleOrUniformRoot<'b>,\n+        ident: Ident,\n+    ) -> Option<(Option<Suggestion>, Vec<String>)> {\n+        let mut crate_module = if let ModuleOrUniformRoot::Module(module) = module {\n+            module\n+        } else {\n+            return None;\n+        };\n+\n+        while let Some(parent) = crate_module.parent {\n+            crate_module = parent;\n+        }\n \n-Be sure to copy over any bounds as well:\n+        if ModuleOrUniformRoot::same_def(ModuleOrUniformRoot::Module(crate_module), module) {\n+            // Don't make a suggestion if the import was already from the root of the\n+            // crate.\n+            return None;\n+        }\n \n-```\n-fn foo<T: Copy>(x: T) {\n-    fn bar<T: Copy>(y: T) {\n-        // ..\n+        let resolutions = crate_module.resolutions.borrow();\n+        let resolution = resolutions.get(&(ident, MacroNS))?;\n+        let binding = resolution.borrow().binding()?;\n+        if let Def::Macro(_, MacroKind::Bang) = binding.def() {\n+            let module_name = crate_module.kind.name().unwrap();\n+            let import = match directive.subclass {\n+                ImportDirectiveSubclass::SingleImport { source, target, .. } if source != target =>\n+                    format!(\"{} as {}\", source, target),\n+                _ => format!(\"{}\", ident),\n+            };\n+\n+            let mut corrections: Vec<(Span, String)> = Vec::new();\n+            if !directive.is_nested() {\n+                // Assume this is the easy case of `use issue_59764::foo::makro;` and just remove\n+                // intermediate segments.\n+                corrections.push((directive.span, format!(\"{}::{}\", module_name, import)));\n+            } else {\n+                // Find the binding span (and any trailing commas and spaces).\n+                //   ie. `use a::b::{c, d, e};`\n+                //                      ^^^\n+                let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n+                    self.resolver.session, directive.span, directive.use_span,\n+                );\n+                debug!(\"check_for_module_export_macro: found_closing_brace={:?} binding_span={:?}\",\n+                       found_closing_brace, binding_span);\n+\n+                let mut removal_span = binding_span;\n+                if found_closing_brace {\n+                    // If the binding span ended with a closing brace, as in the below example:\n+                    //   ie. `use a::b::{c, d};`\n+                    //                      ^\n+                    // Then expand the span of characters to remove to include the previous\n+                    // binding's trailing comma.\n+                    //   ie. `use a::b::{c, d};`\n+                    //                    ^^^\n+                    if let Some(previous_span) = extend_span_to_previous_binding(\n+                        self.resolver.session, binding_span,\n+                    ) {\n+                        debug!(\"check_for_module_export_macro: previous_span={:?}\", previous_span);\n+                        removal_span = removal_span.with_lo(previous_span.lo());\n+                    }\n+                }\n+                debug!(\"check_for_module_export_macro: removal_span={:?}\", removal_span);\n+\n+                // Remove the `removal_span`.\n+                corrections.push((removal_span, \"\".to_string()));\n+\n+                // Find the span after the crate name and if it has nested imports immediatately\n+                // after the crate name already.\n+                //   ie. `use a::b::{c, d};`\n+                //               ^^^^^^^^^\n+                //   or  `use a::{b, c, d}};`\n+                //               ^^^^^^^^^^^\n+                let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n+                    self.resolver.session, module_name, directive.use_span,\n+                );\n+                debug!(\"check_for_module_export_macro: has_nested={:?} after_crate_name={:?}\",\n+                       has_nested, after_crate_name);\n+\n+                let source_map = self.resolver.session.source_map();\n+\n+                // Add the import to the start, with a `{` if required.\n+                let start_point = source_map.start_point(after_crate_name);\n+                if let Ok(start_snippet) = source_map.span_to_snippet(start_point) {\n+                    corrections.push((\n+                        start_point,\n+                        if has_nested {\n+                            // In this case, `start_snippet` must equal '{'.\n+                            format!(\"{}{}, \", start_snippet, import)\n+                        } else {\n+                            // In this case, add a `{`, then the moved import, then whatever\n+                            // was there before.\n+                            format!(\"{{{}, {}\", import, start_snippet)\n+                        }\n+                    ));\n+                }\n+\n+                // Add a `};` to the end if nested, matching the `{` added at the start.\n+                if !has_nested {\n+                    corrections.push((source_map.end_point(after_crate_name),\n+                                     \"};\".to_string()));\n+                }\n+            }\n+\n+            let suggestion = Some((\n+                corrections,\n+                String::from(\"a macro with this name exists at the root of the crate\"),\n+                Applicability::MaybeIncorrect,\n+            ));\n+            let note = vec![\n+                \"this could be because a macro annotated with `#[macro_export]` will be exported \\\n+                 at the root of the crate instead of the module where it is defined\".to_string(),\n+            ];\n+            Some((suggestion, note))\n+        } else {\n+            None\n+        }\n     }\n-    bar(x);\n }\n-```\n \n-```\n-fn foo<T: Copy>(x: T) {\n-    struct Foo<T: Copy> {\n-        x: T,\n+/// Given a `binding_span` of a binding within a use statement:\n+///\n+/// ```\n+/// use foo::{a, b, c};\n+///              ^\n+/// ```\n+///\n+/// then return the span until the next binding or the end of the statement:\n+///\n+/// ```\n+/// use foo::{a, b, c};\n+///              ^^^\n+/// ```\n+pub(crate) fn find_span_of_binding_until_next_binding(\n+    sess: &Session,\n+    binding_span: Span,\n+    use_span: Span,\n+) -> (bool, Span) {\n+    let source_map = sess.source_map();\n+\n+    // Find the span of everything after the binding.\n+    //   ie. `a, e};` or `a};`\n+    let binding_until_end = binding_span.with_hi(use_span.hi());\n+\n+    // Find everything after the binding but not including the binding.\n+    //   ie. `, e};` or `};`\n+    let after_binding_until_end = binding_until_end.with_lo(binding_span.hi());\n+\n+    // Keep characters in the span until we encounter something that isn't a comma or\n+    // whitespace.\n+    //   ie. `, ` or ``.\n+    //\n+    // Also note whether a closing brace character was encountered. If there\n+    // was, then later go backwards to remove any trailing commas that are left.\n+    let mut found_closing_brace = false;\n+    let after_binding_until_next_binding = source_map.span_take_while(\n+        after_binding_until_end,\n+        |&ch| {\n+            if ch == '}' { found_closing_brace = true; }\n+            ch == ' ' || ch == ','\n+        }\n+    );\n+\n+    // Combine the two spans.\n+    //   ie. `a, ` or `a`.\n+    //\n+    // Removing these would leave `issue_52891::{d, e};` or `issue_52891::{d, e, };`\n+    let span = binding_span.with_hi(after_binding_until_next_binding.hi());\n+\n+    (found_closing_brace, span)\n+}\n+\n+/// Given a `binding_span`, return the span through to the comma or opening brace of the previous\n+/// binding.\n+///\n+/// ```\n+/// use foo::a::{a, b, c};\n+///               ^^--- binding span\n+///               |\n+///               returned span\n+///\n+/// use foo::{a, b, c};\n+///           --- binding span\n+/// ```\n+pub(crate) fn extend_span_to_previous_binding(\n+    sess: &Session,\n+    binding_span: Span,\n+) -> Option<Span> {\n+    let source_map = sess.source_map();\n+\n+    // `prev_source` will contain all of the source that came before the span.\n+    // Then split based on a command and take the first (ie. closest to our span)\n+    // snippet. In the example, this is a space.\n+    let prev_source = source_map.span_to_prev_source(binding_span).ok()?;\n+\n+    let prev_comma = prev_source.rsplit(',').collect::<Vec<_>>();\n+    let prev_starting_brace = prev_source.rsplit('{').collect::<Vec<_>>();\n+    if prev_comma.len() <= 1 || prev_starting_brace.len() <= 1 {\n+        return None;\n     }\n-}\n-```\n \n-This may require additional type hints in the function body.\n+    let prev_comma = prev_comma.first().unwrap();\n+    let prev_starting_brace = prev_starting_brace.first().unwrap();\n \n-In case the item is a function inside an `impl`, defining a private helper\n-function might be easier:\n-\n-```\n-# struct Foo<T>(T);\n-impl<T> Foo<T> {\n-    pub fn foo(&self, x: T) {\n-        self.bar(x);\n-    }\n-\n-    fn bar(&self, y: T) {\n-        // ..\n+    // If the amount of source code before the comma is greater than\n+    // the amount of source code before the starting brace then we've only\n+    // got one item in the nested item (eg. `issue_52891::{self}`).\n+    if prev_comma.len() > prev_starting_brace.len() {\n+        return None;\n     }\n-}\n-```\n-\n-For default impls in traits, the private helper solution won't work, however\n-closures or copying the parameters should still work.\n-\"##,\n-\n-E0403: r##\"\n-Some type parameters have the same name.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0403\n-fn foo<T, T>(s: T, u: T) {} // error: the name `T` is already used for a type\n-                            //        parameter in this type parameter list\n-```\n-\n-Please verify that none of the type parameters are misspelled, and rename any\n-clashing parameters. Example:\n-\n-```\n-fn foo<T, Y>(s: T, u: Y) {} // ok!\n-```\n-\"##,\n-\n-E0404: r##\"\n-You tried to use something which is not a trait in a trait position, such as\n-a bound or `impl`.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0404\n-struct Foo;\n-struct Bar;\n-\n-impl Foo for Bar {} // error: `Foo` is not a trait\n-```\n-\n-Another erroneous code example:\n-\n-```compile_fail,E0404\n-struct Foo;\n-\n-fn bar<T: Foo>(t: T) {} // error: `Foo` is not a trait\n-```\n-\n-Please verify that you didn't misspell the trait's name or otherwise use the\n-wrong identifier. Example:\n-\n-```\n-trait Foo {\n-    // some functions\n-}\n-struct Bar;\n-\n-impl Foo for Bar { // ok!\n-    // functions implementation\n-}\n-```\n-\n-or\n-\n-```\n-trait Foo {\n-    // some functions\n-}\n-\n-fn bar<T: Foo>(t: T) {} // ok!\n-```\n-\n-\"##,\n-\n-E0405: r##\"\n-The code refers to a trait that is not in scope.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0405\n-struct Foo;\n-\n-impl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope\n-```\n-\n-Please verify that the name of the trait wasn't misspelled and ensure that it\n-was imported. Example:\n-\n-```\n-# #[cfg(for_demonstration_only)]\n-// solution 1:\n-use some_file::SomeTrait;\n-\n-// solution 2:\n-trait SomeTrait {\n-    // some functions\n-}\n-\n-struct Foo;\n-\n-impl SomeTrait for Foo { // ok!\n-    // implements functions\n-}\n-```\n-\"##,\n-\n-E0407: r##\"\n-A definition of a method not in the implemented trait was given in a trait\n-implementation.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0407\n-trait Foo {\n-    fn a();\n-}\n-\n-struct Bar;\n-\n-impl Foo for Bar {\n-    fn a() {}\n-    fn b() {} // error: method `b` is not a member of trait `Foo`\n-}\n-```\n-\n-Please verify you didn't misspell the method name and you used the correct\n-trait. First example:\n-\n-```\n-trait Foo {\n-    fn a();\n-    fn b();\n-}\n-\n-struct Bar;\n-\n-impl Foo for Bar {\n-    fn a() {}\n-    fn b() {} // ok!\n-}\n-```\n-\n-Second example:\n-\n-```\n-trait Foo {\n-    fn a();\n-}\n-\n-struct Bar;\n-\n-impl Foo for Bar {\n-    fn a() {}\n-}\n-\n-impl Bar {\n-    fn b() {}\n-}\n-```\n-\"##,\n-\n-E0408: r##\"\n-An \"or\" pattern was used where the variable bindings are not consistently bound\n-across patterns.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0408\n-match x {\n-    Some(y) | None => { /* use y */ } // error: variable `y` from pattern #1 is\n-                                      //        not bound in pattern #2\n-    _ => ()\n-}\n-```\n-\n-Here, `y` is bound to the contents of the `Some` and can be used within the\n-block corresponding to the match arm. However, in case `x` is `None`, we have\n-not specified what `y` is, and the block will use a nonexistent variable.\n-\n-To fix this error, either split into multiple match arms:\n-\n-```\n-let x = Some(1);\n-match x {\n-    Some(y) => { /* use y */ }\n-    None => { /* ... */ }\n-}\n-```\n-\n-or, bind the variable to a field of the same type in all sub-patterns of the\n-or pattern:\n-\n-```\n-let x = (0, 2);\n-match x {\n-    (0, y) | (y, 0) => { /* use y */}\n-    _ => {}\n-}\n-```\n-\n-In this example, if `x` matches the pattern `(0, _)`, the second field is set\n-to `y`. If it matches `(_, 0)`, the first field is set to `y`; so in all\n-cases `y` is set to some value.\n-\"##,\n-\n-E0409: r##\"\n-An \"or\" pattern was used where the variable bindings are not consistently bound\n-across patterns.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0409\n-let x = (0, 2);\n-match x {\n-    (0, ref y) | (y, 0) => { /* use y */} // error: variable `y` is bound with\n-                                          //        different mode in pattern #2\n-                                          //        than in pattern #1\n-    _ => ()\n-}\n-```\n-\n-Here, `y` is bound by-value in one case and by-reference in the other.\n-\n-To fix this error, just use the same mode in both cases.\n-Generally using `ref` or `ref mut` where not already used will fix this:\n-\n-```\n-let x = (0, 2);\n-match x {\n-    (0, ref y) | (ref y, 0) => { /* use y */}\n-    _ => ()\n-}\n-```\n-\n-Alternatively, split the pattern:\n-\n-```\n-let x = (0, 2);\n-match x {\n-    (y, 0) => { /* use y */ }\n-    (0, ref y) => { /* use y */}\n-    _ => ()\n-}\n-```\n-\"##,\n-\n-E0411: r##\"\n-The `Self` keyword was used outside an impl, trait, or type definition.\n-\n-Erroneous code example:\n \n-```compile_fail,E0411\n-<Self>::foo; // error: use of `Self` outside of an impl, trait, or type\n-             // definition\n-```\n-\n-The `Self` keyword represents the current type, which explains why it can only\n-be used inside an impl, trait, or type definition. It gives access to the\n-associated items of a type:\n-\n-```\n-trait Foo {\n-    type Bar;\n-}\n-\n-trait Baz : Foo {\n-    fn bar() -> Self::Bar; // like this\n-}\n-```\n-\n-However, be careful when two types have a common associated type:\n-\n-```compile_fail\n-trait Foo {\n-    type Bar;\n-}\n-\n-trait Foo2 {\n-    type Bar;\n-}\n-\n-trait Baz : Foo + Foo2 {\n-    fn bar() -> Self::Bar;\n-    // error: ambiguous associated type `Bar` in bounds of `Self`\n-}\n-```\n-\n-This problem can be solved by specifying from which trait we want to use the\n-`Bar` type:\n-\n-```\n-trait Foo {\n-    type Bar;\n-}\n-\n-trait Foo2 {\n-    type Bar;\n-}\n-\n-trait Baz : Foo + Foo2 {\n-    fn bar() -> <Self as Foo>::Bar; // ok!\n-}\n-```\n-\"##,\n-\n-E0412: r##\"\n-The type name used is not in scope.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0412\n-impl Something {} // error: type name `Something` is not in scope\n-\n-// or:\n-\n-trait Foo {\n-    fn bar(N); // error: type name `N` is not in scope\n-}\n-\n-// or:\n-\n-fn foo(x: T) {} // type name `T` is not in scope\n-```\n-\n-To fix this error, please verify you didn't misspell the type name, you did\n-declare it or imported it into the scope. Examples:\n-\n-```\n-struct Something;\n-\n-impl Something {} // ok!\n-\n-// or:\n-\n-trait Foo {\n-    type N;\n-\n-    fn bar(_: Self::N); // ok!\n-}\n-\n-// or:\n-\n-fn foo<T>(x: T) {} // ok!\n-```\n-\n-Another case that causes this error is when a type is imported into a parent\n-module. To fix this, you can follow the suggestion and use File directly or\n-`use super::File;` which will import the types from the parent namespace. An\n-example that causes this error is below:\n-\n-```compile_fail,E0412\n-use std::fs::File;\n-\n-mod foo {\n-    fn some_function(f: File) {}\n-}\n-```\n-\n-```\n-use std::fs::File;\n-\n-mod foo {\n-    // either\n-    use super::File;\n-    // or\n-    // use std::fs::File;\n-    fn foo(f: File) {}\n-}\n-# fn main() {} // don't insert it for us; that'll break imports\n-```\n-\"##,\n-\n-E0415: r##\"\n-More than one function parameter have the same name.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0415\n-fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than\n-                          //        once in this parameter list\n-```\n-\n-Please verify you didn't misspell parameters' name. Example:\n-\n-```\n-fn foo(f: i32, g: i32) {} // ok!\n-```\n-\"##,\n-\n-E0416: r##\"\n-An identifier is bound more than once in a pattern.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0416\n-match (1, 2) {\n-    (x, x) => {} // error: identifier `x` is bound more than once in the\n-                 //        same pattern\n-}\n-```\n-\n-Please verify you didn't misspell identifiers' name. Example:\n-\n-```\n-match (1, 2) {\n-    (x, y) => {} // ok!\n-}\n-```\n-\n-Or maybe did you mean to unify? Consider using a guard:\n-\n-```\n-# let (A, B, C) = (1, 2, 3);\n-match (A, B, C) {\n-    (x, x2, see) if x == x2 => { /* A and B are equal, do one thing */ }\n-    (y, z, see) => { /* A and B unequal; do another thing */ }\n-}\n-```\n-\"##,\n-\n-E0422: r##\"\n-You are trying to use an identifier that is either undefined or not a struct.\n-Erroneous code example:\n-\n-```compile_fail,E0422\n-fn main () {\n-    let x = Foo { x: 1, y: 2 };\n-}\n-```\n-\n-In this case, `Foo` is undefined, so it inherently isn't anything, and\n-definitely not a struct.\n-\n-```compile_fail\n-fn main () {\n-    let foo = 1;\n-    let x = foo { x: 1, y: 2 };\n-}\n-```\n-\n-In this case, `foo` is defined, but is not a struct, so Rust can't use it as\n-one.\n-\"##,\n-\n-E0423: r##\"\n-An identifier was used like a function name or a value was expected and the\n-identifier exists but it belongs to a different namespace.\n-\n-For (an erroneous) example, here a `struct` variant name were used as a\n-function:\n-\n-```compile_fail,E0423\n-struct Foo { a: bool };\n-\n-let f = Foo();\n-// error: expected function, found `Foo`\n-// `Foo` is a struct name, but this expression uses it like a function name\n-```\n-\n-Please verify you didn't misspell the name of what you actually wanted to use\n-here. Example:\n-\n-```\n-fn Foo() -> u32 { 0 }\n-\n-let f = Foo(); // ok!\n-```\n-\n-It is common to forget the trailing `!` on macro invocations, which would also\n-yield this error:\n-\n-```compile_fail,E0423\n-println(\"\");\n-// error: expected function, found macro `println`\n-// did you mean `println!(...)`? (notice the trailing `!`)\n-```\n-\n-Another case where this error is emitted is when a value is expected, but\n-something else is found:\n-\n-```compile_fail,E0423\n-pub mod a {\n-    pub const I: i32 = 1;\n-}\n-\n-fn h1() -> i32 {\n-    a.I\n-    //~^ ERROR expected value, found module `a`\n-    // did you mean `a::I`?\n-}\n-```\n-\"##,\n-\n-E0424: r##\"\n-The `self` keyword was used in a static method.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0424\n-struct Foo;\n-\n-impl Foo {\n-    fn bar(self) {}\n-\n-    fn foo() {\n-        self.bar(); // error: `self` is not available in a static method.\n-    }\n-}\n-```\n-\n-Please check if the method's argument list should have contained `self`,\n-`&self`, or `&mut self` (in case you didn't want to create a static\n-method), and add it if so. Example:\n-\n-```\n-struct Foo;\n-\n-impl Foo {\n-    fn bar(self) {}\n-\n-    fn foo(self) {\n-        self.bar(); // ok!\n-    }\n-}\n-```\n-\"##,\n-\n-E0425: r##\"\n-An unresolved name was used.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0425\n-something_that_doesnt_exist::foo;\n-// error: unresolved name `something_that_doesnt_exist::foo`\n-\n-// or:\n-\n-trait Foo {\n-    fn bar() {\n-        Self; // error: unresolved name `Self`\n-    }\n-}\n-\n-// or:\n-\n-let x = unknown_variable;  // error: unresolved name `unknown_variable`\n-```\n-\n-Please verify that the name wasn't misspelled and ensure that the\n-identifier being referred to is valid for the given situation. Example:\n-\n-```\n-enum something_that_does_exist {\n-    Foo,\n-}\n-```\n-\n-Or:\n-\n-```\n-mod something_that_does_exist {\n-    pub static foo : i32 = 0i32;\n-}\n-\n-something_that_does_exist::foo; // ok!\n-```\n-\n-Or:\n-\n-```\n-let unknown_variable = 12u32;\n-let x = unknown_variable; // ok!\n-```\n-\n-If the item is not defined in the current module, it must be imported using a\n-`use` statement, like so:\n-\n-```\n-# mod foo { pub fn bar() {} }\n-# fn main() {\n-use foo::bar;\n-bar();\n-# }\n-```\n-\n-If the item you are importing is not defined in some super-module of the\n-current module, then it must also be declared as public (e.g., `pub fn`).\n-\"##,\n-\n-E0426: r##\"\n-An undeclared label was used.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0426\n-loop {\n-    break 'a; // error: use of undeclared label `'a`\n-}\n-```\n-\n-Please verify you spelt or declare the label correctly. Example:\n-\n-```\n-'a: loop {\n-    break 'a; // ok!\n-}\n-```\n-\"##,\n-\n-E0428: r##\"\n-A type or module has been defined more than once.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0428\n-struct Bar;\n-struct Bar; // error: duplicate definition of value `Bar`\n-```\n-\n-Please verify you didn't misspell the type/module's name or remove/rename the\n-duplicated one. Example:\n-\n-```\n-struct Bar;\n-struct Bar2; // ok!\n-```\n-\"##,\n-\n-E0429: r##\"\n-The `self` keyword cannot appear alone as the last segment in a `use`\n-declaration.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0429\n-use std::fmt::self; // error: `self` imports are only allowed within a { } list\n-```\n-\n-To use a namespace itself in addition to some of its members, `self` may appear\n-as part of a brace-enclosed list of imports:\n-\n-```\n-use std::fmt::{self, Debug};\n-```\n-\n-If you only want to import the namespace, do so directly:\n-\n-```\n-use std::fmt;\n-```\n-\"##,\n-\n-E0430: r##\"\n-The `self` import appears more than once in the list.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0430\n-use something::{self, self}; // error: `self` import can only appear once in\n-                             //        the list\n-```\n-\n-Please verify you didn't misspell the import name or remove the duplicated\n-`self` import. Example:\n-\n-```\n-# mod something {}\n-# fn main() {\n-use something::{self}; // ok!\n-# }\n-```\n-\"##,\n-\n-E0431: r##\"\n-An invalid `self` import was made.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0431\n-use {self}; // error: `self` import can only appear in an import list with a\n-            //        non-empty prefix\n-```\n-\n-You cannot import the current module into itself, please remove this import\n-or verify you didn't misspell it.\n-\"##,\n-\n-E0432: r##\"\n-An import was unresolved.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0432\n-use something::Foo; // error: unresolved import `something::Foo`.\n-```\n-\n-Paths in `use` statements are relative to the crate root. To import items\n-relative to the current and parent modules, use the `self::` and `super::`\n-prefixes, respectively. Also verify that you didn't misspell the import\n-name and that the import exists in the module from where you tried to\n-import it. Example:\n-\n-```\n-use self::something::Foo; // ok!\n-\n-mod something {\n-    pub struct Foo;\n-}\n-# fn main() {}\n-```\n-\n-Or, if you tried to use a module from an external crate, you may have missed\n-the `extern crate` declaration (which is usually placed in the crate root):\n-\n-```\n-extern crate core; // Required to use the `core` crate\n-\n-use core::any;\n-# fn main() {}\n-```\n-\"##,\n-\n-E0433: r##\"\n-An undeclared type or module was used.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0433\n-let map = HashMap::new();\n-// error: failed to resolve: use of undeclared type or module `HashMap`\n-```\n-\n-Please verify you didn't misspell the type/module's name or that you didn't\n-forget to import it:\n-\n-\n-```\n-use std::collections::HashMap; // HashMap has been imported.\n-let map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n-```\n-\"##,\n-\n-E0434: r##\"\n-This error indicates that a variable usage inside an inner function is invalid\n-because the variable comes from a dynamic environment. Inner functions do not\n-have access to their containing environment.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0434\n-fn foo() {\n-    let y = 5;\n-    fn bar() -> u32 {\n-        y // error: can't capture dynamic environment in a fn item; use the\n-          //        || { ... } closure form instead.\n-    }\n-}\n-```\n-\n-Functions do not capture local variables. To fix this error, you can replace the\n-function with a closure:\n-\n-```\n-fn foo() {\n-    let y = 5;\n-    let bar = || {\n-        y\n-    };\n-}\n-```\n-\n-or replace the captured variable with a constant or a static item:\n-\n-```\n-fn foo() {\n-    static mut X: u32 = 4;\n-    const Y: u32 = 5;\n-    fn bar() -> u32 {\n-        unsafe {\n-            X = 3;\n+    Some(binding_span.with_lo(BytePos(\n+        // Take away the number of bytes for the characters we've found and an\n+        // extra for the comma.\n+        binding_span.lo().0 - (prev_comma.as_bytes().len() as u32) - 1\n+    )))\n+}\n+\n+/// Given a `use_span` of a binding within a use statement, returns the highlighted span and if\n+/// it is a nested use tree.\n+///\n+/// ```\n+/// use foo::a::{b, c};\n+///          ^^^^^^^^^^ // false\n+///\n+/// use foo::{a, b, c};\n+///          ^^^^^^^^^^ // true\n+///\n+/// use foo::{a, b::{c, d}};\n+///          ^^^^^^^^^^^^^^^ // true\n+/// ```\n+fn find_span_immediately_after_crate_name(\n+    sess: &Session,\n+    module_name: Symbol,\n+    use_span: Span,\n+) -> (bool, Span) {\n+    debug!(\"find_span_immediately_after_crate_name: module_name={:?} use_span={:?}\",\n+           module_name, use_span);\n+    let source_map = sess.source_map();\n+\n+    // Using `use issue_59764::foo::{baz, makro};` as an example throughout..\n+    let mut num_colons = 0;\n+    // Find second colon.. `use issue_59764:`\n+    let until_second_colon = source_map.span_take_while(use_span, |c| {\n+        if *c == ':' { num_colons += 1; }\n+        match c {\n+            ':' if num_colons == 2 => false,\n+            _ => true,\n         }\n-        Y\n-    }\n-}\n-```\n-\"##,\n-\n-E0435: r##\"\n-A non-constant value was used in a constant expression.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0435\n-let foo = 42;\n-let a: [u8; foo]; // error: attempt to use a non-constant value in a constant\n-```\n-\n-To fix this error, please replace the value with a constant. Example:\n-\n-```\n-let a: [u8; 42]; // ok!\n-```\n-\n-Or:\n-\n-```\n-const FOO: usize = 42;\n-let a: [u8; FOO]; // ok!\n-```\n-\"##,\n-\n-E0437: r##\"\n-Trait implementations can only implement associated types that are members of\n-the trait in question. This error indicates that you attempted to implement\n-an associated type whose name does not match the name of any associated type\n-in the trait.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0437\n-trait Foo {}\n-\n-impl Foo for i32 {\n-    type Bar = bool;\n-}\n-```\n-\n-The solution to this problem is to remove the extraneous associated type:\n-\n-```\n-trait Foo {}\n-\n-impl Foo for i32 {}\n-```\n-\"##,\n-\n-E0438: r##\"\n-Trait implementations can only implement associated constants that are\n-members of the trait in question. This error indicates that you\n-attempted to implement an associated constant whose name does not\n-match the name of any associated constant in the trait.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0438\n-trait Foo {}\n-\n-impl Foo for i32 {\n-    const BAR: bool = true;\n-}\n-```\n-\n-The solution to this problem is to remove the extraneous associated constant:\n-\n-```\n-trait Foo {}\n-\n-impl Foo for i32 {}\n-```\n-\"##,\n-\n-E0466: r##\"\n-Macro import declarations were malformed.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0466\n-#[macro_use(a_macro(another_macro))] // error: invalid import declaration\n-extern crate core as some_crate;\n-\n-#[macro_use(i_want = \"some_macros\")] // error: invalid import declaration\n-extern crate core as another_crate;\n-```\n-\n-This is a syntax error at the level of attribute declarations. The proper\n-syntax for macro imports is the following:\n-\n-```ignore (cannot-doctest-multicrate-project)\n-// In some_crate:\n-#[macro_export]\n-macro_rules! get_tacos {\n-    ...\n-}\n-\n-#[macro_export]\n-macro_rules! get_pimientos {\n-    ...\n-}\n-\n-// In your crate:\n-#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and\n-extern crate some_crate;               // `get_pimientos` macros from some_crate\n-```\n-\n-If you would like to import all exported macros, write `macro_use` with no\n-arguments.\n-\"##,\n-\n-E0468: r##\"\n-A non-root module attempts to import macros from another crate.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0468\n-mod foo {\n-    #[macro_use(debug_assert)]  // error: must be at crate root to import\n-    extern crate core;          //        macros from another crate\n-    fn run_macro() { debug_assert!(true); }\n-}\n-```\n-\n-Only `extern crate` imports at the crate root level are allowed to import\n-macros.\n-\n-Either move the macro import to crate root or do without the foreign macros.\n-This will work:\n-\n-```\n-#[macro_use(debug_assert)]\n-extern crate core;\n-\n-mod foo {\n-    fn run_macro() { debug_assert!(true); }\n-}\n-# fn main() {}\n-```\n-\"##,\n-\n-E0469: r##\"\n-A macro listed for import was not found.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0469\n-#[macro_use(drink, be_merry)] // error: imported macro not found\n-extern crate alloc;\n-\n-fn main() {\n-    // ...\n-}\n-```\n-\n-Either the listed macro is not contained in the imported crate, or it is not\n-exported from the given crate.\n-\n-This could be caused by a typo. Did you misspell the macro's name?\n-\n-Double-check the names of the macros listed for import, and that the crate\n-in question exports them.\n-\n-A working version would be:\n-\n-```ignore (cannot-doctest-multicrate-project)\n-// In some_crate crate:\n-#[macro_export]\n-macro_rules! eat {\n-    ...\n-}\n-\n-#[macro_export]\n-macro_rules! drink {\n-    ...\n-}\n-\n-// In your crate:\n-#[macro_use(eat, drink)]\n-extern crate some_crate; //ok!\n-```\n-\"##,\n-\n-E0530: r##\"\n-A binding shadowed something it shouldn't.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0530\n-static TEST: i32 = 0;\n-\n-let r: (i32, i32) = (0, 0);\n-match r {\n-    TEST => {} // error: match bindings cannot shadow statics\n-}\n-```\n-\n-To fix this error, just change the binding's name in order to avoid shadowing\n-one of the following:\n-\n-* struct name\n-* struct/enum variant\n-* static\n-* const\n-* associated const\n-\n-Fixed example:\n-\n-```\n-static TEST: i32 = 0;\n-\n-let r: (i32, i32) = (0, 0);\n-match r {\n-    something => {} // ok!\n-}\n-```\n-\"##,\n-\n-E0532: r##\"\n-Pattern arm did not match expected kind.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0532\n-enum State {\n-    Succeeded,\n-    Failed(String),\n-}\n-\n-fn print_on_failure(state: &State) {\n-    match *state {\n-        // error: expected unit struct/variant or constant, found tuple\n-        //        variant `State::Failed`\n-        State::Failed => println!(\"Failed\"),\n-        _ => ()\n-    }\n-}\n-```\n-\n-To fix this error, ensure the match arm kind is the same as the expression\n-matched.\n-\n-Fixed example:\n-\n-```\n-enum State {\n-    Succeeded,\n-    Failed(String),\n-}\n-\n-fn print_on_failure(state: &State) {\n-    match *state {\n-        State::Failed(ref msg) => println!(\"Failed with {}\", msg),\n-        _ => ()\n-    }\n-}\n-```\n-\"##,\n-\n-E0603: r##\"\n-A private item was used outside its scope.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0603\n-mod SomeModule {\n-    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n-                                            // can't use it outside of the\n-                                            // `SomeModule` module.\n-}\n-\n-println!(\"const value: {}\", SomeModule::PRIVATE); // error: constant `PRIVATE`\n-                                                  //        is private\n-```\n-\n-In order to fix this error, you need to make the item public by using the `pub`\n-keyword. Example:\n-\n-```\n-mod SomeModule {\n-    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n-                                                // `pub` keyword.\n-}\n-\n-println!(\"const value: {}\", SomeModule::PRIVATE); // ok!\n-```\n-\"##,\n-\n-E0659: r##\"\n-An item usage is ambiguous.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0659\n-pub mod moon {\n-    pub fn foo() {}\n-}\n-\n-pub mod earth {\n-    pub fn foo() {}\n-}\n-\n-mod collider {\n-    pub use moon::*;\n-    pub use earth::*;\n-}\n-\n-fn main() {\n-    collider::foo(); // ERROR: `foo` is ambiguous\n-}\n-```\n-\n-This error generally appears when two items with the same name are imported into\n-a module. Here, the `foo` functions are imported and reexported from the\n-`collider` module and therefore, when we're using `collider::foo()`, both\n-functions collide.\n-\n-To solve this error, the best solution is generally to keep the path before the\n-item when using it. Example:\n-\n-```\n-pub mod moon {\n-    pub fn foo() {}\n-}\n-\n-pub mod earth {\n-    pub fn foo() {}\n-}\n-\n-mod collider {\n-    pub use moon;\n-    pub use earth;\n-}\n-\n-fn main() {\n-    collider::moon::foo(); // ok!\n-    collider::earth::foo(); // ok!\n-}\n-```\n-\"##,\n-\n-}\n-\n-register_diagnostics! {\n-//  E0153, unused error code\n-//  E0157, unused error code\n-//  E0257,\n-//  E0258,\n-//  E0402, // cannot use an outer type parameter in this context\n-//  E0406, merged into 420\n-//  E0410, merged into 408\n-//  E0413, merged into 530\n-//  E0414, merged into 530\n-//  E0417, merged into 532\n-//  E0418, merged into 532\n-//  E0419, merged into 531\n-//  E0420, merged into 532\n-//  E0421, merged into 531\n-    E0531, // unresolved pattern path kind `name`\n-//  E0427, merged into 530\n-//  E0467, removed\n-//  E0470, removed\n-    E0573,\n-    E0574,\n-    E0575,\n-    E0576,\n-    E0577,\n-    E0578,\n+    });\n+    // Find everything after the second colon.. `foo::{baz, makro};`\n+    let from_second_colon = use_span.with_lo(until_second_colon.hi() + BytePos(1));\n+\n+    let mut found_a_non_whitespace_character = false;\n+    // Find the first non-whitespace character in `from_second_colon`.. `f`\n+    let after_second_colon = source_map.span_take_while(from_second_colon, |c| {\n+        if found_a_non_whitespace_character { return false; }\n+        if !c.is_whitespace() { found_a_non_whitespace_character = true; }\n+        true\n+    });\n+\n+    // Find the first `{` in from_second_colon.. `foo::{`\n+    let next_left_bracket = source_map.span_through_char(from_second_colon, '{');\n+\n+    (next_left_bracket == after_second_colon, from_second_colon)\n }"}, {"sha": "5c095994a1bbd422f3a55d4b883b7de11db6ec37", "filename": "src/librustc_resolve/error_codes.rs", "status": "added", "additions": 1672, "deletions": 0, "changes": 1672, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_resolve%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_resolve%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_codes.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -0,0 +1,1672 @@\n+#![allow(non_snake_case)]\n+\n+use syntax::{register_diagnostic, register_diagnostics, register_long_diagnostics};\n+\n+// Error messages for EXXXX errors.  Each message should start and end with a\n+// new line, and be wrapped to 80 characters.  In vim you can `:set tw=80` and\n+// use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n+register_long_diagnostics! {\n+\n+E0128: r##\"\n+Type parameter defaults can only use parameters that occur before them.\n+Erroneous code example:\n+\n+```compile_fail,E0128\n+struct Foo<T=U, U=()> {\n+    field1: T,\n+    filed2: U,\n+}\n+// error: type parameters with a default cannot use forward declared\n+// identifiers\n+```\n+\n+Since type parameters are evaluated in-order, you may be able to fix this issue\n+by doing:\n+\n+```\n+struct Foo<U=(), T=U> {\n+    field1: T,\n+    filed2: U,\n+}\n+```\n+\n+Please also verify that this wasn't because of a name-clash and rename the type\n+parameter if so.\n+\"##,\n+\n+E0154: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Imports (`use` statements) are not allowed after non-item statements, such as\n+variable declarations and expression statements.\n+\n+Here is an example that demonstrates the error:\n+\n+```\n+fn f() {\n+    // Variable declaration before import\n+    let x = 0;\n+    use std::io::Read;\n+    // ...\n+}\n+```\n+\n+The solution is to declare the imports at the top of the block, function, or\n+file.\n+\n+Here is the previous example again, with the correct order:\n+\n+```\n+fn f() {\n+    use std::io::Read;\n+    let x = 0;\n+    // ...\n+}\n+```\n+\n+See the Declaration Statements section of the reference for more information\n+about what constitutes an Item declaration and what does not:\n+\n+https://doc.rust-lang.org/reference.html#statements\n+\"##,\n+\n+E0251: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Two items of the same name cannot be imported without rebinding one of the\n+items under a new local name.\n+\n+An example of this error:\n+\n+```\n+use foo::baz;\n+use bar::*; // error, do `use foo::baz as quux` instead on the previous line\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\"##,\n+\n+E0252: r##\"\n+Two items of the same name cannot be imported without rebinding one of the\n+items under a new local name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0252\n+use foo::baz;\n+use bar::baz; // error, do `use bar::baz as quux` instead\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\n+You can use aliases in order to fix this error. Example:\n+\n+```\n+use foo::baz as foo_baz;\n+use bar::baz; // ok!\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\n+Or you can reference the item with its parent:\n+\n+```\n+use bar::baz;\n+\n+fn main() {\n+    let x = foo::baz; // ok!\n+}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\"##,\n+\n+E0253: r##\"\n+Attempt was made to import an unimportable value. This can happen when trying\n+to import a method from a trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0253\n+mod foo {\n+    pub trait MyTrait {\n+        fn do_something();\n+    }\n+}\n+\n+use foo::MyTrait::do_something;\n+// error: `do_something` is not directly importable\n+\n+fn main() {}\n+```\n+\n+It's invalid to directly import methods belonging to a trait or concrete type.\n+\"##,\n+\n+E0254: r##\"\n+Attempt was made to import an item whereas an extern crate with this name has\n+already been imported.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0254\n+extern crate core;\n+\n+mod foo {\n+    pub trait core {\n+        fn do_something();\n+    }\n+}\n+\n+use foo::core;  // error: an extern crate named `core` has already\n+                //        been imported in this module\n+\n+fn main() {}\n+```\n+\n+To fix this issue, you have to rename at least one of the two imports.\n+Example:\n+\n+```\n+extern crate core as libcore; // ok!\n+\n+mod foo {\n+    pub trait core {\n+        fn do_something();\n+    }\n+}\n+\n+use foo::core;\n+\n+fn main() {}\n+```\n+\"##,\n+\n+E0255: r##\"\n+You can't import a value whose name is the same as another value defined in the\n+module.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0255\n+use bar::foo; // error: an item named `foo` is already in scope\n+\n+fn foo() {}\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {}\n+```\n+\n+You can use aliases in order to fix this error. Example:\n+\n+```\n+use bar::foo as bar_foo; // ok!\n+\n+fn foo() {}\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {}\n+```\n+\n+Or you can reference the item with its parent:\n+\n+```\n+fn foo() {}\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {\n+    bar::foo(); // we get the item by referring to its parent\n+}\n+```\n+\"##,\n+\n+E0256: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You can't import a type or module when the name of the item being imported is\n+the same as another type or submodule defined in the module.\n+\n+An example of this error:\n+\n+```compile_fail\n+use foo::Bar; // error\n+\n+type Bar = u32;\n+\n+mod foo {\n+    pub mod Bar { }\n+}\n+\n+fn main() {}\n+```\n+\"##,\n+\n+E0259: r##\"\n+The name chosen for an external crate conflicts with another external crate\n+that has been imported into the current module.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0259\n+extern crate core;\n+extern crate std as core;\n+\n+fn main() {}\n+```\n+\n+The solution is to choose a different name that doesn't conflict with any\n+external crate imported into the current module.\n+\n+Correct example:\n+\n+```\n+extern crate core;\n+extern crate std as other_name;\n+\n+fn main() {}\n+```\n+\"##,\n+\n+E0260: r##\"\n+The name for an item declaration conflicts with an external crate's name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0260\n+extern crate core;\n+\n+struct core;\n+\n+fn main() {}\n+```\n+\n+There are two possible solutions:\n+\n+Solution #1: Rename the item.\n+\n+```\n+extern crate core;\n+\n+struct xyz;\n+```\n+\n+Solution #2: Import the crate with a different name.\n+\n+```\n+extern crate core as xyz;\n+\n+struct abc;\n+```\n+\n+See the Declaration Statements section of the reference for more information\n+about what constitutes an Item declaration and what does not:\n+\n+https://doc.rust-lang.org/reference.html#statements\n+\"##,\n+\n+E0364: r##\"\n+Private items cannot be publicly re-exported. This error indicates that you\n+attempted to `pub use` a type or value that was not itself public.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+mod foo {\n+    const X: u32 = 1;\n+}\n+\n+pub use foo::X;\n+\n+fn main() {}\n+```\n+\n+The solution to this problem is to ensure that the items that you are\n+re-exporting are themselves marked with `pub`:\n+\n+```\n+mod foo {\n+    pub const X: u32 = 1;\n+}\n+\n+pub use foo::X;\n+\n+fn main() {}\n+```\n+\n+See the 'Use Declarations' section of the reference for more information on\n+this topic:\n+\n+https://doc.rust-lang.org/reference.html#use-declarations\n+\"##,\n+\n+E0365: r##\"\n+Private modules cannot be publicly re-exported. This error indicates that you\n+attempted to `pub use` a module that was not itself public.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0365\n+mod foo {\n+    pub const X: u32 = 1;\n+}\n+\n+pub use foo as foo2;\n+\n+fn main() {}\n+```\n+\n+The solution to this problem is to ensure that the module that you are\n+re-exporting is itself marked with `pub`:\n+\n+```\n+pub mod foo {\n+    pub const X: u32 = 1;\n+}\n+\n+pub use foo as foo2;\n+\n+fn main() {}\n+```\n+\n+See the 'Use Declarations' section of the reference for more information\n+on this topic:\n+\n+https://doc.rust-lang.org/reference.html#use-declarations\n+\"##,\n+\n+E0401: r##\"\n+Inner items do not inherit type or const parameters from the functions\n+they are embedded in.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0401\n+fn foo<T>(x: T) {\n+    fn bar(y: T) { // T is defined in the \"outer\" function\n+        // ..\n+    }\n+    bar(x);\n+}\n+```\n+\n+Nor will this:\n+\n+```compile_fail,E0401\n+fn foo<T>(x: T) {\n+    type MaybeT = Option<T>;\n+    // ...\n+}\n+```\n+\n+Or this:\n+\n+```compile_fail,E0401\n+fn foo<T>(x: T) {\n+    struct Foo {\n+        x: T,\n+    }\n+    // ...\n+}\n+```\n+\n+Items inside functions are basically just like top-level items, except\n+that they can only be used from the function they are in.\n+\n+There are a couple of solutions for this.\n+\n+If the item is a function, you may use a closure:\n+\n+```\n+fn foo<T>(x: T) {\n+    let bar = |y: T| { // explicit type annotation may not be necessary\n+        // ..\n+    };\n+    bar(x);\n+}\n+```\n+\n+For a generic item, you can copy over the parameters:\n+\n+```\n+fn foo<T>(x: T) {\n+    fn bar<T>(y: T) {\n+        // ..\n+    }\n+    bar(x);\n+}\n+```\n+\n+```\n+fn foo<T>(x: T) {\n+    type MaybeT<T> = Option<T>;\n+}\n+```\n+\n+Be sure to copy over any bounds as well:\n+\n+```\n+fn foo<T: Copy>(x: T) {\n+    fn bar<T: Copy>(y: T) {\n+        // ..\n+    }\n+    bar(x);\n+}\n+```\n+\n+```\n+fn foo<T: Copy>(x: T) {\n+    struct Foo<T: Copy> {\n+        x: T,\n+    }\n+}\n+```\n+\n+This may require additional type hints in the function body.\n+\n+In case the item is a function inside an `impl`, defining a private helper\n+function might be easier:\n+\n+```\n+# struct Foo<T>(T);\n+impl<T> Foo<T> {\n+    pub fn foo(&self, x: T) {\n+        self.bar(x);\n+    }\n+\n+    fn bar(&self, y: T) {\n+        // ..\n+    }\n+}\n+```\n+\n+For default impls in traits, the private helper solution won't work, however\n+closures or copying the parameters should still work.\n+\"##,\n+\n+E0403: r##\"\n+Some type parameters have the same name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0403\n+fn foo<T, T>(s: T, u: T) {} // error: the name `T` is already used for a type\n+                            //        parameter in this type parameter list\n+```\n+\n+Please verify that none of the type parameters are misspelled, and rename any\n+clashing parameters. Example:\n+\n+```\n+fn foo<T, Y>(s: T, u: Y) {} // ok!\n+```\n+\"##,\n+\n+E0404: r##\"\n+You tried to use something which is not a trait in a trait position, such as\n+a bound or `impl`.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0404\n+struct Foo;\n+struct Bar;\n+\n+impl Foo for Bar {} // error: `Foo` is not a trait\n+```\n+\n+Another erroneous code example:\n+\n+```compile_fail,E0404\n+struct Foo;\n+\n+fn bar<T: Foo>(t: T) {} // error: `Foo` is not a trait\n+```\n+\n+Please verify that you didn't misspell the trait's name or otherwise use the\n+wrong identifier. Example:\n+\n+```\n+trait Foo {\n+    // some functions\n+}\n+struct Bar;\n+\n+impl Foo for Bar { // ok!\n+    // functions implementation\n+}\n+```\n+\n+or\n+\n+```\n+trait Foo {\n+    // some functions\n+}\n+\n+fn bar<T: Foo>(t: T) {} // ok!\n+```\n+\n+\"##,\n+\n+E0405: r##\"\n+The code refers to a trait that is not in scope.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0405\n+struct Foo;\n+\n+impl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope\n+```\n+\n+Please verify that the name of the trait wasn't misspelled and ensure that it\n+was imported. Example:\n+\n+```\n+# #[cfg(for_demonstration_only)]\n+// solution 1:\n+use some_file::SomeTrait;\n+\n+// solution 2:\n+trait SomeTrait {\n+    // some functions\n+}\n+\n+struct Foo;\n+\n+impl SomeTrait for Foo { // ok!\n+    // implements functions\n+}\n+```\n+\"##,\n+\n+E0407: r##\"\n+A definition of a method not in the implemented trait was given in a trait\n+implementation.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0407\n+trait Foo {\n+    fn a();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn a() {}\n+    fn b() {} // error: method `b` is not a member of trait `Foo`\n+}\n+```\n+\n+Please verify you didn't misspell the method name and you used the correct\n+trait. First example:\n+\n+```\n+trait Foo {\n+    fn a();\n+    fn b();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn a() {}\n+    fn b() {} // ok!\n+}\n+```\n+\n+Second example:\n+\n+```\n+trait Foo {\n+    fn a();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn a() {}\n+}\n+\n+impl Bar {\n+    fn b() {}\n+}\n+```\n+\"##,\n+\n+E0408: r##\"\n+An \"or\" pattern was used where the variable bindings are not consistently bound\n+across patterns.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0408\n+match x {\n+    Some(y) | None => { /* use y */ } // error: variable `y` from pattern #1 is\n+                                      //        not bound in pattern #2\n+    _ => ()\n+}\n+```\n+\n+Here, `y` is bound to the contents of the `Some` and can be used within the\n+block corresponding to the match arm. However, in case `x` is `None`, we have\n+not specified what `y` is, and the block will use a nonexistent variable.\n+\n+To fix this error, either split into multiple match arms:\n+\n+```\n+let x = Some(1);\n+match x {\n+    Some(y) => { /* use y */ }\n+    None => { /* ... */ }\n+}\n+```\n+\n+or, bind the variable to a field of the same type in all sub-patterns of the\n+or pattern:\n+\n+```\n+let x = (0, 2);\n+match x {\n+    (0, y) | (y, 0) => { /* use y */}\n+    _ => {}\n+}\n+```\n+\n+In this example, if `x` matches the pattern `(0, _)`, the second field is set\n+to `y`. If it matches `(_, 0)`, the first field is set to `y`; so in all\n+cases `y` is set to some value.\n+\"##,\n+\n+E0409: r##\"\n+An \"or\" pattern was used where the variable bindings are not consistently bound\n+across patterns.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0409\n+let x = (0, 2);\n+match x {\n+    (0, ref y) | (y, 0) => { /* use y */} // error: variable `y` is bound with\n+                                          //        different mode in pattern #2\n+                                          //        than in pattern #1\n+    _ => ()\n+}\n+```\n+\n+Here, `y` is bound by-value in one case and by-reference in the other.\n+\n+To fix this error, just use the same mode in both cases.\n+Generally using `ref` or `ref mut` where not already used will fix this:\n+\n+```\n+let x = (0, 2);\n+match x {\n+    (0, ref y) | (ref y, 0) => { /* use y */}\n+    _ => ()\n+}\n+```\n+\n+Alternatively, split the pattern:\n+\n+```\n+let x = (0, 2);\n+match x {\n+    (y, 0) => { /* use y */ }\n+    (0, ref y) => { /* use y */}\n+    _ => ()\n+}\n+```\n+\"##,\n+\n+E0411: r##\"\n+The `Self` keyword was used outside an impl, trait, or type definition.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0411\n+<Self>::foo; // error: use of `Self` outside of an impl, trait, or type\n+             // definition\n+```\n+\n+The `Self` keyword represents the current type, which explains why it can only\n+be used inside an impl, trait, or type definition. It gives access to the\n+associated items of a type:\n+\n+```\n+trait Foo {\n+    type Bar;\n+}\n+\n+trait Baz : Foo {\n+    fn bar() -> Self::Bar; // like this\n+}\n+```\n+\n+However, be careful when two types have a common associated type:\n+\n+```compile_fail\n+trait Foo {\n+    type Bar;\n+}\n+\n+trait Foo2 {\n+    type Bar;\n+}\n+\n+trait Baz : Foo + Foo2 {\n+    fn bar() -> Self::Bar;\n+    // error: ambiguous associated type `Bar` in bounds of `Self`\n+}\n+```\n+\n+This problem can be solved by specifying from which trait we want to use the\n+`Bar` type:\n+\n+```\n+trait Foo {\n+    type Bar;\n+}\n+\n+trait Foo2 {\n+    type Bar;\n+}\n+\n+trait Baz : Foo + Foo2 {\n+    fn bar() -> <Self as Foo>::Bar; // ok!\n+}\n+```\n+\"##,\n+\n+E0412: r##\"\n+The type name used is not in scope.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0412\n+impl Something {} // error: type name `Something` is not in scope\n+\n+// or:\n+\n+trait Foo {\n+    fn bar(N); // error: type name `N` is not in scope\n+}\n+\n+// or:\n+\n+fn foo(x: T) {} // type name `T` is not in scope\n+```\n+\n+To fix this error, please verify you didn't misspell the type name, you did\n+declare it or imported it into the scope. Examples:\n+\n+```\n+struct Something;\n+\n+impl Something {} // ok!\n+\n+// or:\n+\n+trait Foo {\n+    type N;\n+\n+    fn bar(_: Self::N); // ok!\n+}\n+\n+// or:\n+\n+fn foo<T>(x: T) {} // ok!\n+```\n+\n+Another case that causes this error is when a type is imported into a parent\n+module. To fix this, you can follow the suggestion and use File directly or\n+`use super::File;` which will import the types from the parent namespace. An\n+example that causes this error is below:\n+\n+```compile_fail,E0412\n+use std::fs::File;\n+\n+mod foo {\n+    fn some_function(f: File) {}\n+}\n+```\n+\n+```\n+use std::fs::File;\n+\n+mod foo {\n+    // either\n+    use super::File;\n+    // or\n+    // use std::fs::File;\n+    fn foo(f: File) {}\n+}\n+# fn main() {} // don't insert it for us; that'll break imports\n+```\n+\"##,\n+\n+E0415: r##\"\n+More than one function parameter have the same name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0415\n+fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than\n+                          //        once in this parameter list\n+```\n+\n+Please verify you didn't misspell parameters' name. Example:\n+\n+```\n+fn foo(f: i32, g: i32) {} // ok!\n+```\n+\"##,\n+\n+E0416: r##\"\n+An identifier is bound more than once in a pattern.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0416\n+match (1, 2) {\n+    (x, x) => {} // error: identifier `x` is bound more than once in the\n+                 //        same pattern\n+}\n+```\n+\n+Please verify you didn't misspell identifiers' name. Example:\n+\n+```\n+match (1, 2) {\n+    (x, y) => {} // ok!\n+}\n+```\n+\n+Or maybe did you mean to unify? Consider using a guard:\n+\n+```\n+# let (A, B, C) = (1, 2, 3);\n+match (A, B, C) {\n+    (x, x2, see) if x == x2 => { /* A and B are equal, do one thing */ }\n+    (y, z, see) => { /* A and B unequal; do another thing */ }\n+}\n+```\n+\"##,\n+\n+E0422: r##\"\n+You are trying to use an identifier that is either undefined or not a struct.\n+Erroneous code example:\n+\n+```compile_fail,E0422\n+fn main () {\n+    let x = Foo { x: 1, y: 2 };\n+}\n+```\n+\n+In this case, `Foo` is undefined, so it inherently isn't anything, and\n+definitely not a struct.\n+\n+```compile_fail\n+fn main () {\n+    let foo = 1;\n+    let x = foo { x: 1, y: 2 };\n+}\n+```\n+\n+In this case, `foo` is defined, but is not a struct, so Rust can't use it as\n+one.\n+\"##,\n+\n+E0423: r##\"\n+An identifier was used like a function name or a value was expected and the\n+identifier exists but it belongs to a different namespace.\n+\n+For (an erroneous) example, here a `struct` variant name were used as a\n+function:\n+\n+```compile_fail,E0423\n+struct Foo { a: bool };\n+\n+let f = Foo();\n+// error: expected function, found `Foo`\n+// `Foo` is a struct name, but this expression uses it like a function name\n+```\n+\n+Please verify you didn't misspell the name of what you actually wanted to use\n+here. Example:\n+\n+```\n+fn Foo() -> u32 { 0 }\n+\n+let f = Foo(); // ok!\n+```\n+\n+It is common to forget the trailing `!` on macro invocations, which would also\n+yield this error:\n+\n+```compile_fail,E0423\n+println(\"\");\n+// error: expected function, found macro `println`\n+// did you mean `println!(...)`? (notice the trailing `!`)\n+```\n+\n+Another case where this error is emitted is when a value is expected, but\n+something else is found:\n+\n+```compile_fail,E0423\n+pub mod a {\n+    pub const I: i32 = 1;\n+}\n+\n+fn h1() -> i32 {\n+    a.I\n+    //~^ ERROR expected value, found module `a`\n+    // did you mean `a::I`?\n+}\n+```\n+\"##,\n+\n+E0424: r##\"\n+The `self` keyword was used in a static method.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0424\n+struct Foo;\n+\n+impl Foo {\n+    fn bar(self) {}\n+\n+    fn foo() {\n+        self.bar(); // error: `self` is not available in a static method.\n+    }\n+}\n+```\n+\n+Please check if the method's argument list should have contained `self`,\n+`&self`, or `&mut self` (in case you didn't want to create a static\n+method), and add it if so. Example:\n+\n+```\n+struct Foo;\n+\n+impl Foo {\n+    fn bar(self) {}\n+\n+    fn foo(self) {\n+        self.bar(); // ok!\n+    }\n+}\n+```\n+\"##,\n+\n+E0425: r##\"\n+An unresolved name was used.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0425\n+something_that_doesnt_exist::foo;\n+// error: unresolved name `something_that_doesnt_exist::foo`\n+\n+// or:\n+\n+trait Foo {\n+    fn bar() {\n+        Self; // error: unresolved name `Self`\n+    }\n+}\n+\n+// or:\n+\n+let x = unknown_variable;  // error: unresolved name `unknown_variable`\n+```\n+\n+Please verify that the name wasn't misspelled and ensure that the\n+identifier being referred to is valid for the given situation. Example:\n+\n+```\n+enum something_that_does_exist {\n+    Foo,\n+}\n+```\n+\n+Or:\n+\n+```\n+mod something_that_does_exist {\n+    pub static foo : i32 = 0i32;\n+}\n+\n+something_that_does_exist::foo; // ok!\n+```\n+\n+Or:\n+\n+```\n+let unknown_variable = 12u32;\n+let x = unknown_variable; // ok!\n+```\n+\n+If the item is not defined in the current module, it must be imported using a\n+`use` statement, like so:\n+\n+```\n+# mod foo { pub fn bar() {} }\n+# fn main() {\n+use foo::bar;\n+bar();\n+# }\n+```\n+\n+If the item you are importing is not defined in some super-module of the\n+current module, then it must also be declared as public (e.g., `pub fn`).\n+\"##,\n+\n+E0426: r##\"\n+An undeclared label was used.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0426\n+loop {\n+    break 'a; // error: use of undeclared label `'a`\n+}\n+```\n+\n+Please verify you spelt or declare the label correctly. Example:\n+\n+```\n+'a: loop {\n+    break 'a; // ok!\n+}\n+```\n+\"##,\n+\n+E0428: r##\"\n+A type or module has been defined more than once.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0428\n+struct Bar;\n+struct Bar; // error: duplicate definition of value `Bar`\n+```\n+\n+Please verify you didn't misspell the type/module's name or remove/rename the\n+duplicated one. Example:\n+\n+```\n+struct Bar;\n+struct Bar2; // ok!\n+```\n+\"##,\n+\n+E0429: r##\"\n+The `self` keyword cannot appear alone as the last segment in a `use`\n+declaration.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0429\n+use std::fmt::self; // error: `self` imports are only allowed within a { } list\n+```\n+\n+To use a namespace itself in addition to some of its members, `self` may appear\n+as part of a brace-enclosed list of imports:\n+\n+```\n+use std::fmt::{self, Debug};\n+```\n+\n+If you only want to import the namespace, do so directly:\n+\n+```\n+use std::fmt;\n+```\n+\"##,\n+\n+E0430: r##\"\n+The `self` import appears more than once in the list.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0430\n+use something::{self, self}; // error: `self` import can only appear once in\n+                             //        the list\n+```\n+\n+Please verify you didn't misspell the import name or remove the duplicated\n+`self` import. Example:\n+\n+```\n+# mod something {}\n+# fn main() {\n+use something::{self}; // ok!\n+# }\n+```\n+\"##,\n+\n+E0431: r##\"\n+An invalid `self` import was made.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0431\n+use {self}; // error: `self` import can only appear in an import list with a\n+            //        non-empty prefix\n+```\n+\n+You cannot import the current module into itself, please remove this import\n+or verify you didn't misspell it.\n+\"##,\n+\n+E0432: r##\"\n+An import was unresolved.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0432\n+use something::Foo; // error: unresolved import `something::Foo`.\n+```\n+\n+Paths in `use` statements are relative to the crate root. To import items\n+relative to the current and parent modules, use the `self::` and `super::`\n+prefixes, respectively. Also verify that you didn't misspell the import\n+name and that the import exists in the module from where you tried to\n+import it. Example:\n+\n+```\n+use self::something::Foo; // ok!\n+\n+mod something {\n+    pub struct Foo;\n+}\n+# fn main() {}\n+```\n+\n+Or, if you tried to use a module from an external crate, you may have missed\n+the `extern crate` declaration (which is usually placed in the crate root):\n+\n+```\n+extern crate core; // Required to use the `core` crate\n+\n+use core::any;\n+# fn main() {}\n+```\n+\"##,\n+\n+E0433: r##\"\n+An undeclared type or module was used.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0433\n+let map = HashMap::new();\n+// error: failed to resolve: use of undeclared type or module `HashMap`\n+```\n+\n+Please verify you didn't misspell the type/module's name or that you didn't\n+forget to import it:\n+\n+\n+```\n+use std::collections::HashMap; // HashMap has been imported.\n+let map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n+```\n+\"##,\n+\n+E0434: r##\"\n+This error indicates that a variable usage inside an inner function is invalid\n+because the variable comes from a dynamic environment. Inner functions do not\n+have access to their containing environment.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0434\n+fn foo() {\n+    let y = 5;\n+    fn bar() -> u32 {\n+        y // error: can't capture dynamic environment in a fn item; use the\n+          //        || { ... } closure form instead.\n+    }\n+}\n+```\n+\n+Functions do not capture local variables. To fix this error, you can replace the\n+function with a closure:\n+\n+```\n+fn foo() {\n+    let y = 5;\n+    let bar = || {\n+        y\n+    };\n+}\n+```\n+\n+or replace the captured variable with a constant or a static item:\n+\n+```\n+fn foo() {\n+    static mut X: u32 = 4;\n+    const Y: u32 = 5;\n+    fn bar() -> u32 {\n+        unsafe {\n+            X = 3;\n+        }\n+        Y\n+    }\n+}\n+```\n+\"##,\n+\n+E0435: r##\"\n+A non-constant value was used in a constant expression.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0435\n+let foo = 42;\n+let a: [u8; foo]; // error: attempt to use a non-constant value in a constant\n+```\n+\n+To fix this error, please replace the value with a constant. Example:\n+\n+```\n+let a: [u8; 42]; // ok!\n+```\n+\n+Or:\n+\n+```\n+const FOO: usize = 42;\n+let a: [u8; FOO]; // ok!\n+```\n+\"##,\n+\n+E0437: r##\"\n+Trait implementations can only implement associated types that are members of\n+the trait in question. This error indicates that you attempted to implement\n+an associated type whose name does not match the name of any associated type\n+in the trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0437\n+trait Foo {}\n+\n+impl Foo for i32 {\n+    type Bar = bool;\n+}\n+```\n+\n+The solution to this problem is to remove the extraneous associated type:\n+\n+```\n+trait Foo {}\n+\n+impl Foo for i32 {}\n+```\n+\"##,\n+\n+E0438: r##\"\n+Trait implementations can only implement associated constants that are\n+members of the trait in question. This error indicates that you\n+attempted to implement an associated constant whose name does not\n+match the name of any associated constant in the trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0438\n+trait Foo {}\n+\n+impl Foo for i32 {\n+    const BAR: bool = true;\n+}\n+```\n+\n+The solution to this problem is to remove the extraneous associated constant:\n+\n+```\n+trait Foo {}\n+\n+impl Foo for i32 {}\n+```\n+\"##,\n+\n+E0466: r##\"\n+Macro import declarations were malformed.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0466\n+#[macro_use(a_macro(another_macro))] // error: invalid import declaration\n+extern crate core as some_crate;\n+\n+#[macro_use(i_want = \"some_macros\")] // error: invalid import declaration\n+extern crate core as another_crate;\n+```\n+\n+This is a syntax error at the level of attribute declarations. The proper\n+syntax for macro imports is the following:\n+\n+```ignore (cannot-doctest-multicrate-project)\n+// In some_crate:\n+#[macro_export]\n+macro_rules! get_tacos {\n+    ...\n+}\n+\n+#[macro_export]\n+macro_rules! get_pimientos {\n+    ...\n+}\n+\n+// In your crate:\n+#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and\n+extern crate some_crate;               // `get_pimientos` macros from some_crate\n+```\n+\n+If you would like to import all exported macros, write `macro_use` with no\n+arguments.\n+\"##,\n+\n+E0468: r##\"\n+A non-root module attempts to import macros from another crate.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0468\n+mod foo {\n+    #[macro_use(debug_assert)]  // error: must be at crate root to import\n+    extern crate core;          //        macros from another crate\n+    fn run_macro() { debug_assert!(true); }\n+}\n+```\n+\n+Only `extern crate` imports at the crate root level are allowed to import\n+macros.\n+\n+Either move the macro import to crate root or do without the foreign macros.\n+This will work:\n+\n+```\n+#[macro_use(debug_assert)]\n+extern crate core;\n+\n+mod foo {\n+    fn run_macro() { debug_assert!(true); }\n+}\n+# fn main() {}\n+```\n+\"##,\n+\n+E0469: r##\"\n+A macro listed for import was not found.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0469\n+#[macro_use(drink, be_merry)] // error: imported macro not found\n+extern crate alloc;\n+\n+fn main() {\n+    // ...\n+}\n+```\n+\n+Either the listed macro is not contained in the imported crate, or it is not\n+exported from the given crate.\n+\n+This could be caused by a typo. Did you misspell the macro's name?\n+\n+Double-check the names of the macros listed for import, and that the crate\n+in question exports them.\n+\n+A working version would be:\n+\n+```ignore (cannot-doctest-multicrate-project)\n+// In some_crate crate:\n+#[macro_export]\n+macro_rules! eat {\n+    ...\n+}\n+\n+#[macro_export]\n+macro_rules! drink {\n+    ...\n+}\n+\n+// In your crate:\n+#[macro_use(eat, drink)]\n+extern crate some_crate; //ok!\n+```\n+\"##,\n+\n+E0530: r##\"\n+A binding shadowed something it shouldn't.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0530\n+static TEST: i32 = 0;\n+\n+let r: (i32, i32) = (0, 0);\n+match r {\n+    TEST => {} // error: match bindings cannot shadow statics\n+}\n+```\n+\n+To fix this error, just change the binding's name in order to avoid shadowing\n+one of the following:\n+\n+* struct name\n+* struct/enum variant\n+* static\n+* const\n+* associated const\n+\n+Fixed example:\n+\n+```\n+static TEST: i32 = 0;\n+\n+let r: (i32, i32) = (0, 0);\n+match r {\n+    something => {} // ok!\n+}\n+```\n+\"##,\n+\n+E0532: r##\"\n+Pattern arm did not match expected kind.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0532\n+enum State {\n+    Succeeded,\n+    Failed(String),\n+}\n+\n+fn print_on_failure(state: &State) {\n+    match *state {\n+        // error: expected unit struct/variant or constant, found tuple\n+        //        variant `State::Failed`\n+        State::Failed => println!(\"Failed\"),\n+        _ => ()\n+    }\n+}\n+```\n+\n+To fix this error, ensure the match arm kind is the same as the expression\n+matched.\n+\n+Fixed example:\n+\n+```\n+enum State {\n+    Succeeded,\n+    Failed(String),\n+}\n+\n+fn print_on_failure(state: &State) {\n+    match *state {\n+        State::Failed(ref msg) => println!(\"Failed with {}\", msg),\n+        _ => ()\n+    }\n+}\n+```\n+\"##,\n+\n+E0603: r##\"\n+A private item was used outside its scope.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0603\n+mod SomeModule {\n+    const PRIVATE: u32 = 0x_a_bad_1dea_u32; // This const is private, so we\n+                                            // can't use it outside of the\n+                                            // `SomeModule` module.\n+}\n+\n+println!(\"const value: {}\", SomeModule::PRIVATE); // error: constant `PRIVATE`\n+                                                  //        is private\n+```\n+\n+In order to fix this error, you need to make the item public by using the `pub`\n+keyword. Example:\n+\n+```\n+mod SomeModule {\n+    pub const PRIVATE: u32 = 0x_a_bad_1dea_u32; // We set it public by using the\n+                                                // `pub` keyword.\n+}\n+\n+println!(\"const value: {}\", SomeModule::PRIVATE); // ok!\n+```\n+\"##,\n+\n+E0659: r##\"\n+An item usage is ambiguous.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0659\n+pub mod moon {\n+    pub fn foo() {}\n+}\n+\n+pub mod earth {\n+    pub fn foo() {}\n+}\n+\n+mod collider {\n+    pub use moon::*;\n+    pub use earth::*;\n+}\n+\n+fn main() {\n+    collider::foo(); // ERROR: `foo` is ambiguous\n+}\n+```\n+\n+This error generally appears when two items with the same name are imported into\n+a module. Here, the `foo` functions are imported and reexported from the\n+`collider` module and therefore, when we're using `collider::foo()`, both\n+functions collide.\n+\n+To solve this error, the best solution is generally to keep the path before the\n+item when using it. Example:\n+\n+```\n+pub mod moon {\n+    pub fn foo() {}\n+}\n+\n+pub mod earth {\n+    pub fn foo() {}\n+}\n+\n+mod collider {\n+    pub use moon;\n+    pub use earth;\n+}\n+\n+fn main() {\n+    collider::moon::foo(); // ok!\n+    collider::earth::foo(); // ok!\n+}\n+```\n+\"##,\n+\n+}\n+\n+register_diagnostics! {\n+//  E0153, unused error code\n+//  E0157, unused error code\n+//  E0257,\n+//  E0258,\n+//  E0402, // cannot use an outer type parameter in this context\n+//  E0406, merged into 420\n+//  E0410, merged into 408\n+//  E0413, merged into 530\n+//  E0414, merged into 530\n+//  E0417, merged into 532\n+//  E0418, merged into 532\n+//  E0419, merged into 531\n+//  E0420, merged into 532\n+//  E0421, merged into 531\n+    E0531, // unresolved pattern path kind `name`\n+//  E0427, merged into 530\n+//  E0467, removed\n+//  E0470, removed\n+    E0573,\n+    E0574,\n+    E0575,\n+    E0576,\n+    E0577,\n+    E0578,\n+}"}, {"sha": "9e3894dab0da0b40f1bc418edc006725a9385cd0", "filename": "src/librustc_resolve/error_reporting.rs", "status": "removed", "additions": 0, "deletions": 856, "changes": 856, "blob_url": "https://github.com/rust-lang/rust/blob/bf843eb9c2d48a80a5992a5d60858e27269f9575/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf843eb9c2d48a80a5992a5d60858e27269f9575/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=bf843eb9c2d48a80a5992a5d60858e27269f9575", "patch": "@@ -1,856 +0,0 @@\n-use std::cmp::Reverse;\n-\n-use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n-use log::debug;\n-use rustc::hir::def::{self, CtorKind, Namespace::*};\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::session::{Session, config::nightly_options};\n-use syntax::ast::{self, Expr, ExprKind, Ident};\n-use syntax::ext::base::MacroKind;\n-use syntax::symbol::{Symbol, keywords};\n-use syntax_pos::{BytePos, Span};\n-\n-type Def = def::Def<ast::NodeId>;\n-\n-use crate::macros::ParentScope;\n-use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n-use crate::{import_candidate_to_enum_paths, is_self_type, is_self_value, path_names_to_string};\n-use crate::{AssocSuggestion, CrateLint, ImportSuggestion, ModuleOrUniformRoot, PathResult,\n-            PathSource, Resolver, Segment, Suggestion};\n-\n-impl<'a> Resolver<'a> {\n-    /// Handles error reporting for `smart_resolve_path_fragment` function.\n-    /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n-    pub(crate) fn smart_resolve_report_errors(\n-        &mut self,\n-        path: &[Segment],\n-        span: Span,\n-        source: PathSource<'_>,\n-        def: Option<Def>,\n-    ) -> (DiagnosticBuilder<'a>, Vec<ImportSuggestion>) {\n-        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n-        let ns = source.namespace();\n-        let is_expected = &|def| source.is_expected(def);\n-        let is_enum_variant = &|def| if let Def::Variant(..) = def { true } else { false };\n-\n-        // Make the base error.\n-        let expected = source.descr_expected();\n-        let path_str = Segment::names_to_string(path);\n-        let item_str = path.last().unwrap().ident;\n-        let code = source.error_code(def.is_some());\n-        let (base_msg, fallback_label, base_span) = if let Some(def) = def {\n-            (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n-                format!(\"not a {}\", expected),\n-                span)\n-        } else {\n-            let item_span = path.last().unwrap().ident.span;\n-            let (mod_prefix, mod_str) = if path.len() == 1 {\n-                (String::new(), \"this scope\".to_string())\n-            } else if path.len() == 2 && path[0].ident.name == keywords::PathRoot.name() {\n-                (String::new(), \"the crate root\".to_string())\n-            } else {\n-                let mod_path = &path[..path.len() - 1];\n-                let mod_prefix = match self.resolve_path_without_parent_scope(\n-                    mod_path, Some(TypeNS), false, span, CrateLint::No\n-                ) {\n-                    PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                        module.def(),\n-                    _ => None,\n-                }.map_or(String::new(), |def| format!(\"{} \", def.kind_name()));\n-                (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n-            };\n-            (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n-                format!(\"not found in {}\", mod_str),\n-                item_span)\n-        };\n-\n-        let code = DiagnosticId::Error(code.into());\n-        let mut err = self.session.struct_span_err_with_code(base_span, &base_msg, code);\n-\n-        // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n-        if [\"this\", \"my\"].contains(&&*item_str.as_str())\n-            && self.self_value_is_available(path[0].ident.span, span) {\n-            err.span_suggestion(\n-                span,\n-                \"did you mean\",\n-                \"self\".to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-\n-        // Emit special messages for unresolved `Self` and `self`.\n-        if is_self_type(path, ns) {\n-            __diagnostic_used!(E0411);\n-            err.code(DiagnosticId::Error(\"E0411\".into()));\n-            err.span_label(span, format!(\"`Self` is only available in impls, traits, \\\n-                                          and type definitions\"));\n-            return (err, Vec::new());\n-        }\n-        if is_self_value(path, ns) {\n-            debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n-\n-            __diagnostic_used!(E0424);\n-            err.code(DiagnosticId::Error(\"E0424\".into()));\n-            err.span_label(span, match source {\n-                PathSource::Pat => {\n-                    format!(\"`self` value is a keyword \\\n-                             and may not be bound to \\\n-                             variables or shadowed\")\n-                }\n-                _ => {\n-                    format!(\"`self` value is a keyword \\\n-                             only available in methods \\\n-                             with `self` parameter\")\n-                }\n-            });\n-            return (err, Vec::new());\n-        }\n-\n-        // Try to lookup name in more relaxed fashion for better error reporting.\n-        let ident = path.last().unwrap().ident;\n-        let candidates = self.lookup_import_candidates(ident, ns, is_expected)\n-            .drain(..)\n-            .filter(|ImportSuggestion { did, .. }| {\n-                match (did, def.and_then(|def| def.opt_def_id())) {\n-                    (Some(suggestion_did), Some(actual_did)) => *suggestion_did != actual_did,\n-                    _ => true,\n-                }\n-            })\n-            .collect::<Vec<_>>();\n-        if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n-            let enum_candidates =\n-                self.lookup_import_candidates(ident, ns, is_enum_variant);\n-            let mut enum_candidates = enum_candidates.iter()\n-                .map(|suggestion| {\n-                    import_candidate_to_enum_paths(&suggestion)\n-                }).collect::<Vec<_>>();\n-            enum_candidates.sort();\n-\n-            if !enum_candidates.is_empty() {\n-                // Contextualize for E0412 \"cannot find type\", but don't belabor the point\n-                // (that it's a variant) for E0573 \"expected type, found variant\".\n-                let preamble = if def.is_none() {\n-                    let others = match enum_candidates.len() {\n-                        1 => String::new(),\n-                        2 => \" and 1 other\".to_owned(),\n-                        n => format!(\" and {} others\", n)\n-                    };\n-                    format!(\"there is an enum variant `{}`{}; \",\n-                            enum_candidates[0].0, others)\n-                } else {\n-                    String::new()\n-                };\n-                let msg = format!(\"{}try using the variant's enum\", preamble);\n-\n-                err.span_suggestions(\n-                    span,\n-                    &msg,\n-                    enum_candidates.into_iter()\n-                        .map(|(_variant_path, enum_ty_path)| enum_ty_path)\n-                        // Variants re-exported in prelude doesn't mean `prelude::v1` is the\n-                        // type name!\n-                        // FIXME: is there a more principled way to do this that\n-                        // would work for other re-exports?\n-                        .filter(|enum_ty_path| enum_ty_path != \"std::prelude::v1\")\n-                        // Also write `Option` rather than `std::prelude::v1::Option`.\n-                        .map(|enum_ty_path| {\n-                            // FIXME #56861: DRY-er prelude filtering.\n-                            enum_ty_path.trim_start_matches(\"std::prelude::v1::\").to_owned()\n-                        }),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-        if path.len() == 1 && self.self_type_is_available(span) {\n-            if let Some(candidate) = self.lookup_assoc_candidate(ident, ns, is_expected) {\n-                let self_is_available = self.self_value_is_available(path[0].ident.span, span);\n-                match candidate {\n-                    AssocSuggestion::Field => {\n-                        err.span_suggestion(\n-                            span,\n-                            \"try\",\n-                            format!(\"self.{}\", path_str),\n-                            Applicability::MachineApplicable,\n-                        );\n-                        if !self_is_available {\n-                            err.span_label(span, format!(\"`self` value is a keyword \\\n-                                                         only available in \\\n-                                                         methods with `self` parameter\"));\n-                        }\n-                    }\n-                    AssocSuggestion::MethodWithSelf if self_is_available => {\n-                        err.span_suggestion(\n-                            span,\n-                            \"try\",\n-                            format!(\"self.{}\", path_str),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                    AssocSuggestion::MethodWithSelf | AssocSuggestion::AssocItem => {\n-                        err.span_suggestion(\n-                            span,\n-                            \"try\",\n-                            format!(\"Self::{}\", path_str),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                }\n-                return (err, candidates);\n-            }\n-        }\n-\n-        let mut levenshtein_worked = false;\n-\n-        // Try Levenshtein algorithm.\n-        let suggestion = self.lookup_typo_candidate(path, ns, is_expected, span);\n-        if let Some(suggestion) = suggestion {\n-            let msg = format!(\n-                \"{} {} with a similar name exists\",\n-                suggestion.article, suggestion.kind\n-            );\n-            err.span_suggestion(\n-                ident_span,\n-                &msg,\n-                suggestion.candidate.to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-\n-            levenshtein_worked = true;\n-        }\n-\n-        // Try context-dependent help if relaxed lookup didn't work.\n-        if let Some(def) = def {\n-            if self.smart_resolve_context_dependent_help(&mut err,\n-                                                         span,\n-                                                         source,\n-                                                         def,\n-                                                         &path_str,\n-                                                         &fallback_label) {\n-                return (err, candidates);\n-            }\n-        }\n-\n-        // Fallback label.\n-        if !levenshtein_worked {\n-            err.span_label(base_span, fallback_label);\n-            self.type_ascription_suggestion(&mut err, base_span);\n-        }\n-        (err, candidates)\n-    }\n-\n-    /// Provides context-dependent help for errors reported by the `smart_resolve_path_fragment`\n-    /// function.\n-    /// Returns `true` if able to provide context-dependent help.\n-    fn smart_resolve_context_dependent_help(\n-        &mut self,\n-        err: &mut DiagnosticBuilder<'a>,\n-        span: Span,\n-        source: PathSource<'_>,\n-        def: Def,\n-        path_str: &str,\n-        fallback_label: &str,\n-    ) -> bool {\n-        let ns = source.namespace();\n-        let is_expected = &|def| source.is_expected(def);\n-\n-        let path_sep = |err: &mut DiagnosticBuilder<'_>, expr: &Expr| match expr.node {\n-            ExprKind::Field(_, ident) => {\n-                err.span_suggestion(\n-                    expr.span,\n-                    \"use the path separator to refer to an item\",\n-                    format!(\"{}::{}\", path_str, ident),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                true\n-            }\n-            ExprKind::MethodCall(ref segment, ..) => {\n-                let span = expr.span.with_hi(segment.ident.span.hi());\n-                err.span_suggestion(\n-                    span,\n-                    \"use the path separator to refer to an item\",\n-                    format!(\"{}::{}\", path_str, segment.ident),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                true\n-            }\n-            _ => false,\n-        };\n-\n-        match (def, source) {\n-            (Def::Macro(..), _) => {\n-                err.span_suggestion(\n-                    span,\n-                    \"use `!` to invoke the macro\",\n-                    format!(\"{}!\", path_str),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                if path_str == \"try\" && span.rust_2015() {\n-                    err.note(\"if you want the `try` keyword, you need to be in the 2018 edition\");\n-                }\n-            }\n-            (Def::TyAlias(..), PathSource::Trait(_)) => {\n-                err.span_label(span, \"type aliases cannot be used as traits\");\n-                if nightly_options::is_nightly_build() {\n-                    err.note(\"did you mean to use a trait alias?\");\n-                }\n-            }\n-            (Def::Mod(..), PathSource::Expr(Some(parent))) => if !path_sep(err, &parent) {\n-                return false;\n-            },\n-            (Def::Enum(..), PathSource::TupleStruct)\n-                | (Def::Enum(..), PathSource::Expr(..))  => {\n-                if let Some(variants) = self.collect_enum_variants(def) {\n-                    if !variants.is_empty() {\n-                        let msg = if variants.len() == 1 {\n-                            \"try using the enum's variant\"\n-                        } else {\n-                            \"try using one of the enum's variants\"\n-                        };\n-\n-                        err.span_suggestions(\n-                            span,\n-                            msg,\n-                            variants.iter().map(path_names_to_string),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                } else {\n-                    err.note(\"did you mean to use one of the enum's variants?\");\n-                }\n-            },\n-            (Def::Struct(def_id), _) if ns == ValueNS => {\n-                if let Some((ctor_def, ctor_vis))\n-                        = self.struct_constructors.get(&def_id).cloned() {\n-                    let accessible_ctor = self.is_accessible(ctor_vis);\n-                    if is_expected(ctor_def) && !accessible_ctor {\n-                        err.span_label(\n-                            span,\n-                            format!(\"constructor is not visible here due to private fields\"),\n-                        );\n-                    }\n-                } else {\n-                    // HACK(estebank): find a better way to figure out that this was a\n-                    // parser issue where a struct literal is being used on an expression\n-                    // where a brace being opened means a block is being started. Look\n-                    // ahead for the next text to see if `span` is followed by a `{`.\n-                    let sm = self.session.source_map();\n-                    let mut sp = span;\n-                    loop {\n-                        sp = sm.next_point(sp);\n-                        match sm.span_to_snippet(sp) {\n-                            Ok(ref snippet) => {\n-                                if snippet.chars().any(|c| { !c.is_whitespace() }) {\n-                                    break;\n-                                }\n-                            }\n-                            _ => break,\n-                        }\n-                    }\n-                    let followed_by_brace = match sm.span_to_snippet(sp) {\n-                        Ok(ref snippet) if snippet == \"{\" => true,\n-                        _ => false,\n-                    };\n-                    // In case this could be a struct literal that needs to be surrounded\n-                    // by parenthesis, find the appropriate span.\n-                    let mut i = 0;\n-                    let mut closing_brace = None;\n-                    loop {\n-                        sp = sm.next_point(sp);\n-                        match sm.span_to_snippet(sp) {\n-                            Ok(ref snippet) => {\n-                                if snippet == \"}\" {\n-                                    let sp = span.to(sp);\n-                                    if let Ok(snippet) = sm.span_to_snippet(sp) {\n-                                        closing_brace = Some((sp, snippet));\n-                                    }\n-                                    break;\n-                                }\n-                            }\n-                            _ => break,\n-                        }\n-                        i += 1;\n-                        // The bigger the span, the more likely we're incorrect --\n-                        // bound it to 100 chars long.\n-                        if i > 100 {\n-                            break;\n-                        }\n-                    }\n-                    match source {\n-                        PathSource::Expr(Some(parent)) => if !path_sep(err, &parent) {\n-                            err.span_label(\n-                                span,\n-                                format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n-                            );\n-                        }\n-                        PathSource::Expr(None) if followed_by_brace == true => {\n-                            if let Some((sp, snippet)) = closing_brace {\n-                                err.span_suggestion(\n-                                    sp,\n-                                    \"surround the struct literal with parenthesis\",\n-                                    format!(\"({})\", snippet),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            } else {\n-                                err.span_label(\n-                                    span,\n-                                    format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n-                                );\n-                            }\n-                        },\n-                        _ => {\n-                            err.span_label(\n-                                span,\n-                                format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n-                            );\n-                        },\n-                    }\n-                }\n-            }\n-            (Def::Union(..), _) |\n-            (Def::Variant(..), _) |\n-            (Def::Ctor(_, _, CtorKind::Fictive), _) if ns == ValueNS => {\n-                err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str));\n-            }\n-            (Def::SelfTy(..), _) if ns == ValueNS => {\n-                err.span_label(span, fallback_label);\n-                err.note(\"can't use `Self` as a constructor, you must use the implemented struct\");\n-            }\n-            (Def::TyAlias(_), _) | (Def::AssociatedTy(..), _) if ns == ValueNS => {\n-                err.note(\"can't use a type alias as a constructor\");\n-            }\n-            _ => return false,\n-        }\n-        true\n-    }\n-}\n-\n-impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n-    /// Adds suggestions for a path that cannot be resolved.\n-    pub(crate) fn make_path_suggestion(\n-        &mut self,\n-        span: Span,\n-        mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n-        debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n-\n-        match (path.get(0), path.get(1)) {\n-            // `{{root}}::ident::...` on both editions.\n-            // On 2015 `{{root}}` is usually added implicitly.\n-            (Some(fst), Some(snd)) if fst.ident.name == keywords::PathRoot.name() &&\n-                                      !snd.ident.is_path_segment_keyword() => {}\n-            // `ident::...` on 2018.\n-            (Some(fst), _) if fst.ident.span.rust_2018() &&\n-                              !fst.ident.is_path_segment_keyword() => {\n-                // Insert a placeholder that's later replaced by `self`/`super`/etc.\n-                path.insert(0, Segment::from_ident(keywords::Invalid.ident()));\n-            }\n-            _ => return None,\n-        }\n-\n-        self.make_missing_self_suggestion(span, path.clone(), parent_scope)\n-            .or_else(|| self.make_missing_crate_suggestion(span, path.clone(), parent_scope))\n-            .or_else(|| self.make_missing_super_suggestion(span, path.clone(), parent_scope))\n-            .or_else(|| self.make_external_crate_suggestion(span, path, parent_scope))\n-    }\n-\n-    /// Suggest a missing `self::` if that resolves to an correct module.\n-    ///\n-    /// ```\n-    ///    |\n-    /// LL | use foo::Bar;\n-    ///    |     ^^^ did you mean `self::foo`?\n-    /// ```\n-    fn make_missing_self_suggestion(\n-        &mut self,\n-        span: Span,\n-        mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n-        // Replace first ident with `self` and check if that is valid.\n-        path[0].ident.name = keywords::SelfLower.name();\n-        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n-        debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n-        if let PathResult::Module(..) = result {\n-            Some((path, Vec::new()))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Suggests a missing `crate::` if that resolves to an correct module.\n-    ///\n-    /// ```\n-    ///    |\n-    /// LL | use foo::Bar;\n-    ///    |     ^^^ did you mean `crate::foo`?\n-    /// ```\n-    fn make_missing_crate_suggestion(\n-        &mut self,\n-        span: Span,\n-        mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n-        // Replace first ident with `crate` and check if that is valid.\n-        path[0].ident.name = keywords::Crate.name();\n-        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n-        debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n-        if let PathResult::Module(..) = result {\n-            Some((\n-                path,\n-                vec![\n-                    \"`use` statements changed in Rust 2018; read more at \\\n-                     <https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-\\\n-                     clarity.html>\".to_string()\n-                ],\n-            ))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Suggests a missing `super::` if that resolves to an correct module.\n-    ///\n-    /// ```\n-    ///    |\n-    /// LL | use foo::Bar;\n-    ///    |     ^^^ did you mean `super::foo`?\n-    /// ```\n-    fn make_missing_super_suggestion(\n-        &mut self,\n-        span: Span,\n-        mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n-        // Replace first ident with `crate` and check if that is valid.\n-        path[0].ident.name = keywords::Super.name();\n-        let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n-        debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n-        if let PathResult::Module(..) = result {\n-            Some((path, Vec::new()))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Suggests a missing external crate name if that resolves to an correct module.\n-    ///\n-    /// ```\n-    ///    |\n-    /// LL | use foobar::Baz;\n-    ///    |     ^^^^^^ did you mean `baz::foobar`?\n-    /// ```\n-    ///\n-    /// Used when importing a submodule of an external crate but missing that crate's\n-    /// name as the first part of path.\n-    fn make_external_crate_suggestion(\n-        &mut self,\n-        span: Span,\n-        mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Vec<String>)> {\n-        if path[1].ident.span.rust_2015() {\n-            return None;\n-        }\n-\n-        // Sort extern crate names in reverse order to get\n-        // 1) some consistent ordering for emitted dignostics, and\n-        // 2) `std` suggestions before `core` suggestions.\n-        let mut extern_crate_names =\n-            self.resolver.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();\n-        extern_crate_names.sort_by_key(|name| Reverse(name.as_str()));\n-\n-        for name in extern_crate_names.into_iter() {\n-            // Replace first ident with a crate name and check if that is valid.\n-            path[0].ident.name = name;\n-            let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n-            debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n-                    name, path, result);\n-            if let PathResult::Module(..) = result {\n-                return Some((path, Vec::new()));\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    /// Suggests importing a macro from the root of the crate rather than a module within\n-    /// the crate.\n-    ///\n-    /// ```\n-    /// help: a macro with this name exists at the root of the crate\n-    ///    |\n-    /// LL | use issue_59764::makro;\n-    ///    |     ^^^^^^^^^^^^^^^^^^\n-    ///    |\n-    ///    = note: this could be because a macro annotated with `#[macro_export]` will be exported\n-    ///            at the root of the crate instead of the module where it is defined\n-    /// ```\n-    pub(crate) fn check_for_module_export_macro(\n-        &self,\n-        directive: &'b ImportDirective<'b>,\n-        module: ModuleOrUniformRoot<'b>,\n-        ident: Ident,\n-    ) -> Option<(Option<Suggestion>, Vec<String>)> {\n-        let mut crate_module = if let ModuleOrUniformRoot::Module(module) = module {\n-            module\n-        } else {\n-            return None;\n-        };\n-\n-        while let Some(parent) = crate_module.parent {\n-            crate_module = parent;\n-        }\n-\n-        if ModuleOrUniformRoot::same_def(ModuleOrUniformRoot::Module(crate_module), module) {\n-            // Don't make a suggestion if the import was already from the root of the\n-            // crate.\n-            return None;\n-        }\n-\n-        let resolutions = crate_module.resolutions.borrow();\n-        let resolution = resolutions.get(&(ident, MacroNS))?;\n-        let binding = resolution.borrow().binding()?;\n-        if let Def::Macro(_, MacroKind::Bang) = binding.def() {\n-            let module_name = crate_module.kind.name().unwrap();\n-            let import = match directive.subclass {\n-                ImportDirectiveSubclass::SingleImport { source, target, .. } if source != target =>\n-                    format!(\"{} as {}\", source, target),\n-                _ => format!(\"{}\", ident),\n-            };\n-\n-            let mut corrections: Vec<(Span, String)> = Vec::new();\n-            if !directive.is_nested() {\n-                // Assume this is the easy case of `use issue_59764::foo::makro;` and just remove\n-                // intermediate segments.\n-                corrections.push((directive.span, format!(\"{}::{}\", module_name, import)));\n-            } else {\n-                // Find the binding span (and any trailing commas and spaces).\n-                //   ie. `use a::b::{c, d, e};`\n-                //                      ^^^\n-                let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n-                    self.resolver.session, directive.span, directive.use_span,\n-                );\n-                debug!(\"check_for_module_export_macro: found_closing_brace={:?} binding_span={:?}\",\n-                       found_closing_brace, binding_span);\n-\n-                let mut removal_span = binding_span;\n-                if found_closing_brace {\n-                    // If the binding span ended with a closing brace, as in the below example:\n-                    //   ie. `use a::b::{c, d};`\n-                    //                      ^\n-                    // Then expand the span of characters to remove to include the previous\n-                    // binding's trailing comma.\n-                    //   ie. `use a::b::{c, d};`\n-                    //                    ^^^\n-                    if let Some(previous_span) = extend_span_to_previous_binding(\n-                        self.resolver.session, binding_span,\n-                    ) {\n-                        debug!(\"check_for_module_export_macro: previous_span={:?}\", previous_span);\n-                        removal_span = removal_span.with_lo(previous_span.lo());\n-                    }\n-                }\n-                debug!(\"check_for_module_export_macro: removal_span={:?}\", removal_span);\n-\n-                // Remove the `removal_span`.\n-                corrections.push((removal_span, \"\".to_string()));\n-\n-                // Find the span after the crate name and if it has nested imports immediatately\n-                // after the crate name already.\n-                //   ie. `use a::b::{c, d};`\n-                //               ^^^^^^^^^\n-                //   or  `use a::{b, c, d}};`\n-                //               ^^^^^^^^^^^\n-                let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n-                    self.resolver.session, module_name, directive.use_span,\n-                );\n-                debug!(\"check_for_module_export_macro: has_nested={:?} after_crate_name={:?}\",\n-                       has_nested, after_crate_name);\n-\n-                let source_map = self.resolver.session.source_map();\n-\n-                // Add the import to the start, with a `{` if required.\n-                let start_point = source_map.start_point(after_crate_name);\n-                if let Ok(start_snippet) = source_map.span_to_snippet(start_point) {\n-                    corrections.push((\n-                        start_point,\n-                        if has_nested {\n-                            // In this case, `start_snippet` must equal '{'.\n-                            format!(\"{}{}, \", start_snippet, import)\n-                        } else {\n-                            // In this case, add a `{`, then the moved import, then whatever\n-                            // was there before.\n-                            format!(\"{{{}, {}\", import, start_snippet)\n-                        }\n-                    ));\n-                }\n-\n-                // Add a `};` to the end if nested, matching the `{` added at the start.\n-                if !has_nested {\n-                    corrections.push((source_map.end_point(after_crate_name),\n-                                     \"};\".to_string()));\n-                }\n-            }\n-\n-            let suggestion = Some((\n-                corrections,\n-                String::from(\"a macro with this name exists at the root of the crate\"),\n-                Applicability::MaybeIncorrect,\n-            ));\n-            let note = vec![\n-                \"this could be because a macro annotated with `#[macro_export]` will be exported \\\n-                 at the root of the crate instead of the module where it is defined\".to_string(),\n-            ];\n-            Some((suggestion, note))\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// Given a `binding_span` of a binding within a use statement:\n-///\n-/// ```\n-/// use foo::{a, b, c};\n-///              ^\n-/// ```\n-///\n-/// then return the span until the next binding or the end of the statement:\n-///\n-/// ```\n-/// use foo::{a, b, c};\n-///              ^^^\n-/// ```\n-pub(crate) fn find_span_of_binding_until_next_binding(\n-    sess: &Session,\n-    binding_span: Span,\n-    use_span: Span,\n-) -> (bool, Span) {\n-    let source_map = sess.source_map();\n-\n-    // Find the span of everything after the binding.\n-    //   ie. `a, e};` or `a};`\n-    let binding_until_end = binding_span.with_hi(use_span.hi());\n-\n-    // Find everything after the binding but not including the binding.\n-    //   ie. `, e};` or `};`\n-    let after_binding_until_end = binding_until_end.with_lo(binding_span.hi());\n-\n-    // Keep characters in the span until we encounter something that isn't a comma or\n-    // whitespace.\n-    //   ie. `, ` or ``.\n-    //\n-    // Also note whether a closing brace character was encountered. If there\n-    // was, then later go backwards to remove any trailing commas that are left.\n-    let mut found_closing_brace = false;\n-    let after_binding_until_next_binding = source_map.span_take_while(\n-        after_binding_until_end,\n-        |&ch| {\n-            if ch == '}' { found_closing_brace = true; }\n-            ch == ' ' || ch == ','\n-        }\n-    );\n-\n-    // Combine the two spans.\n-    //   ie. `a, ` or `a`.\n-    //\n-    // Removing these would leave `issue_52891::{d, e};` or `issue_52891::{d, e, };`\n-    let span = binding_span.with_hi(after_binding_until_next_binding.hi());\n-\n-    (found_closing_brace, span)\n-}\n-\n-/// Given a `binding_span`, return the span through to the comma or opening brace of the previous\n-/// binding.\n-///\n-/// ```\n-/// use foo::a::{a, b, c};\n-///               ^^--- binding span\n-///               |\n-///               returned span\n-///\n-/// use foo::{a, b, c};\n-///           --- binding span\n-/// ```\n-pub(crate) fn extend_span_to_previous_binding(\n-    sess: &Session,\n-    binding_span: Span,\n-) -> Option<Span> {\n-    let source_map = sess.source_map();\n-\n-    // `prev_source` will contain all of the source that came before the span.\n-    // Then split based on a command and take the first (ie. closest to our span)\n-    // snippet. In the example, this is a space.\n-    let prev_source = source_map.span_to_prev_source(binding_span).ok()?;\n-\n-    let prev_comma = prev_source.rsplit(',').collect::<Vec<_>>();\n-    let prev_starting_brace = prev_source.rsplit('{').collect::<Vec<_>>();\n-    if prev_comma.len() <= 1 || prev_starting_brace.len() <= 1 {\n-        return None;\n-    }\n-\n-    let prev_comma = prev_comma.first().unwrap();\n-    let prev_starting_brace = prev_starting_brace.first().unwrap();\n-\n-    // If the amount of source code before the comma is greater than\n-    // the amount of source code before the starting brace then we've only\n-    // got one item in the nested item (eg. `issue_52891::{self}`).\n-    if prev_comma.len() > prev_starting_brace.len() {\n-        return None;\n-    }\n-\n-    Some(binding_span.with_lo(BytePos(\n-        // Take away the number of bytes for the characters we've found and an\n-        // extra for the comma.\n-        binding_span.lo().0 - (prev_comma.as_bytes().len() as u32) - 1\n-    )))\n-}\n-\n-/// Given a `use_span` of a binding within a use statement, returns the highlighted span and if\n-/// it is a nested use tree.\n-///\n-/// ```\n-/// use foo::a::{b, c};\n-///          ^^^^^^^^^^ // false\n-///\n-/// use foo::{a, b, c};\n-///          ^^^^^^^^^^ // true\n-///\n-/// use foo::{a, b::{c, d}};\n-///          ^^^^^^^^^^^^^^^ // true\n-/// ```\n-fn find_span_immediately_after_crate_name(\n-    sess: &Session,\n-    module_name: Symbol,\n-    use_span: Span,\n-) -> (bool, Span) {\n-    debug!(\"find_span_immediately_after_crate_name: module_name={:?} use_span={:?}\",\n-           module_name, use_span);\n-    let source_map = sess.source_map();\n-\n-    // Using `use issue_59764::foo::{baz, makro};` as an example throughout..\n-    let mut num_colons = 0;\n-    // Find second colon.. `use issue_59764:`\n-    let until_second_colon = source_map.span_take_while(use_span, |c| {\n-        if *c == ':' { num_colons += 1; }\n-        match c {\n-            ':' if num_colons == 2 => false,\n-            _ => true,\n-        }\n-    });\n-    // Find everything after the second colon.. `foo::{baz, makro};`\n-    let from_second_colon = use_span.with_lo(until_second_colon.hi() + BytePos(1));\n-\n-    let mut found_a_non_whitespace_character = false;\n-    // Find the first non-whitespace character in `from_second_colon`.. `f`\n-    let after_second_colon = source_map.span_take_while(from_second_colon, |c| {\n-        if found_a_non_whitespace_character { return false; }\n-        if !c.is_whitespace() { found_a_non_whitespace_character = true; }\n-        true\n-    });\n-\n-    // Find the first `{` in from_second_colon.. `foo::{`\n-    let next_left_bracket = source_map.span_through_char(from_second_colon, '{');\n-\n-    (next_left_bracket == after_second_colon, from_second_colon)\n-}"}, {"sha": "08b2f1a0f16fc1ff6585a2eaefeca8a7c1403a5f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -65,16 +65,16 @@ use std::mem::replace;\n use rustc_data_structures::ptr_key::PtrKey;\n use rustc_data_structures::sync::Lrc;\n \n-use error_reporting::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n+use diagnostics::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n use macros::{InvocationData, LegacyBinding, ParentScope};\n \n type Def = def::Def<NodeId>;\n \n // N.B., this module needs to be declared first so diagnostics are\n // registered before they are used.\n+mod error_codes;\n mod diagnostics;\n-mod error_reporting;\n mod macros;\n mod check_unused;\n mod build_reduced_graph;"}, {"sha": "22f24df450f462377f91ff9acd7d355f951fdaed", "filename": "src/librustc_typeck/error_codes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "previous_filename": "src/librustc_typeck/diagnostics.rs"}, {"sha": "9bc221fac1b0b58422340f69a9aae2af9d855b72", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -81,7 +81,7 @@ This API is completely unstable and subject to change.\n \n // N.B., this module needs to be declared first so diagnostics are\n // registered before they are used.\n-mod diagnostics;\n+mod error_codes;\n \n mod astconv;\n mod check;"}, {"sha": "ac24475cab89fa1d6c614c3e2c3d9bd9f6a1e6d0", "filename": "src/libsyntax/error_codes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibsyntax%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibsyntax%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferror_codes.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "previous_filename": "src/libsyntax/diagnostic_list.rs"}, {"sha": "db10ab7af5a72efac4abb98577202274b9233776", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -114,7 +114,7 @@ pub mod diagnostics {\n \n // N.B., this module needs to be declared first so diagnostics are\n // registered before they are used.\n-pub mod diagnostic_list;\n+pub mod error_codes;\n \n pub mod util {\n     pub mod lev_distance;"}, {"sha": "9bbd9fdec17d69d8951703488ba5c228e2d37d0c", "filename": "src/libsyntax_ext/error_codes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibsyntax_ext%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibsyntax_ext%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ferror_codes.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "previous_filename": "src/libsyntax_ext/diagnostics.rs"}, {"sha": "508f740cac927d020e6813cb2a96e72916e621bc", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -17,7 +17,7 @@\n \n extern crate proc_macro;\n \n-mod diagnostics;\n+mod error_codes;\n \n mod asm;\n mod assert;"}, {"sha": "ef1000ee5065af570864b554fb0fe7fa7b280a6c", "filename": "src/tools/tidy/src/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6f513ec7d1e83c8689f94fb48686dd11f1d1c80/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs?ref=d6f513ec7d1e83c8689f94fb48686dd11f1d1c80", "patch": "@@ -15,7 +15,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n                 &mut |path| super::filter_dirs(path) || path.ends_with(\"src/test\"),\n                 &mut |file| {\n         let filename = file.file_name().unwrap().to_string_lossy();\n-        if filename != \"diagnostics.rs\" && filename != \"diagnostic_list.rs\" {\n+        if filename != \"error_codes.rs\" {\n             return\n         }\n "}]}