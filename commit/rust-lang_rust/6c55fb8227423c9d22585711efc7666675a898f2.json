{"sha": "6c55fb8227423c9d22585711efc7666675a898f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNTVmYjgyMjc0MjNjOWQyMjU4NTcxMWVmYzc2NjY2NzVhODk4ZjI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-08-21T20:31:58Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-25T22:45:53Z"}, "message": "rustc_mir: double-check const-promotion candidates for sanity.", "tree": {"sha": "6cb30847037e33df28b654cfa19bd7949d333713", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cb30847037e33df28b654cfa19bd7949d333713"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c55fb8227423c9d22585711efc7666675a898f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c55fb8227423c9d22585711efc7666675a898f2", "html_url": "https://github.com/rust-lang/rust/commit/6c55fb8227423c9d22585711efc7666675a898f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c55fb8227423c9d22585711efc7666675a898f2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23f890f10202a71168c6424da0cdf94135d3c40c", "url": "https://api.github.com/repos/rust-lang/rust/commits/23f890f10202a71168c6424da0cdf94135d3c40c", "html_url": "https://github.com/rust-lang/rust/commit/23f890f10202a71168c6424da0cdf94135d3c40c"}], "stats": {"total": 721, "additions": 691, "deletions": 30}, "files": [{"sha": "4d411ad4f537c38aa45d95dcade72032146abfbf", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 590, "deletions": 14, "changes": 604, "blob_url": "https://github.com/rust-lang/rust/blob/6c55fb8227423c9d22585711efc7666675a898f2/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c55fb8227423c9d22585711efc7666675a898f2/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=6c55fb8227423c9d22585711efc7666675a898f2", "patch": "@@ -12,15 +12,22 @@\n //! initialization and can otherwise silence errors, if\n //! move analysis runs after promotion on broken MIR.\n \n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n+use rustc::mir::interpret::ConstValue;\n use rustc::mir::visit::{PlaceContext, MutatingUseContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n+use rustc::ty::{self, List, TyCtxt};\n use rustc::ty::subst::InternalSubsts;\n-use rustc::ty::{List, TyCtxt};\n-use syntax_pos::Span;\n+use rustc::ty::cast::CastTy;\n+use syntax::ast::LitKind;\n+use syntax::symbol::sym;\n+use syntax_pos::{Span, DUMMY_SP};\n \n+use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{IndexVec, Idx};\n+use rustc_target::spec::abi::Abi;\n \n use std::{iter, mem, usize};\n \n@@ -57,7 +64,7 @@ impl TempState {\n /// A \"root candidate\" for promotion, which will become the\n /// returned value in a promoted MIR, unless it's a subset\n /// of a larger candidate.\n-#[derive(Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Candidate {\n     /// Borrow of a constant temporary.\n     Ref(Location),\n@@ -73,13 +80,28 @@ pub enum Candidate {\n     Argument { bb: BasicBlock, index: usize },\n }\n \n-struct TempCollector<'tcx> {\n+fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Vec<usize>> {\n+    let attrs = tcx.get_attrs(def_id);\n+    let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;\n+    let mut ret = vec![];\n+    for meta in attr.meta_item_list()? {\n+        match meta.literal()?.kind {\n+            LitKind::Int(a, _) => { ret.push(a as usize); }\n+            _ => return None,\n+        }\n+    }\n+    Some(ret)\n+}\n+\n+struct Collector<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    body: &'a Body<'tcx>,\n     temps: IndexVec<Local, TempState>,\n+    candidates: Vec<Candidate>,\n     span: Span,\n-    body: &'tcx Body<'tcx>,\n }\n \n-impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n+impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n     fn visit_local(&mut self,\n                    &index: &Local,\n                    context: PlaceContext,\n@@ -134,22 +156,576 @@ impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n         *temp = TempState::Unpromotable;\n     }\n \n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        self.super_rvalue(rvalue, location);\n+\n+        match *rvalue {\n+            Rvalue::Ref(..) => {\n+                self.candidates.push(Candidate::Ref(location));\n+            }\n+            Rvalue::Repeat(..) if self.tcx.features().const_in_array_repeat_expressions => {\n+                // FIXME(#49147) only promote the element when it isn't `Copy`\n+                // (so that code that can copy it at runtime is unaffected).\n+                self.candidates.push(Candidate::Repeat(location));\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn visit_terminator_kind(&mut self,\n+                             kind: &TerminatorKind<'tcx>,\n+                             location: Location) {\n+        self.super_terminator_kind(kind, location);\n+\n+        if let TerminatorKind::Call { ref func, .. } = *kind {\n+            if let ty::FnDef(def_id, _) = func.ty(self.body, self.tcx).kind {\n+                let fn_sig = self.tcx.fn_sig(def_id);\n+                if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = fn_sig.abi() {\n+                    let name = self.tcx.item_name(def_id);\n+                    // FIXME(eddyb) use `#[rustc_args_required_const(2)]` for shuffles.\n+                    if name.as_str().starts_with(\"simd_shuffle\") {\n+                        self.candidates.push(Candidate::Argument {\n+                            bb: location.block,\n+                            index: 2,\n+                        });\n+                    }\n+                }\n+\n+                if let Some(constant_args) = args_required_const(self.tcx, def_id) {\n+                    for index in constant_args {\n+                        self.candidates.push(Candidate::Argument { bb: location.block, index });\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn visit_source_info(&mut self, source_info: &SourceInfo) {\n         self.span = source_info.span;\n     }\n }\n \n-pub fn collect_temps(body: &Body<'_>,\n-                     rpo: &mut ReversePostorder<'_, '_>) -> IndexVec<Local, TempState> {\n-    let mut collector = TempCollector {\n+pub fn collect_temps_and_candidates(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    rpo: &mut ReversePostorder<'_, 'tcx>,\n+) -> (IndexVec<Local, TempState>, Vec<Candidate>) {\n+    let mut collector = Collector {\n+        tcx,\n+        body,\n         temps: IndexVec::from_elem(TempState::Undefined, &body.local_decls),\n+        candidates: vec![],\n         span: body.span,\n-        body,\n     };\n     for (bb, data) in rpo {\n         collector.visit_basic_block_data(bb, data);\n     }\n-    collector.temps\n+    (collector.temps, collector.candidates)\n+}\n+\n+struct Validator<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    body: &'a Body<'tcx>,\n+    is_static: bool,\n+    is_static_mut: bool,\n+    is_non_const_fn: bool,\n+    temps: &'a IndexVec<Local, TempState>,\n+    // FIXME(eddyb) compute these 2 on the fly.\n+    has_mut_interior: &'a BitSet<Local>,\n+    needs_drop: &'a BitSet<Local>,\n+\n+    /// Explicit promotion happens e.g. for constant arguments declared via\n+    /// `rustc_args_required_const`.\n+    /// Implicit promotion has almost the same rules, except that disallows `const fn`\n+    /// except for those marked `#[rustc_promotable]`. This is to avoid changing\n+    /// a legitimate run-time operation into a failing compile-time operation\n+    /// e.g. due to addresses being compared inside the function.\n+    explicit: bool,\n+}\n+\n+struct Unpromotable;\n+\n+impl<'tcx> Validator<'_, 'tcx> {\n+    fn is_const_panic_fn(&self, def_id: DefId) -> bool {\n+        Some(def_id) == self.tcx.lang_items().panic_fn() ||\n+        Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+    }\n+\n+    fn validate_candidate(&self, candidate: Candidate) -> Result<(), Unpromotable> {\n+        match candidate {\n+            Candidate::Ref(loc) => {\n+                assert!(!self.explicit);\n+\n+                let statement = &self.body[loc.block].statements[loc.statement_index];\n+                match &statement.kind {\n+                    StatementKind::Assign(box(_, Rvalue::Ref(_, kind, place))) => {\n+                        match kind {\n+                            BorrowKind::Shared | BorrowKind::Mut { .. } => {}\n+\n+                            // FIXME(eddyb) these aren't promoted here but *could*\n+                            // be promoted as part of a larger value because\n+                            // `validate_rvalue`  doesn't check them, need to\n+                            // figure out what is the intended behavior.\n+                            BorrowKind::Shallow | BorrowKind::Unique => return Err(Unpromotable),\n+                        }\n+\n+                        // We can only promote interior borrows of promotable temps (non-temps\n+                        // don't get promoted anyway).\n+                        let base = match place.base {\n+                            PlaceBase::Local(local) => local,\n+                            _ => return Err(Unpromotable),\n+                        };\n+                        if place.projection.contains(&ProjectionElem::Deref) {\n+                            return Err(Unpromotable);\n+                        }\n+\n+                        // FIXME(eddyb) compute this on the fly.\n+                        let mut has_mut_interior = self.has_mut_interior.contains(base);\n+                        // HACK(eddyb) this should compute the same thing as\n+                        // `<HasMutInterior as Qualif>::in_projection` from\n+                        // `qualify_consts` but without recursion.\n+                        if has_mut_interior {\n+                            // This allows borrowing fields which don't have\n+                            // `HasMutInterior`, from a type that does, e.g.:\n+                            // `let _: &'static _ = &(Cell::new(1), 2).1;`\n+                            let mut place_projection = &place.projection[..];\n+                            // FIXME(eddyb) use a forward loop instead of a reverse one.\n+                            while let [proj_base @ .., elem] = place_projection {\n+                                // FIXME(eddyb) this is probably excessive, with\n+                                // the exception of `union` member accesses.\n+                                let ty =\n+                                    Place::ty_from(&place.base, proj_base, self.body, self.tcx)\n+                                        .projection_ty(self.tcx, elem)\n+                                        .ty;\n+                                if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n+                                    has_mut_interior = false;\n+                                    break;\n+                                }\n+\n+                                place_projection = proj_base;\n+                            }\n+                        }\n+\n+                        // FIXME(eddyb) this duplicates part of `validate_rvalue`.\n+                        if has_mut_interior {\n+                            return Err(Unpromotable);\n+                        }\n+                        // FIXME(eddyb) compute this on the fly.\n+                        if self.needs_drop.contains(base) {\n+                            return Err(Unpromotable);\n+                        }\n+                        if let BorrowKind::Mut { .. } = kind {\n+                            let ty = place.ty(self.body, self.tcx).ty;\n+\n+                            // In theory, any zero-sized value could be borrowed\n+                            // mutably without consequences. However, only &mut []\n+                            // is allowed right now, and only in functions.\n+                            if self.is_static_mut {\n+                                // Inside a `static mut`, &mut [...] is also allowed.\n+                                match ty.kind {\n+                                    ty::Array(..) | ty::Slice(_) => {}\n+                                    _ => return Err(Unpromotable),\n+                                }\n+                            } else if let ty::Array(_, len) = ty.kind {\n+                                // FIXME(eddyb) the `self.is_non_const_fn` condition\n+                                // seems unnecessary, given that this is merely a ZST.\n+                                match len.try_eval_usize(self.tcx, self.param_env) {\n+                                    Some(0) if self.is_non_const_fn => {},\n+                                    _ => return Err(Unpromotable),\n+                                }\n+                            } else {\n+                                return Err(Unpromotable);\n+                            }\n+                        }\n+\n+                        self.validate_local(base)\n+                    }\n+                    _ => bug!()\n+                }\n+            }\n+            Candidate::Repeat(loc) => {\n+                assert!(!self.explicit);\n+\n+                let statement = &self.body[loc.block].statements[loc.statement_index];\n+                match &statement.kind {\n+                    StatementKind::Assign(box(_, Rvalue::Repeat(ref operand, _))) => {\n+                        if !self.tcx.features().const_in_array_repeat_expressions {\n+                            return Err(Unpromotable);\n+                        }\n+\n+                        self.validate_operand(operand)\n+                    }\n+                    _ => bug!()\n+                }\n+            },\n+            Candidate::Argument { bb, index } => {\n+                assert!(self.explicit);\n+\n+                let terminator = self.body[bb].terminator();\n+                match &terminator.kind {\n+                    TerminatorKind::Call { args, .. } => {\n+                        self.validate_operand(&args[index])\n+                    }\n+                    _ => bug!()\n+                }\n+            }\n+        }\n+    }\n+\n+    // FIXME(eddyb) maybe cache this?\n+    fn validate_local(&self, local: Local) -> Result<(), Unpromotable> {\n+        if let TempState::Defined { location: loc, .. } = self.temps[local] {\n+            let num_stmts = self.body[loc.block].statements.len();\n+\n+            if loc.statement_index < num_stmts {\n+                let statement = &self.body[loc.block].statements[loc.statement_index];\n+                match &statement.kind {\n+                    StatementKind::Assign(box(_, rhs)) => self.validate_rvalue(rhs),\n+                    _ => {\n+                        span_bug!(statement.source_info.span, \"{:?} is not an assignment\",\n+                                statement);\n+                    }\n+                }\n+            } else {\n+                let terminator = self.body[loc.block].terminator();\n+                match &terminator.kind {\n+                    TerminatorKind::Call { func, args, .. } => self.validate_call(func, args),\n+                    kind => {\n+                        span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n+                    }\n+                }\n+            }\n+        } else {\n+            Err(Unpromotable)\n+        }\n+    }\n+\n+    fn validate_place(&self, place: PlaceRef<'_, 'tcx>) -> Result<(), Unpromotable> {\n+        match place {\n+            PlaceRef {\n+                base: PlaceBase::Local(local),\n+                projection: [],\n+            } => self.validate_local(*local),\n+            PlaceRef {\n+                base: PlaceBase::Static(box Static {\n+                    kind: StaticKind::Promoted { .. },\n+                    ..\n+                }),\n+                projection: [],\n+            } => bug!(\"qualifying already promoted MIR\"),\n+            PlaceRef {\n+                base: PlaceBase::Static(box Static {\n+                    kind: StaticKind::Static,\n+                    def_id,\n+                    ..\n+                }),\n+                projection: [],\n+            } => {\n+                // Only allow statics (not consts) to refer to other statics.\n+                // FIXME(eddyb) does this matter at all for promotion?\n+                let allowed = self.is_static || self.is_static_mut;\n+                if !allowed {\n+                    return Err(Unpromotable);\n+                }\n+\n+                let is_thread_local = self.tcx.has_attr(*def_id, sym::thread_local);\n+                if is_thread_local {\n+                    return Err(Unpromotable);\n+                }\n+\n+                Ok(())\n+            }\n+            PlaceRef {\n+                base: _,\n+                projection: [proj_base @ .., elem],\n+            } => {\n+                match *elem {\n+                    ProjectionElem::Deref |\n+                    ProjectionElem::Downcast(..) => return Err(Unpromotable),\n+\n+                    ProjectionElem::ConstantIndex {..} |\n+                    ProjectionElem::Subslice {..} => {}\n+\n+                    ProjectionElem::Index(local) => {\n+                        self.validate_local(local)?;\n+                    }\n+\n+                    ProjectionElem::Field(..) => {\n+                        if self.is_non_const_fn {\n+                            let base_ty =\n+                                Place::ty_from(place.base, proj_base, self.body, self.tcx).ty;\n+                            if let Some(def) = base_ty.ty_adt_def() {\n+                                // No promotion of union field accesses.\n+                                if def.is_union() {\n+                                    return Err(Unpromotable);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                self.validate_place(PlaceRef {\n+                    base: place.base,\n+                    projection: proj_base,\n+                })\n+            }\n+        }\n+    }\n+\n+    fn validate_operand(&self, operand: &Operand<'tcx>) -> Result<(), Unpromotable> {\n+        match operand {\n+            Operand::Copy(place) |\n+            Operand::Move(place) => self.validate_place(place.as_ref()),\n+\n+            Operand::Constant(constant) => {\n+                if let ConstValue::Unevaluated(def_id, _) = constant.literal.val {\n+                    if self.tcx.trait_of_item(def_id).is_some() {\n+                        // Don't peek inside trait associated constants.\n+                        // (see below what we do for other consts, for now)\n+                    } else {\n+                        // HACK(eddyb) ensure that errors propagate correctly.\n+                        // FIXME(eddyb) remove this once the old promotion logic\n+                        // is gone - we can always promote constants even if they\n+                        // fail to pass const-checking, as compilation would've\n+                        // errored independently and promotion can't change that.\n+                        let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(def_id);\n+                        if bits == super::qualify_consts::QUALIF_ERROR_BIT {\n+                            self.tcx.sess.delay_span_bug(\n+                                constant.span,\n+                                \"promote_consts: MIR had errors\",\n+                            );\n+                            return Err(Unpromotable);\n+                        }\n+                    }\n+                }\n+\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n+        match *rvalue {\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if self.is_non_const_fn => {\n+                let operand_ty = operand.ty(self.body, self.tcx);\n+                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n+                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+                match (cast_in, cast_out) {\n+                    (CastTy::Ptr(_), CastTy::Int(_)) |\n+                    (CastTy::FnPtr, CastTy::Int(_)) => {\n+                        // in normal functions, mark such casts as not promotable\n+                        return Err(Unpromotable);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            Rvalue::BinaryOp(op, ref lhs, _) if self.is_non_const_fn => {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n+                    assert!(op == BinOp::Eq || op == BinOp::Ne ||\n+                            op == BinOp::Le || op == BinOp::Lt ||\n+                            op == BinOp::Ge || op == BinOp::Gt ||\n+                            op == BinOp::Offset);\n+\n+                    // raw pointer operations are not allowed inside promoteds\n+                    return Err(Unpromotable);\n+                }\n+            }\n+\n+            Rvalue::NullaryOp(NullOp::Box, _) => return Err(Unpromotable),\n+\n+            _ => {}\n+        }\n+\n+        match rvalue {\n+            Rvalue::NullaryOp(..) => Ok(()),\n+\n+            Rvalue::Discriminant(place) |\n+            Rvalue::Len(place) => self.validate_place(place.as_ref()),\n+\n+            Rvalue::Use(operand) |\n+            Rvalue::Repeat(operand, _) |\n+            Rvalue::UnaryOp(_, operand) |\n+            Rvalue::Cast(_, operand, _) => self.validate_operand(operand),\n+\n+            Rvalue::BinaryOp(_, lhs, rhs) |\n+            Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n+                self.validate_operand(lhs)?;\n+                self.validate_operand(rhs)\n+            }\n+\n+            Rvalue::Ref(_, kind, place) => {\n+                if let BorrowKind::Mut { .. } = kind {\n+                    let ty = place.ty(self.body, self.tcx).ty;\n+\n+                    // In theory, any zero-sized value could be borrowed\n+                    // mutably without consequences. However, only &mut []\n+                    // is allowed right now, and only in functions.\n+                    if self.is_static_mut {\n+                        // Inside a `static mut`, &mut [...] is also allowed.\n+                        match ty.kind {\n+                            ty::Array(..) | ty::Slice(_) => {}\n+                            _ => return Err(Unpromotable),\n+                        }\n+                    } else if let ty::Array(_, len) = ty.kind {\n+                        // FIXME(eddyb) the `self.is_non_const_fn` condition\n+                        // seems unnecessary, given that this is merely a ZST.\n+                        match len.try_eval_usize(self.tcx, self.param_env) {\n+                            Some(0) if self.is_non_const_fn => {},\n+                            _ => return Err(Unpromotable),\n+                        }\n+                    } else {\n+                        return Err(Unpromotable);\n+                    }\n+                }\n+\n+                // Special-case reborrows to be more like a copy of the reference.\n+                let mut place = place.as_ref();\n+                if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n+                    let base_ty =\n+                        Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n+                    if let ty::Ref(..) = base_ty.kind {\n+                        place = PlaceRef {\n+                            base: &place.base,\n+                            projection: proj_base,\n+                        };\n+                    }\n+                }\n+\n+                // HACK(eddyb) this should compute the same thing as\n+                // `<HasMutInterior as Qualif>::in_projection` from\n+                // `qualify_consts` but without recursion.\n+                let mut has_mut_interior = match place.base {\n+                    PlaceBase::Local(local) => {\n+                        // FIXME(eddyb) compute this on the fly.\n+                        self.has_mut_interior.contains(*local)\n+                    }\n+                    PlaceBase::Static(_) => false,\n+                };\n+                if has_mut_interior {\n+                    let mut place_projection = place.projection;\n+                    // FIXME(eddyb) use a forward loop instead of a reverse one.\n+                    while let [proj_base @ .., elem] = place_projection {\n+                        // FIXME(eddyb) this is probably excessive, with\n+                        // the exception of `union` member accesses.\n+                        let ty = Place::ty_from(place.base, proj_base, self.body, self.tcx)\n+                            .projection_ty(self.tcx, elem)\n+                            .ty;\n+                        if ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n+                            has_mut_interior = false;\n+                            break;\n+                        }\n+\n+                        place_projection = proj_base;\n+                    }\n+                }\n+                if has_mut_interior {\n+                    return Err(Unpromotable);\n+                }\n+\n+                self.validate_place(place)\n+            }\n+\n+            Rvalue::Aggregate(_, ref operands) => {\n+                for o in operands {\n+                    self.validate_operand(o)?;\n+                }\n+\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    fn validate_call(\n+        &self,\n+        callee: &Operand<'tcx>,\n+        args: &[Operand<'tcx>],\n+    ) -> Result<(), Unpromotable> {\n+        let fn_ty = callee.ty(self.body, self.tcx);\n+\n+        if !self.explicit && self.is_non_const_fn {\n+            if let ty::FnDef(def_id, _) = fn_ty.kind {\n+                // Never promote runtime `const fn` calls of\n+                // functions without `#[rustc_promotable]`.\n+                if !self.tcx.is_promotable_const_fn(def_id) {\n+                    return Err(Unpromotable);\n+                }\n+            }\n+        }\n+\n+        let is_const_fn = match fn_ty.kind {\n+            ty::FnDef(def_id, _) => {\n+                self.tcx.is_const_fn(def_id) ||\n+                self.tcx.is_unstable_const_fn(def_id).is_some() ||\n+                self.is_const_panic_fn(def_id)\n+            }\n+            _ => false,\n+        };\n+        if !is_const_fn {\n+            return Err(Unpromotable);\n+        }\n+\n+        self.validate_operand(callee)?;\n+        for arg in args {\n+            self.validate_operand(arg)?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+pub fn validate_candidates(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    def_id: DefId,\n+    temps: &IndexVec<Local, TempState>,\n+    // FIXME(eddyb) compute these 2 on the fly.\n+    has_mut_interior: &BitSet<Local>,\n+    needs_drop: &BitSet<Local>,\n+    candidates: &[Candidate],\n+) -> Vec<Candidate> {\n+    let mut validator = Validator {\n+        tcx,\n+        param_env: tcx.param_env(def_id),\n+        body,\n+        is_static: false,\n+        is_static_mut: false,\n+        is_non_const_fn: false,\n+        temps,\n+        // FIXME(eddyb) compute these 2 on the fly.\n+        has_mut_interior,\n+        needs_drop,\n+\n+        explicit: false,\n+    };\n+\n+    // FIXME(eddyb) remove the distinctions that make this necessary.\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    match tcx.hir().body_owner_kind(id) {\n+        hir::BodyOwnerKind::Closure => validator.is_non_const_fn = true,\n+        hir::BodyOwnerKind::Fn => {\n+            if !tcx.is_const_fn(def_id) {\n+                validator.is_non_const_fn = true;\n+            }\n+        },\n+        hir::BodyOwnerKind::Static(hir::MutImmutable) => validator.is_static = true,\n+        hir::BodyOwnerKind::Static(hir::MutMutable) => validator.is_static_mut = true,\n+        _ => {}\n+    }\n+\n+    candidates.iter().copied().filter(|&candidate| {\n+        validator.explicit = match candidate {\n+            Candidate::Ref(_) |\n+            Candidate::Repeat(_) => false,\n+            Candidate::Argument { .. } => true,\n+        };\n+\n+        // FIXME(eddyb) also emit the errors for shuffle indices\n+        // and `#[rustc_args_required_const]` arguments here.\n+\n+        validator.validate_candidate(candidate).is_ok()\n+    }).collect()\n }\n \n struct Promoter<'a, 'tcx> {\n@@ -215,17 +791,17 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             self.temps[temp] = TempState::PromotedOut;\n         }\n \n-        let no_stmts = self.source[loc.block].statements.len();\n+        let num_stmts = self.source[loc.block].statements.len();\n         let new_temp = self.promoted.local_decls.push(\n             LocalDecl::new_temp(self.source.local_decls[temp].ty,\n                                 self.source.local_decls[temp].source_info.span));\n \n         debug!(\"promote({:?} @ {:?}/{:?}, {:?})\",\n-               temp, loc, no_stmts, self.keep_original);\n+               temp, loc, num_stmts, self.keep_original);\n \n         // First, take the Rvalue or Call out of the source MIR,\n         // or duplicate it, depending on keep_original.\n-        if loc.statement_index < no_stmts {\n+        if loc.statement_index < num_stmts {\n             let (mut rvalue, source_info) = {\n                 let statement = &mut self.source[loc.block].statements[loc.statement_index];\n                 let rhs = match statement.kind {"}, {"sha": "1c5c84c692364c0a79307d2befacc1f54094d984", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 101, "deletions": 16, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/6c55fb8227423c9d22585711efc7666675a898f2/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c55fb8227423c9d22585711efc7666675a898f2/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=6c55fb8227423c9d22585711efc7666675a898f2", "patch": "@@ -206,6 +206,9 @@ trait Qualif {\n                 ProjectionElem::ConstantIndex { .. } |\n                 ProjectionElem::Downcast(..) => qualif,\n \n+                // FIXME(eddyb) shouldn't this be masked *after* including the\n+                // index local? Then again, it's `usize` which is neither\n+                // `HasMutInterior` nor `NeedsDrop`.\n                 ProjectionElem::Index(local) => qualif || Self::in_local(cx, *local),\n             }\n         } else {\n@@ -442,6 +445,7 @@ impl Qualif for IsNotPromotable {\n             StaticKind::Promoted(_, _) => unreachable!(),\n             StaticKind::Static => {\n                 // Only allow statics (not consts) to refer to other statics.\n+                // FIXME(eddyb) does this matter at all for promotion?\n                 let allowed = cx.mode == Mode::Static || cx.mode == Mode::StaticMut;\n \n                 !allowed ||\n@@ -674,6 +678,7 @@ struct Checker<'a, 'tcx> {\n \n     temp_promotion_state: IndexVec<Local, TempState>,\n     promotion_candidates: Vec<Candidate>,\n+    unchecked_promotion_candidates: Vec<Candidate>,\n \n     /// If `true`, do not emit errors to the user, merely collect them in `errors`.\n     suppress_errors: bool,\n@@ -703,7 +708,8 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     fn new(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>, mode: Mode) -> Self {\n         assert!(def_id.is_local());\n         let mut rpo = traversal::reverse_postorder(body);\n-        let temps = promote_consts::collect_temps(body, &mut rpo);\n+        let (temps, unchecked_promotion_candidates) =\n+            promote_consts::collect_temps_and_candidates(tcx, body, &mut rpo);\n         rpo.reset();\n \n         let param_env = tcx.param_env(def_id);\n@@ -742,6 +748,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             rpo,\n             temp_promotion_state: temps,\n             promotion_candidates: vec![],\n+            unchecked_promotion_candidates,\n             errors: vec![],\n             suppress_errors: false,\n         }\n@@ -828,6 +835,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 } else if let BorrowKind::Mut { .. } | BorrowKind::Shared = kind {\n                     // Don't promote BorrowKind::Shallow borrows, as they don't\n                     // reach codegen.\n+                    // FIXME(eddyb) the two other kinds of borrow (`Shallow` and `Unique`)\n+                    // aren't promoted here but *could* be promoted as part of a larger\n+                    // value because `IsNotPromotable` isn't being set for them,\n+                    // need to figure out what is the intended behavior.\n \n                     // We might have a candidate for promotion.\n                     let candidate = Candidate::Ref(location);\n@@ -967,6 +978,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n         let mut seen_blocks = BitSet::new_empty(body.basic_blocks().len());\n         let mut bb = START_BLOCK;\n+        let mut has_controlflow_error = false;\n         loop {\n             seen_blocks.insert(bb.index());\n \n@@ -1007,6 +1019,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     bb = target;\n                 }\n                 _ => {\n+                    has_controlflow_error = true;\n                     self.not_const(ops::Loop);\n                     validator.check_op(ops::Loop);\n                     break;\n@@ -1036,9 +1049,28 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         // Collect all the temps we need to promote.\n         let mut promoted_temps = BitSet::new_empty(self.temp_promotion_state.len());\n \n-        debug!(\"qualify_const: promotion_candidates={:?}\", self.promotion_candidates);\n-        for candidate in &self.promotion_candidates {\n-            match *candidate {\n+        // HACK(eddyb) don't try to validate promotion candidates if any\n+        // parts of the control-flow graph were skipped due to an error.\n+        let promotion_candidates = if has_controlflow_error {\n+            let unleash_miri = self\n+                .tcx\n+                .sess\n+                .opts\n+                .debugging_opts\n+                .unleash_the_miri_inside_of_you;\n+            if !unleash_miri {\n+                self.tcx.sess.delay_span_bug(\n+                    body.span,\n+                    \"check_const: expected control-flow error(s)\",\n+                );\n+            }\n+            self.promotion_candidates.clone()\n+        } else {\n+            self.valid_promotion_candidates()\n+        };\n+        debug!(\"qualify_const: promotion_candidates={:?}\", promotion_candidates);\n+        for candidate in promotion_candidates {\n+            match candidate {\n                 Candidate::Repeat(Location { block: bb, statement_index: stmt_idx }) => {\n                     if let StatementKind::Assign(box(_, Rvalue::Repeat(\n                         Operand::Move(place),\n@@ -1075,6 +1107,51 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n         (qualifs.encode_to_bits(), self.tcx.arena.alloc(promoted_temps))\n     }\n+\n+    /// Get the subset of `unchecked_promotion_candidates` that are eligible\n+    /// for promotion.\n+    // FIXME(eddyb) replace the old candidate gathering with this.\n+    fn valid_promotion_candidates(&self) -> Vec<Candidate> {\n+        // Sanity-check the promotion candidates.\n+        let candidates = promote_consts::validate_candidates(\n+            self.tcx,\n+            self.body,\n+            self.def_id,\n+            &self.temp_promotion_state,\n+            &self.per_local.0[HasMutInterior::IDX],\n+            &self.per_local.0[NeedsDrop::IDX],\n+            &self.unchecked_promotion_candidates,\n+        );\n+\n+        if candidates != self.promotion_candidates {\n+            let report = |msg, candidate| {\n+                let span = match candidate {\n+                    Candidate::Ref(loc) |\n+                    Candidate::Repeat(loc) => self.body.source_info(loc).span,\n+                    Candidate::Argument { bb, .. } => {\n+                        self.body[bb].terminator().source_info.span\n+                    }\n+                };\n+                self.tcx.sess.span_err(span, &format!(\"{}: {:?}\", msg, candidate));\n+            };\n+\n+            for &c in &self.promotion_candidates {\n+                if !candidates.contains(&c) {\n+                    report(\"invalidated old candidate\", c);\n+                }\n+            }\n+\n+            for &c in &candidates {\n+                if !self.promotion_candidates.contains(&c) {\n+                    report(\"extra new candidate\", c);\n+                }\n+            }\n+\n+            bug!(\"promotion candidate validation mismatches (see above)\");\n+        }\n+\n+        candidates\n+    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n@@ -1644,6 +1721,10 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n+// FIXME(eddyb) this is only left around for the validation logic\n+// in `promote_consts`, see the comment in `validate_operand`.\n+pub(super) const QUALIF_ERROR_BIT: u8 = 1 << IsNotPromotable::IDX;\n+\n fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> (u8, &BitSet<Local>) {\n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n@@ -1653,7 +1734,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> (u8, &BitSet<Local>) {\n \n     if body.return_ty().references_error() {\n         tcx.sess.delay_span_bug(body.span, \"mir_const_qualif: MIR had errors\");\n-        return (1 << IsNotPromotable::IDX, tcx.arena.alloc(BitSet::new_empty(0)));\n+        return (QUALIF_ERROR_BIT, tcx.arena.alloc(BitSet::new_empty(0)));\n     }\n \n     Checker::new(tcx, def_id, body, Mode::Const).check_const()\n@@ -1695,29 +1776,33 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants<'tcx> {\n             let (temps, candidates) = {\n                 let mut checker = Checker::new(tcx, def_id, body, mode);\n                 if let Mode::ConstFn = mode {\n-                    if tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-                        checker.check_const();\n-                    } else if tcx.is_min_const_fn(def_id) {\n+                    let use_min_const_fn_checks =\n+                        !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you &&\n+                        tcx.is_min_const_fn(def_id);\n+                    if use_min_const_fn_checks {\n                         // Enforce `min_const_fn` for stable `const fn`s.\n                         use super::qualify_min_const_fn::is_min_const_fn;\n                         if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n                             error_min_const_fn_violation(tcx, span, err);\n-                        } else {\n-                            // this should not produce any errors, but better safe than sorry\n-                            // FIXME(#53819)\n-                            checker.check_const();\n+                            return;\n                         }\n-                    } else {\n-                        // Enforce a constant-like CFG for `const fn`.\n-                        checker.check_const();\n+\n+                        // `check_const` should not produce any errors, but better safe than sorry\n+                        // FIXME(#53819)\n+                        // NOTE(eddyb) `check_const` is actually needed for promotion inside\n+                        // `min_const_fn` functions.\n                     }\n+\n+                    // Enforce a constant-like CFG for `const fn`.\n+                    checker.check_const();\n                 } else {\n                     while let Some((bb, data)) = checker.rpo.next() {\n                         checker.visit_basic_block_data(bb, data);\n                     }\n                 }\n \n-                (checker.temp_promotion_state, checker.promotion_candidates)\n+                let promotion_candidates = checker.valid_promotion_candidates();\n+                (checker.temp_promotion_state, promotion_candidates)\n             };\n \n             // Do the actual promotion, now that we know what's viable."}]}