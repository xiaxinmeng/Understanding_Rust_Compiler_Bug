{"sha": "76c728901e6b9d9b1c90de78c0f612f7a3fc63d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YzcyODkwMWU2YjlkOWIxYzkwZGU3OGMwZjYxMmY3YTNmYzYzZDU=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-08-05T02:28:59Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-09-04T23:12:54Z"}, "message": "More chalk work", "tree": {"sha": "de64a25a1224303b89c43f1bf9180604d793e525", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de64a25a1224303b89c43f1bf9180604d793e525"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76c728901e6b9d9b1c90de78c0f612f7a3fc63d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76c728901e6b9d9b1c90de78c0f612f7a3fc63d5", "html_url": "https://github.com/rust-lang/rust/commit/76c728901e6b9d9b1c90de78c0f612f7a3fc63d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76c728901e6b9d9b1c90de78c0f612f7a3fc63d5/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d66452c3e5dfad901099493e8b86f5643d084a32", "url": "https://api.github.com/repos/rust-lang/rust/commits/d66452c3e5dfad901099493e8b86f5643d084a32", "html_url": "https://github.com/rust-lang/rust/commit/d66452c3e5dfad901099493e8b86f5643d084a32"}], "stats": {"total": 837, "additions": 492, "deletions": 345}, "files": [{"sha": "cc417b05ed43a2cf0d0af2ed6abf82ee13bdcaf7", "filename": "compiler/rustc_middle/src/traits/chalk.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/76c728901e6b9d9b1c90de78c0f612f7a3fc63d5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c728901e6b9d9b1c90de78c0f612f7a3fc63d5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs?ref=76c728901e6b9d9b1c90de78c0f612f7a3fc63d5", "patch": "@@ -109,6 +109,44 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         application_ty: &chalk_ir::ApplicationTy<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n+        match application_ty.name {\n+            chalk_ir::TypeName::Ref(mutbl) => {\n+                let data = application_ty.substitution.interned();\n+                let lifetime = match &**data[0].interned() {\n+                    chalk_ir::GenericArgData::Lifetime(t) => t,\n+                    _ => unreachable!(),\n+                };\n+                let ty = match &**data[1].interned() {\n+                    chalk_ir::GenericArgData::Ty(t) => t,\n+                    _ => unreachable!(),\n+                };\n+                return Some(match mutbl {\n+                    chalk_ir::Mutability::Not => write!(fmt, \"(&{:?} {:?})\", lifetime, ty),\n+                    chalk_ir::Mutability::Mut => write!(fmt, \"(&{:?} mut {:?})\", lifetime, ty),\n+                });\n+            }\n+            chalk_ir::TypeName::Array => {\n+                let data = application_ty.substitution.interned();\n+                let ty = match &**data[0].interned() {\n+                    chalk_ir::GenericArgData::Ty(t) => t,\n+                    _ => unreachable!(),\n+                };\n+                let len = match &**data[1].interned() {\n+                    chalk_ir::GenericArgData::Const(t) => t,\n+                    _ => unreachable!(),\n+                };\n+                return Some(write!(fmt, \"[{:?}; {:?}]\", ty, len));\n+            }\n+            chalk_ir::TypeName::Slice => {\n+                let data = application_ty.substitution.interned();\n+                let ty = match &**data[0].interned() {\n+                    chalk_ir::GenericArgData::Ty(t) => t,\n+                    _ => unreachable!(),\n+                };\n+                return Some(write!(fmt, \"[{:?}]\", ty));\n+            }\n+            _ => {}\n+        }\n         let chalk_ir::ApplicationTy { name, substitution } = application_ty;\n         Some(write!(fmt, \"{:?}{:?}\", name, chalk_ir::debug::Angle(substitution.interned())))\n     }"}, {"sha": "23e2855f36dc55f0642f7a5966018e90c158d309", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 46, "deletions": 33, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/76c728901e6b9d9b1c90de78c0f612f7a3fc63d5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c728901e6b9d9b1c90de78c0f612f7a3fc63d5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=76c728901e6b9d9b1c90de78c0f612f7a3fc63d5", "patch": "@@ -8,7 +8,7 @@\n \n use rustc_middle::traits::ChalkRustInterner as RustInterner;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{self, AssocItemContainer, AssocKind, TyCtxt};\n+use rustc_middle::ty::{self, AssocItemContainer, AssocKind, TyCtxt, TypeFoldable};\n \n use rustc_hir::def_id::DefId;\n use rustc_hir::Unsafety;\n@@ -18,11 +18,13 @@ use rustc_span::symbol::sym;\n use std::fmt;\n use std::sync::Arc;\n \n-use crate::chalk::lowering::LowerInto;\n+use crate::chalk::lowering::{self, LowerInto};\n \n pub struct RustIrDatabase<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub interner: RustInterner<'tcx>,\n+    pub restatic_placeholder: ty::Region<'tcx>,\n+    pub reempty_placeholder: ty::Region<'tcx>,\n }\n \n impl fmt::Debug for RustIrDatabase<'_> {\n@@ -31,6 +33,26 @@ impl fmt::Debug for RustIrDatabase<'_> {\n     }\n }\n \n+impl<'tcx> RustIrDatabase<'tcx> {\n+    fn where_clauses_for(\n+        &self,\n+        def_id: DefId,\n+        bound_vars: SubstsRef<'tcx>,\n+    ) -> Vec<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n+        let predicates = self.tcx.predicates_of(def_id).predicates;\n+        let mut regions_substitutor = lowering::RegionsSubstitutor::new(\n+            self.tcx,\n+            self.restatic_placeholder,\n+            self.reempty_placeholder,\n+        );\n+        predicates\n+            .iter()\n+            .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n+            .map(|wc| wc.fold_with(&mut regions_substitutor))\n+            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect()\n+    }\n+}\n+\n impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'tcx> {\n     fn interner(&self) -> &RustInterner<'tcx> {\n         &self.interner\n@@ -55,11 +77,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         // FIXME(chalk): this really isn't right I don't think. The functions\n         // for GATs are a bit hard to figure out. Are these supposed to be where\n         // clauses or bounds?\n-        let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n-        let where_clauses: Vec<_> = predicates\n-            .iter()\n-            .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n-            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+        let where_clauses = self.where_clauses_for(def_id, bound_vars);\n \n         Arc::new(chalk_solve::rust_ir::AssociatedTyDatum {\n             trait_id: chalk_ir::TraitId(trait_def_id),\n@@ -81,11 +99,9 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n         let bound_vars = bound_vars_for_item(self.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n-        let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n-        let where_clauses: Vec<_> = predicates\n-            .iter()\n-            .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n-            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+\n+        let where_clauses = self.where_clauses_for(def_id, bound_vars);\n+\n         let associated_ty_ids: Vec<_> = self\n             .tcx\n             .associated_items(def_id)\n@@ -140,12 +156,8 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let bound_vars = bound_vars_for_item(self.tcx, adt_def.did);\n         let binders = binders_for(&self.interner, bound_vars);\n \n-        let predicates = self.tcx.predicates_of(adt_def.did).predicates;\n-        let where_clauses: Vec<_> = predicates\n-            .iter()\n-            .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n-            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner))\n-            .collect();\n+        let where_clauses = self.where_clauses_for(adt_def.did, bound_vars);\n+\n         let variants: Vec<_> = adt_def\n             .variants\n             .iter()\n@@ -201,14 +213,11 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         let bound_vars = bound_vars_for_item(self.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n \n-        let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n-        let where_clauses: Vec<_> = predicates\n-            .iter()\n-            .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n-            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+        let where_clauses = self.where_clauses_for(def_id, bound_vars);\n \n         let sig = self.tcx.fn_sig(def_id);\n         let inputs_and_output = sig.inputs_and_output();\n+        let inputs_and_output = inputs_and_output.subst(self.tcx, bound_vars);\n         let (inputs_and_output, iobinders, _) = crate::chalk::lowering::collect_bound_vars(\n             &self.interner,\n             self.tcx,\n@@ -253,12 +262,14 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n         let trait_ref = self.tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n         let trait_ref = trait_ref.subst(self.tcx, bound_vars);\n+        let mut regions_substitutor = lowering::RegionsSubstitutor::new(\n+            self.tcx,\n+            self.restatic_placeholder,\n+            self.reempty_placeholder,\n+        );\n+        let trait_ref = trait_ref.fold_with(&mut regions_substitutor);\n \n-        let predicates = self.tcx.predicates_of(def_id).predicates;\n-        let where_clauses: Vec<_> = predicates\n-            .iter()\n-            .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n-            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+        let where_clauses = self.where_clauses_for(def_id, bound_vars);\n \n         let value = chalk_solve::rust_ir::ImplDatumBound {\n             trait_ref: trait_ref.lower_into(&self.interner),\n@@ -293,6 +304,12 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n             let self_ty = trait_ref.self_ty();\n             let self_ty = self_ty.subst(self.tcx, bound_vars);\n+            let mut regions_substitutor = lowering::RegionsSubstitutor::new(\n+                self.tcx,\n+                self.restatic_placeholder,\n+                self.reempty_placeholder,\n+            );\n+            let self_ty = self_ty.fold_with(&mut regions_substitutor);\n             let lowered_ty = self_ty.lower_into(&self.interner);\n \n             parameters[0].assert_ty_ref(&self.interner).could_match(&self.interner, &lowered_ty)\n@@ -370,11 +387,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> Arc<chalk_solve::rust_ir::OpaqueTyDatum<RustInterner<'tcx>>> {\n         let bound_vars = bound_vars_for_item(self.tcx, opaque_ty_id.0);\n         let binders = binders_for(&self.interner, bound_vars);\n-        let predicates = self.tcx.predicates_defined_on(opaque_ty_id.0).predicates;\n-        let where_clauses: Vec<_> = predicates\n-            .iter()\n-            .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n-            .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n+        let where_clauses = self.where_clauses_for(opaque_ty_id.0, bound_vars);\n \n         let value = chalk_solve::rust_ir::OpaqueTyDatumBound {\n             bounds: chalk_ir::Binders::new(binders.clone(), vec![]),"}, {"sha": "c2a3fa22dc8b75440b53c9b56967815fb39600d8", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 382, "deletions": 217, "changes": 599, "blob_url": "https://github.com/rust-lang/rust/blob/76c728901e6b9d9b1c90de78c0f612f7a3fc63d5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c728901e6b9d9b1c90de78c0f612f7a3fc63d5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=76c728901e6b9d9b1c90de78c0f612f7a3fc63d5", "patch": "@@ -60,6 +60,12 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Substitution<RustInterner<'tcx>>> for Subst\n     }\n }\n \n+impl<'tcx> LowerInto<'tcx, SubstsRef<'tcx>> for &chalk_ir::Substitution<RustInterner<'tcx>> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> SubstsRef<'tcx> {\n+        interner.tcx.mk_substs(self.iter(interner).map(|subst| subst.lower_into(interner)))\n+    }\n+}\n+\n impl<'tcx> LowerInto<'tcx, chalk_ir::AliasTy<RustInterner<'tcx>>> for ty::ProjectionTy<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::AliasTy<RustInterner<'tcx>> {\n         chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n@@ -76,104 +82,29 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>> {\n-        let clauses = self.environment.into_iter().filter_map(|clause| match clause {\n+        let clauses = self.environment.into_iter().map(|clause| match clause {\n             ChalkEnvironmentClause::Predicate(predicate) => {\n-                // FIXME(chalk): forall\n-                match predicate.bound_atom(interner.tcx).skip_binder() {\n-                    ty::PredicateAtom::Trait(predicate, _) => {\n-                        let predicate = ty::Binder::bind(predicate);\n-                        let (predicate, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, &predicate);\n-\n-                        Some(\n-                            chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n-                                binders,\n-                                chalk_ir::ProgramClauseImplication {\n-                                    consequence: chalk_ir::DomainGoal::FromEnv(\n-                                        chalk_ir::FromEnv::Trait(\n-                                            predicate.trait_ref.lower_into(interner),\n-                                        ),\n-                                    ),\n-                                    conditions: chalk_ir::Goals::empty(interner),\n-                                    priority: chalk_ir::ClausePriority::High,\n-                                    constraints: chalk_ir::Constraints::empty(interner),\n-                                },\n-                            ))\n-                            .intern(interner),\n-                        )\n-                    }\n-                    ty::PredicateAtom::RegionOutlives(predicate) => {\n-                        let predicate = ty::Binder::bind(predicate);\n-                        let (predicate, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, &predicate);\n-\n-                        Some(\n-                            chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n-                                binders,\n-                                chalk_ir::ProgramClauseImplication {\n-                                    consequence: chalk_ir::DomainGoal::Holds(\n-                                        chalk_ir::WhereClause::LifetimeOutlives(\n-                                            chalk_ir::LifetimeOutlives {\n-                                                a: predicate.0.lower_into(interner),\n-                                                b: predicate.1.lower_into(interner),\n-                                            },\n-                                        ),\n-                                    ),\n-                                    conditions: chalk_ir::Goals::empty(interner),\n-                                    priority: chalk_ir::ClausePriority::High,\n-                                    constraints: chalk_ir::Constraints::empty(interner),\n-                                },\n-                            ))\n-                            .intern(interner),\n-                        )\n-                    }\n-                    ty::PredicateAtom::TypeOutlives(predicate) => {\n-                        let predicate = ty::Binder::bind(predicate);\n-                        let (predicate, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, &predicate);\n-\n-                        Some(\n-                            chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n-                                binders,\n-                                chalk_ir::ProgramClauseImplication {\n-                                    consequence: chalk_ir::DomainGoal::Holds(\n-                                        chalk_ir::WhereClause::TypeOutlives(\n-                                            chalk_ir::TypeOutlives {\n-                                                ty: predicate.0.lower_into(interner),\n-                                                lifetime: predicate.1.lower_into(interner),\n-                                            },\n-                                        ),\n-                                    ),\n-                                    conditions: chalk_ir::Goals::empty(interner),\n-                                    priority: chalk_ir::ClausePriority::High,\n-                                    constraints: chalk_ir::Constraints::empty(interner),\n-                                },\n-                            ))\n-                            .intern(interner),\n-                        )\n-                    }\n-                    ty::PredicateAtom::Projection(predicate) => {\n-                        let predicate = ty::Binder::bind(predicate);\n-                        let (predicate, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, &predicate);\n-\n-                        Some(\n-                            chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n-                                binders,\n-                                chalk_ir::ProgramClauseImplication {\n-                                    consequence: chalk_ir::DomainGoal::Holds(\n-                                        chalk_ir::WhereClause::AliasEq(\n-                                            predicate.lower_into(interner),\n-                                        ),\n-                                    ),\n-                                    conditions: chalk_ir::Goals::empty(interner),\n-                                    priority: chalk_ir::ClausePriority::High,\n-                                    constraints: chalk_ir::Constraints::empty(interner),\n-                                },\n-                            ))\n-                            .intern(interner),\n-                        )\n-                    }\n+                let (predicate, binders, _named_regions) =\n+                    collect_bound_vars(interner, interner.tcx, &predicate.bound_atom(interner.tcx));\n+                let consequence = match predicate {\n+                    ty::PredicateAtom::Trait(predicate, _) => chalk_ir::DomainGoal::FromEnv(\n+                        chalk_ir::FromEnv::Trait(predicate.trait_ref.lower_into(interner)),\n+                    ),\n+                    ty::PredicateAtom::RegionOutlives(predicate) => chalk_ir::DomainGoal::Holds(\n+                        chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n+                            a: predicate.0.lower_into(interner),\n+                            b: predicate.1.lower_into(interner),\n+                        }),\n+                    ),\n+                    ty::PredicateAtom::TypeOutlives(predicate) => chalk_ir::DomainGoal::Holds(\n+                        chalk_ir::WhereClause::TypeOutlives(chalk_ir::TypeOutlives {\n+                            ty: predicate.0.lower_into(interner),\n+                            lifetime: predicate.1.lower_into(interner),\n+                        }),\n+                    ),\n+                    ty::PredicateAtom::Projection(predicate) => chalk_ir::DomainGoal::Holds(\n+                        chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)),\n+                    ),\n                     ty::PredicateAtom::WellFormed(..)\n                     | ty::PredicateAtom::ObjectSafe(..)\n                     | ty::PredicateAtom::ClosureKind(..)\n@@ -182,9 +113,16 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                     | ty::PredicateAtom::ConstEquate(..) => {\n                         bug!(\"unexpected predicate {}\", predicate)\n                     }\n-                }\n+                };\n+                let value = chalk_ir::ProgramClauseImplication {\n+                    consequence,\n+                    conditions: chalk_ir::Goals::empty(interner),\n+                    priority: chalk_ir::ClausePriority::High,\n+                    constraints: chalk_ir::Constraints::empty(interner),\n+                };\n+                chalk_ir::ProgramClauseData(chalk_ir::Binders::new(binders, value)).intern(interner)\n             }\n-            ChalkEnvironmentClause::TypeFromEnv(ty) => Some(\n+            ChalkEnvironmentClause::TypeFromEnv(ty) => {\n                 chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n                     chalk_ir::VariableKinds::empty(interner),\n                     chalk_ir::ProgramClauseImplication {\n@@ -196,8 +134,8 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                         constraints: chalk_ir::Constraints::empty(interner),\n                     },\n                 ))\n-                .intern(interner),\n-            ),\n+                .intern(interner)\n+            }\n         });\n \n         let goal: chalk_ir::GoalData<RustInterner<'tcx>> = self.goal.lower_into(&interner);\n@@ -212,36 +150,35 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predicate<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n-        // FIXME(chalk): forall\n-        match self.bound_atom(interner.tcx).skip_binder() {\n+        let (predicate, binders, _named_regions) =\n+            collect_bound_vars(interner, interner.tcx, &self.bound_atom(interner.tcx));\n+\n+        let value = match predicate {\n             ty::PredicateAtom::Trait(predicate, _) => {\n-                ty::Binder::bind(predicate).lower_into(interner)\n+                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n+                    chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n+                ))\n             }\n             ty::PredicateAtom::RegionOutlives(predicate) => {\n-                let predicate = ty::Binder::bind(predicate);\n-                let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, &predicate);\n-\n-                chalk_ir::GoalData::Quantified(\n-                    chalk_ir::QuantifierKind::ForAll,\n-                    chalk_ir::Binders::new(\n-                        binders,\n-                        chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n-                            chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n-                                a: predicate.0.lower_into(interner),\n-                                b: predicate.1.lower_into(interner),\n-                            }),\n-                        ))\n-                        .intern(interner),\n-                    ),\n-                )\n+                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n+                    chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n+                        a: predicate.0.lower_into(interner),\n+                        b: predicate.1.lower_into(interner),\n+                    }),\n+                ))\n             }\n-            // FIXME(chalk): TypeOutlives\n-            ty::PredicateAtom::TypeOutlives(_predicate) => {\n-                chalk_ir::GoalData::All(chalk_ir::Goals::empty(interner))\n+            ty::PredicateAtom::TypeOutlives(predicate) => {\n+                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n+                    chalk_ir::WhereClause::TypeOutlives(chalk_ir::TypeOutlives {\n+                        ty: predicate.0.lower_into(interner),\n+                        lifetime: predicate.1.lower_into(interner),\n+                    }),\n+                ))\n             }\n             ty::PredicateAtom::Projection(predicate) => {\n-                ty::Binder::bind(predicate).lower_into(interner)\n+                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n+                    chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)),\n+                ))\n             }\n             ty::PredicateAtom::WellFormed(arg) => match arg.unpack() {\n                 GenericArgKind::Type(ty) => match ty.kind() {\n@@ -252,21 +189,9 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n                         chalk_ir::GoalData::All(chalk_ir::Goals::empty(interner))\n                     }\n \n-                    _ => {\n-                        let (ty, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, &ty::Binder::bind(ty));\n-\n-                        chalk_ir::GoalData::Quantified(\n-                            chalk_ir::QuantifierKind::ForAll,\n-                            chalk_ir::Binders::new(\n-                                binders,\n-                                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::WellFormed(\n-                                    chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n-                                ))\n-                                .intern(interner),\n-                            ),\n-                        )\n-                    }\n+                    _ => chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::WellFormed(\n+                        chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n+                    )),\n                 },\n                 // FIXME(chalk): handle well formed consts\n                 GenericArgKind::Const(..) => {\n@@ -289,7 +214,12 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             | ty::PredicateAtom::ConstEquate(..) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::empty(interner))\n             }\n-        }\n+        };\n+\n+        chalk_ir::GoalData::Quantified(\n+            chalk_ir::QuantifierKind::ForAll,\n+            chalk_ir::Binders::new(binders, value.intern(interner)),\n+        )\n     }\n }\n \n@@ -304,25 +234,6 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::TraitRef<RustInterner<'tcx>>>\n     }\n }\n \n-impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>>\n-    for ty::PolyTraitPredicate<'tcx>\n-{\n-    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n-        let (ty, binders, _named_regions) = collect_bound_vars(interner, interner.tcx, &self);\n-\n-        chalk_ir::GoalData::Quantified(\n-            chalk_ir::QuantifierKind::ForAll,\n-            chalk_ir::Binders::new(\n-                binders,\n-                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n-                    chalk_ir::WhereClause::Implemented(ty.trait_ref.lower_into(interner)),\n-                ))\n-                .intern(interner),\n-            ),\n-        )\n-    }\n-}\n-\n impl<'tcx> LowerInto<'tcx, chalk_ir::AliasEq<RustInterner<'tcx>>>\n     for rustc_middle::ty::ProjectionPredicate<'tcx>\n {\n@@ -334,25 +245,6 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::AliasEq<RustInterner<'tcx>>>\n     }\n }\n \n-impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>>\n-    for ty::PolyProjectionPredicate<'tcx>\n-{\n-    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n-        let (ty, binders, _named_regions) = collect_bound_vars(interner, interner.tcx, &self);\n-\n-        chalk_ir::GoalData::Quantified(\n-            chalk_ir::QuantifierKind::ForAll,\n-            chalk_ir::Binders::new(\n-                binders,\n-                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n-                    chalk_ir::WhereClause::AliasEq(ty.lower_into(interner)),\n-                ))\n-                .intern(interner),\n-            ),\n-        )\n-    }\n-}\n-\n impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Ty<RustInterner<'tcx>> {\n         use chalk_ir::TyData;\n@@ -393,7 +285,8 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                 ast::FloatTy::F64 => float(chalk_ir::FloatTy::F64),\n             },\n             Adt(def, substs) => apply(struct_ty(def.did), substs.lower_into(interner)),\n-            Foreign(_def_id) => unimplemented!(),\n+            // FIXME(chalk): lower Foreign\n+            Foreign(def_id) => apply(chalk_ir::TypeName::FnDef(chalk_ir::FnDefId(def_id)), empty()),\n             Str => apply(chalk_ir::TypeName::Str, empty()),\n             Array(ty, len) => {\n                 let value = match len.val {\n@@ -520,6 +413,111 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n     }\n }\n \n+impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> Ty<'tcx> {\n+        use chalk_ir::TyData;\n+        use rustc_ast::ast;\n+\n+        let kind = match self.data(interner) {\n+            TyData::Apply(application_ty) => match application_ty.name {\n+                chalk_ir::TypeName::Adt(struct_id) => {\n+                    ty::Adt(struct_id.0, application_ty.substitution.lower_into(interner))\n+                }\n+                chalk_ir::TypeName::Scalar(scalar) => match scalar {\n+                    chalk_ir::Scalar::Bool => ty::Bool,\n+                    chalk_ir::Scalar::Char => ty::Char,\n+                    chalk_ir::Scalar::Int(int_ty) => match int_ty {\n+                        chalk_ir::IntTy::Isize => ty::Int(ast::IntTy::Isize),\n+                        chalk_ir::IntTy::I8 => ty::Int(ast::IntTy::I8),\n+                        chalk_ir::IntTy::I16 => ty::Int(ast::IntTy::I16),\n+                        chalk_ir::IntTy::I32 => ty::Int(ast::IntTy::I32),\n+                        chalk_ir::IntTy::I64 => ty::Int(ast::IntTy::I64),\n+                        chalk_ir::IntTy::I128 => ty::Int(ast::IntTy::I128),\n+                    },\n+                    chalk_ir::Scalar::Uint(int_ty) => match int_ty {\n+                        chalk_ir::UintTy::Usize => ty::Uint(ast::UintTy::Usize),\n+                        chalk_ir::UintTy::U8 => ty::Uint(ast::UintTy::U8),\n+                        chalk_ir::UintTy::U16 => ty::Uint(ast::UintTy::U16),\n+                        chalk_ir::UintTy::U32 => ty::Uint(ast::UintTy::U32),\n+                        chalk_ir::UintTy::U64 => ty::Uint(ast::UintTy::U64),\n+                        chalk_ir::UintTy::U128 => ty::Uint(ast::UintTy::U128),\n+                    },\n+                    chalk_ir::Scalar::Float(float_ty) => match float_ty {\n+                        chalk_ir::FloatTy::F32 => ty::Float(ast::FloatTy::F32),\n+                        chalk_ir::FloatTy::F64 => ty::Float(ast::FloatTy::F64),\n+                    },\n+                },\n+                chalk_ir::TypeName::Array => unimplemented!(),\n+                chalk_ir::TypeName::FnDef(id) => {\n+                    ty::FnDef(id.0, application_ty.substitution.lower_into(interner))\n+                }\n+                chalk_ir::TypeName::Closure(closure) => {\n+                    ty::Closure(closure.0, application_ty.substitution.lower_into(interner))\n+                }\n+                chalk_ir::TypeName::Never => ty::Never,\n+                chalk_ir::TypeName::Tuple(_size) => {\n+                    ty::Tuple(application_ty.substitution.lower_into(interner))\n+                }\n+                chalk_ir::TypeName::Slice => ty::Slice(\n+                    application_ty.substitution.as_slice(interner)[0]\n+                        .ty(interner)\n+                        .unwrap()\n+                        .lower_into(interner),\n+                ),\n+                chalk_ir::TypeName::Raw(mutbl) => ty::RawPtr(ty::TypeAndMut {\n+                    ty: application_ty.substitution.as_slice(interner)[0]\n+                        .ty(interner)\n+                        .unwrap()\n+                        .lower_into(interner),\n+                    mutbl: match mutbl {\n+                        chalk_ir::Mutability::Mut => ast::Mutability::Mut,\n+                        chalk_ir::Mutability::Not => ast::Mutability::Not,\n+                    },\n+                }),\n+                chalk_ir::TypeName::Ref(mutbl) => ty::Ref(\n+                    application_ty.substitution.as_slice(interner)[0]\n+                        .lifetime(interner)\n+                        .unwrap()\n+                        .lower_into(interner),\n+                    application_ty.substitution.as_slice(interner)[1]\n+                        .ty(interner)\n+                        .unwrap()\n+                        .lower_into(interner),\n+                    match mutbl {\n+                        chalk_ir::Mutability::Mut => ast::Mutability::Mut,\n+                        chalk_ir::Mutability::Not => ast::Mutability::Not,\n+                    },\n+                ),\n+                chalk_ir::TypeName::Str => ty::Str,\n+                chalk_ir::TypeName::OpaqueType(opaque_ty) => {\n+                    ty::Opaque(opaque_ty.0, application_ty.substitution.lower_into(interner))\n+                }\n+                chalk_ir::TypeName::AssociatedType(assoc_ty) => ty::Projection(ty::ProjectionTy {\n+                    substs: application_ty.substitution.lower_into(interner),\n+                    item_def_id: assoc_ty.0,\n+                }),\n+                chalk_ir::TypeName::Error => unimplemented!(),\n+            },\n+            TyData::Placeholder(placeholder) => ty::Placeholder(ty::Placeholder {\n+                universe: ty::UniverseIndex::from_usize(placeholder.ui.counter),\n+                name: ty::BoundVar::from_usize(placeholder.idx),\n+            }),\n+            TyData::Alias(_alias_ty) => unimplemented!(),\n+            TyData::Function(_quantified_ty) => unimplemented!(),\n+            TyData::BoundVar(_bound) => ty::Bound(\n+                ty::DebruijnIndex::from_usize(_bound.debruijn.depth() as usize),\n+                ty::BoundTy {\n+                    var: ty::BoundVar::from_usize(_bound.index),\n+                    kind: ty::BoundTyKind::Anon,\n+                },\n+            ),\n+            TyData::InferenceVar(_, _) => unimplemented!(),\n+            TyData::Dyn(_) => unimplemented!(),\n+        };\n+        interner.tcx.mk_ty(kind)\n+    }\n+}\n+\n impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Lifetime<RustInterner<'tcx>> {\n         use rustc_middle::ty::RegionKind::*;\n@@ -557,6 +555,59 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'t\n     }\n }\n \n+impl<'tcx> LowerInto<'tcx, Region<'tcx>> for &chalk_ir::Lifetime<RustInterner<'tcx>> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> Region<'tcx> {\n+        let kind = match self.data(interner) {\n+            chalk_ir::LifetimeData::BoundVar(var) => ty::RegionKind::ReLateBound(\n+                ty::DebruijnIndex::from_u32(var.debruijn.depth()),\n+                ty::BoundRegion::BrAnon(var.index as u32),\n+            ),\n+            chalk_ir::LifetimeData::InferenceVar(_var) => unimplemented!(),\n+            chalk_ir::LifetimeData::Placeholder(p) => {\n+                ty::RegionKind::RePlaceholder(ty::Placeholder {\n+                    universe: ty::UniverseIndex::from_usize(p.ui.counter),\n+                    name: ty::BoundRegion::BrAnon(p.idx as u32),\n+                })\n+            }\n+            chalk_ir::LifetimeData::Phantom(_, _) => unimplemented!(),\n+        };\n+        interner.tcx.mk_region(kind)\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_ir::Const<RustInterner<'tcx>>> for ty::Const<'tcx> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Const<RustInterner<'tcx>> {\n+        let ty = self.ty.lower_into(interner);\n+        let value = match self.val {\n+            ty::ConstKind::Value(val) => {\n+                chalk_ir::ConstValue::Concrete(chalk_ir::ConcreteConst { interned: val })\n+            }\n+            ty::ConstKind::Bound(db, bound) => chalk_ir::ConstValue::BoundVar(\n+                chalk_ir::BoundVar::new(chalk_ir::DebruijnIndex::new(db.as_u32()), bound.index()),\n+            ),\n+            _ => unimplemented!(\"Const not implemented. {:?}\", self),\n+        };\n+        chalk_ir::ConstData { ty, value }.intern(interner)\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, ty::Const<'tcx>> for &chalk_ir::Const<RustInterner<'tcx>> {\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> ty::Const<'tcx> {\n+        let data = self.data(interner);\n+        let ty = data.ty.lower_into(interner);\n+        let val = match data.value {\n+            chalk_ir::ConstValue::BoundVar(var) => ty::ConstKind::Bound(\n+                ty::DebruijnIndex::from_u32(var.debruijn.depth()),\n+                ty::BoundVar::from_u32(var.index as u32),\n+            ),\n+            chalk_ir::ConstValue::InferenceVar(_var) => unimplemented!(),\n+            chalk_ir::ConstValue::Placeholder(_p) => unimplemented!(),\n+            chalk_ir::ConstValue::Concrete(c) => ty::ConstKind::Value(c.interned),\n+        };\n+        ty::Const { ty, val }\n+    }\n+}\n+\n impl<'tcx> LowerInto<'tcx, chalk_ir::GenericArg<RustInterner<'tcx>>> for GenericArg<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GenericArg<RustInterner<'tcx>> {\n         match self.unpack() {\n@@ -566,18 +617,35 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GenericArg<RustInterner<'tcx>>> for Generic\n             ty::subst::GenericArgKind::Lifetime(lifetime) => {\n                 chalk_ir::GenericArgData::Lifetime(lifetime.lower_into(interner))\n             }\n-            ty::subst::GenericArgKind::Const(_) => chalk_ir::GenericArgData::Ty(\n-                chalk_ir::TyData::Apply(chalk_ir::ApplicationTy {\n-                    name: chalk_ir::TypeName::Tuple(0),\n-                    substitution: chalk_ir::Substitution::empty(interner),\n-                })\n-                .intern(interner),\n-            ),\n+            ty::subst::GenericArgKind::Const(c) => {\n+                chalk_ir::GenericArgData::Const(c.lower_into(interner))\n+            }\n         }\n         .intern(interner)\n     }\n }\n \n+impl<'tcx> LowerInto<'tcx, ty::subst::GenericArg<'tcx>>\n+    for &chalk_ir::GenericArg<RustInterner<'tcx>>\n+{\n+    fn lower_into(self, interner: &RustInterner<'tcx>) -> ty::subst::GenericArg<'tcx> {\n+        match self.data(interner) {\n+            chalk_ir::GenericArgData::Ty(ty) => {\n+                let t: Ty<'tcx> = ty.lower_into(interner);\n+                t.into()\n+            }\n+            chalk_ir::GenericArgData::Lifetime(lifetime) => {\n+                let r: Region<'tcx> = lifetime.lower_into(interner);\n+                r.into()\n+            }\n+            chalk_ir::GenericArgData::Const(c) => {\n+                let c: ty::Const<'tcx> = c.lower_into(interner);\n+                interner.tcx.mk_const(c).into()\n+            }\n+        }\n+    }\n+}\n+\n // We lower into an Option here since there are some predicates which Chalk\n // doesn't have a representation for yet (as a `WhereClause`), but are so common\n // that we just are accepting the unsoundness for now. The `Option` will\n@@ -589,41 +657,36 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        // FIXME(chalk): forall\n-        match self.bound_atom(interner.tcx).skip_binder() {\n+        let (predicate, binders, _named_regions) =\n+            collect_bound_vars(interner, interner.tcx, &self.bound_atom(interner.tcx));\n+        let value = match predicate {\n             ty::PredicateAtom::Trait(predicate, _) => {\n-                let predicate = ty::Binder::bind(predicate);\n-                let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, &predicate);\n-\n-                Some(chalk_ir::Binders::new(\n-                    binders,\n-                    chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n-                ))\n+                Some(chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)))\n             }\n             ty::PredicateAtom::RegionOutlives(predicate) => {\n-                let predicate = ty::Binder::bind(predicate);\n-                let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, &predicate);\n-\n-                Some(chalk_ir::Binders::new(\n-                    binders,\n-                    chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n-                        a: predicate.0.lower_into(interner),\n-                        b: predicate.1.lower_into(interner),\n-                    }),\n-                ))\n+                Some(chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n+                    a: predicate.0.lower_into(interner),\n+                    b: predicate.1.lower_into(interner),\n+                }))\n+            }\n+            ty::PredicateAtom::TypeOutlives(predicate) => {\n+                Some(chalk_ir::WhereClause::TypeOutlives(chalk_ir::TypeOutlives {\n+                    ty: predicate.0.lower_into(interner),\n+                    lifetime: predicate.1.lower_into(interner),\n+                }))\n+            }\n+            ty::PredicateAtom::Projection(predicate) => {\n+                Some(chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)))\n             }\n-            ty::PredicateAtom::TypeOutlives(_predicate) => None,\n-            ty::PredicateAtom::Projection(_predicate) => None,\n             ty::PredicateAtom::WellFormed(_ty) => None,\n \n             ty::PredicateAtom::ObjectSafe(..)\n             | ty::PredicateAtom::ClosureKind(..)\n             | ty::PredicateAtom::Subtype(..)\n             | ty::PredicateAtom::ConstEvaluatable(..)\n             | ty::PredicateAtom::ConstEquate(..) => bug!(\"unexpected predicate {}\", &self),\n-        }\n+        };\n+        value.map(|value| chalk_ir::Binders::new(binders, value))\n     }\n }\n \n@@ -636,13 +699,21 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n     ) -> chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<RustInterner<'tcx>>> {\n         let (predicates, binders, _named_regions) =\n             collect_bound_vars(interner, interner.tcx, &self);\n+        let self_ty = interner.tcx.mk_ty(ty::Bound(\n+            // This is going to be wrapped in a binder\n+            ty::DebruijnIndex::from_usize(1),\n+            ty::BoundTy { var: ty::BoundVar::from_usize(0), kind: ty::BoundTyKind::Anon },\n+        ));\n         let where_clauses = predicates.into_iter().map(|predicate| match predicate {\n             ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef { def_id, substs }) => {\n                 chalk_ir::Binders::new(\n                     chalk_ir::VariableKinds::empty(interner),\n                     chalk_ir::WhereClause::Implemented(chalk_ir::TraitRef {\n                         trait_id: chalk_ir::TraitId(def_id),\n-                        substitution: substs.lower_into(interner),\n+                        substitution: interner\n+                            .tcx\n+                            .mk_substs_trait(self_ty, substs)\n+                            .lower_into(interner),\n                     }),\n                 )\n             }\n@@ -651,7 +722,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n                 chalk_ir::VariableKinds::empty(interner),\n                 chalk_ir::WhereClause::Implemented(chalk_ir::TraitRef {\n                     trait_id: chalk_ir::TraitId(def_id),\n-                    substitution: chalk_ir::Substitution::empty(interner),\n+                    substitution: interner.tcx.mk_substs_trait(self_ty, &[]).lower_into(interner),\n                 }),\n             ),\n         });\n@@ -843,16 +914,18 @@ crate struct ParamsSubstitutor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     binder_index: ty::DebruijnIndex,\n     list: Vec<rustc_middle::ty::ParamTy>,\n+    next_ty_placehoder: usize,\n     crate params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n     crate named_regions: BTreeMap<DefId, u32>,\n }\n \n impl<'tcx> ParamsSubstitutor<'tcx> {\n-    crate fn new(tcx: TyCtxt<'tcx>) -> Self {\n+    crate fn new(tcx: TyCtxt<'tcx>, next_ty_placehoder: usize) -> Self {\n         ParamsSubstitutor {\n             tcx,\n             binder_index: ty::INNERMOST,\n             list: vec![],\n+            next_ty_placehoder,\n             params: rustc_data_structures::fx::FxHashMap::default(),\n             named_regions: BTreeMap::default(),\n         }\n@@ -878,13 +951,13 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n             // first pass to collect placeholders. Then we can insert params after.\n             ty::Placeholder(_) => unimplemented!(),\n             ty::Param(param) => match self.list.iter().position(|r| r == &param) {\n-                Some(_idx) => self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n+                Some(idx) => self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                     universe: ty::UniverseIndex::from_usize(0),\n-                    name: ty::BoundVar::from_usize(_idx),\n+                    name: ty::BoundVar::from_usize(idx),\n                 })),\n                 None => {\n                     self.list.push(param);\n-                    let idx = self.list.len() - 1;\n+                    let idx = self.list.len() - 1 + self.next_ty_placehoder;\n                     self.params.insert(idx, param);\n                     self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                         universe: ty::UniverseIndex::from_usize(0),\n@@ -920,3 +993,95 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n         }\n     }\n }\n+\n+/// Used to collect `Placeholder`s.\n+crate struct PlaceholdersCollector {\n+    universe_index: ty::UniverseIndex,\n+    crate next_ty_placehoder: usize,\n+    crate next_anon_region_placeholder: u32,\n+}\n+\n+impl PlaceholdersCollector {\n+    crate fn new() -> Self {\n+        PlaceholdersCollector {\n+            universe_index: ty::UniverseIndex::ROOT,\n+            next_ty_placehoder: 0,\n+            next_anon_region_placeholder: 0,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for PlaceholdersCollector {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        match t.kind {\n+            ty::Placeholder(p) if p.universe == self.universe_index => {\n+                self.next_ty_placehoder = self.next_ty_placehoder.max(p.name.as_usize() + 1);\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: Region<'tcx>) -> bool {\n+        match r {\n+            ty::RePlaceholder(p) if p.universe == self.universe_index => {\n+                if let ty::BoundRegion::BrAnon(anon) = p.name {\n+                    self.next_anon_region_placeholder = self.next_anon_region_placeholder.max(anon);\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n+    }\n+}\n+\n+/// Used to substitute specific `Regions`s with placeholders.\n+crate struct RegionsSubstitutor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    restatic_placeholder: ty::Region<'tcx>,\n+    reempty_placeholder: ty::Region<'tcx>,\n+}\n+\n+impl<'tcx> RegionsSubstitutor<'tcx> {\n+    crate fn new(\n+        tcx: TyCtxt<'tcx>,\n+        restatic_placeholder: ty::Region<'tcx>,\n+        reempty_placeholder: ty::Region<'tcx>,\n+    ) -> Self {\n+        RegionsSubstitutor { tcx, restatic_placeholder, reempty_placeholder }\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for RegionsSubstitutor<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> Binder<T> {\n+        t.super_fold_with(self)\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        t.super_fold_with(self)\n+    }\n+\n+    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n+        match r {\n+            ty::ReStatic => self.restatic_placeholder,\n+            ty::ReEmpty(ui) => {\n+                assert_eq!(ui.as_usize(), 0);\n+                self.reempty_placeholder\n+            }\n+\n+            _ => r.super_fold_with(self),\n+        }\n+    }\n+}"}, {"sha": "a8e5bae0fc41fe3544d9780f16f99855c6a9ec5c", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 26, "deletions": 95, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/76c728901e6b9d9b1c90de78c0f612f7a3fc63d5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c728901e6b9d9b1c90de78c0f612f7a3fc63d5/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=76c728901e6b9d9b1c90de78c0f612f7a3fc63d5", "patch": "@@ -15,17 +15,17 @@ use rustc_middle::infer::canonical::{CanonicalTyVarKind, CanonicalVarKind};\n use rustc_middle::traits::ChalkRustInterner;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::GenericArg;\n-use rustc_middle::ty::{\n-    self, Bound, BoundVar, ParamTy, Region, RegionKind, Ty, TyCtxt, TypeFoldable,\n-};\n+use rustc_middle::ty::{self, BoundVar, ParamTy, TyCtxt, TypeFoldable};\n \n use rustc_infer::infer::canonical::{\n     Canonical, CanonicalVarValues, Certainty, QueryRegionConstraints, QueryResponse,\n };\n use rustc_infer::traits::{self, ChalkCanonicalGoal};\n \n use crate::chalk::db::RustIrDatabase as ChalkRustIrDatabase;\n-use crate::chalk::lowering::{LowerInto, ParamsSubstitutor};\n+use crate::chalk::lowering::{\n+    LowerInto, ParamsSubstitutor, PlaceholdersCollector, RegionsSubstitutor,\n+};\n \n use chalk_solve::Solution;\n \n@@ -40,9 +40,27 @@ crate fn evaluate_goal<'tcx>(\n     let interner = ChalkRustInterner { tcx };\n \n     // Chalk doesn't have a notion of `Params`, so instead we use placeholders.\n-    let mut params_substitutor = ParamsSubstitutor::new(tcx);\n+    let mut placeholders_collector = PlaceholdersCollector::new();\n+    obligation.visit_with(&mut placeholders_collector);\n+\n+    let restatic_placeholder = tcx.mk_region(ty::RegionKind::RePlaceholder(ty::Placeholder {\n+        universe: ty::UniverseIndex::ROOT,\n+        name: ty::BoundRegion::BrAnon(placeholders_collector.next_anon_region_placeholder),\n+    }));\n+    let reempty_placeholder = tcx.mk_region(ty::RegionKind::RePlaceholder(ty::Placeholder {\n+        universe: ty::UniverseIndex::ROOT,\n+        name: ty::BoundRegion::BrAnon(placeholders_collector.next_anon_region_placeholder + 1),\n+    }));\n+\n+    let mut params_substitutor =\n+        ParamsSubstitutor::new(tcx, placeholders_collector.next_ty_placehoder);\n     let obligation = obligation.fold_with(&mut params_substitutor);\n     let _params: FxHashMap<usize, ParamTy> = params_substitutor.params;\n+\n+    let mut regions_substitutor =\n+        RegionsSubstitutor::new(tcx, restatic_placeholder, reempty_placeholder);\n+    let obligation = obligation.fold_with(&mut regions_substitutor);\n+\n     let max_universe = obligation.max_universe.index();\n \n     let _lowered_goal: chalk_ir::UCanonical<\n@@ -83,7 +101,7 @@ crate fn evaluate_goal<'tcx>(\n \n     use chalk_solve::Solver;\n     let mut solver = chalk_engine::solve::SLGSolver::new(32, None);\n-    let db = ChalkRustIrDatabase { tcx, interner };\n+    let db = ChalkRustIrDatabase { tcx, interner, restatic_placeholder, reempty_placeholder };\n     let solution = chalk_solve::logging::with_tracing_logs(|| solver.solve(&db, &_lowered_goal));\n \n     // Ideally, the code to convert *back* to rustc types would live close to\n@@ -94,94 +112,7 @@ crate fn evaluate_goal<'tcx>(\n     let make_solution = |_subst: chalk_ir::Substitution<_>| {\n         let mut var_values: IndexVec<BoundVar, GenericArg<'tcx>> = IndexVec::new();\n         _subst.as_slice(&interner).iter().for_each(|p| {\n-            // FIXME(chalk): we should move this elsewhere, since this is\n-            // essentially inverse of lowering a `GenericArg`.\n-            let _data = p.data(&interner);\n-            match _data {\n-                chalk_ir::GenericArgData::Ty(_t) => {\n-                    use chalk_ir::TyData;\n-                    use rustc_ast as ast;\n-\n-                    let _data = _t.data(&interner);\n-                    let kind = match _data {\n-                        TyData::Apply(_application_ty) => match _application_ty.name {\n-                            chalk_ir::TypeName::Adt(_struct_id) => unimplemented!(),\n-                            chalk_ir::TypeName::Scalar(scalar) => match scalar {\n-                                chalk_ir::Scalar::Bool => ty::Bool,\n-                                chalk_ir::Scalar::Char => ty::Char,\n-                                chalk_ir::Scalar::Int(int_ty) => match int_ty {\n-                                    chalk_ir::IntTy::Isize => ty::Int(ast::IntTy::Isize),\n-                                    chalk_ir::IntTy::I8 => ty::Int(ast::IntTy::I8),\n-                                    chalk_ir::IntTy::I16 => ty::Int(ast::IntTy::I16),\n-                                    chalk_ir::IntTy::I32 => ty::Int(ast::IntTy::I32),\n-                                    chalk_ir::IntTy::I64 => ty::Int(ast::IntTy::I64),\n-                                    chalk_ir::IntTy::I128 => ty::Int(ast::IntTy::I128),\n-                                },\n-                                chalk_ir::Scalar::Uint(int_ty) => match int_ty {\n-                                    chalk_ir::UintTy::Usize => ty::Uint(ast::UintTy::Usize),\n-                                    chalk_ir::UintTy::U8 => ty::Uint(ast::UintTy::U8),\n-                                    chalk_ir::UintTy::U16 => ty::Uint(ast::UintTy::U16),\n-                                    chalk_ir::UintTy::U32 => ty::Uint(ast::UintTy::U32),\n-                                    chalk_ir::UintTy::U64 => ty::Uint(ast::UintTy::U64),\n-                                    chalk_ir::UintTy::U128 => ty::Uint(ast::UintTy::U128),\n-                                },\n-                                chalk_ir::Scalar::Float(float_ty) => match float_ty {\n-                                    chalk_ir::FloatTy::F32 => ty::Float(ast::FloatTy::F32),\n-                                    chalk_ir::FloatTy::F64 => ty::Float(ast::FloatTy::F64),\n-                                },\n-                            },\n-                            chalk_ir::TypeName::Array => unimplemented!(),\n-                            chalk_ir::TypeName::FnDef(_) => unimplemented!(),\n-                            chalk_ir::TypeName::Closure(_) => unimplemented!(),\n-                            chalk_ir::TypeName::Never => unimplemented!(),\n-                            chalk_ir::TypeName::Tuple(_size) => unimplemented!(),\n-                            chalk_ir::TypeName::Slice => unimplemented!(),\n-                            chalk_ir::TypeName::Raw(_) => unimplemented!(),\n-                            chalk_ir::TypeName::Ref(_) => unimplemented!(),\n-                            chalk_ir::TypeName::Str => unimplemented!(),\n-                            chalk_ir::TypeName::OpaqueType(_ty) => unimplemented!(),\n-                            chalk_ir::TypeName::AssociatedType(_assoc_ty) => unimplemented!(),\n-                            chalk_ir::TypeName::Error => unimplemented!(),\n-                        },\n-                        TyData::Placeholder(_placeholder) => {\n-                            unimplemented!();\n-                        }\n-                        TyData::Alias(_alias_ty) => unimplemented!(),\n-                        TyData::Function(_quantified_ty) => unimplemented!(),\n-                        TyData::BoundVar(_bound) => Bound(\n-                            ty::DebruijnIndex::from_usize(_bound.debruijn.depth() as usize),\n-                            ty::BoundTy {\n-                                var: ty::BoundVar::from_usize(_bound.index),\n-                                kind: ty::BoundTyKind::Anon,\n-                            },\n-                        ),\n-                        TyData::InferenceVar(_, _) => unimplemented!(),\n-                        TyData::Dyn(_) => unimplemented!(),\n-                    };\n-                    let _ty: Ty<'_> = tcx.mk_ty(kind);\n-                    let _arg: GenericArg<'_> = _ty.into();\n-                    var_values.push(_arg);\n-                }\n-                chalk_ir::GenericArgData::Lifetime(_l) => {\n-                    let _data = _l.data(&interner);\n-                    let _lifetime: Region<'_> = match _data {\n-                        chalk_ir::LifetimeData::BoundVar(_var) => {\n-                            tcx.mk_region(RegionKind::ReLateBound(\n-                                rustc_middle::ty::DebruijnIndex::from_usize(\n-                                    _var.debruijn.depth() as usize\n-                                ),\n-                                rustc_middle::ty::BoundRegion::BrAnon(_var.index as u32),\n-                            ))\n-                        }\n-                        chalk_ir::LifetimeData::InferenceVar(_var) => unimplemented!(),\n-                        chalk_ir::LifetimeData::Placeholder(_index) => unimplemented!(),\n-                        chalk_ir::LifetimeData::Phantom(_, _) => unimplemented!(),\n-                    };\n-                    let _arg: GenericArg<'_> = _lifetime.into();\n-                    var_values.push(_arg);\n-                }\n-                chalk_ir::GenericArgData::Const(_) => unimplemented!(),\n-            }\n+            var_values.push(p.lower_into(&interner));\n         });\n         let sol = Canonical {\n             max_universe: ty::UniverseIndex::from_usize(0),\n@@ -193,7 +124,7 @@ crate fn evaluate_goal<'tcx>(\n                 value: (),\n             },\n         };\n-        &*tcx.arena.alloc(sol)\n+        tcx.arena.alloc(sol)\n     };\n     solution\n         .map(|s| match s {"}]}