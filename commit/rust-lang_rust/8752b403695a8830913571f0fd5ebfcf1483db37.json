{"sha": "8752b403695a8830913571f0fd5ebfcf1483db37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NTJiNDAzNjk1YTg4MzA5MTM1NzFmMGZkNWViZmNmMTQ4M2RiMzc=", "commit": {"author": {"name": "Alex Huszagh", "email": "ahuszagh@gmail.com", "date": "2021-07-17T05:30:34Z"}, "committer": {"name": "Alex Huszagh", "email": "ahuszagh@gmail.com", "date": "2021-07-17T05:30:34Z"}, "message": "Changed dec2flt to use the Eisel-Lemire algorithm.\n\nImplementation is based off fast-float-rust, with a few notable changes.\n\n- Some unsafe methods have been removed.\n- Safe methods with inherently unsafe functionality have been removed.\n- All unsafe functionality is documented and provably safe.\n- Extensive documentation has been added for simpler maintenance.\n- Inline annotations on internal routines has been removed.\n- Fixed Python errors in src/etc/test-float-parse/runtests.py.\n- Updated test-float-parse to be a library, to avoid missing rand dependency.\n- Added regression tests for #31109 and #31407 in core tests.\n- Added regression tests for #31109 and #31407 in ui tests.\n- Use the existing slice primitive to simplify shared dec2flt methods\n- Remove Miri ignores from dec2flt, due to faster parsing times.\n\n- resolves #85198\n- resolves #85214\n- resolves #85234\n- fixes #31407\n- fixes #31109\n- fixes #53015\n- resolves #68396\n- closes https://github.com/aldanor/fast-float-rust/issues/15", "tree": {"sha": "fba1ac7613edb617bee5b257b21bd6d10dad0662", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fba1ac7613edb617bee5b257b21bd6d10dad0662"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8752b403695a8830913571f0fd5ebfcf1483db37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8752b403695a8830913571f0fd5ebfcf1483db37", "html_url": "https://github.com/rust-lang/rust/commit/8752b403695a8830913571f0fd5ebfcf1483db37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8752b403695a8830913571f0fd5ebfcf1483db37/comments", "author": {"login": "Alexhuszagh", "id": 9440903, "node_id": "MDQ6VXNlcjk0NDA5MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/9440903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexhuszagh", "html_url": "https://github.com/Alexhuszagh", "followers_url": "https://api.github.com/users/Alexhuszagh/followers", "following_url": "https://api.github.com/users/Alexhuszagh/following{/other_user}", "gists_url": "https://api.github.com/users/Alexhuszagh/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexhuszagh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexhuszagh/subscriptions", "organizations_url": "https://api.github.com/users/Alexhuszagh/orgs", "repos_url": "https://api.github.com/users/Alexhuszagh/repos", "events_url": "https://api.github.com/users/Alexhuszagh/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexhuszagh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Alexhuszagh", "id": 9440903, "node_id": "MDQ6VXNlcjk0NDA5MDM=", "avatar_url": "https://avatars.githubusercontent.com/u/9440903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Alexhuszagh", "html_url": "https://github.com/Alexhuszagh", "followers_url": "https://api.github.com/users/Alexhuszagh/followers", "following_url": "https://api.github.com/users/Alexhuszagh/following{/other_user}", "gists_url": "https://api.github.com/users/Alexhuszagh/gists{/gist_id}", "starred_url": "https://api.github.com/users/Alexhuszagh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Alexhuszagh/subscriptions", "organizations_url": "https://api.github.com/users/Alexhuszagh/orgs", "repos_url": "https://api.github.com/users/Alexhuszagh/repos", "events_url": "https://api.github.com/users/Alexhuszagh/events{/privacy}", "received_events_url": "https://api.github.com/users/Alexhuszagh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2b04f075c0ce010758c4c8674152ff89d1d73f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2b04f075c0ce010758c4c8674152ff89d1d73f3", "html_url": "https://github.com/rust-lang/rust/commit/d2b04f075c0ce010758c4c8674152ff89d1d73f3"}], "stats": {"total": 5353, "additions": 2530, "deletions": 2823}, "files": [{"sha": "58902c5e469f12b6d31274503cf23304c8a92d7a", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -172,7 +172,6 @@ pub enum LitToConstError {\n     /// This is used for graceful error handling (`delay_span_bug`) in\n     /// type checking (`Const::from_anon_const`).\n     TypeError,\n-    UnparseableFloat,\n     Reported,\n }\n "}, {"sha": "1592a1e976eb6daf8cdd7a808fd5c733e59650d5", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -46,9 +46,7 @@ crate fn lit_to_const<'tcx>(\n         (ast::LitKind::Int(n, _), ty::Uint(_)) | (ast::LitKind::Int(n, _), ty::Int(_)) => {\n             trunc(if neg { (*n as i128).overflowing_neg().0 as u128 } else { *n })?\n         }\n-        (ast::LitKind::Float(n, _), ty::Float(fty)) => {\n-            parse_float(*n, *fty, neg).map_err(|_| LitToConstError::UnparseableFloat)?\n-        }\n+        (ast::LitKind::Float(n, _), ty::Float(fty)) => parse_float(*n, *fty, neg),\n         (ast::LitKind::Bool(b), ty::Bool) => ConstValue::Scalar(Scalar::from_bool(*b)),\n         (ast::LitKind::Char(c), ty::Char) => ConstValue::Scalar(Scalar::from_char(*c)),\n         (ast::LitKind::Err(_), _) => return Err(LitToConstError::Reported),\n@@ -57,12 +55,14 @@ crate fn lit_to_const<'tcx>(\n     Ok(ty::Const::from_value(tcx, lit, ty))\n }\n \n-fn parse_float<'tcx>(num: Symbol, fty: ty::FloatTy, neg: bool) -> Result<ConstValue<'tcx>, ()> {\n+fn parse_float<'tcx>(num: Symbol, fty: ty::FloatTy, neg: bool) -> ConstValue<'tcx> {\n     let num = num.as_str();\n     use rustc_apfloat::ieee::{Double, Single};\n     let scalar = match fty {\n         ty::FloatTy::F32 => {\n-            let rust_f = num.parse::<f32>().map_err(|_| ())?;\n+            let rust_f = num\n+                .parse::<f32>()\n+                .unwrap_or_else(|e| panic!(\"f32 failed to parse `{}`: {:?}\", num, e));\n             let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n                 panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n             });\n@@ -82,7 +82,9 @@ fn parse_float<'tcx>(num: Symbol, fty: ty::FloatTy, neg: bool) -> Result<ConstVa\n             Scalar::from_f32(f)\n         }\n         ty::FloatTy::F64 => {\n-            let rust_f = num.parse::<f64>().map_err(|_| ())?;\n+            let rust_f = num\n+                .parse::<f64>()\n+                .unwrap_or_else(|e| panic!(\"f64 failed to parse `{}`: {:?}\", num, e));\n             let mut f = num.parse::<Double>().unwrap_or_else(|e| {\n                 panic!(\"apfloat::ieee::Double failed to parse `{}`: {:?}\", num, e)\n             });\n@@ -103,5 +105,5 @@ fn parse_float<'tcx>(num: Symbol, fty: ty::FloatTy, neg: bool) -> Result<ConstVa\n         }\n     };\n \n-    Ok(ConstValue::Scalar(scalar))\n+    ConstValue::Scalar(scalar)\n }"}, {"sha": "604e544286aefb9fc229f76954190f3cb7cfd7fa", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -67,12 +67,6 @@ impl<'tcx> Cx<'tcx> {\n \n         match self.tcx.at(sp).lit_to_const(LitToConstInput { lit, ty, neg }) {\n             Ok(c) => c,\n-            Err(LitToConstError::UnparseableFloat) => {\n-                // FIXME(#31407) this is only necessary because float parsing is buggy\n-                self.tcx.sess.span_err(sp, \"could not evaluate float literal (see issue #31407)\");\n-                // create a dummy value and continue compiling\n-                self.tcx.const_error(ty)\n-            }\n             Err(LitToConstError::Reported) => {\n                 // create a dummy value and continue compiling\n                 self.tcx.const_error(ty)"}, {"sha": "22c07fbec68279e357e3afb09b315ddbff2ad1aa", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -84,7 +84,7 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n }\n \n impl PatCtxt<'_, '_> {\n-    fn report_inlining_errors(&self, pat_span: Span) {\n+    fn report_inlining_errors(&self) {\n         for error in &self.errors {\n             match *error {\n                 PatternError::StaticInPattern(span) => {\n@@ -96,14 +96,6 @@ impl PatCtxt<'_, '_> {\n                 PatternError::ConstParamInPattern(span) => {\n                     self.span_e0158(span, \"const parameters cannot be referenced in patterns\")\n                 }\n-                PatternError::FloatBug => {\n-                    // FIXME(#31407) this is only necessary because float parsing is buggy\n-                    rustc_middle::mir::interpret::struct_error(\n-                        self.tcx.at(pat_span),\n-                        \"could not evaluate float literal (see issue #31407)\",\n-                    )\n-                    .emit();\n-                }\n                 PatternError::NonConstPath(span) => {\n                     rustc_middle::mir::interpret::struct_error(\n                         self.tcx.at(span),\n@@ -142,7 +134,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(pattern));\n         if !patcx.errors.is_empty() {\n             *have_errors = true;\n-            patcx.report_inlining_errors(pat.span);\n+            patcx.report_inlining_errors();\n         }\n         (pattern, pattern_ty)\n     }"}, {"sha": "c3adbb422157a4dc94478031036189e0369d4f40", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -31,7 +31,6 @@ crate enum PatternError {\n     AssocConstInPattern(Span),\n     ConstParamInPattern(Span),\n     StaticInPattern(Span),\n-    FloatBug,\n     NonConstPath(Span),\n }\n \n@@ -563,10 +562,6 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 LitToConstInput { lit: &lit.node, ty: self.typeck_results.expr_ty(expr), neg };\n             match self.tcx.at(expr.span).lit_to_const(lit_input) {\n                 Ok(val) => *self.const_to_pat(val, expr.hir_id, lit.span, false).kind,\n-                Err(LitToConstError::UnparseableFloat) => {\n-                    self.errors.push(PatternError::FloatBug);\n-                    PatKind::Wild\n-                }\n                 Err(LitToConstError::Reported) => PatKind::Wild,\n                 Err(LitToConstError::TypeError) => bug!(\"lower_lit: had type error\"),\n             }"}, {"sha": "313b6870ac9d30bd07d5baf1777b2d2a153490d0", "filename": "library/core/src/num/dec2flt/algorithm.rs", "status": "removed", "additions": 0, "deletions": 429, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/d2b04f075c0ce010758c4c8674152ff89d1d73f3/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b04f075c0ce010758c4c8674152ff89d1d73f3/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=d2b04f075c0ce010758c4c8674152ff89d1d73f3", "patch": "@@ -1,429 +0,0 @@\n-//! The various algorithms from the paper.\n-\n-use crate::cmp::min;\n-use crate::cmp::Ordering::{Equal, Greater, Less};\n-use crate::num::dec2flt::num::{self, Big};\n-use crate::num::dec2flt::rawfp::{self, fp_to_float, next_float, prev_float, RawFloat, Unpacked};\n-use crate::num::dec2flt::table;\n-use crate::num::diy_float::Fp;\n-\n-/// Number of significand bits in Fp\n-const P: u32 = 64;\n-\n-// We simply store the best approximation for *all* exponents, so the variable \"h\" and the\n-// associated conditions can be omitted. This trades performance for a couple kilobytes of space.\n-\n-fn power_of_ten(e: i16) -> Fp {\n-    assert!(e >= table::MIN_E);\n-    let i = e - table::MIN_E;\n-    let sig = table::POWERS.0[i as usize];\n-    let exp = table::POWERS.1[i as usize];\n-    Fp { f: sig, e: exp }\n-}\n-\n-// In most architectures, floating point operations have an explicit bit size, therefore the\n-// precision of the computation is determined on a per-operation basis.\n-#[cfg(any(not(target_arch = \"x86\"), target_feature = \"sse2\"))]\n-mod fpu_precision {\n-    pub fn set_precision<T>() {}\n-}\n-\n-// On x86, the x87 FPU is used for float operations if the SSE/SSE2 extensions are not available.\n-// The x87 FPU operates with 80 bits of precision by default, which means that operations will\n-// round to 80 bits causing double rounding to happen when values are eventually represented as\n-// 32/64 bit float values. To overcome this, the FPU control word can be set so that the\n-// computations are performed in the desired precision.\n-#[cfg(all(target_arch = \"x86\", not(target_feature = \"sse2\")))]\n-mod fpu_precision {\n-    use crate::mem::size_of;\n-\n-    /// A structure used to preserve the original value of the FPU control word, so that it can be\n-    /// restored when the structure is dropped.\n-    ///\n-    /// The x87 FPU is a 16-bits register whose fields are as follows:\n-    ///\n-    /// | 12-15 | 10-11 | 8-9 | 6-7 |  5 |  4 |  3 |  2 |  1 |  0 |\n-    /// |------:|------:|----:|----:|---:|---:|---:|---:|---:|---:|\n-    /// |       | RC    | PC  |     | PM | UM | OM | ZM | DM | IM |\n-    ///\n-    /// The documentation for all of the fields is available in the IA-32 Architectures Software\n-    /// Developer's Manual (Volume 1).\n-    ///\n-    /// The only field which is relevant for the following code is PC, Precision Control. This\n-    /// field determines the precision of the operations performed by the  FPU. It can be set to:\n-    ///  - 0b00, single precision i.e., 32-bits\n-    ///  - 0b10, double precision i.e., 64-bits\n-    ///  - 0b11, double extended precision i.e., 80-bits (default state)\n-    /// The 0b01 value is reserved and should not be used.\n-    pub struct FPUControlWord(u16);\n-\n-    fn set_cw(cw: u16) {\n-        // SAFETY: the `fldcw` instruction has been audited to be able to work correctly with\n-        // any `u16`\n-        unsafe {\n-            asm!(\n-                \"fldcw word ptr [{}]\",\n-                in(reg) &cw,\n-                options(nostack),\n-            )\n-        }\n-    }\n-\n-    /// Sets the precision field of the FPU to `T` and returns a `FPUControlWord`.\n-    pub fn set_precision<T>() -> FPUControlWord {\n-        let mut cw = 0_u16;\n-\n-        // Compute the value for the Precision Control field that is appropriate for `T`.\n-        let cw_precision = match size_of::<T>() {\n-            4 => 0x0000, // 32 bits\n-            8 => 0x0200, // 64 bits\n-            _ => 0x0300, // default, 80 bits\n-        };\n-\n-        // Get the original value of the control word to restore it later, when the\n-        // `FPUControlWord` structure is dropped\n-        // SAFETY: the `fnstcw` instruction has been audited to be able to work correctly with\n-        // any `u16`\n-        unsafe {\n-            asm!(\n-                \"fnstcw word ptr [{}]\",\n-                in(reg) &mut cw,\n-                options(nostack),\n-            )\n-        }\n-\n-        // Set the control word to the desired precision. This is achieved by masking away the old\n-        // precision (bits 8 and 9, 0x300) and replacing it with the precision flag computed above.\n-        set_cw((cw & 0xFCFF) | cw_precision);\n-\n-        FPUControlWord(cw)\n-    }\n-\n-    impl Drop for FPUControlWord {\n-        fn drop(&mut self) {\n-            set_cw(self.0)\n-        }\n-    }\n-}\n-\n-/// The fast path of Bellerophon using machine-sized integers and floats.\n-///\n-/// This is extracted into a separate function so that it can be attempted before constructing\n-/// a bignum.\n-pub fn fast_path<T: RawFloat>(integral: &[u8], fractional: &[u8], e: i64) -> Option<T> {\n-    let num_digits = integral.len() + fractional.len();\n-    // log_10(f64::MAX_SIG) ~ 15.95. We compare the exact value to MAX_SIG near the end,\n-    // this is just a quick, cheap rejection (and also frees the rest of the code from\n-    // worrying about underflow).\n-    if num_digits > 16 {\n-        return None;\n-    }\n-    if e.abs() >= T::CEIL_LOG5_OF_MAX_SIG as i64 {\n-        return None;\n-    }\n-    let f = num::from_str_unchecked(integral.iter().chain(fractional.iter()));\n-    if f > T::MAX_SIG {\n-        return None;\n-    }\n-\n-    // The fast path crucially depends on arithmetic being rounded to the correct number of bits\n-    // without any intermediate rounding. On x86 (without SSE or SSE2) this requires the precision\n-    // of the x87 FPU stack to be changed so that it directly rounds to 64/32 bit.\n-    // The `set_precision` function takes care of setting the precision on architectures which\n-    // require setting it by changing the global state (like the control word of the x87 FPU).\n-    let _cw = fpu_precision::set_precision::<T>();\n-\n-    // The case e < 0 cannot be folded into the other branch. Negative powers result in\n-    // a repeating fractional part in binary, which are rounded, which causes real\n-    // (and occasionally quite significant!) errors in the final result.\n-    if e >= 0 {\n-        Some(T::from_int(f) * T::short_fast_pow10(e as usize))\n-    } else {\n-        Some(T::from_int(f) / T::short_fast_pow10(e.abs() as usize))\n-    }\n-}\n-\n-/// Algorithm Bellerophon is trivial code justified by non-trivial numeric analysis.\n-///\n-/// It rounds ``f`` to a float with 64 bit significand and multiplies it by the best approximation\n-/// of `10^e` (in the same floating point format). This is often enough to get the correct result.\n-/// However, when the result is close to halfway between two adjacent (ordinary) floats, the\n-/// compound rounding error from multiplying two approximation means the result may be off by a\n-/// few bits. When this happens, the iterative Algorithm R fixes things up.\n-///\n-/// The hand-wavy \"close to halfway\" is made precise by the numeric analysis in the paper.\n-/// In the words of Clinger:\n-///\n-/// > Slop, expressed in units of the least significant bit, is an inclusive bound for the error\n-/// > accumulated during the floating point calculation of the approximation to f * 10^e. (Slop is\n-/// > not a bound for the true error, but bounds the difference between the approximation z and\n-/// > the best possible approximation that uses p bits of significand.)\n-pub fn bellerophon<T: RawFloat>(f: &Big, e: i16) -> T {\n-    let slop = if f <= &Big::from_u64(T::MAX_SIG) {\n-        // The cases abs(e) < log5(2^N) are in fast_path()\n-        if e >= 0 { 0 } else { 3 }\n-    } else {\n-        if e >= 0 { 1 } else { 4 }\n-    };\n-    let z = rawfp::big_to_fp(f).mul(&power_of_ten(e)).normalize();\n-    let exp_p_n = 1 << (P - T::SIG_BITS as u32);\n-    let lowbits: i64 = (z.f % exp_p_n) as i64;\n-    // Is the slop large enough to make a difference when\n-    // rounding to n bits?\n-    if (lowbits - exp_p_n as i64 / 2).abs() <= slop {\n-        algorithm_r(f, e, fp_to_float(z))\n-    } else {\n-        fp_to_float(z)\n-    }\n-}\n-\n-/// An iterative algorithm that improves a floating point approximation of `f * 10^e`.\n-///\n-/// Each iteration gets one unit in the last place closer, which of course takes terribly long to\n-/// converge if `z0` is even mildly off. Luckily, when used as fallback for Bellerophon, the\n-/// starting approximation is off by at most one ULP.\n-fn algorithm_r<T: RawFloat>(f: &Big, e: i16, z0: T) -> T {\n-    let mut z = z0;\n-    loop {\n-        let raw = z.unpack();\n-        let (m, k) = (raw.sig, raw.k);\n-        let mut x = f.clone();\n-        let mut y = Big::from_u64(m);\n-\n-        // Find positive integers `x`, `y` such that `x / y` is exactly `(f * 10^e) / (m * 2^k)`.\n-        // This not only avoids dealing with the signs of `e` and `k`, we also eliminate the\n-        // power of two common to `10^e` and `2^k` to make the numbers smaller.\n-        make_ratio(&mut x, &mut y, e, k);\n-\n-        let m_digits = [(m & 0xFF_FF_FF_FF) as u32, (m >> 32) as u32];\n-        // This is written a bit awkwardly because our bignums don't support\n-        // negative numbers, so we use the absolute value + sign information.\n-        // The multiplication with m_digits can't overflow. If `x` or `y` are large enough that\n-        // we need to worry about overflow, then they are also large enough that `make_ratio` has\n-        // reduced the fraction by a factor of 2^64 or more.\n-        let (d2, d_negative) = if x >= y {\n-            // Don't need x any more, save a clone().\n-            x.sub(&y).mul_pow2(1).mul_digits(&m_digits);\n-            (x, false)\n-        } else {\n-            // Still need y - make a copy.\n-            let mut y = y.clone();\n-            y.sub(&x).mul_pow2(1).mul_digits(&m_digits);\n-            (y, true)\n-        };\n-\n-        if d2 < y {\n-            let mut d2_double = d2;\n-            d2_double.mul_pow2(1);\n-            if m == T::MIN_SIG && d_negative && d2_double > y {\n-                z = prev_float(z);\n-            } else {\n-                return z;\n-            }\n-        } else if d2 == y {\n-            if m % 2 == 0 {\n-                if m == T::MIN_SIG && d_negative {\n-                    z = prev_float(z);\n-                } else {\n-                    return z;\n-                }\n-            } else if d_negative {\n-                z = prev_float(z);\n-            } else {\n-                z = next_float(z);\n-            }\n-        } else if d_negative {\n-            z = prev_float(z);\n-        } else {\n-            z = next_float(z);\n-        }\n-    }\n-}\n-\n-/// Given `x = f` and `y = m` where `f` represent input decimal digits as usual and `m` is the\n-/// significand of a floating point approximation, make the ratio `x / y` equal to\n-/// `(f * 10^e) / (m * 2^k)`, possibly reduced by a power of two both have in common.\n-fn make_ratio(x: &mut Big, y: &mut Big, e: i16, k: i16) {\n-    let (e_abs, k_abs) = (e.abs() as usize, k.abs() as usize);\n-    if e >= 0 {\n-        if k >= 0 {\n-            // x = f * 10^e, y = m * 2^k, except that we reduce the fraction by some power of two.\n-            let common = min(e_abs, k_abs);\n-            x.mul_pow5(e_abs).mul_pow2(e_abs - common);\n-            y.mul_pow2(k_abs - common);\n-        } else {\n-            // x = f * 10^e * 2^abs(k), y = m\n-            // This can't overflow because it requires positive `e` and negative `k`, which can\n-            // only happen for values extremely close to 1, which means that `e` and `k` will be\n-            // comparatively tiny.\n-            x.mul_pow5(e_abs).mul_pow2(e_abs + k_abs);\n-        }\n-    } else {\n-        if k >= 0 {\n-            // x = f, y = m * 10^abs(e) * 2^k\n-            // This can't overflow either, see above.\n-            y.mul_pow5(e_abs).mul_pow2(k_abs + e_abs);\n-        } else {\n-            // x = f * 2^abs(k), y = m * 10^abs(e), again reducing by a common power of two.\n-            let common = min(e_abs, k_abs);\n-            x.mul_pow2(k_abs - common);\n-            y.mul_pow5(e_abs).mul_pow2(e_abs - common);\n-        }\n-    }\n-}\n-\n-/// Conceptually, Algorithm M is the simplest way to convert a decimal to a float.\n-///\n-/// We form a ratio that is equal to `f * 10^e`, then throwing in powers of two until it gives\n-/// a valid float significand. The binary exponent `k` is the number of times we multiplied\n-/// numerator or denominator by two, i.e., at all times `f * 10^e` equals `(u / v) * 2^k`.\n-/// When we have found out significand, we only need to round by inspecting the remainder of the\n-/// division, which is done in helper functions further below.\n-///\n-/// This algorithm is super slow, even with the optimization described in `quick_start()`.\n-/// However, it's the simplest of the algorithms to adapt for overflow, underflow, and subnormal\n-/// results. This implementation takes over when Bellerophon and Algorithm R are overwhelmed.\n-/// Detecting underflow and overflow is easy: The ratio still isn't an in-range significand,\n-/// yet the minimum/maximum exponent has been reached. In the case of overflow, we simply return\n-/// infinity.\n-///\n-/// Handling underflow and subnormals is trickier. One big problem is that, with the minimum\n-/// exponent, the ratio might still be too large for a significand. See underflow() for details.\n-pub fn algorithm_m<T: RawFloat>(f: &Big, e: i16) -> T {\n-    let mut u;\n-    let mut v;\n-    let e_abs = e.abs() as usize;\n-    let mut k = 0;\n-    if e < 0 {\n-        u = f.clone();\n-        v = Big::from_small(1);\n-        v.mul_pow5(e_abs).mul_pow2(e_abs);\n-    } else {\n-        // FIXME possible optimization: generalize big_to_fp so that we can do the equivalent of\n-        // fp_to_float(big_to_fp(u)) here, only without the double rounding.\n-        u = f.clone();\n-        u.mul_pow5(e_abs).mul_pow2(e_abs);\n-        v = Big::from_small(1);\n-    }\n-    quick_start::<T>(&mut u, &mut v, &mut k);\n-    let mut rem = Big::from_small(0);\n-    let mut x = Big::from_small(0);\n-    let min_sig = Big::from_u64(T::MIN_SIG);\n-    let max_sig = Big::from_u64(T::MAX_SIG);\n-    loop {\n-        u.div_rem(&v, &mut x, &mut rem);\n-        if k == T::MIN_EXP_INT {\n-            // We have to stop at the minimum exponent, if we wait until `k < T::MIN_EXP_INT`,\n-            // then we'd be off by a factor of two. Unfortunately this means we have to special-\n-            // case normal numbers with the minimum exponent.\n-            // FIXME find a more elegant formulation, but run the `tiny-pow10` test to make sure\n-            // that it's actually correct!\n-            if x >= min_sig && x <= max_sig {\n-                break;\n-            }\n-            return underflow(x, v, rem);\n-        }\n-        if k > T::MAX_EXP_INT {\n-            return T::INFINITY;\n-        }\n-        if x < min_sig {\n-            u.mul_pow2(1);\n-            k -= 1;\n-        } else if x > max_sig {\n-            v.mul_pow2(1);\n-            k += 1;\n-        } else {\n-            break;\n-        }\n-    }\n-    let q = num::to_u64(&x);\n-    let z = rawfp::encode_normal(Unpacked::new(q, k));\n-    round_by_remainder(v, rem, q, z)\n-}\n-\n-/// Skips over most Algorithm M iterations by checking the bit length.\n-fn quick_start<T: RawFloat>(u: &mut Big, v: &mut Big, k: &mut i16) {\n-    // The bit length is an estimate of the base two logarithm, and log(u / v) = log(u) - log(v).\n-    // The estimate is off by at most 1, but always an under-estimate, so the error on log(u)\n-    // and log(v) are of the same sign and cancel out (if both are large). Therefore the error\n-    // for log(u / v) is at most one as well.\n-    // The target ratio is one where u/v is in an in-range significand. Thus our termination\n-    // condition is log2(u / v) being the significand bits, plus/minus one.\n-    // FIXME Looking at the second bit could improve the estimate and avoid some more divisions.\n-    let target_ratio = T::SIG_BITS as i16;\n-    let log2_u = u.bit_length() as i16;\n-    let log2_v = v.bit_length() as i16;\n-    let mut u_shift: i16 = 0;\n-    let mut v_shift: i16 = 0;\n-    assert!(*k == 0);\n-    loop {\n-        if *k == T::MIN_EXP_INT {\n-            // Underflow or subnormal. Leave it to the main function.\n-            break;\n-        }\n-        if *k == T::MAX_EXP_INT {\n-            // Overflow. Leave it to the main function.\n-            break;\n-        }\n-        let log2_ratio = (log2_u + u_shift) - (log2_v + v_shift);\n-        if log2_ratio < target_ratio - 1 {\n-            u_shift += 1;\n-            *k -= 1;\n-        } else if log2_ratio > target_ratio + 1 {\n-            v_shift += 1;\n-            *k += 1;\n-        } else {\n-            break;\n-        }\n-    }\n-    u.mul_pow2(u_shift as usize);\n-    v.mul_pow2(v_shift as usize);\n-}\n-\n-fn underflow<T: RawFloat>(x: Big, v: Big, rem: Big) -> T {\n-    if x < Big::from_u64(T::MIN_SIG) {\n-        let q = num::to_u64(&x);\n-        let z = rawfp::encode_subnormal(q);\n-        return round_by_remainder(v, rem, q, z);\n-    }\n-    // Ratio isn't an in-range significand with the minimum exponent, so we need to round off\n-    // excess bits and adjust the exponent accordingly. The real value now looks like this:\n-    //\n-    //        x        lsb\n-    // /--------------\\/\n-    // 1010101010101010.10101010101010 * 2^k\n-    // \\-----/\\-------/ \\------------/\n-    //    q     trunc.    (represented by rem)\n-    //\n-    // Therefore, when the rounded-off bits are != 0.5 ULP, they decide the rounding\n-    // on their own. When they are equal and the remainder is non-zero, the value still\n-    // needs to be rounded up. Only when the rounded off bits are 1/2 and the remainder\n-    // is zero, we have a half-to-even situation.\n-    let bits = x.bit_length();\n-    let lsb = bits - T::SIG_BITS as usize;\n-    let q = num::get_bits(&x, lsb, bits);\n-    let k = T::MIN_EXP_INT + lsb as i16;\n-    let z = rawfp::encode_normal(Unpacked::new(q, k));\n-    let q_even = q % 2 == 0;\n-    match num::compare_with_half_ulp(&x, lsb) {\n-        Greater => next_float(z),\n-        Less => z,\n-        Equal if rem.is_zero() && q_even => z,\n-        Equal => next_float(z),\n-    }\n-}\n-\n-/// Ordinary round-to-even, obfuscated by having to round based on the remainder of a division.\n-fn round_by_remainder<T: RawFloat>(v: Big, r: Big, q: u64, z: T) -> T {\n-    let mut v_minus_r = v;\n-    v_minus_r.sub(&r);\n-    if r < v_minus_r {\n-        z\n-    } else if r > v_minus_r {\n-        next_float(z)\n-    } else if q % 2 == 0 {\n-        z\n-    } else {\n-        next_float(z)\n-    }\n-}"}, {"sha": "247123737df423e445f399efd80584cce70960ba", "filename": "library/core/src/num/dec2flt/common.rs", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fcommon.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -0,0 +1,198 @@\n+//! Common utilities, for internal use only.\n+\n+use crate::ptr;\n+\n+/// Helper methods to process immutable bytes.\n+pub(crate) trait ByteSlice: AsRef<[u8]> {\n+    unsafe fn first_unchecked(&self) -> u8 {\n+        debug_assert!(!self.is_empty());\n+        // SAFETY: safe as long as self is not empty\n+        unsafe { *self.as_ref().get_unchecked(0) }\n+    }\n+\n+    /// Get if the slice contains no elements.\n+    fn is_empty(&self) -> bool {\n+        self.as_ref().is_empty()\n+    }\n+\n+    /// Check if the slice at least `n` length.\n+    fn check_len(&self, n: usize) -> bool {\n+        n <= self.as_ref().len()\n+    }\n+\n+    /// Check if the first character in the slice is equal to c.\n+    fn first_is(&self, c: u8) -> bool {\n+        self.as_ref().first() == Some(&c)\n+    }\n+\n+    /// Check if the first character in the slice is equal to c1 or c2.\n+    fn first_is2(&self, c1: u8, c2: u8) -> bool {\n+        if let Some(&c) = self.as_ref().first() { c == c1 || c == c2 } else { false }\n+    }\n+\n+    /// Bounds-checked test if the first character in the slice is a digit.\n+    fn first_isdigit(&self) -> bool {\n+        if let Some(&c) = self.as_ref().first() { c.is_ascii_digit() } else { false }\n+    }\n+\n+    /// Check if self starts with u with a case-insensitive comparison.\n+    fn eq_ignore_case(&self, u: &[u8]) -> bool {\n+        debug_assert!(self.as_ref().len() >= u.len());\n+        let iter = self.as_ref().iter().zip(u.iter());\n+        let d = iter.fold(0, |i, (&x, &y)| i | (x ^ y));\n+        d == 0 || d == 32\n+    }\n+\n+    /// Get the remaining slice after the first N elements.\n+    fn advance(&self, n: usize) -> &[u8] {\n+        &self.as_ref()[n..]\n+    }\n+\n+    /// Get the slice after skipping all leading characters equal c.\n+    fn skip_chars(&self, c: u8) -> &[u8] {\n+        let mut s = self.as_ref();\n+        while s.first_is(c) {\n+            s = s.advance(1);\n+        }\n+        s\n+    }\n+\n+    /// Get the slice after skipping all leading characters equal c1 or c2.\n+    fn skip_chars2(&self, c1: u8, c2: u8) -> &[u8] {\n+        let mut s = self.as_ref();\n+        while s.first_is2(c1, c2) {\n+            s = s.advance(1);\n+        }\n+        s\n+    }\n+\n+    /// Read 8 bytes as a 64-bit integer in little-endian order.\n+    unsafe fn read_u64_unchecked(&self) -> u64 {\n+        debug_assert!(self.check_len(8));\n+        let src = self.as_ref().as_ptr() as *const u64;\n+        // SAFETY: safe as long as self is at least 8 bytes\n+        u64::from_le(unsafe { ptr::read_unaligned(src) })\n+    }\n+\n+    /// Try to read the next 8 bytes from the slice.\n+    fn read_u64(&self) -> Option<u64> {\n+        if self.check_len(8) {\n+            // SAFETY: self must be at least 8 bytes.\n+            Some(unsafe { self.read_u64_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Calculate the offset of slice from another.\n+    fn offset_from(&self, other: &Self) -> isize {\n+        other.as_ref().len() as isize - self.as_ref().len() as isize\n+    }\n+}\n+\n+impl ByteSlice for [u8] {}\n+\n+/// Helper methods to process mutable bytes.\n+pub(crate) trait ByteSliceMut: AsMut<[u8]> {\n+    /// Write a 64-bit integer as 8 bytes in little-endian order.\n+    unsafe fn write_u64_unchecked(&mut self, value: u64) {\n+        debug_assert!(self.as_mut().len() >= 8);\n+        let dst = self.as_mut().as_mut_ptr() as *mut u64;\n+        // NOTE: we must use `write_unaligned`, since dst is not\n+        // guaranteed to be properly aligned. Miri will warn us\n+        // if we use `write` instead of `write_unaligned`, as expected.\n+        // SAFETY: safe as long as self is at least 8 bytes\n+        unsafe {\n+            ptr::write_unaligned(dst, u64::to_le(value));\n+        }\n+    }\n+}\n+\n+impl ByteSliceMut for [u8] {}\n+\n+/// Bytes wrapper with specialized methods for ASCII characters.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub(crate) struct AsciiStr<'a> {\n+    slc: &'a [u8],\n+}\n+\n+impl<'a> AsciiStr<'a> {\n+    pub fn new(slc: &'a [u8]) -> Self {\n+        Self { slc }\n+    }\n+\n+    /// Advance the view by n, advancing it in-place to (n..).\n+    pub unsafe fn step_by(&mut self, n: usize) -> &mut Self {\n+        // SAFETY: safe as long n is less than the buffer length\n+        self.slc = unsafe { self.slc.get_unchecked(n..) };\n+        self\n+    }\n+\n+    /// Advance the view by n, advancing it in-place to (1..).\n+    pub unsafe fn step(&mut self) -> &mut Self {\n+        // SAFETY: safe as long as self is not empty\n+        unsafe { self.step_by(1) }\n+    }\n+\n+    /// Iteratively parse and consume digits from bytes.\n+    pub fn parse_digits(&mut self, mut func: impl FnMut(u8)) {\n+        while let Some(&c) = self.as_ref().first() {\n+            let c = c.wrapping_sub(b'0');\n+            if c < 10 {\n+                func(c);\n+                // SAFETY: self cannot be empty\n+                unsafe {\n+                    self.step();\n+                }\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> AsRef<[u8]> for AsciiStr<'a> {\n+    #[inline]\n+    fn as_ref(&self) -> &[u8] {\n+        self.slc\n+    }\n+}\n+\n+impl<'a> ByteSlice for AsciiStr<'a> {}\n+\n+/// Determine if 8 bytes are all decimal digits.\n+/// This does not care about the order in which the bytes were loaded.\n+pub(crate) fn is_8digits(v: u64) -> bool {\n+    let a = v.wrapping_add(0x4646_4646_4646_4646);\n+    let b = v.wrapping_sub(0x3030_3030_3030_3030);\n+    (a | b) & 0x8080_8080_8080_8080 == 0\n+}\n+\n+/// Iteratively parse and consume digits from bytes.\n+pub(crate) fn parse_digits(s: &mut &[u8], mut f: impl FnMut(u8)) {\n+    while let Some(&c) = s.get(0) {\n+        let c = c.wrapping_sub(b'0');\n+        if c < 10 {\n+            f(c);\n+            *s = s.advance(1);\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+/// A custom 64-bit floating point type, representing `f * 2^e`.\n+/// e is biased, so it be directly shifted into the exponent bits.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Default)]\n+pub struct BiasedFp {\n+    /// The significant digits.\n+    pub f: u64,\n+    /// The biased, binary exponent.\n+    pub e: i32,\n+}\n+\n+impl BiasedFp {\n+    pub const fn zero_pow2(e: i32) -> Self {\n+        Self { f: 0, e }\n+    }\n+}"}, {"sha": "f8edc3625e0ab079ee306a10a74bde260643695c", "filename": "library/core/src/num/dec2flt/decimal.rs", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fdecimal.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -0,0 +1,351 @@\n+//! Arbitrary-precision decimal class for fallback algorithms.\n+//!\n+//! This is only used if the fast-path (native floats) and\n+//! the Eisel-Lemire algorithm are unable to unambiguously\n+//! determine the float.\n+//!\n+//! The technique used is \"Simple Decimal Conversion\", developed\n+//! by Nigel Tao and Ken Thompson. A detailed description of the\n+//! algorithm can be found in \"ParseNumberF64 by Simple Decimal Conversion\",\n+//! available online: <https://nigeltao.github.io/blog/2020/parse-number-f64-simple.html>.\n+\n+use crate::num::dec2flt::common::{is_8digits, parse_digits, ByteSlice, ByteSliceMut};\n+\n+#[derive(Clone)]\n+pub struct Decimal {\n+    /// The number of significant digits in the decimal.\n+    pub num_digits: usize,\n+    /// The offset of the decimal point in the significant digits.\n+    pub decimal_point: i32,\n+    /// If the number of significant digits stored in the decimal is truncated.\n+    pub truncated: bool,\n+    /// Buffer of the raw digits, in the range [0, 9].\n+    pub digits: [u8; Self::MAX_DIGITS],\n+}\n+\n+impl Default for Decimal {\n+    fn default() -> Self {\n+        Self { num_digits: 0, decimal_point: 0, truncated: false, digits: [0; Self::MAX_DIGITS] }\n+    }\n+}\n+\n+impl Decimal {\n+    /// The maximum number of digits required to unambiguously round a float.\n+    ///\n+    /// For a double-precision IEEE-754 float, this required 767 digits,\n+    /// so we store the max digits + 1.\n+    ///\n+    /// We can exactly represent a float in radix `b` from radix 2 if\n+    /// `b` is divisible by 2. This function calculates the exact number of\n+    /// digits required to exactly represent that float.\n+    ///\n+    /// According to the \"Handbook of Floating Point Arithmetic\",\n+    /// for IEEE754, with emin being the min exponent, p2 being the\n+    /// precision, and b being the radix, the number of digits follows as:\n+    ///\n+    /// `\u2212emin + p2 + \u230a(emin + 1) log(2, b) \u2212 log(1 \u2212 2^(\u2212p2), b)\u230b`\n+    ///\n+    /// For f32, this follows as:\n+    ///     emin = -126\n+    ///     p2 = 24\n+    ///\n+    /// For f64, this follows as:\n+    ///     emin = -1022\n+    ///     p2 = 53\n+    ///\n+    /// In Python:\n+    ///     `-emin + p2 + math.floor((emin+ 1)*math.log(2, b)-math.log(1-2**(-p2), b))`\n+    pub const MAX_DIGITS: usize = 768;\n+    /// The max digits that can be exactly represented in a 64-bit integer.\n+    pub const MAX_DIGITS_WITHOUT_OVERFLOW: usize = 19;\n+    pub const DECIMAL_POINT_RANGE: i32 = 2047;\n+\n+    /// Append a digit to the buffer.\n+    pub fn try_add_digit(&mut self, digit: u8) {\n+        if self.num_digits < Self::MAX_DIGITS {\n+            self.digits[self.num_digits] = digit;\n+        }\n+        self.num_digits += 1;\n+    }\n+\n+    /// Trim trailing zeros from the buffer.\n+    pub fn trim(&mut self) {\n+        // All of the following calls to `Decimal::trim` can't panic because:\n+        //\n+        //  1. `parse_decimal` sets `num_digits` to a max of `Decimal::MAX_DIGITS`.\n+        //  2. `right_shift` sets `num_digits` to `write_index`, which is bounded by `num_digits`.\n+        //  3. `left_shift` `num_digits` to a max of `Decimal::MAX_DIGITS`.\n+        //\n+        // Trim is only called in `right_shift` and `left_shift`.\n+        debug_assert!(self.num_digits <= Self::MAX_DIGITS);\n+        while self.num_digits != 0 && self.digits[self.num_digits - 1] == 0 {\n+            self.num_digits -= 1;\n+        }\n+    }\n+\n+    pub fn round(&self) -> u64 {\n+        if self.num_digits == 0 || self.decimal_point < 0 {\n+            return 0;\n+        } else if self.decimal_point > 18 {\n+            return 0xFFFF_FFFF_FFFF_FFFF_u64;\n+        }\n+        let dp = self.decimal_point as usize;\n+        let mut n = 0_u64;\n+        for i in 0..dp {\n+            n *= 10;\n+            if i < self.num_digits {\n+                n += self.digits[i] as u64;\n+            }\n+        }\n+        let mut round_up = false;\n+        if dp < self.num_digits {\n+            round_up = self.digits[dp] >= 5;\n+            if self.digits[dp] == 5 && dp + 1 == self.num_digits {\n+                round_up = self.truncated || ((dp != 0) && (1 & self.digits[dp - 1] != 0))\n+            }\n+        }\n+        if round_up {\n+            n += 1;\n+        }\n+        n\n+    }\n+\n+    /// Computes decimal * 2^shift.\n+    pub fn left_shift(&mut self, shift: usize) {\n+        if self.num_digits == 0 {\n+            return;\n+        }\n+        let num_new_digits = number_of_digits_decimal_left_shift(self, shift);\n+        let mut read_index = self.num_digits;\n+        let mut write_index = self.num_digits + num_new_digits;\n+        let mut n = 0_u64;\n+        while read_index != 0 {\n+            read_index -= 1;\n+            write_index -= 1;\n+            n += (self.digits[read_index] as u64) << shift;\n+            let quotient = n / 10;\n+            let remainder = n - (10 * quotient);\n+            if write_index < Self::MAX_DIGITS {\n+                self.digits[write_index] = remainder as u8;\n+            } else if remainder > 0 {\n+                self.truncated = true;\n+            }\n+            n = quotient;\n+        }\n+        while n > 0 {\n+            write_index -= 1;\n+            let quotient = n / 10;\n+            let remainder = n - (10 * quotient);\n+            if write_index < Self::MAX_DIGITS {\n+                self.digits[write_index] = remainder as u8;\n+            } else if remainder > 0 {\n+                self.truncated = true;\n+            }\n+            n = quotient;\n+        }\n+        self.num_digits += num_new_digits;\n+        if self.num_digits > Self::MAX_DIGITS {\n+            self.num_digits = Self::MAX_DIGITS;\n+        }\n+        self.decimal_point += num_new_digits as i32;\n+        self.trim();\n+    }\n+\n+    /// Computes decimal * 2^-shift.\n+    pub fn right_shift(&mut self, shift: usize) {\n+        let mut read_index = 0;\n+        let mut write_index = 0;\n+        let mut n = 0_u64;\n+        while (n >> shift) == 0 {\n+            if read_index < self.num_digits {\n+                n = (10 * n) + self.digits[read_index] as u64;\n+                read_index += 1;\n+            } else if n == 0 {\n+                return;\n+            } else {\n+                while (n >> shift) == 0 {\n+                    n *= 10;\n+                    read_index += 1;\n+                }\n+                break;\n+            }\n+        }\n+        self.decimal_point -= read_index as i32 - 1;\n+        if self.decimal_point < -Self::DECIMAL_POINT_RANGE {\n+            // `self = Self::Default()`, but without the overhead of clearing `digits`.\n+            self.num_digits = 0;\n+            self.decimal_point = 0;\n+            self.truncated = false;\n+            return;\n+        }\n+        let mask = (1_u64 << shift) - 1;\n+        while read_index < self.num_digits {\n+            let new_digit = (n >> shift) as u8;\n+            n = (10 * (n & mask)) + self.digits[read_index] as u64;\n+            read_index += 1;\n+            self.digits[write_index] = new_digit;\n+            write_index += 1;\n+        }\n+        while n > 0 {\n+            let new_digit = (n >> shift) as u8;\n+            n = 10 * (n & mask);\n+            if write_index < Self::MAX_DIGITS {\n+                self.digits[write_index] = new_digit;\n+                write_index += 1;\n+            } else if new_digit > 0 {\n+                self.truncated = true;\n+            }\n+        }\n+        self.num_digits = write_index;\n+        self.trim();\n+    }\n+}\n+\n+/// Parse a big integer representation of the float as a decimal.\n+pub fn parse_decimal(mut s: &[u8]) -> Decimal {\n+    let mut d = Decimal::default();\n+    let start = s;\n+    s = s.skip_chars(b'0');\n+    parse_digits(&mut s, |digit| d.try_add_digit(digit));\n+    if s.first_is(b'.') {\n+        s = s.advance(1);\n+        let first = s;\n+        // Skip leading zeros.\n+        if d.num_digits == 0 {\n+            s = s.skip_chars(b'0');\n+        }\n+        while s.len() >= 8 && d.num_digits + 8 < Decimal::MAX_DIGITS {\n+            // SAFETY: s is at least 8 bytes.\n+            let v = unsafe { s.read_u64_unchecked() };\n+            if !is_8digits(v) {\n+                break;\n+            }\n+            // SAFETY: d.num_digits + 8 is less than d.digits.len()\n+            unsafe {\n+                d.digits[d.num_digits..].write_u64_unchecked(v - 0x3030_3030_3030_3030);\n+            }\n+            d.num_digits += 8;\n+            s = s.advance(8);\n+        }\n+        parse_digits(&mut s, |digit| d.try_add_digit(digit));\n+        d.decimal_point = s.len() as i32 - first.len() as i32;\n+    }\n+    if d.num_digits != 0 {\n+        // Ignore the trailing zeros if there are any\n+        let mut n_trailing_zeros = 0;\n+        for &c in start[..(start.len() - s.len())].iter().rev() {\n+            if c == b'0' {\n+                n_trailing_zeros += 1;\n+            } else if c != b'.' {\n+                break;\n+            }\n+        }\n+        d.decimal_point += n_trailing_zeros as i32;\n+        d.num_digits -= n_trailing_zeros;\n+        d.decimal_point += d.num_digits as i32;\n+        if d.num_digits > Decimal::MAX_DIGITS {\n+            d.truncated = true;\n+            d.num_digits = Decimal::MAX_DIGITS;\n+        }\n+    }\n+    if s.first_is2(b'e', b'E') {\n+        s = s.advance(1);\n+        let mut neg_exp = false;\n+        if s.first_is(b'-') {\n+            neg_exp = true;\n+            s = s.advance(1);\n+        } else if s.first_is(b'+') {\n+            s = s.advance(1);\n+        }\n+        let mut exp_num = 0_i32;\n+        parse_digits(&mut s, |digit| {\n+            if exp_num < 0x10000 {\n+                exp_num = 10 * exp_num + digit as i32;\n+            }\n+        });\n+        d.decimal_point += if neg_exp { -exp_num } else { exp_num };\n+    }\n+    for i in d.num_digits..Decimal::MAX_DIGITS_WITHOUT_OVERFLOW {\n+        d.digits[i] = 0;\n+    }\n+    d\n+}\n+\n+fn number_of_digits_decimal_left_shift(d: &Decimal, mut shift: usize) -> usize {\n+    #[rustfmt::skip]\n+    const TABLE: [u16; 65] = [\n+        0x0000, 0x0800, 0x0801, 0x0803, 0x1006, 0x1009, 0x100D, 0x1812, 0x1817, 0x181D, 0x2024,\n+        0x202B, 0x2033, 0x203C, 0x2846, 0x2850, 0x285B, 0x3067, 0x3073, 0x3080, 0x388E, 0x389C,\n+        0x38AB, 0x38BB, 0x40CC, 0x40DD, 0x40EF, 0x4902, 0x4915, 0x4929, 0x513E, 0x5153, 0x5169,\n+        0x5180, 0x5998, 0x59B0, 0x59C9, 0x61E3, 0x61FD, 0x6218, 0x6A34, 0x6A50, 0x6A6D, 0x6A8B,\n+        0x72AA, 0x72C9, 0x72E9, 0x7B0A, 0x7B2B, 0x7B4D, 0x8370, 0x8393, 0x83B7, 0x83DC, 0x8C02,\n+        0x8C28, 0x8C4F, 0x9477, 0x949F, 0x94C8, 0x9CF2, 0x051C, 0x051C, 0x051C, 0x051C,\n+    ];\n+    #[rustfmt::skip]\n+    const TABLE_POW5: [u8; 0x051C] = [\n+        5, 2, 5, 1, 2, 5, 6, 2, 5, 3, 1, 2, 5, 1, 5, 6, 2, 5, 7, 8, 1, 2, 5, 3, 9, 0, 6, 2, 5, 1,\n+        9, 5, 3, 1, 2, 5, 9, 7, 6, 5, 6, 2, 5, 4, 8, 8, 2, 8, 1, 2, 5, 2, 4, 4, 1, 4, 0, 6, 2, 5,\n+        1, 2, 2, 0, 7, 0, 3, 1, 2, 5, 6, 1, 0, 3, 5, 1, 5, 6, 2, 5, 3, 0, 5, 1, 7, 5, 7, 8, 1, 2,\n+        5, 1, 5, 2, 5, 8, 7, 8, 9, 0, 6, 2, 5, 7, 6, 2, 9, 3, 9, 4, 5, 3, 1, 2, 5, 3, 8, 1, 4, 6,\n+        9, 7, 2, 6, 5, 6, 2, 5, 1, 9, 0, 7, 3, 4, 8, 6, 3, 2, 8, 1, 2, 5, 9, 5, 3, 6, 7, 4, 3, 1,\n+        6, 4, 0, 6, 2, 5, 4, 7, 6, 8, 3, 7, 1, 5, 8, 2, 0, 3, 1, 2, 5, 2, 3, 8, 4, 1, 8, 5, 7, 9,\n+        1, 0, 1, 5, 6, 2, 5, 1, 1, 9, 2, 0, 9, 2, 8, 9, 5, 5, 0, 7, 8, 1, 2, 5, 5, 9, 6, 0, 4, 6,\n+        4, 4, 7, 7, 5, 3, 9, 0, 6, 2, 5, 2, 9, 8, 0, 2, 3, 2, 2, 3, 8, 7, 6, 9, 5, 3, 1, 2, 5, 1,\n+        4, 9, 0, 1, 1, 6, 1, 1, 9, 3, 8, 4, 7, 6, 5, 6, 2, 5, 7, 4, 5, 0, 5, 8, 0, 5, 9, 6, 9, 2,\n+        3, 8, 2, 8, 1, 2, 5, 3, 7, 2, 5, 2, 9, 0, 2, 9, 8, 4, 6, 1, 9, 1, 4, 0, 6, 2, 5, 1, 8, 6,\n+        2, 6, 4, 5, 1, 4, 9, 2, 3, 0, 9, 5, 7, 0, 3, 1, 2, 5, 9, 3, 1, 3, 2, 2, 5, 7, 4, 6, 1, 5,\n+        4, 7, 8, 5, 1, 5, 6, 2, 5, 4, 6, 5, 6, 6, 1, 2, 8, 7, 3, 0, 7, 7, 3, 9, 2, 5, 7, 8, 1, 2,\n+        5, 2, 3, 2, 8, 3, 0, 6, 4, 3, 6, 5, 3, 8, 6, 9, 6, 2, 8, 9, 0, 6, 2, 5, 1, 1, 6, 4, 1, 5,\n+        3, 2, 1, 8, 2, 6, 9, 3, 4, 8, 1, 4, 4, 5, 3, 1, 2, 5, 5, 8, 2, 0, 7, 6, 6, 0, 9, 1, 3, 4,\n+        6, 7, 4, 0, 7, 2, 2, 6, 5, 6, 2, 5, 2, 9, 1, 0, 3, 8, 3, 0, 4, 5, 6, 7, 3, 3, 7, 0, 3, 6,\n+        1, 3, 2, 8, 1, 2, 5, 1, 4, 5, 5, 1, 9, 1, 5, 2, 2, 8, 3, 6, 6, 8, 5, 1, 8, 0, 6, 6, 4, 0,\n+        6, 2, 5, 7, 2, 7, 5, 9, 5, 7, 6, 1, 4, 1, 8, 3, 4, 2, 5, 9, 0, 3, 3, 2, 0, 3, 1, 2, 5, 3,\n+        6, 3, 7, 9, 7, 8, 8, 0, 7, 0, 9, 1, 7, 1, 2, 9, 5, 1, 6, 6, 0, 1, 5, 6, 2, 5, 1, 8, 1, 8,\n+        9, 8, 9, 4, 0, 3, 5, 4, 5, 8, 5, 6, 4, 7, 5, 8, 3, 0, 0, 7, 8, 1, 2, 5, 9, 0, 9, 4, 9, 4,\n+        7, 0, 1, 7, 7, 2, 9, 2, 8, 2, 3, 7, 9, 1, 5, 0, 3, 9, 0, 6, 2, 5, 4, 5, 4, 7, 4, 7, 3, 5,\n+        0, 8, 8, 6, 4, 6, 4, 1, 1, 8, 9, 5, 7, 5, 1, 9, 5, 3, 1, 2, 5, 2, 2, 7, 3, 7, 3, 6, 7, 5,\n+        4, 4, 3, 2, 3, 2, 0, 5, 9, 4, 7, 8, 7, 5, 9, 7, 6, 5, 6, 2, 5, 1, 1, 3, 6, 8, 6, 8, 3, 7,\n+        7, 2, 1, 6, 1, 6, 0, 2, 9, 7, 3, 9, 3, 7, 9, 8, 8, 2, 8, 1, 2, 5, 5, 6, 8, 4, 3, 4, 1, 8,\n+        8, 6, 0, 8, 0, 8, 0, 1, 4, 8, 6, 9, 6, 8, 9, 9, 4, 1, 4, 0, 6, 2, 5, 2, 8, 4, 2, 1, 7, 0,\n+        9, 4, 3, 0, 4, 0, 4, 0, 0, 7, 4, 3, 4, 8, 4, 4, 9, 7, 0, 7, 0, 3, 1, 2, 5, 1, 4, 2, 1, 0,\n+        8, 5, 4, 7, 1, 5, 2, 0, 2, 0, 0, 3, 7, 1, 7, 4, 2, 2, 4, 8, 5, 3, 5, 1, 5, 6, 2, 5, 7, 1,\n+        0, 5, 4, 2, 7, 3, 5, 7, 6, 0, 1, 0, 0, 1, 8, 5, 8, 7, 1, 1, 2, 4, 2, 6, 7, 5, 7, 8, 1, 2,\n+        5, 3, 5, 5, 2, 7, 1, 3, 6, 7, 8, 8, 0, 0, 5, 0, 0, 9, 2, 9, 3, 5, 5, 6, 2, 1, 3, 3, 7, 8,\n+        9, 0, 6, 2, 5, 1, 7, 7, 6, 3, 5, 6, 8, 3, 9, 4, 0, 0, 2, 5, 0, 4, 6, 4, 6, 7, 7, 8, 1, 0,\n+        6, 6, 8, 9, 4, 5, 3, 1, 2, 5, 8, 8, 8, 1, 7, 8, 4, 1, 9, 7, 0, 0, 1, 2, 5, 2, 3, 2, 3, 3,\n+        8, 9, 0, 5, 3, 3, 4, 4, 7, 2, 6, 5, 6, 2, 5, 4, 4, 4, 0, 8, 9, 2, 0, 9, 8, 5, 0, 0, 6, 2,\n+        6, 1, 6, 1, 6, 9, 4, 5, 2, 6, 6, 7, 2, 3, 6, 3, 2, 8, 1, 2, 5, 2, 2, 2, 0, 4, 4, 6, 0, 4,\n+        9, 2, 5, 0, 3, 1, 3, 0, 8, 0, 8, 4, 7, 2, 6, 3, 3, 3, 6, 1, 8, 1, 6, 4, 0, 6, 2, 5, 1, 1,\n+        1, 0, 2, 2, 3, 0, 2, 4, 6, 2, 5, 1, 5, 6, 5, 4, 0, 4, 2, 3, 6, 3, 1, 6, 6, 8, 0, 9, 0, 8,\n+        2, 0, 3, 1, 2, 5, 5, 5, 5, 1, 1, 1, 5, 1, 2, 3, 1, 2, 5, 7, 8, 2, 7, 0, 2, 1, 1, 8, 1, 5,\n+        8, 3, 4, 0, 4, 5, 4, 1, 0, 1, 5, 6, 2, 5, 2, 7, 7, 5, 5, 5, 7, 5, 6, 1, 5, 6, 2, 8, 9, 1,\n+        3, 5, 1, 0, 5, 9, 0, 7, 9, 1, 7, 0, 2, 2, 7, 0, 5, 0, 7, 8, 1, 2, 5, 1, 3, 8, 7, 7, 7, 8,\n+        7, 8, 0, 7, 8, 1, 4, 4, 5, 6, 7, 5, 5, 2, 9, 5, 3, 9, 5, 8, 5, 1, 1, 3, 5, 2, 5, 3, 9, 0,\n+        6, 2, 5, 6, 9, 3, 8, 8, 9, 3, 9, 0, 3, 9, 0, 7, 2, 2, 8, 3, 7, 7, 6, 4, 7, 6, 9, 7, 9, 2,\n+        5, 5, 6, 7, 6, 2, 6, 9, 5, 3, 1, 2, 5, 3, 4, 6, 9, 4, 4, 6, 9, 5, 1, 9, 5, 3, 6, 1, 4, 1,\n+        8, 8, 8, 2, 3, 8, 4, 8, 9, 6, 2, 7, 8, 3, 8, 1, 3, 4, 7, 6, 5, 6, 2, 5, 1, 7, 3, 4, 7, 2,\n+        3, 4, 7, 5, 9, 7, 6, 8, 0, 7, 0, 9, 4, 4, 1, 1, 9, 2, 4, 4, 8, 1, 3, 9, 1, 9, 0, 6, 7, 3,\n+        8, 2, 8, 1, 2, 5, 8, 6, 7, 3, 6, 1, 7, 3, 7, 9, 8, 8, 4, 0, 3, 5, 4, 7, 2, 0, 5, 9, 6, 2,\n+        2, 4, 0, 6, 9, 5, 9, 5, 3, 3, 6, 9, 1, 4, 0, 6, 2, 5,\n+    ];\n+\n+    shift &= 63;\n+    let x_a = TABLE[shift];\n+    let x_b = TABLE[shift + 1];\n+    let num_new_digits = (x_a >> 11) as _;\n+    let pow5_a = (0x7FF & x_a) as usize;\n+    let pow5_b = (0x7FF & x_b) as usize;\n+    let pow5 = &TABLE_POW5[pow5_a..];\n+    for (i, &p5) in pow5.iter().enumerate().take(pow5_b - pow5_a) {\n+        if i >= d.num_digits {\n+            return num_new_digits - 1;\n+        } else if d.digits[i] == p5 {\n+            continue;\n+        } else if d.digits[i] < p5 {\n+            return num_new_digits - 1;\n+        } else {\n+            return num_new_digits;\n+        }\n+    }\n+    num_new_digits\n+}"}, {"sha": "5921c5ed472576a086c1242a16de1660419ca500", "filename": "library/core/src/num/dec2flt/float.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffloat.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -0,0 +1,207 @@\n+//! Helper trait for generic float types.\n+\n+use crate::fmt::{Debug, LowerExp};\n+use crate::num::FpCategory;\n+use crate::ops::{Add, Div, Mul, Neg};\n+\n+/// A helper trait to avoid duplicating basically all the conversion code for `f32` and `f64`.\n+///\n+/// See the parent module's doc comment for why this is necessary.\n+///\n+/// Should **never ever** be implemented for other types or be used outside the dec2flt module.\n+#[doc(hidden)]\n+pub trait RawFloat:\n+    Sized\n+    + Div<Output = Self>\n+    + Neg<Output = Self>\n+    + Mul<Output = Self>\n+    + Add<Output = Self>\n+    + LowerExp\n+    + PartialEq\n+    + PartialOrd\n+    + Default\n+    + Clone\n+    + Copy\n+    + Debug\n+{\n+    const INFINITY: Self;\n+    const NEG_INFINITY: Self;\n+    const NAN: Self;\n+    const NEG_NAN: Self;\n+\n+    /// The number of bits in the significand, *excluding* the hidden bit.\n+    const MANTISSA_EXPLICIT_BITS: usize;\n+\n+    // Round-to-even only happens for negative values of q\n+    // when q \u2265 \u22124 in the 64-bit case and when q \u2265 \u221217 in\n+    // the 32-bitcase.\n+    //\n+    // When q \u2265 0,we have that 5^q \u2264 2m+1. In the 64-bit case,we\n+    // have 5^q \u2264 2m+1 \u2264 2^54 or q \u2264 23. In the 32-bit case,we have\n+    // 5^q \u2264 2m+1 \u2264 2^25 or q \u2264 10.\n+    //\n+    // When q < 0, we have w \u2265 (2m+1)\u00d75^\u2212q. We must have that w < 2^64\n+    // so (2m+1)\u00d75^\u2212q < 2^64. We have that 2m+1 > 2^53 (64-bit case)\n+    // or 2m+1 > 2^24 (32-bit case). Hence,we must have 2^53\u00d75^\u2212q < 2^64\n+    // (64-bit) and 2^24\u00d75^\u2212q < 2^64 (32-bit). Hence we have 5^\u2212q < 2^11\n+    // or q \u2265 \u22124 (64-bit case) and 5^\u2212q < 2^40 or q \u2265 \u221217 (32-bitcase).\n+    //\n+    // Thus we have that we only need to round ties to even when\n+    // we have that q \u2208 [\u22124,23](in the 64-bit case) or q\u2208[\u221217,10]\n+    // (in the 32-bit case). In both cases,the power of five(5^|q|)\n+    // fits in a 64-bit word.\n+    const MIN_EXPONENT_ROUND_TO_EVEN: i32;\n+    const MAX_EXPONENT_ROUND_TO_EVEN: i32;\n+\n+    // Minimum exponent that for a fast path case, or `-\u230a(MANTISSA_EXPLICIT_BITS+1)/log2(5)\u230b`\n+    const MIN_EXPONENT_FAST_PATH: i64;\n+\n+    // Maximum exponent that for a fast path case, or `\u230a(MANTISSA_EXPLICIT_BITS+1)/log2(5)\u230b`\n+    const MAX_EXPONENT_FAST_PATH: i64;\n+\n+    // Maximum exponent that can be represented for a disguised-fast path case.\n+    // This is `MAX_EXPONENT_FAST_PATH + \u230a(MANTISSA_EXPLICIT_BITS+1)/log2(10)\u230b`\n+    const MAX_EXPONENT_DISGUISED_FAST_PATH: i64;\n+\n+    // Minimum exponent value `-(1 << (EXP_BITS - 1)) + 1`.\n+    const MINIMUM_EXPONENT: i32;\n+\n+    // Largest exponent value `(1 << EXP_BITS) - 1`.\n+    const INFINITE_POWER: i32;\n+\n+    // Index (in bits) of the sign.\n+    const SIGN_INDEX: usize;\n+\n+    // Smallest decimal exponent for a non-zero value.\n+    const SMALLEST_POWER_OF_TEN: i32;\n+\n+    // Largest decimal exponent for a non-infinite value.\n+    const LARGEST_POWER_OF_TEN: i32;\n+\n+    // Maximum mantissa for the fast-path (`1 << 53` for f64).\n+    const MAX_MANTISSA_FAST_PATH: u64 = 2_u64 << Self::MANTISSA_EXPLICIT_BITS;\n+\n+    /// Convert integer into float through an as cast.\n+    /// This is only called in the fast-path algorithm, and therefore\n+    /// will not lose precision, since the value will always have\n+    /// only if the value is <= Self::MAX_MANTISSA_FAST_PATH.\n+    fn from_u64(v: u64) -> Self;\n+\n+    /// Performs a raw transmutation from an integer.\n+    fn from_u64_bits(v: u64) -> Self;\n+\n+    /// Get a small power-of-ten for fast-path multiplication.\n+    fn pow10_fast_path(exponent: usize) -> Self;\n+\n+    /// Returns the category that this number falls into.\n+    fn classify(self) -> FpCategory;\n+\n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8);\n+}\n+\n+impl RawFloat for f32 {\n+    const INFINITY: Self = f32::INFINITY;\n+    const NEG_INFINITY: Self = f32::NEG_INFINITY;\n+    const NAN: Self = f32::NAN;\n+    const NEG_NAN: Self = -f32::NAN;\n+\n+    const MANTISSA_EXPLICIT_BITS: usize = 23;\n+    const MIN_EXPONENT_ROUND_TO_EVEN: i32 = -17;\n+    const MAX_EXPONENT_ROUND_TO_EVEN: i32 = 10;\n+    const MIN_EXPONENT_FAST_PATH: i64 = -10; // assuming FLT_EVAL_METHOD = 0\n+    const MAX_EXPONENT_FAST_PATH: i64 = 10;\n+    const MAX_EXPONENT_DISGUISED_FAST_PATH: i64 = 17;\n+    const MINIMUM_EXPONENT: i32 = -127;\n+    const INFINITE_POWER: i32 = 0xFF;\n+    const SIGN_INDEX: usize = 31;\n+    const SMALLEST_POWER_OF_TEN: i32 = -65;\n+    const LARGEST_POWER_OF_TEN: i32 = 38;\n+\n+    fn from_u64(v: u64) -> Self {\n+        debug_assert!(v <= Self::MAX_MANTISSA_FAST_PATH);\n+        v as _\n+    }\n+\n+    fn from_u64_bits(v: u64) -> Self {\n+        f32::from_bits((v & 0xFFFFFFFF) as u32)\n+    }\n+\n+    fn pow10_fast_path(exponent: usize) -> Self {\n+        #[allow(clippy::use_self)]\n+        const TABLE: [f32; 16] =\n+            [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 0., 0., 0., 0., 0.];\n+        TABLE[exponent & 15]\n+    }\n+\n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8) {\n+        let bits = self.to_bits();\n+        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n+        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n+        let mantissa =\n+            if exponent == 0 { (bits & 0x7fffff) << 1 } else { (bits & 0x7fffff) | 0x800000 };\n+        // Exponent bias + mantissa shift\n+        exponent -= 127 + 23;\n+        (mantissa as u64, exponent, sign)\n+    }\n+\n+    fn classify(self) -> FpCategory {\n+        self.classify()\n+    }\n+}\n+\n+impl RawFloat for f64 {\n+    const INFINITY: Self = f64::INFINITY;\n+    const NEG_INFINITY: Self = f64::NEG_INFINITY;\n+    const NAN: Self = f64::NAN;\n+    const NEG_NAN: Self = -f64::NAN;\n+\n+    const MANTISSA_EXPLICIT_BITS: usize = 52;\n+    const MIN_EXPONENT_ROUND_TO_EVEN: i32 = -4;\n+    const MAX_EXPONENT_ROUND_TO_EVEN: i32 = 23;\n+    const MIN_EXPONENT_FAST_PATH: i64 = -22; // assuming FLT_EVAL_METHOD = 0\n+    const MAX_EXPONENT_FAST_PATH: i64 = 22;\n+    const MAX_EXPONENT_DISGUISED_FAST_PATH: i64 = 37;\n+    const MINIMUM_EXPONENT: i32 = -1023;\n+    const INFINITE_POWER: i32 = 0x7FF;\n+    const SIGN_INDEX: usize = 63;\n+    const SMALLEST_POWER_OF_TEN: i32 = -342;\n+    const LARGEST_POWER_OF_TEN: i32 = 308;\n+\n+    fn from_u64(v: u64) -> Self {\n+        debug_assert!(v <= Self::MAX_MANTISSA_FAST_PATH);\n+        v as _\n+    }\n+\n+    fn from_u64_bits(v: u64) -> Self {\n+        f64::from_bits(v)\n+    }\n+\n+    fn pow10_fast_path(exponent: usize) -> Self {\n+        const TABLE: [f64; 32] = [\n+            1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13, 1e14, 1e15,\n+            1e16, 1e17, 1e18, 1e19, 1e20, 1e21, 1e22, 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n+        ];\n+        TABLE[exponent & 31]\n+    }\n+\n+    /// Returns the mantissa, exponent and sign as integers.\n+    fn integer_decode(self) -> (u64, i16, i8) {\n+        let bits = self.to_bits();\n+        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n+        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n+        let mantissa = if exponent == 0 {\n+            (bits & 0xfffffffffffff) << 1\n+        } else {\n+            (bits & 0xfffffffffffff) | 0x10000000000000\n+        };\n+        // Exponent bias + mantissa shift\n+        exponent -= 1023 + 52;\n+        (mantissa, exponent, sign)\n+    }\n+\n+    fn classify(self) -> FpCategory {\n+        self.classify()\n+    }\n+}"}, {"sha": "24492d9a1dd5d69c68812814c164290b62a01813", "filename": "library/core/src/num/dec2flt/fpu.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffpu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffpu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ffpu.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -0,0 +1,89 @@\n+//! Platform-specific, assembly instructions to avoid\n+//! intermediate rounding on architectures with FPUs.\n+\n+pub use fpu_precision::set_precision;\n+\n+// On x86, the x87 FPU is used for float operations if the SSE/SSE2 extensions are not available.\n+// The x87 FPU operates with 80 bits of precision by default, which means that operations will\n+// round to 80 bits causing double rounding to happen when values are eventually represented as\n+// 32/64 bit float values. To overcome this, the FPU control word can be set so that the\n+// computations are performed in the desired precision.\n+#[cfg(all(target_arch = \"x86\", not(target_feature = \"sse2\")))]\n+mod fpu_precision {\n+    use core::mem::size_of;\n+\n+    /// A structure used to preserve the original value of the FPU control word, so that it can be\n+    /// restored when the structure is dropped.\n+    ///\n+    /// The x87 FPU is a 16-bits register whose fields are as follows:\n+    ///\n+    /// | 12-15 | 10-11 | 8-9 | 6-7 |  5 |  4 |  3 |  2 |  1 |  0 |\n+    /// |------:|------:|----:|----:|---:|---:|---:|---:|---:|---:|\n+    /// |       | RC    | PC  |     | PM | UM | OM | ZM | DM | IM |\n+    ///\n+    /// The documentation for all of the fields is available in the IA-32 Architectures Software\n+    /// Developer's Manual (Volume 1).\n+    ///\n+    /// The only field which is relevant for the following code is PC, Precision Control. This\n+    /// field determines the precision of the operations performed by the  FPU. It can be set to:\n+    ///  - 0b00, single precision i.e., 32-bits\n+    ///  - 0b10, double precision i.e., 64-bits\n+    ///  - 0b11, double extended precision i.e., 80-bits (default state)\n+    /// The 0b01 value is reserved and should not be used.\n+    pub struct FPUControlWord(u16);\n+\n+    fn set_cw(cw: u16) {\n+        // SAFETY: the `fldcw` instruction has been audited to be able to work correctly with\n+        // any `u16`\n+        unsafe {\n+            asm!(\n+                \"fldcw word ptr [{}]\",\n+                in(reg) &cw,\n+                options(nostack),\n+            )\n+        }\n+    }\n+\n+    /// Sets the precision field of the FPU to `T` and returns a `FPUControlWord`.\n+    pub fn set_precision<T>() -> FPUControlWord {\n+        let mut cw = 0_u16;\n+\n+        // Compute the value for the Precision Control field that is appropriate for `T`.\n+        let cw_precision = match size_of::<T>() {\n+            4 => 0x0000, // 32 bits\n+            8 => 0x0200, // 64 bits\n+            _ => 0x0300, // default, 80 bits\n+        };\n+\n+        // Get the original value of the control word to restore it later, when the\n+        // `FPUControlWord` structure is dropped\n+        // SAFETY: the `fnstcw` instruction has been audited to be able to work correctly with\n+        // any `u16`\n+        unsafe {\n+            asm!(\n+                \"fnstcw word ptr [{}]\",\n+                in(reg) &mut cw,\n+                options(nostack),\n+            )\n+        }\n+\n+        // Set the control word to the desired precision. This is achieved by masking away the old\n+        // precision (bits 8 and 9, 0x300) and replacing it with the precision flag computed above.\n+        set_cw((cw & 0xFCFF) | cw_precision);\n+\n+        FPUControlWord(cw)\n+    }\n+\n+    impl Drop for FPUControlWord {\n+        fn drop(&mut self) {\n+            set_cw(self.0)\n+        }\n+    }\n+}\n+\n+// In most architectures, floating point operations have an explicit bit size, therefore the\n+// precision of the computation is determined on a per-operation basis.\n+#[cfg(any(not(target_arch = \"x86\"), target_feature = \"sse2\"))]\n+mod fpu_precision {\n+    pub fn set_precision<T>() {}\n+}"}, {"sha": "9b7efc3d556bf87040d1355a1ebc1b813460eecc", "filename": "library/core/src/num/dec2flt/lemire.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Flemire.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -0,0 +1,166 @@\n+//! Implementation of the Eisel-Lemire algorithm.\n+\n+use crate::num::dec2flt::common::BiasedFp;\n+use crate::num::dec2flt::float::RawFloat;\n+use crate::num::dec2flt::table::{\n+    LARGEST_POWER_OF_FIVE, POWER_OF_FIVE_128, SMALLEST_POWER_OF_FIVE,\n+};\n+\n+/// Compute a float using an extended-precision representation.\n+///\n+/// Fast conversion of a the significant digits and decimal exponent\n+/// a float to a extended representation with a binary float. This\n+/// algorithm will accurately parse the vast majority of cases,\n+/// and uses a 128-bit representation (with a fallback 192-bit\n+/// representation).\n+///\n+/// This algorithm scales the exponent by the decimal exponent\n+/// using pre-computed powers-of-5, and calculates if the\n+/// representation can be unambiguously rounded to the nearest\n+/// machine float. Near-halfway cases are not handled here,\n+/// and are represented by a negative, biased binary exponent.\n+///\n+/// The algorithm is described in detail in \"Daniel Lemire, Number Parsing\n+/// at a Gigabyte per Second\" in section 5, \"Fast Algorithm\", and\n+/// section 6, \"Exact Numbers And Ties\", available online:\n+/// <https://arxiv.org/abs/2101.11408.pdf>.\n+pub fn compute_float<F: RawFloat>(q: i64, mut w: u64) -> BiasedFp {\n+    let fp_zero = BiasedFp::zero_pow2(0);\n+    let fp_inf = BiasedFp::zero_pow2(F::INFINITE_POWER);\n+    let fp_error = BiasedFp::zero_pow2(-1);\n+\n+    // Short-circuit if the value can only be a literal 0 or infinity.\n+    if w == 0 || q < F::SMALLEST_POWER_OF_TEN as i64 {\n+        return fp_zero;\n+    } else if q > F::LARGEST_POWER_OF_TEN as i64 {\n+        return fp_inf;\n+    }\n+    // Normalize our significant digits, so the most-significant bit is set.\n+    let lz = w.leading_zeros();\n+    w <<= lz;\n+    let (lo, hi) = compute_product_approx(q, w, F::MANTISSA_EXPLICIT_BITS + 3);\n+    if lo == 0xFFFF_FFFF_FFFF_FFFF {\n+        // If we have failed to approximate w x 5^-q with our 128-bit value.\n+        // Since the addition of 1 could lead to an overflow which could then\n+        // round up over the half-way point, this can lead to improper rounding\n+        // of a float.\n+        //\n+        // However, this can only occur if q \u2208 [-27, 55]. The upper bound of q\n+        // is 55 because 5^55 < 2^128, however, this can only happen if 5^q > 2^64,\n+        // since otherwise the product can be represented in 64-bits, producing\n+        // an exact result. For negative exponents, rounding-to-even can\n+        // only occur if 5^-q < 2^64.\n+        //\n+        // For detailed explanations of rounding for negative exponents, see\n+        // <https://arxiv.org/pdf/2101.11408.pdf#section.9.1>. For detailed\n+        // explanations of rounding for positive exponents, see\n+        // <https://arxiv.org/pdf/2101.11408.pdf#section.8>.\n+        let inside_safe_exponent = (q >= -27) && (q <= 55);\n+        if !inside_safe_exponent {\n+            return fp_error;\n+        }\n+    }\n+    let upperbit = (hi >> 63) as i32;\n+    let mut mantissa = hi >> (upperbit + 64 - F::MANTISSA_EXPLICIT_BITS as i32 - 3);\n+    let mut power2 = power(q as i32) + upperbit - lz as i32 - F::MINIMUM_EXPONENT;\n+    if power2 <= 0 {\n+        if -power2 + 1 >= 64 {\n+            // Have more than 64 bits below the minimum exponent, must be 0.\n+            return fp_zero;\n+        }\n+        // Have a subnormal value.\n+        mantissa >>= -power2 + 1;\n+        mantissa += mantissa & 1;\n+        mantissa >>= 1;\n+        power2 = (mantissa >= (1_u64 << F::MANTISSA_EXPLICIT_BITS)) as i32;\n+        return BiasedFp { f: mantissa, e: power2 };\n+    }\n+    // Need to handle rounding ties. Normally, we need to round up,\n+    // but if we fall right in between and and we have an even basis, we\n+    // need to round down.\n+    //\n+    // This will only occur if:\n+    //  1. The lower 64 bits of the 128-bit representation is 0.\n+    //      IE, 5^q fits in single 64-bit word.\n+    //  2. The least-significant bit prior to truncated mantissa is odd.\n+    //  3. All the bits truncated when shifting to mantissa bits + 1 are 0.\n+    //\n+    // Or, we may fall between two floats: we are exactly halfway.\n+    if lo <= 1\n+        && q >= F::MIN_EXPONENT_ROUND_TO_EVEN as i64\n+        && q <= F::MAX_EXPONENT_ROUND_TO_EVEN as i64\n+        && mantissa & 3 == 1\n+        && (mantissa << (upperbit + 64 - F::MANTISSA_EXPLICIT_BITS as i32 - 3)) == hi\n+    {\n+        // Zero the lowest bit, so we don't round up.\n+        mantissa &= !1_u64;\n+    }\n+    // Round-to-even, then shift the significant digits into place.\n+    mantissa += mantissa & 1;\n+    mantissa >>= 1;\n+    if mantissa >= (2_u64 << F::MANTISSA_EXPLICIT_BITS) {\n+        // Rounding up overflowed, so the carry bit is set. Set the\n+        // mantissa to 1 (only the implicit, hidden bit is set) and\n+        // increase the exponent.\n+        mantissa = 1_u64 << F::MANTISSA_EXPLICIT_BITS;\n+        power2 += 1;\n+    }\n+    // Zero out the hidden bit.\n+    mantissa &= !(1_u64 << F::MANTISSA_EXPLICIT_BITS);\n+    if power2 >= F::INFINITE_POWER {\n+        // Exponent is above largest normal value, must be infinite.\n+        return fp_inf;\n+    }\n+    BiasedFp { f: mantissa, e: power2 }\n+}\n+\n+/// Calculate a base 2 exponent from a decimal exponent.\n+/// This uses a pre-computed integer approximation for\n+/// log2(10), where 217706 / 2^16 is accurate for the\n+/// entire range of non-finite decimal exponents.\n+fn power(q: i32) -> i32 {\n+    (q.wrapping_mul(152_170 + 65536) >> 16) + 63\n+}\n+\n+fn full_multiplication(a: u64, b: u64) -> (u64, u64) {\n+    let r = (a as u128) * (b as u128);\n+    (r as u64, (r >> 64) as u64)\n+}\n+\n+// This will compute or rather approximate w * 5**q and return a pair of 64-bit words\n+// approximating the result, with the \"high\" part corresponding to the most significant\n+// bits and the low part corresponding to the least significant bits.\n+fn compute_product_approx(q: i64, w: u64, precision: usize) -> (u64, u64) {\n+    debug_assert!(q >= SMALLEST_POWER_OF_FIVE as i64);\n+    debug_assert!(q <= LARGEST_POWER_OF_FIVE as i64);\n+    debug_assert!(precision <= 64);\n+\n+    let mask = if precision < 64 {\n+        0xFFFF_FFFF_FFFF_FFFF_u64 >> precision\n+    } else {\n+        0xFFFF_FFFF_FFFF_FFFF_u64\n+    };\n+\n+    // 5^q < 2^64, then the multiplication always provides an exact value.\n+    // That means whenever we need to round ties to even, we always have\n+    // an exact value.\n+    let index = (q - SMALLEST_POWER_OF_FIVE as i64) as usize;\n+    let (lo5, hi5) = POWER_OF_FIVE_128[index];\n+    // Only need one multiplication as long as there is 1 zero but\n+    // in the explicit mantissa bits, +1 for the hidden bit, +1 to\n+    // determine the rounding direction, +1 for if the computed\n+    // product has a leading zero.\n+    let (mut first_lo, mut first_hi) = full_multiplication(w, lo5);\n+    if first_hi & mask == mask {\n+        // Need to do a second multiplication to get better precision\n+        // for the lower product. This will always be exact\n+        // where q is < 55, since 5^55 < 2^128. If this wraps,\n+        // then we need to need to round up the hi product.\n+        let (_, second_hi) = full_multiplication(w, hi5);\n+        first_lo = first_lo.wrapping_add(second_hi);\n+        if second_hi > first_lo {\n+            first_hi += 1;\n+        }\n+    }\n+    (first_lo, first_hi)\n+}"}, {"sha": "c78492f5ae2c9ae0702f5ac06ac3c7de0647456b", "filename": "library/core/src/num/dec2flt/mod.rs", "status": "modified", "additions": 66, "deletions": 154, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fmod.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -27,20 +27,12 @@\n //!\n //! We then try a long chain of progressively more general and expensive special cases using\n //! machine-sized integers and small, fixed-sized floating point numbers (first `f32`/`f64`, then\n-//! a type with 64 bit significand, `Fp`). When all these fail, we bite the bullet and resort to a\n-//! simple but very slow algorithm that involved computing `f * 10^e` fully and doing an iterative\n-//! search for the best approximation.\n-//!\n-//! Primarily, this module and its children implement the algorithms described in:\n-//! \"How to Read Floating Point Numbers Accurately\" by William D. Clinger,\n-//! available online: <https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.4152>\n-//!\n-//! In addition, there are numerous helper functions that are used in the paper but not available\n-//! in Rust (or at least in core). Our version is additionally complicated by the need to handle\n-//! overflow and underflow and the desire to handle subnormal numbers. Bellerophon and\n-//! Algorithm R have trouble with overflow, subnormals, and underflow. We conservatively switch to\n-//! Algorithm M (with the modifications described in section 8 of the paper) well before the\n-//! inputs get into the critical region.\n+//! a type with 64 bit significand). The extended-precision algorithm\n+//! uses the Eisel-Lemire algorithm, which uses a 128-bit (or 192-bit)\n+//! representation that can accurately and quickly compute the vast majority\n+//! of floats. When all these fail, we bite the bullet and resort to using\n+//! a large-decimal representation, shifting the digits into range, calculating\n+//! the upper significant bits and exactly round to the nearest representation.\n //!\n //! Another aspect that needs attention is the ``RawFloat`` trait by which almost all functions\n //! are parametrized. One might think that it's enough to parse to `f64` and cast the result to\n@@ -54,10 +46,9 @@\n //! operations as well, if you want 0.5 ULP accuracy you need to do *everything* in full precision\n //! and round *exactly once, at the end*, by considering all truncated bits at once.\n //!\n-//! FIXME: Although some code duplication is necessary, perhaps parts of the code could be shuffled\n-//! around such that less code is duplicated. Large parts of the algorithms are independent of the\n-//! float type to output, or only needs access to a few constants, which could be passed in as\n-//! parameters.\n+//! Primarily, this module and its children implement the algorithms described in:\n+//! \"Number Parsing at a Gigabyte per Second\", available online:\n+//! <https://arxiv.org/abs/2101.11408>.\n //!\n //! # Other\n //!\n@@ -87,16 +78,22 @@\n use crate::fmt;\n use crate::str::FromStr;\n \n-use self::num::digits_to_big;\n-use self::parse::{parse_decimal, Decimal, ParseResult, Sign};\n-use self::rawfp::RawFloat;\n+use self::common::{BiasedFp, ByteSlice};\n+use self::float::RawFloat;\n+use self::lemire::compute_float;\n+use self::parse::{parse_inf_nan, parse_number};\n+use self::slow::parse_long_mantissa;\n \n-mod algorithm;\n-mod num;\n+mod common;\n+mod decimal;\n+mod fpu;\n+mod slow;\n mod table;\n-// These two have their own tests.\n+// float is used in flt2dec, and all are used in unit tests.\n+pub mod float;\n+pub mod lemire;\n+pub mod number;\n pub mod parse;\n-pub mod rawfp;\n \n macro_rules! from_str_float_impl {\n     ($t:ty) => {\n@@ -136,13 +133,6 @@ macro_rules! from_str_float_impl {\n             ///\n             /// [EBNF]: https://www.w3.org/TR/REC-xml/#sec-notation\n             ///\n-            /// # Known bugs\n-            ///\n-            /// In some situations, some strings that should create a valid float\n-            /// instead return an error. See [issue #31407] for details.\n-            ///\n-            /// [issue #31407]: https://github.com/rust-lang/rust/issues/31407\n-            ///\n             /// # Arguments\n             ///\n             /// * src - A string\n@@ -211,148 +201,70 @@ impl fmt::Display for ParseFloatError {\n     }\n }\n \n-fn pfe_empty() -> ParseFloatError {\n+pub(super) fn pfe_empty() -> ParseFloatError {\n     ParseFloatError { kind: FloatErrorKind::Empty }\n }\n \n-fn pfe_invalid() -> ParseFloatError {\n+// Used in unit tests, keep public.\n+// This is much better than making FloatErrorKind and ParseFloatError::kind public.\n+pub fn pfe_invalid() -> ParseFloatError {\n     ParseFloatError { kind: FloatErrorKind::Invalid }\n }\n \n-/// Splits a decimal string into sign and the rest, without inspecting or validating the rest.\n-fn extract_sign(s: &str) -> (Sign, &str) {\n-    match s.as_bytes()[0] {\n-        b'+' => (Sign::Positive, &s[1..]),\n-        b'-' => (Sign::Negative, &s[1..]),\n-        // If the string is invalid, we never use the sign, so we don't need to validate here.\n-        _ => (Sign::Positive, s),\n-    }\n+/// Converts a `BiasedFp` to the closest machine float type.\n+fn biased_fp_to_float<T: RawFloat>(x: BiasedFp) -> T {\n+    let mut word = x.f;\n+    word |= (x.e as u64) << T::MANTISSA_EXPLICIT_BITS;\n+    T::from_u64_bits(word)\n }\n \n /// Converts a decimal string into a floating point number.\n-fn dec2flt<T: RawFloat>(s: &str) -> Result<T, ParseFloatError> {\n-    if s.is_empty() {\n+pub fn dec2flt<F: RawFloat>(s: &str) -> Result<F, ParseFloatError> {\n+    let mut s = s.as_bytes();\n+    let c = if let Some(&c) = s.first() {\n+        c\n+    } else {\n         return Err(pfe_empty());\n+    };\n+    let negative = c == b'-';\n+    if c == b'-' || c == b'+' {\n+        s = s.advance(1);\n+    }\n+    if s.is_empty() {\n+        return Err(pfe_invalid());\n     }\n-    let (sign, s) = extract_sign(s);\n-    let flt = match parse_decimal(s) {\n-        ParseResult::Valid(decimal) => convert(decimal)?,\n-        ParseResult::ShortcutToInf => T::INFINITY,\n-        ParseResult::ShortcutToZero => T::ZERO,\n-        ParseResult::Invalid => {\n-            if s.eq_ignore_ascii_case(\"nan\") {\n-                T::NAN\n-            } else if s.eq_ignore_ascii_case(\"inf\") || s.eq_ignore_ascii_case(\"infinity\") {\n-                T::INFINITY\n+\n+    let num = match parse_number(s, negative) {\n+        Some(r) => r,\n+        None => {\n+            if let Some(value) = parse_inf_nan(s, negative) {\n+                return Ok(value);\n             } else {\n                 return Err(pfe_invalid());\n             }\n         }\n     };\n-\n-    match sign {\n-        Sign::Positive => Ok(flt),\n-        Sign::Negative => Ok(-flt),\n+    if let Some(value) = num.try_fast_path::<F>() {\n+        return Ok(value);\n     }\n-}\n-\n-/// The main workhorse for the decimal-to-float conversion: Orchestrate all the preprocessing\n-/// and figure out which algorithm should do the actual conversion.\n-fn convert<T: RawFloat>(mut decimal: Decimal<'_>) -> Result<T, ParseFloatError> {\n-    simplify(&mut decimal);\n-    if let Some(x) = trivial_cases(&decimal) {\n-        return Ok(x);\n-    }\n-    // Remove/shift out the decimal point.\n-    let e = decimal.exp - decimal.fractional.len() as i64;\n-    if let Some(x) = algorithm::fast_path(decimal.integral, decimal.fractional, e) {\n-        return Ok(x);\n-    }\n-    // Big32x40 is limited to 1280 bits, which translates to about 385 decimal digits.\n-    // If we exceed this, we'll crash, so we error out before getting too close (within 10^10).\n-    let upper_bound = bound_intermediate_digits(&decimal, e);\n-    if upper_bound > 375 {\n-        return Err(pfe_invalid());\n-    }\n-    let f = digits_to_big(decimal.integral, decimal.fractional);\n-\n-    // Now the exponent certainly fits in 16 bit, which is used throughout the main algorithms.\n-    let e = e as i16;\n-    // FIXME These bounds are rather conservative. A more careful analysis of the failure modes\n-    // of Bellerophon could allow using it in more cases for a massive speed up.\n-    let exponent_in_range = table::MIN_E <= e && e <= table::MAX_E;\n-    let value_in_range = upper_bound <= T::MAX_NORMAL_DIGITS as u64;\n-    if exponent_in_range && value_in_range {\n-        Ok(algorithm::bellerophon(&f, e))\n-    } else {\n-        Ok(algorithm::algorithm_m(&f, e))\n-    }\n-}\n \n-// As written, this optimizes badly (see #27130, though it refers to an old version of the code).\n-// `inline(always)` is a workaround for that. There are only two call sites overall and it doesn't\n-// make code size worse.\n-\n-/// Strip zeros where possible, even when this requires changing the exponent\n-#[inline(always)]\n-fn simplify(decimal: &mut Decimal<'_>) {\n-    let is_zero = &|&&d: &&u8| -> bool { d == b'0' };\n-    // Trimming these zeros does not change anything but may enable the fast path (< 15 digits).\n-    let leading_zeros = decimal.integral.iter().take_while(is_zero).count();\n-    decimal.integral = &decimal.integral[leading_zeros..];\n-    let trailing_zeros = decimal.fractional.iter().rev().take_while(is_zero).count();\n-    let end = decimal.fractional.len() - trailing_zeros;\n-    decimal.fractional = &decimal.fractional[..end];\n-    // Simplify numbers of the form 0.0...x and x...0.0, adjusting the exponent accordingly.\n-    // This may not always be a win (possibly pushes some numbers out of the fast path), but it\n-    // simplifies other parts significantly (notably, approximating the magnitude of the value).\n-    if decimal.integral.is_empty() {\n-        let leading_zeros = decimal.fractional.iter().take_while(is_zero).count();\n-        decimal.fractional = &decimal.fractional[leading_zeros..];\n-        decimal.exp -= leading_zeros as i64;\n-    } else if decimal.fractional.is_empty() {\n-        let trailing_zeros = decimal.integral.iter().rev().take_while(is_zero).count();\n-        let end = decimal.integral.len() - trailing_zeros;\n-        decimal.integral = &decimal.integral[..end];\n-        decimal.exp += trailing_zeros as i64;\n+    // If significant digits were truncated, then we can have rounding error\n+    // only if `mantissa + 1` produces a different result. We also avoid\n+    // redundantly using the Eisel-Lemire algorithm if it was unable to\n+    // correctly round on the first pass.\n+    let mut fp = compute_float::<F>(num.exponent, num.mantissa);\n+    if num.many_digits && fp.e >= 0 && fp != compute_float::<F>(num.exponent, num.mantissa + 1) {\n+        fp.e = -1;\n     }\n-}\n-\n-/// Returns a quick-an-dirty upper bound on the size (log10) of the largest value that Algorithm R\n-/// and Algorithm M will compute while working on the given decimal.\n-fn bound_intermediate_digits(decimal: &Decimal<'_>, e: i64) -> u64 {\n-    // We don't need to worry too much about overflow here thanks to trivial_cases() and the\n-    // parser, which filter out the most extreme inputs for us.\n-    let f_len: u64 = decimal.integral.len() as u64 + decimal.fractional.len() as u64;\n-    if e >= 0 {\n-        // In the case e >= 0, both algorithms compute about `f * 10^e`. Algorithm R proceeds to\n-        // do some complicated calculations with this but we can ignore that for the upper bound\n-        // because it also reduces the fraction beforehand, so we have plenty of buffer there.\n-        f_len + (e as u64)\n-    } else {\n-        // If e < 0, Algorithm R does roughly the same thing, but Algorithm M differs:\n-        // It tries to find a positive number k such that `f << k / 10^e` is an in-range\n-        // significand. This will result in about `2^53 * f * 10^e` < `10^17 * f * 10^e`.\n-        // One input that triggers this is 0.33...33 (375 x 3).\n-        f_len + e.unsigned_abs() + 17\n+    // Unable to correctly round the float using the Eisel-Lemire algorithm.\n+    // Fallback to a slower, but always correct algorithm.\n+    if fp.e < 0 {\n+        fp = parse_long_mantissa::<F>(s);\n     }\n-}\n \n-/// Detects obvious overflows and underflows without even looking at the decimal digits.\n-fn trivial_cases<T: RawFloat>(decimal: &Decimal<'_>) -> Option<T> {\n-    // There were zeros but they were stripped by simplify()\n-    if decimal.integral.is_empty() && decimal.fractional.is_empty() {\n-        return Some(T::ZERO);\n-    }\n-    // This is a crude approximation of ceil(log10(the real value)). We don't need to worry too\n-    // much about overflow here because the input length is tiny (at least compared to 2^64) and\n-    // the parser already handles exponents whose absolute value is greater than 10^18\n-    // (which is still 10^19 short of 2^64).\n-    let max_place = decimal.exp + decimal.integral.len() as i64;\n-    if max_place > T::INF_CUTOFF {\n-        return Some(T::INFINITY);\n-    } else if max_place < T::ZERO_CUTOFF {\n-        return Some(T::ZERO);\n+    let mut float = biased_fp_to_float::<F>(fp);\n+    if num.negative {\n+        float = -float;\n     }\n-    None\n+    Ok(float)\n }"}, {"sha": "208783dd32fd5df8c271cbb0c69e308b4f3e1f2b", "filename": "library/core/src/num/dec2flt/num.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d2b04f075c0ce010758c4c8674152ff89d1d73f3/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b04f075c0ce010758c4c8674152ff89d1d73f3/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fnum.rs?ref=d2b04f075c0ce010758c4c8674152ff89d1d73f3", "patch": "@@ -1,81 +0,0 @@\n-//! Utility functions for bignums that don't make too much sense to turn into methods.\n-\n-// FIXME This module's name is a bit unfortunate, since other modules also import `core::num`.\n-\n-use crate::cmp::Ordering::{self, Equal, Greater, Less};\n-\n-pub use crate::num::bignum::Big32x40 as Big;\n-\n-/// Test whether truncating all bits less significant than `ones_place` introduces\n-/// a relative error less, equal, or greater than 0.5 ULP.\n-pub fn compare_with_half_ulp(f: &Big, ones_place: usize) -> Ordering {\n-    if ones_place == 0 {\n-        return Less;\n-    }\n-    let half_bit = ones_place - 1;\n-    if f.get_bit(half_bit) == 0 {\n-        // < 0.5 ULP\n-        return Less;\n-    }\n-    // If all remaining bits are zero, it's = 0.5 ULP, otherwise > 0.5\n-    // If there are no more bits (half_bit == 0), the below also correctly returns Equal.\n-    for i in 0..half_bit {\n-        if f.get_bit(i) == 1 {\n-            return Greater;\n-        }\n-    }\n-    Equal\n-}\n-\n-/// Converts an ASCII string containing only decimal digits to a `u64`.\n-///\n-/// Does not perform checks for overflow or invalid characters, so if the caller is not careful,\n-/// the result is bogus and can panic (though it won't be `unsafe`). Additionally, empty strings\n-/// are treated as zero. This function exists because\n-///\n-/// 1. using `FromStr` on `&[u8]` requires `from_utf8_unchecked`, which is bad, and\n-/// 2. piecing together the results of `integral.parse()` and `fractional.parse()` is\n-///    more complicated than this entire function.\n-pub fn from_str_unchecked<'a, T>(bytes: T) -> u64\n-where\n-    T: IntoIterator<Item = &'a u8>,\n-{\n-    let mut result = 0;\n-    for &c in bytes {\n-        result = result * 10 + (c - b'0') as u64;\n-    }\n-    result\n-}\n-\n-/// Converts a string of ASCII digits into a bignum.\n-///\n-/// Like `from_str_unchecked`, this function relies on the parser to weed out non-digits.\n-pub fn digits_to_big(integral: &[u8], fractional: &[u8]) -> Big {\n-    let mut f = Big::from_small(0);\n-    for &c in integral.iter().chain(fractional) {\n-        let n = (c - b'0') as u32;\n-        f.mul_small(10);\n-        f.add_small(n);\n-    }\n-    f\n-}\n-\n-/// Unwraps a bignum into a 64 bit integer. Panics if the number is too large.\n-pub fn to_u64(x: &Big) -> u64 {\n-    assert!(x.bit_length() < 64);\n-    let d = x.digits();\n-    if d.len() < 2 { d[0] as u64 } else { (d[1] as u64) << 32 | d[0] as u64 }\n-}\n-\n-/// Extracts a range of bits.\n-\n-/// Index 0 is the least significant bit and the range is half-open as usual.\n-/// Panics if asked to extract more bits than fit into the return type.\n-pub fn get_bits(x: &Big, start: usize, end: usize) -> u64 {\n-    assert!(end - start <= 64);\n-    let mut result: u64 = 0;\n-    for i in (start..end).rev() {\n-        result = result << 1 | x.get_bit(i) as u64;\n-    }\n-    result\n-}"}, {"sha": "36432718af40eaed18f60c2a6836a0d2b6f4ac8e", "filename": "library/core/src/num/dec2flt/number.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fnumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fnumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fnumber.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -0,0 +1,86 @@\n+//! Representation of a float as the significant digits and exponent.\n+\n+use crate::num::dec2flt::float::RawFloat;\n+use crate::num::dec2flt::fpu::set_precision;\n+\n+#[rustfmt::skip]\n+const INT_POW10: [u64; 16] = [\n+    1,\n+    10,\n+    100,\n+    1000,\n+    10000,\n+    100000,\n+    1000000,\n+    10000000,\n+    100000000,\n+    1000000000,\n+    10000000000,\n+    100000000000,\n+    1000000000000,\n+    10000000000000,\n+    100000000000000,\n+    1000000000000000,\n+];\n+\n+#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]\n+pub struct Number {\n+    pub exponent: i64,\n+    pub mantissa: u64,\n+    pub negative: bool,\n+    pub many_digits: bool,\n+}\n+\n+impl Number {\n+    /// Detect if the float can be accurately reconstructed from native floats.\n+    fn is_fast_path<F: RawFloat>(&self) -> bool {\n+        F::MIN_EXPONENT_FAST_PATH <= self.exponent\n+            && self.exponent <= F::MAX_EXPONENT_DISGUISED_FAST_PATH\n+            && self.mantissa <= F::MAX_MANTISSA_FAST_PATH\n+            && !self.many_digits\n+    }\n+\n+    /// The fast path algorithmn using machine-sized integers and floats.\n+    ///\n+    /// This is extracted into a separate function so that it can be attempted before constructing\n+    /// a Decimal. This only works if both the mantissa and the exponent\n+    /// can be exactly represented as a machine float, since IEE-754 guarantees\n+    /// no rounding will occur.\n+    ///\n+    /// There is an exception: disguised fast-path cases, where we can shift\n+    /// powers-of-10 from the exponent to the significant digits.\n+    pub fn try_fast_path<F: RawFloat>(&self) -> Option<F> {\n+        // The fast path crucially depends on arithmetic being rounded to the correct number of bits\n+        // without any intermediate rounding. On x86 (without SSE or SSE2) this requires the precision\n+        // of the x87 FPU stack to be changed so that it directly rounds to 64/32 bit.\n+        // The `set_precision` function takes care of setting the precision on architectures which\n+        // require setting it by changing the global state (like the control word of the x87 FPU).\n+        let _cw = set_precision::<F>();\n+\n+        if self.is_fast_path::<F>() {\n+            let mut value = if self.exponent <= F::MAX_EXPONENT_FAST_PATH {\n+                // normal fast path\n+                let value = F::from_u64(self.mantissa);\n+                if self.exponent < 0 {\n+                    value / F::pow10_fast_path((-self.exponent) as _)\n+                } else {\n+                    value * F::pow10_fast_path(self.exponent as _)\n+                }\n+            } else {\n+                // disguised fast path\n+                let shift = self.exponent - F::MAX_EXPONENT_FAST_PATH;\n+                let mantissa = self.mantissa.checked_mul(INT_POW10[shift as usize])?;\n+                if mantissa > F::MAX_MANTISSA_FAST_PATH {\n+                    return None;\n+                }\n+                F::from_u64(mantissa) * F::pow10_fast_path(F::MAX_EXPONENT_FAST_PATH as _)\n+            };\n+            if self.negative {\n+                value = -value;\n+            }\n+            Some(value)\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "fa677bf5123959820054064cf58abb580dcfd3f1", "filename": "library/core/src/num/dec2flt/parse.rs", "status": "modified", "additions": 208, "deletions": 96, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fparse.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,121 +1,233 @@\n-//! Validating and decomposing a decimal string of the form:\n-//!\n-//! `(digits | digits? '.'? digits?) (('e' | 'E') ('+' | '-')? digits)?`\n-//!\n-//! In other words, standard floating-point syntax, with two exceptions: No sign, and no\n-//! handling of \"inf\" and \"NaN\". These are handled by the driver function (super::dec2flt).\n-//!\n-//! Although recognizing valid inputs is relatively easy, this module also has to reject the\n-//! countless invalid variations, never panic, and perform numerous checks that the other\n-//! modules rely on to not panic (or overflow) in turn.\n-//! To make matters worse, all that happens in a single pass over the input.\n-//! So, be careful when modifying anything, and double-check with the other modules.\n-use self::ParseResult::{Invalid, ShortcutToInf, ShortcutToZero, Valid};\n-use super::num;\n-\n-#[derive(Debug)]\n-pub enum Sign {\n-    Positive,\n-    Negative,\n+//! Functions to parse floating-point numbers.\n+\n+use crate::num::dec2flt::common::{is_8digits, AsciiStr, ByteSlice};\n+use crate::num::dec2flt::float::RawFloat;\n+use crate::num::dec2flt::number::Number;\n+\n+const MIN_19DIGIT_INT: u64 = 100_0000_0000_0000_0000;\n+\n+/// Parse 8 digits, loaded as bytes in little-endian order.\n+///\n+/// This uses the trick where every digit is in [0x030, 0x39],\n+/// and therefore can be parsed in 3 multiplications, much\n+/// faster than the normal 8.\n+///\n+/// This is based off the algorithm described in \"Fast numeric string to\n+/// int\", available here: <https://johnnylee-sde.github.io/Fast-numeric-string-to-int/>.\n+fn parse_8digits(mut v: u64) -> u64 {\n+    const MASK: u64 = 0x0000_00FF_0000_00FF;\n+    const MUL1: u64 = 0x000F_4240_0000_0064;\n+    const MUL2: u64 = 0x0000_2710_0000_0001;\n+    v -= 0x3030_3030_3030_3030;\n+    v = (v * 10) + (v >> 8); // will not overflow, fits in 63 bits\n+    let v1 = (v & MASK).wrapping_mul(MUL1);\n+    let v2 = ((v >> 16) & MASK).wrapping_mul(MUL2);\n+    ((v1.wrapping_add(v2) >> 32) as u32) as u64\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n-/// The interesting parts of a decimal string.\n-pub struct Decimal<'a> {\n-    pub integral: &'a [u8],\n-    pub fractional: &'a [u8],\n-    /// The decimal exponent, guaranteed to have fewer than 18 decimal digits.\n-    pub exp: i64,\n+/// Parse digits until a non-digit character is found.\n+fn try_parse_digits(s: &mut AsciiStr<'_>, x: &mut u64) {\n+    // may cause overflows, to be handled later\n+    s.parse_digits(|digit| {\n+        *x = x.wrapping_mul(10).wrapping_add(digit as _);\n+    });\n }\n \n-impl<'a> Decimal<'a> {\n-    pub fn new(integral: &'a [u8], fractional: &'a [u8], exp: i64) -> Decimal<'a> {\n-        Decimal { integral, fractional, exp }\n+/// Parse up to 19 digits (the max that can be stored in a 64-bit integer).\n+fn try_parse_19digits(s: &mut AsciiStr<'_>, x: &mut u64) {\n+    while *x < MIN_19DIGIT_INT {\n+        if let Some(&c) = s.as_ref().first() {\n+            let digit = c.wrapping_sub(b'0');\n+            if digit < 10 {\n+                *x = (*x * 10) + digit as u64; // no overflows here\n+                // SAFETY: cannot be empty\n+                unsafe {\n+                    s.step();\n+                }\n+            } else {\n+                break;\n+            }\n+        } else {\n+            break;\n+        }\n     }\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n-pub enum ParseResult<'a> {\n-    Valid(Decimal<'a>),\n-    ShortcutToInf,\n-    ShortcutToZero,\n-    Invalid,\n+/// Try to parse 8 digits at a time, using an optimized algorithm.\n+fn try_parse_8digits(s: &mut AsciiStr<'_>, x: &mut u64) {\n+    // may cause overflows, to be handled later\n+    if let Some(v) = s.read_u64() {\n+        if is_8digits(v) {\n+            *x = x.wrapping_mul(1_0000_0000).wrapping_add(parse_8digits(v));\n+            // SAFETY: already ensured the buffer was >= 8 bytes in read_u64.\n+            unsafe {\n+                s.step_by(8);\n+            }\n+            if let Some(v) = s.read_u64() {\n+                if is_8digits(v) {\n+                    *x = x.wrapping_mul(1_0000_0000).wrapping_add(parse_8digits(v));\n+                    // SAFETY: already ensured the buffer was >= 8 bytes in try_read_u64.\n+                    unsafe {\n+                        s.step_by(8);\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n-/// Checks if the input string is a valid floating point number and if so, locate the integral\n-/// part, the fractional part, and the exponent in it. Does not handle signs.\n-pub fn parse_decimal(s: &str) -> ParseResult<'_> {\n-    if s.is_empty() {\n-        return Invalid;\n+/// Parse the scientific notation component of a float.\n+fn parse_scientific(s: &mut AsciiStr<'_>) -> Option<i64> {\n+    let mut exponent = 0_i64;\n+    let mut negative = false;\n+    if let Some(&c) = s.as_ref().get(0) {\n+        negative = c == b'-';\n+        if c == b'-' || c == b'+' {\n+            // SAFETY: s cannot be empty\n+            unsafe {\n+                s.step();\n+            }\n+        }\n     }\n+    if s.first_isdigit() {\n+        s.parse_digits(|digit| {\n+            // no overflows here, saturate well before overflow\n+            if exponent < 0x10000 {\n+                exponent = 10 * exponent + digit as i64;\n+            }\n+        });\n+        if negative { Some(-exponent) } else { Some(exponent) }\n+    } else {\n+        None\n+    }\n+}\n \n-    let s = s.as_bytes();\n-    let (integral, s) = eat_digits(s);\n+/// Parse a partial, non-special floating point number.\n+///\n+/// This creates a representation of the float as the\n+/// significant digits and the decimal exponent.\n+fn parse_partial_number(s: &[u8], negative: bool) -> Option<(Number, usize)> {\n+    let mut s = AsciiStr::new(s);\n+    let start = s;\n+    debug_assert!(!s.is_empty());\n \n-    match s.first() {\n-        None => Valid(Decimal::new(integral, b\"\", 0)),\n-        Some(&b'e' | &b'E') => {\n-            if integral.is_empty() {\n-                return Invalid; // No digits before 'e'\n-            }\n+    // parse initial digits before dot\n+    let mut mantissa = 0_u64;\n+    let digits_start = s;\n+    try_parse_digits(&mut s, &mut mantissa);\n+    let mut n_digits = s.offset_from(&digits_start);\n+\n+    // handle dot with the following digits\n+    let mut n_after_dot = 0;\n+    let mut exponent = 0_i64;\n+    let int_end = s;\n+    if s.first_is(b'.') {\n+        // SAFETY: s cannot be empty due to first_is\n+        unsafe { s.step() };\n+        let before = s;\n+        try_parse_8digits(&mut s, &mut mantissa);\n+        try_parse_digits(&mut s, &mut mantissa);\n+        n_after_dot = s.offset_from(&before);\n+        exponent = -n_after_dot as i64;\n+    }\n \n-            parse_exp(integral, b\"\", &s[1..])\n+    n_digits += n_after_dot;\n+    if n_digits == 0 {\n+        return None;\n+    }\n+\n+    // handle scientific format\n+    let mut exp_number = 0_i64;\n+    if s.first_is2(b'e', b'E') {\n+        // SAFETY: s cannot be empty\n+        unsafe {\n+            s.step();\n         }\n-        Some(&b'.') => {\n-            let (fractional, s) = eat_digits(&s[1..]);\n-            if integral.is_empty() && fractional.is_empty() {\n-                // We require at least a single digit before or after the point.\n-                return Invalid;\n-            }\n+        // If None, we have no trailing digits after exponent, or an invalid float.\n+        exp_number = parse_scientific(&mut s)?;\n+        exponent += exp_number;\n+    }\n \n-            match s.first() {\n-                None => Valid(Decimal::new(integral, fractional, 0)),\n-                Some(&b'e' | &b'E') => parse_exp(integral, fractional, &s[1..]),\n-                _ => Invalid, // Trailing junk after fractional part\n-            }\n+    let len = s.offset_from(&start) as _;\n+\n+    // handle uncommon case with many digits\n+    if n_digits <= 19 {\n+        return Some((Number { exponent, mantissa, negative, many_digits: false }, len));\n+    }\n+\n+    n_digits -= 19;\n+    let mut many_digits = false;\n+    let mut p = digits_start;\n+    while p.first_is2(b'0', b'.') {\n+        // SAFETY: p cannot be empty due to first_is2\n+        unsafe {\n+            // '0' = b'.' + 2\n+            n_digits -= p.first_unchecked().saturating_sub(b'0' - 1) as isize;\n+            p.step();\n         }\n-        _ => Invalid, // Trailing junk after first digit string\n     }\n-}\n+    if n_digits > 0 {\n+        // at this point we have more than 19 significant digits, let's try again\n+        many_digits = true;\n+        mantissa = 0;\n+        let mut s = digits_start;\n+        try_parse_19digits(&mut s, &mut mantissa);\n+        exponent = if mantissa >= MIN_19DIGIT_INT {\n+            // big int\n+            int_end.offset_from(&s)\n+        } else {\n+            // SAFETY: the next byte must be present and be '.'\n+            // We know this is true because we had more than 19\n+            // digits previously, so we overflowed a 64-bit integer,\n+            // but parsing only the integral digits produced less\n+            // than 19 digits. That means we must have a decimal\n+            // point, and at least 1 fractional digit.\n+            unsafe { s.step() };\n+            let before = s;\n+            try_parse_19digits(&mut s, &mut mantissa);\n+            -s.offset_from(&before)\n+        } as i64;\n+        // add back the explicit part\n+        exponent += exp_number;\n+    }\n \n-/// Carves off decimal digits up to the first non-digit character.\n-fn eat_digits(s: &[u8]) -> (&[u8], &[u8]) {\n-    let pos = s.iter().position(|c| !c.is_ascii_digit()).unwrap_or(s.len());\n-    s.split_at(pos)\n+    Some((Number { exponent, mantissa, negative, many_digits }, len))\n }\n \n-/// Exponent extraction and error checking.\n-fn parse_exp<'a>(integral: &'a [u8], fractional: &'a [u8], rest: &'a [u8]) -> ParseResult<'a> {\n-    let (sign, rest) = match rest.first() {\n-        Some(&b'-') => (Sign::Negative, &rest[1..]),\n-        Some(&b'+') => (Sign::Positive, &rest[1..]),\n-        _ => (Sign::Positive, rest),\n-    };\n-    let (mut number, trailing) = eat_digits(rest);\n-    if !trailing.is_empty() {\n-        return Invalid; // Trailing junk after exponent\n+/// Try to parse a non-special floating point number.\n+pub fn parse_number(s: &[u8], negative: bool) -> Option<Number> {\n+    if let Some((float, rest)) = parse_partial_number(s, negative) {\n+        if rest == s.len() {\n+            return Some(float);\n+        }\n     }\n-    if number.is_empty() {\n-        return Invalid; // Empty exponent\n+    None\n+}\n+\n+/// Parse a partial representation of a special, non-finite float.\n+fn parse_partial_inf_nan<F: RawFloat>(s: &[u8]) -> Option<(F, usize)> {\n+    fn parse_inf_rest(s: &[u8]) -> usize {\n+        if s.len() >= 8 && s[3..].as_ref().eq_ignore_case(b\"inity\") { 8 } else { 3 }\n     }\n-    // At this point, we certainly have a valid string of digits. It may be too long to put into\n-    // an `i64`, but if it's that huge, the input is certainly zero or infinity. Since each zero\n-    // in the decimal digits only adjusts the exponent by +/- 1, at exp = 10^18 the input would\n-    // have to be 17 exabyte (!) of zeros to get even remotely close to being finite.\n-    // This is not exactly a use case we need to cater to.\n-    while number.first() == Some(&b'0') {\n-        number = &number[1..];\n+    if s.len() >= 3 {\n+        if s.eq_ignore_case(b\"nan\") {\n+            return Some((F::NAN, 3));\n+        } else if s.eq_ignore_case(b\"inf\") {\n+            return Some((F::INFINITY, parse_inf_rest(s)));\n+        }\n     }\n-    if number.len() >= 18 {\n-        return match sign {\n-            Sign::Positive => ShortcutToInf,\n-            Sign::Negative => ShortcutToZero,\n-        };\n+    None\n+}\n+\n+/// Try to parse a special, non-finite float.\n+pub fn parse_inf_nan<F: RawFloat>(s: &[u8], negative: bool) -> Option<F> {\n+    if let Some((mut float, rest)) = parse_partial_inf_nan::<F>(s) {\n+        if rest == s.len() {\n+            if negative {\n+                float = -float;\n+            }\n+            return Some(float);\n+        }\n     }\n-    let abs_exp = num::from_str_unchecked(number);\n-    let e = match sign {\n-        Sign::Positive => abs_exp as i64,\n-        Sign::Negative => -(abs_exp as i64),\n-    };\n-    Valid(Decimal::new(integral, fractional, e))\n+    None\n }"}, {"sha": "0ab15b23e5337214cc6d295ef68ac1435d33c041", "filename": "library/core/src/num/dec2flt/rawfp.rs", "status": "removed", "additions": 0, "deletions": 363, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/d2b04f075c0ce010758c4c8674152ff89d1d73f3/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b04f075c0ce010758c4c8674152ff89d1d73f3/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Frawfp.rs?ref=d2b04f075c0ce010758c4c8674152ff89d1d73f3", "patch": "@@ -1,363 +0,0 @@\n-//! Bit fiddling on positive IEEE 754 floats. Negative numbers aren't and needn't be handled.\n-//! Normal floating point numbers have a canonical representation as (frac, exp) such that the\n-//! value is 2<sup>exp</sup> * (1 + sum(frac[N-i] / 2<sup>i</sup>)) where N is the number of bits.\n-//! Subnormals are slightly different and weird, but the same principle applies.\n-//!\n-//! Here, however, we represent them as (sig, k) with f positive, such that the value is f *\n-//! 2<sup>e</sup>. Besides making the \"hidden bit\" explicit, this changes the exponent by the\n-//! so-called mantissa shift.\n-//!\n-//! Put another way, normally floats are written as (1) but here they are written as (2):\n-//!\n-//! 1. `1.101100...11 * 2^m`\n-//! 2. `1101100...11 * 2^n`\n-//!\n-//! We call (1) the **fractional representation** and (2) the **integral representation**.\n-//!\n-//! Many functions in this module only handle normal numbers. The dec2flt routines conservatively\n-//! take the universally-correct slow path (Algorithm M) for very small and very large numbers.\n-//! That algorithm needs only next_float() which does handle subnormals and zeros.\n-use crate::cmp::Ordering::{Equal, Greater, Less};\n-use crate::convert::{TryFrom, TryInto};\n-use crate::fmt::{Debug, LowerExp};\n-use crate::num::dec2flt::num::{self, Big};\n-use crate::num::dec2flt::table;\n-use crate::num::diy_float::Fp;\n-use crate::num::FpCategory;\n-use crate::num::FpCategory::{Infinite, Nan, Normal, Subnormal, Zero};\n-use crate::ops::{Add, Div, Mul, Neg};\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct Unpacked {\n-    pub sig: u64,\n-    pub k: i16,\n-}\n-\n-impl Unpacked {\n-    pub fn new(sig: u64, k: i16) -> Self {\n-        Unpacked { sig, k }\n-    }\n-}\n-\n-/// A helper trait to avoid duplicating basically all the conversion code for `f32` and `f64`.\n-///\n-/// See the parent module's doc comment for why this is necessary.\n-///\n-/// Should **never ever** be implemented for other types or be used outside the dec2flt module.\n-pub trait RawFloat:\n-    Copy + Debug + LowerExp + Mul<Output = Self> + Div<Output = Self> + Neg<Output = Self>\n-{\n-    const INFINITY: Self;\n-    const NAN: Self;\n-    const ZERO: Self;\n-\n-    /// Type used by `to_bits` and `from_bits`.\n-    type Bits: Add<Output = Self::Bits> + From<u8> + TryFrom<u64>;\n-\n-    /// Performs a raw transmutation to an integer.\n-    fn to_bits(self) -> Self::Bits;\n-\n-    /// Performs a raw transmutation from an integer.\n-    fn from_bits(v: Self::Bits) -> Self;\n-\n-    /// Returns the category that this number falls into.\n-    fn classify(self) -> FpCategory;\n-\n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(self) -> (u64, i16, i8);\n-\n-    /// Decodes the float.\n-    fn unpack(self) -> Unpacked;\n-\n-    /// Casts from a small integer that can be represented exactly. Panic if the integer can't be\n-    /// represented, the other code in this module makes sure to never let that happen.\n-    fn from_int(x: u64) -> Self;\n-\n-    /// Gets the value 10<sup>e</sup> from a pre-computed table.\n-    /// Panics for `e >= CEIL_LOG5_OF_MAX_SIG`.\n-    fn short_fast_pow10(e: usize) -> Self;\n-\n-    /// What the name says. It's easier to hard code than juggling intrinsics and\n-    /// hoping LLVM constant folds it.\n-    const CEIL_LOG5_OF_MAX_SIG: i16;\n-\n-    // A conservative bound on the decimal digits of inputs that can't produce overflow or zero or\n-    /// subnormals. Probably the decimal exponent of the maximum normal value, hence the name.\n-    const MAX_NORMAL_DIGITS: usize;\n-\n-    /// When the most significant decimal digit has a place value greater than this, the number\n-    /// is certainly rounded to infinity.\n-    const INF_CUTOFF: i64;\n-\n-    /// When the most significant decimal digit has a place value less than this, the number\n-    /// is certainly rounded to zero.\n-    const ZERO_CUTOFF: i64;\n-\n-    /// The number of bits in the exponent.\n-    const EXP_BITS: u8;\n-\n-    /// The number of bits in the significand, *including* the hidden bit.\n-    const SIG_BITS: u8;\n-\n-    /// The number of bits in the significand, *excluding* the hidden bit.\n-    const EXPLICIT_SIG_BITS: u8;\n-\n-    /// The maximum legal exponent in fractional representation.\n-    const MAX_EXP: i16;\n-\n-    /// The minimum legal exponent in fractional representation, excluding subnormals.\n-    const MIN_EXP: i16;\n-\n-    /// `MAX_EXP` for integral representation, i.e., with the shift applied.\n-    const MAX_EXP_INT: i16;\n-\n-    /// `MAX_EXP` encoded (i.e., with offset bias)\n-    const MAX_ENCODED_EXP: i16;\n-\n-    /// `MIN_EXP` for integral representation, i.e., with the shift applied.\n-    const MIN_EXP_INT: i16;\n-\n-    /// The maximum normalized significand in integral representation.\n-    const MAX_SIG: u64;\n-\n-    /// The minimal normalized significand in integral representation.\n-    const MIN_SIG: u64;\n-}\n-\n-// Mostly a workaround for #34344.\n-macro_rules! other_constants {\n-    ($type: ident) => {\n-        const EXPLICIT_SIG_BITS: u8 = Self::SIG_BITS - 1;\n-        const MAX_EXP: i16 = (1 << (Self::EXP_BITS - 1)) - 1;\n-        const MIN_EXP: i16 = -<Self as RawFloat>::MAX_EXP + 1;\n-        const MAX_EXP_INT: i16 = <Self as RawFloat>::MAX_EXP - (Self::SIG_BITS as i16 - 1);\n-        const MAX_ENCODED_EXP: i16 = (1 << Self::EXP_BITS) - 1;\n-        const MIN_EXP_INT: i16 = <Self as RawFloat>::MIN_EXP - (Self::SIG_BITS as i16 - 1);\n-        const MAX_SIG: u64 = (1 << Self::SIG_BITS) - 1;\n-        const MIN_SIG: u64 = 1 << (Self::SIG_BITS - 1);\n-\n-        const INFINITY: Self = $type::INFINITY;\n-        const NAN: Self = $type::NAN;\n-        const ZERO: Self = 0.0;\n-    };\n-}\n-\n-impl RawFloat for f32 {\n-    type Bits = u32;\n-\n-    const SIG_BITS: u8 = 24;\n-    const EXP_BITS: u8 = 8;\n-    const CEIL_LOG5_OF_MAX_SIG: i16 = 11;\n-    const MAX_NORMAL_DIGITS: usize = 35;\n-    const INF_CUTOFF: i64 = 40;\n-    const ZERO_CUTOFF: i64 = -48;\n-    other_constants!(f32);\n-\n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits = self.to_bits();\n-        let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n-        let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n-        let mantissa =\n-            if exponent == 0 { (bits & 0x7fffff) << 1 } else { (bits & 0x7fffff) | 0x800000 };\n-        // Exponent bias + mantissa shift\n-        exponent -= 127 + 23;\n-        (mantissa as u64, exponent, sign)\n-    }\n-\n-    fn unpack(self) -> Unpacked {\n-        let (sig, exp, _sig) = self.integer_decode();\n-        Unpacked::new(sig, exp)\n-    }\n-\n-    fn from_int(x: u64) -> f32 {\n-        // rkruppe is uncertain whether `as` rounds correctly on all platforms.\n-        debug_assert!(x as f32 == fp_to_float(Fp { f: x, e: 0 }));\n-        x as f32\n-    }\n-\n-    fn short_fast_pow10(e: usize) -> Self {\n-        table::F32_SHORT_POWERS[e]\n-    }\n-\n-    fn classify(self) -> FpCategory {\n-        self.classify()\n-    }\n-    fn to_bits(self) -> Self::Bits {\n-        self.to_bits()\n-    }\n-    fn from_bits(v: Self::Bits) -> Self {\n-        Self::from_bits(v)\n-    }\n-}\n-\n-impl RawFloat for f64 {\n-    type Bits = u64;\n-\n-    const SIG_BITS: u8 = 53;\n-    const EXP_BITS: u8 = 11;\n-    const CEIL_LOG5_OF_MAX_SIG: i16 = 23;\n-    const MAX_NORMAL_DIGITS: usize = 305;\n-    const INF_CUTOFF: i64 = 310;\n-    const ZERO_CUTOFF: i64 = -326;\n-    other_constants!(f64);\n-\n-    /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(self) -> (u64, i16, i8) {\n-        let bits = self.to_bits();\n-        let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n-        let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n-        let mantissa = if exponent == 0 {\n-            (bits & 0xfffffffffffff) << 1\n-        } else {\n-            (bits & 0xfffffffffffff) | 0x10000000000000\n-        };\n-        // Exponent bias + mantissa shift\n-        exponent -= 1023 + 52;\n-        (mantissa, exponent, sign)\n-    }\n-\n-    fn unpack(self) -> Unpacked {\n-        let (sig, exp, _sig) = self.integer_decode();\n-        Unpacked::new(sig, exp)\n-    }\n-\n-    fn from_int(x: u64) -> f64 {\n-        // rkruppe is uncertain whether `as` rounds correctly on all platforms.\n-        debug_assert!(x as f64 == fp_to_float(Fp { f: x, e: 0 }));\n-        x as f64\n-    }\n-\n-    fn short_fast_pow10(e: usize) -> Self {\n-        table::F64_SHORT_POWERS[e]\n-    }\n-\n-    fn classify(self) -> FpCategory {\n-        self.classify()\n-    }\n-    fn to_bits(self) -> Self::Bits {\n-        self.to_bits()\n-    }\n-    fn from_bits(v: Self::Bits) -> Self {\n-        Self::from_bits(v)\n-    }\n-}\n-\n-/// Converts an `Fp` to the closest machine float type.\n-/// Does not handle subnormal results.\n-pub fn fp_to_float<T: RawFloat>(x: Fp) -> T {\n-    let x = x.normalize();\n-    // x.f is 64 bit, so x.e has a mantissa shift of 63\n-    let e = x.e + 63;\n-    if e > T::MAX_EXP {\n-        panic!(\"fp_to_float: exponent {} too large\", e)\n-    } else if e > T::MIN_EXP {\n-        encode_normal(round_normal::<T>(x))\n-    } else {\n-        panic!(\"fp_to_float: exponent {} too small\", e)\n-    }\n-}\n-\n-/// Round the 64-bit significand to T::SIG_BITS bits with half-to-even.\n-/// Does not handle exponent overflow.\n-pub fn round_normal<T: RawFloat>(x: Fp) -> Unpacked {\n-    let excess = 64 - T::SIG_BITS as i16;\n-    let half: u64 = 1 << (excess - 1);\n-    let (q, rem) = (x.f >> excess, x.f & ((1 << excess) - 1));\n-    assert_eq!(q << excess | rem, x.f);\n-    // Adjust mantissa shift\n-    let k = x.e + excess;\n-    if rem < half {\n-        Unpacked::new(q, k)\n-    } else if rem == half && (q % 2) == 0 {\n-        Unpacked::new(q, k)\n-    } else if q == T::MAX_SIG {\n-        Unpacked::new(T::MIN_SIG, k + 1)\n-    } else {\n-        Unpacked::new(q + 1, k)\n-    }\n-}\n-\n-/// Inverse of `RawFloat::unpack()` for normalized numbers.\n-/// Panics if the significand or exponent are not valid for normalized numbers.\n-pub fn encode_normal<T: RawFloat>(x: Unpacked) -> T {\n-    debug_assert!(\n-        T::MIN_SIG <= x.sig && x.sig <= T::MAX_SIG,\n-        \"encode_normal: significand not normalized\"\n-    );\n-    // Remove the hidden bit\n-    let sig_enc = x.sig & !(1 << T::EXPLICIT_SIG_BITS);\n-    // Adjust the exponent for exponent bias and mantissa shift\n-    let k_enc = x.k + T::MAX_EXP + T::EXPLICIT_SIG_BITS as i16;\n-    debug_assert!(k_enc != 0 && k_enc < T::MAX_ENCODED_EXP, \"encode_normal: exponent out of range\");\n-    // Leave sign bit at 0 (\"+\"), our numbers are all positive\n-    let bits = (k_enc as u64) << T::EXPLICIT_SIG_BITS | sig_enc;\n-    T::from_bits(bits.try_into().unwrap_or_else(|_| unreachable!()))\n-}\n-\n-/// Construct a subnormal. A mantissa of 0 is allowed and constructs zero.\n-pub fn encode_subnormal<T: RawFloat>(significand: u64) -> T {\n-    assert!(significand < T::MIN_SIG, \"encode_subnormal: not actually subnormal\");\n-    // Encoded exponent is 0, the sign bit is 0, so we just have to reinterpret the bits.\n-    T::from_bits(significand.try_into().unwrap_or_else(|_| unreachable!()))\n-}\n-\n-/// Approximate a bignum with an Fp. Rounds within 0.5 ULP with half-to-even.\n-pub fn big_to_fp(f: &Big) -> Fp {\n-    let end = f.bit_length();\n-    assert!(end != 0, \"big_to_fp: unexpectedly, input is zero\");\n-    let start = end.saturating_sub(64);\n-    let leading = num::get_bits(f, start, end);\n-    // We cut off all bits prior to the index `start`, i.e., we effectively right-shift by\n-    // an amount of `start`, so this is also the exponent we need.\n-    let e = start as i16;\n-    let rounded_down = Fp { f: leading, e }.normalize();\n-    // Round (half-to-even) depending on the truncated bits.\n-    match num::compare_with_half_ulp(f, start) {\n-        Less => rounded_down,\n-        Equal if leading % 2 == 0 => rounded_down,\n-        Equal | Greater => match leading.checked_add(1) {\n-            Some(f) => Fp { f, e }.normalize(),\n-            None => Fp { f: 1 << 63, e: e + 1 },\n-        },\n-    }\n-}\n-\n-/// Finds the largest floating point number strictly smaller than the argument.\n-/// Does not handle subnormals, zero, or exponent underflow.\n-pub fn prev_float<T: RawFloat>(x: T) -> T {\n-    match x.classify() {\n-        Infinite => panic!(\"prev_float: argument is infinite\"),\n-        Nan => panic!(\"prev_float: argument is NaN\"),\n-        Subnormal => panic!(\"prev_float: argument is subnormal\"),\n-        Zero => panic!(\"prev_float: argument is zero\"),\n-        Normal => {\n-            let Unpacked { sig, k } = x.unpack();\n-            if sig == T::MIN_SIG {\n-                encode_normal(Unpacked::new(T::MAX_SIG, k - 1))\n-            } else {\n-                encode_normal(Unpacked::new(sig - 1, k))\n-            }\n-        }\n-    }\n-}\n-\n-// Find the smallest floating point number strictly larger than the argument.\n-// This operation is saturating, i.e., next_float(inf) == inf.\n-// Unlike most code in this module, this function does handle zero, subnormals, and infinities.\n-// However, like all other code here, it does not deal with NaN and negative numbers.\n-pub fn next_float<T: RawFloat>(x: T) -> T {\n-    match x.classify() {\n-        Nan => panic!(\"next_float: argument is NaN\"),\n-        Infinite => T::INFINITY,\n-        // This seems too good to be true, but it works.\n-        // 0.0 is encoded as the all-zero word. Subnormals are 0x000m...m where m is the mantissa.\n-        // In particular, the smallest subnormal is 0x0...01 and the largest is 0x000F...F.\n-        // The smallest normal number is 0x0010...0, so this corner case works as well.\n-        // If the increment overflows the mantissa, the carry bit increments the exponent as we\n-        // want, and the mantissa bits become zero. Because of the hidden bit convention, this\n-        // too is exactly what we want!\n-        // Finally, f64::MAX + 1 = 7eff...f + 1 = 7ff0...0 = f64::INFINITY.\n-        Zero | Subnormal | Normal => T::from_bits(x.to_bits() + T::Bits::from(1u8)),\n-    }\n-}"}, {"sha": "bf1044033e69eb2868eda3d03986c1e0c5ffd31f", "filename": "library/core/src/num/dec2flt/slow.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fslow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fslow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Fslow.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -0,0 +1,109 @@\n+//! Slow, fallback algorithm for cases the Eisel-Lemire algorithm cannot round.\n+\n+use crate::num::dec2flt::common::BiasedFp;\n+use crate::num::dec2flt::decimal::{parse_decimal, Decimal};\n+use crate::num::dec2flt::float::RawFloat;\n+\n+/// Parse the significant digits and biased, binary exponent of a float.\n+///\n+/// This is a fallback algorithm that uses a big-integer representation\n+/// of the float, and therefore is considerably slower than faster\n+/// approximations. However, it will always determine how to round\n+/// the significant digits to the nearest machine float, allowing\n+/// use to handle near half-way cases.\n+///\n+/// Near half-way cases are halfway between two consecutive machine floats.\n+/// For example, the float `16777217.0` has a bitwise representation of\n+/// `100000000000000000000000 1`. Rounding to a single-precision float,\n+/// the trailing `1` is truncated. Using round-nearest, tie-even, any\n+/// value above `16777217.0` must be rounded up to `16777218.0`, while\n+/// any value before or equal to `16777217.0` must be rounded down\n+/// to `16777216.0`. These near-halfway conversions therefore may require\n+/// a large number of digits to unambiguously determine how to round.\n+///\n+/// The algorithms described here are based on \"Processing Long Numbers Quickly\",\n+/// available here: <https://arxiv.org/pdf/2101.11408.pdf#section.11>.\n+pub(crate) fn parse_long_mantissa<F: RawFloat>(s: &[u8]) -> BiasedFp {\n+    const MAX_SHIFT: usize = 60;\n+    const NUM_POWERS: usize = 19;\n+    const POWERS: [u8; 19] =\n+        [0, 3, 6, 9, 13, 16, 19, 23, 26, 29, 33, 36, 39, 43, 46, 49, 53, 56, 59];\n+\n+    let get_shift = |n| {\n+        if n < NUM_POWERS { POWERS[n] as usize } else { MAX_SHIFT }\n+    };\n+\n+    let fp_zero = BiasedFp::zero_pow2(0);\n+    let fp_inf = BiasedFp::zero_pow2(F::INFINITE_POWER);\n+\n+    let mut d = parse_decimal(s);\n+\n+    // Short-circuit if the value can only be a literal 0 or infinity.\n+    if d.num_digits == 0 || d.decimal_point < -324 {\n+        return fp_zero;\n+    } else if d.decimal_point >= 310 {\n+        return fp_inf;\n+    }\n+    let mut exp2 = 0_i32;\n+    // Shift right toward (1/2 ... 1].\n+    while d.decimal_point > 0 {\n+        let n = d.decimal_point as usize;\n+        let shift = get_shift(n);\n+        d.right_shift(shift);\n+        if d.decimal_point < -Decimal::DECIMAL_POINT_RANGE {\n+            return fp_zero;\n+        }\n+        exp2 += shift as i32;\n+    }\n+    // Shift left toward (1/2 ... 1].\n+    while d.decimal_point <= 0 {\n+        let shift = if d.decimal_point == 0 {\n+            match d.digits[0] {\n+                digit if digit >= 5 => break,\n+                0 | 1 => 2,\n+                _ => 1,\n+            }\n+        } else {\n+            get_shift((-d.decimal_point) as _)\n+        };\n+        d.left_shift(shift);\n+        if d.decimal_point > Decimal::DECIMAL_POINT_RANGE {\n+            return fp_inf;\n+        }\n+        exp2 -= shift as i32;\n+    }\n+    // We are now in the range [1/2 ... 1] but the binary format uses [1 ... 2].\n+    exp2 -= 1;\n+    while (F::MINIMUM_EXPONENT + 1) > exp2 {\n+        let mut n = ((F::MINIMUM_EXPONENT + 1) - exp2) as usize;\n+        if n > MAX_SHIFT {\n+            n = MAX_SHIFT;\n+        }\n+        d.right_shift(n);\n+        exp2 += n as i32;\n+    }\n+    if (exp2 - F::MINIMUM_EXPONENT) >= F::INFINITE_POWER {\n+        return fp_inf;\n+    }\n+    // Shift the decimal to the hidden bit, and then round the value\n+    // to get the high mantissa+1 bits.\n+    d.left_shift(F::MANTISSA_EXPLICIT_BITS + 1);\n+    let mut mantissa = d.round();\n+    if mantissa >= (1_u64 << (F::MANTISSA_EXPLICIT_BITS + 1)) {\n+        // Rounding up overflowed to the carry bit, need to\n+        // shift back to the hidden bit.\n+        d.right_shift(1);\n+        exp2 += 1;\n+        mantissa = d.round();\n+        if (exp2 - F::MINIMUM_EXPONENT) >= F::INFINITE_POWER {\n+            return fp_inf;\n+        }\n+    }\n+    let mut power2 = exp2 - F::MINIMUM_EXPONENT;\n+    if mantissa < (1_u64 << F::MANTISSA_EXPLICIT_BITS) {\n+        power2 -= 1;\n+    }\n+    // Zero out all the bits above the explicit mantissa bits.\n+    mantissa &= (1_u64 << F::MANTISSA_EXPLICIT_BITS) - 1;\n+    BiasedFp { f: mantissa, e: power2 }\n+}"}, {"sha": "4856074a62bd01d0824226e28fc7341285f2d1a5", "filename": "library/core/src/num/dec2flt/table.rs", "status": "modified", "additions": 665, "deletions": 1272, "changes": 1937, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fdec2flt%2Ftable.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,1277 +1,670 @@\n-//! Tables of approximations of powers of ten.\n+//! Pre-computed tables powers-of-5 for extended-precision representations.\n+//!\n+//! These tables enable fast scaling of the significant digits\n+//! of a float to the decimal exponent, with minimal rounding\n+//! errors, in a 128 or 192-bit representation.\n+//!\n //! DO NOT MODIFY: Generated by `src/etc/dec2flt_table.py`\n \n-pub const MIN_E: i16 = -305;\n-pub const MAX_E: i16 = 305;\n+pub const SMALLEST_POWER_OF_FIVE: i32 = -342;\n+pub const LARGEST_POWER_OF_FIVE: i32 = 308;\n+pub const N_POWERS_OF_FIVE: usize = (LARGEST_POWER_OF_FIVE - SMALLEST_POWER_OF_FIVE + 1) as usize;\n \n+// Use static to avoid long compile times: Rust compiler errors\n+// can have the entire table compiled multiple times, and then\n+// emit code multiple times, even if it's stripped out in\n+// the final binary.\n #[rustfmt::skip]\n-pub static POWERS: ([u64; 611], [i16; 611]) = (\n-    [\n-        0xe0b62e2929aba83c,\n-        0x8c71dcd9ba0b4926,\n-        0xaf8e5410288e1b6f,\n-        0xdb71e91432b1a24b,\n-        0x892731ac9faf056f,\n-        0xab70fe17c79ac6ca,\n-        0xd64d3d9db981787d,\n-        0x85f0468293f0eb4e,\n-        0xa76c582338ed2622,\n-        0xd1476e2c07286faa,\n-        0x82cca4db847945ca,\n-        0xa37fce126597973d,\n-        0xcc5fc196fefd7d0c,\n-        0xff77b1fcbebcdc4f,\n-        0x9faacf3df73609b1,\n-        0xc795830d75038c1e,\n-        0xf97ae3d0d2446f25,\n-        0x9becce62836ac577,\n-        0xc2e801fb244576d5,\n-        0xf3a20279ed56d48a,\n-        0x9845418c345644d7,\n-        0xbe5691ef416bd60c,\n-        0xedec366b11c6cb8f,\n-        0x94b3a202eb1c3f39,\n-        0xb9e08a83a5e34f08,\n-        0xe858ad248f5c22ca,\n-        0x91376c36d99995be,\n-        0xb58547448ffffb2e,\n-        0xe2e69915b3fff9f9,\n-        0x8dd01fad907ffc3c,\n-        0xb1442798f49ffb4b,\n-        0xdd95317f31c7fa1d,\n-        0x8a7d3eef7f1cfc52,\n-        0xad1c8eab5ee43b67,\n-        0xd863b256369d4a41,\n-        0x873e4f75e2224e68,\n-        0xa90de3535aaae202,\n-        0xd3515c2831559a83,\n-        0x8412d9991ed58092,\n-        0xa5178fff668ae0b6,\n-        0xce5d73ff402d98e4,\n-        0x80fa687f881c7f8e,\n-        0xa139029f6a239f72,\n-        0xc987434744ac874f,\n-        0xfbe9141915d7a922,\n-        0x9d71ac8fada6c9b5,\n-        0xc4ce17b399107c23,\n-        0xf6019da07f549b2b,\n-        0x99c102844f94e0fb,\n-        0xc0314325637a193a,\n-        0xf03d93eebc589f88,\n-        0x96267c7535b763b5,\n-        0xbbb01b9283253ca3,\n-        0xea9c227723ee8bcb,\n-        0x92a1958a7675175f,\n-        0xb749faed14125d37,\n-        0xe51c79a85916f485,\n-        0x8f31cc0937ae58d3,\n-        0xb2fe3f0b8599ef08,\n-        0xdfbdcece67006ac9,\n-        0x8bd6a141006042be,\n-        0xaecc49914078536d,\n-        0xda7f5bf590966849,\n-        0x888f99797a5e012d,\n-        0xaab37fd7d8f58179,\n-        0xd5605fcdcf32e1d7,\n-        0x855c3be0a17fcd26,\n-        0xa6b34ad8c9dfc070,\n-        0xd0601d8efc57b08c,\n-        0x823c12795db6ce57,\n-        0xa2cb1717b52481ed,\n-        0xcb7ddcdda26da269,\n-        0xfe5d54150b090b03,\n-        0x9efa548d26e5a6e2,\n-        0xc6b8e9b0709f109a,\n-        0xf867241c8cc6d4c1,\n-        0x9b407691d7fc44f8,\n-        0xc21094364dfb5637,\n-        0xf294b943e17a2bc4,\n-        0x979cf3ca6cec5b5b,\n-        0xbd8430bd08277231,\n-        0xece53cec4a314ebe,\n-        0x940f4613ae5ed137,\n-        0xb913179899f68584,\n-        0xe757dd7ec07426e5,\n-        0x9096ea6f3848984f,\n-        0xb4bca50b065abe63,\n-        0xe1ebce4dc7f16dfc,\n-        0x8d3360f09cf6e4bd,\n-        0xb080392cc4349ded,\n-        0xdca04777f541c568,\n-        0x89e42caaf9491b61,\n-        0xac5d37d5b79b6239,\n-        0xd77485cb25823ac7,\n-        0x86a8d39ef77164bd,\n-        0xa8530886b54dbdec,\n-        0xd267caa862a12d67,\n-        0x8380dea93da4bc60,\n-        0xa46116538d0deb78,\n-        0xcd795be870516656,\n-        0x806bd9714632dff6,\n-        0xa086cfcd97bf97f4,\n-        0xc8a883c0fdaf7df0,\n-        0xfad2a4b13d1b5d6c,\n-        0x9cc3a6eec6311a64,\n-        0xc3f490aa77bd60fd,\n-        0xf4f1b4d515acb93c,\n-        0x991711052d8bf3c5,\n-        0xbf5cd54678eef0b7,\n-        0xef340a98172aace5,\n-        0x9580869f0e7aac0f,\n-        0xbae0a846d2195713,\n-        0xe998d258869facd7,\n-        0x91ff83775423cc06,\n-        0xb67f6455292cbf08,\n-        0xe41f3d6a7377eeca,\n-        0x8e938662882af53e,\n-        0xb23867fb2a35b28e,\n-        0xdec681f9f4c31f31,\n-        0x8b3c113c38f9f37f,\n-        0xae0b158b4738705f,\n-        0xd98ddaee19068c76,\n-        0x87f8a8d4cfa417ca,\n-        0xa9f6d30a038d1dbc,\n-        0xd47487cc8470652b,\n-        0x84c8d4dfd2c63f3b,\n-        0xa5fb0a17c777cf0a,\n-        0xcf79cc9db955c2cc,\n-        0x81ac1fe293d599c0,\n-        0xa21727db38cb0030,\n-        0xca9cf1d206fdc03c,\n-        0xfd442e4688bd304b,\n-        0x9e4a9cec15763e2f,\n-        0xc5dd44271ad3cdba,\n-        0xf7549530e188c129,\n-        0x9a94dd3e8cf578ba,\n-        0xc13a148e3032d6e8,\n-        0xf18899b1bc3f8ca2,\n-        0x96f5600f15a7b7e5,\n-        0xbcb2b812db11a5de,\n-        0xebdf661791d60f56,\n-        0x936b9fcebb25c996,\n-        0xb84687c269ef3bfb,\n-        0xe65829b3046b0afa,\n-        0x8ff71a0fe2c2e6dc,\n-        0xb3f4e093db73a093,\n-        0xe0f218b8d25088b8,\n-        0x8c974f7383725573,\n-        0xafbd2350644eead0,\n-        0xdbac6c247d62a584,\n-        0x894bc396ce5da772,\n-        0xab9eb47c81f5114f,\n-        0xd686619ba27255a3,\n-        0x8613fd0145877586,\n-        0xa798fc4196e952e7,\n-        0xd17f3b51fca3a7a1,\n-        0x82ef85133de648c5,\n-        0xa3ab66580d5fdaf6,\n-        0xcc963fee10b7d1b3,\n-        0xffbbcfe994e5c620,\n-        0x9fd561f1fd0f9bd4,\n-        0xc7caba6e7c5382c9,\n-        0xf9bd690a1b68637b,\n-        0x9c1661a651213e2d,\n-        0xc31bfa0fe5698db8,\n-        0xf3e2f893dec3f126,\n-        0x986ddb5c6b3a76b8,\n-        0xbe89523386091466,\n-        0xee2ba6c0678b597f,\n-        0x94db483840b717f0,\n-        0xba121a4650e4ddec,\n-        0xe896a0d7e51e1566,\n-        0x915e2486ef32cd60,\n-        0xb5b5ada8aaff80b8,\n-        0xe3231912d5bf60e6,\n-        0x8df5efabc5979c90,\n-        0xb1736b96b6fd83b4,\n-        0xddd0467c64bce4a1,\n-        0x8aa22c0dbef60ee4,\n-        0xad4ab7112eb3929e,\n-        0xd89d64d57a607745,\n-        0x87625f056c7c4a8b,\n-        0xa93af6c6c79b5d2e,\n-        0xd389b47879823479,\n-        0x843610cb4bf160cc,\n-        0xa54394fe1eedb8ff,\n-        0xce947a3da6a9273e,\n-        0x811ccc668829b887,\n-        0xa163ff802a3426a9,\n-        0xc9bcff6034c13053,\n-        0xfc2c3f3841f17c68,\n-        0x9d9ba7832936edc1,\n-        0xc5029163f384a931,\n-        0xf64335bcf065d37d,\n-        0x99ea0196163fa42e,\n-        0xc06481fb9bcf8d3a,\n-        0xf07da27a82c37088,\n-        0x964e858c91ba2655,\n-        0xbbe226efb628afeb,\n-        0xeadab0aba3b2dbe5,\n-        0x92c8ae6b464fc96f,\n-        0xb77ada0617e3bbcb,\n-        0xe55990879ddcaabe,\n-        0x8f57fa54c2a9eab7,\n-        0xb32df8e9f3546564,\n-        0xdff9772470297ebd,\n-        0x8bfbea76c619ef36,\n-        0xaefae51477a06b04,\n-        0xdab99e59958885c5,\n-        0x88b402f7fd75539b,\n-        0xaae103b5fcd2a882,\n-        0xd59944a37c0752a2,\n-        0x857fcae62d8493a5,\n-        0xa6dfbd9fb8e5b88f,\n-        0xd097ad07a71f26b2,\n-        0x825ecc24c8737830,\n-        0xa2f67f2dfa90563b,\n-        0xcbb41ef979346bca,\n-        0xfea126b7d78186bd,\n-        0x9f24b832e6b0f436,\n-        0xc6ede63fa05d3144,\n-        0xf8a95fcf88747d94,\n-        0x9b69dbe1b548ce7d,\n-        0xc24452da229b021c,\n-        0xf2d56790ab41c2a3,\n-        0x97c560ba6b0919a6,\n-        0xbdb6b8e905cb600f,\n-        0xed246723473e3813,\n-        0x9436c0760c86e30c,\n-        0xb94470938fa89bcf,\n-        0xe7958cb87392c2c3,\n-        0x90bd77f3483bb9ba,\n-        0xb4ecd5f01a4aa828,\n-        0xe2280b6c20dd5232,\n-        0x8d590723948a535f,\n-        0xb0af48ec79ace837,\n-        0xdcdb1b2798182245,\n-        0x8a08f0f8bf0f156b,\n-        0xac8b2d36eed2dac6,\n-        0xd7adf884aa879177,\n-        0x86ccbb52ea94baeb,\n-        0xa87fea27a539e9a5,\n-        0xd29fe4b18e88640f,\n-        0x83a3eeeef9153e89,\n-        0xa48ceaaab75a8e2b,\n-        0xcdb02555653131b6,\n-        0x808e17555f3ebf12,\n-        0xa0b19d2ab70e6ed6,\n-        0xc8de047564d20a8c,\n-        0xfb158592be068d2f,\n-        0x9ced737bb6c4183d,\n-        0xc428d05aa4751e4d,\n-        0xf53304714d9265e0,\n-        0x993fe2c6d07b7fac,\n-        0xbf8fdb78849a5f97,\n-        0xef73d256a5c0f77d,\n-        0x95a8637627989aae,\n-        0xbb127c53b17ec159,\n-        0xe9d71b689dde71b0,\n-        0x9226712162ab070e,\n-        0xb6b00d69bb55c8d1,\n-        0xe45c10c42a2b3b06,\n-        0x8eb98a7a9a5b04e3,\n-        0xb267ed1940f1c61c,\n-        0xdf01e85f912e37a3,\n-        0x8b61313bbabce2c6,\n-        0xae397d8aa96c1b78,\n-        0xd9c7dced53c72256,\n-        0x881cea14545c7575,\n-        0xaa242499697392d3,\n-        0xd4ad2dbfc3d07788,\n-        0x84ec3c97da624ab5,\n-        0xa6274bbdd0fadd62,\n-        0xcfb11ead453994ba,\n-        0x81ceb32c4b43fcf5,\n-        0xa2425ff75e14fc32,\n-        0xcad2f7f5359a3b3e,\n-        0xfd87b5f28300ca0e,\n-        0x9e74d1b791e07e48,\n-        0xc612062576589ddb,\n-        0xf79687aed3eec551,\n-        0x9abe14cd44753b53,\n-        0xc16d9a0095928a27,\n-        0xf1c90080baf72cb1,\n-        0x971da05074da7bef,\n-        0xbce5086492111aeb,\n-        0xec1e4a7db69561a5,\n-        0x9392ee8e921d5d07,\n-        0xb877aa3236a4b449,\n-        0xe69594bec44de15b,\n-        0x901d7cf73ab0acd9,\n-        0xb424dc35095cd80f,\n-        0xe12e13424bb40e13,\n-        0x8cbccc096f5088cc,\n-        0xafebff0bcb24aaff,\n-        0xdbe6fecebdedd5bf,\n-        0x89705f4136b4a597,\n-        0xabcc77118461cefd,\n-        0xd6bf94d5e57a42bc,\n-        0x8637bd05af6c69b6,\n-        0xa7c5ac471b478423,\n-        0xd1b71758e219652c,\n-        0x83126e978d4fdf3b,\n-        0xa3d70a3d70a3d70a,\n-        0xcccccccccccccccd,\n-        0x8000000000000000,\n-        0xa000000000000000,\n-        0xc800000000000000,\n-        0xfa00000000000000,\n-        0x9c40000000000000,\n-        0xc350000000000000,\n-        0xf424000000000000,\n-        0x9896800000000000,\n-        0xbebc200000000000,\n-        0xee6b280000000000,\n-        0x9502f90000000000,\n-        0xba43b74000000000,\n-        0xe8d4a51000000000,\n-        0x9184e72a00000000,\n-        0xb5e620f480000000,\n-        0xe35fa931a0000000,\n-        0x8e1bc9bf04000000,\n-        0xb1a2bc2ec5000000,\n-        0xde0b6b3a76400000,\n-        0x8ac7230489e80000,\n-        0xad78ebc5ac620000,\n-        0xd8d726b7177a8000,\n-        0x878678326eac9000,\n-        0xa968163f0a57b400,\n-        0xd3c21bcecceda100,\n-        0x84595161401484a0,\n-        0xa56fa5b99019a5c8,\n-        0xcecb8f27f4200f3a,\n-        0x813f3978f8940984,\n-        0xa18f07d736b90be5,\n-        0xc9f2c9cd04674edf,\n-        0xfc6f7c4045812296,\n-        0x9dc5ada82b70b59e,\n-        0xc5371912364ce305,\n-        0xf684df56c3e01bc7,\n-        0x9a130b963a6c115c,\n-        0xc097ce7bc90715b3,\n-        0xf0bdc21abb48db20,\n-        0x96769950b50d88f4,\n-        0xbc143fa4e250eb31,\n-        0xeb194f8e1ae525fd,\n-        0x92efd1b8d0cf37be,\n-        0xb7abc627050305ae,\n-        0xe596b7b0c643c719,\n-        0x8f7e32ce7bea5c70,\n-        0xb35dbf821ae4f38c,\n-        0xe0352f62a19e306f,\n-        0x8c213d9da502de45,\n-        0xaf298d050e4395d7,\n-        0xdaf3f04651d47b4c,\n-        0x88d8762bf324cd10,\n-        0xab0e93b6efee0054,\n-        0xd5d238a4abe98068,\n-        0x85a36366eb71f041,\n-        0xa70c3c40a64e6c52,\n-        0xd0cf4b50cfe20766,\n-        0x82818f1281ed44a0,\n-        0xa321f2d7226895c8,\n-        0xcbea6f8ceb02bb3a,\n-        0xfee50b7025c36a08,\n-        0x9f4f2726179a2245,\n-        0xc722f0ef9d80aad6,\n-        0xf8ebad2b84e0d58c,\n-        0x9b934c3b330c8577,\n-        0xc2781f49ffcfa6d5,\n-        0xf316271c7fc3908b,\n-        0x97edd871cfda3a57,\n-        0xbde94e8e43d0c8ec,\n-        0xed63a231d4c4fb27,\n-        0x945e455f24fb1cf9,\n-        0xb975d6b6ee39e437,\n-        0xe7d34c64a9c85d44,\n-        0x90e40fbeea1d3a4b,\n-        0xb51d13aea4a488dd,\n-        0xe264589a4dcdab15,\n-        0x8d7eb76070a08aed,\n-        0xb0de65388cc8ada8,\n-        0xdd15fe86affad912,\n-        0x8a2dbf142dfcc7ab,\n-        0xacb92ed9397bf996,\n-        0xd7e77a8f87daf7fc,\n-        0x86f0ac99b4e8dafd,\n-        0xa8acd7c0222311bd,\n-        0xd2d80db02aabd62c,\n-        0x83c7088e1aab65db,\n-        0xa4b8cab1a1563f52,\n-        0xcde6fd5e09abcf27,\n-        0x80b05e5ac60b6178,\n-        0xa0dc75f1778e39d6,\n-        0xc913936dd571c84c,\n-        0xfb5878494ace3a5f,\n-        0x9d174b2dcec0e47b,\n-        0xc45d1df942711d9a,\n-        0xf5746577930d6501,\n-        0x9968bf6abbe85f20,\n-        0xbfc2ef456ae276e9,\n-        0xefb3ab16c59b14a3,\n-        0x95d04aee3b80ece6,\n-        0xbb445da9ca61281f,\n-        0xea1575143cf97227,\n-        0x924d692ca61be758,\n-        0xb6e0c377cfa2e12e,\n-        0xe498f455c38b997a,\n-        0x8edf98b59a373fec,\n-        0xb2977ee300c50fe7,\n-        0xdf3d5e9bc0f653e1,\n-        0x8b865b215899f46d,\n-        0xae67f1e9aec07188,\n-        0xda01ee641a708dea,\n-        0x884134fe908658b2,\n-        0xaa51823e34a7eedf,\n-        0xd4e5e2cdc1d1ea96,\n-        0x850fadc09923329e,\n-        0xa6539930bf6bff46,\n-        0xcfe87f7cef46ff17,\n-        0x81f14fae158c5f6e,\n-        0xa26da3999aef774a,\n-        0xcb090c8001ab551c,\n-        0xfdcb4fa002162a63,\n-        0x9e9f11c4014dda7e,\n-        0xc646d63501a1511e,\n-        0xf7d88bc24209a565,\n-        0x9ae757596946075f,\n-        0xc1a12d2fc3978937,\n-        0xf209787bb47d6b85,\n-        0x9745eb4d50ce6333,\n-        0xbd176620a501fc00,\n-        0xec5d3fa8ce427b00,\n-        0x93ba47c980e98ce0,\n-        0xb8a8d9bbe123f018,\n-        0xe6d3102ad96cec1e,\n-        0x9043ea1ac7e41393,\n-        0xb454e4a179dd1877,\n-        0xe16a1dc9d8545e95,\n-        0x8ce2529e2734bb1d,\n-        0xb01ae745b101e9e4,\n-        0xdc21a1171d42645d,\n-        0x899504ae72497eba,\n-        0xabfa45da0edbde69,\n-        0xd6f8d7509292d603,\n-        0x865b86925b9bc5c2,\n-        0xa7f26836f282b733,\n-        0xd1ef0244af2364ff,\n-        0x8335616aed761f1f,\n-        0xa402b9c5a8d3a6e7,\n-        0xcd036837130890a1,\n-        0x802221226be55a65,\n-        0xa02aa96b06deb0fe,\n-        0xc83553c5c8965d3d,\n-        0xfa42a8b73abbf48d,\n-        0x9c69a97284b578d8,\n-        0xc38413cf25e2d70e,\n-        0xf46518c2ef5b8cd1,\n-        0x98bf2f79d5993803,\n-        0xbeeefb584aff8604,\n-        0xeeaaba2e5dbf6785,\n-        0x952ab45cfa97a0b3,\n-        0xba756174393d88e0,\n-        0xe912b9d1478ceb17,\n-        0x91abb422ccb812ef,\n-        0xb616a12b7fe617aa,\n-        0xe39c49765fdf9d95,\n-        0x8e41ade9fbebc27d,\n-        0xb1d219647ae6b31c,\n-        0xde469fbd99a05fe3,\n-        0x8aec23d680043bee,\n-        0xada72ccc20054aea,\n-        0xd910f7ff28069da4,\n-        0x87aa9aff79042287,\n-        0xa99541bf57452b28,\n-        0xd3fa922f2d1675f2,\n-        0x847c9b5d7c2e09b7,\n-        0xa59bc234db398c25,\n-        0xcf02b2c21207ef2f,\n-        0x8161afb94b44f57d,\n-        0xa1ba1ba79e1632dc,\n-        0xca28a291859bbf93,\n-        0xfcb2cb35e702af78,\n-        0x9defbf01b061adab,\n-        0xc56baec21c7a1916,\n-        0xf6c69a72a3989f5c,\n-        0x9a3c2087a63f6399,\n-        0xc0cb28a98fcf3c80,\n-        0xf0fdf2d3f3c30b9f,\n-        0x969eb7c47859e744,\n-        0xbc4665b596706115,\n-        0xeb57ff22fc0c795a,\n-        0x9316ff75dd87cbd8,\n-        0xb7dcbf5354e9bece,\n-        0xe5d3ef282a242e82,\n-        0x8fa475791a569d11,\n-        0xb38d92d760ec4455,\n-        0xe070f78d3927556b,\n-        0x8c469ab843b89563,\n-        0xaf58416654a6babb,\n-        0xdb2e51bfe9d0696a,\n-        0x88fcf317f22241e2,\n-        0xab3c2fddeeaad25b,\n-        0xd60b3bd56a5586f2,\n-        0x85c7056562757457,\n-        0xa738c6bebb12d16d,\n-        0xd106f86e69d785c8,\n-        0x82a45b450226b39d,\n-        0xa34d721642b06084,\n-        0xcc20ce9bd35c78a5,\n-        0xff290242c83396ce,\n-        0x9f79a169bd203e41,\n-        0xc75809c42c684dd1,\n-        0xf92e0c3537826146,\n-        0x9bbcc7a142b17ccc,\n-        0xc2abf989935ddbfe,\n-        0xf356f7ebf83552fe,\n-        0x98165af37b2153df,\n-        0xbe1bf1b059e9a8d6,\n-        0xeda2ee1c7064130c,\n-        0x9485d4d1c63e8be8,\n-        0xb9a74a0637ce2ee1,\n-        0xe8111c87c5c1ba9a,\n-        0x910ab1d4db9914a0,\n-        0xb54d5e4a127f59c8,\n-        0xe2a0b5dc971f303a,\n-        0x8da471a9de737e24,\n-        0xb10d8e1456105dad,\n-        0xdd50f1996b947519,\n-        0x8a5296ffe33cc930,\n-        0xace73cbfdc0bfb7b,\n-        0xd8210befd30efa5a,\n-        0x8714a775e3e95c78,\n-        0xa8d9d1535ce3b396,\n-        0xd31045a8341ca07c,\n-        0x83ea2b892091e44e,\n-        0xa4e4b66b68b65d61,\n-        0xce1de40642e3f4b9,\n-        0x80d2ae83e9ce78f4,\n-        0xa1075a24e4421731,\n-        0xc94930ae1d529cfd,\n-        0xfb9b7cd9a4a7443c,\n-        0x9d412e0806e88aa6,\n-        0xc491798a08a2ad4f,\n-        0xf5b5d7ec8acb58a3,\n-        0x9991a6f3d6bf1766,\n-        0xbff610b0cc6edd3f,\n-        0xeff394dcff8a948f,\n-        0x95f83d0a1fb69cd9,\n-        0xbb764c4ca7a44410,\n-        0xea53df5fd18d5514,\n-        0x92746b9be2f8552c,\n-        0xb7118682dbb66a77,\n-        0xe4d5e82392a40515,\n-        0x8f05b1163ba6832d,\n-        0xb2c71d5bca9023f8,\n-        0xdf78e4b2bd342cf7,\n-        0x8bab8eefb6409c1a,\n-        0xae9672aba3d0c321,\n-        0xda3c0f568cc4f3e9,\n-        0x8865899617fb1871,\n-        0xaa7eebfb9df9de8e,\n-        0xd51ea6fa85785631,\n-        0x8533285c936b35df,\n-        0xa67ff273b8460357,\n-        0xd01fef10a657842c,\n-        0x8213f56a67f6b29c,\n-        0xa298f2c501f45f43,\n-        0xcb3f2f7642717713,\n-        0xfe0efb53d30dd4d8,\n-        0x9ec95d1463e8a507,\n-        0xc67bb4597ce2ce49,\n-        0xf81aa16fdc1b81db,\n-        0x9b10a4e5e9913129,\n-        0xc1d4ce1f63f57d73,\n-        0xf24a01a73cf2dcd0,\n-        0x976e41088617ca02,\n-        0xbd49d14aa79dbc82,\n-        0xec9c459d51852ba3,\n-        0x93e1ab8252f33b46,\n-        0xb8da1662e7b00a17,\n-        0xe7109bfba19c0c9d,\n-        0x906a617d450187e2,\n-        0xb484f9dc9641e9db,\n-        0xe1a63853bbd26451,\n-        0x8d07e33455637eb3,\n-        0xb049dc016abc5e60,\n-        0xdc5c5301c56b75f7,\n-        0x89b9b3e11b6329bb,\n-        0xac2820d9623bf429,\n-        0xd732290fbacaf134,\n-        0x867f59a9d4bed6c0,\n-        0xa81f301449ee8c70,\n-        0xd226fc195c6a2f8c,\n-        0x83585d8fd9c25db8,\n-        0xa42e74f3d032f526,\n-        0xcd3a1230c43fb26f,\n-        0x80444b5e7aa7cf85,\n-        0xa0555e361951c367,\n-        0xc86ab5c39fa63441,\n-        0xfa856334878fc151,\n-        0x9c935e00d4b9d8d2,\n-        0xc3b8358109e84f07,\n-        0xf4a642e14c6262c9,\n-        0x98e7e9cccfbd7dbe,\n-        0xbf21e44003acdd2d,\n-        0xeeea5d5004981478,\n-        0x95527a5202df0ccb,\n-        0xbaa718e68396cffe,\n-        0xe950df20247c83fd,\n-        0x91d28b7416cdd27e,\n-    ],\n-    [\n-        -1077,\n-        -1073,\n-        -1070,\n-        -1067,\n-        -1063,\n-        -1060,\n-        -1057,\n-        -1053,\n-        -1050,\n-        -1047,\n-        -1043,\n-        -1040,\n-        -1037,\n-        -1034,\n-        -1030,\n-        -1027,\n-        -1024,\n-        -1020,\n-        -1017,\n-        -1014,\n-        -1010,\n-        -1007,\n-        -1004,\n-        -1000,\n-        -997,\n-        -994,\n-        -990,\n-        -987,\n-        -984,\n-        -980,\n-        -977,\n-        -974,\n-        -970,\n-        -967,\n-        -964,\n-        -960,\n-        -957,\n-        -954,\n-        -950,\n-        -947,\n-        -944,\n-        -940,\n-        -937,\n-        -934,\n-        -931,\n-        -927,\n-        -924,\n-        -921,\n-        -917,\n-        -914,\n-        -911,\n-        -907,\n-        -904,\n-        -901,\n-        -897,\n-        -894,\n-        -891,\n-        -887,\n-        -884,\n-        -881,\n-        -877,\n-        -874,\n-        -871,\n-        -867,\n-        -864,\n-        -861,\n-        -857,\n-        -854,\n-        -851,\n-        -847,\n-        -844,\n-        -841,\n-        -838,\n-        -834,\n-        -831,\n-        -828,\n-        -824,\n-        -821,\n-        -818,\n-        -814,\n-        -811,\n-        -808,\n-        -804,\n-        -801,\n-        -798,\n-        -794,\n-        -791,\n-        -788,\n-        -784,\n-        -781,\n-        -778,\n-        -774,\n-        -771,\n-        -768,\n-        -764,\n-        -761,\n-        -758,\n-        -754,\n-        -751,\n-        -748,\n-        -744,\n-        -741,\n-        -738,\n-        -735,\n-        -731,\n-        -728,\n-        -725,\n-        -721,\n-        -718,\n-        -715,\n-        -711,\n-        -708,\n-        -705,\n-        -701,\n-        -698,\n-        -695,\n-        -691,\n-        -688,\n-        -685,\n-        -681,\n-        -678,\n-        -675,\n-        -671,\n-        -668,\n-        -665,\n-        -661,\n-        -658,\n-        -655,\n-        -651,\n-        -648,\n-        -645,\n-        -642,\n-        -638,\n-        -635,\n-        -632,\n-        -628,\n-        -625,\n-        -622,\n-        -618,\n-        -615,\n-        -612,\n-        -608,\n-        -605,\n-        -602,\n-        -598,\n-        -595,\n-        -592,\n-        -588,\n-        -585,\n-        -582,\n-        -578,\n-        -575,\n-        -572,\n-        -568,\n-        -565,\n-        -562,\n-        -558,\n-        -555,\n-        -552,\n-        -549,\n-        -545,\n-        -542,\n-        -539,\n-        -535,\n-        -532,\n-        -529,\n-        -525,\n-        -522,\n-        -519,\n-        -515,\n-        -512,\n-        -509,\n-        -505,\n-        -502,\n-        -499,\n-        -495,\n-        -492,\n-        -489,\n-        -485,\n-        -482,\n-        -479,\n-        -475,\n-        -472,\n-        -469,\n-        -465,\n-        -462,\n-        -459,\n-        -455,\n-        -452,\n-        -449,\n-        -446,\n-        -442,\n-        -439,\n-        -436,\n-        -432,\n-        -429,\n-        -426,\n-        -422,\n-        -419,\n-        -416,\n-        -412,\n-        -409,\n-        -406,\n-        -402,\n-        -399,\n-        -396,\n-        -392,\n-        -389,\n-        -386,\n-        -382,\n-        -379,\n-        -376,\n-        -372,\n-        -369,\n-        -366,\n-        -362,\n-        -359,\n-        -356,\n-        -353,\n-        -349,\n-        -346,\n-        -343,\n-        -339,\n-        -336,\n-        -333,\n-        -329,\n-        -326,\n-        -323,\n-        -319,\n-        -316,\n-        -313,\n-        -309,\n-        -306,\n-        -303,\n-        -299,\n-        -296,\n-        -293,\n-        -289,\n-        -286,\n-        -283,\n-        -279,\n-        -276,\n-        -273,\n-        -269,\n-        -266,\n-        -263,\n-        -259,\n-        -256,\n-        -253,\n-        -250,\n-        -246,\n-        -243,\n-        -240,\n-        -236,\n-        -233,\n-        -230,\n-        -226,\n-        -223,\n-        -220,\n-        -216,\n-        -213,\n-        -210,\n-        -206,\n-        -203,\n-        -200,\n-        -196,\n-        -193,\n-        -190,\n-        -186,\n-        -183,\n-        -180,\n-        -176,\n-        -173,\n-        -170,\n-        -166,\n-        -163,\n-        -160,\n-        -157,\n-        -153,\n-        -150,\n-        -147,\n-        -143,\n-        -140,\n-        -137,\n-        -133,\n-        -130,\n-        -127,\n-        -123,\n-        -120,\n-        -117,\n-        -113,\n-        -110,\n-        -107,\n-        -103,\n-        -100,\n-        -97,\n-        -93,\n-        -90,\n-        -87,\n-        -83,\n-        -80,\n-        -77,\n-        -73,\n-        -70,\n-        -67,\n-        -63,\n-        -60,\n-        -57,\n-        -54,\n-        -50,\n-        -47,\n-        -44,\n-        -40,\n-        -37,\n-        -34,\n-        -30,\n-        -27,\n-        -24,\n-        -20,\n-        -17,\n-        -14,\n-        -10,\n-        -7,\n-        -4,\n-        0,\n-        3,\n-        6,\n-        10,\n-        13,\n-        16,\n-        20,\n-        23,\n-        26,\n-        30,\n-        33,\n-        36,\n-        39,\n-        43,\n-        46,\n-        49,\n-        53,\n-        56,\n-        59,\n-        63,\n-        66,\n-        69,\n-        73,\n-        76,\n-        79,\n-        83,\n-        86,\n-        89,\n-        93,\n-        96,\n-        99,\n-        103,\n-        106,\n-        109,\n-        113,\n-        116,\n-        119,\n-        123,\n-        126,\n-        129,\n-        132,\n-        136,\n-        139,\n-        142,\n-        146,\n-        149,\n-        152,\n-        156,\n-        159,\n-        162,\n-        166,\n-        169,\n-        172,\n-        176,\n-        179,\n-        182,\n-        186,\n-        189,\n-        192,\n-        196,\n-        199,\n-        202,\n-        206,\n-        209,\n-        212,\n-        216,\n-        219,\n-        222,\n-        226,\n-        229,\n-        232,\n-        235,\n-        239,\n-        242,\n-        245,\n-        249,\n-        252,\n-        255,\n-        259,\n-        262,\n-        265,\n-        269,\n-        272,\n-        275,\n-        279,\n-        282,\n-        285,\n-        289,\n-        292,\n-        295,\n-        299,\n-        302,\n-        305,\n-        309,\n-        312,\n-        315,\n-        319,\n-        322,\n-        325,\n-        328,\n-        332,\n-        335,\n-        338,\n-        342,\n-        345,\n-        348,\n-        352,\n-        355,\n-        358,\n-        362,\n-        365,\n-        368,\n-        372,\n-        375,\n-        378,\n-        382,\n-        385,\n-        388,\n-        392,\n-        395,\n-        398,\n-        402,\n-        405,\n-        408,\n-        412,\n-        415,\n-        418,\n-        422,\n-        425,\n-        428,\n-        431,\n-        435,\n-        438,\n-        441,\n-        445,\n-        448,\n-        451,\n-        455,\n-        458,\n-        461,\n-        465,\n-        468,\n-        471,\n-        475,\n-        478,\n-        481,\n-        485,\n-        488,\n-        491,\n-        495,\n-        498,\n-        501,\n-        505,\n-        508,\n-        511,\n-        515,\n-        518,\n-        521,\n-        524,\n-        528,\n-        531,\n-        534,\n-        538,\n-        541,\n-        544,\n-        548,\n-        551,\n-        554,\n-        558,\n-        561,\n-        564,\n-        568,\n-        571,\n-        574,\n-        578,\n-        581,\n-        584,\n-        588,\n-        591,\n-        594,\n-        598,\n-        601,\n-        604,\n-        608,\n-        611,\n-        614,\n-        617,\n-        621,\n-        624,\n-        627,\n-        631,\n-        634,\n-        637,\n-        641,\n-        644,\n-        647,\n-        651,\n-        654,\n-        657,\n-        661,\n-        664,\n-        667,\n-        671,\n-        674,\n-        677,\n-        681,\n-        684,\n-        687,\n-        691,\n-        694,\n-        697,\n-        701,\n-        704,\n-        707,\n-        711,\n-        714,\n-        717,\n-        720,\n-        724,\n-        727,\n-        730,\n-        734,\n-        737,\n-        740,\n-        744,\n-        747,\n-        750,\n-        754,\n-        757,\n-        760,\n-        764,\n-        767,\n-        770,\n-        774,\n-        777,\n-        780,\n-        784,\n-        787,\n-        790,\n-        794,\n-        797,\n-        800,\n-        804,\n-        807,\n-        810,\n-        813,\n-        817,\n-        820,\n-        823,\n-        827,\n-        830,\n-        833,\n-        837,\n-        840,\n-        843,\n-        847,\n-        850,\n-        853,\n-        857,\n-        860,\n-        863,\n-        867,\n-        870,\n-        873,\n-        877,\n-        880,\n-        883,\n-        887,\n-        890,\n-        893,\n-        897,\n-        900,\n-        903,\n-        907,\n-        910,\n-        913,\n-        916,\n-        920,\n-        923,\n-        926,\n-        930,\n-        933,\n-        936,\n-        940,\n-        943,\n-        946,\n-        950,\n-    ],\n-);\n-\n-#[rustfmt::skip]\n-pub const F32_SHORT_POWERS: [f32; 11] = [\n-    1e0,\n-    1e1,\n-    1e2,\n-    1e3,\n-    1e4,\n-    1e5,\n-    1e6,\n-    1e7,\n-    1e8,\n-    1e9,\n-    1e10,\n-];\n-\n-#[rustfmt::skip]\n-pub const F64_SHORT_POWERS: [f64; 23] = [\n-    1e0,\n-    1e1,\n-    1e2,\n-    1e3,\n-    1e4,\n-    1e5,\n-    1e6,\n-    1e7,\n-    1e8,\n-    1e9,\n-    1e10,\n-    1e11,\n-    1e12,\n-    1e13,\n-    1e14,\n-    1e15,\n-    1e16,\n-    1e17,\n-    1e18,\n-    1e19,\n-    1e20,\n-    1e21,\n-    1e22,\n+pub static POWER_OF_FIVE_128: [(u64, u64); N_POWERS_OF_FIVE] = [\n+    (0xeef453d6923bd65a, 0x113faa2906a13b3f), // 5^-342\n+    (0x9558b4661b6565f8, 0x4ac7ca59a424c507), // 5^-341\n+    (0xbaaee17fa23ebf76, 0x5d79bcf00d2df649), // 5^-340\n+    (0xe95a99df8ace6f53, 0xf4d82c2c107973dc), // 5^-339\n+    (0x91d8a02bb6c10594, 0x79071b9b8a4be869), // 5^-338\n+    (0xb64ec836a47146f9, 0x9748e2826cdee284), // 5^-337\n+    (0xe3e27a444d8d98b7, 0xfd1b1b2308169b25), // 5^-336\n+    (0x8e6d8c6ab0787f72, 0xfe30f0f5e50e20f7), // 5^-335\n+    (0xb208ef855c969f4f, 0xbdbd2d335e51a935), // 5^-334\n+    (0xde8b2b66b3bc4723, 0xad2c788035e61382), // 5^-333\n+    (0x8b16fb203055ac76, 0x4c3bcb5021afcc31), // 5^-332\n+    (0xaddcb9e83c6b1793, 0xdf4abe242a1bbf3d), // 5^-331\n+    (0xd953e8624b85dd78, 0xd71d6dad34a2af0d), // 5^-330\n+    (0x87d4713d6f33aa6b, 0x8672648c40e5ad68), // 5^-329\n+    (0xa9c98d8ccb009506, 0x680efdaf511f18c2), // 5^-328\n+    (0xd43bf0effdc0ba48, 0x212bd1b2566def2),  // 5^-327\n+    (0x84a57695fe98746d, 0x14bb630f7604b57),  // 5^-326\n+    (0xa5ced43b7e3e9188, 0x419ea3bd35385e2d), // 5^-325\n+    (0xcf42894a5dce35ea, 0x52064cac828675b9), // 5^-324\n+    (0x818995ce7aa0e1b2, 0x7343efebd1940993), // 5^-323\n+    (0xa1ebfb4219491a1f, 0x1014ebe6c5f90bf8), // 5^-322\n+    (0xca66fa129f9b60a6, 0xd41a26e077774ef6), // 5^-321\n+    (0xfd00b897478238d0, 0x8920b098955522b4), // 5^-320\n+    (0x9e20735e8cb16382, 0x55b46e5f5d5535b0), // 5^-319\n+    (0xc5a890362fddbc62, 0xeb2189f734aa831d), // 5^-318\n+    (0xf712b443bbd52b7b, 0xa5e9ec7501d523e4), // 5^-317\n+    (0x9a6bb0aa55653b2d, 0x47b233c92125366e), // 5^-316\n+    (0xc1069cd4eabe89f8, 0x999ec0bb696e840a), // 5^-315\n+    (0xf148440a256e2c76, 0xc00670ea43ca250d), // 5^-314\n+    (0x96cd2a865764dbca, 0x380406926a5e5728), // 5^-313\n+    (0xbc807527ed3e12bc, 0xc605083704f5ecf2), // 5^-312\n+    (0xeba09271e88d976b, 0xf7864a44c633682e), // 5^-311\n+    (0x93445b8731587ea3, 0x7ab3ee6afbe0211d), // 5^-310\n+    (0xb8157268fdae9e4c, 0x5960ea05bad82964), // 5^-309\n+    (0xe61acf033d1a45df, 0x6fb92487298e33bd), // 5^-308\n+    (0x8fd0c16206306bab, 0xa5d3b6d479f8e056), // 5^-307\n+    (0xb3c4f1ba87bc8696, 0x8f48a4899877186c), // 5^-306\n+    (0xe0b62e2929aba83c, 0x331acdabfe94de87), // 5^-305\n+    (0x8c71dcd9ba0b4925, 0x9ff0c08b7f1d0b14), // 5^-304\n+    (0xaf8e5410288e1b6f, 0x7ecf0ae5ee44dd9),  // 5^-303\n+    (0xdb71e91432b1a24a, 0xc9e82cd9f69d6150), // 5^-302\n+    (0x892731ac9faf056e, 0xbe311c083a225cd2), // 5^-301\n+    (0xab70fe17c79ac6ca, 0x6dbd630a48aaf406), // 5^-300\n+    (0xd64d3d9db981787d, 0x92cbbccdad5b108),  // 5^-299\n+    (0x85f0468293f0eb4e, 0x25bbf56008c58ea5), // 5^-298\n+    (0xa76c582338ed2621, 0xaf2af2b80af6f24e), // 5^-297\n+    (0xd1476e2c07286faa, 0x1af5af660db4aee1), // 5^-296\n+    (0x82cca4db847945ca, 0x50d98d9fc890ed4d), // 5^-295\n+    (0xa37fce126597973c, 0xe50ff107bab528a0), // 5^-294\n+    (0xcc5fc196fefd7d0c, 0x1e53ed49a96272c8), // 5^-293\n+    (0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7a), // 5^-292\n+    (0x9faacf3df73609b1, 0x77b191618c54e9ac), // 5^-291\n+    (0xc795830d75038c1d, 0xd59df5b9ef6a2417), // 5^-290\n+    (0xf97ae3d0d2446f25, 0x4b0573286b44ad1d), // 5^-289\n+    (0x9becce62836ac577, 0x4ee367f9430aec32), // 5^-288\n+    (0xc2e801fb244576d5, 0x229c41f793cda73f), // 5^-287\n+    (0xf3a20279ed56d48a, 0x6b43527578c1110f), // 5^-286\n+    (0x9845418c345644d6, 0x830a13896b78aaa9), // 5^-285\n+    (0xbe5691ef416bd60c, 0x23cc986bc656d553), // 5^-284\n+    (0xedec366b11c6cb8f, 0x2cbfbe86b7ec8aa8), // 5^-283\n+    (0x94b3a202eb1c3f39, 0x7bf7d71432f3d6a9), // 5^-282\n+    (0xb9e08a83a5e34f07, 0xdaf5ccd93fb0cc53), // 5^-281\n+    (0xe858ad248f5c22c9, 0xd1b3400f8f9cff68), // 5^-280\n+    (0x91376c36d99995be, 0x23100809b9c21fa1), // 5^-279\n+    (0xb58547448ffffb2d, 0xabd40a0c2832a78a), // 5^-278\n+    (0xe2e69915b3fff9f9, 0x16c90c8f323f516c), // 5^-277\n+    (0x8dd01fad907ffc3b, 0xae3da7d97f6792e3), // 5^-276\n+    (0xb1442798f49ffb4a, 0x99cd11cfdf41779c), // 5^-275\n+    (0xdd95317f31c7fa1d, 0x40405643d711d583), // 5^-274\n+    (0x8a7d3eef7f1cfc52, 0x482835ea666b2572), // 5^-273\n+    (0xad1c8eab5ee43b66, 0xda3243650005eecf), // 5^-272\n+    (0xd863b256369d4a40, 0x90bed43e40076a82), // 5^-271\n+    (0x873e4f75e2224e68, 0x5a7744a6e804a291), // 5^-270\n+    (0xa90de3535aaae202, 0x711515d0a205cb36), // 5^-269\n+    (0xd3515c2831559a83, 0xd5a5b44ca873e03),  // 5^-268\n+    (0x8412d9991ed58091, 0xe858790afe9486c2), // 5^-267\n+    (0xa5178fff668ae0b6, 0x626e974dbe39a872), // 5^-266\n+    (0xce5d73ff402d98e3, 0xfb0a3d212dc8128f), // 5^-265\n+    (0x80fa687f881c7f8e, 0x7ce66634bc9d0b99), // 5^-264\n+    (0xa139029f6a239f72, 0x1c1fffc1ebc44e80), // 5^-263\n+    (0xc987434744ac874e, 0xa327ffb266b56220), // 5^-262\n+    (0xfbe9141915d7a922, 0x4bf1ff9f0062baa8), // 5^-261\n+    (0x9d71ac8fada6c9b5, 0x6f773fc3603db4a9), // 5^-260\n+    (0xc4ce17b399107c22, 0xcb550fb4384d21d3), // 5^-259\n+    (0xf6019da07f549b2b, 0x7e2a53a146606a48), // 5^-258\n+    (0x99c102844f94e0fb, 0x2eda7444cbfc426d), // 5^-257\n+    (0xc0314325637a1939, 0xfa911155fefb5308), // 5^-256\n+    (0xf03d93eebc589f88, 0x793555ab7eba27ca), // 5^-255\n+    (0x96267c7535b763b5, 0x4bc1558b2f3458de), // 5^-254\n+    (0xbbb01b9283253ca2, 0x9eb1aaedfb016f16), // 5^-253\n+    (0xea9c227723ee8bcb, 0x465e15a979c1cadc), // 5^-252\n+    (0x92a1958a7675175f, 0xbfacd89ec191ec9),  // 5^-251\n+    (0xb749faed14125d36, 0xcef980ec671f667b), // 5^-250\n+    (0xe51c79a85916f484, 0x82b7e12780e7401a), // 5^-249\n+    (0x8f31cc0937ae58d2, 0xd1b2ecb8b0908810), // 5^-248\n+    (0xb2fe3f0b8599ef07, 0x861fa7e6dcb4aa15), // 5^-247\n+    (0xdfbdcece67006ac9, 0x67a791e093e1d49a), // 5^-246\n+    (0x8bd6a141006042bd, 0xe0c8bb2c5c6d24e0), // 5^-245\n+    (0xaecc49914078536d, 0x58fae9f773886e18), // 5^-244\n+    (0xda7f5bf590966848, 0xaf39a475506a899e), // 5^-243\n+    (0x888f99797a5e012d, 0x6d8406c952429603), // 5^-242\n+    (0xaab37fd7d8f58178, 0xc8e5087ba6d33b83), // 5^-241\n+    (0xd5605fcdcf32e1d6, 0xfb1e4a9a90880a64), // 5^-240\n+    (0x855c3be0a17fcd26, 0x5cf2eea09a55067f), // 5^-239\n+    (0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481e), // 5^-238\n+    (0xd0601d8efc57b08b, 0xf13b94daf124da26), // 5^-237\n+    (0x823c12795db6ce57, 0x76c53d08d6b70858), // 5^-236\n+    (0xa2cb1717b52481ed, 0x54768c4b0c64ca6e), // 5^-235\n+    (0xcb7ddcdda26da268, 0xa9942f5dcf7dfd09), // 5^-234\n+    (0xfe5d54150b090b02, 0xd3f93b35435d7c4c), // 5^-233\n+    (0x9efa548d26e5a6e1, 0xc47bc5014a1a6daf), // 5^-232\n+    (0xc6b8e9b0709f109a, 0x359ab6419ca1091b), // 5^-231\n+    (0xf867241c8cc6d4c0, 0xc30163d203c94b62), // 5^-230\n+    (0x9b407691d7fc44f8, 0x79e0de63425dcf1d), // 5^-229\n+    (0xc21094364dfb5636, 0x985915fc12f542e4), // 5^-228\n+    (0xf294b943e17a2bc4, 0x3e6f5b7b17b2939d), // 5^-227\n+    (0x979cf3ca6cec5b5a, 0xa705992ceecf9c42), // 5^-226\n+    (0xbd8430bd08277231, 0x50c6ff782a838353), // 5^-225\n+    (0xece53cec4a314ebd, 0xa4f8bf5635246428), // 5^-224\n+    (0x940f4613ae5ed136, 0x871b7795e136be99), // 5^-223\n+    (0xb913179899f68584, 0x28e2557b59846e3f), // 5^-222\n+    (0xe757dd7ec07426e5, 0x331aeada2fe589cf), // 5^-221\n+    (0x9096ea6f3848984f, 0x3ff0d2c85def7621), // 5^-220\n+    (0xb4bca50b065abe63, 0xfed077a756b53a9),  // 5^-219\n+    (0xe1ebce4dc7f16dfb, 0xd3e8495912c62894), // 5^-218\n+    (0x8d3360f09cf6e4bd, 0x64712dd7abbbd95c), // 5^-217\n+    (0xb080392cc4349dec, 0xbd8d794d96aacfb3), // 5^-216\n+    (0xdca04777f541c567, 0xecf0d7a0fc5583a0), // 5^-215\n+    (0x89e42caaf9491b60, 0xf41686c49db57244), // 5^-214\n+    (0xac5d37d5b79b6239, 0x311c2875c522ced5), // 5^-213\n+    (0xd77485cb25823ac7, 0x7d633293366b828b), // 5^-212\n+    (0x86a8d39ef77164bc, 0xae5dff9c02033197), // 5^-211\n+    (0xa8530886b54dbdeb, 0xd9f57f830283fdfc), // 5^-210\n+    (0xd267caa862a12d66, 0xd072df63c324fd7b), // 5^-209\n+    (0x8380dea93da4bc60, 0x4247cb9e59f71e6d), // 5^-208\n+    (0xa46116538d0deb78, 0x52d9be85f074e608), // 5^-207\n+    (0xcd795be870516656, 0x67902e276c921f8b), // 5^-206\n+    (0x806bd9714632dff6, 0xba1cd8a3db53b6),   // 5^-205\n+    (0xa086cfcd97bf97f3, 0x80e8a40eccd228a4), // 5^-204\n+    (0xc8a883c0fdaf7df0, 0x6122cd128006b2cd), // 5^-203\n+    (0xfad2a4b13d1b5d6c, 0x796b805720085f81), // 5^-202\n+    (0x9cc3a6eec6311a63, 0xcbe3303674053bb0), // 5^-201\n+    (0xc3f490aa77bd60fc, 0xbedbfc4411068a9c), // 5^-200\n+    (0xf4f1b4d515acb93b, 0xee92fb5515482d44), // 5^-199\n+    (0x991711052d8bf3c5, 0x751bdd152d4d1c4a), // 5^-198\n+    (0xbf5cd54678eef0b6, 0xd262d45a78a0635d), // 5^-197\n+    (0xef340a98172aace4, 0x86fb897116c87c34), // 5^-196\n+    (0x9580869f0e7aac0e, 0xd45d35e6ae3d4da0), // 5^-195\n+    (0xbae0a846d2195712, 0x8974836059cca109), // 5^-194\n+    (0xe998d258869facd7, 0x2bd1a438703fc94b), // 5^-193\n+    (0x91ff83775423cc06, 0x7b6306a34627ddcf), // 5^-192\n+    (0xb67f6455292cbf08, 0x1a3bc84c17b1d542), // 5^-191\n+    (0xe41f3d6a7377eeca, 0x20caba5f1d9e4a93), // 5^-190\n+    (0x8e938662882af53e, 0x547eb47b7282ee9c), // 5^-189\n+    (0xb23867fb2a35b28d, 0xe99e619a4f23aa43), // 5^-188\n+    (0xdec681f9f4c31f31, 0x6405fa00e2ec94d4), // 5^-187\n+    (0x8b3c113c38f9f37e, 0xde83bc408dd3dd04), // 5^-186\n+    (0xae0b158b4738705e, 0x9624ab50b148d445), // 5^-185\n+    (0xd98ddaee19068c76, 0x3badd624dd9b0957), // 5^-184\n+    (0x87f8a8d4cfa417c9, 0xe54ca5d70a80e5d6), // 5^-183\n+    (0xa9f6d30a038d1dbc, 0x5e9fcf4ccd211f4c), // 5^-182\n+    (0xd47487cc8470652b, 0x7647c3200069671f), // 5^-181\n+    (0x84c8d4dfd2c63f3b, 0x29ecd9f40041e073), // 5^-180\n+    (0xa5fb0a17c777cf09, 0xf468107100525890), // 5^-179\n+    (0xcf79cc9db955c2cc, 0x7182148d4066eeb4), // 5^-178\n+    (0x81ac1fe293d599bf, 0xc6f14cd848405530), // 5^-177\n+    (0xa21727db38cb002f, 0xb8ada00e5a506a7c), // 5^-176\n+    (0xca9cf1d206fdc03b, 0xa6d90811f0e4851c), // 5^-175\n+    (0xfd442e4688bd304a, 0x908f4a166d1da663), // 5^-174\n+    (0x9e4a9cec15763e2e, 0x9a598e4e043287fe), // 5^-173\n+    (0xc5dd44271ad3cdba, 0x40eff1e1853f29fd), // 5^-172\n+    (0xf7549530e188c128, 0xd12bee59e68ef47c), // 5^-171\n+    (0x9a94dd3e8cf578b9, 0x82bb74f8301958ce), // 5^-170\n+    (0xc13a148e3032d6e7, 0xe36a52363c1faf01), // 5^-169\n+    (0xf18899b1bc3f8ca1, 0xdc44e6c3cb279ac1), // 5^-168\n+    (0x96f5600f15a7b7e5, 0x29ab103a5ef8c0b9), // 5^-167\n+    (0xbcb2b812db11a5de, 0x7415d448f6b6f0e7), // 5^-166\n+    (0xebdf661791d60f56, 0x111b495b3464ad21), // 5^-165\n+    (0x936b9fcebb25c995, 0xcab10dd900beec34), // 5^-164\n+    (0xb84687c269ef3bfb, 0x3d5d514f40eea742), // 5^-163\n+    (0xe65829b3046b0afa, 0xcb4a5a3112a5112),  // 5^-162\n+    (0x8ff71a0fe2c2e6dc, 0x47f0e785eaba72ab), // 5^-161\n+    (0xb3f4e093db73a093, 0x59ed216765690f56), // 5^-160\n+    (0xe0f218b8d25088b8, 0x306869c13ec3532c), // 5^-159\n+    (0x8c974f7383725573, 0x1e414218c73a13fb), // 5^-158\n+    (0xafbd2350644eeacf, 0xe5d1929ef90898fa), // 5^-157\n+    (0xdbac6c247d62a583, 0xdf45f746b74abf39), // 5^-156\n+    (0x894bc396ce5da772, 0x6b8bba8c328eb783), // 5^-155\n+    (0xab9eb47c81f5114f, 0x66ea92f3f326564),  // 5^-154\n+    (0xd686619ba27255a2, 0xc80a537b0efefebd), // 5^-153\n+    (0x8613fd0145877585, 0xbd06742ce95f5f36), // 5^-152\n+    (0xa798fc4196e952e7, 0x2c48113823b73704), // 5^-151\n+    (0xd17f3b51fca3a7a0, 0xf75a15862ca504c5), // 5^-150\n+    (0x82ef85133de648c4, 0x9a984d73dbe722fb), // 5^-149\n+    (0xa3ab66580d5fdaf5, 0xc13e60d0d2e0ebba), // 5^-148\n+    (0xcc963fee10b7d1b3, 0x318df905079926a8), // 5^-147\n+    (0xffbbcfe994e5c61f, 0xfdf17746497f7052), // 5^-146\n+    (0x9fd561f1fd0f9bd3, 0xfeb6ea8bedefa633), // 5^-145\n+    (0xc7caba6e7c5382c8, 0xfe64a52ee96b8fc0), // 5^-144\n+    (0xf9bd690a1b68637b, 0x3dfdce7aa3c673b0), // 5^-143\n+    (0x9c1661a651213e2d, 0x6bea10ca65c084e),  // 5^-142\n+    (0xc31bfa0fe5698db8, 0x486e494fcff30a62), // 5^-141\n+    (0xf3e2f893dec3f126, 0x5a89dba3c3efccfa), // 5^-140\n+    (0x986ddb5c6b3a76b7, 0xf89629465a75e01c), // 5^-139\n+    (0xbe89523386091465, 0xf6bbb397f1135823), // 5^-138\n+    (0xee2ba6c0678b597f, 0x746aa07ded582e2c), // 5^-137\n+    (0x94db483840b717ef, 0xa8c2a44eb4571cdc), // 5^-136\n+    (0xba121a4650e4ddeb, 0x92f34d62616ce413), // 5^-135\n+    (0xe896a0d7e51e1566, 0x77b020baf9c81d17), // 5^-134\n+    (0x915e2486ef32cd60, 0xace1474dc1d122e),  // 5^-133\n+    (0xb5b5ada8aaff80b8, 0xd819992132456ba),  // 5^-132\n+    (0xe3231912d5bf60e6, 0x10e1fff697ed6c69), // 5^-131\n+    (0x8df5efabc5979c8f, 0xca8d3ffa1ef463c1), // 5^-130\n+    (0xb1736b96b6fd83b3, 0xbd308ff8a6b17cb2), // 5^-129\n+    (0xddd0467c64bce4a0, 0xac7cb3f6d05ddbde), // 5^-128\n+    (0x8aa22c0dbef60ee4, 0x6bcdf07a423aa96b), // 5^-127\n+    (0xad4ab7112eb3929d, 0x86c16c98d2c953c6), // 5^-126\n+    (0xd89d64d57a607744, 0xe871c7bf077ba8b7), // 5^-125\n+    (0x87625f056c7c4a8b, 0x11471cd764ad4972), // 5^-124\n+    (0xa93af6c6c79b5d2d, 0xd598e40d3dd89bcf), // 5^-123\n+    (0xd389b47879823479, 0x4aff1d108d4ec2c3), // 5^-122\n+    (0x843610cb4bf160cb, 0xcedf722a585139ba), // 5^-121\n+    (0xa54394fe1eedb8fe, 0xc2974eb4ee658828), // 5^-120\n+    (0xce947a3da6a9273e, 0x733d226229feea32), // 5^-119\n+    (0x811ccc668829b887, 0x806357d5a3f525f),  // 5^-118\n+    (0xa163ff802a3426a8, 0xca07c2dcb0cf26f7), // 5^-117\n+    (0xc9bcff6034c13052, 0xfc89b393dd02f0b5), // 5^-116\n+    (0xfc2c3f3841f17c67, 0xbbac2078d443ace2), // 5^-115\n+    (0x9d9ba7832936edc0, 0xd54b944b84aa4c0d), // 5^-114\n+    (0xc5029163f384a931, 0xa9e795e65d4df11),  // 5^-113\n+    (0xf64335bcf065d37d, 0x4d4617b5ff4a16d5), // 5^-112\n+    (0x99ea0196163fa42e, 0x504bced1bf8e4e45), // 5^-111\n+    (0xc06481fb9bcf8d39, 0xe45ec2862f71e1d6), // 5^-110\n+    (0xf07da27a82c37088, 0x5d767327bb4e5a4c), // 5^-109\n+    (0x964e858c91ba2655, 0x3a6a07f8d510f86f), // 5^-108\n+    (0xbbe226efb628afea, 0x890489f70a55368b), // 5^-107\n+    (0xeadab0aba3b2dbe5, 0x2b45ac74ccea842e), // 5^-106\n+    (0x92c8ae6b464fc96f, 0x3b0b8bc90012929d), // 5^-105\n+    (0xb77ada0617e3bbcb, 0x9ce6ebb40173744),  // 5^-104\n+    (0xe55990879ddcaabd, 0xcc420a6a101d0515), // 5^-103\n+    (0x8f57fa54c2a9eab6, 0x9fa946824a12232d), // 5^-102\n+    (0xb32df8e9f3546564, 0x47939822dc96abf9), // 5^-101\n+    (0xdff9772470297ebd, 0x59787e2b93bc56f7), // 5^-100\n+    (0x8bfbea76c619ef36, 0x57eb4edb3c55b65a), // 5^-99\n+    (0xaefae51477a06b03, 0xede622920b6b23f1), // 5^-98\n+    (0xdab99e59958885c4, 0xe95fab368e45eced), // 5^-97\n+    (0x88b402f7fd75539b, 0x11dbcb0218ebb414), // 5^-96\n+    (0xaae103b5fcd2a881, 0xd652bdc29f26a119), // 5^-95\n+    (0xd59944a37c0752a2, 0x4be76d3346f0495f), // 5^-94\n+    (0x857fcae62d8493a5, 0x6f70a4400c562ddb), // 5^-93\n+    (0xa6dfbd9fb8e5b88e, 0xcb4ccd500f6bb952), // 5^-92\n+    (0xd097ad07a71f26b2, 0x7e2000a41346a7a7), // 5^-91\n+    (0x825ecc24c873782f, 0x8ed400668c0c28c8), // 5^-90\n+    (0xa2f67f2dfa90563b, 0x728900802f0f32fa), // 5^-89\n+    (0xcbb41ef979346bca, 0x4f2b40a03ad2ffb9), // 5^-88\n+    (0xfea126b7d78186bc, 0xe2f610c84987bfa8), // 5^-87\n+    (0x9f24b832e6b0f436, 0xdd9ca7d2df4d7c9),  // 5^-86\n+    (0xc6ede63fa05d3143, 0x91503d1c79720dbb), // 5^-85\n+    (0xf8a95fcf88747d94, 0x75a44c6397ce912a), // 5^-84\n+    (0x9b69dbe1b548ce7c, 0xc986afbe3ee11aba), // 5^-83\n+    (0xc24452da229b021b, 0xfbe85badce996168), // 5^-82\n+    (0xf2d56790ab41c2a2, 0xfae27299423fb9c3), // 5^-81\n+    (0x97c560ba6b0919a5, 0xdccd879fc967d41a), // 5^-80\n+    (0xbdb6b8e905cb600f, 0x5400e987bbc1c920), // 5^-79\n+    (0xed246723473e3813, 0x290123e9aab23b68), // 5^-78\n+    (0x9436c0760c86e30b, 0xf9a0b6720aaf6521), // 5^-77\n+    (0xb94470938fa89bce, 0xf808e40e8d5b3e69), // 5^-76\n+    (0xe7958cb87392c2c2, 0xb60b1d1230b20e04), // 5^-75\n+    (0x90bd77f3483bb9b9, 0xb1c6f22b5e6f48c2), // 5^-74\n+    (0xb4ecd5f01a4aa828, 0x1e38aeb6360b1af3), // 5^-73\n+    (0xe2280b6c20dd5232, 0x25c6da63c38de1b0), // 5^-72\n+    (0x8d590723948a535f, 0x579c487e5a38ad0e), // 5^-71\n+    (0xb0af48ec79ace837, 0x2d835a9df0c6d851), // 5^-70\n+    (0xdcdb1b2798182244, 0xf8e431456cf88e65), // 5^-69\n+    (0x8a08f0f8bf0f156b, 0x1b8e9ecb641b58ff), // 5^-68\n+    (0xac8b2d36eed2dac5, 0xe272467e3d222f3f), // 5^-67\n+    (0xd7adf884aa879177, 0x5b0ed81dcc6abb0f), // 5^-66\n+    (0x86ccbb52ea94baea, 0x98e947129fc2b4e9), // 5^-65\n+    (0xa87fea27a539e9a5, 0x3f2398d747b36224), // 5^-64\n+    (0xd29fe4b18e88640e, 0x8eec7f0d19a03aad), // 5^-63\n+    (0x83a3eeeef9153e89, 0x1953cf68300424ac), // 5^-62\n+    (0xa48ceaaab75a8e2b, 0x5fa8c3423c052dd7), // 5^-61\n+    (0xcdb02555653131b6, 0x3792f412cb06794d), // 5^-60\n+    (0x808e17555f3ebf11, 0xe2bbd88bbee40bd0), // 5^-59\n+    (0xa0b19d2ab70e6ed6, 0x5b6aceaeae9d0ec4), // 5^-58\n+    (0xc8de047564d20a8b, 0xf245825a5a445275), // 5^-57\n+    (0xfb158592be068d2e, 0xeed6e2f0f0d56712), // 5^-56\n+    (0x9ced737bb6c4183d, 0x55464dd69685606b), // 5^-55\n+    (0xc428d05aa4751e4c, 0xaa97e14c3c26b886), // 5^-54\n+    (0xf53304714d9265df, 0xd53dd99f4b3066a8), // 5^-53\n+    (0x993fe2c6d07b7fab, 0xe546a8038efe4029), // 5^-52\n+    (0xbf8fdb78849a5f96, 0xde98520472bdd033), // 5^-51\n+    (0xef73d256a5c0f77c, 0x963e66858f6d4440), // 5^-50\n+    (0x95a8637627989aad, 0xdde7001379a44aa8), // 5^-49\n+    (0xbb127c53b17ec159, 0x5560c018580d5d52), // 5^-48\n+    (0xe9d71b689dde71af, 0xaab8f01e6e10b4a6), // 5^-47\n+    (0x9226712162ab070d, 0xcab3961304ca70e8), // 5^-46\n+    (0xb6b00d69bb55c8d1, 0x3d607b97c5fd0d22), // 5^-45\n+    (0xe45c10c42a2b3b05, 0x8cb89a7db77c506a), // 5^-44\n+    (0x8eb98a7a9a5b04e3, 0x77f3608e92adb242), // 5^-43\n+    (0xb267ed1940f1c61c, 0x55f038b237591ed3), // 5^-42\n+    (0xdf01e85f912e37a3, 0x6b6c46dec52f6688), // 5^-41\n+    (0x8b61313bbabce2c6, 0x2323ac4b3b3da015), // 5^-40\n+    (0xae397d8aa96c1b77, 0xabec975e0a0d081a), // 5^-39\n+    (0xd9c7dced53c72255, 0x96e7bd358c904a21), // 5^-38\n+    (0x881cea14545c7575, 0x7e50d64177da2e54), // 5^-37\n+    (0xaa242499697392d2, 0xdde50bd1d5d0b9e9), // 5^-36\n+    (0xd4ad2dbfc3d07787, 0x955e4ec64b44e864), // 5^-35\n+    (0x84ec3c97da624ab4, 0xbd5af13bef0b113e), // 5^-34\n+    (0xa6274bbdd0fadd61, 0xecb1ad8aeacdd58e), // 5^-33\n+    (0xcfb11ead453994ba, 0x67de18eda5814af2), // 5^-32\n+    (0x81ceb32c4b43fcf4, 0x80eacf948770ced7), // 5^-31\n+    (0xa2425ff75e14fc31, 0xa1258379a94d028d), // 5^-30\n+    (0xcad2f7f5359a3b3e, 0x96ee45813a04330),  // 5^-29\n+    (0xfd87b5f28300ca0d, 0x8bca9d6e188853fc), // 5^-28\n+    (0x9e74d1b791e07e48, 0x775ea264cf55347e), // 5^-27\n+    (0xc612062576589dda, 0x95364afe032a819e), // 5^-26\n+    (0xf79687aed3eec551, 0x3a83ddbd83f52205), // 5^-25\n+    (0x9abe14cd44753b52, 0xc4926a9672793543), // 5^-24\n+    (0xc16d9a0095928a27, 0x75b7053c0f178294), // 5^-23\n+    (0xf1c90080baf72cb1, 0x5324c68b12dd6339), // 5^-22\n+    (0x971da05074da7bee, 0xd3f6fc16ebca5e04), // 5^-21\n+    (0xbce5086492111aea, 0x88f4bb1ca6bcf585), // 5^-20\n+    (0xec1e4a7db69561a5, 0x2b31e9e3d06c32e6), // 5^-19\n+    (0x9392ee8e921d5d07, 0x3aff322e62439fd0), // 5^-18\n+    (0xb877aa3236a4b449, 0x9befeb9fad487c3),  // 5^-17\n+    (0xe69594bec44de15b, 0x4c2ebe687989a9b4), // 5^-16\n+    (0x901d7cf73ab0acd9, 0xf9d37014bf60a11),  // 5^-15\n+    (0xb424dc35095cd80f, 0x538484c19ef38c95), // 5^-14\n+    (0xe12e13424bb40e13, 0x2865a5f206b06fba), // 5^-13\n+    (0x8cbccc096f5088cb, 0xf93f87b7442e45d4), // 5^-12\n+    (0xafebff0bcb24aafe, 0xf78f69a51539d749), // 5^-11\n+    (0xdbe6fecebdedd5be, 0xb573440e5a884d1c), // 5^-10\n+    (0x89705f4136b4a597, 0x31680a88f8953031), // 5^-9\n+    (0xabcc77118461cefc, 0xfdc20d2b36ba7c3e), // 5^-8\n+    (0xd6bf94d5e57a42bc, 0x3d32907604691b4d), // 5^-7\n+    (0x8637bd05af6c69b5, 0xa63f9a49c2c1b110), // 5^-6\n+    (0xa7c5ac471b478423, 0xfcf80dc33721d54),  // 5^-5\n+    (0xd1b71758e219652b, 0xd3c36113404ea4a9), // 5^-4\n+    (0x83126e978d4fdf3b, 0x645a1cac083126ea), // 5^-3\n+    (0xa3d70a3d70a3d70a, 0x3d70a3d70a3d70a4), // 5^-2\n+    (0xcccccccccccccccc, 0xcccccccccccccccd), // 5^-1\n+    (0x8000000000000000, 0x0),                // 5^0\n+    (0xa000000000000000, 0x0),                // 5^1\n+    (0xc800000000000000, 0x0),                // 5^2\n+    (0xfa00000000000000, 0x0),                // 5^3\n+    (0x9c40000000000000, 0x0),                // 5^4\n+    (0xc350000000000000, 0x0),                // 5^5\n+    (0xf424000000000000, 0x0),                // 5^6\n+    (0x9896800000000000, 0x0),                // 5^7\n+    (0xbebc200000000000, 0x0),                // 5^8\n+    (0xee6b280000000000, 0x0),                // 5^9\n+    (0x9502f90000000000, 0x0),                // 5^10\n+    (0xba43b74000000000, 0x0),                // 5^11\n+    (0xe8d4a51000000000, 0x0),                // 5^12\n+    (0x9184e72a00000000, 0x0),                // 5^13\n+    (0xb5e620f480000000, 0x0),                // 5^14\n+    (0xe35fa931a0000000, 0x0),                // 5^15\n+    (0x8e1bc9bf04000000, 0x0),                // 5^16\n+    (0xb1a2bc2ec5000000, 0x0),                // 5^17\n+    (0xde0b6b3a76400000, 0x0),                // 5^18\n+    (0x8ac7230489e80000, 0x0),                // 5^19\n+    (0xad78ebc5ac620000, 0x0),                // 5^20\n+    (0xd8d726b7177a8000, 0x0),                // 5^21\n+    (0x878678326eac9000, 0x0),                // 5^22\n+    (0xa968163f0a57b400, 0x0),                // 5^23\n+    (0xd3c21bcecceda100, 0x0),                // 5^24\n+    (0x84595161401484a0, 0x0),                // 5^25\n+    (0xa56fa5b99019a5c8, 0x0),                // 5^26\n+    (0xcecb8f27f4200f3a, 0x0),                // 5^27\n+    (0x813f3978f8940984, 0x4000000000000000), // 5^28\n+    (0xa18f07d736b90be5, 0x5000000000000000), // 5^29\n+    (0xc9f2c9cd04674ede, 0xa400000000000000), // 5^30\n+    (0xfc6f7c4045812296, 0x4d00000000000000), // 5^31\n+    (0x9dc5ada82b70b59d, 0xf020000000000000), // 5^32\n+    (0xc5371912364ce305, 0x6c28000000000000), // 5^33\n+    (0xf684df56c3e01bc6, 0xc732000000000000), // 5^34\n+    (0x9a130b963a6c115c, 0x3c7f400000000000), // 5^35\n+    (0xc097ce7bc90715b3, 0x4b9f100000000000), // 5^36\n+    (0xf0bdc21abb48db20, 0x1e86d40000000000), // 5^37\n+    (0x96769950b50d88f4, 0x1314448000000000), // 5^38\n+    (0xbc143fa4e250eb31, 0x17d955a000000000), // 5^39\n+    (0xeb194f8e1ae525fd, 0x5dcfab0800000000), // 5^40\n+    (0x92efd1b8d0cf37be, 0x5aa1cae500000000), // 5^41\n+    (0xb7abc627050305ad, 0xf14a3d9e40000000), // 5^42\n+    (0xe596b7b0c643c719, 0x6d9ccd05d0000000), // 5^43\n+    (0x8f7e32ce7bea5c6f, 0xe4820023a2000000), // 5^44\n+    (0xb35dbf821ae4f38b, 0xdda2802c8a800000), // 5^45\n+    (0xe0352f62a19e306e, 0xd50b2037ad200000), // 5^46\n+    (0x8c213d9da502de45, 0x4526f422cc340000), // 5^47\n+    (0xaf298d050e4395d6, 0x9670b12b7f410000), // 5^48\n+    (0xdaf3f04651d47b4c, 0x3c0cdd765f114000), // 5^49\n+    (0x88d8762bf324cd0f, 0xa5880a69fb6ac800), // 5^50\n+    (0xab0e93b6efee0053, 0x8eea0d047a457a00), // 5^51\n+    (0xd5d238a4abe98068, 0x72a4904598d6d880), // 5^52\n+    (0x85a36366eb71f041, 0x47a6da2b7f864750), // 5^53\n+    (0xa70c3c40a64e6c51, 0x999090b65f67d924), // 5^54\n+    (0xd0cf4b50cfe20765, 0xfff4b4e3f741cf6d), // 5^55\n+    (0x82818f1281ed449f, 0xbff8f10e7a8921a4), // 5^56\n+    (0xa321f2d7226895c7, 0xaff72d52192b6a0d), // 5^57\n+    (0xcbea6f8ceb02bb39, 0x9bf4f8a69f764490), // 5^58\n+    (0xfee50b7025c36a08, 0x2f236d04753d5b4),  // 5^59\n+    (0x9f4f2726179a2245, 0x1d762422c946590),  // 5^60\n+    (0xc722f0ef9d80aad6, 0x424d3ad2b7b97ef5), // 5^61\n+    (0xf8ebad2b84e0d58b, 0xd2e0898765a7deb2), // 5^62\n+    (0x9b934c3b330c8577, 0x63cc55f49f88eb2f), // 5^63\n+    (0xc2781f49ffcfa6d5, 0x3cbf6b71c76b25fb), // 5^64\n+    (0xf316271c7fc3908a, 0x8bef464e3945ef7a), // 5^65\n+    (0x97edd871cfda3a56, 0x97758bf0e3cbb5ac), // 5^66\n+    (0xbde94e8e43d0c8ec, 0x3d52eeed1cbea317), // 5^67\n+    (0xed63a231d4c4fb27, 0x4ca7aaa863ee4bdd), // 5^68\n+    (0x945e455f24fb1cf8, 0x8fe8caa93e74ef6a), // 5^69\n+    (0xb975d6b6ee39e436, 0xb3e2fd538e122b44), // 5^70\n+    (0xe7d34c64a9c85d44, 0x60dbbca87196b616), // 5^71\n+    (0x90e40fbeea1d3a4a, 0xbc8955e946fe31cd), // 5^72\n+    (0xb51d13aea4a488dd, 0x6babab6398bdbe41), // 5^73\n+    (0xe264589a4dcdab14, 0xc696963c7eed2dd1), // 5^74\n+    (0x8d7eb76070a08aec, 0xfc1e1de5cf543ca2), // 5^75\n+    (0xb0de65388cc8ada8, 0x3b25a55f43294bcb), // 5^76\n+    (0xdd15fe86affad912, 0x49ef0eb713f39ebe), // 5^77\n+    (0x8a2dbf142dfcc7ab, 0x6e3569326c784337), // 5^78\n+    (0xacb92ed9397bf996, 0x49c2c37f07965404), // 5^79\n+    (0xd7e77a8f87daf7fb, 0xdc33745ec97be906), // 5^80\n+    (0x86f0ac99b4e8dafd, 0x69a028bb3ded71a3), // 5^81\n+    (0xa8acd7c0222311bc, 0xc40832ea0d68ce0c), // 5^82\n+    (0xd2d80db02aabd62b, 0xf50a3fa490c30190), // 5^83\n+    (0x83c7088e1aab65db, 0x792667c6da79e0fa), // 5^84\n+    (0xa4b8cab1a1563f52, 0x577001b891185938), // 5^85\n+    (0xcde6fd5e09abcf26, 0xed4c0226b55e6f86), // 5^86\n+    (0x80b05e5ac60b6178, 0x544f8158315b05b4), // 5^87\n+    (0xa0dc75f1778e39d6, 0x696361ae3db1c721), // 5^88\n+    (0xc913936dd571c84c, 0x3bc3a19cd1e38e9),  // 5^89\n+    (0xfb5878494ace3a5f, 0x4ab48a04065c723),  // 5^90\n+    (0x9d174b2dcec0e47b, 0x62eb0d64283f9c76), // 5^91\n+    (0xc45d1df942711d9a, 0x3ba5d0bd324f8394), // 5^92\n+    (0xf5746577930d6500, 0xca8f44ec7ee36479), // 5^93\n+    (0x9968bf6abbe85f20, 0x7e998b13cf4e1ecb), // 5^94\n+    (0xbfc2ef456ae276e8, 0x9e3fedd8c321a67e), // 5^95\n+    (0xefb3ab16c59b14a2, 0xc5cfe94ef3ea101e), // 5^96\n+    (0x95d04aee3b80ece5, 0xbba1f1d158724a12), // 5^97\n+    (0xbb445da9ca61281f, 0x2a8a6e45ae8edc97), // 5^98\n+    (0xea1575143cf97226, 0xf52d09d71a3293bd), // 5^99\n+    (0x924d692ca61be758, 0x593c2626705f9c56), // 5^100\n+    (0xb6e0c377cfa2e12e, 0x6f8b2fb00c77836c), // 5^101\n+    (0xe498f455c38b997a, 0xb6dfb9c0f956447),  // 5^102\n+    (0x8edf98b59a373fec, 0x4724bd4189bd5eac), // 5^103\n+    (0xb2977ee300c50fe7, 0x58edec91ec2cb657), // 5^104\n+    (0xdf3d5e9bc0f653e1, 0x2f2967b66737e3ed), // 5^105\n+    (0x8b865b215899f46c, 0xbd79e0d20082ee74), // 5^106\n+    (0xae67f1e9aec07187, 0xecd8590680a3aa11), // 5^107\n+    (0xda01ee641a708de9, 0xe80e6f4820cc9495), // 5^108\n+    (0x884134fe908658b2, 0x3109058d147fdcdd), // 5^109\n+    (0xaa51823e34a7eede, 0xbd4b46f0599fd415), // 5^110\n+    (0xd4e5e2cdc1d1ea96, 0x6c9e18ac7007c91a), // 5^111\n+    (0x850fadc09923329e, 0x3e2cf6bc604ddb0),  // 5^112\n+    (0xa6539930bf6bff45, 0x84db8346b786151c), // 5^113\n+    (0xcfe87f7cef46ff16, 0xe612641865679a63), // 5^114\n+    (0x81f14fae158c5f6e, 0x4fcb7e8f3f60c07e), // 5^115\n+    (0xa26da3999aef7749, 0xe3be5e330f38f09d), // 5^116\n+    (0xcb090c8001ab551c, 0x5cadf5bfd3072cc5), // 5^117\n+    (0xfdcb4fa002162a63, 0x73d9732fc7c8f7f6), // 5^118\n+    (0x9e9f11c4014dda7e, 0x2867e7fddcdd9afa), // 5^119\n+    (0xc646d63501a1511d, 0xb281e1fd541501b8), // 5^120\n+    (0xf7d88bc24209a565, 0x1f225a7ca91a4226), // 5^121\n+    (0x9ae757596946075f, 0x3375788de9b06958), // 5^122\n+    (0xc1a12d2fc3978937, 0x52d6b1641c83ae),   // 5^123\n+    (0xf209787bb47d6b84, 0xc0678c5dbd23a49a), // 5^124\n+    (0x9745eb4d50ce6332, 0xf840b7ba963646e0), // 5^125\n+    (0xbd176620a501fbff, 0xb650e5a93bc3d898), // 5^126\n+    (0xec5d3fa8ce427aff, 0xa3e51f138ab4cebe), // 5^127\n+    (0x93ba47c980e98cdf, 0xc66f336c36b10137), // 5^128\n+    (0xb8a8d9bbe123f017, 0xb80b0047445d4184), // 5^129\n+    (0xe6d3102ad96cec1d, 0xa60dc059157491e5), // 5^130\n+    (0x9043ea1ac7e41392, 0x87c89837ad68db2f), // 5^131\n+    (0xb454e4a179dd1877, 0x29babe4598c311fb), // 5^132\n+    (0xe16a1dc9d8545e94, 0xf4296dd6fef3d67a), // 5^133\n+    (0x8ce2529e2734bb1d, 0x1899e4a65f58660c), // 5^134\n+    (0xb01ae745b101e9e4, 0x5ec05dcff72e7f8f), // 5^135\n+    (0xdc21a1171d42645d, 0x76707543f4fa1f73), // 5^136\n+    (0x899504ae72497eba, 0x6a06494a791c53a8), // 5^137\n+    (0xabfa45da0edbde69, 0x487db9d17636892),  // 5^138\n+    (0xd6f8d7509292d603, 0x45a9d2845d3c42b6), // 5^139\n+    (0x865b86925b9bc5c2, 0xb8a2392ba45a9b2),  // 5^140\n+    (0xa7f26836f282b732, 0x8e6cac7768d7141e), // 5^141\n+    (0xd1ef0244af2364ff, 0x3207d795430cd926), // 5^142\n+    (0x8335616aed761f1f, 0x7f44e6bd49e807b8), // 5^143\n+    (0xa402b9c5a8d3a6e7, 0x5f16206c9c6209a6), // 5^144\n+    (0xcd036837130890a1, 0x36dba887c37a8c0f), // 5^145\n+    (0x802221226be55a64, 0xc2494954da2c9789), // 5^146\n+    (0xa02aa96b06deb0fd, 0xf2db9baa10b7bd6c), // 5^147\n+    (0xc83553c5c8965d3d, 0x6f92829494e5acc7), // 5^148\n+    (0xfa42a8b73abbf48c, 0xcb772339ba1f17f9), // 5^149\n+    (0x9c69a97284b578d7, 0xff2a760414536efb), // 5^150\n+    (0xc38413cf25e2d70d, 0xfef5138519684aba), // 5^151\n+    (0xf46518c2ef5b8cd1, 0x7eb258665fc25d69), // 5^152\n+    (0x98bf2f79d5993802, 0xef2f773ffbd97a61), // 5^153\n+    (0xbeeefb584aff8603, 0xaafb550ffacfd8fa), // 5^154\n+    (0xeeaaba2e5dbf6784, 0x95ba2a53f983cf38), // 5^155\n+    (0x952ab45cfa97a0b2, 0xdd945a747bf26183), // 5^156\n+    (0xba756174393d88df, 0x94f971119aeef9e4), // 5^157\n+    (0xe912b9d1478ceb17, 0x7a37cd5601aab85d), // 5^158\n+    (0x91abb422ccb812ee, 0xac62e055c10ab33a), // 5^159\n+    (0xb616a12b7fe617aa, 0x577b986b314d6009), // 5^160\n+    (0xe39c49765fdf9d94, 0xed5a7e85fda0b80b), // 5^161\n+    (0x8e41ade9fbebc27d, 0x14588f13be847307), // 5^162\n+    (0xb1d219647ae6b31c, 0x596eb2d8ae258fc8), // 5^163\n+    (0xde469fbd99a05fe3, 0x6fca5f8ed9aef3bb), // 5^164\n+    (0x8aec23d680043bee, 0x25de7bb9480d5854), // 5^165\n+    (0xada72ccc20054ae9, 0xaf561aa79a10ae6a), // 5^166\n+    (0xd910f7ff28069da4, 0x1b2ba1518094da04), // 5^167\n+    (0x87aa9aff79042286, 0x90fb44d2f05d0842), // 5^168\n+    (0xa99541bf57452b28, 0x353a1607ac744a53), // 5^169\n+    (0xd3fa922f2d1675f2, 0x42889b8997915ce8), // 5^170\n+    (0x847c9b5d7c2e09b7, 0x69956135febada11), // 5^171\n+    (0xa59bc234db398c25, 0x43fab9837e699095), // 5^172\n+    (0xcf02b2c21207ef2e, 0x94f967e45e03f4bb), // 5^173\n+    (0x8161afb94b44f57d, 0x1d1be0eebac278f5), // 5^174\n+    (0xa1ba1ba79e1632dc, 0x6462d92a69731732), // 5^175\n+    (0xca28a291859bbf93, 0x7d7b8f7503cfdcfe), // 5^176\n+    (0xfcb2cb35e702af78, 0x5cda735244c3d43e), // 5^177\n+    (0x9defbf01b061adab, 0x3a0888136afa64a7), // 5^178\n+    (0xc56baec21c7a1916, 0x88aaa1845b8fdd0),  // 5^179\n+    (0xf6c69a72a3989f5b, 0x8aad549e57273d45), // 5^180\n+    (0x9a3c2087a63f6399, 0x36ac54e2f678864b), // 5^181\n+    (0xc0cb28a98fcf3c7f, 0x84576a1bb416a7dd), // 5^182\n+    (0xf0fdf2d3f3c30b9f, 0x656d44a2a11c51d5), // 5^183\n+    (0x969eb7c47859e743, 0x9f644ae5a4b1b325), // 5^184\n+    (0xbc4665b596706114, 0x873d5d9f0dde1fee), // 5^185\n+    (0xeb57ff22fc0c7959, 0xa90cb506d155a7ea), // 5^186\n+    (0x9316ff75dd87cbd8, 0x9a7f12442d588f2),  // 5^187\n+    (0xb7dcbf5354e9bece, 0xc11ed6d538aeb2f),  // 5^188\n+    (0xe5d3ef282a242e81, 0x8f1668c8a86da5fa), // 5^189\n+    (0x8fa475791a569d10, 0xf96e017d694487bc), // 5^190\n+    (0xb38d92d760ec4455, 0x37c981dcc395a9ac), // 5^191\n+    (0xe070f78d3927556a, 0x85bbe253f47b1417), // 5^192\n+    (0x8c469ab843b89562, 0x93956d7478ccec8e), // 5^193\n+    (0xaf58416654a6babb, 0x387ac8d1970027b2), // 5^194\n+    (0xdb2e51bfe9d0696a, 0x6997b05fcc0319e),  // 5^195\n+    (0x88fcf317f22241e2, 0x441fece3bdf81f03), // 5^196\n+    (0xab3c2fddeeaad25a, 0xd527e81cad7626c3), // 5^197\n+    (0xd60b3bd56a5586f1, 0x8a71e223d8d3b074), // 5^198\n+    (0x85c7056562757456, 0xf6872d5667844e49), // 5^199\n+    (0xa738c6bebb12d16c, 0xb428f8ac016561db), // 5^200\n+    (0xd106f86e69d785c7, 0xe13336d701beba52), // 5^201\n+    (0x82a45b450226b39c, 0xecc0024661173473), // 5^202\n+    (0xa34d721642b06084, 0x27f002d7f95d0190), // 5^203\n+    (0xcc20ce9bd35c78a5, 0x31ec038df7b441f4), // 5^204\n+    (0xff290242c83396ce, 0x7e67047175a15271), // 5^205\n+    (0x9f79a169bd203e41, 0xf0062c6e984d386),  // 5^206\n+    (0xc75809c42c684dd1, 0x52c07b78a3e60868), // 5^207\n+    (0xf92e0c3537826145, 0xa7709a56ccdf8a82), // 5^208\n+    (0x9bbcc7a142b17ccb, 0x88a66076400bb691), // 5^209\n+    (0xc2abf989935ddbfe, 0x6acff893d00ea435), // 5^210\n+    (0xf356f7ebf83552fe, 0x583f6b8c4124d43),  // 5^211\n+    (0x98165af37b2153de, 0xc3727a337a8b704a), // 5^212\n+    (0xbe1bf1b059e9a8d6, 0x744f18c0592e4c5c), // 5^213\n+    (0xeda2ee1c7064130c, 0x1162def06f79df73), // 5^214\n+    (0x9485d4d1c63e8be7, 0x8addcb5645ac2ba8), // 5^215\n+    (0xb9a74a0637ce2ee1, 0x6d953e2bd7173692), // 5^216\n+    (0xe8111c87c5c1ba99, 0xc8fa8db6ccdd0437), // 5^217\n+    (0x910ab1d4db9914a0, 0x1d9c9892400a22a2), // 5^218\n+    (0xb54d5e4a127f59c8, 0x2503beb6d00cab4b), // 5^219\n+    (0xe2a0b5dc971f303a, 0x2e44ae64840fd61d), // 5^220\n+    (0x8da471a9de737e24, 0x5ceaecfed289e5d2), // 5^221\n+    (0xb10d8e1456105dad, 0x7425a83e872c5f47), // 5^222\n+    (0xdd50f1996b947518, 0xd12f124e28f77719), // 5^223\n+    (0x8a5296ffe33cc92f, 0x82bd6b70d99aaa6f), // 5^224\n+    (0xace73cbfdc0bfb7b, 0x636cc64d1001550b), // 5^225\n+    (0xd8210befd30efa5a, 0x3c47f7e05401aa4e), // 5^226\n+    (0x8714a775e3e95c78, 0x65acfaec34810a71), // 5^227\n+    (0xa8d9d1535ce3b396, 0x7f1839a741a14d0d), // 5^228\n+    (0xd31045a8341ca07c, 0x1ede48111209a050), // 5^229\n+    (0x83ea2b892091e44d, 0x934aed0aab460432), // 5^230\n+    (0xa4e4b66b68b65d60, 0xf81da84d5617853f), // 5^231\n+    (0xce1de40642e3f4b9, 0x36251260ab9d668e), // 5^232\n+    (0x80d2ae83e9ce78f3, 0xc1d72b7c6b426019), // 5^233\n+    (0xa1075a24e4421730, 0xb24cf65b8612f81f), // 5^234\n+    (0xc94930ae1d529cfc, 0xdee033f26797b627), // 5^235\n+    (0xfb9b7cd9a4a7443c, 0x169840ef017da3b1), // 5^236\n+    (0x9d412e0806e88aa5, 0x8e1f289560ee864e), // 5^237\n+    (0xc491798a08a2ad4e, 0xf1a6f2bab92a27e2), // 5^238\n+    (0xf5b5d7ec8acb58a2, 0xae10af696774b1db), // 5^239\n+    (0x9991a6f3d6bf1765, 0xacca6da1e0a8ef29), // 5^240\n+    (0xbff610b0cc6edd3f, 0x17fd090a58d32af3), // 5^241\n+    (0xeff394dcff8a948e, 0xddfc4b4cef07f5b0), // 5^242\n+    (0x95f83d0a1fb69cd9, 0x4abdaf101564f98e), // 5^243\n+    (0xbb764c4ca7a4440f, 0x9d6d1ad41abe37f1), // 5^244\n+    (0xea53df5fd18d5513, 0x84c86189216dc5ed), // 5^245\n+    (0x92746b9be2f8552c, 0x32fd3cf5b4e49bb4), // 5^246\n+    (0xb7118682dbb66a77, 0x3fbc8c33221dc2a1), // 5^247\n+    (0xe4d5e82392a40515, 0xfabaf3feaa5334a),  // 5^248\n+    (0x8f05b1163ba6832d, 0x29cb4d87f2a7400e), // 5^249\n+    (0xb2c71d5bca9023f8, 0x743e20e9ef511012), // 5^250\n+    (0xdf78e4b2bd342cf6, 0x914da9246b255416), // 5^251\n+    (0x8bab8eefb6409c1a, 0x1ad089b6c2f7548e), // 5^252\n+    (0xae9672aba3d0c320, 0xa184ac2473b529b1), // 5^253\n+    (0xda3c0f568cc4f3e8, 0xc9e5d72d90a2741e), // 5^254\n+    (0x8865899617fb1871, 0x7e2fa67c7a658892), // 5^255\n+    (0xaa7eebfb9df9de8d, 0xddbb901b98feeab7), // 5^256\n+    (0xd51ea6fa85785631, 0x552a74227f3ea565), // 5^257\n+    (0x8533285c936b35de, 0xd53a88958f87275f), // 5^258\n+    (0xa67ff273b8460356, 0x8a892abaf368f137), // 5^259\n+    (0xd01fef10a657842c, 0x2d2b7569b0432d85), // 5^260\n+    (0x8213f56a67f6b29b, 0x9c3b29620e29fc73), // 5^261\n+    (0xa298f2c501f45f42, 0x8349f3ba91b47b8f), // 5^262\n+    (0xcb3f2f7642717713, 0x241c70a936219a73), // 5^263\n+    (0xfe0efb53d30dd4d7, 0xed238cd383aa0110), // 5^264\n+    (0x9ec95d1463e8a506, 0xf4363804324a40aa), // 5^265\n+    (0xc67bb4597ce2ce48, 0xb143c6053edcd0d5), // 5^266\n+    (0xf81aa16fdc1b81da, 0xdd94b7868e94050a), // 5^267\n+    (0x9b10a4e5e9913128, 0xca7cf2b4191c8326), // 5^268\n+    (0xc1d4ce1f63f57d72, 0xfd1c2f611f63a3f0), // 5^269\n+    (0xf24a01a73cf2dccf, 0xbc633b39673c8cec), // 5^270\n+    (0x976e41088617ca01, 0xd5be0503e085d813), // 5^271\n+    (0xbd49d14aa79dbc82, 0x4b2d8644d8a74e18), // 5^272\n+    (0xec9c459d51852ba2, 0xddf8e7d60ed1219e), // 5^273\n+    (0x93e1ab8252f33b45, 0xcabb90e5c942b503), // 5^274\n+    (0xb8da1662e7b00a17, 0x3d6a751f3b936243), // 5^275\n+    (0xe7109bfba19c0c9d, 0xcc512670a783ad4),  // 5^276\n+    (0x906a617d450187e2, 0x27fb2b80668b24c5), // 5^277\n+    (0xb484f9dc9641e9da, 0xb1f9f660802dedf6), // 5^278\n+    (0xe1a63853bbd26451, 0x5e7873f8a0396973), // 5^279\n+    (0x8d07e33455637eb2, 0xdb0b487b6423e1e8), // 5^280\n+    (0xb049dc016abc5e5f, 0x91ce1a9a3d2cda62), // 5^281\n+    (0xdc5c5301c56b75f7, 0x7641a140cc7810fb), // 5^282\n+    (0x89b9b3e11b6329ba, 0xa9e904c87fcb0a9d), // 5^283\n+    (0xac2820d9623bf429, 0x546345fa9fbdcd44), // 5^284\n+    (0xd732290fbacaf133, 0xa97c177947ad4095), // 5^285\n+    (0x867f59a9d4bed6c0, 0x49ed8eabcccc485d), // 5^286\n+    (0xa81f301449ee8c70, 0x5c68f256bfff5a74), // 5^287\n+    (0xd226fc195c6a2f8c, 0x73832eec6fff3111), // 5^288\n+    (0x83585d8fd9c25db7, 0xc831fd53c5ff7eab), // 5^289\n+    (0xa42e74f3d032f525, 0xba3e7ca8b77f5e55), // 5^290\n+    (0xcd3a1230c43fb26f, 0x28ce1bd2e55f35eb), // 5^291\n+    (0x80444b5e7aa7cf85, 0x7980d163cf5b81b3), // 5^292\n+    (0xa0555e361951c366, 0xd7e105bcc332621f), // 5^293\n+    (0xc86ab5c39fa63440, 0x8dd9472bf3fefaa7), // 5^294\n+    (0xfa856334878fc150, 0xb14f98f6f0feb951), // 5^295\n+    (0x9c935e00d4b9d8d2, 0x6ed1bf9a569f33d3), // 5^296\n+    (0xc3b8358109e84f07, 0xa862f80ec4700c8),  // 5^297\n+    (0xf4a642e14c6262c8, 0xcd27bb612758c0fa), // 5^298\n+    (0x98e7e9cccfbd7dbd, 0x8038d51cb897789c), // 5^299\n+    (0xbf21e44003acdd2c, 0xe0470a63e6bd56c3), // 5^300\n+    (0xeeea5d5004981478, 0x1858ccfce06cac74), // 5^301\n+    (0x95527a5202df0ccb, 0xf37801e0c43ebc8),  // 5^302\n+    (0xbaa718e68396cffd, 0xd30560258f54e6ba), // 5^303\n+    (0xe950df20247c83fd, 0x47c6b82ef32a2069), // 5^304\n+    (0x91d28b7416cdd27e, 0x4cdc331d57fa5441), // 5^305\n+    (0xb6472e511c81471d, 0xe0133fe4adf8e952), // 5^306\n+    (0xe3d8f9e563a198e5, 0x58180fddd97723a6), // 5^307\n+    (0x8e679c2f5e44ff8f, 0x570f09eaa7ea7648), // 5^308\n ];"}, {"sha": "5763860540aa49511951ec2b661afc1bbeb1a7f2", "filename": "library/core/src/num/flt2dec/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,6 +1,6 @@\n //! Decodes a floating-point value into individual parts and error ranges.\n \n-use crate::num::dec2flt::rawfp::RawFloat;\n+use crate::num::dec2flt::float::RawFloat;\n use crate::num::FpCategory;\n \n /// Decoded unsigned finite value, such that:"}, {"sha": "7a9587a18d0305ea44febfc31ccd98f23253d785", "filename": "library/core/tests/num/dec2flt/float.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Ffloat.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -0,0 +1,33 @@\n+use core::num::dec2flt::float::RawFloat;\n+\n+#[test]\n+fn test_f32_integer_decode() {\n+    assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n+    assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n+    assert_eq!(2f32.powf(100.0).integer_decode(), (8388608, 77, 1));\n+    assert_eq!(0f32.integer_decode(), (0, -150, 1));\n+    assert_eq!((-0f32).integer_decode(), (0, -150, -1));\n+    assert_eq!(f32::INFINITY.integer_decode(), (8388608, 105, 1));\n+    assert_eq!(f32::NEG_INFINITY.integer_decode(), (8388608, 105, -1));\n+\n+    // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n+    // It can vary between runtime operations and LLVM folding.\n+    let (nan_m, nan_e, _nan_s) = f32::NAN.integer_decode();\n+    assert_eq!((nan_m, nan_e), (12582912, 105));\n+}\n+\n+#[test]\n+fn test_f64_integer_decode() {\n+    assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n+    assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n+    assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496, 48, 1));\n+    assert_eq!(0f64.integer_decode(), (0, -1075, 1));\n+    assert_eq!((-0f64).integer_decode(), (0, -1075, -1));\n+    assert_eq!(f64::INFINITY.integer_decode(), (4503599627370496, 972, 1));\n+    assert_eq!(f64::NEG_INFINITY.integer_decode(), (4503599627370496, 972, -1));\n+\n+    // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n+    // It can vary between runtime operations and LLVM folding.\n+    let (nan_m, nan_e, _nan_s) = f64::NAN.integer_decode();\n+    assert_eq!((nan_m, nan_e), (6755399441055744, 972));\n+}"}, {"sha": "f71bbb7c7a318889b2d0c5053b4ede89759532cd", "filename": "library/core/tests/num/dec2flt/lemire.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Flemire.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Flemire.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Flemire.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -0,0 +1,53 @@\n+use core::num::dec2flt::lemire::compute_float;\n+\n+fn compute_float32(q: i64, w: u64) -> (i32, u64) {\n+    let fp = compute_float::<f32>(q, w);\n+    (fp.e, fp.f)\n+}\n+\n+fn compute_float64(q: i64, w: u64) -> (i32, u64) {\n+    let fp = compute_float::<f64>(q, w);\n+    (fp.e, fp.f)\n+}\n+\n+#[test]\n+fn compute_float_f32_rounding() {\n+    // These test near-halfway cases for single-precision floats.\n+    assert_eq!(compute_float32(0, 16777216), (151, 0));\n+    assert_eq!(compute_float32(0, 16777217), (151, 0));\n+    assert_eq!(compute_float32(0, 16777218), (151, 1));\n+    assert_eq!(compute_float32(0, 16777219), (151, 2));\n+    assert_eq!(compute_float32(0, 16777220), (151, 2));\n+\n+    // These are examples of the above tests, with\n+    // digits from the exponent shifted to the mantissa.\n+    assert_eq!(compute_float32(-10, 167772160000000000), (151, 0));\n+    assert_eq!(compute_float32(-10, 167772170000000000), (151, 0));\n+    assert_eq!(compute_float32(-10, 167772180000000000), (151, 1));\n+    // Let's check the lines to see if anything is different in table...\n+    assert_eq!(compute_float32(-10, 167772190000000000), (151, 2));\n+    assert_eq!(compute_float32(-10, 167772200000000000), (151, 2));\n+}\n+\n+#[test]\n+fn compute_float_f64_rounding() {\n+    // These test near-halfway cases for double-precision floats.\n+    assert_eq!(compute_float64(0, 9007199254740992), (1076, 0));\n+    assert_eq!(compute_float64(0, 9007199254740993), (1076, 0));\n+    assert_eq!(compute_float64(0, 9007199254740994), (1076, 1));\n+    assert_eq!(compute_float64(0, 9007199254740995), (1076, 2));\n+    assert_eq!(compute_float64(0, 9007199254740996), (1076, 2));\n+    assert_eq!(compute_float64(0, 18014398509481984), (1077, 0));\n+    assert_eq!(compute_float64(0, 18014398509481986), (1077, 0));\n+    assert_eq!(compute_float64(0, 18014398509481988), (1077, 1));\n+    assert_eq!(compute_float64(0, 18014398509481990), (1077, 2));\n+    assert_eq!(compute_float64(0, 18014398509481992), (1077, 2));\n+\n+    // These are examples of the above tests, with\n+    // digits from the exponent shifted to the mantissa.\n+    assert_eq!(compute_float64(-3, 9007199254740992000), (1076, 0));\n+    assert_eq!(compute_float64(-3, 9007199254740993000), (1076, 0));\n+    assert_eq!(compute_float64(-3, 9007199254740994000), (1076, 1));\n+    assert_eq!(compute_float64(-3, 9007199254740995000), (1076, 2));\n+    assert_eq!(compute_float64(-3, 9007199254740996000), (1076, 2));\n+}"}, {"sha": "4990d4a083df62e5faa3b01979f74b4ee8654915", "filename": "library/core/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,7 +1,8 @@\n #![allow(overflowing_literals)]\n \n+mod float;\n+mod lemire;\n mod parse;\n-mod rawfp;\n \n // Take a float literal, turn it into a string in various ways (that are all trusted\n // to be correct) and see if those strings are parsed back to the value of the literal.\n@@ -28,12 +29,6 @@ fn ordinary() {\n     test_literal!(0.1);\n     test_literal!(12345.);\n     test_literal!(0.9999999);\n-\n-    if cfg!(miri) {\n-        // Miri is too slow\n-        return;\n-    }\n-\n     test_literal!(2.2250738585072014e-308);\n }\n \n@@ -54,7 +49,6 @@ fn large() {\n }\n \n #[test]\n-#[cfg_attr(miri, ignore)] // Miri is too slow\n fn subnormals() {\n     test_literal!(5e-324);\n     test_literal!(91e-324);\n@@ -66,7 +60,6 @@ fn subnormals() {\n }\n \n #[test]\n-#[cfg_attr(miri, ignore)] // Miri is too slow\n fn infinity() {\n     test_literal!(1e400);\n     test_literal!(1e309);\n@@ -78,12 +71,6 @@ fn infinity() {\n fn zero() {\n     test_literal!(0.0);\n     test_literal!(1e-325);\n-\n-    if cfg!(miri) {\n-        // Miri is too slow\n-        return;\n-    }\n-\n     test_literal!(1e-326);\n     test_literal!(1e-500);\n }"}, {"sha": "473feacc91fa95eb48fb8b32ee468ab7c87cedfb", "filename": "library/core/tests/num/dec2flt/parse.rs", "status": "modified", "additions": 149, "deletions": 13, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,41 +1,177 @@\n-use core::num::dec2flt::parse::ParseResult::{Invalid, Valid};\n-use core::num::dec2flt::parse::{parse_decimal, Decimal};\n+use core::num::dec2flt::number::Number;\n+use core::num::dec2flt::parse::parse_number;\n+use core::num::dec2flt::{dec2flt, pfe_invalid};\n+\n+fn new_number(e: i64, m: u64) -> Number {\n+    Number { exponent: e, mantissa: m, negative: false, many_digits: false }\n+}\n \n #[test]\n fn missing_pieces() {\n     let permutations = &[\".e\", \"1e\", \"e4\", \"e\", \".12e\", \"321.e\", \"32.12e+\", \"12.32e-\"];\n     for &s in permutations {\n-        assert_eq!(parse_decimal(s), Invalid);\n+        assert_eq!(dec2flt::<f64>(s), Err(pfe_invalid()));\n     }\n }\n \n #[test]\n fn invalid_chars() {\n     let invalid = \"r,?<j\";\n+    let error = Err(pfe_invalid());\n     let valid_strings = &[\"123\", \"666.\", \".1\", \"5e1\", \"7e-3\", \"0.0e+1\"];\n     for c in invalid.chars() {\n         for s in valid_strings {\n             for i in 0..s.len() {\n                 let mut input = String::new();\n                 input.push_str(s);\n                 input.insert(i, c);\n-                assert!(parse_decimal(&input) == Invalid, \"did not reject invalid {:?}\", input);\n+                assert!(dec2flt::<f64>(&input) == error, \"did not reject invalid {:?}\", input);\n             }\n         }\n     }\n }\n \n+fn parse_positive(s: &[u8]) -> Option<Number> {\n+    parse_number(s, false)\n+}\n+\n #[test]\n fn valid() {\n-    assert_eq!(parse_decimal(\"123.456e789\"), Valid(Decimal::new(b\"123\", b\"456\", 789)));\n-    assert_eq!(parse_decimal(\"123.456e+789\"), Valid(Decimal::new(b\"123\", b\"456\", 789)));\n-    assert_eq!(parse_decimal(\"123.456e-789\"), Valid(Decimal::new(b\"123\", b\"456\", -789)));\n-    assert_eq!(parse_decimal(\".050\"), Valid(Decimal::new(b\"\", b\"050\", 0)));\n-    assert_eq!(parse_decimal(\"999\"), Valid(Decimal::new(b\"999\", b\"\", 0)));\n-    assert_eq!(parse_decimal(\"1.e300\"), Valid(Decimal::new(b\"1\", b\"\", 300)));\n-    assert_eq!(parse_decimal(\".1e300\"), Valid(Decimal::new(b\"\", b\"1\", 300)));\n-    assert_eq!(parse_decimal(\"101e-33\"), Valid(Decimal::new(b\"101\", b\"\", -33)));\n+    assert_eq!(parse_positive(b\"123.456e789\"), Some(new_number(786, 123456)));\n+    assert_eq!(parse_positive(b\"123.456e+789\"), Some(new_number(786, 123456)));\n+    assert_eq!(parse_positive(b\"123.456e-789\"), Some(new_number(-792, 123456)));\n+    assert_eq!(parse_positive(b\".050\"), Some(new_number(-3, 50)));\n+    assert_eq!(parse_positive(b\"999\"), Some(new_number(0, 999)));\n+    assert_eq!(parse_positive(b\"1.e300\"), Some(new_number(300, 1)));\n+    assert_eq!(parse_positive(b\".1e300\"), Some(new_number(299, 1)));\n+    assert_eq!(parse_positive(b\"101e-33\"), Some(new_number(-33, 101)));\n     let zeros = \"0\".repeat(25);\n     let s = format!(\"1.5e{}\", zeros);\n-    assert_eq!(parse_decimal(&s), Valid(Decimal::new(b\"1\", b\"5\", 0)));\n+    assert_eq!(parse_positive(s.as_bytes()), Some(new_number(-1, 15)));\n+}\n+\n+macro_rules! assert_float_result_bits_eq {\n+    ($bits:literal, $ty:ty, $str:literal) => {{\n+        let p = dec2flt::<$ty>($str);\n+        assert_eq!(p.map(|x| x.to_bits()), Ok($bits));\n+    }};\n+}\n+\n+#[test]\n+fn issue31109() {\n+    // Regression test for #31109.\n+    // Ensure the test produces a valid float with the expected bit pattern.\n+    assert_float_result_bits_eq!(\n+        0x3fd5555555555555,\n+        f64,\n+        \"0.3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333\"\n+    );\n+}\n+\n+#[test]\n+fn issue31407() {\n+    // Regression test for #31407.\n+    // Ensure the test produces a valid float with the expected bit pattern.\n+    assert_float_result_bits_eq!(\n+        0x1752a64e34ba0d3,\n+        f64,\n+        \"1234567890123456789012345678901234567890e-340\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0xfffffffffffff,\n+        f64,\n+        \"2.225073858507201136057409796709131975934819546351645648023426109724822222021076945516529523908135087914149158913039621106870086438694594645527657207407820621743379988141063267329253552286881372149012981122451451889849057222307285255133155755015914397476397983411801999323962548289017107081850690630666655994938275772572015763062690663332647565300009245888316433037779791869612049497390377829704905051080609940730262937128958950003583799967207254304360284078895771796150945516748243471030702609144621572289880258182545180325707018860872113128079512233426288368622321503775666622503982534335974568884423900265498198385487948292206894721689831099698365846814022854243330660339850886445804001034933970427567186443383770486037861622771738545623065874679014086723327636718749999999999999999999999999999999999999e-308\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x10000000000000,\n+        f64,\n+        \"2.22507385850720113605740979670913197593481954635164564802342610972482222202107694551652952390813508791414915891303962110687008643869459464552765720740782062174337998814106326732925355228688137214901298112245145188984905722230728525513315575501591439747639798341180199932396254828901710708185069063066665599493827577257201576306269066333264756530000924588831643303777979186961204949739037782970490505108060994073026293712895895000358379996720725430436028407889577179615094551674824347103070260914462157228988025818254518032570701886087211312807951223342628836862232150377566662250398253433597456888442390026549819838548794829220689472168983109969836584681402285424333066033985088644580400103493397042756718644338377048603786162277173854562306587467901408672332763671875e-308\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x10000000000000,\n+        f64,\n+        \"0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000222507385850720138309023271733240406421921598046233183055332741688720443481391819585428315901251102056406733973103581100515243416155346010885601238537771882113077799353200233047961014744258363607192156504694250373420837525080665061665815894872049117996859163964850063590877011830487479978088775374994945158045160505091539985658247081864511353793580499211598108576605199243335211435239014879569960959128889160299264151106346631339366347758651302937176204732563178148566435087212282863764204484681140761391147706280168985324411002416144742161856716615054015428508471675290190316132277889672970737312333408698898317506783884692609277397797285865965494109136909540613646756870239867831529068098461721092462539672851562500000000000000001\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x7fefffffffffffff,\n+        f64,\n+        \"179769313486231580793728971405303415079934132710037826936173778980444968292764750946649017977587207096330286416692887910946555547851940402630657488671505820681908902000708383676273854845817711531764475730270069855571366959622842914819860834936475292719074168444365510704342711559699508093042880177904174497791.9999999999999999999999999999999999999999999999999999999999999999999999\"\n+    );\n+    assert_float_result_bits_eq!(0x0, f64, \"2.47032822920623272e-324\");\n+    assert_float_result_bits_eq!(\n+        0x8000000,\n+        f64,\n+        \"6.631236871469758276785396630275967243399099947355303144249971758736286630139265439618068200788048744105960420552601852889715006376325666595539603330361800519107591783233358492337208057849499360899425128640718856616503093444922854759159988160304439909868291973931426625698663157749836252274523485312442358651207051292453083278116143932569727918709786004497872322193856150225415211997283078496319412124640111777216148110752815101775295719811974338451936095907419622417538473679495148632480391435931767981122396703443803335529756003353209830071832230689201383015598792184172909927924176339315507402234836120730914783168400715462440053817592702766213559042115986763819482654128770595766806872783349146967171293949598850675682115696218943412532098591327667236328125E-316\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x10000,\n+        f64,\n+        \"3.237883913302901289588352412501532174863037669423108059901297049552301970670676565786835742587799557860615776559838283435514391084153169252689190564396459577394618038928365305143463955100356696665629202017331344031730044369360205258345803431471660032699580731300954848363975548690010751530018881758184174569652173110473696022749934638425380623369774736560008997404060967498028389191878963968575439222206416981462690113342524002724385941651051293552601421155333430225237291523843322331326138431477823591142408800030775170625915670728657003151953664260769822494937951845801530895238439819708403389937873241463484205608000027270531106827387907791444918534771598750162812548862768493201518991668028251730299953143924168545708663913273994694463908672332763671875E-319\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x800000000100,\n+        f64,\n+        \"6.953355807847677105972805215521891690222119817145950754416205607980030131549636688806115726399441880065386399864028691275539539414652831584795668560082999889551357784961446896042113198284213107935110217162654939802416034676213829409720583759540476786936413816541621287843248433202369209916612249676005573022703244799714622116542188837770376022371172079559125853382801396219552418839469770514904192657627060319372847562301074140442660237844114174497210955449896389180395827191602886654488182452409583981389442783377001505462015745017848754574668342161759496661766020028752888783387074850773192997102997936619876226688096314989645766000479009083731736585750335262099860150896718774401964796827166283225641992040747894382698751809812609536720628966577351093292236328125E-310\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x10800,\n+        f64,\n+        \"3.339068557571188581835713701280943911923401916998521771655656997328440314559615318168849149074662609099998113009465566426808170378434065722991659642619467706034884424989741080790766778456332168200464651593995817371782125010668346652995912233993254584461125868481633343674905074271064409763090708017856584019776878812425312008812326260363035474811532236853359905334625575404216060622858633280744301892470300555678734689978476870369853549413277156622170245846166991655321535529623870646888786637528995592800436177901746286272273374471701452991433047257863864601424252024791567368195056077320885329384322332391564645264143400798619665040608077549162173963649264049738362290606875883456826586710961041737908872035803481241600376705491726170293986797332763671875E-319\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x0,\n+        f64,\n+        \"2.4703282292062327208828439643411068618252990130716238221279284125033775363510437593264991818081799618989828234772285886546332835517796989819938739800539093906315035659515570226392290858392449105184435931802849936536152500319370457678249219365623669863658480757001585769269903706311928279558551332927834338409351978015531246597263579574622766465272827220056374006485499977096599470454020828166226237857393450736339007967761930577506740176324673600968951340535537458516661134223766678604162159680461914467291840300530057530849048765391711386591646239524912623653881879636239373280423891018672348497668235089863388587925628302755995657524455507255189313690836254779186948667994968324049705821028513185451396213837722826145437693412532098591327667236328124999e-324\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x0,\n+        f64,\n+        \"2.4703282292062327208828439643411068618252990130716238221279284125033775363510437593264991818081799618989828234772285886546332835517796989819938739800539093906315035659515570226392290858392449105184435931802849936536152500319370457678249219365623669863658480757001585769269903706311928279558551332927834338409351978015531246597263579574622766465272827220056374006485499977096599470454020828166226237857393450736339007967761930577506740176324673600968951340535537458516661134223766678604162159680461914467291840300530057530849048765391711386591646239524912623653881879636239373280423891018672348497668235089863388587925628302755995657524455507255189313690836254779186948667994968324049705821028513185451396213837722826145437693412532098591327667236328125e-324\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x1,\n+        f64,\n+        \"2.4703282292062327208828439643411068618252990130716238221279284125033775363510437593264991818081799618989828234772285886546332835517796989819938739800539093906315035659515570226392290858392449105184435931802849936536152500319370457678249219365623669863658480757001585769269903706311928279558551332927834338409351978015531246597263579574622766465272827220056374006485499977096599470454020828166226237857393450736339007967761930577506740176324673600968951340535537458516661134223766678604162159680461914467291840300530057530849048765391711386591646239524912623653881879636239373280423891018672348497668235089863388587925628302755995657524455507255189313690836254779186948667994968324049705821028513185451396213837722826145437693412532098591327667236328125001e-324\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x1,\n+        f64,\n+        \"7.4109846876186981626485318930233205854758970392148714663837852375101326090531312779794975454245398856969484704316857659638998506553390969459816219401617281718945106978546710679176872575177347315553307795408549809608457500958111373034747658096871009590975442271004757307809711118935784838675653998783503015228055934046593739791790738723868299395818481660169122019456499931289798411362062484498678713572180352209017023903285791732520220528974020802906854021606612375549983402671300035812486479041385743401875520901590172592547146296175134159774938718574737870961645638908718119841271673056017045493004705269590165763776884908267986972573366521765567941072508764337560846003984904972149117463085539556354188641513168478436313080237596295773983001708984374999e-324\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x2,\n+        f64,\n+        \"7.4109846876186981626485318930233205854758970392148714663837852375101326090531312779794975454245398856969484704316857659638998506553390969459816219401617281718945106978546710679176872575177347315553307795408549809608457500958111373034747658096871009590975442271004757307809711118935784838675653998783503015228055934046593739791790738723868299395818481660169122019456499931289798411362062484498678713572180352209017023903285791732520220528974020802906854021606612375549983402671300035812486479041385743401875520901590172592547146296175134159774938718574737870961645638908718119841271673056017045493004705269590165763776884908267986972573366521765567941072508764337560846003984904972149117463085539556354188641513168478436313080237596295773983001708984375e-324\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x2,\n+        f64,\n+        \"7.4109846876186981626485318930233205854758970392148714663837852375101326090531312779794975454245398856969484704316857659638998506553390969459816219401617281718945106978546710679176872575177347315553307795408549809608457500958111373034747658096871009590975442271004757307809711118935784838675653998783503015228055934046593739791790738723868299395818481660169122019456499931289798411362062484498678713572180352209017023903285791732520220528974020802906854021606612375549983402671300035812486479041385743401875520901590172592547146296175134159774938718574737870961645638908718119841271673056017045493004705269590165763776884908267986972573366521765567941072508764337560846003984904972149117463085539556354188641513168478436313080237596295773983001708984375001e-324\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x6c9a143590c14,\n+        f64,\n+        \"94393431193180696942841837085033647913224148539854e-358\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x7802665fd9600,\n+        f64,\n+        \"104308485241983990666713401708072175773165034278685682646111762292409330928739751702404658197872319129036519947435319418387839758990478549477777586673075945844895981012024387992135617064532141489278815239849108105951619997829153633535314849999674266169258928940692239684771590065027025835804863585454872499320500023126142553932654370362024104462255244034053203998964360882487378334860197725139151265590832887433736189468858614521708567646743455601905935595381852723723645799866672558576993978025033590728687206296379801363024094048327273913079612469982585674824156000783167963081616214710691759864332339239688734656548790656486646106983450809073750535624894296242072010195710276073042036425579852459556183541199012652571123898996574563824424330960027873516082763671875e-1075\"\n+    );\n+}\n+\n+#[test]\n+fn many_digits() {\n+    // Check large numbers of digits to ensure we have cases where significant\n+    // digits (above Decimal::MAX_DIGITS) occurs.\n+    assert_float_result_bits_eq!(\n+        0x7ffffe,\n+        f32,\n+        \"1.175494140627517859246175898662808184331245864732796240031385942718174675986064769972472277004271745681762695312500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-38\"\n+    );\n+    assert_float_result_bits_eq!(\n+        0x7ffffe,\n+        f32,\n+        \"1.175494140627517859246175898662808184331245864732796240031385942718174675986064769972472277004271745681762695312500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e-38\"\n+    );\n }"}, {"sha": "34a37209d99f8846a31d2bb3ea328999cd340611", "filename": "library/core/tests/num/dec2flt/rawfp.rs", "status": "removed", "additions": 0, "deletions": 172, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/d2b04f075c0ce010758c4c8674152ff89d1d73f3/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b04f075c0ce010758c4c8674152ff89d1d73f3/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs?ref=d2b04f075c0ce010758c4c8674152ff89d1d73f3", "patch": "@@ -1,172 +0,0 @@\n-use core::num::dec2flt::rawfp::RawFloat;\n-use core::num::dec2flt::rawfp::{fp_to_float, next_float, prev_float, round_normal};\n-use core::num::diy_float::Fp;\n-\n-fn integer_decode(f: f64) -> (u64, i16, i8) {\n-    RawFloat::integer_decode(f)\n-}\n-\n-#[test]\n-fn fp_to_float_half_to_even() {\n-    fn is_normalized(sig: u64) -> bool {\n-        // intentionally written without {min,max}_sig() as a sanity check\n-        sig >> 52 == 1 && sig >> 53 == 0\n-    }\n-\n-    fn conv(sig: u64) -> u64 {\n-        // The significands are perfectly in range, so the exponent should not matter\n-        let (m1, e1, _) = integer_decode(fp_to_float::<f64>(Fp { f: sig, e: 0 }));\n-        assert_eq!(e1, 0 + 64 - 53);\n-        let (m2, e2, _) = integer_decode(fp_to_float::<f64>(Fp { f: sig, e: 55 }));\n-        assert_eq!(e2, 55 + 64 - 53);\n-        assert_eq!(m2, m1);\n-        let (m3, e3, _) = integer_decode(fp_to_float::<f64>(Fp { f: sig, e: -78 }));\n-        assert_eq!(e3, -78 + 64 - 53);\n-        assert_eq!(m3, m2);\n-        m3\n-    }\n-\n-    let odd = 0x1F_EDCB_A012_345F;\n-    let even = odd - 1;\n-    assert!(is_normalized(odd));\n-    assert!(is_normalized(even));\n-    assert_eq!(conv(odd << 11), odd);\n-    assert_eq!(conv(even << 11), even);\n-    assert_eq!(conv(odd << 11 | 1 << 10), odd + 1);\n-    assert_eq!(conv(even << 11 | 1 << 10), even);\n-    assert_eq!(conv(even << 11 | 1 << 10 | 1), even + 1);\n-    assert_eq!(conv(odd << 11 | 1 << 9), odd);\n-    assert_eq!(conv(even << 11 | 1 << 9), even);\n-    assert_eq!(conv(odd << 11 | 0x7FF), odd + 1);\n-    assert_eq!(conv(even << 11 | 0x7FF), even + 1);\n-    assert_eq!(conv(odd << 11 | 0x3FF), odd);\n-    assert_eq!(conv(even << 11 | 0x3FF), even);\n-}\n-\n-#[test]\n-fn integers_to_f64() {\n-    assert_eq!(fp_to_float::<f64>(Fp { f: 1, e: 0 }), 1.0);\n-    assert_eq!(fp_to_float::<f64>(Fp { f: 42, e: 7 }), (42 << 7) as f64);\n-    assert_eq!(fp_to_float::<f64>(Fp { f: 1 << 20, e: 30 }), (1u64 << 50) as f64);\n-    assert_eq!(fp_to_float::<f64>(Fp { f: 4, e: -3 }), 0.5);\n-}\n-\n-const SOME_FLOATS: [f64; 9] = [\n-    0.1f64,\n-    33.568,\n-    42.1e-5,\n-    777.0e9,\n-    1.1111,\n-    0.347997,\n-    9843579834.35892,\n-    12456.0e-150,\n-    54389573.0e-150,\n-];\n-\n-#[test]\n-fn human_f64_roundtrip() {\n-    for &x in &SOME_FLOATS {\n-        let (f, e, _) = integer_decode(x);\n-        let fp = Fp { f: f, e: e };\n-        assert_eq!(fp_to_float::<f64>(fp), x);\n-    }\n-}\n-\n-#[test]\n-fn rounding_overflow() {\n-    let x = Fp { f: 0xFF_FF_FF_FF_FF_FF_FF_00u64, e: 42 };\n-    let rounded = round_normal::<f64>(x);\n-    let adjusted_k = x.e + 64 - 53;\n-    assert_eq!(rounded.sig, 1 << 52);\n-    assert_eq!(rounded.k, adjusted_k + 1);\n-}\n-\n-#[test]\n-fn prev_float_monotonic() {\n-    let mut x = 1.0;\n-    for _ in 0..100 {\n-        let x1 = prev_float(x);\n-        assert!(x1 < x);\n-        assert!(x - x1 < 1e-15);\n-        x = x1;\n-    }\n-}\n-\n-const MIN_SUBNORMAL: f64 = 5e-324;\n-\n-#[test]\n-fn next_float_zero() {\n-    let tiny = next_float(0.0);\n-    assert_eq!(tiny, MIN_SUBNORMAL);\n-    assert!(tiny != 0.0);\n-}\n-\n-#[test]\n-fn next_float_subnormal() {\n-    let second = next_float(MIN_SUBNORMAL);\n-    // For subnormals, MIN_SUBNORMAL is the ULP\n-    assert!(second != MIN_SUBNORMAL);\n-    assert!(second > 0.0);\n-    assert_eq!(second - MIN_SUBNORMAL, MIN_SUBNORMAL);\n-}\n-\n-#[test]\n-fn next_float_inf() {\n-    assert_eq!(next_float(f64::MAX), f64::INFINITY);\n-    assert_eq!(next_float(f64::INFINITY), f64::INFINITY);\n-}\n-\n-#[test]\n-fn next_prev_identity() {\n-    for &x in &SOME_FLOATS {\n-        assert_eq!(prev_float(next_float(x)), x);\n-        assert_eq!(prev_float(prev_float(next_float(next_float(x)))), x);\n-        assert_eq!(next_float(prev_float(x)), x);\n-        assert_eq!(next_float(next_float(prev_float(prev_float(x)))), x);\n-    }\n-}\n-\n-#[test]\n-fn next_float_monotonic() {\n-    let mut x = 0.49999999999999;\n-    assert!(x < 0.5);\n-    for _ in 0..200 {\n-        let x1 = next_float(x);\n-        assert!(x1 > x);\n-        assert!(x1 - x < 1e-15, \"next_float_monotonic: delta = {:?}\", x1 - x);\n-        x = x1;\n-    }\n-    assert!(x > 0.5);\n-}\n-\n-#[test]\n-fn test_f32_integer_decode() {\n-    assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n-    assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n-    assert_eq!(2f32.powf(100.0).integer_decode(), (8388608, 77, 1));\n-    assert_eq!(0f32.integer_decode(), (0, -150, 1));\n-    assert_eq!((-0f32).integer_decode(), (0, -150, -1));\n-    assert_eq!(f32::INFINITY.integer_decode(), (8388608, 105, 1));\n-    assert_eq!(f32::NEG_INFINITY.integer_decode(), (8388608, 105, -1));\n-\n-    // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n-    // It can vary between runtime operations and LLVM folding.\n-    let (nan_m, nan_e, _nan_s) = f32::NAN.integer_decode();\n-    assert_eq!((nan_m, nan_e), (12582912, 105));\n-}\n-\n-#[test]\n-fn test_f64_integer_decode() {\n-    assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n-    assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n-    assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496, 48, 1));\n-    assert_eq!(0f64.integer_decode(), (0, -1075, 1));\n-    assert_eq!((-0f64).integer_decode(), (0, -1075, -1));\n-    assert_eq!(f64::INFINITY.integer_decode(), (4503599627370496, 972, 1));\n-    assert_eq!(f64::NEG_INFINITY.integer_decode(), (4503599627370496, 972, -1));\n-\n-    // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n-    // It can vary between runtime operations and LLVM folding.\n-    let (nan_m, nan_e, _nan_s) = f64::NAN.integer_decode();\n-    assert_eq!((nan_m, nan_e), (6755399441055744, 972));\n-}"}, {"sha": "aa5188d96c3e7a5b2573edd6d96951f260b0b3dd", "filename": "src/etc/dec2flt_table.py", "status": "modified", "additions": 84, "deletions": 115, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Fdec2flt_table.py", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Fdec2flt_table.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdec2flt_table.py?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,141 +1,110 @@\n #!/usr/bin/env python3\n \n \"\"\"\n-Generate powers of ten using William Clinger's ``AlgorithmM`` for use in\n+Generate powers of five using Daniel Lemire's ``Eisel-Lemire algorithm`` for use in\n decimal to floating point conversions.\n \n Specifically, computes and outputs (as Rust code) a table of 10^e for some\n-range of exponents e. The output is one array of 64 bit significands and\n-another array of corresponding base two exponents. The approximations are\n-normalized and rounded perfectly, i.e., within 0.5 ULP of the true value.\n+range of exponents e. The output is one array of 128 bit significands.\n+The base two exponents can be inferred using a logarithmic slope\n+of the decimal exponent. The approximations are normalized and rounded perfectly,\n+i.e., within 0.5 ULP of the true value.\n \n-The representation ([u64], [i16]) instead of the more natural [(u64, i16)]\n-is used because (u64, i16) has a ton of padding which would make the table\n-even larger, and it's already uncomfortably large (6 KiB).\n+Adapted from Daniel Lemire's fast_float ``table_generation.py``,\n+available here: <https://github.com/fastfloat/fast_float/blob/main/script/table_generation.py>.\n \"\"\"\n from __future__ import print_function\n-from math import ceil, log\n+from math import ceil, floor, log, log2\n from fractions import Fraction\n-from collections import namedtuple\n-\n-\n-N = 64  # Size of the significand field in bits\n-MIN_SIG = 2 ** (N - 1)\n-MAX_SIG = (2 ** N) - 1\n-\n-# Hand-rolled fp representation without arithmetic or any other operations.\n-# The significand is normalized and always N bit, but the exponent is\n-# unrestricted in range.\n-Fp = namedtuple('Fp', 'sig exp')\n-\n-\n-def algorithm_m(f, e):\n-    assert f > 0\n-    if e < 0:\n-        u = f\n-        v = 10 ** abs(e)\n-    else:\n-        u = f * 10 ** e\n-        v = 1\n-    k = 0\n-    x = u // v\n-    while True:\n-        if x < MIN_SIG:\n-            u <<= 1\n-            k -= 1\n-        elif x >= MAX_SIG:\n-            v <<= 1\n-            k += 1\n-        else:\n-            break\n-        x = u // v\n-    return ratio_to_float(u, v, k)\n-\n-\n-def ratio_to_float(u, v, k):\n-    q, r = divmod(u, v)\n-    v_r = v - r\n-    z = Fp(q, k)\n-    if r < v_r:\n-        return z\n-    elif r > v_r:\n-        return next_float(z)\n-    elif q % 2 == 0:\n-        return z\n-    else:\n-        return next_float(z)\n-\n-\n-def next_float(z):\n-    if z.sig == MAX_SIG:\n-        return Fp(MIN_SIG, z.exp + 1)\n-    else:\n-        return Fp(z.sig + 1, z.exp)\n-\n-\n-def error(f, e, z):\n-    decimal = f * Fraction(10) ** e\n-    binary = z.sig * Fraction(2) ** z.exp\n-    abs_err = abs(decimal - binary)\n-    # The unit in the last place has value z.exp\n-    ulp_err = abs_err / Fraction(2) ** z.exp\n-    return float(ulp_err)\n-\n+from collections import deque\n \n HEADER = \"\"\"\n-//! Tables of approximations of powers of ten.\n+//! Pre-computed tables powers-of-5 for extended-precision representations.\n+//!\n+//! These tables enable fast scaling of the significant digits\n+//! of a float to the decimal exponent, with minimal rounding\n+//! errors, in a 128 or 192-bit representation.\n+//!\n //! DO NOT MODIFY: Generated by `src/etc/dec2flt_table.py`\n \"\"\"\n \n+STATIC_WARNING = \"\"\"\n+// Use static to avoid long compile times: Rust compiler errors\n+// can have the entire table compiled multiple times, and then\n+// emit code multiple times, even if it's stripped out in\n+// the final binary.\n+\"\"\"\n \n def main():\n+    min_exp = minimum_exponent(10)\n+    max_exp = maximum_exponent(10)\n+    bias = -minimum_exponent(5)\n+\n     print(HEADER.strip())\n     print()\n-    print_proper_powers()\n-    print()\n-    print_short_powers(32, 24)\n+    print('pub const SMALLEST_POWER_OF_FIVE: i32 = {};'.format(min_exp))\n+    print('pub const LARGEST_POWER_OF_FIVE: i32 = {};'.format(max_exp))\n+    print('pub const N_POWERS_OF_FIVE: usize = ', end='')\n+    print('(LARGEST_POWER_OF_FIVE - SMALLEST_POWER_OF_FIVE + 1) as usize;')\n     print()\n-    print_short_powers(64, 53)\n+    print_proper_powers(min_exp, max_exp, bias)\n+\n+\n+def minimum_exponent(base):\n+    return ceil(log(5e-324, base) - log(0xFFFFFFFFFFFFFFFF, base))\n+\n \n+def maximum_exponent(base):\n+    return floor(log(1.7976931348623157e+308, base))\n \n-def print_proper_powers():\n-    MIN_E = -305\n-    MAX_E = 305\n-    e_range = range(MIN_E, MAX_E+1)\n+\n+def print_proper_powers(min_exp, max_exp, bias):\n+    powers = deque()\n+\n+    # Add negative exponents.\n+    # 2^(2b)/(5^\u2212q) with b=64 + int(math.ceil(log2(5^\u2212q)))\n     powers = []\n-    for e in e_range:\n-        z = algorithm_m(1, e)\n-        err = error(1, e, z)\n-        assert err < 0.5\n-        powers.append(z)\n-    print(\"pub const MIN_E: i16 = {};\".format(MIN_E))\n-    print(\"pub const MAX_E: i16 = {};\".format(MAX_E))\n-    print()\n-    print(\"#[rustfmt::skip]\")\n-    typ = \"([u64; {0}], [i16; {0}])\".format(len(powers))\n-    print(\"pub static POWERS: \", typ, \" = (\", sep='')\n-    print(\"    [\")\n-    for z in powers:\n-        print(\"        0x{:x},\".format(z.sig))\n-    print(\"    ],\")\n-    print(\"    [\")\n-    for z in powers:\n-        print(\"        {},\".format(z.exp))\n-    print(\"    ],\")\n-    print(\");\")\n-\n-\n-def print_short_powers(num_bits, significand_size):\n-    max_sig = 2**significand_size - 1\n-    # The fast path bails out for exponents >= ceil(log5(max_sig))\n-    max_e = int(ceil(log(max_sig, 5)))\n-    e_range = range(max_e)\n-    typ = \"[f{}; {}]\".format(num_bits, len(e_range))\n-    print(\"#[rustfmt::skip]\")\n-    print(\"pub const F\", num_bits, \"_SHORT_POWERS: \", typ, \" = [\", sep='')\n-    for e in e_range:\n-        print(\"    1e{},\".format(e))\n-    print(\"];\")\n+    for q in range(min_exp, 0):\n+        power5 = 5 ** -q\n+        z = 0\n+        while (1 << z) < power5:\n+            z += 1\n+        if q >= -27:\n+            b = z + 127\n+            c = 2 ** b // power5 + 1\n+            powers.append((c, q))\n+        else:\n+            b = 2 * z + 2 * 64\n+            c = 2 ** b // power5 + 1\n+            # truncate\n+            while c >= (1<<128):\n+                c //= 2\n+            powers.append((c, q))\n+\n+    # Add positive exponents\n+    for q in range(0, max_exp + 1):\n+        power5 = 5 ** q\n+        # move the most significant bit in position\n+        while power5 < (1<<127):\n+            power5 *= 2\n+        # *truncate*\n+        while power5 >= (1<<128):\n+            power5 //= 2\n+        powers.append((power5, q))\n+\n+    # Print the powers.\n+    print(STATIC_WARNING.strip())\n+    print('#[rustfmt::skip]')\n+    typ = '[(u64, u64); N_POWERS_OF_FIVE]'\n+    print('pub static POWER_OF_FIVE_128: {} = ['.format(typ))\n+    lo_mask = (1 << 64) - 1\n+    for c, exp in powers:\n+        hi = '0x{:x}'.format(c // (1 << 64))\n+        lo = '0x{:x}'.format(c % (1 << 64))\n+        value = '    ({}, {}), '.format(hi, lo)\n+        comment = '// {}^{}'.format(5, exp)\n+        print(value.ljust(46, ' ') + comment)\n+    print('];')\n \n \n if __name__ == '__main__':"}, {"sha": "8226e815c2c1e846f4dec07d07943076abc4e8e1", "filename": "src/etc/test-float-parse/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2FCargo.toml?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+name = \"test-float-parse\"\n+version = \"0.1.0\"\n+edition = \"2018\"\n+publish = false\n+\n+[workspace]\n+\n+[dependencies]\n+rand = \"0.4\"\n+\n+[lib]\n+name = \"test_float_parse\""}, {"sha": "cf7279534dc86edf3b099e187169023845f8c771", "filename": "src/etc/test-float-parse/runtests.py", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fruntests.py?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -131,22 +131,20 @@ def write_errors():\n             exit_status = 101\n \n \n-def rustc(test):\n-    rs = test + '.rs'\n-    exe = test + '.exe'  # hopefully this makes it work on *nix\n-    print(\"compiling\", test)\n+def cargo():\n+    print(\"compiling tests\")\n     sys.stdout.flush()\n-    check_call(['rustc', rs, '-o', exe])\n+    check_call(['cargo', 'build', '--release'])\n \n \n def run(test):\n     global test_name\n     test_name = test\n \n-    t0 = time.clock()\n+    t0 = time.perf_counter()\n     msg(\"setting up supervisor\")\n-    exe = test + '.exe'\n-    proc = Popen(exe, bufsize=1<<20 , stdin=PIPE, stdout=PIPE, stderr=PIPE)\n+    command = ['cargo', 'run', '--bin', test, '--release']\n+    proc = Popen(command, bufsize=1<<20 , stdin=PIPE, stdout=PIPE, stderr=PIPE)\n     done = multiprocessing.Value(ctypes.c_bool)\n     queue = multiprocessing.Queue(maxsize=5)#(maxsize=1024)\n     workers = []\n@@ -166,7 +164,7 @@ def run(test):\n         worker.join()\n     msg(\"python is done\")\n     assert queue.empty(), \"did not validate everything\"\n-    dt = time.clock() - t0\n+    dt = time.perf_counter() - t0\n     msg(\"took\", round(dt, 3), \"seconds\")\n \n \n@@ -176,7 +174,7 @@ def interact(proc, queue):\n         line = proc.stdout.readline()\n         if not line:\n             continue\n-        assert line.endswith('\\n'), \"incomplete line: \" + repr(line)\n+        assert line.endswith(b'\\n'), \"incomplete line: \" + repr(line)\n         queue.put(line)\n         n += 1\n         if n % UPDATE_EVERY_N == 0:\n@@ -185,26 +183,27 @@ def interact(proc, queue):\n     rest, stderr = proc.communicate()\n     if stderr:\n         msg(\"rust stderr output:\", stderr)\n-    for line in rest.split('\\n'):\n+    for line in rest.split(b'\\n'):\n         if not line:\n             continue\n         queue.put(line)\n \n \n def main():\n     global MAILBOX\n-    all_tests = [os.path.splitext(f)[0] for f in glob('*.rs') if not f.startswith('_')]\n+    files = glob('src/bin/*.rs')\n+    basenames = [os.path.basename(i) for i in files]\n+    all_tests = [os.path.splitext(f)[0] for f in basenames if not f.startswith('_')]\n     args = sys.argv[1:]\n     if args:\n         tests = [test for test in all_tests if test in args]\n-    else\n+    else:\n         tests = all_tests\n     if not tests:\n         print(\"Error: No tests to run\")\n         sys.exit(1)\n     # Compile first for quicker feedback\n-    for test in tests:\n-        rustc(test)\n+    cargo()\n     # Set up mailbox once for all tests\n     MAILBOX = multiprocessing.Queue()\n     mailman = threading.Thread(target=write_errors)\n@@ -251,7 +250,7 @@ def do_work(queue):\n             else:\n                 continue\n         bin64, bin32, text = line.rstrip().split()\n-        validate(bin64, bin32, text)\n+        validate(bin64, bin32, text.decode('utf-8'))\n \n \n def decode_binary64(x):\n@@ -331,7 +330,11 @@ def decode_binary32(x):\n SINGLE_INF_CUTOFF = MAX_SINGLE + 2 ** (MAX_ULP_SINGLE - 1)\n \n def validate(bin64, bin32, text):\n-    double = decode_binary64(bin64)\n+    try:\n+        double = decode_binary64(bin64)\n+    except AssertionError:\n+        print(bin64, bin32, text)\n+        raise\n     single = decode_binary32(bin32)\n     real = Fraction(text)\n "}, {"sha": "6bb406a5947713052ab466982fde50f932b653ea", "filename": "src/etc/test-float-parse/src/bin/few-ones.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Ffew-ones.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Ffew-ones.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Ffew-ones.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,6 +1,4 @@\n-mod _common;\n-\n-use _common::validate;\n+use test_float_parse::validate;\n \n fn main() {\n     let mut pow = vec![];", "previous_filename": "src/etc/test-float-parse/few-ones.rs"}, {"sha": "722a24ffcd8d995140081e671c053970bfb7b22e", "filename": "src/etc/test-float-parse/src/bin/huge-pow10.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fhuge-pow10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fhuge-pow10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fhuge-pow10.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,6 +1,4 @@\n-mod _common;\n-\n-use _common::validate;\n+use test_float_parse::validate;\n \n fn main() {\n     for e in 300..310 {", "previous_filename": "src/etc/test-float-parse/huge-pow10.rs"}, {"sha": "c715bc1ac2bd388c6804627d37e3f57b20d0a708", "filename": "src/etc/test-float-parse/src/bin/long-fractions.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Flong-fractions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Flong-fractions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Flong-fractions.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,7 +1,5 @@\n-mod _common;\n-\n-use _common::validate;\n use std::char;\n+use test_float_parse::validate;\n \n fn main() {\n     for n in 0..10 {", "previous_filename": "src/etc/test-float-parse/long-fractions.rs"}, {"sha": "ba166fd56079d0c40d425aa05e02507e61dace1b", "filename": "src/etc/test-float-parse/src/bin/many-digits.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fmany-digits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fmany-digits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fmany-digits.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,11 +1,9 @@\n extern crate rand;\n \n-mod _common;\n-\n-use _common::{validate, SEED};\n use rand::distributions::{Range, Sample};\n use rand::{IsaacRng, Rng, SeedableRng};\n use std::char;\n+use test_float_parse::{validate, SEED};\n \n fn main() {\n     let mut rnd = IsaacRng::from_seed(&SEED);", "previous_filename": "src/etc/test-float-parse/many-digits.rs"}, {"sha": "6991e8be15e1c5aaed49499e4734541041046336", "filename": "src/etc/test-float-parse/src/bin/rand-f64.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Frand-f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Frand-f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Frand-f64.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,10 +1,8 @@\n extern crate rand;\n \n-mod _common;\n-\n-use _common::{validate, SEED};\n use rand::{IsaacRng, Rng, SeedableRng};\n use std::mem::transmute;\n+use test_float_parse::{validate, SEED};\n \n fn main() {\n     let mut rnd = IsaacRng::from_seed(&SEED);", "previous_filename": "src/etc/test-float-parse/rand-f64.rs"}, {"sha": "49084eb35e8346d0cac600e0fae2e6c3bb4bc6e5", "filename": "src/etc/test-float-parse/src/bin/short-decimals.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fshort-decimals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fshort-decimals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fshort-decimals.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,6 +1,4 @@\n-mod _common;\n-\n-use _common::validate;\n+use test_float_parse::validate;\n \n fn main() {\n     // Skip e = 0 because small-u32 already does those.", "previous_filename": "src/etc/test-float-parse/short-decimals.rs"}, {"sha": "ac88747eacd35881520ad53557dc1cf2af17ccc0", "filename": "src/etc/test-float-parse/src/bin/subnorm.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fsubnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fsubnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fsubnorm.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,7 +1,5 @@\n-mod _common;\n-\n-use _common::validate;\n use std::mem::transmute;\n+use test_float_parse::validate;\n \n fn main() {\n     for bits in 0u32..(1 << 21) {", "previous_filename": "src/etc/test-float-parse/subnorm.rs"}, {"sha": "fb6ba166380443b8f58ff6248cce9dd0dc083bab", "filename": "src/etc/test-float-parse/src/bin/tiny-pow10.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Ftiny-pow10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Ftiny-pow10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Ftiny-pow10.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,6 +1,4 @@\n-mod _common;\n-\n-use _common::validate;\n+use test_float_parse::validate;\n \n fn main() {\n     for e in 301..327 {", "previous_filename": "src/etc/test-float-parse/tiny-pow10.rs"}, {"sha": "5ec9d1eea5fbee829a57f6ff2d8eff8c3ea7314c", "filename": "src/etc/test-float-parse/src/bin/u32-small.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fu32-small.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fu32-small.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fu32-small.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,6 +1,4 @@\n-mod _common;\n-\n-use _common::validate;\n+use test_float_parse::validate;\n \n fn main() {\n     for i in 0..(1 << 19) {", "previous_filename": "src/etc/test-float-parse/u32-small.rs"}, {"sha": "984e49200cda378863b3453b9144917271ce9955", "filename": "src/etc/test-float-parse/src/bin/u64-pow2.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fu64-pow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fu64-pow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fsrc%2Fbin%2Fu64-pow2.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -1,6 +1,4 @@\n-mod _common;\n-\n-use _common::validate;\n+use test_float_parse::validate;\n \n fn main() {\n     for exp in 19..64 {", "previous_filename": "src/etc/test-float-parse/u64-pow2.rs"}, {"sha": "9cbad5486b485d908c153f4d21b06319a7f50d6a", "filename": "src/etc/test-float-parse/src/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Fetc%2Ftest-float-parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fsrc%2Flib.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "previous_filename": "src/etc/test-float-parse/_common.rs"}, {"sha": "37c2390581973f726962e5c94ff50ee617743bea", "filename": "src/test/ui/issues/issue-31109.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2b04f075c0ce010758c4c8674152ff89d1d73f3/src%2Ftest%2Fui%2Fissues%2Fissue-31109.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b04f075c0ce010758c4c8674152ff89d1d73f3/src%2Ftest%2Fui%2Fissues%2Fissue-31109.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31109.rs?ref=d2b04f075c0ce010758c4c8674152ff89d1d73f3", "patch": "@@ -1,6 +0,0 @@\n-fn main() {\n-    // FIXME(#31407) this error should go away, but in the meantime we test that it\n-    // is accompanied by a somewhat useful error message.\n-    let _: f64 = 1234567890123456789012345678901234567890e-340;\n-    //~^ ERROR could not evaluate float literal (see issue #31407)\n-}"}, {"sha": "d354f61a50143a1cb056e9a106a2cda904326630", "filename": "src/test/ui/issues/issue-31109.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2b04f075c0ce010758c4c8674152ff89d1d73f3/src%2Ftest%2Fui%2Fissues%2Fissue-31109.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2b04f075c0ce010758c4c8674152ff89d1d73f3/src%2Ftest%2Fui%2Fissues%2Fissue-31109.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31109.stderr?ref=d2b04f075c0ce010758c4c8674152ff89d1d73f3", "patch": "@@ -1,8 +0,0 @@\n-error: could not evaluate float literal (see issue #31407)\n-  --> $DIR/issue-31109.rs:4:18\n-   |\n-LL |     let _: f64 = 1234567890123456789012345678901234567890e-340;\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "1e9319fd27d4816181fb8c80790c0af757ad29aa", "filename": "src/test/ui/parser/float-literals.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Ftest%2Fui%2Fparser%2Ffloat-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8752b403695a8830913571f0fd5ebfcf1483db37/src%2Ftest%2Fui%2Fparser%2Ffloat-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffloat-literals.rs?ref=8752b403695a8830913571f0fd5ebfcf1483db37", "patch": "@@ -0,0 +1,9 @@\n+// build-pass\n+// ignore-tidy-linelength\n+// Regression test for #31109 and #31407.\n+\n+pub fn main() {\n+    let _: f64 = 0.3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333;\n+\n+    let _: f64 = 1234567890123456789012345678901234567890e-340;\n+}"}, {"sha": "afc599a4b22b6a0efbedcaa4adeeb4f12fd700d2", "filename": "src/test/ui/pattern/issue-68396-let-float-bug.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2b04f075c0ce010758c4c8674152ff89d1d73f3/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b04f075c0ce010758c4c8674152ff89d1d73f3/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.rs?ref=d2b04f075c0ce010758c4c8674152ff89d1d73f3", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    let 1234567890123456789012345678901234567890e-340: f64 = 0.0;\n-    //~^ ERROR could not evaluate float literal (see issue #31407)\n-\n-    fn param(1234567890123456789012345678901234567890e-340: f64) {}\n-    //~^ ERROR could not evaluate float literal (see issue #31407)\n-}"}, {"sha": "618aa4b5021f10e3aa053633a3403056a465c0a1", "filename": "src/test/ui/pattern/issue-68396-let-float-bug.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d2b04f075c0ce010758c4c8674152ff89d1d73f3/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2b04f075c0ce010758c4c8674152ff89d1d73f3/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-68396-let-float-bug.stderr?ref=d2b04f075c0ce010758c4c8674152ff89d1d73f3", "patch": "@@ -1,15 +0,0 @@\n-error[E0080]: could not evaluate float literal (see issue #31407)\n-  --> $DIR/issue-68396-let-float-bug.rs:2:9\n-   |\n-LL |     let 1234567890123456789012345678901234567890e-340: f64 = 0.0;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0080]: could not evaluate float literal (see issue #31407)\n-  --> $DIR/issue-68396-let-float-bug.rs:5:14\n-   |\n-LL |     fn param(1234567890123456789012345678901234567890e-340: f64) {}\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0080`."}]}