{"sha": "78b2dd813a927012328bf870d680fe952c8157b9", "node_id": "C_kwDOAAsO6NoAKDc4YjJkZDgxM2E5MjcwMTIzMjhiZjg3MGQ2ODBmZTk1MmM4MTU3Yjk", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-03T18:32:18Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-03T19:43:10Z"}, "message": "Diagnose unresolved field accesses", "tree": {"sha": "3a7cb6acc0b3c644cf7141c99e3f569be5c71b9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a7cb6acc0b3c644cf7141c99e3f569be5c71b9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78b2dd813a927012328bf870d680fe952c8157b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78b2dd813a927012328bf870d680fe952c8157b9", "html_url": "https://github.com/rust-lang/rust/commit/78b2dd813a927012328bf870d680fe952c8157b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78b2dd813a927012328bf870d680fe952c8157b9/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c7a0aa00ee4d574af36a1ab982a63488acb211a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c7a0aa00ee4d574af36a1ab982a63488acb211a", "html_url": "https://github.com/rust-lang/rust/commit/3c7a0aa00ee4d574af36a1ab982a63488acb211a"}], "stats": {"total": 367, "additions": 273, "deletions": 94}, "files": [{"sha": "a663a568b919dce365f3dc9a2cccf2009e36aff1", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78b2dd813a927012328bf870d680fe952c8157b9/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b2dd813a927012328bf870d680fe952c8157b9/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=78b2dd813a927012328bf870d680fe952c8157b9", "patch": "@@ -31,7 +31,7 @@ use hir_def::{\n     AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule,\n     ItemContainerId, Lookup, TraitId, TypeAliasId, VariantId,\n };\n-use hir_expand::name::name;\n+use hir_expand::name::{name, Name};\n use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n use stdx::always;\n@@ -167,6 +167,7 @@ pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n     PrivateField { expr: ExprId, field: FieldId },\n     PrivateAssocItem { id: ExprOrPatId, item: AssocItemId },\n+    UnresolvedField { expr: ExprId, receiver: Ty, name: Name, method_with_same_name_exists: bool },\n     // FIXME: Make this proper\n     BreakOutsideOfLoop { expr: ExprId, is_break: bool, bad_value_break: bool },\n     MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n@@ -506,14 +507,17 @@ impl<'a> InferenceContext<'a> {\n             mismatch.expected = table.resolve_completely(mismatch.expected.clone());\n             mismatch.actual = table.resolve_completely(mismatch.actual.clone());\n         }\n-        for diagnostic in &mut result.diagnostics {\n-            match diagnostic {\n-                InferenceDiagnostic::ExpectedFunction { found, .. } => {\n-                    *found = table.resolve_completely(found.clone())\n+        result.diagnostics.retain_mut(|diagnostic| {\n+            if let InferenceDiagnostic::ExpectedFunction { found: ty, .. }\n+            | InferenceDiagnostic::UnresolvedField { receiver: ty, .. } = diagnostic\n+            {\n+                *ty = table.resolve_completely(ty.clone());\n+                if ty.is_unknown() {\n+                    return false;\n                 }\n-                _ => (),\n             }\n-        }\n+            true\n+        });\n         for (_, subst) in result.method_resolutions.values_mut() {\n             *subst = table.resolve_completely(subst.clone());\n         }"}, {"sha": "531a359a96a41b88dd86c68b455ff6848c2f3e04", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 87, "deletions": 65, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/78b2dd813a927012328bf870d680fe952c8157b9/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b2dd813a927012328bf870d680fe952c8157b9/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=78b2dd813a927012328bf870d680fe952c8157b9", "patch": "@@ -552,71 +552,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 ty\n             }\n-            Expr::Field { expr, name } => {\n-                let receiver_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-\n-                let mut autoderef = Autoderef::new(&mut self.table, receiver_ty);\n-                let mut private_field = None;\n-                let ty = autoderef.by_ref().find_map(|(derefed_ty, _)| {\n-                    let (field_id, parameters) = match derefed_ty.kind(Interner) {\n-                        TyKind::Tuple(_, substs) => {\n-                            return name.as_tuple_index().and_then(|idx| {\n-                                substs\n-                                    .as_slice(Interner)\n-                                    .get(idx)\n-                                    .map(|a| a.assert_ty_ref(Interner))\n-                                    .cloned()\n-                            });\n-                        }\n-                        TyKind::Adt(AdtId(hir_def::AdtId::StructId(s)), parameters) => {\n-                            let local_id = self.db.struct_data(*s).variant_data.field(name)?;\n-                            let field = FieldId { parent: (*s).into(), local_id };\n-                            (field, parameters.clone())\n-                        }\n-                        TyKind::Adt(AdtId(hir_def::AdtId::UnionId(u)), parameters) => {\n-                            let local_id = self.db.union_data(*u).variant_data.field(name)?;\n-                            let field = FieldId { parent: (*u).into(), local_id };\n-                            (field, parameters.clone())\n-                        }\n-                        _ => return None,\n-                    };\n-                    let is_visible = self.db.field_visibilities(field_id.parent)[field_id.local_id]\n-                        .is_visible_from(self.db.upcast(), self.resolver.module());\n-                    if !is_visible {\n-                        if private_field.is_none() {\n-                            private_field = Some(field_id);\n-                        }\n-                        return None;\n-                    }\n-                    // can't have `write_field_resolution` here because `self.table` is borrowed :(\n-                    self.result.field_resolutions.insert(tgt_expr, field_id);\n-                    let ty = self.db.field_types(field_id.parent)[field_id.local_id]\n-                        .clone()\n-                        .substitute(Interner, &parameters);\n-                    Some(ty)\n-                });\n-                let ty = match ty {\n-                    Some(ty) => {\n-                        let adjustments = auto_deref_adjust_steps(&autoderef);\n-                        self.write_expr_adj(*expr, adjustments);\n-                        let ty = self.insert_type_vars(ty);\n-                        let ty = self.normalize_associated_types_in(ty);\n-                        ty\n-                    }\n-                    _ => {\n-                        // Write down the first private field resolution if we found no field\n-                        // This aids IDE features for private fields like goto def\n-                        if let Some(field) = private_field {\n-                            self.result.field_resolutions.insert(tgt_expr, field);\n-                            self.result\n-                                .diagnostics\n-                                .push(InferenceDiagnostic::PrivateField { expr: tgt_expr, field });\n-                        }\n-                        self.err_ty()\n-                    }\n-                };\n-                ty\n-            }\n+            Expr::Field { expr, name } => self.infer_field_access(tgt_expr, *expr, name),\n             Expr::Await { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 self.resolve_associated_type(inner_ty, self.resolve_future_future_output())\n@@ -1276,6 +1212,92 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n+    fn infer_field_access(&mut self, tgt_expr: ExprId, expr: ExprId, name: &Name) -> Ty {\n+        let receiver_ty = self.infer_expr_inner(expr, &Expectation::none());\n+\n+        let mut autoderef = Autoderef::new(&mut self.table, receiver_ty.clone());\n+        let mut private_field = None;\n+        let ty = autoderef.by_ref().find_map(|(derefed_ty, _)| {\n+            let (field_id, parameters) = match derefed_ty.kind(Interner) {\n+                TyKind::Tuple(_, substs) => {\n+                    return name.as_tuple_index().and_then(|idx| {\n+                        substs\n+                            .as_slice(Interner)\n+                            .get(idx)\n+                            .map(|a| a.assert_ty_ref(Interner))\n+                            .cloned()\n+                    });\n+                }\n+                TyKind::Adt(AdtId(hir_def::AdtId::StructId(s)), parameters) => {\n+                    let local_id = self.db.struct_data(*s).variant_data.field(name)?;\n+                    let field = FieldId { parent: (*s).into(), local_id };\n+                    (field, parameters.clone())\n+                }\n+                TyKind::Adt(AdtId(hir_def::AdtId::UnionId(u)), parameters) => {\n+                    let local_id = self.db.union_data(*u).variant_data.field(name)?;\n+                    let field = FieldId { parent: (*u).into(), local_id };\n+                    (field, parameters.clone())\n+                }\n+                _ => return None,\n+            };\n+            let is_visible = self.db.field_visibilities(field_id.parent)[field_id.local_id]\n+                .is_visible_from(self.db.upcast(), self.resolver.module());\n+            if !is_visible {\n+                if private_field.is_none() {\n+                    private_field = Some(field_id);\n+                }\n+                return None;\n+            }\n+            // can't have `write_field_resolution` here because `self.table` is borrowed :(\n+            self.result.field_resolutions.insert(tgt_expr, field_id);\n+            let ty = self.db.field_types(field_id.parent)[field_id.local_id]\n+                .clone()\n+                .substitute(Interner, &parameters);\n+            Some(ty)\n+        });\n+        let ty = match ty {\n+            Some(ty) => {\n+                let adjustments = auto_deref_adjust_steps(&autoderef);\n+                self.write_expr_adj(expr, adjustments);\n+                let ty = self.insert_type_vars(ty);\n+                let ty = self.normalize_associated_types_in(ty);\n+                ty\n+            }\n+            _ => {\n+                // Write down the first private field resolution if we found no field\n+                // This aids IDE features for private fields like goto def\n+                if let Some(field) = private_field {\n+                    self.result.field_resolutions.insert(tgt_expr, field);\n+                    // FIXME: Merge this diagnostic into UnresolvedField\n+                    self.result\n+                        .diagnostics\n+                        .push(InferenceDiagnostic::PrivateField { expr: tgt_expr, field });\n+                } else {\n+                    // no field found, try looking for a method of the same name\n+                    let canonicalized_receiver = self.canonicalize(receiver_ty.clone());\n+                    let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n+\n+                    let resolved = method_resolution::lookup_method(\n+                        self.db,\n+                        &canonicalized_receiver.value,\n+                        self.trait_env.clone(),\n+                        &traits_in_scope,\n+                        VisibleFromModule::Filter(self.resolver.module()),\n+                        name,\n+                    );\n+                    self.result.diagnostics.push(InferenceDiagnostic::UnresolvedField {\n+                        expr: tgt_expr,\n+                        receiver: receiver_ty,\n+                        name: name.clone(),\n+                        method_with_same_name_exists: resolved.is_some(),\n+                    });\n+                }\n+                self.err_ty()\n+            }\n+        };\n+        ty\n+    }\n+\n     fn infer_method_call(\n         &mut self,\n         tgt_expr: ExprId,"}, {"sha": "58d02479e57c670cf665e9a0e3d5d126448b58fa", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/78b2dd813a927012328bf870d680fe952c8157b9/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b2dd813a927012328bf870d680fe952c8157b9/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=78b2dd813a927012328bf870d680fe952c8157b9", "patch": "@@ -48,6 +48,7 @@ diagnostics![\n     TypeMismatch,\n     UnimplementedBuiltinMacro,\n     UnresolvedExternCrate,\n+    UnresolvedField,\n     UnresolvedImport,\n     UnresolvedMacroCall,\n     UnresolvedModule,\n@@ -137,6 +138,14 @@ pub struct ExpectedFunction {\n     pub found: Type,\n }\n \n+#[derive(Debug)]\n+pub struct UnresolvedField {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub receiver: Type,\n+    pub name: Name,\n+    pub method_with_same_name_exists: bool,\n+}\n+\n #[derive(Debug)]\n pub struct PrivateField {\n     pub expr: InFile<AstPtr<ast::Expr>>,"}, {"sha": "bac6d4cd85407cf86f905bbac77a160006bacede", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/78b2dd813a927012328bf870d680fe952c8157b9/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b2dd813a927012328bf870d680fe952c8157b9/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=78b2dd813a927012328bf870d680fe952c8157b9", "patch": "@@ -88,8 +88,8 @@ pub use crate::{\n         InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n         MissingMatchArms, MissingUnsafe, NoSuchField, PrivateAssocItem, PrivateField,\n         ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n-        UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n-        UnresolvedProcMacro,\n+        UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n+        UnresolvedModule, UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -1375,6 +1375,7 @@ impl DefWithBody {\n \n         let infer = db.infer(self.into());\n         let source_map = Lazy::new(|| db.body_with_source_map(self.into()).1);\n+        let expr_syntax = |expr| source_map.expr_syntax(expr).expect(\"unexpected synthetic\");\n         for d in &infer.diagnostics {\n             match d {\n                 &hir_ty::InferenceDiagnostic::NoSuchField { expr } => {\n@@ -1386,30 +1387,23 @@ impl DefWithBody {\n                     is_break,\n                     bad_value_break,\n                 } => {\n-                    let expr = source_map\n-                        .expr_syntax(expr)\n-                        .expect(\"break outside of loop in synthetic syntax\");\n+                    let expr = expr_syntax(expr);\n                     acc.push(BreakOutsideOfLoop { expr, is_break, bad_value_break }.into())\n                 }\n                 &hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n-                    match source_map.expr_syntax(call_expr) {\n-                        Ok(source_ptr) => acc.push(\n-                            MismatchedArgCount { call_expr: source_ptr, expected, found }.into(),\n-                        ),\n-                        Err(SyntheticSyntax) => (),\n-                    }\n+                    acc.push(\n+                        MismatchedArgCount { call_expr: expr_syntax(call_expr), expected, found }\n+                            .into(),\n+                    )\n                 }\n                 &hir_ty::InferenceDiagnostic::PrivateField { expr, field } => {\n-                    let expr = source_map.expr_syntax(expr).expect(\"unexpected synthetic\");\n+                    let expr = expr_syntax(expr);\n                     let field = field.into();\n                     acc.push(PrivateField { expr, field }.into())\n                 }\n                 &hir_ty::InferenceDiagnostic::PrivateAssocItem { id, item } => {\n                     let expr_or_pat = match id {\n-                        ExprOrPatId::ExprId(expr) => source_map\n-                            .expr_syntax(expr)\n-                            .expect(\"unexpected synthetic\")\n-                            .map(Either::Left),\n+                        ExprOrPatId::ExprId(expr) => expr_syntax(expr).map(Either::Left),\n                         ExprOrPatId::PatId(pat) => source_map\n                             .pat_syntax(pat)\n                             .expect(\"unexpected synthetic\")\n@@ -1419,8 +1413,7 @@ impl DefWithBody {\n                     acc.push(PrivateAssocItem { expr_or_pat, item }.into())\n                 }\n                 hir_ty::InferenceDiagnostic::ExpectedFunction { call_expr, found } => {\n-                    let call_expr =\n-                        source_map.expr_syntax(*call_expr).expect(\"unexpected synthetic\");\n+                    let call_expr = expr_syntax(*call_expr);\n \n                     acc.push(\n                         ExpectedFunction {\n@@ -1430,6 +1423,24 @@ impl DefWithBody {\n                         .into(),\n                     )\n                 }\n+                hir_ty::InferenceDiagnostic::UnresolvedField {\n+                    expr,\n+                    receiver,\n+                    name,\n+                    method_with_same_name_exists,\n+                } => {\n+                    let expr = expr_syntax(*expr);\n+\n+                    acc.push(\n+                        UnresolvedField {\n+                            expr,\n+                            name: name.clone(),\n+                            receiver: Type::new(db, DefWithBodyId::from(self), receiver.clone()),\n+                            method_with_same_name_exists: *method_with_same_name_exists,\n+                        }\n+                        .into(),\n+                    )\n+                }\n             }\n         }\n         for (pat_or_expr, mismatch) in infer.type_mismatches() {"}, {"sha": "0979f6a6dfc7d492e8b5bc619a719d572b9faf8f", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/78b2dd813a927012328bf870d680fe952c8157b9/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b2dd813a927012328bf870d680fe952c8157b9/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=78b2dd813a927012328bf870d680fe952c8157b9", "patch": "@@ -5,10 +5,7 @@ use ide_db::imports::{\n     insert_use::ImportScope,\n };\n use itertools::Itertools;\n-use syntax::{\n-    ast::{self},\n-    AstNode, SyntaxNode, T,\n-};\n+use syntax::{ast, AstNode, SyntaxNode, T};\n \n use crate::{\n     context::{"}, {"sha": "33c39de085d8ebda5180106a607951336c385d04", "filename": "crates/ide-diagnostics/src/handlers/unresolved_field.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/78b2dd813a927012328bf870d680fe952c8157b9/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b2dd813a927012328bf870d680fe952c8157b9/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs?ref=78b2dd813a927012328bf870d680fe952c8157b9", "patch": "@@ -0,0 +1,134 @@\n+use hir::{db::AstDatabase, HirDisplay, InFile};\n+use ide_db::{\n+    assists::{Assist, AssistId, AssistKind},\n+    base_db::FileRange,\n+    label::Label,\n+    source_change::SourceChange,\n+};\n+use syntax::{ast, AstNode, AstPtr};\n+use text_edit::TextEdit;\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: unresolved-field\n+//\n+// This diagnostic is triggered if a field does not exist on a given type.\n+pub(crate) fn unresolved_field(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnresolvedField,\n+) -> Diagnostic {\n+    let method_suffix = if d.method_with_same_name_exists {\n+        \", but a method with a similar name exists\"\n+    } else {\n+        \"\"\n+    };\n+    Diagnostic::new(\n+        \"unresolved-field\",\n+        format!(\n+            \"no field `{}` on type `{}`{method_suffix}\",\n+            d.name,\n+            d.receiver.display(ctx.sema.db)\n+        ),\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedField) -> Option<Vec<Assist>> {\n+    if d.method_with_same_name_exists {\n+        method_fix(ctx, &d.expr)\n+    } else {\n+        // FIXME: add quickfix\n+\n+        None\n+    }\n+}\n+\n+// FIXME: We should fill out the call here, mvoe the cursor and trigger signature help\n+fn method_fix(\n+    ctx: &DiagnosticsContext<'_>,\n+    expr_ptr: &InFile<AstPtr<ast::Expr>>,\n+) -> Option<Vec<Assist>> {\n+    let root = ctx.sema.db.parse_or_expand(expr_ptr.file_id)?;\n+    let expr = expr_ptr.value.to_node(&root);\n+    let FileRange { range, file_id } = ctx.sema.original_range_opt(expr.syntax())?;\n+    Some(vec![Assist {\n+        id: AssistId(\"expected-field-found-method-call-fix\", AssistKind::QuickFix),\n+        label: Label::new(\"Use parentheses to call the method\".to_string()),\n+        group: None,\n+        target: range,\n+        source_change: Some(SourceChange::from_text_edit(\n+            file_id,\n+            TextEdit::insert(range.end(), \"()\".to_owned()),\n+        )),\n+        trigger_signature_help: false,\n+    }])\n+}\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn smoke_test() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    ().foo;\n+ // ^^^^^^ error: no field `foo` on type `()`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_clash() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo;\n+impl Foo {\n+    fn bar(&self) {}\n+}\n+fn foo() {\n+    Foo.bar;\n+ // ^^^^^^^ \ud83d\udca1 error: no field `bar` on type `Foo`, but a method with a similar name exists\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_trait_() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo;\n+trait Bar {\n+    fn bar(&self) {}\n+}\n+impl Bar for Foo {}\n+fn foo() {\n+    Foo.bar;\n+ // ^^^^^^^ \ud83d\udca1 error: no field `bar` on type `Foo`, but a method with a similar name exists\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_trait_2() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo;\n+trait Bar {\n+    fn bar(&self);\n+}\n+impl Bar for Foo {\n+    fn bar(&self) {}\n+}\n+fn foo() {\n+    Foo.bar;\n+ // ^^^^^^^ \ud83d\udca1 error: no field `bar` on type `Foo`, but a method with a similar name exists\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "a0e8bca5cb9094578a1010bf6287b2346cdc53b5", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78b2dd813a927012328bf870d680fe952c8157b9/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78b2dd813a927012328bf870d680fe952c8157b9/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=78b2dd813a927012328bf870d680fe952c8157b9", "patch": "@@ -44,6 +44,7 @@ mod handlers {\n     pub(crate) mod type_mismatch;\n     pub(crate) mod unimplemented_builtin_macro;\n     pub(crate) mod unresolved_extern_crate;\n+    pub(crate) mod unresolved_field;\n     pub(crate) mod unresolved_import;\n     pub(crate) mod unresolved_macro_call;\n     pub(crate) mod unresolved_module;\n@@ -269,6 +270,7 @@ pub fn diagnostics(\n             AnyDiagnostic::UnresolvedModule(d) => handlers::unresolved_module::unresolved_module(&ctx, &d),\n             AnyDiagnostic::UnresolvedProcMacro(d) => handlers::unresolved_proc_macro::unresolved_proc_macro(&ctx, &d, config.proc_macros_enabled, config.proc_attr_macros_enabled),\n             AnyDiagnostic::InvalidDeriveTarget(d) => handlers::invalid_derive_target::invalid_derive_target(&ctx, &d),\n+            AnyDiagnostic::UnresolvedField(d) => handlers::unresolved_field::unresolved_field(&ctx, &d),\n \n             AnyDiagnostic::InactiveCode(d) => match handlers::inactive_code::inactive_code(&ctx, &d) {\n                 Some(it) => it,"}]}