{"sha": "22899555463a9e813801af60eec8f11839672c54", "node_id": "C_kwDOAAsO6NoAKDIyODk5NTU1NDYzYTllODEzODAxYWY2MGVlYzhmMTE4Mzk2NzJjNTQ", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-08-06T20:17:40Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-08-06T20:20:04Z"}, "message": "rustdoc: do not mark the contents of a skipped module as inlined", "tree": {"sha": "1ecf0e07d50a580a35f345d5fe628f46fbb87104", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ecf0e07d50a580a35f345d5fe628f46fbb87104"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22899555463a9e813801af60eec8f11839672c54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22899555463a9e813801af60eec8f11839672c54", "html_url": "https://github.com/rust-lang/rust/commit/22899555463a9e813801af60eec8f11839672c54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22899555463a9e813801af60eec8f11839672c54/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c54be35c63a883d5114cdbc50e07194e5cece0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c54be35c63a883d5114cdbc50e07194e5cece0f", "html_url": "https://github.com/rust-lang/rust/commit/5c54be35c63a883d5114cdbc50e07194e5cece0f"}], "stats": {"total": 91, "additions": 70, "deletions": 21}, "files": [{"sha": "58d0aedb0239955eee4bcf23914679e2d0bba9e0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/22899555463a9e813801af60eec8f11839672c54/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22899555463a9e813801af60eec8f11839672c54/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=22899555463a9e813801af60eec8f11839672c54", "patch": "@@ -145,6 +145,7 @@ pub(crate) fn try_inline_glob(\n     cx: &mut DocContext<'_>,\n     res: Res,\n     visited: &mut FxHashSet<DefId>,\n+    inlined_names: &mut FxHashSet<(ItemType, Symbol)>,\n ) -> Option<Vec<clean::Item>> {\n     let did = res.opt_def_id()?;\n     if did.is_local() {\n@@ -153,8 +154,17 @@ pub(crate) fn try_inline_glob(\n \n     match res {\n         Res::Def(DefKind::Mod, did) => {\n-            let m = build_module(cx, did, visited);\n-            Some(m.items)\n+            let mut items = build_module_items(cx, did, visited, inlined_names);\n+            items.drain_filter(|item| {\n+                if let Some(name) = item.name {\n+                    // If an item with the same type and name already exists,\n+                    // it takes priority over the inlined stuff.\n+                    !inlined_names.insert((item.type_(), name))\n+                } else {\n+                    false\n+                }\n+            });\n+            Some(items)\n         }\n         // glob imports on things like enums aren't inlined even for local exports, so just bail\n         _ => None,\n@@ -517,6 +527,18 @@ fn build_module(\n     did: DefId,\n     visited: &mut FxHashSet<DefId>,\n ) -> clean::Module {\n+    let items = build_module_items(cx, did, visited, &mut FxHashSet::default());\n+\n+    let span = clean::Span::new(cx.tcx.def_span(did));\n+    clean::Module { items, span }\n+}\n+\n+fn build_module_items(\n+    cx: &mut DocContext<'_>,\n+    did: DefId,\n+    visited: &mut FxHashSet<DefId>,\n+    inlined_names: &mut FxHashSet<(ItemType, Symbol)>,\n+) -> Vec<clean::Item> {\n     let mut items = Vec::new();\n \n     // If we're re-exporting a re-export it may actually re-export something in\n@@ -526,7 +548,13 @@ fn build_module(\n         if item.vis.is_public() {\n             let res = item.res.expect_non_local();\n             if let Some(def_id) = res.mod_def_id() {\n-                if did == def_id || !visited.insert(def_id) {\n+                // If we're inlining a glob import, it's possible to have\n+                // two distinct modules with the same name. We don't want to\n+                // inline it, or mark any of its contents as visited.\n+                if did == def_id\n+                    || inlined_names.contains(&(ItemType::Module, item.ident.name))\n+                    || !visited.insert(def_id)\n+                {\n                     continue;\n                 }\n             }\n@@ -563,8 +591,7 @@ fn build_module(\n         }\n     }\n \n-    let span = clean::Span::new(cx.tcx.def_span(did));\n-    clean::Module { items, span }\n+    items\n }\n \n pub(crate) fn print_inlined_const(tcx: TyCtxt<'_>, did: DefId) -> String {"}, {"sha": "e18b0c2a77f979c5a9dc73163ab56e82062b6407", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/22899555463a9e813801af60eec8f11839672c54/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22899555463a9e813801af60eec8f11839672c54/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=22899555463a9e813801af60eec8f11839672c54", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> Clean<'tcx, Item> for DocModule<'tcx> {\n         // priority to the not-imported one, so we should, too.\n         items.extend(self.items.iter().flat_map(|(item, renamed)| {\n             // First, lower everything other than imports.\n-            if matches!(item.kind, hir::ItemKind::Use(..)) {\n+            if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n                 return Vec::new();\n             }\n             let v = clean_maybe_renamed_item(cx, item, *renamed);\n@@ -84,20 +84,13 @@ impl<'tcx> Clean<'tcx, Item> for DocModule<'tcx> {\n         }));\n         items.extend(self.items.iter().flat_map(|(item, renamed)| {\n             // Now we actually lower the imports, skipping everything else.\n-            if !matches!(item.kind, hir::ItemKind::Use(..)) {\n-                return Vec::new();\n+            if let hir::ItemKind::Use(path, hir::UseKind::Glob) = item.kind {\n+                let name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n+                clean_use_statement(item, name, path, hir::UseKind::Glob, cx, &mut inserted)\n+            } else {\n+                // skip everything else\n+                Vec::new()\n             }\n-            let mut v = clean_maybe_renamed_item(cx, item, *renamed);\n-            v.drain_filter(|item| {\n-                if let Some(name) = item.name {\n-                    // If an item with the same type and name already exists,\n-                    // it takes priority over the inlined stuff.\n-                    !inserted.insert((item.type_(), name))\n-                } else {\n-                    false\n-                }\n-            });\n-            v\n         }));\n \n         // determine if we should display the inner contents or\n@@ -1962,7 +1955,7 @@ fn clean_maybe_renamed_item<'tcx>(\n                 return clean_extern_crate(item, name, orig_name, cx);\n             }\n             ItemKind::Use(path, kind) => {\n-                return clean_use_statement(item, name, path, kind, cx);\n+                return clean_use_statement(item, name, path, kind, cx, &mut FxHashSet::default());\n             }\n             _ => unreachable!(\"not yet converted\"),\n         };\n@@ -2083,6 +2076,7 @@ fn clean_use_statement<'tcx>(\n     path: &hir::Path<'tcx>,\n     kind: hir::UseKind,\n     cx: &mut DocContext<'tcx>,\n+    inlined_names: &mut FxHashSet<(ItemType, Symbol)>,\n ) -> Vec<Item> {\n     // We need this comparison because some imports (for std types for example)\n     // are \"inserted\" as well but directly by the compiler and they should not be\n@@ -2148,7 +2142,8 @@ fn clean_use_statement<'tcx>(\n     let inner = if kind == hir::UseKind::Glob {\n         if !denied {\n             let mut visited = FxHashSet::default();\n-            if let Some(items) = inline::try_inline_glob(cx, path.res, &mut visited) {\n+            if let Some(items) = inline::try_inline_glob(cx, path.res, &mut visited, inlined_names)\n+            {\n                 return items;\n             }\n         }"}, {"sha": "df1b59069be994b4783fa6e8f0883bf777043e07", "filename": "src/test/rustdoc/auxiliary/issue-100204-aux.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/22899555463a9e813801af60eec8f11839672c54/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-100204-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22899555463a9e813801af60eec8f11839672c54/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-100204-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-100204-aux.rs?ref=22899555463a9e813801af60eec8f11839672c54", "patch": "@@ -0,0 +1,13 @@\n+#![crate_name=\"first\"]\n+\n+pub mod prelude {\n+    pub use crate::Bot;\n+}\n+\n+pub struct Bot;\n+\n+impl Bot {\n+    pub fn new() -> Bot {\n+        Bot\n+    }\n+}"}, {"sha": "3e20c5c0741efaa045855fd6944d28c3f09b4a58", "filename": "src/test/rustdoc/issue-100204-inline-impl-through-glob-import.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/22899555463a9e813801af60eec8f11839672c54/src%2Ftest%2Frustdoc%2Fissue-100204-inline-impl-through-glob-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22899555463a9e813801af60eec8f11839672c54/src%2Ftest%2Frustdoc%2Fissue-100204-inline-impl-through-glob-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-100204-inline-impl-through-glob-import.rs?ref=22899555463a9e813801af60eec8f11839672c54", "patch": "@@ -0,0 +1,14 @@\n+// aux-build:issue-100204-aux.rs\n+// build-aux-docs\n+// ignore-cross-compile\n+\n+#![crate_name=\"second\"]\n+\n+extern crate first;\n+\n+pub mod prelude {}\n+\n+// @has first/struct.Bot.html '//h4[@class=\"code-header\"]' 'pub fn new() -> Bot'\n+// @has second/struct.Bot.html '//h4[@class=\"code-header\"]' 'pub fn new() -> Bot'\n+#[doc(inline)]\n+pub use first::*;"}]}