{"sha": "136eaa1b25d13635b773a481ecab61a3162cb627", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNmVhYTFiMjVkMTM2MzViNzczYTQ4MWVjYWI2MWEzMTYyY2I2Mjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-14T12:06:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-14T12:06:34Z"}, "message": "Auto merge of #87375 - fee1-dead:move-constness-to-traitpred, r=oli-obk\n\nTry filtering out non-const impls when we expect const impls\n\n**TL;DR**: Associated types on const impls are now bounded; we now disallow calling a const function with bounds when the specified type param only has a non-const impl.\n\nr? `@oli-obk`", "tree": {"sha": "a381f4c235d7c028d37f3c98644d847cde643bce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a381f4c235d7c028d37f3c98644d847cde643bce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/136eaa1b25d13635b773a481ecab61a3162cb627", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/136eaa1b25d13635b773a481ecab61a3162cb627", "html_url": "https://github.com/rust-lang/rust/commit/136eaa1b25d13635b773a481ecab61a3162cb627", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/136eaa1b25d13635b773a481ecab61a3162cb627/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa2692990c05652c7823c8d2afae501a00a69050", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa2692990c05652c7823c8d2afae501a00a69050", "html_url": "https://github.com/rust-lang/rust/commit/fa2692990c05652c7823c8d2afae501a00a69050"}, {"sha": "74627c17c5fab9de9d634ad29166000d127170ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/74627c17c5fab9de9d634ad29166000d127170ca", "html_url": "https://github.com/rust-lang/rust/commit/74627c17c5fab9de9d634ad29166000d127170ca"}], "stats": {"total": 728, "additions": 517, "deletions": 211}, "files": [{"sha": "3879d6052922a6959b3f442fbd1ccf3b60125153", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -2751,6 +2751,15 @@ pub enum Constness {\n     NotConst,\n }\n \n+impl fmt::Display for Constness {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match *self {\n+            Self::Const => \"const\",\n+            Self::NotConst => \"non-const\",\n+        })\n+    }\n+}\n+\n #[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n@@ -3252,8 +3261,13 @@ impl<'hir> Node<'hir> {\n         }\n     }\n \n-    /// Returns `Constness::Const` when this node is a const fn/impl.\n-    pub fn constness(&self) -> Constness {\n+    /// Returns `Constness::Const` when this node is a const fn/impl/item,\n+    ///\n+    /// HACK(fee1-dead): or an associated type in a trait. This works because\n+    /// only typeck cares about const trait predicates, so although the predicates\n+    /// query would return const predicates when it does not need to be const,\n+    /// it wouldn't have any effect.\n+    pub fn constness_for_typeck(&self) -> Constness {\n         match self {\n             Node::Item(Item {\n                 kind: ItemKind::Fn(FnSig { header: FnHeader { constness, .. }, .. }, ..),\n@@ -3269,6 +3283,11 @@ impl<'hir> Node<'hir> {\n             })\n             | Node::Item(Item { kind: ItemKind::Impl(Impl { constness, .. }), .. }) => *constness,\n \n+            Node::Item(Item { kind: ItemKind::Const(..), .. })\n+            | Node::TraitItem(TraitItem { kind: TraitItemKind::Const(..), .. })\n+            | Node::TraitItem(TraitItem { kind: TraitItemKind::Type(..), .. })\n+            | Node::ImplItem(ImplItem { kind: ImplItemKind::Const(..), .. }) => Constness::Const,\n+\n             _ => Constness::NotConst,\n         }\n     }"}, {"sha": "d60388b31c13c878f48ff6abf4eb502de39583a4", "filename": "compiler/rustc_infer/src/traits/engine.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -1,5 +1,6 @@\n use crate::infer::InferCtxt;\n use crate::traits::Obligation;\n+use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, ToPredicate, Ty, WithConstness};\n \n@@ -49,11 +50,28 @@ pub trait TraitEngine<'tcx>: 'tcx {\n         infcx: &InferCtxt<'_, 'tcx>,\n     ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n \n+    fn select_all_with_constness_or_error(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        _constness: hir::Constness,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n+        self.select_all_or_error(infcx)\n+    }\n+\n     fn select_where_possible(\n         &mut self,\n         infcx: &InferCtxt<'_, 'tcx>,\n     ) -> Result<(), Vec<FulfillmentError<'tcx>>>;\n \n+    // FIXME this should not provide a default body for chalk as chalk should be updated\n+    fn select_with_constness_where_possible(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        _constness: hir::Constness,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n+        self.select_where_possible(infcx)\n+    }\n+\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>>;\n }\n "}, {"sha": "3139e12116373ee37c012baaba36a206892691f6", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -124,7 +124,7 @@ impl Elaborator<'tcx> {\n \n         let bound_predicate = obligation.predicate.kind();\n         match bound_predicate.skip_binder() {\n-            ty::PredicateKind::Trait(data, _) => {\n+            ty::PredicateKind::Trait(data) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n "}, {"sha": "2c039b6d05d29a44ba6d451f051688442fba0585", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -87,7 +87,7 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n         let predicates = cx.tcx.explicit_predicates_of(item.def_id);\n         for &(predicate, span) in predicates.predicates {\n             let trait_predicate = match predicate.kind().skip_binder() {\n-                Trait(trait_predicate, _constness) => trait_predicate,\n+                Trait(trait_predicate) => trait_predicate,\n                 _ => continue,\n             };\n             let def_id = trait_predicate.trait_ref.def_id;"}, {"sha": "2d2897f3f9899bb1716cc4676e1c763e318d7469", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -211,7 +211,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     let mut has_emitted = false;\n                     for &(predicate, _) in cx.tcx.explicit_item_bounds(def) {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n-                        if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) =\n+                        if let ty::PredicateKind::Trait(ref poly_trait_predicate) =\n                             predicate.kind().skip_binder()\n                         {\n                             let def_id = poly_trait_predicate.trait_ref.def_id;"}, {"sha": "924568a01a7de8d8dc4521c2dcbe4d3e62f28ca4", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -12,12 +12,12 @@ use rustc_hir::def_id::DefId;\n use rustc_query_system::cache::Cache;\n \n pub type SelectionCache<'tcx> = Cache<\n-    ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>,\n+    ty::ConstnessAnd<ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>>,\n     SelectionResult<'tcx, SelectionCandidate<'tcx>>,\n >;\n \n pub type EvaluationCache<'tcx> =\n-    Cache<ty::ParamEnvAnd<'tcx, ty::PolyTraitRef<'tcx>>, EvaluationResult>;\n+    Cache<ty::ParamEnvAnd<'tcx, ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>>, EvaluationResult>;\n \n /// The selection process begins by considering all impls, where\n /// clauses, and so forth that might resolve an obligation. Sometimes"}, {"sha": "5cb2b90fe1116bb7a424ee59332f5008bfb3e8d0", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -16,6 +16,13 @@ pub enum AssocItemContainer {\n }\n \n impl AssocItemContainer {\n+    pub fn impl_def_id(&self) -> Option<DefId> {\n+        match *self {\n+            ImplContainer(id) => Some(id),\n+            _ => None,\n+        }\n+    }\n+\n     /// Asserts that this is the `DefId` of an associated item declared\n     /// in a trait, and returns the trait `DefId`.\n     pub fn assert_trait(&self) -> DefId {"}, {"sha": "106b443ee3c1486d126a474efa7584603c8fd4f3", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -2169,7 +2169,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             let generic_predicates = self.super_predicates_of(trait_did);\n \n             for (predicate, _) in generic_predicates.predicates {\n-                if let ty::PredicateKind::Trait(data, _) = predicate.kind().skip_binder() {\n+                if let ty::PredicateKind::Trait(data) = predicate.kind().skip_binder() {\n                     if set.insert(data.def_id()) {\n                         stack.push(data.def_id());\n                     }"}, {"sha": "3846d9ffdbae573f5aa8e02c6fb71e470fd859bc", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -33,6 +33,7 @@ impl<T> ExpectedFound<T> {\n #[derive(Clone, Debug, TypeFoldable)]\n pub enum TypeError<'tcx> {\n     Mismatch,\n+    ConstnessMismatch(ExpectedFound<hir::Constness>),\n     UnsafetyMismatch(ExpectedFound<hir::Unsafety>),\n     AbiMismatch(ExpectedFound<abi::Abi>),\n     Mutability,\n@@ -106,6 +107,9 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             CyclicTy(_) => write!(f, \"cyclic type of infinite size\"),\n             CyclicConst(_) => write!(f, \"encountered a self-referencing constant\"),\n             Mismatch => write!(f, \"types differ\"),\n+            ConstnessMismatch(values) => {\n+                write!(f, \"expected {} fn, found {} fn\", values.expected, values.found)\n+            }\n             UnsafetyMismatch(values) => {\n                 write!(f, \"expected {} fn, found {} fn\", values.expected, values.found)\n             }\n@@ -213,9 +217,11 @@ impl<'tcx> TypeError<'tcx> {\n     pub fn must_include_note(&self) -> bool {\n         use self::TypeError::*;\n         match self {\n-            CyclicTy(_) | CyclicConst(_) | UnsafetyMismatch(_) | Mismatch | AbiMismatch(_)\n-            | FixedArraySize(_) | ArgumentSorts(..) | Sorts(_) | IntMismatch(_)\n-            | FloatMismatch(_) | VariadicMismatch(_) | TargetFeatureCast(_) => false,\n+            CyclicTy(_) | CyclicConst(_) | UnsafetyMismatch(_) | ConstnessMismatch(_)\n+            | Mismatch | AbiMismatch(_) | FixedArraySize(_) | ArgumentSorts(..) | Sorts(_)\n+            | IntMismatch(_) | FloatMismatch(_) | VariadicMismatch(_) | TargetFeatureCast(_) => {\n+                false\n+            }\n \n             Mutability\n             | ArgumentMutability(_)"}, {"sha": "391c8292bd542d1e820b8e17544f72d069d7a94c", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -216,7 +216,7 @@ impl FlagComputation {\n \n     fn add_predicate_atom(&mut self, atom: ty::PredicateKind<'_>) {\n         match atom {\n-            ty::PredicateKind::Trait(trait_pred, _constness) => {\n+            ty::PredicateKind::Trait(trait_pred) => {\n                 self.add_substs(trait_pred.trait_ref.substs);\n             }\n             ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {"}, {"sha": "0906cffa05c32e6c6118c5e21cd2dab84950e2f4", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -461,7 +461,7 @@ pub enum PredicateKind<'tcx> {\n     /// A trait predicate will have `Constness::Const` if it originates\n     /// from a bound on a `const fn` without the `?const` opt-out (e.g.,\n     /// `const fn foobar<Foo: Bar>() {}`).\n-    Trait(TraitPredicate<'tcx>, Constness),\n+    Trait(TraitPredicate<'tcx>),\n \n     /// `where 'a: 'b`\n     RegionOutlives(RegionOutlivesPredicate<'tcx>),\n@@ -617,6 +617,11 @@ impl<'tcx> Predicate<'tcx> {\n #[derive(HashStable, TypeFoldable)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>,\n+\n+    /// A trait predicate will have `Constness::Const` if it originates\n+    /// from a bound on a `const fn` without the `?const` opt-out (e.g.,\n+    /// `const fn foobar<Foo: Bar>() {}`).\n+    pub constness: hir::Constness,\n }\n \n pub type PolyTraitPredicate<'tcx> = ty::Binder<'tcx, TraitPredicate<'tcx>>;\n@@ -750,24 +755,27 @@ impl ToPredicate<'tcx> for PredicateKind<'tcx> {\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateKind::Trait(ty::TraitPredicate { trait_ref: self.value }, self.constness)\n-            .to_predicate(tcx)\n+        PredicateKind::Trait(ty::TraitPredicate {\n+            trait_ref: self.value,\n+            constness: self.constness,\n+        })\n+        .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         self.value\n             .map_bound(|trait_ref| {\n-                PredicateKind::Trait(ty::TraitPredicate { trait_ref }, self.constness)\n+                PredicateKind::Trait(ty::TraitPredicate { trait_ref, constness: self.constness })\n             })\n             .to_predicate(tcx)\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitPredicate<'tcx>> {\n+impl<'tcx> ToPredicate<'tcx> for PolyTraitPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.value.map_bound(|value| PredicateKind::Trait(value, self.constness)).to_predicate(tcx)\n+        self.map_bound(PredicateKind::Trait).to_predicate(tcx)\n     }\n }\n \n@@ -793,8 +801,8 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn to_opt_poly_trait_ref(self) -> Option<ConstnessAnd<PolyTraitRef<'tcx>>> {\n         let predicate = self.kind();\n         match predicate.skip_binder() {\n-            PredicateKind::Trait(t, constness) => {\n-                Some(ConstnessAnd { constness, value: predicate.rebind(t.trait_ref) })\n+            PredicateKind::Trait(t) => {\n+                Some(ConstnessAnd { constness: t.constness, value: predicate.rebind(t.trait_ref) })\n             }\n             PredicateKind::Projection(..)\n             | PredicateKind::Subtype(..)"}, {"sha": "c96621338f574f65c5cba6b74866d6c207d39c01", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -630,7 +630,7 @@ pub trait PrettyPrinter<'tcx>:\n                     for (predicate, _) in bounds {\n                         let predicate = predicate.subst(self.tcx(), substs);\n                         let bound_predicate = predicate.kind();\n-                        if let ty::PredicateKind::Trait(pred, _) = bound_predicate.skip_binder() {\n+                        if let ty::PredicateKind::Trait(pred) = bound_predicate.skip_binder() {\n                             let trait_ref = bound_predicate.rebind(pred.trait_ref);\n                             // Don't print +Sized, but rather +?Sized if absent.\n                             if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n@@ -2264,10 +2264,7 @@ define_print_and_forward_display! {\n \n     ty::PredicateKind<'tcx> {\n         match *self {\n-            ty::PredicateKind::Trait(ref data, constness) => {\n-                if let hir::Constness::Const = constness {\n-                    p!(\"const \");\n-                }\n+            ty::PredicateKind::Trait(ref data) => {\n                 p!(print(data))\n             }\n             ty::PredicateKind::Subtype(predicate) => p!(print(predicate)),"}, {"sha": "9c48f05617e0993e09883a8ff5b3ef2123644a42", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -200,6 +200,33 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for ast::Constness {\n+    fn relate<R: TypeRelation<'tcx>>(\n+        relation: &mut R,\n+        a: ast::Constness,\n+        b: ast::Constness,\n+    ) -> RelateResult<'tcx, ast::Constness> {\n+        if a != b {\n+            Err(TypeError::ConstnessMismatch(expected_found(relation, a, b)))\n+        } else {\n+            Ok(a)\n+        }\n+    }\n+}\n+\n+impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::ConstnessAnd<T> {\n+    fn relate<R: TypeRelation<'tcx>>(\n+        relation: &mut R,\n+        a: ty::ConstnessAnd<T>,\n+        b: ty::ConstnessAnd<T>,\n+    ) -> RelateResult<'tcx, ty::ConstnessAnd<T>> {\n+        Ok(ty::ConstnessAnd {\n+            constness: relation.relate(a.constness, b.constness)?,\n+            value: relation.relate(a.value, b.value)?,\n+        })\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for ast::Unsafety {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n@@ -767,7 +794,10 @@ impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n         a: ty::TraitPredicate<'tcx>,\n         b: ty::TraitPredicate<'tcx>,\n     ) -> RelateResult<'tcx, ty::TraitPredicate<'tcx>> {\n-        Ok(ty::TraitPredicate { trait_ref: relation.relate(a.trait_ref, b.trait_ref)? })\n+        Ok(ty::TraitPredicate {\n+            trait_ref: relation.relate(a.trait_ref, b.trait_ref)?,\n+            constness: relation.relate(a.constness, b.constness)?,\n+        })\n     }\n }\n "}, {"sha": "62397752db2fcdebd9c40982ac867f3f6d6d4176", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -155,6 +155,9 @@ impl fmt::Debug for ty::ParamConst {\n \n impl fmt::Debug for ty::TraitPredicate<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if let hir::Constness::Const = self.constness {\n+            write!(f, \"const \")?;\n+        }\n         write!(f, \"TraitPredicate({:?})\", self.trait_ref)\n     }\n }\n@@ -174,12 +177,7 @@ impl fmt::Debug for ty::Predicate<'tcx> {\n impl fmt::Debug for ty::PredicateKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            ty::PredicateKind::Trait(ref a, constness) => {\n-                if let hir::Constness::Const = constness {\n-                    write!(f, \"const \")?;\n-                }\n-                a.fmt(f)\n-            }\n+            ty::PredicateKind::Trait(ref a) => a.fmt(f),\n             ty::PredicateKind::Subtype(ref pair) => pair.fmt(f),\n             ty::PredicateKind::RegionOutlives(ref pair) => pair.fmt(f),\n             ty::PredicateKind::TypeOutlives(ref pair) => pair.fmt(f),\n@@ -366,7 +364,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n-        tcx.lift(self.trait_ref).map(|trait_ref| ty::TraitPredicate { trait_ref })\n+        tcx.lift(self.trait_ref)\n+            .map(|trait_ref| ty::TraitPredicate { trait_ref, constness: self.constness })\n     }\n }\n \n@@ -419,9 +418,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n     type Lifted = ty::PredicateKind<'tcx>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self {\n-            ty::PredicateKind::Trait(data, constness) => {\n-                tcx.lift(data).map(|data| ty::PredicateKind::Trait(data, constness))\n-            }\n+            ty::PredicateKind::Trait(data) => tcx.lift(data).map(ty::PredicateKind::Trait),\n             ty::PredicateKind::Subtype(data) => tcx.lift(data).map(ty::PredicateKind::Subtype),\n             ty::PredicateKind::RegionOutlives(data) => {\n                 tcx.lift(data).map(ty::PredicateKind::RegionOutlives)\n@@ -584,6 +581,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n \n         Some(match self {\n             Mismatch => Mismatch,\n+            ConstnessMismatch(x) => ConstnessMismatch(x),\n             UnsafetyMismatch(x) => UnsafetyMismatch(x),\n             AbiMismatch(x) => AbiMismatch(x),\n             Mutability => Mutability,"}, {"sha": "a1edb8071c459eb32bd21db381be33e6afadadb9", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -876,7 +876,10 @@ impl<'tcx> PolyTraitRef<'tcx> {\n     }\n \n     pub fn to_poly_trait_predicate(&self) -> ty::PolyTraitPredicate<'tcx> {\n-        self.map_bound(|trait_ref| ty::TraitPredicate { trait_ref })\n+        self.map_bound(|trait_ref| ty::TraitPredicate {\n+            trait_ref,\n+            constness: hir::Constness::NotConst,\n+        })\n     }\n }\n "}, {"sha": "86dcb9c9c1b7a1c134698ccf1d20a15363adf932", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -1084,11 +1084,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         span_mirbug!(\n                             self,\n                             user_annotation,\n-                            \"bad user type AscribeUserType({:?}, {:?} {:?}): {:?}\",\n+                            \"bad user type AscribeUserType({:?}, {:?} {:?}, type_of={:?}): {:?}\",\n                             inferred_ty,\n                             def_id,\n                             user_substs,\n-                            terr\n+                            self.tcx().type_of(def_id),\n+                            terr,\n                         );\n                     }\n                 }\n@@ -2688,10 +2689,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory,\n     ) {\n         self.prove_predicates(\n-            Some(ty::PredicateKind::Trait(\n-                ty::TraitPredicate { trait_ref },\n-                hir::Constness::NotConst,\n-            )),\n+            Some(ty::PredicateKind::Trait(ty::TraitPredicate {\n+                trait_ref,\n+                constness: hir::Constness::NotConst,\n+            })),\n             locations,\n             category,\n         );"}, {"sha": "48fd63b258ca739f66934f7aeb0332374a07c19a", "filename": "compiler/rustc_mir/src/transform/check_consts/check.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -423,7 +423,7 @@ impl Checker<'mir, 'tcx> {\n                     ty::PredicateKind::Subtype(_) => {\n                         bug!(\"subtype predicate on function: {:#?}\", predicate)\n                     }\n-                    ty::PredicateKind::Trait(pred, _constness) => {\n+                    ty::PredicateKind::Trait(pred) => {\n                         if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                             continue;\n                         }\n@@ -817,7 +817,10 @@ impl Visitor<'tcx> for Checker<'mir, 'tcx> {\n                     let obligation = Obligation::new(\n                         ObligationCause::dummy(),\n                         param_env,\n-                        Binder::dummy(TraitPredicate { trait_ref }),\n+                        Binder::dummy(TraitPredicate {\n+                            trait_ref,\n+                            constness: hir::Constness::Const,\n+                        }),\n                     );\n \n                     let implsrc = tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "26fe796cb916ffdce81e967fd6c27d1c36a88872", "filename": "compiler/rustc_mir/src/transform/function_item_references.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -132,7 +132,7 @@ impl<'a, 'tcx> FunctionItemRefChecker<'a, 'tcx> {\n \n     /// If the given predicate is the trait `fmt::Pointer`, returns the bound parameter type.\n     fn is_pointer_trait(&self, bound: &PredicateKind<'tcx>) -> Option<Ty<'tcx>> {\n-        if let ty::PredicateKind::Trait(predicate, _) = bound {\n+        if let ty::PredicateKind::Trait(predicate) = bound {\n             if self.tcx.is_diagnostic_item(sym::pointer_trait, predicate.def_id()) {\n                 Some(predicate.trait_ref.self_ty())\n             } else {"}, {"sha": "3df8ade216925edc5546a1082a07080a467ebe1c", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -122,7 +122,7 @@ where\n \n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<V::BreakTy> {\n         match predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref }, _) => {\n+            ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref, constness: _ }) => {\n                 self.visit_trait(trait_ref)\n             }\n             ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {"}, {"sha": "d79fd910b7e78687b67e1e999633dd978759b7c7", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -2657,7 +2657,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             let obligations = predicates.predicates.iter().filter_map(|&(pred, _)| {\n                 let bound_predicate = pred.kind();\n                 match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Trait(data, _) => {\n+                    ty::PredicateKind::Trait(data) => {\n                         // The order here needs to match what we would get from `subst_supertrait`\n                         let pred_bound_vars = bound_predicate.bound_vars();\n                         let mut all_bound_vars = bound_vars.clone();"}, {"sha": "282502cfa0d3d8d73f2ed0ccc7871a6a84092387", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -285,6 +285,7 @@ impl AutoTraitFinder<'tcx> {\n                 def_id: trait_did,\n                 substs: infcx.tcx.mk_substs_trait(ty, &[]),\n             },\n+            constness: hir::Constness::NotConst,\n         }));\n \n         let computed_preds = param_env.caller_bounds().iter();\n@@ -344,10 +345,7 @@ impl AutoTraitFinder<'tcx> {\n                 Err(SelectionError::Unimplemented) => {\n                     if self.is_param_no_infer(pred.skip_binder().trait_ref.substs) {\n                         already_visited.remove(&pred);\n-                        self.add_user_pred(\n-                            &mut user_computed_preds,\n-                            pred.without_const().to_predicate(self.tcx),\n-                        );\n+                        self.add_user_pred(&mut user_computed_preds, pred.to_predicate(self.tcx));\n                         predicates.push_back(pred);\n                     } else {\n                         debug!(\n@@ -414,10 +412,8 @@ impl AutoTraitFinder<'tcx> {\n     ) {\n         let mut should_add_new = true;\n         user_computed_preds.retain(|&old_pred| {\n-            if let (\n-                ty::PredicateKind::Trait(new_trait, _),\n-                ty::PredicateKind::Trait(old_trait, _),\n-            ) = (new_pred.kind().skip_binder(), old_pred.kind().skip_binder())\n+            if let (ty::PredicateKind::Trait(new_trait), ty::PredicateKind::Trait(old_trait)) =\n+                (new_pred.kind().skip_binder(), old_pred.kind().skip_binder())\n             {\n                 if new_trait.def_id() == old_trait.def_id() {\n                     let new_substs = new_trait.trait_ref.substs;\n@@ -638,7 +634,7 @@ impl AutoTraitFinder<'tcx> {\n \n             let bound_predicate = predicate.kind();\n             match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Trait(p, _) => {\n+                ty::PredicateKind::Trait(p) => {\n                     // Add this to `predicates` so that we end up calling `select`\n                     // with it. If this predicate ends up being unimplemented,\n                     // then `evaluate_predicates` will handle adding it the `ParamEnv`"}, {"sha": "2f91666ca641dd081427be274074dadac673469c", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -277,7 +277,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                 let bound_predicate = obligation.predicate.kind();\n                 match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Trait(trait_predicate, _) => {\n+                    ty::PredicateKind::Trait(trait_predicate) => {\n                         let trait_predicate = bound_predicate.rebind(trait_predicate);\n                         let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n \n@@ -518,8 +518,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 );\n                                 trait_pred\n                             });\n-                            let unit_obligation =\n-                                obligation.with(predicate.without_const().to_predicate(tcx));\n+                            let unit_obligation = obligation.with(predicate.to_predicate(tcx));\n                             if self.predicate_may_hold(&unit_obligation) {\n                                 err.note(\"this trait is implemented for `()`.\");\n                                 err.note(\n@@ -1148,7 +1147,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // FIXME: It should be possible to deal with `ForAll` in a cleaner way.\n         let bound_error = error.kind();\n         let (cond, error) = match (cond.kind().skip_binder(), bound_error.skip_binder()) {\n-            (ty::PredicateKind::Trait(..), ty::PredicateKind::Trait(error, _)) => {\n+            (ty::PredicateKind::Trait(..), ty::PredicateKind::Trait(error)) => {\n                 (cond, bound_error.rebind(error))\n             }\n             _ => {\n@@ -1159,7 +1158,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         for obligation in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n             let bound_predicate = obligation.predicate.kind();\n-            if let ty::PredicateKind::Trait(implication, _) = bound_predicate.skip_binder() {\n+            if let ty::PredicateKind::Trait(implication) = bound_predicate.skip_binder() {\n                 let error = error.to_poly_trait_ref();\n                 let implication = bound_predicate.rebind(implication.trait_ref);\n                 // FIXME: I'm just not taking associated types at all here.\n@@ -1536,7 +1535,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         let bound_predicate = predicate.kind();\n         let mut err = match bound_predicate.skip_binder() {\n-            ty::PredicateKind::Trait(data, _) => {\n+            ty::PredicateKind::Trait(data) => {\n                 let trait_ref = bound_predicate.rebind(data.trait_ref);\n                 debug!(\"trait_ref {:?}\", trait_ref);\n \n@@ -1803,7 +1802,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             match (obligation.predicate.kind().skip_binder(), obligation.cause.code.peel_derives())\n             {\n                 (\n-                    ty::PredicateKind::Trait(pred, _),\n+                    ty::PredicateKind::Trait(pred),\n                     &ObligationCauseCode::BindingObligation(item_def_id, span),\n                 ) => (pred, item_def_id, span),\n                 _ => return,"}, {"sha": "269560843657dbdf5c8dd43598373f152fd4b4ca", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -1386,7 +1386,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // bound was introduced. At least one generator should be present for this diagnostic to be\n         // modified.\n         let (mut trait_ref, mut target_ty) = match obligation.predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(p, _) => (Some(p.trait_ref), Some(p.self_ty())),\n+            ty::PredicateKind::Trait(p) => (Some(p.trait_ref), Some(p.self_ty())),\n             _ => (None, None),\n         };\n         let mut generator = None;"}, {"sha": "7048f0dbedcb670fe81f31d2b4e1e6b095bedd66", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -3,6 +3,7 @@ use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{Error, ForestObligation, Outcome};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n use rustc_errors::ErrorReported;\n+use rustc_hir as hir;\n use rustc_infer::traits::{SelectionError, TraitEngine, TraitEngineExt as _, TraitObligation};\n use rustc_middle::mir::abstract_const::NotConstEvaluatable;\n use rustc_middle::mir::interpret::ErrorHandled;\n@@ -228,6 +229,22 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         if errors.is_empty() { Ok(()) } else { Err(errors) }\n     }\n \n+    fn select_all_with_constness_or_error(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        constness: rustc_hir::Constness,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n+        self.select_with_constness_where_possible(infcx, constness)?;\n+\n+        let errors: Vec<_> = self\n+            .predicates\n+            .to_errors(CodeAmbiguity)\n+            .into_iter()\n+            .map(to_fulfillment_error)\n+            .collect();\n+        if errors.is_empty() { Ok(()) } else { Err(errors) }\n+    }\n+\n     fn select_where_possible(\n         &mut self,\n         infcx: &InferCtxt<'_, 'tcx>,\n@@ -236,6 +253,15 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         self.select(&mut selcx)\n     }\n \n+    fn select_with_constness_where_possible(\n+        &mut self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        constness: hir::Constness,\n+    ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n+        let mut selcx = SelectionContext::with_constness(infcx, constness);\n+        self.select(&mut selcx)\n+    }\n+\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.predicates.map_pending_obligations(|o| o.obligation.clone())\n     }\n@@ -352,7 +378,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 // Evaluation will discard candidates using the leak check.\n                 // This means we need to pass it the bound version of our\n                 // predicate.\n-                ty::PredicateKind::Trait(trait_ref, _constness) => {\n+                ty::PredicateKind::Trait(trait_ref) => {\n                     let trait_obligation = obligation.with(binder.rebind(trait_ref));\n \n                     self.process_trait_obligation(\n@@ -388,7 +414,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 }\n             },\n             Some(pred) => match pred {\n-                ty::PredicateKind::Trait(data, _) => {\n+                ty::PredicateKind::Trait(data) => {\n                     let trait_obligation = obligation.with(Binder::dummy(data));\n \n                     self.process_trait_obligation(\n@@ -623,7 +649,12 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n         if obligation.predicate.is_global() {\n             // no type variables present, can use evaluation for better caching.\n             // FIXME: consider caching errors too.\n-            if infcx.predicate_must_hold_considering_regions(obligation) {\n+            //\n+            // If the predicate is considered const, then we cannot use this because\n+            // it will cause false negatives in the ui tests.\n+            if !self.selcx.is_predicate_const(obligation.predicate)\n+                && infcx.predicate_must_hold_considering_regions(obligation)\n+            {\n                 debug!(\n                     \"selecting trait at depth {} evaluated to holds\",\n                     obligation.recursion_depth\n@@ -677,7 +708,12 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n         if obligation.predicate.is_global() {\n             // no type variables present, can use evaluation for better caching.\n             // FIXME: consider caching errors too.\n-            if self.selcx.infcx().predicate_must_hold_considering_regions(obligation) {\n+            //\n+            // If the predicate is considered const, then we cannot use this because\n+            // it will cause false negatives in the ui tests.\n+            if !self.selcx.is_predicate_const(obligation.predicate)\n+                && self.selcx.infcx().predicate_must_hold_considering_regions(obligation)\n+            {\n                 return ProcessResult::Changed(vec![]);\n             } else {\n                 tracing::debug!(\"Does NOT hold: {:?}\", obligation);"}, {"sha": "04bc689d5116196b9b7abac42151cdaa67c6ac83", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -280,7 +280,7 @@ fn predicate_references_self(\n     let self_ty = tcx.types.self_param;\n     let has_self_ty = |arg: &GenericArg<'_>| arg.walk().any(|arg| arg == self_ty.into());\n     match predicate.kind().skip_binder() {\n-        ty::PredicateKind::Trait(ref data, _) => {\n+        ty::PredicateKind::Trait(ref data) => {\n             // In the case of a trait predicate, we can skip the \"self\" type.\n             if data.trait_ref.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n         }\n@@ -331,7 +331,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n     elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| {\n         match obligation.predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(ref trait_pred, _) => {\n+            ty::PredicateKind::Trait(ref trait_pred) => {\n                 trait_pred.def_id() == sized_def_id && trait_pred.self_ty().is_param(0)\n             }\n             ty::PredicateKind::Projection(..)"}, {"sha": "02e9b4d0f0e7272d8ee8b347359389f9c16f3d4a", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -15,7 +15,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n         // `&T`, accounts for about 60% percentage of the predicates\n         // we have to prove. No need to canonicalize and all that for\n         // such cases.\n-        if let ty::PredicateKind::Trait(trait_ref, _) = key.value.predicate.kind().skip_binder() {\n+        if let ty::PredicateKind::Trait(trait_ref) = key.value.predicate.kind().skip_binder() {\n             if let Some(sized_def_id) = tcx.lang_items().sized_trait() {\n                 if trait_ref.def_id() == sized_def_id {\n                     if trait_ref.self_ty().is_trivially_sized(tcx) {"}, {"sha": "4312cc9468242312777dadb93e15be2030301f26", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -144,7 +144,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Instead, we select the right impl now but report \"`Bar` does\n         // not implement `Clone`\".\n         if candidates.len() == 1 {\n-            return self.filter_negative_and_reservation_impls(candidates.pop().unwrap());\n+            return self.filter_impls(candidates.pop().unwrap(), stack.obligation);\n         }\n \n         // Winnow, but record the exact outcome of evaluation, which\n@@ -217,7 +217,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // Just one candidate left.\n-        self.filter_negative_and_reservation_impls(candidates.pop().unwrap().candidate)\n+        self.filter_impls(candidates.pop().unwrap().candidate, stack.obligation)\n     }\n \n     pub(super) fn assemble_candidates<'o>("}, {"sha": "dcf5ac63b78ea7dbd20a8739efe27b2fff70c46d", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 111, "deletions": 28, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -41,8 +41,9 @@ use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n+use rustc_middle::ty::WithConstness;\n use rustc_middle::ty::{self, PolyProjectionPredicate, ToPolyTraitRef, ToPredicate};\n-use rustc_middle::ty::{Ty, TyCtxt, TypeFoldable, WithConstness};\n+use rustc_middle::ty::{Ty, TyCtxt, TypeFoldable};\n use rustc_span::symbol::sym;\n \n use std::cell::{Cell, RefCell};\n@@ -129,6 +130,9 @@ pub struct SelectionContext<'cx, 'tcx> {\n     /// and a negative impl\n     allow_negative_impls: bool,\n \n+    /// Do we only want const impls when we have a const trait predicate?\n+    const_impls_required: bool,\n+\n     /// The mode that trait queries run in, which informs our error handling\n     /// policy. In essence, canonicalized queries need their errors propagated\n     /// rather than immediately reported because we do not have accurate spans.\n@@ -141,7 +145,7 @@ struct TraitObligationStack<'prev, 'tcx> {\n \n     /// The trait ref from `obligation` but \"freshened\" with the\n     /// selection-context's freshener. Used to check for recursion.\n-    fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n+    fresh_trait_ref: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n \n     /// Starts out equal to `depth` -- if, during evaluation, we\n     /// encounter a cycle, then we will set this flag to the minimum\n@@ -220,6 +224,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             intercrate: false,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n+            const_impls_required: false,\n             query_mode: TraitQueryMode::Standard,\n         }\n     }\n@@ -231,6 +236,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             intercrate: true,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n+            const_impls_required: false,\n             query_mode: TraitQueryMode::Standard,\n         }\n     }\n@@ -246,6 +252,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             intercrate: false,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls,\n+            const_impls_required: false,\n             query_mode: TraitQueryMode::Standard,\n         }\n     }\n@@ -261,10 +268,26 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             intercrate: false,\n             intercrate_ambiguity_causes: None,\n             allow_negative_impls: false,\n+            const_impls_required: false,\n             query_mode,\n         }\n     }\n \n+    pub fn with_constness(\n+        infcx: &'cx InferCtxt<'cx, 'tcx>,\n+        constness: hir::Constness,\n+    ) -> SelectionContext<'cx, 'tcx> {\n+        SelectionContext {\n+            infcx,\n+            freshener: infcx.freshener_keep_static(),\n+            intercrate: false,\n+            intercrate_ambiguity_causes: None,\n+            allow_negative_impls: false,\n+            const_impls_required: matches!(constness, hir::Constness::Const),\n+            query_mode: TraitQueryMode::Standard,\n+        }\n+    }\n+\n     /// Enables tracking of intercrate ambiguity causes. These are\n     /// used in coherence to give improved diagnostics. We don't do\n     /// this until we detect a coherence error because it can lead to\n@@ -293,6 +316,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    /// returns `true` if the predicate is considered `const` to\n+    /// this selection context.\n+    pub fn is_predicate_const(&self, pred: ty::Predicate<'_>) -> bool {\n+        match pred.kind().skip_binder() {\n+            ty::PredicateKind::Trait(ty::TraitPredicate {\n+                constness: hir::Constness::Const,\n+                ..\n+            }) if self.const_impls_required => true,\n+            _ => false,\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Selection\n     //\n@@ -454,7 +489,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let result = ensure_sufficient_stack(|| {\n             let bound_predicate = obligation.predicate.kind();\n             match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Trait(t, _) => {\n+                ty::PredicateKind::Trait(t) => {\n                     let t = bound_predicate.rebind(t);\n                     debug_assert!(!t.has_escaping_bound_vars());\n                     let obligation = obligation.with(t);\n@@ -762,8 +797,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // if the regions match exactly.\n             let cycle = stack.iter().skip(1).take_while(|s| s.depth >= cycle_depth);\n             let tcx = self.tcx();\n-            let cycle =\n-                cycle.map(|stack| stack.obligation.predicate.without_const().to_predicate(tcx));\n+            let cycle = cycle.map(|stack| stack.obligation.predicate.to_predicate(tcx));\n             if self.coinductive_match(cycle) {\n                 debug!(\"evaluate_stack --> recursive, coinductive\");\n                 Some(EvaluatedToOk)\n@@ -805,7 +839,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n         let unbound_input_types =\n-            stack.fresh_trait_ref.skip_binder().substs.types().any(|ty| ty.is_fresh());\n+            stack.fresh_trait_ref.value.skip_binder().substs.types().any(|ty| ty.is_fresh());\n         // This check was an imperfect workaround for a bug in the old\n         // intercrate mode; it should be removed when that goes away.\n         if unbound_input_types && self.intercrate {\n@@ -873,7 +907,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n         let result = match predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n+            ty::PredicateKind::Trait(ref data) => self.tcx().trait_is_auto(data.def_id()),\n             _ => false,\n         };\n         debug!(?predicate, ?result, \"coinductive_predicate\");\n@@ -926,7 +960,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn check_evaluation_cache(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_ref: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n     ) -> Option<EvaluationResult> {\n         let tcx = self.tcx();\n         if self.can_use_global_caches(param_env) {\n@@ -940,7 +974,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn insert_evaluation_cache(\n         &mut self,\n         param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_ref: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n         dep_node: DepNodeIndex,\n         result: EvaluationResult,\n     ) {\n@@ -1016,13 +1050,44 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         (result, dep_node)\n     }\n \n-    // Treat negative impls as unimplemented, and reservation impls as ambiguity.\n-    fn filter_negative_and_reservation_impls(\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn filter_impls(\n         &mut self,\n         candidate: SelectionCandidate<'tcx>,\n+        obligation: &TraitObligation<'tcx>,\n     ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        let tcx = self.tcx();\n+        // Respect const trait obligations\n+        if self.const_impls_required {\n+            if let hir::Constness::Const = obligation.predicate.skip_binder().constness {\n+                if Some(obligation.predicate.skip_binder().trait_ref.def_id)\n+                    != tcx.lang_items().sized_trait()\n+                // const Sized bounds are skipped\n+                {\n+                    match candidate {\n+                        // const impl\n+                        ImplCandidate(def_id)\n+                            if tcx.impl_constness(def_id) == hir::Constness::Const => {}\n+                        // const param\n+                        ParamCandidate(ty::ConstnessAnd {\n+                            constness: hir::Constness::Const,\n+                            ..\n+                        }) => {}\n+                        // auto trait impl\n+                        AutoImplCandidate(..) => {}\n+                        // generator, this will raise error in other places\n+                        // or ignore error with const_async_blocks feature\n+                        GeneratorCandidate => {}\n+                        _ => {\n+                            // reject all other types of candidates\n+                            return Err(Unimplemented);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        // Treat negative impls as unimplemented, and reservation impls as ambiguity.\n         if let ImplCandidate(def_id) = candidate {\n-            let tcx = self.tcx();\n             match tcx.impl_polarity(def_id) {\n                 ty::ImplPolarity::Negative if !self.allow_negative_impls => {\n                     return Err(Unimplemented);\n@@ -1036,7 +1101,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         let value = attr.and_then(|a| a.value_str());\n                         if let Some(value) = value {\n                             debug!(\n-                                \"filter_negative_and_reservation_impls: \\\n+                                \"filter_impls: \\\n                                  reservation impl ambiguity on {:?}\",\n                                 def_id\n                             );\n@@ -1103,13 +1168,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         cache_fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>> {\n         let tcx = self.tcx();\n-        let trait_ref = &cache_fresh_trait_pred.skip_binder().trait_ref;\n+        let pred = &cache_fresh_trait_pred.skip_binder();\n+        let trait_ref = pred.trait_ref;\n         if self.can_use_global_caches(param_env) {\n-            if let Some(res) = tcx.selection_cache.get(&param_env.and(*trait_ref), tcx) {\n+            if let Some(res) = tcx\n+                .selection_cache\n+                .get(&param_env.and(trait_ref).with_constness(pred.constness), tcx)\n+            {\n                 return Some(res);\n             }\n         }\n-        self.infcx.selection_cache.get(&param_env.and(*trait_ref), tcx)\n+        self.infcx\n+            .selection_cache\n+            .get(&param_env.and(trait_ref).with_constness(pred.constness), tcx)\n     }\n \n     /// Determines whether can we safely cache the result\n@@ -1146,7 +1217,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidate: SelectionResult<'tcx, SelectionCandidate<'tcx>>,\n     ) {\n         let tcx = self.tcx();\n-        let trait_ref = cache_fresh_trait_pred.skip_binder().trait_ref;\n+        let pred = cache_fresh_trait_pred.skip_binder();\n+        let trait_ref = pred.trait_ref;\n \n         if !self.can_cache_candidate(&candidate) {\n             debug!(?trait_ref, ?candidate, \"insert_candidate_cache - candidate is not cacheable\");\n@@ -1160,14 +1232,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 if !candidate.needs_infer() {\n                     debug!(?trait_ref, ?candidate, \"insert_candidate_cache global\");\n                     // This may overwrite the cache with the same value.\n-                    tcx.selection_cache.insert(param_env.and(trait_ref), dep_node, candidate);\n+                    tcx.selection_cache.insert(\n+                        param_env.and(trait_ref).with_constness(pred.constness),\n+                        dep_node,\n+                        candidate,\n+                    );\n                     return;\n                 }\n             }\n         }\n \n         debug!(?trait_ref, ?candidate, \"insert_candidate_cache local\");\n-        self.infcx.selection_cache.insert(param_env.and(trait_ref), dep_node, candidate);\n+        self.infcx.selection_cache.insert(\n+            param_env.and(trait_ref).with_constness(pred.constness),\n+            dep_node,\n+            candidate,\n+        );\n     }\n \n     /// Matches a predicate against the bounds of its self type.\n@@ -1213,7 +1293,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .enumerate()\n             .filter_map(|(idx, bound)| {\n                 let bound_predicate = bound.kind();\n-                if let ty::PredicateKind::Trait(pred, _) = bound_predicate.skip_binder() {\n+                if let ty::PredicateKind::Trait(pred) = bound_predicate.skip_binder() {\n                     let bound = bound_predicate.rebind(pred.trait_ref);\n                     if self.infcx.probe(|_| {\n                         match self.match_normalize_trait_ref(\n@@ -1997,8 +2077,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_fresh_trait_refs(\n         &self,\n-        previous: ty::PolyTraitRef<'tcx>,\n-        current: ty::PolyTraitRef<'tcx>,\n+        previous: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n+        current: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> bool {\n         let mut matcher = ty::_match::Match::new(self.tcx(), param_env);\n@@ -2010,8 +2090,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         previous_stack: TraitObligationStackList<'o, 'tcx>,\n         obligation: &'o TraitObligation<'tcx>,\n     ) -> TraitObligationStack<'o, 'tcx> {\n-        let fresh_trait_ref =\n-            obligation.predicate.to_poly_trait_ref().fold_with(&mut self.freshener);\n+        let fresh_trait_ref = obligation\n+            .predicate\n+            .to_poly_trait_ref()\n+            .fold_with(&mut self.freshener)\n+            .with_constness(obligation.predicate.skip_binder().constness);\n \n         let dfn = previous_stack.cache.next_dfn();\n         let depth = previous_stack.depth() + 1;\n@@ -2290,7 +2373,7 @@ struct ProvisionalEvaluationCache<'tcx> {\n     /// - then we determine that `E` is in error -- we will then clear\n     ///   all cache values whose DFN is >= 4 -- in this case, that\n     ///   means the cached value for `F`.\n-    map: RefCell<FxHashMap<ty::PolyTraitRef<'tcx>, ProvisionalEvaluation>>,\n+    map: RefCell<FxHashMap<ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>, ProvisionalEvaluation>>,\n }\n \n /// A cache value for the provisional cache: contains the depth-first\n@@ -2322,7 +2405,7 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n     /// `reached_depth` (from the returned value).\n     fn get_provisional(\n         &self,\n-        fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n+        fresh_trait_ref: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n     ) -> Option<ProvisionalEvaluation> {\n         debug!(\n             ?fresh_trait_ref,\n@@ -2340,7 +2423,7 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n         &self,\n         from_dfn: usize,\n         reached_depth: usize,\n-        fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n+        fresh_trait_ref: ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>,\n         result: EvaluationResult,\n     ) {\n         debug!(?from_dfn, ?fresh_trait_ref, ?result, \"insert_provisional\");\n@@ -2418,7 +2501,7 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n     fn on_completion(\n         &self,\n         dfn: usize,\n-        mut op: impl FnMut(ty::PolyTraitRef<'tcx>, EvaluationResult),\n+        mut op: impl FnMut(ty::ConstnessAnd<ty::PolyTraitRef<'tcx>>, EvaluationResult),\n     ) {\n         debug!(?dfn, \"on_completion\");\n "}, {"sha": "9c9664d7b5e846b82f6f3adeb246fded6d4297b7", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -108,7 +108,7 @@ pub fn predicate_obligations<'a, 'tcx>(\n \n     // It's ok to skip the binder here because wf code is prepared for it\n     match predicate.kind().skip_binder() {\n-        ty::PredicateKind::Trait(t, _) => {\n+        ty::PredicateKind::Trait(t) => {\n             wf.compute_trait_ref(&t.trait_ref, Elaborate::None);\n         }\n         ty::PredicateKind::RegionOutlives(..) => {}\n@@ -226,7 +226,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n                 }\n             }\n         }\n-        ty::PredicateKind::Trait(pred, _) => {\n+        ty::PredicateKind::Trait(pred) => {\n             // An associated item obligation born out of the `trait` failed to be met. An example\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);"}, {"sha": "974755e9e266934c6fa7faaf761f16cc6b309d64", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -87,7 +87,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                 ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                     chalk_ir::DomainGoal::FromEnv(chalk_ir::FromEnv::Ty(ty.lower_into(interner)))\n                 }\n-                ty::PredicateKind::Trait(predicate, _) => chalk_ir::DomainGoal::FromEnv(\n+                ty::PredicateKind::Trait(predicate) => chalk_ir::DomainGoal::FromEnv(\n                     chalk_ir::FromEnv::Trait(predicate.trait_ref.lower_into(interner)),\n                 ),\n                 ty::PredicateKind::RegionOutlives(predicate) => chalk_ir::DomainGoal::Holds(\n@@ -137,7 +137,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             collect_bound_vars(interner, interner.tcx, self.kind());\n \n         let value = match predicate {\n-            ty::PredicateKind::Trait(predicate, _) => {\n+            ty::PredicateKind::Trait(predicate) => {\n                 chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n                     chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n                 ))\n@@ -569,7 +569,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n         let (predicate, binders, _named_regions) =\n             collect_bound_vars(interner, interner.tcx, self.kind());\n         let value = match predicate {\n-            ty::PredicateKind::Trait(predicate, _) => {\n+            ty::PredicateKind::Trait(predicate) => {\n                 Some(chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)))\n             }\n             ty::PredicateKind::RegionOutlives(predicate) => {\n@@ -702,7 +702,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n         let (predicate, binders, _named_regions) =\n             collect_bound_vars(interner, interner.tcx, self.kind());\n         match predicate {\n-            ty::PredicateKind::Trait(predicate, _) => Some(chalk_ir::Binders::new(\n+            ty::PredicateKind::Trait(predicate) => Some(chalk_ir::Binders::new(\n                 binders,\n                 chalk_solve::rust_ir::InlineBound::TraitBound(\n                     predicate.trait_ref.lower_into(interner),"}, {"sha": "f4a0cc6767f09416a311d4600f88750c3417cc1c", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -6,7 +6,9 @@ use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArg, Subst, UserSelfTy, UserSubsts};\n-use rustc_middle::ty::{self, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable, Variance};\n+use rustc_middle::ty::{\n+    self, FnSig, Lift, PolyFnSig, PredicateKind, Ty, TyCtxt, TypeFoldable, Variance,\n+};\n use rustc_middle::ty::{ParamEnv, ParamEnvAnd, Predicate, ToPredicate};\n use rustc_span::DUMMY_SP;\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n@@ -85,7 +87,16 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         Ok(())\n     }\n \n-    fn prove_predicate(&mut self, predicate: Predicate<'tcx>) {\n+    fn prove_predicate(&mut self, mut predicate: Predicate<'tcx>) {\n+        if let PredicateKind::Trait(mut tr) = predicate.kind().skip_binder() {\n+            if let hir::Constness::Const = tr.constness {\n+                // FIXME check if we actually want to prove const predicates inside AscribeUserType\n+                tr.constness = hir::Constness::NotConst;\n+                predicate =\n+                    predicate.kind().rebind(PredicateKind::Trait(tr)).to_predicate(self.tcx());\n+            }\n+        }\n+\n         self.fulfill_cx.register_predicate_obligation(\n             self.infcx,\n             Obligation::new(ObligationCause::dummy(), self.param_env, predicate),\n@@ -126,6 +137,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         // outlives\" error messages.\n         let instantiated_predicates =\n             self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n+        debug!(?instantiated_predicates.predicates);\n         for instantiated_predicate in instantiated_predicates.predicates {\n             let instantiated_predicate = self.normalize(instantiated_predicate);\n             self.prove_predicate(instantiated_predicate);"}, {"sha": "3f72a431bd15561effa89281e2554159f866e0fe", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -1340,7 +1340,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                 let bound_predicate = obligation.predicate.kind();\n                 match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Trait(pred, _) => {\n+                    ty::PredicateKind::Trait(pred) => {\n                         let pred = bound_predicate.rebind(pred);\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())"}, {"sha": "4f8c8ca899f9008da93a43ea0234565f977d1179", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -606,16 +606,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut suggest_box = !obligations.is_empty();\n                 for o in obligations {\n                     match o.predicate.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(t, constness) => {\n-                            let pred = ty::PredicateKind::Trait(\n-                                ty::TraitPredicate {\n-                                    trait_ref: ty::TraitRef {\n-                                        def_id: t.def_id(),\n-                                        substs: self.infcx.tcx.mk_substs_trait(outer_ty, &[]),\n-                                    },\n+                        ty::PredicateKind::Trait(t) => {\n+                            let pred = ty::PredicateKind::Trait(ty::TraitPredicate {\n+                                trait_ref: ty::TraitRef {\n+                                    def_id: t.def_id(),\n+                                    substs: self.infcx.tcx.mk_substs_trait(outer_ty, &[]),\n                                 },\n-                                constness,\n-                            );\n+                                constness: t.constness,\n+                            });\n                             let obl = Obligation::new(\n                                 o.cause.clone(),\n                                 self.param_env,"}, {"sha": "208eb27c84406f7ebdf67a13b414d1e1a3444de5", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -587,9 +587,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n             let bound_predicate = obligation.predicate.kind();\n             let trait_pred = match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Trait(trait_pred, _)\n-                    if traits.contains(&trait_pred.def_id()) =>\n-                {\n+                ty::PredicateKind::Trait(trait_pred) if traits.contains(&trait_pred.def_id()) => {\n                     if unsize_did == trait_pred.def_id() {\n                         let self_ty = trait_pred.self_ty();\n                         let unsize_ty = trait_pred.trait_ref.substs[1].expect_ty();"}, {"sha": "316a097556aec685f1c7502ceabe40cf22bb10b6", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -1292,7 +1292,13 @@ pub fn check_type_bounds<'tcx>(\n     };\n \n     tcx.infer_ctxt().enter(move |infcx| {\n-        let inh = Inherited::new(infcx, impl_ty.def_id.expect_local());\n+        let constness = impl_ty\n+            .container\n+            .impl_def_id()\n+            .map(|did| tcx.impl_constness(did))\n+            .unwrap_or(hir::Constness::NotConst);\n+\n+        let inh = Inherited::with_constness(infcx, impl_ty.def_id.expect_local(), constness);\n         let infcx = &inh.infcx;\n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n@@ -1334,7 +1340,9 @@ pub fn check_type_bounds<'tcx>(\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        if let Err(ref errors) = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n+        if let Err(ref errors) =\n+            inh.fulfillment_cx.borrow_mut().select_all_with_constness_or_error(&infcx, constness)\n+        {\n             infcx.report_fulfillment_errors(errors, None, false);\n             return Err(ErrorReported);\n         }"}, {"sha": "c34dd705bef7b148c25737d6abc8251c752f2ec4", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -229,7 +229,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n             let predicate = predicate.kind();\n             let p = p.kind();\n             match (predicate.skip_binder(), p.skip_binder()) {\n-                (ty::PredicateKind::Trait(a, _), ty::PredicateKind::Trait(b, _)) => {\n+                (ty::PredicateKind::Trait(a), ty::PredicateKind::Trait(b)) => {\n                     relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n                 }\n                 (ty::PredicateKind::Projection(a), ty::PredicateKind::Projection(b)) => {"}, {"sha": "c13901ae8be2b7be59dc465008af303a4278766b", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -714,7 +714,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub(in super::super) fn select_all_obligations_or_error(&self) {\n         debug!(\"select_all_obligations_or_error\");\n-        if let Err(errors) = self.fulfillment_cx.borrow_mut().select_all_or_error(&self) {\n+        if let Err(errors) = self\n+            .fulfillment_cx\n+            .borrow_mut()\n+            .select_all_with_constness_or_error(&self, self.inh.constness)\n+        {\n             self.report_fulfillment_errors(&errors, self.inh.body_id, false);\n         }\n     }\n@@ -725,7 +729,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fallback_has_occurred: bool,\n         mutate_fulfillment_errors: impl Fn(&mut Vec<traits::FulfillmentError<'tcx>>),\n     ) {\n-        let result = self.fulfillment_cx.borrow_mut().select_where_possible(self);\n+        let result = self\n+            .fulfillment_cx\n+            .borrow_mut()\n+            .select_with_constness_where_possible(self, self.inh.constness);\n         if let Err(mut errors) = result {\n             mutate_fulfillment_errors(&mut errors);\n             self.report_fulfillment_errors(&errors, self.inh.body_id, fallback_has_occurred);\n@@ -796,7 +803,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         bound_predicate.rebind(data).required_poly_trait_ref(self.tcx),\n                         obligation,\n                     )),\n-                    ty::PredicateKind::Trait(data, _) => {\n+                    ty::PredicateKind::Trait(data) => {\n                         Some((bound_predicate.rebind(data).to_poly_trait_ref(), obligation))\n                     }\n                     ty::PredicateKind::Subtype(..) => None,"}, {"sha": "9952413353fa9ca04328d40131abbc67c75756af", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -923,7 +923,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 continue;\n             }\n \n-            if let ty::PredicateKind::Trait(predicate, _) =\n+            if let ty::PredicateKind::Trait(predicate) =\n                 error.obligation.predicate.kind().skip_binder()\n             {\n                 // Collect the argument position for all arguments that could have caused this\n@@ -974,7 +974,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let hir::ExprKind::Path(qpath) = &path.kind {\n                 if let hir::QPath::Resolved(_, path) = &qpath {\n                     for error in errors {\n-                        if let ty::PredicateKind::Trait(predicate, _) =\n+                        if let ty::PredicateKind::Trait(predicate) =\n                             error.obligation.predicate.kind().skip_binder()\n                         {\n                             // If any of the type arguments in this path segment caused the"}, {"sha": "c0ecee155c6dd0b381e15f5699b87d186f2db938", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -174,7 +174,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n \n     fn default_constness_for_trait_bounds(&self) -> hir::Constness {\n-        self.tcx.hir().get(self.body_id).constness()\n+        self.tcx.hir().get(self.body_id).constness_for_typeck()\n     }\n \n     fn get_type_parameter_bounds(\n@@ -194,7 +194,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n             predicates: tcx.arena.alloc_from_iter(\n                 self.param_env.caller_bounds().iter().filter_map(|predicate| {\n                     match predicate.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(data, _) if data.self_ty().is_param(index) => {\n+                        ty::PredicateKind::Trait(data) if data.self_ty().is_param(index) => {\n                             // HACK(eddyb) should get the original `Span`.\n                             let span = tcx.def_span(def_id);\n                             Some((predicate, span))"}, {"sha": "6006c8f7513d70d91eb3cd77187685c578273146", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -52,6 +52,9 @@ pub struct Inherited<'a, 'tcx> {\n     pub(super) deferred_generator_interiors:\n         RefCell<Vec<(hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n \n+    /// Reports whether this is in a const context.\n+    pub(super) constness: hir::Constness,\n+\n     pub(super) body_id: Option<hir::BodyId>,\n }\n \n@@ -93,6 +96,16 @@ impl<'tcx> InheritedBuilder<'tcx> {\n \n impl Inherited<'a, 'tcx> {\n     pub(super) fn new(infcx: InferCtxt<'a, 'tcx>, def_id: LocalDefId) -> Self {\n+        let tcx = infcx.tcx;\n+        let item_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        Self::with_constness(infcx, def_id, tcx.hir().get(item_id).constness_for_typeck())\n+    }\n+\n+    pub(super) fn with_constness(\n+        infcx: InferCtxt<'a, 'tcx>,\n+        def_id: LocalDefId,\n+        constness: hir::Constness,\n+    ) -> Self {\n         let tcx = infcx.tcx;\n         let item_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let body_id = tcx.hir().maybe_body_owned_by(item_id);\n@@ -108,6 +121,7 @@ impl Inherited<'a, 'tcx> {\n             deferred_call_resolutions: RefCell::new(Default::default()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n+            constness,\n             body_id,\n         }\n     }"}, {"sha": "88be49e96e7be3f7da39723e20bc383cd32d0efa", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -507,7 +507,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n             // We don't care about regions here.\n             .filter_map(|obligation| match obligation.predicate.kind().skip_binder() {\n-                ty::PredicateKind::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n+                ty::PredicateKind::Trait(trait_pred) if trait_pred.def_id() == sized_def_id => {\n                     let span = iter::zip(&predicates.predicates, &predicates.spans)\n                         .find_map(\n                             |(p, span)| {"}, {"sha": "c6e6c8c5d70e2f7d6dd8a686855b6adae62a43f6", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -832,7 +832,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         let bounds = self.param_env.caller_bounds().iter().filter_map(|predicate| {\n             let bound_predicate = predicate.kind();\n             match bound_predicate.skip_binder() {\n-                ty::PredicateKind::Trait(trait_predicate, _) => {\n+                ty::PredicateKind::Trait(trait_predicate) => {\n                     match *trait_predicate.trait_ref.self_ty().kind() {\n                         ty::Param(p) if p == param_ty => {\n                             Some(bound_predicate.rebind(trait_predicate.trait_ref))"}, {"sha": "1d5a9e3e1f968fed8efab7a6820e5467af12da6f", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -683,7 +683,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut collect_type_param_suggestions =\n                         |self_ty: Ty<'tcx>, parent_pred: &ty::Predicate<'tcx>, obligation: &str| {\n                             // We don't care about regions here, so it's fine to skip the binder here.\n-                            if let (ty::Param(_), ty::PredicateKind::Trait(p, _)) =\n+                            if let (ty::Param(_), ty::PredicateKind::Trait(p)) =\n                                 (self_ty.kind(), parent_pred.kind().skip_binder())\n                             {\n                                 if let ty::Adt(def, _) = p.trait_ref.self_ty().kind() {\n@@ -763,7 +763,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n                                 Some((obligation, projection_ty.self_ty()))\n                             }\n-                            ty::PredicateKind::Trait(poly_trait_ref, _) => {\n+                            ty::PredicateKind::Trait(poly_trait_ref) => {\n                                 let p = poly_trait_ref.trait_ref;\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n@@ -1200,7 +1200,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     match p.kind().skip_binder() {\n                         // Hide traits if they are present in predicates as they can be fixed without\n                         // having to implement them.\n-                        ty::PredicateKind::Trait(t, _) => t.def_id() == info.def_id,\n+                        ty::PredicateKind::Trait(t) => t.def_id() == info.def_id,\n                         ty::PredicateKind::Projection(p) => {\n                             p.projection_ty.item_def_id == info.def_id\n                         }"}, {"sha": "d1e583ed1845a991ba32a964f69898228fa3e089", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -689,7 +689,7 @@ fn bounds_from_generic_predicates<'tcx>(\n         debug!(\"predicate {:?}\", predicate);\n         let bound_predicate = predicate.kind();\n         match bound_predicate.skip_binder() {\n-            ty::PredicateKind::Trait(trait_predicate, _) => {\n+            ty::PredicateKind::Trait(trait_predicate) => {\n                 let entry = types.entry(trait_predicate.self_ty()).or_default();\n                 let def_id = trait_predicate.def_id();\n                 if Some(def_id) != tcx.lang_items().sized_trait() {"}, {"sha": "9fbf5ab85334f8584b3e884f3b08bba54c07839b", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -364,7 +364,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n     }\n \n     fn default_constness_for_trait_bounds(&self) -> hir::Constness {\n-        self.node().constness()\n+        self.node().constness_for_typeck()\n     }\n \n     fn get_type_parameter_bounds(\n@@ -640,7 +640,7 @@ fn type_param_predicates(\n         )\n         .into_iter()\n         .filter(|(predicate, _)| match predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(data, _) => data.self_ty().is_param(index),\n+            ty::PredicateKind::Trait(data) => data.self_ty().is_param(index),\n             _ => false,\n         }),\n     );\n@@ -1198,7 +1198,7 @@ fn super_predicates_that_define_assoc_type(\n             // which will, in turn, reach indirect supertraits.\n             for &(pred, span) in superbounds {\n                 debug!(\"superbound: {:?}\", pred);\n-                if let ty::PredicateKind::Trait(bound, _) = pred.kind().skip_binder() {\n+                if let ty::PredicateKind::Trait(bound) = pred.kind().skip_binder() {\n                     tcx.at(span).super_predicates_of(bound.def_id());\n                 }\n             }\n@@ -2439,7 +2439,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n             .iter()\n             .copied()\n             .filter(|(pred, _)| match pred.kind().skip_binder() {\n-                ty::PredicateKind::Trait(tr, _) => !is_assoc_item_ty(tr.self_ty()),\n+                ty::PredicateKind::Trait(tr) => !is_assoc_item_ty(tr.self_ty()),\n                 ty::PredicateKind::Projection(proj) => {\n                     !is_assoc_item_ty(proj.projection_ty.self_ty())\n                 }"}, {"sha": "1d08c4450afcfcb1595ab811ede3fc914ebdf411", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -38,7 +38,7 @@ fn associated_type_bounds<'tcx>(\n \n     let bounds_from_parent = trait_predicates.predicates.iter().copied().filter(|(pred, _)| {\n         match pred.kind().skip_binder() {\n-            ty::PredicateKind::Trait(tr, _) => tr.self_ty() == item_ty,\n+            ty::PredicateKind::Trait(tr) => tr.self_ty() == item_ty,\n             ty::PredicateKind::Projection(proj) => proj.projection_ty.self_ty() == item_ty,\n             ty::PredicateKind::TypeOutlives(outlives) => outlives.0 == item_ty,\n             _ => false,"}, {"sha": "d5d81603fc5167239a6579d68d267f3dfd5d415b", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -366,7 +366,10 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n         _ if predicate.is_global() => (),\n         // We allow specializing on explicitly marked traits with no associated\n         // items.\n-        ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n+        ty::PredicateKind::Trait(ty::TraitPredicate {\n+            trait_ref,\n+            constness: hir::Constness::NotConst,\n+        }) => {\n             if !matches!(\n                 trait_predicate_kind(tcx, predicate),\n                 Some(TraitSpecializationKind::Marker)\n@@ -376,7 +379,7 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n                         span,\n                         &format!(\n                             \"cannot specialize on trait `{}`\",\n-                            tcx.def_path_str(pred.def_id()),\n+                            tcx.def_path_str(trait_ref.def_id),\n                         ),\n                     )\n                     .emit()\n@@ -394,10 +397,11 @@ fn trait_predicate_kind<'tcx>(\n     predicate: ty::Predicate<'tcx>,\n ) -> Option<TraitSpecializationKind> {\n     match predicate.kind().skip_binder() {\n-        ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n-            Some(tcx.trait_def(pred.def_id()).specialization_kind)\n-        }\n-        ty::PredicateKind::Trait(_, hir::Constness::Const)\n+        ty::PredicateKind::Trait(ty::TraitPredicate {\n+            trait_ref,\n+            constness: hir::Constness::NotConst,\n+        }) => Some(tcx.trait_def(trait_ref.def_id).specialization_kind),\n+        ty::PredicateKind::Trait(_)\n         | ty::PredicateKind::RegionOutlives(_)\n         | ty::PredicateKind::TypeOutlives(_)\n         | ty::PredicateKind::Projection(_)"}, {"sha": "17e538483431ca0573317c64f98248920eeb7f7a", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -1786,13 +1786,6 @@ fn test_ord_absence() {\n     }\n }\n \n-#[allow(dead_code)]\n-fn test_const() {\n-    const MAP: &'static BTreeMap<(), ()> = &BTreeMap::new();\n-    const LEN: usize = MAP.len();\n-    const IS_EMPTY: bool = MAP.is_empty();\n-}\n-\n #[test]\n fn test_occupied_entry_key() {\n     let mut a = BTreeMap::new();"}, {"sha": "5d590a26281d2b993d38aea9e7e6e1ca0eba46eb", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -16,13 +16,6 @@ fn test_clone_eq() {\n     assert_eq!(m.clone(), m);\n }\n \n-#[allow(dead_code)]\n-fn test_const() {\n-    const SET: &'static BTreeSet<()> = &BTreeSet::new();\n-    const LEN: usize = SET.len();\n-    const IS_EMPTY: bool = SET.is_empty();\n-}\n-\n #[test]\n fn test_iter_min_max() {\n     let mut a = BTreeSet::new();"}, {"sha": "02e8f8f40228f3231a420f4b33c1868735990cc3", "filename": "library/alloc/tests/const_fns.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/library%2Falloc%2Ftests%2Fconst_fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/library%2Falloc%2Ftests%2Fconst_fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fconst_fns.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -0,0 +1,53 @@\n+// Test several functions can be used for constants\n+// 1. Vec::new()\n+// 2. String::new()\n+// 3. BTreeMap::new()\n+// 4. BTreeSet::new()\n+\n+#[allow(dead_code)]\n+pub const MY_VEC: Vec<usize> = Vec::new();\n+\n+#[allow(dead_code)]\n+pub const MY_STRING: String = String::new();\n+\n+// FIXME remove this struct once we put `K: ?const Ord` on BTreeMap::new.\n+#[derive(PartialEq, Eq, PartialOrd)]\n+pub struct MyType;\n+\n+impl const Ord for MyType {\n+    fn cmp(&self, _: &Self) -> Ordering {\n+        Ordering::Equal\n+    }\n+\n+    fn max(self, _: Self) -> Self {\n+        Self\n+    }\n+\n+    fn min(self, _: Self) -> Self {\n+        Self\n+    }\n+\n+    fn clamp(self, _: Self, _: Self) -> Self {\n+        Self\n+    }\n+}\n+\n+use core::cmp::Ordering;\n+use std::collections::{BTreeMap, BTreeSet};\n+\n+pub const MY_BTREEMAP: BTreeMap<MyType, MyType> = BTreeMap::new();\n+pub const MAP: &'static BTreeMap<MyType, MyType> = &MY_BTREEMAP;\n+pub const MAP_LEN: usize = MAP.len();\n+pub const MAP_IS_EMPTY: bool = MAP.is_empty();\n+\n+pub const MY_BTREESET: BTreeSet<MyType> = BTreeSet::new();\n+pub const SET: &'static BTreeSet<MyType> = &MY_BTREESET;\n+pub const SET_LEN: usize = SET.len();\n+pub const SET_IS_EMPTY: bool = SET.is_empty();\n+\n+#[test]\n+fn test_const() {\n+    assert_eq!(MAP_LEN, 0);\n+    assert_eq!(SET_LEN, 0);\n+    assert!(MAP_IS_EMPTY && SET_IS_EMPTY)\n+}"}, {"sha": "f7d68b5a89e99d925e8b296367abbfa5c897f933", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -23,6 +23,10 @@\n #![feature(slice_partition_dedup)]\n #![feature(vec_spare_capacity)]\n #![feature(string_remove_matches)]\n+#![feature(const_btree_new)]\n+#![feature(const_trait_impl)]\n+// FIXME remove this when const_trait_impl is not incomplete anymore\n+#![allow(incomplete_features)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};\n@@ -32,6 +36,7 @@ mod binary_heap;\n mod borrow;\n mod boxed;\n mod btree_set_hash;\n+mod const_fns;\n mod cow_str;\n mod fmt;\n mod heap;"}, {"sha": "58a87673241f58ff07597906f3e04b0f111ec028", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -316,7 +316,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         let bound_predicate = pred.kind();\n         let tcx = self.cx.tcx;\n         let regions = match bound_predicate.skip_binder() {\n-            ty::PredicateKind::Trait(poly_trait_pred, _) => {\n+            ty::PredicateKind::Trait(poly_trait_pred) => {\n                 tcx.collect_referenced_late_bound_regions(&bound_predicate.rebind(poly_trait_pred))\n             }\n             ty::PredicateKind::Projection(poly_proj_pred) => {\n@@ -463,7 +463,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .filter(|p| {\n                 !orig_bounds.contains(p)\n                     || match p.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(pred, _) => pred.def_id() == sized_trait,\n+                        ty::PredicateKind::Trait(pred) => pred.def_id() == sized_trait,\n                         _ => false,\n                     }\n             })"}, {"sha": "02cfea914209bb09b6e6484f06efa91d4bd91e17", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -325,7 +325,7 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n         let bound_predicate = self.kind();\n         match bound_predicate.skip_binder() {\n-            ty::PredicateKind::Trait(pred, _) => Some(bound_predicate.rebind(pred).clean(cx)),\n+            ty::PredicateKind::Trait(pred) => Some(bound_predicate.rebind(pred).clean(cx)),\n             ty::PredicateKind::RegionOutlives(pred) => pred.clean(cx),\n             ty::PredicateKind::TypeOutlives(pred) => pred.clean(cx),\n             ty::PredicateKind::Projection(pred) => Some(pred.clean(cx)),\n@@ -637,7 +637,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n                 let param_idx = (|| {\n                     let bound_p = p.kind();\n                     match bound_p.skip_binder() {\n-                        ty::PredicateKind::Trait(pred, _constness) => {\n+                        ty::PredicateKind::Trait(pred) => {\n                             if let ty::Param(param) = pred.self_ty().kind() {\n                                 return Some(param.index);\n                             }\n@@ -1555,9 +1555,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     .filter_map(|bound| {\n                         let bound_predicate = bound.kind();\n                         let trait_ref = match bound_predicate.skip_binder() {\n-                            ty::PredicateKind::Trait(tr, _constness) => {\n-                                bound_predicate.rebind(tr.trait_ref)\n-                            }\n+                            ty::PredicateKind::Trait(tr) => bound_predicate.rebind(tr.trait_ref),\n                             ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n                                 if let Some(r) = reg.clean(cx) {\n                                     regions.push(GenericBound::Outlives(r));"}, {"sha": "c0d52d349280f09b538503150e89e078c59d9d85", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -139,7 +139,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId, trait_: DefId)\n         .predicates\n         .iter()\n         .filter_map(|(pred, _)| {\n-            if let ty::PredicateKind::Trait(pred, _) = pred.kind().skip_binder() {\n+            if let ty::PredicateKind::Trait(pred) = pred.kind().skip_binder() {\n                 if pred.trait_ref.self_ty() == self_ty { Some(pred.def_id()) } else { None }\n             } else {\n                 None"}, {"sha": "978f25f9a93449a587300e2b20ddbfe136319116", "filename": "src/test/ui/collections-const-new.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fa2692990c05652c7823c8d2afae501a00a69050/src%2Ftest%2Fui%2Fcollections-const-new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa2692990c05652c7823c8d2afae501a00a69050/src%2Ftest%2Fui%2Fcollections-const-new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcollections-const-new.rs?ref=fa2692990c05652c7823c8d2afae501a00a69050", "patch": "@@ -1,20 +0,0 @@\n-// check-pass\n-\n-// Test several functions can be used for constants\n-// 1. Vec::new()\n-// 2. String::new()\n-// 3. BTreeMap::new()\n-// 4. BTreeSet::new()\n-\n-#![feature(const_btree_new)]\n-\n-const MY_VEC: Vec<usize> = Vec::new();\n-\n-const MY_STRING: String = String::new();\n-\n-use std::collections::{BTreeMap, BTreeSet};\n-const MY_BTREEMAP: BTreeMap<u32, u32> = BTreeMap::new();\n-\n-const MY_BTREESET: BTreeSet<u32> = BTreeSet::new();\n-\n-fn main() {}"}, {"sha": "bb8113e53f9c19f917d1e5fd4cd694860d02a899", "filename": "src/test/ui/consts/const-eval/issue-49296.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -1,8 +1,10 @@\n // issue-49296: Unsafe shenigans in constants can result in missing errors\n \n #![feature(const_fn_trait_bound)]\n+#![feature(const_trait_bound_opt_out)]\n+#![allow(incomplete_features)]\n \n-const unsafe fn transmute<T: Copy, U: Copy>(t: T) -> U {\n+const unsafe fn transmute<T: ?const Copy, U: ?const Copy>(t: T) -> U {\n     #[repr(C)]\n     union Transmute<T: Copy, U: Copy> {\n         from: T,"}, {"sha": "28fdcb7c486371ddb1cdfaf37b0dd789b54733be", "filename": "src/test/ui/consts/const-eval/issue-49296.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-49296.stderr?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -1,5 +1,5 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/issue-49296.rs:18:16\n+  --> $DIR/issue-49296.rs:20:16\n    |\n LL | const X: u64 = *wat(42);\n    |                ^^^^^^^^ pointer to alloc2 was dereferenced after this allocation got freed"}, {"sha": "e7f801a7bd4b1c2cf84f2f977594fbd3a1840736", "filename": "src/test/ui/generic-associated-types/projection-bound-cycle-generic.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle-generic.stderr?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -1,8 +1,8 @@\n error[E0275]: overflow evaluating the requirement `<T as Foo>::Item: Sized`\n   --> $DIR/projection-bound-cycle-generic.rs:44:18\n    |\n-LL | struct OnlySized<T> where T: Sized { f: T }\n-   |                  - required by this bound in `OnlySized`\n+LL |     type Item: Sized where <Self as Foo>::Item: Sized;\n+   |                                                 ----- required by this bound in `Foo::Item`\n ...\n LL |     type Assoc = OnlySized<<T as Foo>::Item>;\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "67195c65d36e6456f2ddd1bf18f4fc7faf443543", "filename": "src/test/ui/generic-associated-types/projection-bound-cycle.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fprojection-bound-cycle.stderr?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -1,8 +1,8 @@\n error[E0275]: overflow evaluating the requirement `<T as Foo>::Item: Sized`\n   --> $DIR/projection-bound-cycle.rs:46:18\n    |\n-LL | struct OnlySized<T> where T: Sized { f: T }\n-   |                  - required by this bound in `OnlySized`\n+LL |     type Item: Sized where <Self as Foo>::Item: Sized;\n+   |                                                 ----- required by this bound in `Foo::Item`\n ...\n LL |     type Assoc = OnlySized<<T as Foo>::Item>;\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "1dbd000afd73ebf0debdf5058268f79e35c7d310", "filename": "src/test/ui/rfc-2632-const-trait-impl/assoc-type.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -1,9 +1,7 @@\n-// ignore-test\n-\n-// FIXME: This test should fail since, within a const impl of `Foo`, the bound on `Foo::Bar` should\n-// require a const impl of `Add` for the associated type.\n-\n+// FIXME(fee1-dead): this should have a better error message\n #![feature(const_trait_impl)]\n+#![feature(const_trait_bound_opt_out)]\n+#![allow(incomplete_features)]\n \n struct NonConstAdd(i32);\n \n@@ -21,6 +19,15 @@ trait Foo {\n \n impl const Foo for NonConstAdd {\n     type Bar = NonConstAdd;\n+    //~^ ERROR\n+}\n+\n+trait Baz {\n+    type Qux: ?const std::ops::Add;\n+}\n+\n+impl const Baz for NonConstAdd {\n+    type Qux = NonConstAdd; // OK\n }\n \n fn main() {}"}, {"sha": "f690d95cc589b69ffc29f7afbd52464a6db8c222", "filename": "src/test/ui/rfc-2632-const-trait-impl/assoc-type.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: cannot add `NonConstAdd` to `NonConstAdd`\n+  --> $DIR/assoc-type.rs:21:5\n+   |\n+LL |     type Bar: std::ops::Add;\n+   |               ------------- required by this bound in `Foo::Bar`\n+...\n+LL |     type Bar = NonConstAdd;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `NonConstAdd + NonConstAdd`\n+   |\n+   = help: the trait `Add` is not implemented for `NonConstAdd`\n+help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+   |\n+LL | impl const Foo for NonConstAdd where NonConstAdd: Add {\n+   |                                ++++++++++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8343974f8c7e756358600e41d278e2cd72249c35", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-generic-method-nonconst.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-nonconst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-nonconst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-nonconst.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -1,7 +1,5 @@\n-// FIXME(jschievink): this is not rejected correctly (only when the non-const impl is actually used)\n-// ignore-test\n-\n #![feature(const_trait_impl)]\n+#![feature(const_fn_trait_bound)]\n \n struct S;\n "}, {"sha": "75c7cab362147daa42bc0dbf483c69146c543e91", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-generic-method-nonconst.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-nonconst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-nonconst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-nonconst.stderr?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: can't compare `S` with `S`\n+  --> $DIR/call-generic-method-nonconst.rs:19:34\n+   |\n+LL | const fn equals_self<T: PartialEq>(t: &T) -> bool {\n+   |                         --------- required by this bound in `equals_self`\n+...\n+LL | pub const EQ: bool = equals_self(&S);\n+   |                                  ^^ no implementation for `S == S`\n+   |\n+   = help: the trait `PartialEq` is not implemented for `S`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "3e35ada7b2a1c909aaeb416f8e11d8be6bc85c31", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -93,7 +93,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                             cx.tcx.infer_ctxt().enter(|infcx| {\n                                 for FulfillmentError { obligation, .. } in send_errors {\n                                     infcx.maybe_note_obligation_cause_for_async_await(db, &obligation);\n-                                    if let Trait(trait_pred, _) = obligation.predicate.kind().skip_binder() {\n+                                    if let Trait(trait_pred) = obligation.predicate.kind().skip_binder() {\n                                         db.note(&format!(\n                                             \"`{}` doesn't implement `{}`\",\n                                             trait_pred.self_ty(),"}, {"sha": "5e559991c1697980d38fcb1798aafea3d890e2b7", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -121,7 +121,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n             .filter_map(|obligation| {\n                 // Note that we do not want to deal with qualified predicates here.\n                 match obligation.predicate.kind().no_bound_vars() {\n-                    Some(ty::PredicateKind::Trait(pred, _)) if pred.def_id() != sized_trait => Some(pred),\n+                    Some(ty::PredicateKind::Trait(pred)) if pred.def_id() != sized_trait => Some(pred),\n                     _ => None,\n                 }\n             })"}, {"sha": "ee675838c4cb3a1de9aa3d12fa1cfd90e8ed7845", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -45,7 +45,7 @@ fn get_trait_predicates_for_trait_id<'tcx>(\n     let mut preds = Vec::new();\n     for (pred, _) in generics.predicates {\n         if_chain! {\n-            if let PredicateKind::Trait(poly_trait_pred, _) = pred.kind().skip_binder();\n+            if let PredicateKind::Trait(poly_trait_pred) = pred.kind().skip_binder();\n             let trait_pred = cx.tcx.erase_late_bound_regions(pred.kind().rebind(poly_trait_pred));\n             if let Some(trait_def_id) = trait_id;\n             if trait_def_id == trait_pred.trait_ref.def_id;"}, {"sha": "dee9d487c78ea28a5ec1826bbfdd5e0f61f31681", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -36,7 +36,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv: Option<&Ru\n                 ty::PredicateKind::ObjectSafe(_) => panic!(\"object safe predicate on function: {:#?}\", predicate),\n                 ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {:#?}\", predicate),\n                 ty::PredicateKind::Subtype(_) => panic!(\"subtype predicate on function: {:#?}\", predicate),\n-                ty::PredicateKind::Trait(pred, _) => {\n+                ty::PredicateKind::Trait(pred) => {\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;\n                     }"}, {"sha": "a2221a0b283b0425a8d8e9f3e061f4af88edfae9", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136eaa1b25d13635b773a481ecab61a3162cb627/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=136eaa1b25d13635b773a481ecab61a3162cb627", "patch": "@@ -157,7 +157,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::Tuple(substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n-                if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder() {\n+                if let ty::PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder() {\n                     if must_use_attr(cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n                         return true;\n                     }"}]}