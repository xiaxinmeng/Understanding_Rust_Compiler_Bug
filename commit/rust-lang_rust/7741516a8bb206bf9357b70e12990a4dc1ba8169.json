{"sha": "7741516a8bb206bf9357b70e12990a4dc1ba8169", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3NDE1MTZhOGJiMjA2YmY5MzU3YjcwZTEyOTkwYTRkYzFiYTgxNjk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-11T17:44:17Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-15T03:03:56Z"}, "message": "std: Collapse SlicePrelude traits\n\nThis commit collapses the various prelude traits for slices into just one trait:\n\n* SlicePrelude/SliceAllocPrelude => SliceExt\n* CloneSlicePrelude/CloneSliceAllocPrelude => CloneSliceExt\n* OrdSlicePrelude/OrdSliceAllocPrelude => OrdSliceExt\n* PartialEqSlicePrelude => PartialEqSliceExt", "tree": {"sha": "4b50ad5a0d83241f97dc0b43aa1bca88226691fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b50ad5a0d83241f97dc0b43aa1bca88226691fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7741516a8bb206bf9357b70e12990a4dc1ba8169", "comment_count": 11, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7741516a8bb206bf9357b70e12990a4dc1ba8169", "html_url": "https://github.com/rust-lang/rust/commit/7741516a8bb206bf9357b70e12990a4dc1ba8169", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7741516a8bb206bf9357b70e12990a4dc1ba8169/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "126db549b038c84269a1e4fe46f051b2c15d6970", "url": "https://api.github.com/repos/rust-lang/rust/commits/126db549b038c84269a1e4fe46f051b2c15d6970", "html_url": "https://github.com/rust-lang/rust/commit/126db549b038c84269a1e4fe46f051b2c15d6970"}], "stats": {"total": 1321, "additions": 782, "deletions": 539}, "files": [{"sha": "63f1b3dcd4414f2fd4ec946acb3d5ab3db7ccf26", "filename": "src/etc/unicode.py", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -289,7 +289,7 @@ def emit_bsearch_range_table(f):\n     f.write(\"\"\"\n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::Ordering::{Equal, Less, Greater};\n-    use core::slice::SlicePrelude;\n+    use core::slice::SliceExt;\n     r.binary_search(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n         else if hi < c { Less }\n@@ -347,7 +347,7 @@ def emit_conversions_module(f, lowerupper, upperlower):\n     f.write(\"pub mod conversions {\")\n     f.write(\"\"\"\n     use core::cmp::Ordering::{Equal, Less, Greater};\n-    use core::slice::SlicePrelude;\n+    use core::slice::SliceExt;\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n     use core::slice;\n@@ -386,8 +386,8 @@ def emit_conversions_module(f, lowerupper, upperlower):\n \n def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n     f.write(\"\"\"pub mod grapheme {\n-    use core::slice::SlicePrelude;\n     use core::kinds::Copy;\n+    use core::slice::SliceExt;\n     pub use self::GraphemeCat::*;\n     use core::slice;\n \n@@ -431,7 +431,7 @@ def emit_charwidth_module(f, width_table):\n     f.write(\"pub mod charwidth {\\n\")\n     f.write(\"    use core::option::Option;\\n\")\n     f.write(\"    use core::option::Option::{Some, None};\\n\")\n-    f.write(\"    use core::slice::SlicePrelude;\\n\")\n+    f.write(\"    use core::slice::SliceExt;\\n\")\n     f.write(\"    use core::slice;\\n\")\n     f.write(\"\"\"\n     fn bsearch_range_value_table(c: char, is_cjk: bool, r: &'static [(char, char, u8, u8)]) -> u8 {\n@@ -531,7 +531,7 @@ def comp_pfun(char):\n     f.write(\"\"\"\n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n         use core::cmp::Ordering::{Equal, Less, Greater};\n-        use core::slice::SlicePrelude;\n+        use core::slice::SliceExt;\n         use core::slice;\n         match r.binary_search(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }"}, {"sha": "446ebbbdbe988b9d2a48729530adada470ed583a", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -297,7 +297,7 @@ mod tests {\n     use core::kinds::Sized;\n     use std::mem;\n \n-    use slice::SlicePrelude;\n+    use slice::SliceExt;\n     use super::{Hash, Hasher, Writer};\n \n     struct MyWriterHasher;"}, {"sha": "575e407fc2ab3f751885301cb77d29990a7eff57", "filename": "src/libcollections/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcollections%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcollections%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fsip.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -276,7 +276,7 @@ mod tests {\n \n     use str::Str;\n     use string::String;\n-    use slice::{AsSlice, SlicePrelude};\n+    use slice::{AsSlice, SliceExt};\n     use vec::Vec;\n \n     use super::super::{Hash, Writer};"}, {"sha": "274fa13d074499c2da72bee305770fe1bcd40d6c", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -24,7 +24,7 @@\n #![allow(unknown_features)]\n #![feature(macro_rules, default_type_params, phase, globs)]\n #![feature(unsafe_destructor, import_shadowing, slicing_syntax)]\n-#![feature(tuple_indexing, unboxed_closures)]\n+#![feature(unboxed_closures)]\n #![no_std]\n \n #[phase(plugin, link)] extern crate core;"}, {"sha": "1ec3f1033e13ef02876122436cc32e63e531315d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 683, "deletions": 15, "changes": 698, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -43,7 +43,7 @@\n //! ## Traits\n //!\n //! A number of traits add methods that allow you to accomplish tasks\n-//! with slices, the most important being `SlicePrelude`. Other traits\n+//! with slices, the most important being `SliceExt`. Other traits\n //! apply only to slices of elements satisfying certain bounds (like\n //! `Ord`).\n //!\n@@ -87,26 +87,27 @@\n \n #![doc(primitive = \"slice\")]\n \n-use self::Direction::*;\n use alloc::boxed::Box;\n use core::borrow::{BorrowFrom, BorrowFromMut, ToOwned};\n use core::cmp;\n+use core::iter::{range_step, MultiplicativeIterator};\n use core::kinds::{Copy, Sized};\n use core::mem::size_of;\n use core::mem;\n use core::ops::FnMut;\n use core::prelude::{Clone, Greater, Iterator, IteratorExt, Less, None, Option};\n use core::prelude::{Ord, Ordering, RawPtr, Some, range};\n use core::ptr;\n-use core::iter::{range_step, MultiplicativeIterator};\n+use core::slice as core_slice;\n+use self::Direction::*;\n \n use vec::Vec;\n \n-pub use core::slice::{Chunks, AsSlice, SlicePrelude, PartialEqSlicePrelude};\n-pub use core::slice::{OrdSlicePrelude, SlicePrelude, Items, MutItems};\n+pub use core::slice::{Chunks, AsSlice, SplitsN, Windows};\n+pub use core::slice::{Items, MutItems, PartialEqSliceExt};\n pub use core::slice::{ImmutableIntSlice, MutableIntSlice};\n pub use core::slice::{MutSplits, MutChunks, Splits};\n-pub use core::slice::{bytes, mut_ref_slice, ref_slice, CloneSlicePrelude};\n+pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n pub use core::slice::{from_raw_buf, from_raw_mut_buf, BinarySearchResult};\n \n // Functional utilities\n@@ -274,12 +275,12 @@ impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n }\n \n /// Extension methods for boxed slices.\n-pub trait BoxedSlicePrelude<T> {\n+pub trait BoxedSliceExt<T> {\n     /// Convert `self` into a vector without clones or allocation.\n     fn into_vec(self) -> Vec<T>;\n }\n \n-impl<T> BoxedSlicePrelude<T> for Box<[T]> {\n+impl<T> BoxedSliceExt<T> for Box<[T]> {\n     #[experimental]\n     fn into_vec(mut self) -> Vec<T> {\n         unsafe {\n@@ -291,7 +292,7 @@ impl<T> BoxedSlicePrelude<T> for Box<[T]> {\n }\n \n /// Allocating extension methods for slices containing `Clone` elements.\n-pub trait CloneSliceAllocPrelude<T> for Sized? {\n+pub trait CloneSliceExt<T> for Sized? {\n     /// Copies `self` into a new `Vec`.\n     fn to_vec(&self) -> Vec<T>;\n \n@@ -324,9 +325,28 @@ pub trait CloneSliceAllocPrelude<T> for Sized? {\n     /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n     /// ```\n     fn permutations(&self) -> Permutations<T>;\n+\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut dst = [0i, 0, 0];\n+    /// let src = [1i, 2];\n+    ///\n+    /// assert!(dst.clone_from_slice(&src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n+    ///\n+    /// let src2 = [3i, 4, 5, 6];\n+    /// assert!(dst.clone_from_slice(&src2) == 3);\n+    /// assert!(dst == [3i, 4, 5]);\n+    /// ```\n+    fn clone_from_slice(&mut self, &[T]) -> uint;\n }\n \n-impl<T: Clone> CloneSliceAllocPrelude<T> for [T] {\n+impl<T: Clone> CloneSliceExt<T> for [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n     fn to_vec(&self) -> Vec<T> {\n@@ -360,6 +380,9 @@ impl<T: Clone> CloneSliceAllocPrelude<T> for [T] {\n         }\n     }\n \n+    fn clone_from_slice(&mut self, src: &[T]) -> uint {\n+        core_slice::CloneSliceExt::clone_from_slice(self, src)\n+    }\n }\n \n fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Ordering {\n@@ -567,7 +590,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n \n /// Allocating extension methods for slices on Ord values.\n #[experimental = \"likely to merge with other traits\"]\n-pub trait OrdSliceAllocPrelude<T> for Sized? {\n+pub trait OrdSliceExt<T> for Sized? {\n     /// Sorts the slice, in place.\n     ///\n     /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n@@ -582,19 +605,95 @@ pub trait OrdSliceAllocPrelude<T> for Sized? {\n     /// ```\n     #[experimental]\n     fn sort(&mut self);\n-}\n \n-impl<T: Ord> OrdSliceAllocPrelude<T> for [T] {\n+    /// Binary search a sorted slice for a given element.\n+    ///\n+    /// If the value is found then `Found` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `NotFound` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n+    ///\n+    /// ```rust\n+    /// use std::slice::BinarySearchResult::{Found, NotFound};\n+    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n+    ///\n+    /// assert_eq!(s.binary_search_elem(&13),  Found(9));\n+    /// assert_eq!(s.binary_search_elem(&4),   NotFound(7));\n+    /// assert_eq!(s.binary_search_elem(&100), NotFound(13));\n+    /// let r = s.binary_search_elem(&1);\n+    /// assert!(match r { Found(1...4) => true, _ => false, });\n+    /// ```\n+    #[unstable = \"name likely to change\"]\n+    fn binary_search_elem(&self, x: &T) -> BinarySearchResult;\n+\n+    /// Mutates the slice to the next lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// last-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [0i, 1, 2];\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.next_permutation();\n+    /// let b: &mut [_] = &mut [1i, 0, 2];\n+    /// assert!(v == b);\n+    /// ```\n+    #[experimental]\n+    fn next_permutation(&mut self) -> bool;\n+\n+    /// Mutates the slice to the previous lexicographic permutation.\n+    ///\n+    /// Returns `true` if successful and `false` if the slice is at the\n+    /// first-ordered permutation.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let v: &mut [_] = &mut [1i, 0, 2];\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 2, 1];\n+    /// assert!(v == b);\n+    /// v.prev_permutation();\n+    /// let b: &mut [_] = &mut [0i, 1, 2];\n+    /// assert!(v == b);\n+    /// ```\n     #[experimental]\n+    fn prev_permutation(&mut self) -> bool;\n+}\n+\n+impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[inline]\n     fn sort(&mut self) {\n         self.sort_by(|a, b| a.cmp(b))\n     }\n+\n+    fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n+        core_slice::OrdSliceExt::binary_search_elem(self, x)\n+    }\n+\n+    fn next_permutation(&mut self) -> bool {\n+        core_slice::OrdSliceExt::next_permutation(self)\n+    }\n+\n+    fn prev_permutation(&mut self) -> bool {\n+        core_slice::OrdSliceExt::prev_permutation(self)\n+    }\n }\n \n /// Allocating extension methods for slices.\n #[experimental = \"likely to merge with other traits\"]\n-pub trait SliceAllocPrelude<T> for Sized? {\n+pub trait SliceExt<T> for Sized? {\n     /// Sorts the slice, in place, using `compare` to compare\n     /// elements.\n     ///\n@@ -636,9 +735,376 @@ pub trait SliceAllocPrelude<T> for Sized? {\n     /// assert!(a == [6i, 7, 8, 4, 5]);\n     /// ```\n     fn move_from(&mut self, src: Vec<T>, start: uint, end: uint) -> uint;\n+\n+    /// Returns a subslice spanning the interval [`start`, `end`).\n+    ///\n+    /// Panics when the end of the new slice lies beyond the end of the\n+    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n+    ///\n+    /// Slicing with `start` equal to `end` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n+    fn slice(&self, start: uint, end: uint) -> &[T];\n+\n+    /// Returns a subslice from `start` to the end of the slice.\n+    ///\n+    /// Panics when `start` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing from `self.len()` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n+    fn slice_from(&self, start: uint) -> &[T];\n+\n+    /// Returns a subslice from the start of the slice to `end`.\n+    ///\n+    /// Panics when `end` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing to `0` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n+    fn slice_to(&self, end: uint) -> &[T];\n+\n+    /// Divides one slice into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// Panics if `mid > len`.\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn split_at(&self, mid: uint) -> (&[T], &[T]);\n+\n+    /// Returns an iterator over the slice\n+    #[unstable = \"iterator type may change\"]\n+    fn iter(&self) -> Items<T>;\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`.  The matched element is not contained in the subslices.\n+    #[unstable = \"iterator type may change, waiting on unboxed closures\"]\n+    fn split<F>(&self, pred: F) -> Splits<T, F>\n+                where F: FnMut(&T) -> bool;\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// not contained in the subslices.\n+    #[unstable = \"iterator type may change\"]\n+    fn splitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n+                 where F: FnMut(&T) -> bool;\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    #[unstable = \"iterator type may change\"]\n+    fn rsplitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n+                  where F: FnMut(&T) -> bool;\n+\n+    /// Returns an iterator over all contiguous windows of length\n+    /// `size`. The windows overlap. If the slice is shorter than\n+    /// `size`, the iterator returns no values.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n+    /// `[3,4]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1i, 2, 3, 4];\n+    /// for win in v.windows(2) {\n+    ///     println!(\"{}\", win);\n+    /// }\n+    /// ```\n+    #[unstable = \"iterator type may change\"]\n+    fn windows(&self, size: uint) -> Windows<T>;\n+\n+    /// Returns an iterator over `size` elements of the slice at a\n+    /// time. The chunks do not overlap. If `size` does not divide the\n+    /// length of the slice, then the last chunk will not have length\n+    /// `size`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the slice two elements at a time (i.e. `[1,2]`,\n+    /// `[3,4]`, `[5]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1i, 2, 3, 4, 5];\n+    /// for win in v.chunks(2) {\n+    ///     println!(\"{}\", win);\n+    /// }\n+    /// ```\n+    #[unstable = \"iterator type may change\"]\n+    fn chunks(&self, size: uint) -> Chunks<T>;\n+\n+    /// Returns the element of a slice at the given index, or `None` if the\n+    /// index is out of bounds.\n+    #[unstable = \"waiting on final collection conventions\"]\n+    fn get(&self, index: uint) -> Option<&T>;\n+\n+    /// Returns the first element of a slice, or `None` if it is empty.\n+    #[unstable = \"name may change\"]\n+    fn head(&self) -> Option<&T>;\n+\n+    /// Returns all but the first element of a slice.\n+    #[unstable = \"name may change\"]\n+    fn tail(&self) -> &[T];\n+\n+    /// Returns all but the last element of a slice.\n+    #[unstable = \"name may change\"]\n+    fn init(&self) -> &[T];\n+\n+    /// Returns the last element of a slice, or `None` if it is empty.\n+    #[unstable = \"name may change\"]\n+    fn last(&self) -> Option<&T>;\n+\n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    #[unstable]\n+    unsafe fn unsafe_get(&self, index: uint) -> &T;\n+\n+    /// Returns an unsafe pointer to the slice's buffer\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[unstable]\n+    fn as_ptr(&self) -> *const T;\n+\n+    /// Binary search a sorted slice with a comparator function.\n+    ///\n+    /// The comparator function should implement an order consistent\n+    /// with the sort order of the underlying slice, returning an\n+    /// order code that indicates whether its argument is `Less`,\n+    /// `Equal` or `Greater` the desired target.\n+    ///\n+    /// If a matching value is found then returns `Found`, containing\n+    /// the index for the matched element; if no match is found then\n+    /// `NotFound` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Example\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1,4]`.\n+    ///\n+    /// ```rust\n+    /// use std::slice::BinarySearchResult::{Found, NotFound};\n+    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n+    /// let s = s.as_slice();\n+    ///\n+    /// let seek = 13;\n+    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), Found(9));\n+    /// let seek = 4;\n+    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), NotFound(7));\n+    /// let seek = 100;\n+    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), NotFound(13));\n+    /// let seek = 1;\n+    /// let r = s.binary_search(|probe| probe.cmp(&seek));\n+    /// assert!(match r { Found(1...4) => true, _ => false, });\n+    /// ```\n+    #[unstable = \"waiting on unboxed closures\"]\n+    fn binary_search<F>(&self, f: F) -> BinarySearchResult\n+                        where F: FnMut(&T) -> Ordering;\n+\n+    /// Return the number of elements in the slice\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let a = [1i, 2, 3];\n+    /// assert_eq!(a.len(), 3);\n+    /// ```\n+    #[experimental = \"not triaged yet\"]\n+    fn len(&self) -> uint;\n+\n+    /// Returns true if the slice has a length of 0\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let a = [1i, 2, 3];\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    #[inline]\n+    #[experimental = \"not triaged yet\"]\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n+    /// Returns a mutable reference to the element at the given index,\n+    /// or `None` if the index is out of bounds\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn get_mut(&mut self, index: uint) -> Option<&mut T>;\n+\n+    /// Work with `self` as a mut slice.\n+    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n+    fn as_mut_slice(&mut self) -> &mut [T];\n+\n+    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n+    ///\n+    /// Panics when the end of the new slice lies beyond the end of the\n+    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n+    ///\n+    /// Slicing with `start` equal to `end` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T];\n+\n+    /// Returns a mutable subslice from `start` to the end of the slice.\n+    ///\n+    /// Panics when `start` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing from `self.len()` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn slice_from_mut(&mut self, start: uint) -> &mut [T];\n+\n+    /// Returns a mutable subslice from the start of the slice to `end`.\n+    ///\n+    /// Panics when `end` is strictly greater than the length of the original slice.\n+    ///\n+    /// Slicing to `0` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn slice_to_mut(&mut self, end: uint) -> &mut [T];\n+\n+    /// Returns an iterator that allows modifying each value\n+    #[unstable = \"waiting on iterator type name conventions\"]\n+    fn iter_mut(&mut self) -> MutItems<T>;\n+\n+    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n+    #[unstable = \"name may change\"]\n+    fn head_mut(&mut self) -> Option<&mut T>;\n+\n+    /// Returns all but the first element of a mutable slice\n+    #[unstable = \"name may change\"]\n+    fn tail_mut(&mut self) -> &mut [T];\n+\n+    /// Returns all but the last element of a mutable slice\n+    #[unstable = \"name may change\"]\n+    fn init_mut(&mut self) -> &mut [T];\n+\n+    /// Returns a mutable pointer to the last item in the slice.\n+    #[unstable = \"name may change\"]\n+    fn last_mut(&mut self) -> Option<&mut T>;\n+\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`.  The matched element is not contained in the subslices.\n+    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n+    fn split_mut<F>(&mut self, pred: F) -> MutSplits<T, F>\n+                    where F: FnMut(&T) -> bool;\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// not contained in the subslices.\n+    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n+    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n+                     where F: FnMut(&T) -> bool;\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n+    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n+                      where F: FnMut(&T) -> bool;\n+\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last chunk will not\n+    /// have length `chunk_size`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `chunk_size` is 0.\n+    #[unstable = \"waiting on iterator type name conventions\"]\n+    fn chunks_mut(&mut self, chunk_size: uint) -> MutChunks<T>;\n+\n+    /// Swaps two elements in a slice.\n+    ///\n+    /// Panics if `a` or `b` are out of bounds.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * a - The index of the first element\n+    /// * b - The index of the second element\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n+    /// v.swap(1, 3);\n+    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// ```\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn swap(&mut self, a: uint, b: uint);\n+\n+    /// Divides one `&mut` into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// Panics if `mid > len`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1i, 2, 3, 4, 5, 6];\n+    ///\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// {\n+    ///    let (left, right) = v.split_at_mut(0);\n+    ///    assert!(left == []);\n+    ///    assert!(right == [1i, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(2);\n+    ///     assert!(left == [1i, 2]);\n+    ///     assert!(right == [3i, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.split_at_mut(6);\n+    ///     assert!(left == [1i, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == []);\n+    /// }\n+    /// ```\n+    #[unstable = \"waiting on final error conventions\"]\n+    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]);\n+\n+    /// Reverse the order of elements in a slice, in place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1i, 2, 3];\n+    /// v.reverse();\n+    /// assert!(v == [3i, 2, 1]);\n+    /// ```\n+    #[experimental = \"may be moved to iterators instead\"]\n+    fn reverse(&mut self);\n+\n+    /// Returns an unsafe mutable pointer to the element in index\n+    #[experimental = \"waiting on unsafe conventions\"]\n+    unsafe fn unsafe_mut(&mut self, index: uint) -> &mut T;\n+\n+    /// Return an unsafe mutable pointer to the slice's buffer.\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[inline]\n+    #[unstable]\n+    fn as_mut_ptr(&mut self) -> *mut T;\n }\n \n-impl<T> SliceAllocPrelude<T> for [T] {\n+impl<T> SliceExt<T> for [T] {\n     #[inline]\n     fn sort_by<F>(&mut self, compare: F) where F: FnMut(&T, &T) -> Ordering {\n         merge_sort(self, compare)\n@@ -651,6 +1117,208 @@ impl<T> SliceAllocPrelude<T> for [T] {\n         }\n         cmp::min(self.len(), end-start)\n     }\n+\n+    #[inline]\n+    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice(self, start, end)\n+    }\n+\n+    #[inline]\n+    fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice_from(self, start)\n+    }\n+\n+    #[inline]\n+    fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n+        core_slice::SliceExt::slice_to(self, end)\n+    }\n+\n+    #[inline]\n+    fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]) {\n+        core_slice::SliceExt::split_at(self, mid)\n+    }\n+\n+    #[inline]\n+    fn iter<'a>(&'a self) -> Items<'a, T> {\n+        core_slice::SliceExt::iter(self)\n+    }\n+\n+    #[inline]\n+    fn split<F>(&self, pred: F) -> Splits<T, F>\n+                where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::split(self, pred)\n+    }\n+\n+    #[inline]\n+    fn splitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n+                 where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::splitn(self, n, pred)\n+    }\n+\n+    #[inline]\n+    fn rsplitn<F>(&self, n: uint, pred: F) -> SplitsN<Splits<T, F>>\n+                  where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::rsplitn(self, n, pred)\n+    }\n+\n+    #[inline]\n+    fn windows<'a>(&'a self, size: uint) -> Windows<'a, T> {\n+        core_slice::SliceExt::windows(self, size)\n+    }\n+\n+    #[inline]\n+    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T> {\n+        core_slice::SliceExt::chunks(self, size)\n+    }\n+\n+    #[inline]\n+    fn get<'a>(&'a self, index: uint) -> Option<&'a T> {\n+        core_slice::SliceExt::get(self, index)\n+    }\n+\n+    #[inline]\n+    fn head<'a>(&'a self) -> Option<&'a T> {\n+        core_slice::SliceExt::head(self)\n+    }\n+\n+    #[inline]\n+    fn tail<'a>(&'a self) -> &'a [T] {\n+        core_slice::SliceExt::tail(self)\n+    }\n+\n+    #[inline]\n+    fn init<'a>(&'a self) -> &'a [T] {\n+        core_slice::SliceExt::init(self)\n+    }\n+\n+    #[inline]\n+    fn last<'a>(&'a self) -> Option<&'a T> {\n+        core_slice::SliceExt::last(self)\n+    }\n+\n+    #[inline]\n+    unsafe fn unsafe_get<'a>(&'a self, index: uint) -> &'a T {\n+        core_slice::SliceExt::unsafe_get(self, index)\n+    }\n+\n+    #[inline]\n+    fn as_ptr(&self) -> *const T {\n+        core_slice::SliceExt::as_ptr(self)\n+    }\n+\n+    #[inline]\n+    fn binary_search<F>(&self, f: F) -> BinarySearchResult\n+                        where F: FnMut(&T) -> Ordering {\n+        core_slice::SliceExt::binary_search(self, f)\n+    }\n+\n+    #[inline]\n+    fn len(&self) -> uint {\n+        core_slice::SliceExt::len(self)\n+    }\n+\n+    #[inline]\n+    fn is_empty(&self) -> bool {\n+        core_slice::SliceExt::is_empty(self)\n+    }\n+\n+    #[inline]\n+    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T> {\n+        core_slice::SliceExt::get_mut(self, index)\n+    }\n+\n+    #[inline]\n+    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::as_mut_slice(self)\n+    }\n+\n+    #[inline]\n+    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_mut(self, start, end)\n+    }\n+\n+    #[inline]\n+    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_from_mut(self, start)\n+    }\n+\n+    #[inline]\n+    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n+        core_slice::SliceExt::slice_to_mut(self, end)\n+    }\n+\n+    #[inline]\n+    fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n+        core_slice::SliceExt::iter_mut(self)\n+    }\n+\n+    #[inline]\n+    fn head_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        core_slice::SliceExt::head_mut(self)\n+    }\n+\n+    #[inline]\n+    fn tail_mut<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::tail_mut(self)\n+    }\n+\n+    #[inline]\n+    fn init_mut<'a>(&'a mut self) -> &'a mut [T] {\n+        core_slice::SliceExt::init_mut(self)\n+    }\n+\n+    #[inline]\n+    fn last_mut<'a>(&'a mut self) -> Option<&'a mut T> {\n+        core_slice::SliceExt::last_mut(self)\n+    }\n+\n+    #[inline]\n+    fn split_mut<F>(&mut self, pred: F) -> MutSplits<T, F>\n+                    where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::split_mut(self, pred)\n+    }\n+\n+    #[inline]\n+    fn splitn_mut<F>(&mut self, n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n+                     where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::splitn_mut(self, n, pred)\n+    }\n+\n+    #[inline]\n+    fn rsplitn_mut<F>(&mut self,  n: uint, pred: F) -> SplitsN<MutSplits<T, F>>\n+                      where F: FnMut(&T) -> bool {\n+        core_slice::SliceExt::rsplitn_mut(self, n, pred)\n+    }\n+\n+    #[inline]\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> MutChunks<'a, T> {\n+        core_slice::SliceExt::chunks_mut(self, chunk_size)\n+    }\n+\n+    #[inline]\n+    fn swap(&mut self, a: uint, b: uint) {\n+        core_slice::SliceExt::swap(self, a, b)\n+    }\n+\n+    #[inline]\n+    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n+        core_slice::SliceExt::split_at_mut(self, mid)\n+    }\n+\n+    #[inline]\n+    fn reverse(&mut self) {\n+        core_slice::SliceExt::reverse(self)\n+    }\n+\n+    #[inline]\n+    unsafe fn unsafe_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n+        core_slice::SliceExt::unsafe_mut(self, index)\n+    }\n+\n+    #[inline]\n+    fn as_mut_ptr(&mut self) -> *mut T {\n+        core_slice::SliceExt::as_mut_ptr(self)\n+    }\n }\n \n #[unstable = \"trait is unstable\"]"}, {"sha": "3c3a1291ba03400f8ad12b4b5334bd1e788bec89", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -51,19 +51,17 @@\n \n #![doc(primitive = \"str\")]\n \n+use core::prelude::*;\n+\n pub use self::MaybeOwned::*;\n use self::RecompositionState::*;\n use self::DecompositionType::*;\n+\n use core::borrow::{BorrowFrom, Cow, ToOwned};\n use core::default::Default;\n use core::fmt;\n use core::cmp;\n use core::iter::AdditiveIterator;\n-use core::kinds::Sized;\n-use core::prelude::{Char, Clone, Eq, Equiv};\n-use core::prelude::{Iterator, IteratorExt, SlicePrelude, None, Option, Ord, Ordering};\n-use core::prelude::{PartialEq, PartialOrd, Result, AsSlice, Some};\n-use core::prelude::{range};\n \n use hash;\n use ring_buf::RingBuf;\n@@ -849,10 +847,10 @@ mod tests {\n     use std::iter::{Iterator, IteratorExt, DoubleEndedIteratorExt};\n \n     use super::*;\n-    use std::slice::{AsSlice, SlicePrelude};\n+    use std::slice::{AsSlice, SliceExt};\n     use string::String;\n     use vec::Vec;\n-    use slice::CloneSliceAllocPrelude;\n+    use slice::CloneSliceExt;\n \n     use unicode::char::UnicodeChar;\n \n@@ -2464,7 +2462,7 @@ mod bench {\n     use super::*;\n     use std::iter::{IteratorExt, DoubleEndedIteratorExt};\n     use std::str::StrPrelude;\n-    use std::slice::SlicePrelude;\n+    use std::slice::SliceExt;\n \n     #[bench]\n     fn char_iterator(b: &mut Bencher) {"}, {"sha": "857126b9e24f879330a6c72dfb392f3eb12d48fc", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -24,7 +24,7 @@ use core::ops;\n use core::raw::Slice as RawSlice;\n \n use hash;\n-use slice::CloneSliceAllocPrelude;\n+use slice::CloneSliceExt;\n use str;\n use str::{CharRange, CowString, FromStr, StrAllocating, Owned};\n use vec::{DerefVec, Vec, as_vec};\n@@ -1014,7 +1014,7 @@ mod tests {\n     use std::prelude::*;\n     use test::Bencher;\n \n-    use slice::CloneSliceAllocPrelude;\n+    use slice::CloneSliceExt;\n     use str::{Str, StrPrelude};\n     use str;\n     use super::{as_string, String, ToString};"}, {"sha": "c4c05969ed1514b3de9ef193ec8bc8a589f73439", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -29,7 +29,7 @@ use core::ptr;\n use core::raw::Slice as RawSlice;\n use core::uint;\n \n-use slice::{CloneSliceAllocPrelude};\n+use slice::CloneSliceExt;\n \n /// An owned, growable vector.\n ///"}, {"sha": "fbc444c2be3548640913fa6d194a45ff3c15f901", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -20,7 +20,7 @@ use ops::FnMut;\n use option::Option;\n use option::Option::{None, Some};\n use iter::{range_step, Iterator, RangeStep};\n-use slice::SlicePrelude;\n+use slice::SliceExt;\n \n // UTF-8 ranges and tags for encoding characters\n static TAG_CONT: u8    = 0b1000_0000u8;"}, {"sha": "d849bfa24c137790865b23e46decb0913f49bfac", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -22,7 +22,7 @@ use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use num::cast;\n use ops::FnOnce;\n use result::Result::Ok;\n-use slice::{mod, SlicePrelude};\n+use slice::{mod, SliceExt};\n use str::StrPrelude;\n \n /// A flag that specifies whether to use exponential (scientific) notation."}, {"sha": "c0a77c04716b96143dd83bad14d2c76b51590346", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -22,7 +22,7 @@ use option::Option::{Some, None};\n use ops::{Deref, FnOnce};\n use result::Result::{Ok, Err};\n use result;\n-use slice::SlicePrelude;\n+use slice::SliceExt;\n use slice;\n use str::StrPrelude;\n "}, {"sha": "9cfa7bec22f6762e6cda8a3170c016dcb58c8d1d", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -18,7 +18,7 @@ use fmt;\n use iter::DoubleEndedIteratorExt;\n use kinds::Copy;\n use num::{Int, cast};\n-use slice::SlicePrelude;\n+use slice::SliceExt;\n \n /// A type that represents a specific radix\n #[doc(hidden)]"}, {"sha": "ff3fc870beb83a40f53ef2694766fce3055f9124", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -64,5 +64,5 @@ pub use str::{Str, StrPrelude};\n pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n-pub use slice::{PartialEqSlicePrelude, OrdSlicePrelude};\n-pub use slice::{AsSlice, SlicePrelude};\n+pub use slice::{PartialEqSliceExt, OrdSliceExt};\n+pub use slice::{AsSlice, SliceExt};"}, {"sha": "a80cf9dab64445be10134ac23d4e2c6d5521ac55", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 26, "deletions": 423, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -61,377 +61,58 @@ use raw::Slice as RawSlice;\n //\n \n /// Extension methods for slices.\n-#[unstable = \"may merge with other traits\"]\n-pub trait SlicePrelude<T> for Sized? {\n-    /// Returns a subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n+#[allow(missing_docs)] // docs in libcollections\n+pub trait SliceExt<T> for Sized? {\n     fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T];\n-\n-    /// Returns a subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n     fn slice_from<'a>(&'a self, start: uint) -> &'a [T];\n-\n-    /// Returns a subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions/slicing syntax\"]\n     fn slice_to<'a>(&'a self, end: uint) -> &'a [T];\n-\n-    /// Divides one slice into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// Panics if `mid > len`.\n-    #[unstable = \"waiting on final error conventions\"]\n     fn split_at<'a>(&'a self, mid: uint) -> (&'a [T], &'a [T]);\n-\n-    /// Returns an iterator over the slice\n-    #[unstable = \"iterator type may change\"]\n     fn iter<'a>(&'a self) -> Items<'a, T>;\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`.  The matched element is not contained in the subslices.\n-    #[unstable = \"iterator type may change, waiting on unboxed closures\"]\n-    fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P> where\n-        P: FnMut(&T) -> bool;\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to splitting at most `n` times.  The matched element is\n-    /// not contained in the subslices.\n-    #[unstable = \"iterator type may change\"]\n-    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n-        P: FnMut(&T) -> bool;\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to splitting at most `n` times. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n-    /// the subslices.\n-    #[unstable = \"iterator type may change\"]\n-    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> SplitsN<Splits<'a, T, P>> where\n-        P: FnMut(&T) -> bool;\n-\n-    /// Returns an iterator over all contiguous windows of length\n-    /// `size`. The windows overlap. If the slice is shorter than\n-    /// `size`, the iterator returns no values.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `size` is 0.\n-    ///\n-    /// # Example\n-    ///\n-    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n-    /// `[3,4]`):\n-    ///\n-    /// ```rust\n-    /// let v = &[1i, 2, 3, 4];\n-    /// for win in v.windows(2) {\n-    ///     println!(\"{}\", win);\n-    /// }\n-    /// ```\n-    #[unstable = \"iterator type may change\"]\n+    fn split<'a, P>(&'a self, pred: P) -> Splits<'a, T, P>\n+                    where P: FnMut(&T) -> bool;\n+    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitsN<Splits<'a, T, P>>\n+                     where P: FnMut(&T) -> bool;\n+    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> SplitsN<Splits<'a, T, P>>\n+                      where P: FnMut(&T) -> bool;\n     fn windows<'a>(&'a self, size: uint) -> Windows<'a, T>;\n-\n-    /// Returns an iterator over `size` elements of the slice at a\n-    /// time. The chunks do not overlap. If `size` does not divide the\n-    /// length of the slice, then the last chunk will not have length\n-    /// `size`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `size` is 0.\n-    ///\n-    /// # Example\n-    ///\n-    /// Print the slice two elements at a time (i.e. `[1,2]`,\n-    /// `[3,4]`, `[5]`):\n-    ///\n-    /// ```rust\n-    /// let v = &[1i, 2, 3, 4, 5];\n-    /// for win in v.chunks(2) {\n-    ///     println!(\"{}\", win);\n-    /// }\n-    /// ```\n-    #[unstable = \"iterator type may change\"]\n     fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, T>;\n-\n-    /// Returns the element of a slice at the given index, or `None` if the\n-    /// index is out of bounds.\n-    #[unstable = \"waiting on final collection conventions\"]\n     fn get<'a>(&'a self, index: uint) -> Option<&'a T>;\n-\n-    /// Returns the first element of a slice, or `None` if it is empty.\n-    #[unstable = \"name may change\"]\n     fn head<'a>(&'a self) -> Option<&'a T>;\n-\n-    /// Returns all but the first element of a slice.\n-    #[unstable = \"name may change\"]\n     fn tail<'a>(&'a self) -> &'a [T];\n-\n-    /// Returns all but the last element of a slice.\n-    #[unstable = \"name may change\"]\n     fn init<'a>(&'a self) -> &'a [T];\n-\n-    /// Returns the last element of a slice, or `None` if it is empty.\n-    #[unstable = \"name may change\"]\n     fn last<'a>(&'a self) -> Option<&'a T>;\n-\n-    /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n-    #[unstable]\n     unsafe fn unsafe_get<'a>(&'a self, index: uint) -> &'a T;\n-\n-    /// Returns an unsafe pointer to the slice's buffer\n-    ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the slice may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    #[unstable]\n     fn as_ptr(&self) -> *const T;\n-\n-    /// Binary search a sorted slice with a comparator function.\n-    ///\n-    /// The comparator function should implement an order consistent\n-    /// with the sort order of the underlying slice, returning an\n-    /// order code that indicates whether its argument is `Less`,\n-    /// `Equal` or `Greater` the desired target.\n-    ///\n-    /// If a matching value is found then returns `Found`, containing\n-    /// the index for the matched element; if no match is found then\n-    /// `NotFound` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Example\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n-    ///\n-    /// ```rust\n-    /// use std::slice::BinarySearchResult::{Found, NotFound};\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n-    ///\n-    /// let seek = 13;\n-    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), Found(9));\n-    /// let seek = 4;\n-    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), NotFound(7));\n-    /// let seek = 100;\n-    /// assert_eq!(s.binary_search(|probe| probe.cmp(&seek)), NotFound(13));\n-    /// let seek = 1;\n-    /// let r = s.binary_search(|probe| probe.cmp(&seek));\n-    /// assert!(match r { Found(1...4) => true, _ => false, });\n-    /// ```\n-    #[unstable = \"waiting on unboxed closures\"]\n-    fn binary_search<F>(&self, f: F) -> BinarySearchResult where F: FnMut(&T) -> Ordering;\n-\n-    /// Return the number of elements in the slice\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let a = [1i, 2, 3];\n-    /// assert_eq!(a.len(), 3);\n-    /// ```\n-    #[experimental = \"not triaged yet\"]\n+    fn binary_search<F>(&self, f: F) -> BinarySearchResult\n+                        where F: FnMut(&T) -> Ordering;\n     fn len(&self) -> uint;\n-\n-    /// Returns true if the slice has a length of 0\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// let a = [1i, 2, 3];\n-    /// assert!(!a.is_empty());\n-    /// ```\n-    #[inline]\n-    #[experimental = \"not triaged yet\"]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n-    /// Returns a mutable reference to the element at the given index,\n-    /// or `None` if the index is out of bounds\n-    #[unstable = \"waiting on final error conventions\"]\n     fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut T>;\n-\n-    /// Work with `self` as a mut slice.\n-    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n     fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T];\n-\n-    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n     fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T];\n-\n-    /// Returns a mutable subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n     fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T];\n-\n-    /// Returns a mutable subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"waiting on final error conventions\"]\n     fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T];\n-\n-    /// Returns an iterator that allows modifying each value\n-    #[unstable = \"waiting on iterator type name conventions\"]\n     fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T>;\n-\n-    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n-    #[unstable = \"name may change\"]\n     fn head_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n-\n-    /// Returns all but the first element of a mutable slice\n-    #[unstable = \"name may change\"]\n     fn tail_mut<'a>(&'a mut self) -> &'a mut [T];\n-\n-    /// Returns all but the last element of a mutable slice\n-    #[unstable = \"name may change\"]\n     fn init_mut<'a>(&'a mut self) -> &'a mut [T];\n-\n-    /// Returns a mutable pointer to the last item in the slice.\n-    #[unstable = \"name may change\"]\n     fn last_mut<'a>(&'a mut self) -> Option<&'a mut T>;\n-\n-    /// Returns an iterator over mutable subslices separated by elements that\n-    /// match `pred`.  The matched element is not contained in the subslices.\n-    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn split_mut<'a, P>(&'a mut self, pred: P) -> MutSplits<'a, T, P> where\n-        P: FnMut(&T) -> bool;\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to splitting at most `n` times.  The matched element is\n-    /// not contained in the subslices.\n-    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn splitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n-        P: FnMut(&T) -> bool;\n-\n-    /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to splitting at most `n` times. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n-    /// the subslices.\n-    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n-    fn rsplitn_mut<'a, P>(&'a mut self,  n: uint, pred: P) -> SplitsN<MutSplits<'a, T, P>> where\n-        P: FnMut(&T) -> bool;\n-\n-    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n-    /// The chunks are mutable and do not overlap. If `chunk_size` does\n-    /// not divide the length of the slice, then the last chunk will not\n-    /// have length `chunk_size`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `chunk_size` is 0.\n-    #[unstable = \"waiting on iterator type name conventions\"]\n+    fn split_mut<'a, P>(&'a mut self, pred: P) -> MutSplits<'a, T, P>\n+                        where P: FnMut(&T) -> bool;\n+    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitsN<MutSplits<T, P>>\n+                     where P: FnMut(&T) -> bool;\n+    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> SplitsN<MutSplits<T, P>>\n+                      where P: FnMut(&T) -> bool;\n     fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> MutChunks<'a, T>;\n-\n-    /// Swaps two elements in a slice.\n-    ///\n-    /// Panics if `a` or `b` are out of bounds.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * a - The index of the first element\n-    /// * b - The index of the second element\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n-    /// v.swap(1, 3);\n-    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n-    /// ```\n-    #[unstable = \"waiting on final error conventions\"]\n     fn swap(&mut self, a: uint, b: uint);\n-\n-    /// Divides one `&mut` into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// Panics if `mid > len`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [1i, 2, 3, 4, 5, 6];\n-    ///\n-    /// // scoped to restrict the lifetime of the borrows\n-    /// {\n-    ///    let (left, right) = v.split_at_mut(0);\n-    ///    assert!(left == []);\n-    ///    assert!(right == [1i, 2, 3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(2);\n-    ///     assert!(left == [1i, 2]);\n-    ///     assert!(right == [3i, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.split_at_mut(6);\n-    ///     assert!(left == [1i, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == []);\n-    /// }\n-    /// ```\n-    #[unstable = \"waiting on final error conventions\"]\n     fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n-\n-    /// Reverse the order of elements in a slice, in place.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [1i, 2, 3];\n-    /// v.reverse();\n-    /// assert!(v == [3i, 2, 1]);\n-    /// ```\n-    #[experimental = \"may be moved to iterators instead\"]\n     fn reverse(&mut self);\n-\n-    /// Returns an unsafe mutable pointer to the element in index\n-    #[experimental = \"waiting on unsafe conventions\"]\n     unsafe fn unsafe_mut<'a>(&'a mut self, index: uint) -> &'a mut T;\n-\n-    /// Return an unsafe mutable pointer to the slice's buffer.\n-    ///\n-    /// The caller must ensure that the slice outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the slice may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    #[inline]\n-    #[unstable]\n     fn as_mut_ptr(&mut self) -> *mut T;\n }\n \n #[unstable]\n-impl<T> SlicePrelude<T> for [T] {\n+impl<T> SliceExt<T> for [T] {\n     #[inline]\n     fn slice(&self, start: uint, end: uint) -> &[T] {\n         assert!(start <= end);\n@@ -789,7 +470,7 @@ impl<T> ops::SliceMut<uint, [T]> for [T] {\n \n /// Extension methods for slices containing `PartialEq` elements.\n #[unstable = \"may merge with other traits\"]\n-pub trait PartialEqSlicePrelude<T: PartialEq> for Sized? {\n+pub trait PartialEqSliceExt<T: PartialEq> for Sized? {\n     /// Find the first index containing a matching value.\n     fn position_elem(&self, t: &T) -> Option<uint>;\n \n@@ -807,7 +488,7 @@ pub trait PartialEqSlicePrelude<T: PartialEq> for Sized? {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<T: PartialEq> PartialEqSlicePrelude<T> for [T] {\n+impl<T: PartialEq> PartialEqSliceExt<T> for [T] {\n     #[inline]\n     fn position_elem(&self, x: &T) -> Option<uint> {\n         self.iter().position(|y| *x == *y)\n@@ -838,75 +519,18 @@ impl<T: PartialEq> PartialEqSlicePrelude<T> for [T] {\n \n /// Extension methods for slices containing `Ord` elements.\n #[unstable = \"may merge with other traits\"]\n-pub trait OrdSlicePrelude<T: Ord> for Sized? {\n-    /// Binary search a sorted slice for a given element.\n-    ///\n-    /// If the value is found then `Found` is returned, containing the\n-    /// index of the matching element; if the value is not found then\n-    /// `NotFound` is returned, containing the index where a matching\n-    /// element could be inserted while maintaining sorted order.\n-    ///\n-    /// # Example\n-    ///\n-    /// Looks up a series of four elements. The first is found, with a\n-    /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n-    ///\n-    /// ```rust\n-    /// use std::slice::BinarySearchResult::{Found, NotFound};\n-    /// let s = [0i, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n-    /// let s = s.as_slice();\n-    ///\n-    /// assert_eq!(s.binary_search_elem(&13),  Found(9));\n-    /// assert_eq!(s.binary_search_elem(&4),   NotFound(7));\n-    /// assert_eq!(s.binary_search_elem(&100), NotFound(13));\n-    /// let r = s.binary_search_elem(&1);\n-    /// assert!(match r { Found(1...4) => true, _ => false, });\n-    /// ```\n+#[allow(missing_docs)] // docs in libcollections\n+pub trait OrdSliceExt<T: Ord> for Sized? {\n     #[unstable = \"name likely to change\"]\n     fn binary_search_elem(&self, x: &T) -> BinarySearchResult;\n-\n-    /// Mutates the slice to the next lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// last-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [0i, 1, 2];\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.next_permutation();\n-    /// let b: &mut [_] = &mut [1i, 0, 2];\n-    /// assert!(v == b);\n-    /// ```\n     #[experimental]\n     fn next_permutation(&mut self) -> bool;\n-\n-    /// Mutates the slice to the previous lexicographic permutation.\n-    ///\n-    /// Returns `true` if successful and `false` if the slice is at the\n-    /// first-ordered permutation.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let v: &mut [_] = &mut [1i, 0, 2];\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 2, 1];\n-    /// assert!(v == b);\n-    /// v.prev_permutation();\n-    /// let b: &mut [_] = &mut [0i, 1, 2];\n-    /// assert!(v == b);\n-    /// ```\n     #[experimental]\n     fn prev_permutation(&mut self) -> bool;\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<T: Ord> OrdSlicePrelude<T> for [T] {\n+impl<T: Ord> OrdSliceExt<T> for [T] {\n     #[unstable]\n     fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n         self.binary_search(|p| p.cmp(x))\n@@ -977,31 +601,13 @@ impl<T: Ord> OrdSlicePrelude<T> for [T] {\n \n /// Extension methods for slices on Clone elements\n #[unstable = \"may merge with other traits\"]\n-pub trait CloneSlicePrelude<T> for Sized? {\n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::slice::CloneSlicePrelude;\n-    ///\n-    /// let mut dst = [0i, 0, 0];\n-    /// let src = [1i, 2];\n-    ///\n-    /// assert!(dst.clone_from_slice(&src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n-    ///\n-    /// let src2 = [3i, 4, 5, 6];\n-    /// assert!(dst.clone_from_slice(&src2) == 3);\n-    /// assert!(dst == [3i, 4, 5]);\n-    /// ```\n+#[allow(missing_docs)] // docs in libcollections\n+pub trait CloneSliceExt<T> for Sized? {\n     fn clone_from_slice(&mut self, &[T]) -> uint;\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<T: Clone> CloneSlicePrelude<T> for [T] {\n+impl<T: Clone> CloneSliceExt<T> for [T] {\n     #[inline]\n     fn clone_from_slice(&mut self, src: &[T]) -> uint {\n         let min = cmp::min(self.len(), src.len());\n@@ -1014,9 +620,6 @@ impl<T: Clone> CloneSlicePrelude<T> for [T] {\n     }\n }\n \n-\n-\n-\n //\n // Common traits\n //\n@@ -1786,7 +1389,7 @@ pub mod raw {\n pub mod bytes {\n     use kinds::Sized;\n     use ptr;\n-    use slice::SlicePrelude;\n+    use slice::SliceExt;\n \n     /// A trait for operations on mutable `[u8]`s.\n     pub trait MutableByteVector for Sized? {"}, {"sha": "38a0b2a7c8ca2685d59fda5ae46acc29a24f2790", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -34,7 +34,7 @@ use option::Option::{None, Some};\n use ops::FnMut;\n use ptr::RawPtr;\n use raw::{Repr, Slice};\n-use slice::{mod, SlicePrelude};\n+use slice::{mod, SliceExt};\n use uint;\n \n /// A trait to abstract the idea of creating a new instance of a type from a\n@@ -1146,7 +1146,7 @@ const TAG_CONT_U8: u8 = 0b1000_0000u8;\n pub mod raw {\n     use ptr::RawPtr;\n     use raw::Slice;\n-    use slice::SlicePrelude;\n+    use slice::SliceExt;\n     use str::{is_utf8, StrPrelude};\n \n     /// Converts a slice of bytes to a string slice without checking"}, {"sha": "cfa08e5f021f82a0f918aa920ac6d764b82f4f46", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -16,7 +16,7 @@ use std::default::Default;\n use std::fmt;\n use std::iter::FromIterator;\n use std::path::BytesContainer;\n-use std::slice::{mod, Permutations};\n+use std::slice;\n \n // Note 1: It is not clear whether the flexibility of providing both\n // the `Growable` and `FixedLen` variants is sufficiently useful.\n@@ -136,21 +136,6 @@ impl<'a,T:fmt::Show> fmt::Show for MaybeOwnedVector<'a,T> {\n     }\n }\n \n-impl<'a,T:Clone> CloneSliceAllocPrelude<T> for MaybeOwnedVector<'a,T> {\n-    /// Returns a copy of `self`.\n-    fn to_vec(&self) -> Vec<T> {\n-        self.as_slice().to_vec()\n-    }\n-\n-    fn partitioned<F>(&self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n-        self.as_slice().partitioned(f)\n-    }\n-\n-    fn permutations(&self) -> Permutations<T> {\n-        self.as_slice().permutations()\n-    }\n-}\n-\n impl<'a, T: Clone> Clone for MaybeOwnedVector<'a, T> {\n     #[allow(deprecated)]\n     fn clone(&self) -> MaybeOwnedVector<'a, T> {"}, {"sha": "15a678d2e7459e426dccf9293d7afc8505df5d8b", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -38,7 +38,7 @@ pub use self::StepState::*;\n \n use std::cmp;\n use std::mem;\n-use std::slice::SlicePrelude;\n+use std::slice::SliceExt;\n use compile::{\n     Program,\n     Match, OneChar, CharClass, Any, EmptyBegin, EmptyEnd, EmptyWordBoundary,"}, {"sha": "18c5aefde506b17c04496f067e292e89469d9f7d", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -67,15 +67,13 @@\n //! }\n //! ```\n \n+use core::prelude::*;\n+\n use collections::string::String;\n use collections::hash;\n use core::fmt;\n use core::kinds::{Sized, marker};\n use core::mem;\n-use core::ops::{FnMut, FnOnce};\n-use core::prelude::{Clone, Drop, Eq, Iterator};\n-use core::prelude::{SlicePrelude, None, Option, Ordering, PartialEq};\n-use core::prelude::{PartialOrd, RawPtr, Some, StrPrelude, range};\n use core::ptr;\n use core::raw::Slice;\n use core::slice;"}, {"sha": "342f5b87bd8a6edd67559e691556db440586bbc9", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -23,7 +23,7 @@ use mem;\n use ops::FnMut;\n use option::Option;\n use option::Option::{Some, None};\n-use slice::{SlicePrelude, AsSlice};\n+use slice::{SliceExt, AsSlice};\n use str::{Str, StrPrelude};\n use string::{String, IntoString};\n use vec::Vec;"}, {"sha": "c71f0d5b935f7948a6124e7e708e3c058fc39b9a", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -638,7 +638,7 @@ mod test_set {\n     use prelude::*;\n \n     use super::HashSet;\n-    use slice::PartialEqSlicePrelude;\n+    use slice::PartialEqSliceExt;\n \n     #[test]\n     fn test_disjoint() {"}, {"sha": "758dab1a10726b0549b5133550e10293e255f5e9", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -26,7 +26,7 @@ use os;\n use path::{Path,GenericPath};\n use result::*;\n use result::Result::{Err, Ok};\n-use slice::{AsSlice,SlicePrelude};\n+use slice::{AsSlice,SliceExt};\n use str;\n use string::String;\n use vec::Vec;\n@@ -295,7 +295,7 @@ pub mod dl {\n     use ptr;\n     use result::Result;\n     use result::Result::{Ok, Err};\n-    use slice::SlicePrelude;\n+    use slice::SliceExt;\n     use str::StrPrelude;\n     use str;\n     use string::String;"}, {"sha": "0a1bf3090ba33db3e286b321d95f12dba7effc8d", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -19,7 +19,7 @@ use ops::Drop;\n use option::Option;\n use option::Option::{Some, None};\n use result::Result::{Ok, Err};\n-use slice::{SlicePrelude};\n+use slice::{SliceExt};\n use slice;\n use vec::Vec;\n "}, {"sha": "2aa7435d871e24c16c076423af81c6853b46975d", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -14,7 +14,7 @@ use comm::{Sender, Receiver};\n use io;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n-use slice::{bytes, CloneSliceAllocPrelude, SlicePrelude};\n+use slice::{bytes, CloneSliceExt, SliceExt};\n use super::{Buffer, Reader, Writer, IoResult};\n use vec::Vec;\n "}, {"sha": "24a000adef2005a3fb202611180d8007b70610c7", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -24,7 +24,7 @@ use option::Option;\n use option::Option::{Some, None};\n use ptr::RawPtr;\n use result::Result::{Ok, Err};\n-use slice::{SlicePrelude, AsSlice};\n+use slice::{SliceExt, AsSlice};\n \n /// An iterator that reads a single byte on each iteration,\n /// until `.read_byte()` returns `EndOfFile`.\n@@ -156,7 +156,7 @@ pub fn u64_to_be_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n ///           32-bit value is parsed.\n pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n     use ptr::{copy_nonoverlapping_memory};\n-    use slice::SlicePrelude;\n+    use slice::SliceExt;\n \n     assert!(size <= 8u);\n "}, {"sha": "40c28877548b9b0e5578f93fdf038aa12ef39bb2", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -64,7 +64,7 @@ use option::Option::{Some, None};\n use path::{Path, GenericPath};\n use path;\n use result::Result::{Err, Ok};\n-use slice::SlicePrelude;\n+use slice::SliceExt;\n use string::String;\n use vec::Vec;\n "}, {"sha": "03d2af1b426449141ecc5eb0cce4f98b55d657f4", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -19,7 +19,7 @@ use option::Option::None;\n use result::Result::{Err, Ok};\n use io;\n use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n-use slice::{mod, AsSlice, SlicePrelude};\n+use slice::{mod, AsSlice, SliceExt};\n use vec::Vec;\n \n const BUF_CAPACITY: uint = 128;"}, {"sha": "9706da739768d5e9aee6ecda4bf355fe231bba23", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -241,7 +241,7 @@ use boxed::Box;\n use result::Result;\n use result::Result::{Ok, Err};\n use sys;\n-use slice::SlicePrelude;\n+use slice::SliceExt;\n use str::StrPrelude;\n use str;\n use string::String;"}, {"sha": "092410fbc8eaafd7e6d67a65a6355876de4a979d", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -27,7 +27,7 @@ use option::Option;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n use str::{FromStr, StrPrelude};\n-use slice::{CloneSlicePrelude, SlicePrelude};\n+use slice::{CloneSliceExt, SliceExt};\n use vec::Vec;\n \n pub type Port = u16;"}, {"sha": "950946da126de864f0a70f4176a01a6ca09018d0", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -44,7 +44,7 @@ use result::Result::{Ok, Err};\n use rustrt;\n use rustrt::local::Local;\n use rustrt::task::Task;\n-use slice::SlicePrelude;\n+use slice::SliceExt;\n use str::StrPrelude;\n use string::String;\n use sys::{fs, tty};"}, {"sha": "9cc165ce57092a35e59c3f60e2d8c4cef8bb6730", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -337,7 +337,7 @@ macro_rules! try (\n #[macro_export]\n macro_rules! vec[\n     ($($x:expr),*) => ({\n-        use std::slice::BoxedSlicePrelude;\n+        use std::slice::BoxedSliceExt;\n         let xs: ::std::boxed::Box<[_]> = box [$($x),*];\n         xs.into_vec()\n     });"}, {"sha": "2b319640d1b4e31f55153e190098aafd38250825", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -16,13 +16,11 @@ pub use self::ExponentFormat::*;\n pub use self::SignificantDigits::*;\n pub use self::SignFormat::*;\n \n-use char;\n-use char::Char;\n+use char::{mod, Char};\n use kinds::Copy;\n-use num;\n-use num::{Int, Float, FPNaN, FPInfinite, ToPrimitive};\n+use num::{mod, Int, Float, FPNaN, FPInfinite, ToPrimitive};\n use ops::FnMut;\n-use slice::{SlicePrelude, CloneSliceAllocPrelude};\n+use slice::{SliceExt, CloneSliceExt};\n use str::StrPrelude;\n use string::String;\n use vec::Vec;"}, {"sha": "bf28b67f43067b229bbd900f53bea16eca809879", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -51,8 +51,8 @@ use ptr::RawPtr;\n use ptr;\n use result::Result;\n use result::Result::{Err, Ok};\n-use slice::{AsSlice, SlicePrelude, PartialEqSlicePrelude};\n-use slice::CloneSliceAllocPrelude;\n+use slice::{AsSlice, SliceExt, PartialEqSliceExt};\n+use slice::CloneSliceExt;\n use str::{Str, StrPrelude, StrAllocating};\n use string::{String, ToString};\n use sync::atomic::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n@@ -168,7 +168,7 @@ pub mod windoze {\n     use option::Option::None;\n     use option;\n     use os::TMPBUF_SZ;\n-    use slice::{SlicePrelude};\n+    use slice::SliceExt;\n     use string::String;\n     use str::StrPrelude;\n     use vec::Vec;"}, {"sha": "8f98329a4be720df6f06e0875eb4d5ab2fd9449c", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -71,8 +71,8 @@ use option::Option::{None, Some};\n use str;\n use str::{CowString, MaybeOwned, Str, StrPrelude};\n use string::String;\n-use slice::{AsSlice, CloneSliceAllocPrelude};\n-use slice::{PartialEqSlicePrelude, SlicePrelude};\n+use slice::{AsSlice, CloneSliceExt};\n+use slice::{PartialEqSliceExt, SliceExt};\n use vec::Vec;\n \n /// Typedef for POSIX file paths."}, {"sha": "bea51712253e660029bedac0a7469cc0dbd592d1", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -22,8 +22,8 @@ use option::Option::{None, Some};\n use kinds::Sized;\n use str::{FromStr, Str};\n use str;\n-use slice::{CloneSliceAllocPrelude, Splits, AsSlice, VectorVector,\n-            PartialEqSlicePrelude, SlicePrelude};\n+use slice::{CloneSliceExt, Splits, AsSlice, VectorVector,\n+            PartialEqSliceExt, SliceExt};\n use vec::Vec;\n \n use super::{BytesContainer, GenericPath, GenericPathUnsafe};"}, {"sha": "8b18d1d8cd4cec164ea1ca0d9d1bc70b141dbba2", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -26,7 +26,7 @@ use kinds::Copy;\n use mem;\n use option::Option;\n use option::Option::{Some, None};\n-use slice::{AsSlice, SlicePrelude};\n+use slice::{AsSlice, SliceExt};\n use str::{CharSplits, FromStr, Str, StrAllocating, StrVector, StrPrelude};\n use string::String;\n use unicode::char::UnicodeChar;"}, {"sha": "8b6575b6bc1cc8ae37ca0e6cd827f54138fd0774", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -84,10 +84,10 @@\n #[doc(no_inline)] pub use tuple::{Tuple1, Tuple2, Tuple3, Tuple4};\n #[doc(no_inline)] pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n #[doc(no_inline)] pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n-#[doc(no_inline)] pub use slice::{SlicePrelude, AsSlice, CloneSlicePrelude};\n-#[doc(no_inline)] pub use slice::{VectorVector, PartialEqSlicePrelude, OrdSlicePrelude};\n-#[doc(no_inline)] pub use slice::{CloneSliceAllocPrelude, OrdSliceAllocPrelude, SliceAllocPrelude};\n-#[doc(no_inline)] pub use slice::{BoxedSlicePrelude};\n+#[doc(no_inline)] pub use slice::AsSlice;\n+#[doc(no_inline)] pub use slice::{VectorVector, PartialEqSliceExt};\n+#[doc(no_inline)] pub use slice::{CloneSliceExt, OrdSliceExt, SliceExt};\n+#[doc(no_inline)] pub use slice::{BoxedSliceExt};\n #[doc(no_inline)] pub use string::{IntoString, String, ToString};\n #[doc(no_inline)] pub use vec::Vec;\n "}, {"sha": "bbe8edc0f007c0a7cbdc6e55062e364994eaa3b5", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -24,7 +24,7 @@ mod imp {\n     use rand::Rng;\n     use rand::reader::ReaderRng;\n     use result::Result::{Ok, Err};\n-    use slice::SlicePrelude;\n+    use slice::SliceExt;\n     use mem;\n     use os::errno;\n \n@@ -175,7 +175,7 @@ mod imp {\n     use rand::Rng;\n     use result::Result::{Ok};\n     use self::libc::{c_int, size_t};\n-    use slice::{SlicePrelude};\n+    use slice::SliceExt;\n \n     /// A random number generator that retrieves randomness straight from\n     /// the operating system. Platform sources:\n@@ -243,7 +243,7 @@ mod imp {\n     use result::Result::{Ok, Err};\n     use self::libc::{DWORD, BYTE, LPCSTR, BOOL};\n     use self::libc::types::os::arch::extra::{LONG_PTR};\n-    use slice::{SlicePrelude};\n+    use slice::SliceExt;\n \n     type HCRYPTPROV = LONG_PTR;\n "}, {"sha": "7298b2ef0acc745cf2d8532c8787ee9b2596a4e2", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -13,7 +13,7 @@\n use io::Reader;\n use rand::Rng;\n use result::Result::{Ok, Err};\n-use slice::SlicePrelude;\n+use slice::SliceExt;\n \n /// An RNG that reads random bytes straight from a `Reader`. This will\n /// work best with an infinite reader, but this is not required."}, {"sha": "ad4695eb7fe6a814e9422216121d1b154ad862c5", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -232,13 +232,12 @@ fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n /// all unix platforms we support right now, so it at least gets the job done.\n #[cfg(unix)]\n mod imp {\n+    use prelude::*;\n+\n     use c_str::CString;\n-    use io::{IoResult, Writer};\n+    use io::IoResult;\n     use libc;\n     use mem;\n-    use option::Option;\n-    use option::Option::{Some, None};\n-    use result::Result::{Ok, Err};\n     use sync::{StaticMutex, MUTEX_INIT};\n \n     /// As always - iOS on arm uses SjLj exceptions and\n@@ -253,9 +252,7 @@ mod imp {\n     #[cfg(all(target_os = \"ios\", target_arch = \"arm\"))]\n     #[inline(never)]\n     pub fn write(w: &mut Writer) -> IoResult<()> {\n-        use iter::{IteratorExt, range};\n         use result;\n-        use slice::{SlicePrelude};\n \n         extern {\n             fn backtrace(buf: *mut *mut libc::c_void,\n@@ -389,12 +386,8 @@ mod imp {\n \n     #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n     fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n-        use iter::IteratorExt;\n         use os;\n-        use path::GenericPath;\n-        use ptr::RawPtr;\n         use ptr;\n-        use slice::{SlicePrelude};\n \n         ////////////////////////////////////////////////////////////////////////\n         // libbacktrace.h API\n@@ -669,7 +662,7 @@ mod imp {\n     use path::Path;\n     use result::Result::{Ok, Err};\n     use sync::{StaticMutex, MUTEX_INIT};\n-    use slice::SlicePrelude;\n+    use slice::SliceExt;\n     use str::StrPrelude;\n     use dynamic_lib::DynamicLibrary;\n "}, {"sha": "d239cb8289682bc80eeddcc65a10d77615054e23", "filename": "src/libunicode/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibunicode%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibunicode%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fnormalize.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -14,7 +14,7 @@ use core::cmp::Ordering::{Equal, Less, Greater};\n use core::option::Option;\n use core::option::Option::{Some, None};\n use core::slice;\n-use core::slice::SlicePrelude;\n+use core::slice::SliceExt;\n use tables::normalization::{canonical_table, compatibility_table, composition_table};\n \n fn bsearch_table<T>(c: char, r: &'static [(char, &'static [T])]) -> Option<&'static [T]> {"}, {"sha": "a219aefad192c81b84fc556d40c8fffa15874ede", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -18,7 +18,7 @@ pub const UNICODE_VERSION: (uint, uint, uint) = (7, 0, 0);\n \n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::Ordering::{Equal, Less, Greater};\n-    use core::slice::SlicePrelude;\n+    use core::slice::SliceExt;\n     r.binary_search(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n         else if hi < c { Less }\n@@ -6825,7 +6825,7 @@ pub mod normalization {\n \n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n         use core::cmp::Ordering::{Equal, Less, Greater};\n-        use core::slice::SlicePrelude;\n+        use core::slice::SliceExt;\n         use core::slice;\n         match r.binary_search(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n@@ -6958,7 +6958,7 @@ pub mod normalization {\n \n pub mod conversions {\n     use core::cmp::Ordering::{Equal, Less, Greater};\n-    use core::slice::SlicePrelude;\n+    use core::slice::SliceExt;\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n     use core::slice;\n@@ -7595,7 +7595,7 @@ pub mod conversions {\n pub mod charwidth {\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n-    use core::slice::SlicePrelude;\n+    use core::slice::SliceExt;\n     use core::slice;\n \n     fn bsearch_range_value_table(c: char, is_cjk: bool, r: &'static [(char, char, u8, u8)]) -> u8 {\n@@ -7801,8 +7801,8 @@ pub mod charwidth {\n }\n \n pub mod grapheme {\n-    use core::slice::SlicePrelude;\n     use core::kinds::Copy;\n+    use core::slice::SliceExt;\n     pub use self::GraphemeCat::*;\n     use core::slice;\n "}, {"sha": "5e98109c432aa349f13f37764865a9e1f0f1d302", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7741516a8bb206bf9357b70e12990a4dc1ba8169/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=7741516a8bb206bf9357b70e12990a4dc1ba8169", "patch": "@@ -17,7 +17,7 @@\n \n use self::GraphemeState::*;\n use core::cmp;\n-use core::slice::SlicePrelude;\n+use core::slice::SliceExt;\n use core::iter::{Filter, AdditiveIterator, Iterator, IteratorExt};\n use core::iter::{DoubleEndedIterator, DoubleEndedIteratorExt};\n use core::kinds::Sized;"}]}