{"sha": "b5f65ec699c8a89155c4aa214cf2510030a88a6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1ZjY1ZWM2OTljOGE4OTE1NWM0YWEyMTRjZjI1MTAwMzBhODhhNmQ=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-18T12:11:07Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-18T12:11:07Z"}, "message": "Improve OR_FUN_CALL to suggest unwrap_or_default", "tree": {"sha": "d83706cbe2d61429ac75b1aa80a789209e3e5223", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d83706cbe2d61429ac75b1aa80a789209e3e5223"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5f65ec699c8a89155c4aa214cf2510030a88a6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5f65ec699c8a89155c4aa214cf2510030a88a6d", "html_url": "https://github.com/rust-lang/rust/commit/b5f65ec699c8a89155c4aa214cf2510030a88a6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5f65ec699c8a89155c4aa214cf2510030a88a6d/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb6b3bed0fc5701287035fc9c445a202e492a0d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb6b3bed0fc5701287035fc9c445a202e492a0d8", "html_url": "https://github.com/rust-lang/rust/commit/fb6b3bed0fc5701287035fc9c445a202e492a0d8"}], "stats": {"total": 155, "additions": 123, "deletions": 32}, "files": [{"sha": "b5ce82f1a43a0c16fc44842b11976fb4ff6f9347", "filename": "src/methods.rs", "status": "modified", "additions": 85, "deletions": 20, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b5f65ec699c8a89155c4aa214cf2510030a88a6d/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f65ec699c8a89155c4aa214cf2510030a88a6d/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=b5f65ec699c8a89155c4aa214cf2510030a88a6d", "patch": "@@ -5,11 +5,13 @@ use rustc::middle::subst::{Subst, TypeSpace};\n use std::iter;\n use std::borrow::Cow;\n use syntax::ptr::P;\n+use syntax::codemap::Span;\n \n use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, method_chain_args, match_trait_method,\n-            walk_ptrs_ty_depth, walk_ptrs_ty};\n-use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n+            walk_ptrs_ty_depth, walk_ptrs_ty, get_trait_def_id, implements_trait};\n+use utils::{DEFAULT_TRAIT_PATH, OPTION_PATH, RESULT_PATH, STRING_PATH};\n use utils::MethodArgs;\n+use rustc::middle::cstore::CrateStore;\n \n use self::SelfKind::*;\n use self::OutType::*;\n@@ -172,7 +174,7 @@ declare_lint!(pub SEARCH_IS_SOME, Warn,\n                expressed as a call to `any()`\");\n \n /// **What it does:** This lint checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`, etc., and\n-/// suggests to use `or_else`, `unwrap_or_else`, etc., instead.\n+/// suggests to use `or_else`, `unwrap_or_else`, etc., or `unwrap_or_default` instead.\n ///\n /// **Why is this bad?** The function will always be called and potentially allocate an object\n /// in expressions such as:\n@@ -183,10 +185,13 @@ declare_lint!(pub SEARCH_IS_SOME, Warn,\n /// ```rust\n /// foo.unwrap_or_else(String::new)\n /// ```\n+/// or\n+/// ```rust\n+/// foo.unwrap_or_default()\n+/// ```\n ///\n /// **Known problems:** If the function as side-effects, not calling it will change the semantic of\n-/// the program, but you shouldn't rely on that anyway. The will won't catch\n-/// `foo.unwrap_or(vec![])`.\n+/// the program, but you shouldn't rely on that anyway.\n declare_lint!(pub OR_FUN_CALL, Warn,\n               \"using any `*or` method when the `*or_else` would do\");\n \n@@ -284,8 +289,61 @@ impl LateLintPass for MethodsPass {\n \n /// Checks for the `OR_FUN_CALL` lint.\n fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>]) {\n-    if args.len() == 2 && [\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"].contains(&name) {\n-        let self_ty = cx.tcx.expr_ty(&args[0]);\n+    /// Check for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n+    fn check_unwrap_or_default(\n+        cx: &LateContext,\n+        name: &str,\n+        fun: &Expr,\n+        self_expr: &Expr,\n+        arg: &Expr,\n+        or_has_args: bool,\n+        span: Span\n+    ) -> bool {\n+        if or_has_args {\n+            return false;\n+        }\n+\n+        if name == \"unwrap_or\" {\n+            if let ExprPath(_, ref path) = fun.node {\n+                let path : &str = &path.segments.last()\n+                    .expect(\"A path must have at least one segment\")\n+                    .identifier.name.as_str();\n+\n+                if [\"default\", \"new\"].contains(&path) {\n+                    let arg_ty = cx.tcx.expr_ty(arg);\n+                    let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &DEFAULT_TRAIT_PATH) {\n+                        default_trait_id\n+                    }\n+                    else {\n+                        return false;\n+                    };\n+\n+                    if implements_trait(cx, arg_ty, default_trait_id) {\n+                        span_lint(cx, OR_FUN_CALL, span,\n+                                  &format!(\"use of `{}` followed by a call to `{}`\", name, path))\n+                            .span_suggestion(span, \"try this\",\n+                                             format!(\"{}.unwrap_or_default()\",\n+                                                     snippet(cx, self_expr.span, \"_\")));\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    /// Check for `*or(foo())`.\n+    fn check_general_case(\n+        cx: &LateContext,\n+        name: &str,\n+        fun: &Expr,\n+        self_expr: &Expr,\n+        arg: &Expr,\n+        or_has_args: bool,\n+        span: Span\n+    ) {\n+        let self_ty = cx.tcx.expr_ty(self_expr);\n \n         let is_result = if match_type(cx, self_ty, &RESULT_PATH) {\n             true\n@@ -297,20 +355,27 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n             return;\n         };\n \n+        let sugg = match (is_result, !or_has_args) {\n+            (true, _) => format!(\"|_| {}\", snippet(cx, arg.span, \"..\")),\n+            (false, false) => format!(\"|| {}\", snippet(cx, arg.span, \"..\")),\n+            (false, true) => format!(\"{}\", snippet(cx, fun.span, \"..\")),\n+        };\n+\n+        span_lint(cx, OR_FUN_CALL, span,\n+                  &format!(\"use of `{}` followed by a function call\", name))\n+            .span_suggestion(span, \"try this\",\n+                             format!(\"{}.{}_else({})\",\n+                                     snippet(cx, self_expr.span, \"_\"),\n+                                     name,\n+                                     sugg));\n+    }\n+\n+    if args.len() == 2 && [\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"].contains(&name) {\n         if let ExprCall(ref fun, ref or_args) = args[1].node {\n-            let sugg = match (is_result, or_args.is_empty()) {\n-                (true, _) => format!(\"|_| {}\", snippet(cx, args[1].span, \"..\")),\n-                (false, false) => format!(\"|| {}\", snippet(cx, args[1].span, \"..\")),\n-                (false, true) => format!(\"{}\", snippet(cx, fun.span, \"..\")),\n-            };\n-\n-            span_lint(cx, OR_FUN_CALL, expr.span,\n-                      &format!(\"use of `{}` followed by a function call\", name))\n-                .span_suggestion(expr.span, \"try this\",\n-                                 format!(\"{}.{}_else({})\",\n-                                         snippet(cx, args[0].span, \"_\"),\n-                                         name,\n-                                         sugg));\n+            let or_has_args = !or_args.is_empty();\n+            if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n+                check_general_case(cx, name, fun, &args[0], &args[1], or_has_args, expr.span);\n+            }\n         }\n     }\n }"}, {"sha": "d357fb0a54ae97a3c76209e54b03f670065159dc", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b5f65ec699c8a89155c4aa214cf2510030a88a6d/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f65ec699c8a89155c4aa214cf2510030a88a6d/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=b5f65ec699c8a89155c4aa214cf2510030a88a6d", "patch": "@@ -177,29 +177,55 @@ fn search_is_some() {\n \n /// Checks implementation of the OR_FUN_CALL lint\n fn or_fun_call() {\n-    let foo = Some(vec![1]);\n-    foo.unwrap_or(Vec::new());\n+    fn make<T>() -> T { unimplemented!(); }\n+\n+    let with_constructor = Some(vec![1]);\n+    with_constructor.unwrap_or(make());\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION with_constructor.unwrap_or_else(make)\n+\n+    let with_new = Some(vec![1]);\n+    with_new.unwrap_or(Vec::new());\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION with_new.unwrap_or_default();\n+\n+    let with_const_args = Some(vec![1]);\n+    with_const_args.unwrap_or(Vec::with_capacity(12));\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION with_const_args.unwrap_or_else(|| Vec::with_capacity(12));\n+\n+    let with_err : Result<_, ()> = Ok(vec![1]);\n+    with_err.unwrap_or(make());\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION with_err.unwrap_or_else(|_| make());\n+\n+    let with_err_args : Result<_, ()> = Ok(vec![1]);\n+    with_err_args.unwrap_or(Vec::with_capacity(12));\n     //~^ERROR use of `unwrap_or`\n     //~|HELP try this\n-    //~|SUGGESTION foo.unwrap_or_else(Vec::new);\n+    //~|SUGGESTION with_err_args.unwrap_or_else(|_| Vec::with_capacity(12));\n \n-    let bar = Some(vec![1]);\n-    bar.unwrap_or(Vec::with_capacity(12));\n+    let with_default_trait = Some(1);\n+    with_default_trait.unwrap_or(Default::default());\n     //~^ERROR use of `unwrap_or`\n     //~|HELP try this\n-    //~|SUGGESTION bar.unwrap_or_else(|| Vec::with_capacity(12));\n+    //~|SUGGESTION with_default_trait.unwrap_or_default();\n \n-    let baz : Result<_, ()> = Ok(vec![1]);\n-    baz.unwrap_or(Vec::new());\n+    let with_default_type = Some(1);\n+    with_default_type.unwrap_or(u64::default());\n     //~^ERROR use of `unwrap_or`\n     //~|HELP try this\n-    //~|SUGGESTION baz.unwrap_or_else(|_| Vec::new());\n+    //~|SUGGESTION with_default_type.unwrap_or_default();\n \n-    let qux : Result<_, ()> = Ok(vec![1]);\n-    qux.unwrap_or(Vec::with_capacity(12));\n+    let with_vec = Some(vec![1]);\n+    with_vec.unwrap_or(vec![]);\n     //~^ERROR use of `unwrap_or`\n     //~|HELP try this\n-    //~|SUGGESTION qux.unwrap_or_else(|_| Vec::with_capacity(12));\n+    //~|SUGGESTION with_vec.unwrap_or_else(|| vec![]);\n }\n \n fn main() {"}]}