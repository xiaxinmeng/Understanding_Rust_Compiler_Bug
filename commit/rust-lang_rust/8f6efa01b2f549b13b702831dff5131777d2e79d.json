{"sha": "8f6efa01b2f549b13b702831dff5131777d2e79d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNmVmYTAxYjJmNTQ5YjEzYjcwMjgzMWRmZjUxMzE3NzdkMmU3OWQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-17T09:26:29Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-17T09:27:09Z"}, "message": "Tidier tidy checks", "tree": {"sha": "2aa85677a9d8337e0f1b1d58a727993d1adda79e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2aa85677a9d8337e0f1b1d58a727993d1adda79e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f6efa01b2f549b13b702831dff5131777d2e79d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f6efa01b2f549b13b702831dff5131777d2e79d", "html_url": "https://github.com/rust-lang/rust/commit/8f6efa01b2f549b13b702831dff5131777d2e79d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f6efa01b2f549b13b702831dff5131777d2e79d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f755486ffc83f56d6c9ed7bfc4385a3ce1696c94", "url": "https://api.github.com/repos/rust-lang/rust/commits/f755486ffc83f56d6c9ed7bfc4385a3ce1696c94", "html_url": "https://github.com/rust-lang/rust/commit/f755486ffc83f56d6c9ed7bfc4385a3ce1696c94"}], "stats": {"total": 276, "additions": 145, "deletions": 131}, "files": [{"sha": "f5b00a8b8c6d758c7dcf7af9d835b71ddb9f1cc6", "filename": "xtask/tests/tidy-tests/cli.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8f6efa01b2f549b13b702831dff5131777d2e79d/xtask%2Ftests%2Ftidy-tests%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6efa01b2f549b13b702831dff5131777d2e79d/xtask%2Ftests%2Ftidy-tests%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fcli.rs?ref=8f6efa01b2f549b13b702831dff5131777d2e79d", "patch": "@@ -1,7 +1,6 @@\n-use walkdir::WalkDir;\n use xtask::{\n     codegen::{self, Mode},\n-    project_root, run_rustfmt,\n+    run_rustfmt,\n };\n \n #[test]\n@@ -31,25 +30,3 @@ fn check_code_formatting() {\n         panic!(\"{}. Please format the code by running `cargo format`\", error);\n     }\n }\n-\n-#[test]\n-fn no_todo() {\n-    WalkDir::new(project_root().join(\"crates\")).into_iter().for_each(|e| {\n-        let e = e.unwrap();\n-        if e.path().extension().map(|it| it != \"rs\").unwrap_or(true) {\n-            return;\n-        }\n-        if e.path().ends_with(\"tests/cli.rs\") {\n-            return;\n-        }\n-        let text = std::fs::read_to_string(e.path()).unwrap();\n-        if text.contains(\"TODO\") || text.contains(\"TOOD\") || text.contains(\"todo!\") {\n-            panic!(\n-                \"\\nTODO markers should not be committed to the master branch,\\n\\\n-                 use FIXME instead\\n\\\n-                 {}\\n\",\n-                e.path().display(),\n-            )\n-        }\n-    })\n-}"}, {"sha": "62c4f844139db470cab851bd87361fe3962908b2", "filename": "xtask/tests/tidy-tests/docs.rs", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f755486ffc83f56d6c9ed7bfc4385a3ce1696c94/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f755486ffc83f56d6c9ed7bfc4385a3ce1696c94/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fdocs.rs?ref=f755486ffc83f56d6c9ed7bfc4385a3ce1696c94", "patch": "@@ -1,106 +0,0 @@\n-use std::{collections::HashMap, fs, io::prelude::*, io::BufReader, path::Path};\n-\n-use anyhow::Context;\n-use walkdir::{DirEntry, WalkDir};\n-use xtask::project_root;\n-\n-fn is_exclude_dir(p: &Path) -> bool {\n-    // Test hopefully don't really need comments, and for assists we already\n-    // have special comments which are source of doc tests and user docs.\n-    let exclude_dirs = [\"tests\", \"test_data\", \"handlers\"];\n-    let mut cur_path = p;\n-    while let Some(path) = cur_path.parent() {\n-        if exclude_dirs.iter().any(|dir| path.ends_with(dir)) {\n-            return true;\n-        }\n-        cur_path = path;\n-    }\n-\n-    false\n-}\n-\n-fn is_exclude_file(d: &DirEntry) -> bool {\n-    let file_names = [\"tests.rs\"];\n-\n-    d.file_name().to_str().map(|f_n| file_names.iter().any(|name| *name == f_n)).unwrap_or(false)\n-}\n-\n-fn is_hidden(entry: &DirEntry) -> bool {\n-    entry.file_name().to_str().map(|s| s.starts_with('.')).unwrap_or(false)\n-}\n-\n-#[test]\n-fn no_docs_comments() {\n-    let crates = project_root().join(\"crates\");\n-    let iter = WalkDir::new(crates);\n-    let mut missing_docs = Vec::new();\n-    let mut contains_fixme = Vec::new();\n-    for f in iter.into_iter().filter_entry(|e| !is_hidden(e)) {\n-        let f = f.unwrap();\n-        if f.file_type().is_dir() {\n-            continue;\n-        }\n-        if f.path().extension().map(|it| it != \"rs\").unwrap_or(false) {\n-            continue;\n-        }\n-        if is_exclude_dir(f.path()) {\n-            continue;\n-        }\n-        if is_exclude_file(&f) {\n-            continue;\n-        }\n-        let mut reader = BufReader::new(fs::File::open(f.path()).unwrap());\n-        let mut line = String::new();\n-        reader\n-            .read_line(&mut line)\n-            .with_context(|| format!(\"Failed to read {}\", f.path().display()))\n-            .unwrap();\n-\n-        if line.starts_with(\"//!\") {\n-            if line.contains(\"FIXME\") {\n-                contains_fixme.push(f.path().to_path_buf())\n-            }\n-        } else {\n-            missing_docs.push(f.path().display().to_string());\n-        }\n-    }\n-    if !missing_docs.is_empty() {\n-        panic!(\n-            \"\\nMissing docs strings\\n\\n\\\n-             modules:\\n{}\\n\\n\",\n-            missing_docs.join(\"\\n\")\n-        )\n-    }\n-\n-    let whitelist = [\n-        \"ra_db\",\n-        \"ra_hir\",\n-        \"ra_hir_expand\",\n-        \"ra_ide\",\n-        \"ra_mbe\",\n-        \"ra_parser\",\n-        \"ra_prof\",\n-        \"ra_project_model\",\n-        \"ra_syntax\",\n-        \"ra_text_edit\",\n-        \"ra_tt\",\n-        \"ra_hir_ty\",\n-    ];\n-\n-    let mut has_fixmes = whitelist.iter().map(|it| (*it, false)).collect::<HashMap<&str, bool>>();\n-    'outer: for path in contains_fixme {\n-        for krate in whitelist.iter() {\n-            if path.components().any(|it| it.as_os_str() == *krate) {\n-                has_fixmes.insert(krate, true);\n-                continue 'outer;\n-            }\n-        }\n-        panic!(\"FIXME doc in a fully-documented crate: {}\", path.display())\n-    }\n-\n-    for (krate, has_fixme) in has_fixmes.iter() {\n-        if !has_fixme {\n-            panic!(\"crate {} is fully documented, remove it from the white list\", krate)\n-        }\n-    }\n-}"}, {"sha": "2d2d88beca9b9a464039bd69d7f4fc1265ce17ee", "filename": "xtask/tests/tidy-tests/main.rs", "status": "modified", "additions": 144, "deletions": 1, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/8f6efa01b2f549b13b702831dff5131777d2e79d/xtask%2Ftests%2Ftidy-tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6efa01b2f549b13b702831dff5131777d2e79d/xtask%2Ftests%2Ftidy-tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fmain.rs?ref=8f6efa01b2f549b13b702831dff5131777d2e79d", "patch": "@@ -1,2 +1,145 @@\n mod cli;\n-mod docs;\n+\n+use std::{\n+    collections::HashMap,\n+    path::{Path, PathBuf},\n+};\n+\n+use walkdir::{DirEntry, WalkDir};\n+use xtask::{not_bash::fs2, project_root};\n+\n+#[test]\n+fn rust_files_are_tidy() {\n+    let mut tidy_docs = TidyDocs::default();\n+    for path in rust_files() {\n+        let text = fs2::read_to_string(&path).unwrap();\n+        check_todo(&path, &text);\n+        tidy_docs.visit(&path, &text);\n+    }\n+    tidy_docs.finish();\n+}\n+\n+fn check_todo(path: &Path, text: &str) {\n+    if path.ends_with(\"tests/cli.rs\") {\n+        return;\n+    }\n+    if text.contains(\"TODO\") || text.contains(\"TOOD\") || text.contains(\"todo!\") {\n+        panic!(\n+            \"\\nTODO markers should not be committed to the master branch,\\n\\\n+             use FIXME instead\\n\\\n+             {}\\n\",\n+            path.display(),\n+        )\n+    }\n+}\n+\n+#[derive(Default)]\n+struct TidyDocs {\n+    missing_docs: Vec<String>,\n+    contains_fixme: Vec<PathBuf>,\n+}\n+\n+impl TidyDocs {\n+    fn visit(&mut self, path: &Path, text: &str) {\n+        if is_exclude_dir(path) || is_exclude_file(path) {\n+            return;\n+        }\n+\n+        let first_line = match text.lines().next() {\n+            Some(it) => it,\n+            None => return,\n+        };\n+\n+        if first_line.starts_with(\"//!\") {\n+            if first_line.contains(\"FIXME\") {\n+                self.contains_fixme.push(path.to_path_buf())\n+            }\n+        } else {\n+            self.missing_docs.push(path.display().to_string());\n+        }\n+\n+        fn is_exclude_dir(p: &Path) -> bool {\n+            // Test hopefully don't really need comments, and for assists we already\n+            // have special comments which are source of doc tests and user docs.\n+            let exclude_dirs = [\"tests\", \"test_data\", \"handlers\"];\n+            let mut cur_path = p;\n+            while let Some(path) = cur_path.parent() {\n+                if exclude_dirs.iter().any(|dir| path.ends_with(dir)) {\n+                    return true;\n+                }\n+                cur_path = path;\n+            }\n+\n+            false\n+        }\n+\n+        fn is_exclude_file(d: &Path) -> bool {\n+            let file_names = [\"tests.rs\"];\n+\n+            d.file_name()\n+                .unwrap_or_default()\n+                .to_str()\n+                .map(|f_n| file_names.iter().any(|name| *name == f_n))\n+                .unwrap_or(false)\n+        }\n+    }\n+\n+    fn finish(self) {\n+        if !self.missing_docs.is_empty() {\n+            panic!(\n+                \"\\nMissing docs strings\\n\\n\\\n+                 modules:\\n{}\\n\\n\",\n+                self.missing_docs.join(\"\\n\")\n+            )\n+        }\n+\n+        let whitelist = [\n+            \"ra_db\",\n+            \"ra_hir\",\n+            \"ra_hir_expand\",\n+            \"ra_ide\",\n+            \"ra_mbe\",\n+            \"ra_parser\",\n+            \"ra_prof\",\n+            \"ra_project_model\",\n+            \"ra_syntax\",\n+            \"ra_text_edit\",\n+            \"ra_tt\",\n+            \"ra_hir_ty\",\n+        ];\n+\n+        let mut has_fixmes =\n+            whitelist.iter().map(|it| (*it, false)).collect::<HashMap<&str, bool>>();\n+        'outer: for path in self.contains_fixme {\n+            for krate in whitelist.iter() {\n+                if path.components().any(|it| it.as_os_str() == *krate) {\n+                    has_fixmes.insert(krate, true);\n+                    continue 'outer;\n+                }\n+            }\n+            panic!(\"FIXME doc in a fully-documented crate: {}\", path.display())\n+        }\n+\n+        for (krate, has_fixme) in has_fixmes.iter() {\n+            if !has_fixme {\n+                panic!(\"crate {} is fully documented, remove it from the white list\", krate)\n+            }\n+        }\n+    }\n+}\n+\n+fn rust_files() -> impl Iterator<Item = PathBuf> {\n+    let crates = project_root().join(\"crates\");\n+    let iter = WalkDir::new(crates);\n+    return iter\n+        .into_iter()\n+        .filter_entry(|e| !is_hidden(e))\n+        .map(|e| e.unwrap())\n+        .filter(|e| !e.file_type().is_dir())\n+        .map(|e| e.into_path())\n+        .filter(|path| path.extension().map(|it| it == \"rs\").unwrap_or(false));\n+\n+    fn is_hidden(entry: &DirEntry) -> bool {\n+        entry.file_name().to_str().map(|s| s.starts_with('.')).unwrap_or(false)\n+    }\n+}"}]}