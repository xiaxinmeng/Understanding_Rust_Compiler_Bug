{"sha": "232065074d5cbc15065860abe4d7fbc8e765ad1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzMjA2NTA3NGQ1Y2JjMTUwNjU4NjBhYmU0ZDdmYmM4ZTc2NWFkMWQ=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2019-11-16T21:31:23Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-09-03T18:59:09Z"}, "message": "recover vectorization\n\nswitch to try_fold and segregate the drop handling to keep\ncollect::<Vec<u8>>() and similar optimizer-friendly\n\nIt comes at the cost of less accurate debug_asserts and code complexity", "tree": {"sha": "b75bbd2a5a0cc7a52a18786aabba170088065849", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b75bbd2a5a0cc7a52a18786aabba170088065849"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/232065074d5cbc15065860abe4d7fbc8e765ad1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/232065074d5cbc15065860abe4d7fbc8e765ad1d", "html_url": "https://github.com/rust-lang/rust/commit/232065074d5cbc15065860abe4d7fbc8e765ad1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/232065074d5cbc15065860abe4d7fbc8e765ad1d/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c5c47b82b982d385eaff1d959bf716925f096f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c5c47b82b982d385eaff1d959bf716925f096f6", "html_url": "https://github.com/rust-lang/rust/commit/6c5c47b82b982d385eaff1d959bf716925f096f6"}], "stats": {"total": 77, "additions": 54, "deletions": 23}, "files": [{"sha": "e755afe9606f17bc93e49d86201938604dd9f96f", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/232065074d5cbc15065860abe4d7fbc8e765ad1d/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/232065074d5cbc15065860abe4d7fbc8e765ad1d/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=232065074d5cbc15065860abe4d7fbc8e765ad1d", "patch": "@@ -107,6 +107,7 @@\n #![feature(map_first_last)]\n #![feature(map_into_keys_values)]\n #![feature(negative_impls)]\n+#![feature(never_type)]\n #![feature(new_uninit)]\n #![feature(nll)]\n #![feature(nonnull_slice_from_raw_parts)]"}, {"sha": "a5caf2522c8f48c3039cd19487e1e182e038c51a", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 53, "deletions": 23, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/232065074d5cbc15065860abe4d7fbc8e765ad1d/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/232065074d5cbc15065860abe4d7fbc8e765ad1d/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=232065074d5cbc15065860abe4d7fbc8e765ad1d", "patch": "@@ -2126,23 +2126,23 @@ where\n     }\n }\n \n-struct InPlaceIterFront<T> {\n+struct InPlaceDrop<T> {\n     inner: *mut T,\n     dst: *mut T,\n     did_panic: bool,\n }\n \n-impl<T> InPlaceIterFront<T> {\n+impl<T> InPlaceDrop<T> {\n     unsafe fn len(&self) -> usize {\n         self.dst.offset_from(self.inner) as usize\n     }\n }\n \n-impl<T> Drop for InPlaceIterFront<T> {\n+impl<T> Drop for InPlaceDrop<T> {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {\n-            if mem::needs_drop::<T>() && self.did_panic {\n+            if self.did_panic {\n                 ptr::drop_in_place(slice::from_raw_parts_mut(self.inner, self.len()) as *mut _);\n             }\n         }\n@@ -2153,31 +2153,61 @@ fn from_into_iter_source<T, I>(mut iterator: I) -> Vec<T>\n where\n     I: Iterator<Item = T> + InPlaceIterable + SourceIter<Source = IntoIter<T>>,\n {\n-    let original_ptr = iterator.as_inner().buf.as_ptr();\n-    let mut front_buffer =\n-        InPlaceIterFront { inner: original_ptr, dst: original_ptr, did_panic: true };\n-\n-    while let Some(item) = iterator.next() {\n-        let source_iter = iterator.as_inner();\n-        debug_assert_eq!(original_ptr, source_iter.buf.as_ptr());\n-        unsafe {\n-            debug_assert!(\n-                front_buffer.dst as *const _ < source_iter.ptr,\n-                \"InPlaceIterable implementation produced more\\\n-                          items than it consumed from the source\"\n-            );\n-            ptr::write(front_buffer.dst, item);\n-            front_buffer.dst = front_buffer.dst.add(1);\n-        }\n-    }\n+    let src_buf = iterator.as_inner().buf.as_ptr();\n+    let src_end = iterator.as_inner().end;\n+    let dst = src_buf;\n+\n+    let dst = if mem::needs_drop::<T>() {\n+        // special-case drop handling since it prevents vectorization\n+        let mut sink = InPlaceDrop { inner: src_buf, dst, did_panic: true };\n+        let _ = iterator.try_for_each::<_, Result<_, !>>(|item| {\n+            unsafe {\n+                debug_assert!(\n+                    sink.dst as *const _ <= src_end,\n+                    \"InPlaceIterable contract violation\"\n+                );\n+                ptr::write(sink.dst, item);\n+                sink.dst = sink.dst.add(1);\n+            }\n+            Ok(())\n+        });\n+        sink.did_panic = false;\n+        sink.dst\n+    } else {\n+        // use try-fold since it vectorizes better, does not take ownership and lets us thread the\n+        // write pointer through its innards\n+        iterator\n+            .try_fold::<_, _, Result<_, !>>(dst, move |mut dst, item| {\n+                unsafe {\n+                    // the InPlaceIterable contract cannot be verified precisely here since\n+                    // try_fold has an exclusive reference to the source pointer\n+                    // all we can do is check if it's still in range\n+                    debug_assert!(dst as *const _ <= src_end, \"InPlaceIterable contract violation\");\n+                    ptr::write(dst, item);\n+                    dst = dst.add(1);\n+                }\n+                Ok(dst)\n+            })\n+            .unwrap()\n+    };\n \n     let src = iterator.as_inner();\n-    front_buffer.did_panic = false;\n-    let vec = unsafe { Vec::from_raw_parts(src.buf.as_ptr(), front_buffer.len(), src.cap) };\n+    // check if SourceIter and InPlaceIterable contracts were upheld.\n+    // but if they weren't we may not even make it to this point\n+    debug_assert_eq!(src_buf, src.buf.as_ptr());\n+    debug_assert!(dst as *const _ <= src.ptr, \"InPlaceIterable contract violation\");\n+\n+    let vec = unsafe {\n+        let len = dst.offset_from(src_buf) as usize;\n+        Vec::from_raw_parts(src.buf.as_ptr(), len, src.cap)\n+    };\n+    // prevent drop of the underlying storage by turning the IntoIter into\n+    // the equivalent of Vec::new().into_iter()\n     src.cap = 0;\n     src.buf = unsafe { NonNull::new_unchecked(RawVec::NEW.ptr()) };\n     src.ptr = src.buf.as_ptr();\n     src.end = src.buf.as_ptr();\n+\n     vec\n }\n "}]}