{"sha": "e8c337b5ca883285e6215f1f669d5556842d1520", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4YzMzN2I1Y2E4ODMyODVlNjIxNWYxZjY2OWQ1NTU2ODQyZDE1MjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-06T18:37:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-06T18:37:57Z"}, "message": "Auto merge of #30532 - nikomatsakis:cross-item-dependencies, r=mw\n\nThis is roughly the same as my previous PR that created a dependency graph, but that:\n\n1. The dependency graph is only optionally constructed, though this doesn't seem to make much of a difference in terms of overhead (see measurements below).\n2. The dependency graph is simpler (I combined a lot of nodes).\n3. The dependency graph debugging facilities are much better: you can now use `RUST_DEP_GRAPH_FILTER` to filter the dep graph to just the nodes you are interested in, which is super help.\n4. The tests are somewhat more elaborate, including a few known bugs I need to fix in a second pass.\n\nThis is potentially a `[breaking-change]` for plugin authors. If you are poking about in tcx state or something like that, you probably want to add `let _ignore = tcx.dep_graph.in_ignore();`, which will cause your reads/writes to be ignored and not affect the dep-graph.\n\nAfter this, or perhaps as an add-on to this PR in some cases, what I would like to do is the following:\n\n- [x] Write-up a little guide to how to use this system, the debugging options available, and what the possible failure modes are.\n- [ ] Introduce read-only and perhaps the `Meta` node\n- [x] Replace \"memoization tasks\" with node from the map itself\n- [ ] Fix the shortcomings, obviously! Notably, the HIR map needs to register reads, and there is some state that is not yet tracked. (Maybe as a separate PR.)\n- [x] Refactor the dep-graph code so that the actual maintenance of the dep-graph occurs in a parallel thread, and the main thread simply throws things into a shared channel (probably a fixed-size channel). There is no reason for dep-graph construction to be on the main thread. (Maybe as a separate PR.)\n\nRegarding performance: adding this tracking does add some overhead, approximately 2% in my measurements (I was comparing the build times for rustdoc). Interestingly, enabling or disabling tracking doesn't seem to do very much. I want to poke at this some more and gather a bit more data -- in some tests I've seen that 2% go away, but on others it comes back. It's not entirely clear to me if that 2% is truly due to constructing the dep-graph at all.\n\nThe next big step after this is write some code to dump the dep-graph to disk and reload it.\n\nr? @michaelwoerister", "tree": {"sha": "4e1063cd9793428232460e617ac6883eb68e3b21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e1063cd9793428232460e617ac6883eb68e3b21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8c337b5ca883285e6215f1f669d5556842d1520", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8c337b5ca883285e6215f1f669d5556842d1520", "html_url": "https://github.com/rust-lang/rust/commit/e8c337b5ca883285e6215f1f669d5556842d1520", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8c337b5ca883285e6215f1f669d5556842d1520/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21b025f55fa7f68982f9faf58522da11b3d91815", "url": "https://api.github.com/repos/rust-lang/rust/commits/21b025f55fa7f68982f9faf58522da11b3d91815", "html_url": "https://github.com/rust-lang/rust/commit/21b025f55fa7f68982f9faf58522da11b3d91815"}, {"sha": "93996b160ce319f864fbab6c9243048c4d65704c", "url": "https://api.github.com/repos/rust-lang/rust/commits/93996b160ce319f864fbab6c9243048c4d65704c", "html_url": "https://github.com/rust-lang/rust/commit/93996b160ce319f864fbab6c9243048c4d65704c"}], "stats": {"total": 3065, "additions": 2641, "deletions": 424}, "files": [{"sha": "21742d9935dc2d8b3ff2f937db958b46fd247218", "filename": "src/librustc/dep_graph/README.md", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,390 @@\n+# Dependency graph for incremental compilation\n+\n+This module contains the infrastructure for managing the incremental\n+compilation dependency graph. This README aims to explain how it ought\n+to be used. In this document, we'll first explain the overall\n+strategy, and then share some tips for handling specific scenarios.\n+\n+The high-level idea is that we want to instrument the compiler to\n+track which parts of the AST and other IR are read/written by what.\n+This way, when we come back later, we can look at this graph and\n+determine what work needs to be redone.\n+\n+### The dependency graph\n+\n+The nodes of the graph are defined by the enum `DepNode`. They represent\n+one of three things:\n+\n+1. HIR nodes (like `Hir(DefId)`) represent the HIR input itself.\n+2. Data nodes (like `ItemSignature(DefId)`) represent some computed\n+   information about a particular item.\n+3. Procedure notes (like `CoherenceCheckImpl(DefId)`) represent some\n+   procedure that is executing. Usually this procedure is\n+   performing some kind of check for errors. You can think of them as\n+   computed values where the value being computed is `()` (and the\n+   value may fail to be computed, if an error results).\n+\n+An edge `N1 -> N2` is added between two nodes if either:\n+\n+- the value of `N1` is used to compute `N2`;\n+- `N1` is read by the procedure `N2`;\n+- the procedure `N1` writes the value `N2`.\n+\n+The latter two conditions are equivalent to the first one if you think\n+of procedures as values.\n+\n+### Basic tracking\n+\n+There is a very general strategy to ensure that you have a correct, if\n+sometimes overconservative, dependency graph. The two main things you have\n+to do are (a) identify shared state and (b) identify the current tasks.\n+\n+### Identifying shared state\n+\n+Identify \"shared state\" that will be written by one pass and read by\n+another. In particular, we need to identify shared state that will be\n+read \"across items\" -- that is, anything where changes in one item\n+could invalidate work done for other items. So, for example:\n+\n+1. The signature for a function is \"shared state\".\n+2. The computed type of some expression in the body of a function is\n+   not shared state, because if it changes it does not itself\n+   invalidate other functions (though it may be that it causes new\n+   monomorphizations to occur, but that's handled independently).\n+   \n+Put another way: if the HIR for an item changes, we are going to\n+recompile that item for sure. But we need the dep tracking map to tell\n+us what *else* we have to recompile. Shared state is anything that is\n+used to communicate results from one item to another.\n+\n+### Identifying the current task\n+\n+The dep graph always tracks a current task: this is basically the\n+`DepNode` that the compiler is computing right now. Typically it would\n+be a procedure node, but it can also be a data node (as noted above,\n+the two are kind of equivalent).\n+\n+You set the current task by calling `dep_graph.in_task(node)`. For example:\n+\n+```rust\n+let _task = tcx.dep_graph.in_task(DepNode::Privacy);\n+```\n+\n+Now all the code until `_task` goes out of scope will be considered\n+part of the \"privacy task\".\n+\n+The tasks are maintained in a stack, so it is perfectly fine to nest\n+one task within another. Because pushing a task is considered to be\n+computing a value, when you nest a task `N2` inside of a task `N1`, we\n+automatically add an edge `N2 -> N1` (since `N1` presumably needed the\n+result of `N2` to complete):\n+\n+```rust\n+let _n1 = tcx.dep_graph.in_task(DepNode::N1);\n+let _n2 = tcx.dep_graph.in_task(DepNode::N2);\n+// this will result in an edge N1 -> n2\n+```\n+\n+### Ignore tasks\n+\n+Although it is rarely needed, you can also push a special \"ignore\"\n+task:\n+\n+```rust\n+let _ignore = tc.dep_graph.in_ignore();\n+```\n+\n+This will cause all read/write edges to be ignored until it goes out\n+of scope or until something else is pushed. For example, we could\n+suppress the edge between nested tasks like so:\n+\n+```rust\n+let _n1 = tcx.dep_graph.in_task(DepNode::N1);\n+let _ignore = tcx.dep_graph.in_ignore();\n+let _n2 = tcx.dep_graph.in_task(DepNode::N2);\n+// now no edge is added\n+```\n+\n+### Tracking reads and writes\n+\n+We need to identify what shared state is read/written by the current\n+task as it executes. The most fundamental way of doing that is to invoke\n+the `read` and `write` methods on `DepGraph`:\n+\n+```rust\n+// Adds an edge from DepNode::Hir(some_def_id) to the current task\n+tcx.dep_graph.read(DepNode::Hir(some_def_id))\n+\n+// Adds an edge from the current task to DepNode::ItemSignature(some_def_id)\n+tcx.dep_graph.write(DepNode::ItemSignature(some_def_id))\n+```\n+\n+However, you should rarely need to invoke those methods directly.\n+Instead, the idea is to *encapsulate* shared state into some API that\n+will invoke `read` and `write` automatically. The most common way to\n+do this is to use a `DepTrackingMap`, described in the next section,\n+but any sort of abstraction barrier will do. In general, the strategy\n+is that getting access to information implicitly adds an appropriate\n+`read`. So, for example, when you use the\n+`dep_graph::visit_all_items_in_krate` helper method, it will visit\n+each item `X`, start a task `Foo(X)` for that item, and automatically\n+add an edge `Hir(X) -> Foo(X)`. This edge is added because the code is\n+being given access to the HIR node for `X`, and hence it is expected\n+to read from it. Similarly, reading from the `tcache` map for item `X`\n+(which is a `DepTrackingMap`, described below) automatically invokes\n+`dep_graph.read(ItemSignature(X))`.\n+\n+To make this strategy work, a certain amount of indirection is\n+required. For example, modules in the HIR do not have direct pointers\n+to the items that they contain. Rather, they contain node-ids -- one\n+can then ask the HIR map for the item with a given node-id. This gives\n+us an opportunity to add an appropriate read edge.\n+\n+#### Explicit calls to read and write when starting a new subtask\n+\n+One time when you *may* need to call `read` and `write` directly is\n+when you push a new task onto the stack, either by calling `in_task`\n+as shown above or indirectly, such as with the `memoize` pattern\n+described below. In that case, any data that the task has access to\n+from the surrounding environment must be explicitly \"read\". For\n+example, in `librustc_typeck`, the collection code visits all items\n+and, among other things, starts a subtask producing its signature\n+(what follows is simplified pseudocode, of course):\n+\n+```rust\n+fn visit_item(item: &hir::Item) {\n+    // Here, current subtask is \"Collect(X)\", and an edge Hir(X) -> Collect(X)\n+    // has automatically been added by `visit_all_items_in_krate`.\n+    let sig = signature_of_item(item);\n+}\n+\n+fn signature_of_item(item: &hir::Item) {\n+    let def_id = tcx.map.local_def_id(item.id);\n+    let task = tcx.dep_graph.in_task(DepNode::ItemSignature(def_id));\n+    tcx.dep_graph.read(DepNode::Hir(def_id)); // <-- the interesting line\n+    ...\n+}\n+```\n+\n+Here you can see that, in `signature_of_item`, we started a subtask\n+corresponding to producing the `ItemSignature`. This subtask will read from\n+`item` -- but it gained access to `item` implicitly. This means that if it just\n+reads from `item`, there would be missing edges in the graph:\n+\n+    Hir(X) --+ // added by the explicit call to `read`\n+      |      |\n+      |      +---> ItemSignature(X) -> Collect(X)\n+      |                                 ^\n+      |                                 |\n+      +---------------------------------+ // added by `visit_all_items_in_krate`\n+    \n+In particular, the edge from `Hir(X)` to `ItemSignature(X)` is only\n+present because we called `read` ourselves when entering the `ItemSignature(X)`\n+task.\n+\n+So, the rule of thumb: when entering a new task yourself, register\n+reads on any shared state that you inherit. (This actually comes up\n+fairly infrequently though: the main place you need caution is around\n+memoization.)\n+\n+#### Dependency tracking map\n+\n+`DepTrackingMap` is a particularly convenient way to correctly store\n+shared state. A `DepTrackingMap` is a special hashmap that will add\n+edges automatically when `get` and `insert` are called. The idea is\n+that, when you get/insert a value for the key `K`, we will add an edge\n+from/to the node `DepNode::Variant(K)` (for some variant specific to\n+the map).\n+\n+Each `DepTrackingMap` is parameterized by a special type `M` that\n+implements `DepTrackingMapConfig`; this trait defines the key and value\n+types of the map, and also defines a fn for converting from the key to\n+a `DepNode` label. You don't usually have to muck about with this by\n+hand, there is a macro for creating it. You can see the complete set\n+of `DepTrackingMap` definitions in `librustc/middle/ty/maps.rs`.\n+\n+As an example, let's look at the `adt_defs` map. The `adt_defs` map\n+maps from the def-id of a struct/enum to its `AdtDef`. It is defined\n+using this macro:\n+\n+```rust\n+dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n+//            ~~~~~~~  ~~~~~~~~~~~~~ ~~~~~     ~~~~~~~~~~~~~~~~~~~~~~\n+//               |           |      Key type       Value type\n+//               |    DepNode variant\n+//      Name of map id type\n+```\n+\n+this indicates that a map id type `AdtDefs` will be created. The key\n+of the map will be a `DefId` and value will be\n+`ty::AdtDefMaster<'tcx>`. The `DepNode` will be created by\n+`DepNode::ItemSignature(K)` for a given key.\n+\n+Once that is done, you can just use the `DepTrackingMap` like any\n+other map:\n+\n+```rust\n+let mut map: DepTrackingMap<M> = DepTrackingMap::new(dep_graph);\n+map.insert(key, value); // registers dep_graph.write\n+map.get(key; // registers dep_graph.read\n+```\n+\n+#### Memoization\n+\n+One particularly interesting case is memoization. If you have some\n+shared state that you compute in a memoized fashion, the correct thing\n+to do is to define a `RefCell<DepTrackingMap>` for it and use the\n+`memoize` helper:\n+\n+```rust\n+map.memoize(key, || /* compute value */)\n+```\n+\n+This will create a graph that looks like\n+\n+    ... -> MapVariant(key) -> CurrentTask\n+\n+where `MapVariant` is the `DepNode` variant that the map is associated with,\n+and `...` are whatever edges the `/* compute value */` closure creates.\n+\n+In particular, using the memoize helper is much better than writing\n+the obvious code yourself:\n+\n+```\n+if let Some(result) = map.get(key) {\n+    return result;\n+}\n+let value = /* compute value */;\n+map.insert(key, value);\n+```\n+\n+If you write that code manually, the dependency graph you get will\n+include artificial edges that are not necessary. For example, imagine that\n+two tasks, A and B, both invoke the manual memoization code, but A happens\n+to go first. The resulting graph will be:\n+\n+    ... -> A -> MapVariant(key) -> B\n+    ~~~~~~~~~~~~~~~~~~~~~~~~~~~       // caused by A writing to MapVariant(key)\n+                ~~~~~~~~~~~~~~~~~~~~  // caused by B reading from MapVariant(key)\n+\n+This graph is not *wrong*, but it encodes a path from A to B that\n+should not exist.  In contrast, using the memoized helper, you get:\n+\n+    ... -> MapVariant(key) -> A\n+                 |\n+                 +----------> B\n+                 \n+which is much cleaner.                 \n+\n+**Be aware though that the closure is executed with `MapVariant(key)`\n+pushed onto the stack as the current task!** That means that you must\n+add explicit `read` calls for any shared state that it accesses\n+implicitly from its environment. See the section on \"explicit calls to\n+read and write when starting a new subtask\" above for more details.\n+\n+### How to decide where to introduce a new task\n+\n+Certainly, you need at least one task on the stack: any attempt to\n+`read` or `write` shared state will panic if there is no current\n+task. But where does it make sense to introduce subtasks? The basic\n+rule is that a subtask makes sense for any discrete unit of work you\n+may want to skip in the future. Adding a subtask separates out the\n+reads/writes from *that particular subtask* versus the larger\n+context. An example: you might have a 'meta' task for all of borrow\n+checking, and then subtasks for borrow checking individual fns.  (Seen\n+in this light, memoized computations are just a special case where we\n+may want to avoid redoing the work even within the context of one\n+compilation.)\n+\n+The other case where you might want a subtask is to help with refining\n+the reads/writes for some later bit of work that needs to be memoized.\n+For example, we create a subtask for type-checking the body of each\n+fn.  However, in the initial version of incr. comp. at least, we do\n+not expect to actually *SKIP* type-checking -- we only expect to skip\n+trans. However, it's still useful to create subtasks for type-checking\n+individual items, because, otherwise, if a fn sig changes, we won't\n+know which callers are affected -- in fact, because the graph would be\n+so coarse, we'd just have to retrans everything, since we can't\n+distinguish which fns used which fn sigs.\n+\n+### Testing the dependency graph\n+\n+There are various ways to write tests against the dependency graph.\n+The simplest mechanism are the\n+`#[rustc_if_this_changed]` and `#[rustc_then_this_would_need]`\n+annotations. These are used in compile-fail tests to test whether the\n+expected set of paths exist in the dependency graph. As an example,\n+see `src/test/compile-fail/dep-graph-caller-callee.rs`.\n+\n+The idea is that you can annotate a test like:\n+\n+```rust\n+#[rustc_if_this_changed]\n+fn foo() { }\n+\n+#[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR OK\n+fn bar() { foo(); }\n+\n+#[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+fn baz() { }\n+```\n+\n+This will check whether there is a path in the dependency graph from\n+`Hir(foo)` to `TypeckItemBody(bar)`. An error is reported for each\n+`#[rustc_then_this_would_need]` annotation that indicates whether a\n+path exists. `//~ ERROR` annotations can then be used to test if a\n+path is found (as demonstrated above).\n+\n+### Debugging the dependency graph\n+\n+The compiler is also capable of dumping the dependency graph for your\n+debugging pleasure. To do so, pass the `-Z dump-dep-graph` flag. The\n+graph will be dumped to `dep_graph.{txt,dot}` in the current\n+directory.  You can override the filename with the `RUST_DEP_GRAPH`\n+environment variable.\n+\n+Frequently, though, the full dep graph is quite overwhelming and not\n+particularly helpful. Therefore, the compiler also allows you to filter\n+the graph. You can filter in three ways:\n+\n+1. All edges originating in a particular set of nodes (usually a single node).\n+2. All edges reaching a particular set of nodes.\n+3. All edges that lie between given start and end nodes.\n+\n+To filter, use the `RUST_DEP_GRAPH_FILTER` environment variable, which should\n+look like one of the following:\n+\n+```\n+source_filter     // nodes originating from source_filter\n+-> target_filter  // nodes that can reach target_filter\n+source_filter -> target_filter // nodes in between source_filter and target_filter\n+```\n+\n+`source_filter` and `target_filter` are a `&`-separated list of strings.\n+A node is considered to match a filter if all of those strings appear in its\n+label. So, for example:\n+\n+```\n+RUST_DEP_GRAPH_FILTER='-> TypeckItemBody'\n+```\n+\n+would select the predecessors of all `TypeckItemBody` nodes. Usually though you\n+want the `TypeckItemBody` node for some particular fn, so you might write:\n+\n+```\n+RUST_DEP_GRAPH_FILTER='-> TypeckItemBody & bar'\n+```\n+\n+This will select only the `TypeckItemBody` nodes for fns with `bar` in their name.\n+\n+Perhaps you are finding that when you change `foo` you need to re-type-check `bar`,\n+but you don't think you should have to. In that case, you might do:\n+\n+```\n+RUST_DEP_GRAPH_FILTER='Hir&foo -> TypeckItemBody & bar'\n+```\n+\n+This will dump out all the nodes that lead from `Hir(foo)` to\n+`TypeckItemBody(bar)`, from which you can (hopefully) see the source\n+of the erroneous edge.\n+"}, {"sha": "c49e64f0f543b593ec551ae181cecb5dae395653", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::fnv::FnvHashMap;\n+use std::cell::RefCell;\n+use std::ops::Index;\n+use std::hash::Hash;\n+use std::marker::PhantomData;\n+use util::common::MemoizationMap;\n+\n+use super::{DepNode, DepGraph};\n+\n+/// A DepTrackingMap offers a subset of the `Map` API and ensures that\n+/// we make calls to `read` and `write` as appropriate. We key the\n+/// maps with a unique type for brevity.\n+pub struct DepTrackingMap<M: DepTrackingMapConfig> {\n+    phantom: PhantomData<M>,\n+    graph: DepGraph,\n+    map: FnvHashMap<M::Key, M::Value>,\n+}\n+\n+pub trait DepTrackingMapConfig {\n+    type Key: Eq + Hash + Clone;\n+    type Value: Clone;\n+    fn to_dep_node(key: &Self::Key) -> DepNode;\n+}\n+\n+impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n+    pub fn new(graph: DepGraph) -> DepTrackingMap<M> {\n+        DepTrackingMap {\n+            phantom: PhantomData,\n+            graph: graph,\n+            map: FnvHashMap()\n+        }\n+    }\n+\n+    /// Registers a (synthetic) read from the key `k`. Usually this\n+    /// is invoked automatically by `get`.\n+    fn read(&self, k: &M::Key) {\n+        let dep_node = M::to_dep_node(k);\n+        self.graph.read(dep_node);\n+    }\n+\n+    /// Registers a (synthetic) write to the key `k`. Usually this is\n+    /// invoked automatically by `insert`.\n+    fn write(&self, k: &M::Key) {\n+        let dep_node = M::to_dep_node(k);\n+        self.graph.write(dep_node);\n+    }\n+\n+    pub fn get(&self, k: &M::Key) -> Option<&M::Value> {\n+        self.read(k);\n+        self.map.get(k)\n+    }\n+\n+    pub fn insert(&mut self, k: M::Key, v: M::Value) -> Option<M::Value> {\n+        self.write(&k);\n+        self.map.insert(k, v)\n+    }\n+\n+    pub fn contains_key(&self, k: &M::Key) -> bool {\n+        self.read(k);\n+        self.map.contains_key(k)\n+    }\n+}\n+\n+impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n+    type Key = M::Key;\n+    type Value = M::Value;\n+\n+    /// Memoizes an entry in the dep-tracking-map. If the entry is not\n+    /// already present, then `op` will be executed to compute its value.\n+    /// The resulting dependency graph looks like this:\n+    ///\n+    ///     [op] -> Map(key) -> CurrentTask\n+    ///\n+    /// Here, `[op]` represents whatever nodes `op` reads in the\n+    /// course of execution; `Map(key)` represents the node for this\n+    /// map; and `CurrentTask` represents the current task when\n+    /// `memoize` is invoked.\n+    ///\n+    /// **Important:* when `op` is invoked, the current task will be\n+    /// switched to `Map(key)`. Therefore, if `op` makes use of any\n+    /// HIR nodes or shared state accessed through its closure\n+    /// environment, it must explicitly register a read of that\n+    /// state. As an example, see `type_scheme_of_item` in `collect`,\n+    /// which looks something like this:\n+    ///\n+    /// ```\n+    /// fn type_scheme_of_item(..., item: &hir::Item) -> ty::TypeScheme<'tcx> {\n+    ///     let item_def_id = ccx.tcx.map.local_def_id(it.id);\n+    ///     ccx.tcx.tcache.memoized(item_def_id, || {\n+    ///         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id)); // (*)\n+    ///         compute_type_scheme_of_item(ccx, item)\n+    ///     });\n+    /// }\n+    /// ```\n+    ///\n+    /// The key is the line marked `(*)`: the closure implicitly\n+    /// accesses the body of the item `item`, so we register a read\n+    /// from `Hir(item_def_id)`.\n+    fn memoize<OP>(&self, key: M::Key, op: OP) -> M::Value\n+        where OP: FnOnce() -> M::Value\n+    {\n+        let graph;\n+        {\n+            let this = self.borrow();\n+            if let Some(result) = this.map.get(&key) {\n+                this.read(&key);\n+                return result.clone();\n+            }\n+            graph = this.graph.clone();\n+        }\n+\n+        let _task = graph.in_task(M::to_dep_node(&key));\n+        let result = op();\n+        self.borrow_mut().map.insert(key, result.clone());\n+        result\n+    }\n+}\n+\n+impl<'k, M: DepTrackingMapConfig> Index<&'k M::Key> for DepTrackingMap<M> {\n+    type Output = M::Value;\n+\n+    #[inline]\n+    fn index(&self, k: &'k M::Key) -> &M::Value {\n+        self.get(k).unwrap()\n+    }\n+}\n+"}, {"sha": "4b25285c476c463e9c9de8e38418570e181e74f5", "filename": "src/librustc/dep_graph/edges.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,162 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n+use super::{DepGraphQuery, DepNode};\n+\n+pub struct DepGraphEdges {\n+    nodes: Vec<DepNode>,\n+    indices: FnvHashMap<DepNode, IdIndex>,\n+    edges: FnvHashSet<(IdIndex, IdIndex)>,\n+    open_nodes: Vec<OpenNode>,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+struct IdIndex {\n+    index: u32\n+}\n+\n+impl IdIndex {\n+    fn new(v: usize) -> IdIndex {\n+        assert!((v & 0xFFFF_FFFF) == v);\n+        IdIndex { index: v as u32 }\n+    }\n+\n+    fn index(self) -> usize {\n+        self.index as usize\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+enum OpenNode {\n+    Node(IdIndex),\n+    Ignore,\n+}\n+\n+impl DepGraphEdges {\n+    pub fn new() -> DepGraphEdges {\n+        DepGraphEdges {\n+            nodes: vec![],\n+            indices: FnvHashMap(),\n+            edges: FnvHashSet(),\n+            open_nodes: Vec::new()\n+        }\n+    }\n+\n+    fn id(&self, index: IdIndex) -> DepNode {\n+        self.nodes[index.index()]\n+    }\n+\n+    /// Creates a node for `id` in the graph.\n+    fn make_node(&mut self, id: DepNode) -> IdIndex {\n+        if let Some(&i) = self.indices.get(&id) {\n+            return i;\n+        }\n+\n+        let index = IdIndex::new(self.nodes.len());\n+        self.nodes.push(id.clone());\n+        self.indices.insert(id, index);\n+        index\n+    }\n+\n+    /// Top of the stack of open nodes.\n+    fn current_node(&self) -> Option<OpenNode> {\n+        self.open_nodes.last().cloned()\n+    }\n+\n+    pub fn push_ignore(&mut self) {\n+        self.open_nodes.push(OpenNode::Ignore);\n+    }\n+\n+    pub fn pop_ignore(&mut self) {\n+        let popped_node = self.open_nodes.pop().unwrap();\n+        assert_eq!(popped_node, OpenNode::Ignore);\n+    }\n+\n+    pub fn push_task(&mut self, key: DepNode) {\n+        let top_node = self.current_node();\n+\n+        let new_node = self.make_node(key);\n+        self.open_nodes.push(OpenNode::Node(new_node));\n+\n+        // if we are in the midst of doing task T, then this new task\n+        // N is a subtask of T, so add an edge N -> T.\n+        if let Some(top_node) = top_node {\n+            self.add_edge_from_open_node(top_node, |t| (new_node, t));\n+        }\n+    }\n+\n+    pub fn pop_task(&mut self, key: DepNode) {\n+        let popped_node = self.open_nodes.pop().unwrap();\n+        assert_eq!(OpenNode::Node(self.indices[&key]), popped_node);\n+    }\n+\n+    /// Indicates that the current task `C` reads `v` by adding an\n+    /// edge from `v` to `C`. If there is no current task, panics. If\n+    /// you want to suppress this edge, use `ignore`.\n+    pub fn read(&mut self, v: DepNode) {\n+        let source = self.make_node(v);\n+        self.add_edge_from_current_node(|current| (source, current))\n+    }\n+\n+    /// Indicates that the current task `C` writes `v` by adding an\n+    /// edge from `C` to `v`. If there is no current task, panics. If\n+    /// you want to suppress this edge, use `ignore`.\n+    pub fn write(&mut self, v: DepNode) {\n+        let target = self.make_node(v);\n+        self.add_edge_from_current_node(|current| (current, target))\n+    }\n+\n+    /// Invoke `add_edge_from_open_node` with the top of the stack, or\n+    /// panic if stack is empty.\n+    fn add_edge_from_current_node<OP>(&mut self,\n+                                      op: OP)\n+        where OP: FnOnce(IdIndex) -> (IdIndex, IdIndex)\n+    {\n+        match self.current_node() {\n+            Some(open_node) => self.add_edge_from_open_node(open_node, op),\n+            None => panic!(\"no current node, cannot add edge into dependency graph\")\n+        }\n+    }\n+\n+    /// Adds an edge to or from the `open_node`, assuming `open_node`\n+    /// is not `Ignore`. The direction of the edge is determined by\n+    /// the closure `op` --- we pass as argument the open node `n`,\n+    /// and the closure returns a (source, target) tuple, which should\n+    /// include `n` in one spot or another.\n+    fn add_edge_from_open_node<OP>(&mut self,\n+                                   open_node: OpenNode,\n+                                   op: OP)\n+        where OP: FnOnce(IdIndex) -> (IdIndex, IdIndex)\n+    {\n+        let (source, target) = match open_node {\n+            OpenNode::Node(n) => op(n),\n+            OpenNode::Ignore => { return; }\n+        };\n+\n+        // ignore trivial self edges, which are not very interesting\n+        if source == target {\n+            return;\n+        }\n+\n+        if self.edges.insert((source, target)) {\n+            debug!(\"adding edge from {:?} to {:?}\",\n+                   self.id(source),\n+                   self.id(target));\n+        }\n+    }\n+\n+    pub fn query(&self) -> DepGraphQuery {\n+        let edges: Vec<_> = self.edges.iter()\n+                                      .map(|&(i, j)| (self.id(i), self.id(j)))\n+                                      .collect();\n+        DepGraphQuery::new(&self.nodes, &edges)\n+    }\n+}"}, {"sha": "9bf0a79115e78f4ebe8cd388ca272c209064ae1d", "filename": "src/librustc/dep_graph/mod.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,196 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self::thread::{DepGraphThreadData, DepMessage};\n+use middle::def_id::DefId;\n+use middle::ty;\n+use middle::ty::fast_reject::SimplifiedType;\n+use rustc_front::hir;\n+use rustc_front::intravisit::Visitor;\n+use std::rc::Rc;\n+\n+mod dep_tracking_map;\n+mod edges;\n+mod query;\n+mod raii;\n+mod thread;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum DepNode {\n+    // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n+    // distinct from the krate module). This is basically a hash of\n+    // the entire krate, so if you read from `Krate` (e.g., by calling\n+    // `tcx.map.krate()`), we will have to assume that any change\n+    // means that you need to be recompiled. This is because the\n+    // `Krate` value gives you access to all other items. To avoid\n+    // this fate, do not call `tcx.map.krate()`; instead, prefer\n+    // wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n+    // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n+    // access to the krate, but you must remember to add suitable\n+    // edges yourself for the individual items that you read.\n+    Krate,\n+\n+    // Represents the HIR node with the given node-id\n+    Hir(DefId),\n+\n+    // Represents different phases in the compiler.\n+    CollectItem(DefId),\n+    Coherence,\n+    CoherenceCheckImpl(DefId),\n+    CoherenceOverlapCheck(DefId),\n+    CoherenceOverlapCheckSpecial(DefId),\n+    CoherenceOrphanCheck(DefId),\n+    Variance,\n+    WfCheck(DefId),\n+    TypeckItemType(DefId),\n+    TypeckItemBody(DefId),\n+    Dropck,\n+    DropckImpl(DefId),\n+    CheckConst(DefId),\n+    Privacy,\n+    IntrinsicCheck(DefId),\n+    MatchCheck(DefId),\n+    MirMapConstruction(DefId),\n+    BorrowCheck(DefId),\n+    RvalueCheck(DefId),\n+    Reachability,\n+    DeadCheck,\n+    StabilityCheck,\n+    LateLintCheck,\n+    IntrinsicUseCheck,\n+    TransCrate,\n+    TransCrateItem(DefId),\n+    TransInlinedItem(DefId),\n+    TransWriteMetadata,\n+\n+    // Nodes representing bits of computed IR in the tcx. Each shared\n+    // table in the tcx (or elsewhere) maps to one of these\n+    // nodes. Often we map multiple tables to the same node if there\n+    // is no point in distinguishing them (e.g., both the type and\n+    // predicates for an item wind up in `ItemSignature`). Other\n+    // times, such as `ImplItems` vs `TraitItemDefIds`, tables which\n+    // might be mergable are kept distinct because the sets of def-ids\n+    // to which they apply are disjoint, and hence we might as well\n+    // have distinct labels for easier debugging.\n+    ImplOrTraitItems(DefId),\n+    ItemSignature(DefId),\n+    FieldTy(DefId),\n+    TraitItemDefIds(DefId),\n+    InherentImpls(DefId),\n+    ImplItems(DefId),\n+\n+    // The set of impls for a given trait. Ultimately, it would be\n+    // nice to get more fine-grained here (e.g., to include a\n+    // simplified type), but we can't do that until we restructure the\n+    // HIR to distinguish the *header* of an impl from its body.  This\n+    // is because changes to the header may change the self-type of\n+    // the impl and hence would require us to be more conservative\n+    // than changes in the impl body.\n+    TraitImpls(DefId),\n+\n+    // Nodes representing caches. To properly handle a true cache, we\n+    // don't use a DepTrackingMap, but rather we push a task node.\n+    // Otherwise the write into the map would be incorrectly\n+    // attributed to the first task that happened to fill the cache,\n+    // which would yield an overly conservative dep-graph.\n+    TraitItems(DefId),\n+    ReprHints(DefId),\n+    TraitSelect(DefId, Option<SimplifiedType>),\n+}\n+\n+#[derive(Clone)]\n+pub struct DepGraph {\n+    data: Rc<DepGraphThreadData>\n+}\n+\n+impl DepGraph {\n+    pub fn new(enabled: bool) -> DepGraph {\n+        DepGraph {\n+            data: Rc::new(DepGraphThreadData::new(enabled))\n+        }\n+    }\n+\n+    pub fn query(&self) -> DepGraphQuery {\n+        self.data.query()\n+    }\n+\n+    pub fn in_ignore<'graph>(&'graph self) -> raii::IgnoreTask<'graph> {\n+        raii::IgnoreTask::new(&self.data)\n+    }\n+\n+    pub fn in_task<'graph>(&'graph self, key: DepNode) -> raii::DepTask<'graph> {\n+        raii::DepTask::new(&self.data, key)\n+    }\n+\n+    pub fn with_ignore<OP,R>(&self, op: OP) -> R\n+        where OP: FnOnce() -> R\n+    {\n+        let _task = self.in_ignore();\n+        op()\n+    }\n+\n+    pub fn with_task<OP,R>(&self, key: DepNode, op: OP) -> R\n+        where OP: FnOnce() -> R\n+    {\n+        let _task = self.in_task(key);\n+        op()\n+    }\n+\n+    pub fn read(&self, v: DepNode) {\n+        self.data.enqueue(DepMessage::Read(v));\n+    }\n+\n+    pub fn write(&self, v: DepNode) {\n+        self.data.enqueue(DepMessage::Write(v));\n+    }\n+}\n+\n+pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n+\n+pub use self::query::DepGraphQuery;\n+\n+/// Visit all the items in the krate in some order. When visiting a\n+/// particular item, first create a dep-node by calling `dep_node_fn`\n+/// and push that onto the dep-graph stack of tasks, and also create a\n+/// read edge from the corresponding AST node. This is used in\n+/// compiler passes to automatically record the item that they are\n+/// working on.\n+pub fn visit_all_items_in_krate<'tcx,V,F>(tcx: &ty::ctxt<'tcx>,\n+                                          mut dep_node_fn: F,\n+                                          visitor: &mut V)\n+    where F: FnMut(DefId) -> DepNode, V: Visitor<'tcx>\n+{\n+    struct TrackingVisitor<'visit, 'tcx: 'visit, F: 'visit, V: 'visit> {\n+        tcx: &'visit ty::ctxt<'tcx>,\n+        dep_node_fn: &'visit mut F,\n+        visitor: &'visit mut V\n+    }\n+\n+    impl<'visit, 'tcx, F, V> Visitor<'tcx> for TrackingVisitor<'visit, 'tcx, F, V>\n+        where F: FnMut(DefId) -> DepNode, V: Visitor<'tcx>\n+    {\n+        fn visit_item(&mut self, i: &'tcx hir::Item) {\n+            let item_def_id = self.tcx.map.local_def_id(i.id);\n+            let task_id = (self.dep_node_fn)(item_def_id);\n+            debug!(\"About to start task {:?}\", task_id);\n+            let _task = self.tcx.dep_graph.in_task(task_id);\n+            self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n+            self.visitor.visit_item(i)\n+        }\n+    }\n+\n+    let krate = tcx.dep_graph.with_ignore(|| tcx.map.krate());\n+    let mut tracking_visitor = TrackingVisitor {\n+        tcx: tcx,\n+        dep_node_fn: &mut dep_node_fn,\n+        visitor: visitor\n+    };\n+    krate.visit_all_items(&mut tracking_visitor)\n+}"}, {"sha": "74a054acb4fa05c98aabf3c5a4afab035626ce3e", "filename": "src/librustc/dep_graph/query.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::graph::{Graph, NodeIndex};\n+\n+use super::DepNode;\n+\n+pub struct DepGraphQuery {\n+    pub graph: Graph<DepNode, ()>,\n+    pub indices: FnvHashMap<DepNode, NodeIndex>,\n+}\n+\n+impl DepGraphQuery {\n+    pub fn new(nodes: &[DepNode], edges: &[(DepNode, DepNode)]) -> DepGraphQuery {\n+        let mut graph = Graph::new();\n+        let mut indices = FnvHashMap();\n+        for node in nodes {\n+            indices.insert(node.clone(), graph.next_node_index());\n+            graph.add_node(node.clone());\n+        }\n+\n+        for &(ref source, ref target) in edges {\n+            let source = indices[source];\n+            let target = indices[target];\n+            graph.add_edge(source, target, ());\n+        }\n+\n+        DepGraphQuery {\n+            graph: graph,\n+            indices: indices\n+        }\n+    }\n+\n+    pub fn nodes(&self) -> Vec<DepNode> {\n+        self.graph.all_nodes()\n+                  .iter()\n+                  .map(|n| n.data.clone())\n+                  .collect()\n+    }\n+\n+    pub fn edges(&self) -> Vec<(DepNode,DepNode)> {\n+        self.graph.all_edges()\n+                  .iter()\n+                  .map(|edge| (edge.source(), edge.target()))\n+                  .map(|(s, t)| (self.graph.node_data(s).clone(), self.graph.node_data(t).clone()))\n+                  .collect()\n+    }\n+\n+    /// All nodes reachable from `node`. In other words, things that\n+    /// will have to be recomputed if `node` changes.\n+    pub fn dependents(&self, node: DepNode) -> Vec<DepNode> {\n+        if let Some(&index) = self.indices.get(&node) {\n+            self.graph.depth_traverse(index)\n+                      .map(|dependent_node| self.graph.node_data(dependent_node).clone())\n+                      .collect()\n+        } else {\n+            vec![]\n+        }\n+    }\n+}"}, {"sha": "dd7ff92f9c360d2b9d2d878a0bc272258c81b9ed", "filename": "src/librustc/dep_graph/raii.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::DepNode;\n+use super::thread::{DepGraphThreadData, DepMessage};\n+\n+pub struct DepTask<'graph> {\n+    data: &'graph DepGraphThreadData,\n+    key: DepNode,\n+}\n+\n+impl<'graph> DepTask<'graph> {\n+    pub fn new(data: &'graph DepGraphThreadData, key: DepNode) -> DepTask<'graph> {\n+        data.enqueue(DepMessage::PushTask(key));\n+        DepTask { data: data, key: key }\n+    }\n+}\n+\n+impl<'graph> Drop for DepTask<'graph> {\n+    fn drop(&mut self) {\n+        self.data.enqueue(DepMessage::PopTask(self.key));\n+    }\n+}\n+\n+pub struct IgnoreTask<'graph> {\n+    data: &'graph DepGraphThreadData\n+}\n+\n+impl<'graph> IgnoreTask<'graph> {\n+    pub fn new(data: &'graph DepGraphThreadData) -> IgnoreTask<'graph> {\n+        data.enqueue(DepMessage::PushIgnore);\n+        IgnoreTask { data: data }\n+    }\n+}\n+\n+impl<'graph> Drop for IgnoreTask<'graph> {\n+    fn drop(&mut self) {\n+        self.data.enqueue(DepMessage::PopIgnore);\n+    }\n+}"}, {"sha": "dbc57605d71aef52cc5265fbd19882965503c4e0", "filename": "src/librustc/dep_graph/thread.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Manages the communication between the compiler's main thread and\n+//! the thread that constructs the dependency graph. The basic idea is\n+//! to use double buffering to lower the cost of producing a message.\n+//! In the compiler thread, we accumulate messages in a vector until\n+//! the vector is full, or until we want to query the graph, and then\n+//! we send that vector over to the depgraph thread. At the same time,\n+//! we receive an empty vector from the depgraph thread that we can use\n+//! to accumulate more messages. This way we only ever have two vectors\n+//! allocated (and both have a fairly large capacity).\n+\n+use rustc_data_structures::veccell::VecCell;\n+use std::sync::mpsc::{self, Sender, Receiver};\n+use std::thread;\n+\n+use super::DepGraphQuery;\n+use super::DepNode;\n+use super::edges::DepGraphEdges;\n+\n+pub enum DepMessage {\n+    Read(DepNode),\n+    Write(DepNode),\n+    PushTask(DepNode),\n+    PopTask(DepNode),\n+    PushIgnore,\n+    PopIgnore,\n+    Query,\n+}\n+\n+pub struct DepGraphThreadData {\n+    enabled: bool,\n+\n+    // current buffer, where we accumulate messages\n+    messages: VecCell<DepMessage>,\n+\n+    // whence to receive new buffer when full\n+    swap_in: Receiver<Vec<DepMessage>>,\n+\n+    // where to send buffer when full\n+    swap_out: Sender<Vec<DepMessage>>,\n+\n+    // where to receive query results\n+    query_in: Receiver<DepGraphQuery>,\n+}\n+\n+const INITIAL_CAPACITY: usize = 2048;\n+\n+impl DepGraphThreadData {\n+    pub fn new(enabled: bool) -> DepGraphThreadData {\n+        let (tx1, rx1) = mpsc::channel();\n+        let (tx2, rx2) = mpsc::channel();\n+        let (txq, rxq) = mpsc::channel();\n+        if enabled {\n+            thread::spawn(move || main(rx1, tx2, txq));\n+        }\n+        DepGraphThreadData {\n+            enabled: enabled,\n+            messages: VecCell::with_capacity(INITIAL_CAPACITY),\n+            swap_in: rx2,\n+            swap_out: tx1,\n+            query_in: rxq,\n+        }\n+    }\n+\n+    /// Sends the current batch of messages to the thread. Installs a\n+    /// new vector of messages.\n+    fn swap(&self) {\n+        assert!(self.enabled, \"should never swap if not enabled\");\n+\n+        // should be a buffer waiting for us (though of course we may\n+        // have to wait for depgraph thread to finish processing the\n+        // old messages)\n+        let new_messages = self.swap_in.recv().unwrap();\n+        assert!(new_messages.is_empty());\n+\n+        // swap in the empty buffer and extract the full one\n+        let old_messages = self.messages.swap(new_messages);\n+\n+        // send full buffer to depgraph thread to be processed\n+        self.swap_out.send(old_messages).unwrap();\n+    }\n+\n+    pub fn query(&self) -> DepGraphQuery {\n+        assert!(self.enabled, \"cannot query if dep graph construction not enabled\");\n+        self.enqueue(DepMessage::Query);\n+        self.swap();\n+        self.query_in.recv().unwrap()\n+    }\n+\n+    /// Enqueue a message to be sent when things are next swapped. (If\n+    /// the buffer is full, this may swap.)\n+    #[inline]\n+    pub fn enqueue(&self, message: DepMessage) {\n+        if self.enabled {\n+            let len = self.messages.push(message);\n+            if len == INITIAL_CAPACITY {\n+                self.swap();\n+            }\n+        }\n+    }\n+}\n+\n+/// Definition of the depgraph thread.\n+pub fn main(swap_in: Receiver<Vec<DepMessage>>,\n+            swap_out: Sender<Vec<DepMessage>>,\n+            query_out: Sender<DepGraphQuery>) {\n+    let mut edges = DepGraphEdges::new();\n+\n+    // the compiler thread always expects a fresh buffer to be\n+    // waiting, so queue one up\n+    swap_out.send(Vec::with_capacity(INITIAL_CAPACITY)).unwrap();\n+\n+    // process the buffers from compiler thread as we receive them\n+    for mut messages in swap_in {\n+        for msg in messages.drain(..) {\n+            match msg {\n+                DepMessage::Read(node) => edges.read(node),\n+                DepMessage::Write(node) => edges.write(node),\n+                DepMessage::PushTask(node) => edges.push_task(node),\n+                DepMessage::PopTask(node) => edges.pop_task(node),\n+                DepMessage::PushIgnore => edges.push_ignore(),\n+                DepMessage::PopIgnore => edges.pop_ignore(),\n+                DepMessage::Query => query_out.send(edges.query()).unwrap(),\n+            }\n+        }\n+        swap_out.send(messages).unwrap();\n+    }\n+}"}, {"sha": "f84d5fbaf81dd6090e2c1f4ad7b5a559b48a0ce7", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -87,6 +87,8 @@ pub mod back {\n     pub use rustc_back::svh;\n }\n \n+pub mod dep_graph;\n+\n pub mod front {\n     pub mod check_attr;\n     pub mod map;"}, {"sha": "0ac5160c29e25c2b01d7173bb90d03cecee7cf40", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -25,6 +25,7 @@\n //! for all lint attributes.\n use self::TargetLint::*;\n \n+use dep_graph::DepNode;\n use middle::privacy::AccessLevels;\n use middle::ty;\n use session::{early_error, Session};\n@@ -1071,6 +1072,8 @@ impl LateLintPass for GatherNodeLevels {\n ///\n /// Consumes the `lint_store` field of the `Session`.\n pub fn check_crate(tcx: &ty::ctxt, access_levels: &AccessLevels) {\n+    let _task = tcx.dep_graph.in_task(DepNode::LateLintCheck);\n+\n     let krate = tcx.map.krate();\n     let mut cx = LateContext::new(tcx, krate, access_levels);\n "}, {"sha": "a9b3043e0909569e72558d3bab10e7ddba2598bd", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -24,6 +24,7 @@\n // - It's not possible to take the address of a static item with unsafe interior. This is enforced\n // by borrowck::gather_loans\n \n+use dep_graph::DepNode;\n use middle::ty::cast::{CastKind};\n use middle::const_eval::{self, ConstEvalErr};\n use middle::const_eval::ErrKind::IndexOpFeatureGated;\n@@ -842,13 +843,12 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {\n-    tcx.map.krate().visit_all_items(&mut CheckCrateVisitor {\n+    tcx.visit_all_items_in_krate(DepNode::CheckConst, &mut CheckCrateVisitor {\n         tcx: tcx,\n         mode: Mode::Var,\n         qualif: ConstQualif::NOT_CONST,\n         rvalue_borrows: NodeMap()\n     });\n-\n     tcx.sess.abort_if_errors();\n }\n "}, {"sha": "972f9e2c64d0e195aa8b33d4ee2eb15cf8cf53c5", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -12,6 +12,7 @@ pub use self::Constructor::*;\n use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n+use dep_graph::DepNode;\n use middle::const_eval::{compare_const_vals, ConstVal};\n use middle::const_eval::{eval_const_expr, eval_const_expr_partial};\n use middle::const_eval::{const_expr_to_pat, lookup_const_by_id};\n@@ -155,7 +156,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt) {\n-    tcx.map.krate().visit_all_items(&mut MatchCheckCtxt {\n+    tcx.visit_all_items_in_krate(DepNode::MatchCheck, &mut MatchCheckCtxt {\n         tcx: tcx,\n         param_env: tcx.empty_parameter_environment(),\n     });"}, {"sha": "8a3e039ac6e535cc2fcc2d514d449b22b8d0f465", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -11,21 +11,21 @@\n // Checks that all rvalues in a crate have statically known size. check_crate\n // is the public starting point.\n \n+use dep_graph::DepNode;\n use middle::expr_use_visitor as euv;\n use middle::infer;\n use middle::mem_categorization as mc;\n use middle::ty::ParameterEnvironment;\n use middle::ty;\n \n-use syntax::ast;\n use rustc_front::hir;\n-use syntax::codemap::Span;\n use rustc_front::intravisit;\n+use syntax::ast;\n+use syntax::codemap::Span;\n \n-pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &hir::Crate) {\n+pub fn check_crate(tcx: &ty::ctxt) {\n     let mut rvcx = RvalueContext { tcx: tcx };\n-    krate.visit_all_items(&mut rvcx);\n+    tcx.visit_all_items_in_krate(DepNode::RvalueCheck, &mut rvcx);\n }\n \n struct RvalueContext<'a, 'tcx: 'a> {"}, {"sha": "1386ef91c70bf49e0ec7209f2252cbd9cb1bbcfa", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -12,6 +12,7 @@\n // closely. The idea is that all reachable symbols are live, codes called\n // from live codes are live, and everything else is dead.\n \n+use dep_graph::DepNode;\n use front::map as ast_map;\n use rustc_front::hir;\n use rustc_front::intravisit::{self, Visitor};\n@@ -590,6 +591,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n }\n \n pub fn check_crate(tcx: &ty::ctxt, access_levels: &privacy::AccessLevels) {\n+    let _task = tcx.dep_graph.in_task(DepNode::DeadCheck);\n     let krate = tcx.map.krate();\n     let live_symbols = find_live(tcx, access_levels, krate);\n     let mut visitor = DeadVisitor { tcx: tcx, live_symbols: live_symbols };"}, {"sha": "23d1617e5c658e39ee93d285a5b2bdcde6b94efb", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -274,7 +274,7 @@ enum PassArgs {\n }\n \n impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n-    pub fn new(delegate: &'d mut (Delegate<'tcx>),\n+    pub fn new(delegate: &'d mut (Delegate<'tcx>+'d),\n                typer: &'t infer::InferCtxt<'a, 'tcx>)\n                -> ExprUseVisitor<'d,'t,'a,'tcx> where 'tcx:'a+'d\n     {"}, {"sha": "f1eed256dd156be3cc0e7eb45b608f43ae5e70ec", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use dep_graph::DepNode;\n use middle::def::DefFn;\n use middle::def_id::DefId;\n use middle::subst::{Subst, Substs, EnumeratedItems};\n@@ -29,7 +30,7 @@ pub fn check_crate(tcx: &ctxt) {\n         dummy_sized_ty: tcx.types.isize,\n         dummy_unsized_ty: tcx.mk_slice(tcx.types.isize),\n     };\n-    tcx.map.krate().visit_all_items(&mut visitor);\n+    tcx.visit_all_items_in_krate(DepNode::IntrinsicCheck, &mut visitor);\n }\n \n struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {"}, {"sha": "738440adf416d9280ff08a92a998db81e66c4f87", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -15,6 +15,7 @@\n // makes all other generics or inline functions that it references\n // reachable as well.\n \n+use dep_graph::DepNode;\n use front::map as ast_map;\n use middle::def;\n use middle::def_id::DefId;\n@@ -349,6 +350,7 @@ impl<'a, 'v> Visitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n pub fn find_reachable(tcx: &ty::ctxt,\n                       access_levels: &privacy::AccessLevels)\n                       -> NodeSet {\n+    let _task = tcx.dep_graph.in_task(DepNode::Reachability);\n \n     let mut reachable_context = ReachableContext::new(tcx);\n "}, {"sha": "8d5c0c98885b2e77e05418050ee1ff6f060d3069", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -13,6 +13,7 @@\n \n pub use self::StabilityLevel::*;\n \n+use dep_graph::DepNode;\n use session::Session;\n use lint;\n use middle::cstore::{CrateStore, LOCAL_CRATE};\n@@ -328,6 +329,7 @@ impl<'tcx> Index<'tcx> {\n /// features used.\n pub fn check_unstable_api_usage(tcx: &ty::ctxt)\n                                 -> FnvHashMap<InternedString, StabilityLevel> {\n+    let _task = tcx.dep_graph.in_task(DepNode::StabilityCheck);\n     let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n \n     // Put the active features into a map for quick lookup\n@@ -341,8 +343,7 @@ pub fn check_unstable_api_usage(tcx: &ty::ctxt)\n     };\n     intravisit::walk_crate(&mut checker, tcx.map.krate());\n \n-    let used_features = checker.used_features;\n-    return used_features;\n+    checker.used_features\n }\n \n struct Checker<'a, 'tcx: 'a> {"}, {"sha": "dddd6f8bc85d790dd19c404e2d74f2de46a17e00", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -15,10 +15,12 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n \n+use dep_graph::DepNode;\n use middle::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use middle::subst;\n use middle::ty::{self, HasTypeFlags, Ty};\n+use middle::ty::fast_reject;\n use middle::ty::fold::TypeFoldable;\n use middle::infer::{self, fixup_err_to_string, InferCtxt};\n \n@@ -599,6 +601,18 @@ impl<'tcx> FulfillmentError<'tcx> {\n }\n \n impl<'tcx> TraitObligation<'tcx> {\n+    /// Creates the dep-node for selecting/evaluating this trait reference.\n+    fn dep_node(&self, tcx: &ty::ctxt<'tcx>) -> DepNode {\n+        let simplified_ty =\n+            fast_reject::simplify_type(tcx,\n+                                       self.predicate.skip_binder().self_ty(), // (*)\n+                                       true);\n+\n+        // (*) skip_binder is ok because `simplify_type` doesn't care about regions\n+\n+        DepNode::TraitSelect(self.predicate.def_id(), simplified_ty)\n+    }\n+\n     fn self_ty(&self) -> ty::Binder<Ty<'tcx>> {\n         ty::Binder(self.predicate.skip_binder().self_ty())\n     }"}, {"sha": "bd92f9748669f8fee6f6aab97a4b27efe337cd0c", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -310,6 +310,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"select({:?})\", obligation);\n         assert!(!obligation.predicate.has_escaping_regions());\n \n+        let dep_node = obligation.dep_node(self.tcx());\n+        let _task = self.tcx().dep_graph.in_task(dep_node);\n+\n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n         match try!(self.candidate_from_obligation(&stack)) {\n             None => {\n@@ -411,7 +414,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// accurate if inference variables are involved.\n     pub fn evaluate_obligation_conservatively(&mut self,\n                                               obligation: &PredicateObligation<'tcx>)\n-                               -> bool\n+                                              -> bool\n     {\n         debug!(\"evaluate_obligation_conservatively({:?})\",\n                obligation);"}, {"sha": "619201a4a9feb016742b05116520c29ca9974f7d", "filename": "src/librustc/middle/ty/contents.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -10,7 +10,7 @@\n \n use middle::def_id::{DefId};\n use middle::ty::{self, Ty};\n-use util::common::{memoized};\n+use util::common::MemoizationMap;\n use util::nodemap::FnvHashMap;\n \n use std::fmt;\n@@ -141,9 +141,7 @@ impl fmt::Debug for TypeContents {\n \n impl<'tcx> ty::TyS<'tcx> {\n     pub fn type_contents(&'tcx self, cx: &ty::ctxt<'tcx>) -> TypeContents {\n-        return memoized(&cx.tc_cache, self, |ty| {\n-            tc_ty(cx, ty, &mut FnvHashMap())\n-        });\n+        return cx.tc_cache.memoize(self, || tc_ty(cx, self, &mut FnvHashMap()));\n \n         fn tc_ty<'tcx>(cx: &ty::ctxt<'tcx>,\n                        ty: Ty<'tcx>,"}, {"sha": "d1504d25288a8d93c4db24aee8e3ccdd5ed74006", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 78, "deletions": 29, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -13,6 +13,7 @@\n // FIXME: (@jroesch) @eddyb should remove this when he renames ctxt\n #![allow(non_camel_case_types)]\n \n+use dep_graph::{DepGraph, DepTrackingMap};\n use front::map as ast_map;\n use session::Session;\n use lint;\n@@ -29,10 +30,12 @@ use middle::traits;\n use middle::ty::{self, TraitRef, Ty, TypeAndMut};\n use middle::ty::{TyS, TypeVariants};\n use middle::ty::{AdtDef, ClosureSubsts, ExistentialBounds, Region};\n-use middle::ty::{FreevarMap, GenericPredicates};\n+use middle::ty::{FreevarMap};\n use middle::ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitTy};\n use middle::ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use middle::ty::TypeVariants::*;\n+use middle::ty::maps;\n+use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::FnvHashMap;\n \n@@ -224,6 +227,8 @@ pub struct ctxt<'tcx> {\n     region_interner: RefCell<FnvHashMap<&'tcx Region, &'tcx Region>>,\n     stability_interner: RefCell<FnvHashMap<&'tcx attr::Stability, &'tcx attr::Stability>>,\n \n+    pub dep_graph: DepGraph,\n+\n     /// Common types, pre-interned for your convenience.\n     pub types: CommonTypes<'tcx>,\n \n@@ -245,57 +250,77 @@ pub struct ctxt<'tcx> {\n     pub tables: RefCell<Tables<'tcx>>,\n \n     /// Maps from a trait item to the trait item \"descriptor\"\n-    pub impl_or_trait_items: RefCell<DefIdMap<ty::ImplOrTraitItem<'tcx>>>,\n+    pub impl_or_trait_items: RefCell<DepTrackingMap<maps::ImplOrTraitItems<'tcx>>>,\n \n     /// Maps from a trait def-id to a list of the def-ids of its trait items\n-    pub trait_item_def_ids: RefCell<DefIdMap<Rc<Vec<ty::ImplOrTraitItemId>>>>,\n+    pub trait_item_def_ids: RefCell<DepTrackingMap<maps::TraitItemDefIds<'tcx>>>,\n \n-    /// A cache for the trait_items() routine\n-    pub trait_items_cache: RefCell<DefIdMap<Rc<Vec<ty::ImplOrTraitItem<'tcx>>>>>,\n+    /// A cache for the trait_items() routine; note that the routine\n+    /// itself pushes the `TraitItems` dependency node.\n+    trait_items_cache: RefCell<DepTrackingMap<maps::TraitItems<'tcx>>>,\n \n-    pub impl_trait_refs: RefCell<DefIdMap<Option<TraitRef<'tcx>>>>,\n-    pub trait_defs: RefCell<DefIdMap<&'tcx ty::TraitDef<'tcx>>>,\n-    pub adt_defs: RefCell<DefIdMap<ty::AdtDefMaster<'tcx>>>,\n+    pub impl_trait_refs: RefCell<DepTrackingMap<maps::ImplTraitRefs<'tcx>>>,\n+    pub trait_defs: RefCell<DepTrackingMap<maps::TraitDefs<'tcx>>>,\n+    pub adt_defs: RefCell<DepTrackingMap<maps::AdtDefs<'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated predicates.\n-    pub predicates: RefCell<DefIdMap<GenericPredicates<'tcx>>>,\n+    pub predicates: RefCell<DepTrackingMap<maps::Predicates<'tcx>>>,\n \n     /// Maps from the def-id of a trait to the list of\n     /// super-predicates. This is a subset of the full list of\n     /// predicates. We store these in a separate map because we must\n     /// evaluate them even during type conversion, often before the\n     /// full predicates are available (note that supertraits have\n     /// additional acyclicity requirements).\n-    pub super_predicates: RefCell<DefIdMap<GenericPredicates<'tcx>>>,\n+    pub super_predicates: RefCell<DepTrackingMap<maps::Predicates<'tcx>>>,\n \n     pub map: ast_map::Map<'tcx>,\n+\n+    // Records the free variables refrenced by every closure\n+    // expression. Do not track deps for this, just recompute it from\n+    // scratch every time.\n     pub freevars: RefCell<FreevarMap>,\n-    pub tcache: RefCell<DefIdMap<ty::TypeScheme<'tcx>>>,\n+\n+    // Records the type of every item.\n+    pub tcache: RefCell<DepTrackingMap<maps::Tcache<'tcx>>>,\n+\n+    // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FnvHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n+\n+    // Cache for the type-contents routine. FIXME -- track deps?\n     pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n+\n+    // Cache for various types within a method body and so forth.\n+    //\n+    // FIXME this should be made local to typeck, but it is currently used by one lint\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n+\n+    // FIXME no dep tracking, but we should be able to remove this\n     pub ty_param_defs: RefCell<NodeMap<ty::TypeParameterDef<'tcx>>>,\n+\n+    // FIXME dep tracking -- should be harmless enough\n     pub normalized_cache: RefCell<FnvHashMap<Ty<'tcx>, Ty<'tcx>>>,\n+\n     pub lang_items: middle::lang_items::LanguageItems,\n \n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n-    pub item_variance_map: RefCell<DefIdMap<Rc<ty::ItemVariances>>>,\n+    pub item_variance_map: RefCell<DepTrackingMap<maps::ItemVariances<'tcx>>>,\n \n     /// True if the variance has been computed yet; false otherwise.\n     pub variance_computed: Cell<bool>,\n \n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n-    pub inherent_impls: RefCell<DefIdMap<Rc<Vec<DefId>>>>,\n+    pub inherent_impls: RefCell<DepTrackingMap<maps::InherentImpls<'tcx>>>,\n \n     /// Maps a DefId of an impl to a list of its items.\n     /// Note that this contains all of the impls that we know about,\n     /// including ones in other crates. It's not clear that this is the best\n     /// way to do it.\n-    pub impl_items: RefCell<DefIdMap<Vec<ty::ImplOrTraitItemId>>>,\n+    pub impl_items: RefCell<DepTrackingMap<maps::ImplItems<'tcx>>>,\n \n     /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     /// present in this set can be warned about.\n@@ -309,6 +334,7 @@ pub struct ctxt<'tcx> {\n     /// The set of external nominal types whose implementations have been read.\n     /// This is used for lazy resolution of methods.\n     pub populated_external_types: RefCell<DefIdSet>,\n+\n     /// The set of external primitive types whose implementations have been read.\n     /// FIXME(arielb1): why is this separate from populated_external_types?\n     pub populated_external_primitive_impls: RefCell<DefIdSet>,\n@@ -344,7 +370,7 @@ pub struct ctxt<'tcx> {\n     pub fulfilled_predicates: RefCell<traits::FulfilledPredicates<'tcx>>,\n \n     /// Caches the representation hints for struct definitions.\n-    pub repr_hint_cache: RefCell<DefIdMap<Rc<Vec<attr::ReprAttr>>>>,\n+    repr_hint_cache: RefCell<DepTrackingMap<maps::ReprHints<'tcx>>>,\n \n     /// Maps Expr NodeId's to their constant qualification.\n     pub const_qualif_map: RefCell<NodeMap<middle::check_const::ConstQualif>>,\n@@ -483,43 +509,44 @@ impl<'tcx> ctxt<'tcx> {\n     {\n         let interner = RefCell::new(FnvHashMap());\n         let common_types = CommonTypes::new(&arenas.type_, &interner);\n-\n+        let dep_graph = DepGraph::new(s.opts.incremental_compilation);\n         tls::enter(ctxt {\n             arenas: arenas,\n             interner: interner,\n             substs_interner: RefCell::new(FnvHashMap()),\n             bare_fn_interner: RefCell::new(FnvHashMap()),\n             region_interner: RefCell::new(FnvHashMap()),\n             stability_interner: RefCell::new(FnvHashMap()),\n+            dep_graph: dep_graph.clone(),\n             types: common_types,\n             named_region_map: named_region_map,\n             region_maps: region_maps,\n             free_region_maps: RefCell::new(FnvHashMap()),\n-            item_variance_map: RefCell::new(DefIdMap()),\n+            item_variance_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             variance_computed: Cell::new(false),\n             sess: s,\n             def_map: def_map,\n             tables: RefCell::new(Tables::empty()),\n-            impl_trait_refs: RefCell::new(DefIdMap()),\n-            trait_defs: RefCell::new(DefIdMap()),\n-            adt_defs: RefCell::new(DefIdMap()),\n-            predicates: RefCell::new(DefIdMap()),\n-            super_predicates: RefCell::new(DefIdMap()),\n+            impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            adt_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            super_predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             fulfilled_predicates: RefCell::new(traits::FulfilledPredicates::new()),\n             map: map,\n             freevars: RefCell::new(freevars),\n-            tcache: RefCell::new(DefIdMap()),\n+            tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rcache: RefCell::new(FnvHashMap()),\n             tc_cache: RefCell::new(FnvHashMap()),\n             ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n-            impl_or_trait_items: RefCell::new(DefIdMap()),\n-            trait_item_def_ids: RefCell::new(DefIdMap()),\n-            trait_items_cache: RefCell::new(DefIdMap()),\n+            impl_or_trait_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            trait_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            trait_items_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             ty_param_defs: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FnvHashMap()),\n             lang_items: lang_items,\n-            inherent_impls: RefCell::new(DefIdMap()),\n-            impl_items: RefCell::new(DefIdMap()),\n+            inherent_impls: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            impl_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),\n             used_mut_nodes: RefCell::new(NodeSet()),\n             populated_external_types: RefCell::new(DefIdSet()),\n@@ -531,7 +558,7 @@ impl<'tcx> ctxt<'tcx> {\n             stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n-            repr_hint_cache: RefCell::new(DefIdMap()),\n+            repr_hint_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             const_qualif_map: RefCell::new(NodeMap()),\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n             cast_kinds: RefCell::new(NodeMap()),\n@@ -1000,4 +1027,26 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn mk_param_from_def(&self, def: &ty::TypeParameterDef) -> Ty<'tcx> {\n         self.mk_param(def.space, def.index, def.name)\n     }\n+\n+    pub fn trait_items(&self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> {\n+        self.trait_items_cache.memoize(trait_did, || {\n+            let def_ids = self.trait_item_def_ids(trait_did);\n+            Rc::new(def_ids.iter()\n+                           .map(|d| self.impl_or_trait_item(d.def_id()))\n+                           .collect())\n+        })\n+    }\n+\n+    /// Obtain the representation annotation for a struct definition.\n+    pub fn lookup_repr_hints(&self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n+        self.repr_hint_cache.memoize(did, || {\n+            Rc::new(if did.is_local() {\n+                self.get_attrs(did).iter().flat_map(|meta| {\n+                    attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n+                }).collect()\n+            } else {\n+                self.sess.cstore.repr_attrs(did)\n+            })\n+        })\n+    }\n }"}, {"sha": "a06e8a72c44ee685b4588b622f4afa395e3d2f32", "filename": "src/librustc/middle/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ffast_reject.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -15,7 +15,7 @@ use syntax::ast;\n use self::SimplifiedType::*;\n \n /// See `simplify_type\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum SimplifiedType {\n     BoolSimplifiedType,\n     CharSimplifiedType,"}, {"sha": "ffc12aa5aea198e37dde94deefcd2b52df5de614", "filename": "src/librustc/middle/ty/ivar.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fty%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fty%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fivar.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use dep_graph::DepNode;\n use middle::ty::{Ty, TyS};\n+use middle::ty::tls;\n \n use rustc_data_structures::ivar;\n \n@@ -27,6 +29,10 @@ use core::nonzero::NonZero;\n ///     (B) no aliases to this value with a 'tcx longer than this\n ///         value's 'lt exist\n ///\n+/// Dependency tracking: each ivar does not know what node in the\n+/// dependency graph it is associated with, so when you get/fulfill\n+/// you must supply a `DepNode` id. This should always be the same id!\n+///\n /// NonZero is used rather than Unique because Unique isn't Copy.\n pub struct TyIVar<'tcx, 'lt: 'tcx>(ivar::Ivar<NonZero<*const TyS<'static>>>,\n                                    PhantomData<fn(TyS<'lt>)->TyS<'tcx>>);\n@@ -40,19 +46,28 @@ impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n     }\n \n     #[inline]\n-    pub fn get(&self) -> Option<Ty<'tcx>> {\n+    pub fn get(&self, dep_node: DepNode) -> Option<Ty<'tcx>> {\n+        tls::with(|tcx| tcx.dep_graph.read(dep_node));\n+        self.untracked_get()\n+    }\n+\n+    #[inline]\n+    fn untracked_get(&self) -> Option<Ty<'tcx>> {\n         match self.0.get() {\n             None => None,\n             // valid because of invariant (A)\n             Some(v) => Some(unsafe { &*(*v as *const TyS<'tcx>) })\n         }\n     }\n+\n     #[inline]\n-    pub fn unwrap(&self) -> Ty<'tcx> {\n-        self.get().unwrap()\n+    pub fn unwrap(&self, dep_node: DepNode) -> Ty<'tcx> {\n+        self.get(dep_node).unwrap()\n     }\n \n-    pub fn fulfill(&self, value: Ty<'lt>) {\n+    pub fn fulfill(&self, dep_node: DepNode, value: Ty<'lt>) {\n+        tls::with(|tcx| tcx.dep_graph.write(dep_node));\n+\n         // Invariant (A) is fulfilled, because by (B), every alias\n         // of this has a 'tcx longer than 'lt.\n         let value: *const TyS<'lt> = value;\n@@ -64,7 +79,7 @@ impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n \n impl<'tcx, 'lt> fmt::Debug for TyIVar<'tcx, 'lt> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.get() {\n+        match self.untracked_get() {\n             Some(val) => write!(f, \"TyIVar({:?})\", val),\n             None => f.write_str(\"TyIVar(<unfulfilled>)\")\n         }"}, {"sha": "7d5276f379ffe83050e23d4bf9d246ff4b1fc9d2", "filename": "src/librustc/middle/ty/maps.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmaps.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dep_graph::{DepNode, DepTrackingMapConfig};\n+use middle::def_id::DefId;\n+use middle::ty;\n+use std::marker::PhantomData;\n+use std::rc::Rc;\n+use syntax::attr;\n+\n+macro_rules! dep_map_ty {\n+    ($ty_name:ident : $node_name:ident ($key:ty) -> $value:ty) => {\n+        pub struct $ty_name<'tcx> {\n+            data: PhantomData<&'tcx ()>\n+        }\n+\n+        impl<'tcx> DepTrackingMapConfig for $ty_name<'tcx> {\n+            type Key = $key;\n+            type Value = $value;\n+            fn to_dep_node(key: &$key) -> DepNode { DepNode::$node_name(*key) }\n+        }\n+    }\n+}\n+\n+dep_map_ty! { ImplOrTraitItems: ImplOrTraitItems(DefId) -> ty::ImplOrTraitItem<'tcx> }\n+dep_map_ty! { Tcache: ItemSignature(DefId) -> ty::TypeScheme<'tcx> }\n+dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n+dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n+dep_map_ty! { TraitItemDefIds: TraitItemDefIds(DefId) -> Rc<Vec<ty::ImplOrTraitItemId>> }\n+dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n+dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n+dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n+dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<ty::ItemVariances> }\n+dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Rc<Vec<DefId>> }\n+dep_map_ty! { ImplItems: ImplItems(DefId) -> Vec<ty::ImplOrTraitItemId> }\n+dep_map_ty! { TraitItems: TraitItems(DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> }\n+dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }"}, {"sha": "2baf5c5145fcd71dcc5b10eccf0b8f0b3851c87a", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 47, "deletions": 206, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -18,6 +18,7 @@ pub use self::ImplOrTraitItem::*;\n pub use self::IntVarValue::*;\n pub use self::LvaluePreference::*;\n \n+use dep_graph::{self, DepNode};\n use front::map as ast_map;\n use front::map::LinkedPath;\n use middle;\n@@ -31,13 +32,13 @@ use middle::traits;\n use middle::ty;\n use middle::ty::fold::TypeFolder;\n use middle::ty::walk::TypeWalker;\n-use util::common::memoized;\n-use util::nodemap::{NodeMap, NodeSet, DefIdMap};\n+use util::common::MemoizationMap;\n+use util::nodemap::{NodeMap, NodeSet};\n use util::nodemap::FnvHashMap;\n \n use serialize::{Encodable, Encoder, Decodable, Decoder};\n use std::borrow::{Borrow, Cow};\n-use std::cell::{Cell, RefCell};\n+use std::cell::Cell;\n use std::hash::{Hash, Hasher};\n use std::iter;\n use std::rc::Rc;\n@@ -51,6 +52,7 @@ use syntax::parse::token::{InternedString, special_idents};\n \n use rustc_front::hir;\n use rustc_front::hir::{ItemImpl, ItemTrait};\n+use rustc_front::intravisit::Visitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n pub use self::sty::{BuiltinBound, BuiltinBounds, ExistentialBounds};\n@@ -75,14 +77,18 @@ pub use self::contents::TypeContents;\n pub use self::context::{ctxt, tls};\n pub use self::context::{CtxtArenas, Lift, Tables};\n \n+pub use self::trait_def::{TraitDef, TraitFlags};\n+\n pub mod adjustment;\n pub mod cast;\n pub mod error;\n pub mod fast_reject;\n pub mod fold;\n pub mod _match;\n+pub mod maps;\n pub mod outlives;\n pub mod relate;\n+pub mod trait_def;\n pub mod walk;\n pub mod wf;\n pub mod util;\n@@ -1317,161 +1323,6 @@ pub struct TypeScheme<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-bitflags! {\n-    flags TraitFlags: u32 {\n-        const NO_TRAIT_FLAGS        = 0,\n-        const HAS_DEFAULT_IMPL      = 1 << 0,\n-        const IS_OBJECT_SAFE        = 1 << 1,\n-        const OBJECT_SAFETY_VALID   = 1 << 2,\n-        const IMPLS_VALID           = 1 << 3,\n-    }\n-}\n-\n-/// As `TypeScheme` but for a trait ref.\n-pub struct TraitDef<'tcx> {\n-    pub unsafety: hir::Unsafety,\n-\n-    /// If `true`, then this trait had the `#[rustc_paren_sugar]`\n-    /// attribute, indicating that it should be used with `Foo()`\n-    /// sugar. This is a temporary thing -- eventually any trait wil\n-    /// be usable with the sugar (or without it).\n-    pub paren_sugar: bool,\n-\n-    /// Generic type definitions. Note that `Self` is listed in here\n-    /// as having a single bound, the trait itself (e.g., in the trait\n-    /// `Eq`, there is a single bound `Self : Eq`). This is so that\n-    /// default methods get to assume that the `Self` parameters\n-    /// implements the trait.\n-    pub generics: Generics<'tcx>,\n-\n-    pub trait_ref: TraitRef<'tcx>,\n-\n-    /// A list of the associated types defined in this trait. Useful\n-    /// for resolving `X::Foo` type markers.\n-    pub associated_type_names: Vec<Name>,\n-\n-    // Impls of this trait. To allow for quicker lookup, the impls are indexed\n-    // by a simplified version of their Self type: impls with a simplifiable\n-    // Self are stored in nonblanket_impls keyed by it, while all other impls\n-    // are stored in blanket_impls.\n-\n-    /// Impls of the trait.\n-    pub nonblanket_impls: RefCell<\n-        FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n-    >,\n-\n-    /// Blanket impls associated with the trait.\n-    pub blanket_impls: RefCell<Vec<DefId>>,\n-\n-    /// Various flags\n-    pub flags: Cell<TraitFlags>\n-}\n-\n-impl<'tcx> TraitDef<'tcx> {\n-    // returns None if not yet calculated\n-    pub fn object_safety(&self) -> Option<bool> {\n-        if self.flags.get().intersects(TraitFlags::OBJECT_SAFETY_VALID) {\n-            Some(self.flags.get().intersects(TraitFlags::IS_OBJECT_SAFE))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn set_object_safety(&self, is_safe: bool) {\n-        assert!(self.object_safety().map(|cs| cs == is_safe).unwrap_or(true));\n-        self.flags.set(\n-            self.flags.get() | if is_safe {\n-                TraitFlags::OBJECT_SAFETY_VALID | TraitFlags::IS_OBJECT_SAFE\n-            } else {\n-                TraitFlags::OBJECT_SAFETY_VALID\n-            }\n-        );\n-    }\n-\n-    /// Records a trait-to-implementation mapping.\n-    pub fn record_impl(&self,\n-                       tcx: &ctxt<'tcx>,\n-                       impl_def_id: DefId,\n-                       impl_trait_ref: TraitRef<'tcx>) {\n-        debug!(\"TraitDef::record_impl for {:?}, from {:?}\",\n-               self, impl_trait_ref);\n-\n-        // We don't want to borrow_mut after we already populated all impls,\n-        // so check if an impl is present with an immutable borrow first.\n-        if let Some(sty) = fast_reject::simplify_type(tcx,\n-                                                      impl_trait_ref.self_ty(), false) {\n-            if let Some(is) = self.nonblanket_impls.borrow().get(&sty) {\n-                if is.contains(&impl_def_id) {\n-                    return // duplicate - skip\n-                }\n-            }\n-\n-            self.nonblanket_impls.borrow_mut().entry(sty).or_insert(vec![]).push(impl_def_id)\n-        } else {\n-            if self.blanket_impls.borrow().contains(&impl_def_id) {\n-                return // duplicate - skip\n-            }\n-            self.blanket_impls.borrow_mut().push(impl_def_id)\n-        }\n-    }\n-\n-\n-    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &ctxt<'tcx>, mut f: F)  {\n-        tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n-\n-        for &impl_def_id in self.blanket_impls.borrow().iter() {\n-            f(impl_def_id);\n-        }\n-\n-        for v in self.nonblanket_impls.borrow().values() {\n-            for &impl_def_id in v {\n-                f(impl_def_id);\n-            }\n-        }\n-    }\n-\n-    /// Iterate over every impl that could possibly match the\n-    /// self-type `self_ty`.\n-    pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n-                                                   tcx: &ctxt<'tcx>,\n-                                                   self_ty: Ty<'tcx>,\n-                                                   mut f: F)\n-    {\n-        tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n-\n-        for &impl_def_id in self.blanket_impls.borrow().iter() {\n-            f(impl_def_id);\n-        }\n-\n-        // simplify_type(.., false) basically replaces type parameters and\n-        // projections with infer-variables. This is, of course, done on\n-        // the impl trait-ref when it is instantiated, but not on the\n-        // predicate trait-ref which is passed here.\n-        //\n-        // for example, if we match `S: Copy` against an impl like\n-        // `impl<T:Copy> Copy for Option<T>`, we replace the type variable\n-        // in `Option<T>` with an infer variable, to `Option<_>` (this\n-        // doesn't actually change fast_reject output), but we don't\n-        // replace `S` with anything - this impl of course can't be\n-        // selected, and as there are hundreds of similar impls,\n-        // considering them would significantly harm performance.\n-        if let Some(simp) = fast_reject::simplify_type(tcx, self_ty, true) {\n-            if let Some(impls) = self.nonblanket_impls.borrow().get(&simp) {\n-                for &impl_def_id in impls {\n-                    f(impl_def_id);\n-                }\n-            }\n-        } else {\n-            for v in self.nonblanket_impls.borrow().values() {\n-                for &impl_def_id in v {\n-                    f(impl_def_id);\n-                }\n-            }\n-        }\n-    }\n-\n-}\n-\n bitflags! {\n     flags AdtFlags: u32 {\n         const NO_ADT_FLAGS        = 0,\n@@ -1513,6 +1364,8 @@ pub struct FieldDefData<'tcx, 'container: 'tcx> {\n     pub vis: hir::Visibility,\n     /// TyIVar is used here to allow for variance (see the doc at\n     /// AdtDefData).\n+    ///\n+    /// Note: direct accesses to `ty` must also add dep edges.\n     ty: ivar::TyIVar<'tcx, 'container>\n }\n \n@@ -1803,11 +1656,11 @@ impl<'tcx, 'container> FieldDefData<'tcx, 'container> {\n     }\n \n     pub fn unsubst_ty(&self) -> Ty<'tcx> {\n-        self.ty.unwrap()\n+        self.ty.unwrap(DepNode::FieldTy(self.did))\n     }\n \n     pub fn fulfill_ty(&self, ty: Ty<'container>) {\n-        self.ty.fulfill(ty);\n+        self.ty.fulfill(DepNode::FieldTy(self.did), ty);\n     }\n }\n \n@@ -1930,24 +1783,20 @@ impl LvaluePreference {\n /// into the map by the `typeck::collect` phase.  If the def-id is external,\n /// then we have to go consult the crate loading code (and cache the result for\n /// the future).\n-fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n+fn lookup_locally_or_in_crate_store<M, F>(descr: &str,\n                                           def_id: DefId,\n-                                          map: &RefCell<DefIdMap<V>>,\n-                                          load_external: F) -> V where\n-    V: Clone,\n-    F: FnOnce() -> V,\n+                                          map: &M,\n+                                          load_external: F)\n+                                          -> M::Value where\n+    M: MemoizationMap<Key=DefId>,\n+    F: FnOnce() -> M::Value,\n {\n-    match map.borrow().get(&def_id).cloned() {\n-        Some(v) => { return v; }\n-        None => { }\n-    }\n-\n-    if def_id.is_local() {\n-        panic!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n-    }\n-    let v = load_external();\n-    map.borrow_mut().insert(def_id, v.clone());\n-    v\n+    map.memoize(def_id, || {\n+        if def_id.is_local() {\n+            panic!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n+        }\n+        load_external()\n+    })\n }\n \n impl BorrowKind {\n@@ -2223,22 +2072,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn trait_items(&self, trait_did: DefId) -> Rc<Vec<ImplOrTraitItem<'tcx>>> {\n-        let mut trait_items = self.trait_items_cache.borrow_mut();\n-        match trait_items.get(&trait_did).cloned() {\n-            Some(trait_items) => trait_items,\n-            None => {\n-                let def_ids = self.trait_item_def_ids(trait_did);\n-                let items: Rc<Vec<ImplOrTraitItem>> =\n-                    Rc::new(def_ids.iter()\n-                                   .map(|d| self.impl_or_trait_item(d.def_id()))\n-                                   .collect());\n-                trait_items.insert(trait_did, items.clone());\n-                items\n-            }\n-        }\n-    }\n-\n     pub fn trait_impl_polarity(&self, id: DefId) -> Option<hir::ImplPolarity> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             match self.map.find(id) {\n@@ -2256,7 +2089,7 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn custom_coerce_unsized_kind(&self, did: DefId) -> adjustment::CustomCoerceUnsized {\n-        memoized(&self.custom_coerce_unsized_kinds, did, |did: DefId| {\n+        self.custom_coerce_unsized_kinds.memoize(did, || {\n             let (kind, src) = if did.krate != LOCAL_CRATE {\n                 (self.sess.cstore.custom_coerce_unsized_kind(did), \"external\")\n             } else {\n@@ -2452,19 +2285,6 @@ impl<'tcx> ctxt<'tcx> {\n             || self.lookup_repr_hints(did).contains(&attr::ReprSimd)\n     }\n \n-    /// Obtain the representation annotation for a struct definition.\n-    pub fn lookup_repr_hints(&self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n-        memoized(&self.repr_hint_cache, did, |did: DefId| {\n-            Rc::new(if did.is_local() {\n-                self.get_attrs(did).iter().flat_map(|meta| {\n-                    attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n-                }).collect()\n-            } else {\n-                self.sess.cstore.repr_attrs(did)\n-            })\n-        })\n-    }\n-\n     pub fn item_variances(&self, item_id: DefId) -> Rc<ItemVariances> {\n         lookup_locally_or_in_crate_store(\n             \"item_variance_map\", item_id, &self.item_variance_map,\n@@ -2491,6 +2311,10 @@ impl<'tcx> ctxt<'tcx> {\n             return\n         }\n \n+        // The primitive is not local, hence we are reading this out\n+        // of metadata.\n+        let _ignore = self.dep_graph.in_ignore();\n+\n         if self.populated_external_primitive_impls.borrow().contains(&primitive_def_id) {\n             return\n         }\n@@ -2513,6 +2337,10 @@ impl<'tcx> ctxt<'tcx> {\n             return\n         }\n \n+        // The type is not local, hence we are reading this out of\n+        // metadata and don't need to track edges.\n+        let _ignore = self.dep_graph.in_ignore();\n+\n         if self.populated_external_types.borrow().contains(&type_id) {\n             return\n         }\n@@ -2538,6 +2366,10 @@ impl<'tcx> ctxt<'tcx> {\n             return\n         }\n \n+        // The type is not local, hence we are reading this out of\n+        // metadata and don't need to track edges.\n+        let _ignore = self.dep_graph.in_ignore();\n+\n         let def = self.lookup_trait_def(trait_id);\n         if def.flags.get().intersects(TraitFlags::IMPLS_VALID) {\n             return;\n@@ -2760,6 +2592,15 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n         Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }\n+\n+\n+    pub fn visit_all_items_in_krate<V,F>(&self,\n+                                         dep_node_fn: F,\n+                                         visitor: &mut V)\n+        where F: FnMut(DefId) -> DepNode, V: Visitor<'tcx>\n+    {\n+        dep_graph::visit_all_items_in_krate(self, dep_node_fn, visitor);\n+    }\n }\n \n /// The category of explicit self."}, {"sha": "db001ce2c446c8f1ce9ce60840c84def4e311b4b", "filename": "src/librustc/middle/ty/trait_def.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,226 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dep_graph::DepNode;\n+use middle::def_id::DefId;\n+use middle::ty;\n+use middle::ty::fast_reject;\n+use middle::ty::Ty;\n+use std::borrow::{Borrow};\n+use std::cell::{Cell, Ref, RefCell};\n+use syntax::ast::Name;\n+use rustc_front::hir;\n+use util::nodemap::FnvHashMap;\n+\n+/// As `TypeScheme` but for a trait ref.\n+pub struct TraitDef<'tcx> {\n+    pub unsafety: hir::Unsafety,\n+\n+    /// If `true`, then this trait had the `#[rustc_paren_sugar]`\n+    /// attribute, indicating that it should be used with `Foo()`\n+    /// sugar. This is a temporary thing -- eventually any trait wil\n+    /// be usable with the sugar (or without it).\n+    pub paren_sugar: bool,\n+\n+    /// Generic type definitions. Note that `Self` is listed in here\n+    /// as having a single bound, the trait itself (e.g., in the trait\n+    /// `Eq`, there is a single bound `Self : Eq`). This is so that\n+    /// default methods get to assume that the `Self` parameters\n+    /// implements the trait.\n+    pub generics: ty::Generics<'tcx>,\n+\n+    pub trait_ref: ty::TraitRef<'tcx>,\n+\n+    /// A list of the associated types defined in this trait. Useful\n+    /// for resolving `X::Foo` type markers.\n+    pub associated_type_names: Vec<Name>,\n+\n+    // Impls of this trait. To allow for quicker lookup, the impls are indexed\n+    // by a simplified version of their Self type: impls with a simplifiable\n+    // Self are stored in nonblanket_impls keyed by it, while all other impls\n+    // are stored in blanket_impls.\n+    //\n+    // These lists are tracked by `DepNode::TraitImpls`; we don't use\n+    // a DepTrackingMap but instead have the `TraitDef` insert the\n+    // required reads/writes.\n+\n+    /// Impls of the trait.\n+    nonblanket_impls: RefCell<\n+        FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n+    >,\n+\n+    /// Blanket impls associated with the trait.\n+    blanket_impls: RefCell<Vec<DefId>>,\n+\n+    /// Various flags\n+    pub flags: Cell<TraitFlags>\n+}\n+\n+impl<'tcx> TraitDef<'tcx> {\n+    pub fn new(unsafety: hir::Unsafety,\n+               paren_sugar: bool,\n+               generics: ty::Generics<'tcx>,\n+               trait_ref: ty::TraitRef<'tcx>,\n+               associated_type_names: Vec<Name>)\n+               -> TraitDef<'tcx> {\n+        TraitDef {\n+            paren_sugar: paren_sugar,\n+            unsafety: unsafety,\n+            generics: generics,\n+            trait_ref: trait_ref,\n+            associated_type_names: associated_type_names,\n+            nonblanket_impls: RefCell::new(FnvHashMap()),\n+            blanket_impls: RefCell::new(vec![]),\n+            flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS)\n+        }\n+    }\n+\n+    pub fn def_id(&self) -> DefId {\n+        self.trait_ref.def_id\n+    }\n+\n+    // returns None if not yet calculated\n+    pub fn object_safety(&self) -> Option<bool> {\n+        if self.flags.get().intersects(TraitFlags::OBJECT_SAFETY_VALID) {\n+            Some(self.flags.get().intersects(TraitFlags::IS_OBJECT_SAFE))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn set_object_safety(&self, is_safe: bool) {\n+        assert!(self.object_safety().map(|cs| cs == is_safe).unwrap_or(true));\n+        self.flags.set(\n+            self.flags.get() | if is_safe {\n+                TraitFlags::OBJECT_SAFETY_VALID | TraitFlags::IS_OBJECT_SAFE\n+            } else {\n+                TraitFlags::OBJECT_SAFETY_VALID\n+            }\n+        );\n+    }\n+\n+    fn write_trait_impls(&self, tcx: &ty::ctxt<'tcx>) {\n+        tcx.dep_graph.write(DepNode::TraitImpls(self.trait_ref.def_id));\n+    }\n+\n+    fn read_trait_impls(&self, tcx: &ty::ctxt<'tcx>) {\n+        tcx.dep_graph.read(DepNode::TraitImpls(self.trait_ref.def_id));\n+    }\n+\n+    /// Records a trait-to-implementation mapping.\n+    pub fn record_impl(&self,\n+                       tcx: &ty::ctxt<'tcx>,\n+                       impl_def_id: DefId,\n+                       impl_trait_ref: ty::TraitRef<'tcx>) {\n+        debug!(\"TraitDef::record_impl for {:?}, from {:?}\",\n+               self, impl_trait_ref);\n+\n+        // Record the write into the impl set, but only for local\n+        // impls: external impls are handled differently.\n+        if impl_def_id.is_local() {\n+            self.write_trait_impls(tcx);\n+        }\n+\n+        // We don't want to borrow_mut after we already populated all impls,\n+        // so check if an impl is present with an immutable borrow first.\n+        if let Some(sty) = fast_reject::simplify_type(tcx,\n+                                                      impl_trait_ref.self_ty(), false) {\n+            if let Some(is) = self.nonblanket_impls.borrow().get(&sty) {\n+                if is.contains(&impl_def_id) {\n+                    return // duplicate - skip\n+                }\n+            }\n+\n+            self.nonblanket_impls.borrow_mut().entry(sty).or_insert(vec![]).push(impl_def_id)\n+        } else {\n+            if self.blanket_impls.borrow().contains(&impl_def_id) {\n+                return // duplicate - skip\n+            }\n+            self.blanket_impls.borrow_mut().push(impl_def_id)\n+        }\n+    }\n+\n+    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &ty::ctxt<'tcx>, mut f: F)  {\n+        self.read_trait_impls(tcx);\n+\n+        tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n+\n+        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+            f(impl_def_id);\n+        }\n+\n+        for v in self.nonblanket_impls.borrow().values() {\n+            for &impl_def_id in v {\n+                f(impl_def_id);\n+            }\n+        }\n+    }\n+\n+    /// Iterate over every impl that could possibly match the\n+    /// self-type `self_ty`.\n+    pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n+                                                   tcx: &ty::ctxt<'tcx>,\n+                                                   self_ty: Ty<'tcx>,\n+                                                   mut f: F)\n+    {\n+        self.read_trait_impls(tcx);\n+\n+        tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n+\n+        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+            f(impl_def_id);\n+        }\n+\n+        // simplify_type(.., false) basically replaces type parameters and\n+        // projections with infer-variables. This is, of course, done on\n+        // the impl trait-ref when it is instantiated, but not on the\n+        // predicate trait-ref which is passed here.\n+        //\n+        // for example, if we match `S: Copy` against an impl like\n+        // `impl<T:Copy> Copy for Option<T>`, we replace the type variable\n+        // in `Option<T>` with an infer variable, to `Option<_>` (this\n+        // doesn't actually change fast_reject output), but we don't\n+        // replace `S` with anything - this impl of course can't be\n+        // selected, and as there are hundreds of similar impls,\n+        // considering them would significantly harm performance.\n+        if let Some(simp) = fast_reject::simplify_type(tcx, self_ty, true) {\n+            if let Some(impls) = self.nonblanket_impls.borrow().get(&simp) {\n+                for &impl_def_id in impls {\n+                    f(impl_def_id);\n+                }\n+            }\n+        } else {\n+            for v in self.nonblanket_impls.borrow().values() {\n+                for &impl_def_id in v {\n+                    f(impl_def_id);\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn borrow_impl_lists<'s>(&'s self, tcx: &ty::ctxt<'tcx>)\n+                                 -> (Ref<'s, Vec<DefId>>,\n+                                     Ref<'s, FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>>) {\n+        self.read_trait_impls(tcx);\n+        (self.blanket_impls.borrow(), self.nonblanket_impls.borrow())\n+    }\n+\n+}\n+\n+bitflags! {\n+    flags TraitFlags: u32 {\n+        const NO_TRAIT_FLAGS        = 0,\n+        const HAS_DEFAULT_IMPL      = 1 << 0,\n+        const IS_OBJECT_SAFE        = 1 << 1,\n+        const OBJECT_SAFETY_VALID   = 1 << 2,\n+        const IMPLS_VALID           = 1 << 3,\n+    }\n+}\n+"}, {"sha": "0134bcdf1757b2913f6dbcb70b4b13b5157687e3", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -125,6 +125,8 @@ pub struct Options {\n     pub parse_only: bool,\n     pub no_trans: bool,\n     pub treat_err_as_bug: bool,\n+    pub incremental_compilation: bool,\n+    pub dump_dep_graph: bool,\n     pub no_analysis: bool,\n     pub debugging_opts: DebuggingOptions,\n     pub prints: Vec<PrintRequest>,\n@@ -234,6 +236,8 @@ pub fn basic_options() -> Options {\n         parse_only: false,\n         no_trans: false,\n         treat_err_as_bug: false,\n+        incremental_compilation: false,\n+        dump_dep_graph: false,\n         no_analysis: false,\n         debugging_opts: basic_debugging_options(),\n         prints: Vec::new(),\n@@ -606,6 +610,10 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"run all passes except translation; no output\"),\n     treat_err_as_bug: bool = (false, parse_bool,\n           \"treat all errors that occur as bugs\"),\n+    incr_comp: bool = (false, parse_bool,\n+          \"enable incremental compilation (experimental)\"),\n+    dump_dep_graph: bool = (false, parse_bool,\n+          \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n     no_analysis: bool = (false, parse_bool,\n           \"parse and expand the source, but run no analysis\"),\n     extra_plugins: Vec<String> = (Vec::new(), parse_list,\n@@ -932,6 +940,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     let parse_only = debugging_opts.parse_only;\n     let no_trans = debugging_opts.no_trans;\n     let treat_err_as_bug = debugging_opts.treat_err_as_bug;\n+    let incremental_compilation = debugging_opts.incr_comp;\n+    let dump_dep_graph = debugging_opts.dump_dep_graph;\n     let no_analysis = debugging_opts.no_analysis;\n \n     if debugging_opts.debug_llvm {\n@@ -1106,6 +1116,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         parse_only: parse_only,\n         no_trans: no_trans,\n         treat_err_as_bug: treat_err_as_bug,\n+        incremental_compilation: incremental_compilation || dump_dep_graph,\n+        dump_dep_graph: dump_dep_graph,\n         no_analysis: no_analysis,\n         debugging_opts: debugging_opts,\n         prints: prints,"}, {"sha": "2481cab78b4d6f15bdf37bf15d65c19a557cd38c", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -201,46 +201,38 @@ pub fn block_query<P>(b: &hir::Block, p: P) -> bool where P: FnMut(&hir::Expr) -\n     return v.flag;\n }\n \n-/// Memoizes a one-argument closure using the given RefCell containing\n-/// a type implementing MutableMap to serve as a cache.\n-///\n-/// In the future the signature of this function is expected to be:\n-/// ```\n-/// pub fn memoized<T: Clone, U: Clone, M: MutableMap<T, U>>(\n-///    cache: &RefCell<M>,\n-///    f: &|T| -> U\n-/// ) -> impl |T| -> U {\n-/// ```\n-/// but currently it is not possible.\n-///\n-/// # Examples\n-/// ```\n-/// struct Context {\n-///    cache: RefCell<HashMap<usize, usize>>\n-/// }\n-///\n-/// fn factorial(ctxt: &Context, n: usize) -> usize {\n-///     memoized(&ctxt.cache, n, |n| match n {\n-///         0 | 1 => n,\n-///         _ => factorial(ctxt, n - 2) + factorial(ctxt, n - 1)\n-///     })\n-/// }\n-/// ```\n-#[inline(always)]\n-pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) -> U\n-    where T: Clone + Hash + Eq,\n-          U: Clone,\n-          S: HashState,\n-          F: FnOnce(T) -> U,\n+pub trait MemoizationMap {\n+    type Key: Clone;\n+    type Value: Clone;\n+\n+    /// If `key` is present in the map, return the valuee,\n+    /// otherwise invoke `op` and store the value in the map.\n+    ///\n+    /// NB: if the receiver is a `DepTrackingMap`, special care is\n+    /// needed in the `op` to ensure that the correct edges are\n+    /// added into the dep graph. See the `DepTrackingMap` impl for\n+    /// more details!\n+    fn memoize<OP>(&self, key: Self::Key, op: OP) -> Self::Value\n+        where OP: FnOnce() -> Self::Value;\n+}\n+\n+impl<K, V, S> MemoizationMap for RefCell<HashMap<K,V,S>>\n+    where K: Hash+Eq+Clone, V: Clone, S: HashState\n {\n-    let key = arg.clone();\n-    let result = cache.borrow().get(&key).cloned();\n-    match result {\n-        Some(result) => result,\n-        None => {\n-            let result = f(arg);\n-            cache.borrow_mut().insert(key, result.clone());\n-            result\n+    type Key = K;\n+    type Value = V;\n+\n+    fn memoize<OP>(&self, key: K, op: OP) -> V\n+        where OP: FnOnce() -> V\n+    {\n+        let result = self.borrow().get(&key).cloned();\n+        match result {\n+            Some(result) => result,\n+            None => {\n+                let result = op();\n+                self.borrow_mut().insert(key, result.clone());\n+                result\n+            }\n         }\n     }\n }"}, {"sha": "631149e69d77ecdd024def52cc4ab33f43169517", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -20,6 +20,7 @@ pub use self::MovedValueUseKind::*;\n \n use self::InteriorKind::*;\n \n+use rustc::dep_graph::DepNode;\n use rustc::front::map as hir_map;\n use rustc::front::map::blocks::FnParts;\n use rustc::middle::cfg;\n@@ -109,7 +110,7 @@ pub fn check_crate(tcx: &ty::ctxt) {\n         }\n     };\n \n-    tcx.map.krate().visit_all_items(&mut bccx);\n+    tcx.visit_all_items_in_krate(DepNode::BorrowCheck, &mut bccx);\n \n     if tcx.sess.borrowck_stats() {\n         println!(\"--- borrowck stats ---\");"}, {"sha": "1ea09490aed2f4d05d99f64d555e68db2e45de2f", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -77,16 +77,16 @@ impl<E: Debug> Debug for Edge<E> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub struct NodeIndex(pub usize);\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub struct EdgeIndex(pub usize);\n \n pub const INVALID_EDGE_INDEX: EdgeIndex = EdgeIndex(usize::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq)]\n pub struct Direction { repr: usize }\n \n pub const OUTGOING: Direction = Direction { repr: 0 };\n@@ -410,4 +410,12 @@ impl<E> Edge<E> {\n     pub fn target(&self) -> NodeIndex {\n         self.target\n     }\n+\n+    pub fn source_or_target(&self, direction: Direction) -> NodeIndex {\n+        if direction == OUTGOING {\n+            self.target\n+        } else {\n+            self.source\n+        }\n+    }\n }"}, {"sha": "ef64d7dde091c0b99f28295e059d0b232a9071df", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -40,6 +40,7 @@ pub mod transitive_relation;\n pub mod unify;\n pub mod fnv;\n pub mod tuple_slice;\n+pub mod veccell;\n \n // See comments in src/librustc/lib.rs\n #[doc(hidden)]"}, {"sha": "008642d9d6567e329239768b495c2f777039257f", "filename": "src/librustc_data_structures/veccell/mod.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fveccell%2Fmod.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::UnsafeCell;\n+use std::mem;\n+\n+pub struct VecCell<T> {\n+    data: UnsafeCell<Vec<T>>\n+}\n+\n+impl<T> VecCell<T> {\n+    pub fn with_capacity(capacity: usize) -> VecCell<T>{\n+        VecCell { data: UnsafeCell::new(Vec::with_capacity(capacity)) }\n+    }\n+\n+    #[inline]\n+    pub fn push(&self, data: T) -> usize {\n+        // The logic here, and in `swap` below, is that the `push`\n+        // method on the vector will not recursively access this\n+        // `VecCell`. Therefore, we can temporarily obtain mutable\n+        // access, secure in the knowledge that even if aliases exist\n+        // -- indeed, even if aliases are reachable from within the\n+        // vector -- they will not be used for the duration of this\n+        // particular fn call. (Note that we also are relying on the\n+        // fact that `VecCell` is not `Sync`.)\n+        unsafe {\n+            let v = self.data.get();\n+            (*v).push(data);\n+            (*v).len()\n+        }\n+    }\n+\n+    pub fn swap(&self, mut data: Vec<T>) -> Vec<T> {\n+        unsafe {\n+            let v = self.data.get();\n+            mem::swap(&mut *v, &mut data);\n+        }\n+        data\n+    }\n+}"}, {"sha": "d172bfb441358e6ca180ff91b04443c541aec4fb", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -801,7 +801,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n                                    time(time_passes,\n                                         \"rvalue checking\",\n-                                        || middle::check_rvalues::check_crate(tcx, krate));\n+                                        || middle::check_rvalues::check_crate(tcx));\n \n                                    // Avoid overwhelming user with errors if type checking failed.\n                                    // I'm not sure how helpful this is, to be honest, but it avoids"}, {"sha": "ba5ecc22e747487123ecc94ccbed98953653cee5", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -204,6 +204,7 @@ impl PpSourceMode {\n                                                         let annotation = TypedAnnotation {\n                                                             tcx: tcx,\n                                                         };\n+                                                        let _ignore = tcx.dep_graph.in_ignore();\n                                                         f(&annotation,\n                                                           payload,\n                                                           &ast_map.forest.krate)"}, {"sha": "0b48cad36ba8fefddfc9e0f0b1dcb8423a58eb97", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -38,7 +38,7 @@ use middle::ty::{self, RegionEscape, Ty};\n use rustc::mir;\n use rustc::mir::visit::MutVisitor;\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::Cell;\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n@@ -353,16 +353,11 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n     let associated_type_names = parse_associated_type_names(item_doc);\n     let paren_sugar = parse_paren_sugar(item_doc);\n \n-    ty::TraitDef {\n-        paren_sugar: paren_sugar,\n-        unsafety: unsafety,\n-        generics: generics,\n-        trait_ref: item_trait_ref(item_doc, tcx, cdata),\n-        associated_type_names: associated_type_names,\n-        nonblanket_impls: RefCell::new(FnvHashMap()),\n-        blanket_impls: RefCell::new(vec![]),\n-        flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS)\n-    }\n+    ty::TraitDef::new(unsafety,\n+                      paren_sugar,\n+                      generics,\n+                      item_trait_ref(item_doc, tcx, cdata),\n+                      associated_type_names)\n }\n \n pub fn get_adt_def<'tcx>(intr: &IdentInterner,"}, {"sha": "ac15878dc5136232d6f0db35a6d1ebef2d13d298", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -24,6 +24,7 @@ use build;\n use graphviz;\n use pretty;\n use transform::*;\n+use rustc::dep_graph::DepNode;\n use rustc::mir::repr::Mir;\n use hair::cx::Cx;\n use std::fs::File;\n@@ -48,7 +49,7 @@ pub fn build_mir_for_crate<'tcx>(tcx: &ty::ctxt<'tcx>) -> MirMap<'tcx> {\n             tcx: tcx,\n             map: &mut map,\n         };\n-        tcx.map.krate().visit_all_items(&mut dump);\n+        tcx.visit_all_items_in_krate(DepNode::MirMapConstruction, &mut dump);\n     }\n     map\n }"}, {"sha": "955e68be0b00699ce293eab597a4f7790e544e81", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -35,6 +35,7 @@ use std::mem::replace;\n use rustc_front::hir;\n use rustc_front::intravisit::{self, Visitor};\n \n+use rustc::dep_graph::DepNode;\n use rustc::lint;\n use rustc::middle::def;\n use rustc::middle::def_id::DefId;\n@@ -1674,6 +1675,8 @@ pub fn check_crate(tcx: &ty::ctxt,\n                    export_map: &def::ExportMap,\n                    external_exports: ExternalExports)\n                    -> AccessLevels {\n+    let _task = tcx.dep_graph.in_task(DepNode::Privacy);\n+\n     let krate = tcx.map.krate();\n \n     // Sanity check to make sure that all privacy usage and controls are"}, {"sha": "e1edbf4a1276dc963d13858c4510c03d45c0c1bf", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -182,8 +182,10 @@ pub fn find_crate_name(sess: Option<&Session>,\n     \"rust_out\".to_string()\n }\n \n-pub fn build_link_meta(sess: &Session, krate: &hir::Crate,\n-                       name: &str) -> LinkMeta {\n+pub fn build_link_meta(sess: &Session,\n+                       krate: &hir::Crate,\n+                       name: &str)\n+                       -> LinkMeta {\n     let r = LinkMeta {\n         crate_name: name.to_owned(),\n         crate_hash: Svh::calculate(&sess.opts.cg.metadata, krate),"}, {"sha": "0892cf1b5d33ec4ba5ba5858db71289a7ff8e7cc", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -27,6 +27,7 @@\n #![feature(const_fn)]\n #![feature(custom_attribute)]\n #![allow(unused_attributes)]\n+#![feature(into_cow)]\n #![feature(iter_arith)]\n #![feature(libc)]\n #![feature(path_relative_from)]"}, {"sha": "e1343c73acfa90cfbd0db544dd8b4bdbbecc2a51", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -716,6 +716,8 @@ pub fn process_crate<'l, 'tcx>(tcx: &'l ty::ctxt<'tcx>,\n                                analysis: &ty::CrateAnalysis,\n                                cratename: &str,\n                                odir: Option<&Path>) {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+\n     if generated_code(krate.span) {\n         return;\n     }"}, {"sha": "924700f0ae5916c263fb15a23555e838cfc5c793", "filename": "src/librustc_trans/trans/assert_dep_graph.rs", "status": "added", "additions": 430, "deletions": 0, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,430 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass is only used for the UNIT TESTS and DEBUGGING NEEDS\n+//! around dependency graph construction. It serves two purposes; it\n+//! will dump graphs in graphviz form to disk, and it searches for\n+//! `#[rustc_if_this_changed]` and `#[rustc_then_this_would_need]`\n+//! annotations. These annotations can be used to test whether paths\n+//! exist in the graph. We report errors on each\n+//! `rustc_if_this_changed` annotation. If a path exists in all\n+//! cases, then we would report \"all path(s) exist\". Otherwise, we\n+//! report: \"no path to `foo`\" for each case where no path exists.\n+//! `compile-fail` tests can then be used to check when paths exist or\n+//! do not.\n+//!\n+//! The full form of the `rustc_if_this_changed` annotation is\n+//! `#[rustc_if_this_changed(id)]`. The `\"id\"` is optional and\n+//! defaults to `\"id\"` if omitted.\n+//!\n+//! Example:\n+//!\n+//! ```\n+//! #[rustc_if_this_changed]\n+//! fn foo() { }\n+//!\n+//! #[rustc_then_this_would_need(\"trans\")] //~ ERROR no path from `foo`\n+//! fn bar() { }\n+//!\n+//! #[rustc_then_this_would_need(\"trans\")] //~ ERROR OK\n+//! fn baz() { foo(); }\n+//! ```\n+\n+use graphviz as dot;\n+use rustc::dep_graph::{DepGraphQuery, DepNode};\n+use rustc::middle::def_id::DefId;\n+use rustc::middle::ty;\n+use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n+use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n+use rustc_front::hir;\n+use rustc_front::intravisit::Visitor;\n+use std::borrow::IntoCow;\n+use std::env;\n+use std::fs::File;\n+use std::io::Write;\n+use syntax::ast;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n+\n+const IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n+const THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n+const ID: &'static str = \"id\";\n+\n+pub fn assert_dep_graph(tcx: &ty::ctxt) {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+\n+    if tcx.sess.opts.dump_dep_graph {\n+        dump_graph(tcx);\n+    }\n+\n+    // Find annotations supplied by user (if any).\n+    let (if_this_changed, then_this_would_need) = {\n+        let mut visitor = IfThisChanged { tcx: tcx,\n+                                          if_this_changed: FnvHashMap(),\n+                                          then_this_would_need: FnvHashMap() };\n+        tcx.map.krate().visit_all_items(&mut visitor);\n+        (visitor.if_this_changed, visitor.then_this_would_need)\n+    };\n+\n+    // Check paths.\n+    check_paths(tcx, &if_this_changed, &then_this_would_need);\n+}\n+\n+type SourceHashMap = FnvHashMap<InternedString,\n+                                FnvHashSet<(Span, DefId, DepNode)>>;\n+type TargetHashMap = FnvHashMap<InternedString,\n+                                FnvHashSet<(Span, InternedString, ast::NodeId, DepNode)>>;\n+\n+struct IfThisChanged<'a, 'tcx:'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    if_this_changed: SourceHashMap,\n+    then_this_would_need: TargetHashMap,\n+}\n+\n+impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n+    fn process_attrs(&mut self, node_id: ast::NodeId, def_id: DefId) {\n+        for attr in self.tcx.get_attrs(def_id).iter() {\n+            if attr.check_name(IF_THIS_CHANGED) {\n+                let mut id = None;\n+                for meta_item in attr.meta_item_list().unwrap_or_default() {\n+                    match meta_item.node {\n+                        ast::MetaWord(ref s) if id.is_none() => id = Some(s.clone()),\n+                        _ => {\n+                            self.tcx.sess.span_err(\n+                                meta_item.span,\n+                                &format!(\"unexpected meta-item {:?}\", meta_item.node));\n+                        }\n+                    }\n+                }\n+                let id = id.unwrap_or(InternedString::new(ID));\n+                self.if_this_changed.entry(id)\n+                                    .or_insert(FnvHashSet())\n+                                    .insert((attr.span, def_id, DepNode::Hir(def_id)));\n+            } else if attr.check_name(THEN_THIS_WOULD_NEED) {\n+                let mut dep_node_interned = None;\n+                let mut id = None;\n+                for meta_item in attr.meta_item_list().unwrap_or_default() {\n+                    match meta_item.node {\n+                        ast::MetaWord(ref s) if dep_node_interned.is_none() =>\n+                            dep_node_interned = Some(s.clone()),\n+                        ast::MetaWord(ref s) if id.is_none() =>\n+                            id = Some(s.clone()),\n+                        _ => {\n+                            self.tcx.sess.span_err(\n+                                meta_item.span,\n+                                &format!(\"unexpected meta-item {:?}\", meta_item.node));\n+                        }\n+                    }\n+                }\n+                let dep_node_str = dep_node_interned.as_ref().map(|s| &**s);\n+                macro_rules! match_depnode_name {\n+                    ($input:expr, $def_id:expr, match { $($variant:ident,)* } else $y:expr) => {\n+                        match $input {\n+                            $(Some(stringify!($variant)) => DepNode::$variant($def_id),)*\n+                            _ => $y\n+                        }\n+                    }\n+                }\n+                let dep_node = match_depnode_name! {\n+                    dep_node_str, def_id, match {\n+                        CollectItem,\n+                        BorrowCheck,\n+                        TransCrateItem,\n+                        TypeckItemType,\n+                        TypeckItemBody,\n+                        ImplOrTraitItems,\n+                        ItemSignature,\n+                        FieldTy,\n+                        TraitItemDefIds,\n+                        InherentImpls,\n+                        ImplItems,\n+                        TraitImpls,\n+                        ReprHints,\n+                    } else {\n+                        self.tcx.sess.span_fatal(\n+                            attr.span,\n+                            &format!(\"unrecognized DepNode variant {:?}\", dep_node_str));\n+                    }\n+                };\n+                let id = id.unwrap_or(InternedString::new(ID));\n+                self.then_this_would_need\n+                    .entry(id)\n+                    .or_insert(FnvHashSet())\n+                    .insert((attr.span, dep_node_interned.clone().unwrap(), node_id, dep_node));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        let def_id = self.tcx.map.local_def_id(item.id);\n+        self.process_attrs(item.id, def_id);\n+    }\n+}\n+\n+fn check_paths(tcx: &ty::ctxt,\n+               if_this_changed: &SourceHashMap,\n+               then_this_would_need: &TargetHashMap)\n+{\n+    // Return early here so as not to construct the query, which is not cheap.\n+    if if_this_changed.is_empty() {\n+        return;\n+    }\n+    let query = tcx.dep_graph.query();\n+    for (id, sources) in if_this_changed {\n+        let targets = match then_this_would_need.get(id) {\n+            Some(targets) => targets,\n+            None => {\n+                for &(source_span, _, _) in sources.iter().take(1) {\n+                    tcx.sess.span_err(\n+                        source_span,\n+                        &format!(\"no targets for id `{}`\", id));\n+                }\n+                continue;\n+            }\n+        };\n+\n+        for &(_, source_def_id, source_dep_node) in sources {\n+            let dependents = query.dependents(source_dep_node);\n+            for &(target_span, ref target_pass, _, ref target_dep_node) in targets {\n+                if !dependents.contains(&target_dep_node) {\n+                    tcx.sess.span_err(\n+                        target_span,\n+                        &format!(\"no path from `{}` to `{}`\",\n+                                 tcx.item_path_str(source_def_id),\n+                                 target_pass));\n+                } else {\n+                    tcx.sess.span_err(\n+                        target_span,\n+                        &format!(\"OK\"));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn dump_graph(tcx: &ty::ctxt) {\n+    let path: String = env::var(\"RUST_DEP_GRAPH\").unwrap_or_else(|_| format!(\"dep_graph\"));\n+    let query = tcx.dep_graph.query();\n+\n+    let nodes = match env::var(\"RUST_DEP_GRAPH_FILTER\") {\n+        Ok(string) => {\n+            // Expect one of: \"-> target\", \"source -> target\", or \"source ->\".\n+            let parts: Vec<_> = string.split(\"->\").collect();\n+            if parts.len() > 2 {\n+                panic!(\"Invalid RUST_DEP_GRAPH_FILTER: expected '[source] -> [target]'\");\n+            }\n+            let sources = node_set(&query, &parts[0]);\n+            let targets = node_set(&query, &parts[1]);\n+            filter_nodes(&query, &sources, &targets)\n+        }\n+        Err(_) => {\n+            query.nodes()\n+                 .into_iter()\n+                 .collect()\n+        }\n+    };\n+    let edges = filter_edges(&query, &nodes);\n+\n+    { // dump a .txt file with just the edges:\n+        let txt_path = format!(\"{}.txt\", path);\n+        let mut file = File::create(&txt_path).unwrap();\n+        for &(source, target) in &edges {\n+            write!(file, \"{:?} -> {:?}\\n\", source, target).unwrap();\n+        }\n+    }\n+\n+    { // dump a .dot file in graphviz format:\n+        let dot_path = format!(\"{}.dot\", path);\n+        let mut v = Vec::new();\n+        dot::render(&GraphvizDepGraph(nodes, edges), &mut v).unwrap();\n+        File::create(&dot_path).and_then(|mut f| f.write_all(&v)).unwrap();\n+    }\n+}\n+\n+pub struct GraphvizDepGraph(FnvHashSet<DepNode>, Vec<(DepNode, DepNode)>);\n+\n+impl<'a, 'tcx> dot::GraphWalk<'a, DepNode, (DepNode, DepNode)> for GraphvizDepGraph {\n+    fn nodes(&self) -> dot::Nodes<DepNode> {\n+        let nodes: Vec<_> = self.0.iter().cloned().collect();\n+        nodes.into_cow()\n+    }\n+    fn edges(&self) -> dot::Edges<(DepNode, DepNode)> {\n+        self.1[..].into_cow()\n+    }\n+    fn source(&self, edge: &(DepNode, DepNode)) -> DepNode {\n+        edge.0\n+    }\n+    fn target(&self, edge: &(DepNode, DepNode)) -> DepNode {\n+        edge.1\n+    }\n+}\n+\n+impl<'a, 'tcx> dot::Labeller<'a, DepNode, (DepNode, DepNode)> for GraphvizDepGraph {\n+    fn graph_id(&self) -> dot::Id {\n+        dot::Id::new(\"DependencyGraph\").unwrap()\n+    }\n+    fn node_id(&self, n: &DepNode) -> dot::Id {\n+        let s: String =\n+            format!(\"{:?}\", n).chars()\n+                              .map(|c| if c == '_' || c.is_alphanumeric() { c } else { '_' })\n+                              .collect();\n+        debug!(\"n={:?} s={:?}\", n, s);\n+        dot::Id::new(s).unwrap()\n+    }\n+    fn node_label(&self, n: &DepNode) -> dot::LabelText {\n+        dot::LabelText::label(format!(\"{:?}\", n))\n+    }\n+}\n+\n+// Given an optional filter like `\"x,y,z\"`, returns either `None` (no\n+// filter) or the set of nodes whose labels contain all of those\n+// substrings.\n+fn node_set(query: &DepGraphQuery, filter: &str) -> Option<FnvHashSet<DepNode>> {\n+    debug!(\"node_set(filter={:?})\", filter);\n+\n+    if filter.trim().is_empty() {\n+        return None;\n+    }\n+\n+    let filters: Vec<&str> = filter.split(\"&\").map(|s| s.trim()).collect();\n+\n+    debug!(\"node_set: filters={:?}\", filters);\n+\n+    Some(query.nodes()\n+         .into_iter()\n+         .filter(|n| {\n+             let s = format!(\"{:?}\", n);\n+             filters.iter().all(|f| s.contains(f))\n+         })\n+        .collect())\n+}\n+\n+fn filter_nodes(query: &DepGraphQuery,\n+                sources: &Option<FnvHashSet<DepNode>>,\n+                targets: &Option<FnvHashSet<DepNode>>)\n+                -> FnvHashSet<DepNode>\n+{\n+    if let &Some(ref sources) = sources {\n+        if let &Some(ref targets) = targets {\n+            walk_between(query, sources, targets)\n+        } else {\n+            walk_nodes(query, sources, OUTGOING)\n+        }\n+    } else if let &Some(ref targets) = targets {\n+        walk_nodes(query, targets, INCOMING)\n+    } else {\n+        query.nodes().into_iter().collect()\n+    }\n+}\n+\n+fn walk_nodes(query: &DepGraphQuery,\n+              starts: &FnvHashSet<DepNode>,\n+              direction: Direction)\n+              -> FnvHashSet<DepNode>\n+{\n+    let mut set = FnvHashSet();\n+    for start in starts {\n+        debug!(\"walk_nodes: start={:?} outgoing?={:?}\", start, direction == OUTGOING);\n+        if set.insert(*start) {\n+            let mut stack = vec![query.indices[start]];\n+            while let Some(index) = stack.pop() {\n+                for (_, edge) in query.graph.adjacent_edges(index, direction) {\n+                    let neighbor_index = edge.source_or_target(direction);\n+                    let neighbor = query.graph.node_data(neighbor_index);\n+                    if set.insert(*neighbor) {\n+                        stack.push(neighbor_index);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    set\n+}\n+\n+fn walk_between(query: &DepGraphQuery,\n+                sources: &FnvHashSet<DepNode>,\n+                targets: &FnvHashSet<DepNode>)\n+                -> FnvHashSet<DepNode>\n+{\n+    // This is a bit tricky. We want to include a node only if it is:\n+    // (a) reachable from a source and (b) will reach a target. And we\n+    // have to be careful about cycles etc.  Luckily efficiency is not\n+    // a big concern!\n+\n+    #[derive(Copy, Clone, PartialEq)]\n+    enum State { Undecided, Deciding, Included, Excluded }\n+\n+    let mut node_states = vec![State::Undecided; query.graph.len_nodes()];\n+\n+    for &target in targets {\n+        node_states[query.indices[&target].0] = State::Included;\n+    }\n+\n+    for source in sources.iter().map(|n| query.indices[n]) {\n+        recurse(query, &mut node_states, source);\n+    }\n+\n+    return query.nodes()\n+                .into_iter()\n+                .filter(|n| {\n+                    let index = query.indices[n];\n+                    node_states[index.0] == State::Included\n+                })\n+                .collect();\n+\n+    fn recurse(query: &DepGraphQuery,\n+               node_states: &mut [State],\n+               node: NodeIndex)\n+               -> bool\n+    {\n+        match node_states[node.0] {\n+            // known to reach a target\n+            State::Included => return true,\n+\n+            // known not to reach a target\n+            State::Excluded => return false,\n+\n+            // backedge, not yet known, say false\n+            State::Deciding => return false,\n+\n+            State::Undecided => { }\n+        }\n+\n+        node_states[node.0] = State::Deciding;\n+\n+        for neighbor_index in query.graph.successor_nodes(node) {\n+            if recurse(query, node_states, neighbor_index) {\n+                node_states[node.0] = State::Included;\n+            }\n+        }\n+\n+        // if we didn't find a path to target, then set to excluded\n+        if node_states[node.0] == State::Deciding {\n+            node_states[node.0] = State::Excluded;\n+            false\n+        } else {\n+            assert!(node_states[node.0] == State::Included);\n+            true\n+        }\n+    }\n+}\n+\n+fn filter_edges(query: &DepGraphQuery,\n+                nodes: &FnvHashSet<DepNode>)\n+                -> Vec<(DepNode, DepNode)>\n+{\n+    query.edges()\n+         .into_iter()\n+         .filter(|&(source, target)| nodes.contains(&source) && nodes.contains(&target))\n+         .collect()\n+}"}, {"sha": "5a40ff7625224728513907edb8899f222ff88f1d", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -43,13 +43,15 @@ use middle::weak_lang_items;\n use middle::pat_util::simple_name;\n use middle::subst::Substs;\n use middle::ty::{self, Ty, HasTypeFlags};\n+use rustc::dep_graph::DepNode;\n use rustc::front::map as hir_map;\n use rustc::util::common::time;\n use rustc_mir::mir_map::MirMap;\n use session::config::{self, NoDebugInfo, FullDebugInfo};\n use session::Session;\n use trans::_match;\n use trans::adt;\n+use trans::assert_dep_graph;\n use trans::attributes;\n use trans::build::*;\n use trans::builder::{Builder, noname};\n@@ -2984,9 +2986,16 @@ pub fn trans_crate<'tcx>(tcx: &ty::ctxt<'tcx>,\n                          mir_map: &MirMap<'tcx>,\n                          analysis: ty::CrateAnalysis)\n                          -> CrateTranslation {\n-    let ty::CrateAnalysis { export_map, reachable, name, .. } = analysis;\n+    let _task = tcx.dep_graph.in_task(DepNode::TransCrate);\n+\n+    // Be careful with this krate: obviously it gives access to the\n+    // entire contents of the krate. So if you push any subtasks of\n+    // `TransCrate`, you need to be careful to register \"reads\" of the\n+    // particular items that will be processed.\n     let krate = tcx.map.krate();\n \n+    let ty::CrateAnalysis { export_map, reachable, name, .. } = analysis;\n+\n     let check_overflow = if let Some(v) = tcx.sess.opts.debugging_opts.force_overflow_checks {\n         v\n     } else {\n@@ -3140,6 +3149,8 @@ pub fn trans_crate<'tcx>(tcx: &ty::ctxt<'tcx>,\n     };\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n+    assert_dep_graph::assert_dep_graph(tcx);\n+\n     CrateTranslation {\n         modules: modules,\n         metadata_module: metadata_module,\n@@ -3192,7 +3203,16 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TransItemsWithinModVisitor<'a, 'tcx> {\n                 // skip modules, they will be uncovered by the TransModVisitor\n             }\n             _ => {\n-                trans_item(self.ccx, i);\n+                let def_id = self.ccx.tcx().map.local_def_id(i.id);\n+                let tcx = self.ccx.tcx();\n+\n+                // Create a subtask for trans'ing a particular item. We are\n+                // giving `trans_item` access to this item, so also record a read.\n+                tcx.dep_graph.with_task(DepNode::TransCrateItem(def_id), || {\n+                    tcx.dep_graph.read(DepNode::Hir(def_id));\n+                    trans_item(self.ccx, i);\n+                });\n+\n                 intravisit::walk_item(self, i);\n             }\n         }"}, {"sha": "baf244c2e7960613d3dc11ce077e35b3cd860d55", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -15,12 +15,13 @@ use middle::subst::Substs;\n use trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n use trans::common::*;\n \n+use rustc::dep_graph::DepNode;\n use rustc_front::hir;\n \n-fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n-    -> Option<DefId> {\n+fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n     debug!(\"instantiate_inline({:?})\", fn_id);\n     let _icx = push_ctxt(\"instantiate_inline\");\n+    let _task = ccx.tcx().dep_graph.in_task(DepNode::TransInlinedItem(fn_id));\n \n     match ccx.external().borrow().get(&fn_id) {\n         Some(&Some(node_id)) => {"}, {"sha": "d8a3cc50ff4ee5b92157b1547073a4b35ae9e275", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -37,6 +37,7 @@ use trans::machine;\n use trans::type_::Type;\n use middle::ty::{self, Ty, HasTypeFlags};\n use middle::subst::Substs;\n+use rustc::dep_graph::DepNode;\n use rustc_front::hir;\n use syntax::abi::{self, RustIntrinsic};\n use syntax::ast;\n@@ -101,6 +102,7 @@ pub fn span_transmute_size_error(a: &Session, b: Span, msg: &str) {\n /// Performs late verification that intrinsics are used correctly. At present,\n /// the only intrinsic that needs such verification is `transmute`.\n pub fn check_intrinsics(ccx: &CrateContext) {\n+    let _task = ccx.tcx().dep_graph.in_task(DepNode::IntrinsicUseCheck);\n     let mut last_failing_id = None;\n     for transmute_restriction in ccx.tcx().transmute_restrictions.borrow().iter() {\n         // Sometimes, a single call to transmute will push multiple"}, {"sha": "1fbc0d5c0152930a29acf337990a4ddf7d51ecb3", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -20,6 +20,7 @@ mod macros;\n \n mod adt;\n mod asm;\n+mod assert_dep_graph;\n mod attributes;\n mod base;\n mod basic_block;"}, {"sha": "14adc84f701f898af4ca6b9556f18fd94b9dee09", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -82,6 +82,7 @@ use self::TupleArgumentsFlag::*;\n \n use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n use check::_match::pat_ctxt;\n+use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use middle::astconv_util::prohibit_type_params;\n use middle::cstore::LOCAL_CRATE;\n@@ -384,34 +385,33 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n \n pub fn check_wf_new(ccx: &CrateCtxt) {\n     ccx.tcx.sess.abort_if_new_errors(|| {\n-        let krate = ccx.tcx.map.krate();\n         let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(ccx);\n-        krate.visit_all_items(&mut visit);\n+        ccx.tcx.visit_all_items_in_krate(DepNode::WfCheck, &mut visit);\n     });\n }\n \n pub fn check_item_types(ccx: &CrateCtxt) {\n     ccx.tcx.sess.abort_if_new_errors(|| {\n-        let krate = ccx.tcx.map.krate();\n         let mut visit = CheckItemTypesVisitor { ccx: ccx };\n-        krate.visit_all_items(&mut visit);\n+        ccx.tcx.visit_all_items_in_krate(DepNode::TypeckItemType, &mut visit);\n     });\n }\n \n pub fn check_item_bodies(ccx: &CrateCtxt) {\n     ccx.tcx.sess.abort_if_new_errors(|| {\n-        let krate = ccx.tcx.map.krate();\n         let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n-        krate.visit_all_items(&mut visit);\n+        ccx.tcx.visit_all_items_in_krate(DepNode::TypeckItemBody, &mut visit);\n     });\n }\n \n pub fn check_drop_impls(ccx: &CrateCtxt) {\n     ccx.tcx.sess.abort_if_new_errors(|| {\n+        let _task = ccx.tcx.dep_graph.in_task(DepNode::Dropck);\n         let drop_trait = match ccx.tcx.lang_items.drop_trait() {\n             Some(id) => ccx.tcx.lookup_trait_def(id), None => { return }\n         };\n         drop_trait.for_each_impl(ccx.tcx, |drop_impl_did| {\n+            let _task = ccx.tcx.dep_graph.in_task(DepNode::DropckImpl(drop_impl_did));\n             if drop_impl_did.is_local() {\n                 match dropck::check_drop_impl(ccx.tcx, drop_impl_did) {\n                     Ok(()) => {}"}, {"sha": "07c920829d978210cfa9db4b7503b901104b97fb", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -39,9 +39,10 @@ use std::rc::Rc;\n use syntax::codemap::Span;\n use syntax::parse::token;\n use util::nodemap::{DefIdMap, FnvHashMap};\n+use rustc::dep_graph::DepNode;\n use rustc::front::map as hir_map;\n use rustc_front::intravisit;\n-use rustc_front::hir::{Item, ItemImpl,Crate};\n+use rustc_front::hir::{Item, ItemImpl};\n use rustc_front::hir;\n \n mod orphan;\n@@ -104,11 +105,13 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n-    fn check(&self, krate: &Crate) {\n+    fn check(&self) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n-        krate.visit_all_items(&mut CoherenceCheckVisitor { cc: self });\n+        self.crate_context.tcx.visit_all_items_in_krate(\n+            DepNode::CoherenceCheckImpl,\n+            &mut CoherenceCheckVisitor { cc: self });\n \n         // Copy over the inherent impls we gathered up during the walk into\n         // the tcx.\n@@ -513,11 +516,13 @@ fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id:\n }\n \n pub fn check_coherence(crate_context: &CrateCtxt) {\n+    let _task = crate_context.tcx.dep_graph.in_task(DepNode::Coherence);\n+    let infcx = new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None, true);\n     CoherenceChecker {\n         crate_context: crate_context,\n-        inference_context: new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None, true),\n+        inference_context: infcx,\n         inherent_impls: RefCell::new(FnvHashMap()),\n-    }.check(crate_context.tcx.map.krate());\n+    }.check();\n     unsafety::check(crate_context.tcx);\n     orphan::check(crate_context.tcx);\n     overlap::check(crate_context.tcx);"}, {"sha": "69eb7f51f37852228d2a41f30eaba1e2b6e50507", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -17,12 +17,13 @@ use middle::traits;\n use middle::ty;\n use syntax::ast;\n use syntax::codemap::Span;\n+use rustc::dep_graph::DepNode;\n use rustc_front::intravisit;\n use rustc_front::hir;\n \n pub fn check(tcx: &ty::ctxt) {\n     let mut orphan = OrphanChecker { tcx: tcx };\n-    tcx.map.krate().visit_all_items(&mut orphan);\n+    tcx.visit_all_items_in_krate(DepNode::CoherenceOrphanCheck, &mut orphan);\n }\n \n struct OrphanChecker<'cx, 'tcx:'cx> {\n@@ -234,10 +235,10 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                     }\n                     Err(traits::OrphanCheckErr::UncoveredTy(param_ty)) => {\n                         span_err!(self.tcx.sess, item.span, E0210,\n-                                \"type parameter `{}` must be used as the type parameter for \\\n-                                 some local type (e.g. `MyStruct<T>`); only traits defined in \\\n-                                 the current crate can be implemented for a type parameter\",\n-                                param_ty);\n+                                  \"type parameter `{}` must be used as the type parameter for \\\n+                                   some local type (e.g. `MyStruct<T>`); only traits defined in \\\n+                                   the current crate can be implemented for a type parameter\",\n+                                  param_ty);\n                         return;\n                     }\n                 }"}, {"sha": "71c6fc1fd08ec7ad516dfc946d423f2595dc7172", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -18,53 +18,53 @@ use middle::ty;\n use middle::infer;\n use syntax::ast;\n use syntax::codemap::Span;\n+use rustc::dep_graph::DepNode;\n use rustc_front::hir;\n use rustc_front::intravisit;\n-use util::nodemap::DefIdMap;\n+use util::nodemap::{DefIdMap, DefIdSet};\n \n pub fn check(tcx: &ty::ctxt) {\n-    let mut overlap = OverlapChecker { tcx: tcx, default_impls: DefIdMap() };\n-    overlap.check_for_overlapping_impls();\n+    let mut overlap = OverlapChecker { tcx: tcx,\n+                                       traits_checked: DefIdSet(),\n+                                       default_impls: DefIdMap() };\n \n     // this secondary walk specifically checks for some other cases,\n     // like defaulted traits, for which additional overlap rules exist\n-    tcx.map.krate().visit_all_items(&mut overlap);\n+    tcx.visit_all_items_in_krate(DepNode::CoherenceOverlapCheckSpecial, &mut overlap);\n }\n \n struct OverlapChecker<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>,\n \n+    // The set of traits where we have checked for overlap.  This is\n+    // used to avoid checking the same trait twice.\n+    //\n+    // NB. It's ok to skip tracking this set because we fully\n+    // encapsulate it, and we always create a task\n+    // (`CoherenceOverlapCheck`) corresponding to each entry.\n+    traits_checked: DefIdSet,\n+\n     // maps from a trait def-id to an impl id\n     default_impls: DefIdMap<ast::NodeId>,\n }\n \n impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n-    fn check_for_overlapping_impls(&self) {\n-        debug!(\"check_for_overlapping_impls\");\n-\n-        // Collect this into a vector to avoid holding the\n-        // refcell-lock during the\n-        // check_for_overlapping_impls_of_trait() check, since that\n-        // check can populate this table further with impls from other\n-        // crates.\n-        let trait_defs: Vec<_> = self.tcx.trait_defs.borrow().values().cloned().collect();\n-\n-        for trait_def in trait_defs {\n-            self.tcx.populate_implementations_for_trait_if_necessary(trait_def.trait_ref.def_id);\n-            self.check_for_overlapping_impls_of_trait(trait_def);\n+    fn check_for_overlapping_impls_of_trait(&mut self, trait_def_id: DefId) {\n+        debug!(\"check_for_overlapping_impls_of_trait(trait_def_id={:?})\",\n+               trait_def_id);\n+\n+        let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n+        if !self.traits_checked.insert(trait_def_id) {\n+            return;\n         }\n-    }\n \n-    fn check_for_overlapping_impls_of_trait(&self,\n-                                            trait_def: &'tcx ty::TraitDef<'tcx>)\n-    {\n-        debug!(\"check_for_overlapping_impls_of_trait(trait_def={:?})\",\n-               trait_def);\n+        let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n+        self.tcx.populate_implementations_for_trait_if_necessary(\n+            trait_def.trait_ref.def_id);\n \n         // We should already know all impls of this trait, so these\n         // borrows are safe.\n-        let blanket_impls = trait_def.blanket_impls.borrow();\n-        let nonblanket_impls = trait_def.nonblanket_impls.borrow();\n+        let (blanket_impls, nonblanket_impls) = trait_def.borrow_impl_lists(self.tcx);\n \n         // Conflicts can only occur between a blanket impl and another impl,\n         // or between 2 non-blanket impls of the same kind.\n@@ -175,12 +175,20 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemDefaultImpl(_, _) => {\n+            hir::ItemTrait(..) => {\n+                let trait_def_id = self.tcx.map.local_def_id(item.id);\n+                self.check_for_overlapping_impls_of_trait(trait_def_id);\n+            }\n+\n+            hir::ItemDefaultImpl(..) => {\n                 // look for another default impl; note that due to the\n                 // general orphan/coherence rules, it must always be\n                 // in this crate.\n                 let impl_def_id = self.tcx.map.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n+\n+                self.check_for_overlapping_impls_of_trait(trait_ref.def_id);\n+\n                 let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n                 match prev_default_impl {\n                     Some(prev_id) => {\n@@ -195,6 +203,7 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 let impl_def_id = self.tcx.map.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n+                self.check_for_overlapping_impls_of_trait(trait_def_id);\n                 match trait_ref.self_ty().sty {\n                     ty::TyTrait(ref data) => {\n                         // This is something like impl Trait1 for Trait2. Illegal"}, {"sha": "5a9b899175837c4259f546fce4b6eca6b7ee4b58", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 39, "deletions": 62, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -34,13 +34,12 @@ lazilly and on demand, and include logic that checks for cycles.\n Demand is driven by calls to `AstConv::get_item_type_scheme` or\n `AstConv::lookup_trait_def`.\n \n-Currently, we \"convert\" types and traits in three phases (note that\n+Currently, we \"convert\" types and traits in two phases (note that\n conversion only affects the types of items / enum variants / methods;\n it does not e.g. compute the types of individual expressions):\n \n 0. Intrinsics\n-1. Trait definitions\n-2. Type definitions\n+1. Trait/Type definitions\n \n Conversion itself is done by simply walking each of the items in turn\n and invoking an appropriate function (e.g., `trait_def_of_item` or\n@@ -56,11 +55,6 @@ There are some shortcomings in this design:\n - Because the type scheme includes defaults, cycles through type\n   parameter defaults are illegal even if those defaults are never\n   employed. This is not necessarily a bug.\n-- The phasing of trait definitions before type definitions does not\n-  seem to be necessary, sufficient, or particularly helpful, given that\n-  processing a trait definition can trigger processing a type def and\n-  vice versa. However, if I remove it, I get ICEs, so some more work is\n-  needed in that area. -nmatsakis\n \n */\n \n@@ -79,12 +73,13 @@ use middle::ty::{VariantKind};\n use middle::ty::fold::{TypeFolder};\n use middle::ty::util::IntTypeExt;\n use rscope::*;\n+use rustc::dep_graph::DepNode;\n use rustc::front::map as hir_map;\n-use util::common::{ErrorReported, memoized};\n+use util::common::{ErrorReported, MemoizationMap};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use write_ty_to_tcx;\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::RefCell;\n use std::collections::HashSet;\n use std::rc::Rc;\n \n@@ -104,9 +99,6 @@ use rustc_front::print::pprust;\n pub fn collect_item_types(tcx: &ty::ctxt) {\n     let ccx = &CrateCtxt { tcx: tcx, stack: RefCell::new(Vec::new()) };\n \n-    let mut visitor = CollectTraitDefVisitor{ ccx: ccx };\n-    ccx.tcx.map.krate().visit_all_items(&mut visitor);\n-\n     let mut visitor = CollectItemTypesVisitor{ ccx: ccx };\n     ccx.tcx.map.krate().visit_all_items(&mut visitor);\n }\n@@ -146,41 +138,17 @@ enum AstConvRequest {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// First phase: just collect *trait definitions* -- basically, the set\n-// of type parameters and supertraits. This is information we need to\n-// know later when parsing field defs.\n-\n-struct CollectTraitDefVisitor<'a, 'tcx: 'a> {\n-    ccx: &'a CrateCtxt<'a, 'tcx>\n-}\n-\n-impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CollectTraitDefVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &hir::Item) {\n-        match i.node {\n-            hir::ItemTrait(..) => {\n-                // computing the trait def also fills in the table\n-                let _ = trait_def_of_item(self.ccx, i);\n-            }\n-            _ => { }\n-        }\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Second phase: collection proper.\n \n struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n     ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &hir::Item) {\n-        convert_item(self.ccx, i);\n-        intravisit::walk_item(self, i);\n-    }\n-    fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n-        convert_foreign_item(self.ccx, i);\n-        intravisit::walk_foreign_item(self, i);\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        let tcx = self.ccx.tcx;\n+        let item_def_id = tcx.map.local_def_id(item.id);\n+        let _task = tcx.dep_graph.in_task(DepNode::CollectItem(item_def_id));\n+        convert_item(self.ccx, item);\n     }\n }\n \n@@ -703,8 +671,12 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n     debug!(\"convert: item {} with id {}\", it.name, it.id);\n     match it.node {\n         // These don't define types.\n-        hir::ItemExternCrate(_) | hir::ItemUse(_) |\n-        hir::ItemForeignMod(_) | hir::ItemMod(_) => {\n+        hir::ItemExternCrate(_) | hir::ItemUse(_) | hir::ItemMod(_) => {\n+        }\n+        hir::ItemForeignMod(ref foreign_mod) => {\n+            for item in &foreign_mod.items {\n+                convert_foreign_item(ccx, item);\n+            }\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n             let (scheme, predicates) = convert_typed_item(ccx, it);\n@@ -1283,16 +1255,11 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         substs: substs,\n     };\n \n-    let trait_def = ty::TraitDef {\n-        paren_sugar: paren_sugar,\n-        unsafety: unsafety,\n-        generics: ty_generics,\n-        trait_ref: trait_ref,\n-        associated_type_names: associated_type_names,\n-        nonblanket_impls: RefCell::new(FnvHashMap()),\n-        blanket_impls: RefCell::new(vec![]),\n-        flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS)\n-    };\n+    let trait_def = ty::TraitDef::new(unsafety,\n+                                      paren_sugar,\n+                                      ty_generics,\n+                                      trait_ref,\n+                                      associated_type_names);\n \n     return tcx.intern_trait_def(trait_def);\n \n@@ -1452,12 +1419,17 @@ fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n }\n \n fn type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                                it: &hir::Item)\n+                                item: &hir::Item)\n                                 -> ty::TypeScheme<'tcx>\n {\n-    memoized(&ccx.tcx.tcache,\n-             ccx.tcx.map.local_def_id(it.id),\n-             |_| compute_type_scheme_of_item(ccx, it))\n+    let item_def_id = ccx.tcx.map.local_def_id(item.id);\n+    ccx.tcx.tcache.memoize(item_def_id, || {\n+        // NB. Since the `memoized` function enters a new task, and we\n+        // are giving this task access to the item `item`, we must\n+        // register a read.\n+        ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n+        compute_type_scheme_of_item(ccx, item)\n+    })\n }\n \n fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n@@ -1571,13 +1543,18 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn type_scheme_of_foreign_item<'a, 'tcx>(\n     ccx: &CrateCtxt<'a, 'tcx>,\n-    it: &hir::ForeignItem,\n+    item: &hir::ForeignItem,\n     abi: abi::Abi)\n     -> ty::TypeScheme<'tcx>\n {\n-    memoized(&ccx.tcx.tcache,\n-             ccx.tcx.map.local_def_id(it.id),\n-             |_| compute_type_scheme_of_foreign_item(ccx, it, abi))\n+    let item_def_id = ccx.tcx.map.local_def_id(item.id);\n+    ccx.tcx.tcache.memoize(item_def_id, || {\n+        // NB. Since the `memoized` function enters a new task, and we\n+        // are giving this task access to the item `item`, we must\n+        // register a read.\n+        ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n+        compute_type_scheme_of_foreign_item(ccx, item, abi)\n+    })\n }\n \n fn compute_type_scheme_of_foreign_item<'a, 'tcx>("}, {"sha": "580d200eb73a71c06494a119f61817ab0cc42afe", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -92,6 +92,7 @@ extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_front;\n extern crate rustc_back;\n \n+pub use rustc::dep_graph;\n pub use rustc::front;\n pub use rustc::lint;\n pub use rustc::middle;"}, {"sha": "ce0e9e14035f51073965dccb22157995648eb48c", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -266,6 +266,7 @@ use self::ParamKind::*;\n \n use arena;\n use arena::TypedArena;\n+use dep_graph::DepNode;\n use middle::def_id::DefId;\n use middle::resolve_lifetime as rl;\n use middle::subst;\n@@ -280,6 +281,7 @@ use rustc_front::intravisit::Visitor;\n use util::nodemap::NodeMap;\n \n pub fn infer_variance(tcx: &ty::ctxt) {\n+    let _task = tcx.dep_graph.in_task(DepNode::Variance);\n     let krate = tcx.map.krate();\n     let mut arena = arena::TypedArena::new();\n     let terms_cx = determine_parameters_to_be_inferred(tcx, &mut arena, krate);"}, {"sha": "d57d1bcd92da505454cb45ad23818b0550cbb6ff", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -154,6 +154,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n                                         &name,\n                                         resolve::MakeGlobMap::No,\n                                         |tcx, _, analysis| {\n+        let _ignore = tcx.dep_graph.in_ignore();\n         let ty::CrateAnalysis { access_levels, .. } = analysis;\n \n         // Convert from a NodeId set to a DefId set since we don't always have easy access"}, {"sha": "c281571305b8bc7de8f4df9c4af3af69a4b368f0", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -326,6 +326,14 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                        \"the `#[rustc_error]` attribute \\\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\")),\n+    (\"rustc_if_this_changed\", Whitelisted, Gated(\"rustc_attrs\",\n+                                       \"the `#[rustc_if_this_changed]` attribute \\\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\")),\n+    (\"rustc_then_this_would_need\", Whitelisted, Gated(\"rustc_attrs\",\n+                                       \"the `#[rustc_if_this_changed]` attribute \\\n+                                        is just used for rustc unit tests \\\n+                                        and will never be stable\")),\n     (\"rustc_move_fragments\", Normal, Gated(\"rustc_attrs\",\n                                            \"the `#[rustc_move_fragments]` attribute \\\n                                             is just used for rustc unit tests \\"}, {"sha": "acd6091cbdd482c93319d7474ecaa14473dcfac5", "filename": "src/test/compile-fail/dep-graph-caller-callee.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Ftest%2Fcompile-fail%2Fdep-graph-caller-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Ftest%2Fcompile-fail%2Fdep-graph-caller-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-caller-callee.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that immediate callers have to change when callee changes, but\n+// not callers' callers.\n+\n+// compile-flags: -Z incr-comp\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+fn main() { }\n+\n+mod x {\n+    #[rustc_if_this_changed]\n+    pub fn x() { }\n+}\n+\n+mod y {\n+    use x;\n+\n+    // These dependencies SHOULD exist:\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR OK\n+    pub fn y() {\n+        x::x();\n+    }\n+}\n+\n+mod z {\n+    use y;\n+\n+    // These are expected to yield errors, because changes to `x`\n+    // affect the BODY of `y`, but not its signature.\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR no path\n+    pub fn z() {\n+        y::y();\n+    }\n+}"}, {"sha": "5cfb748b6f4596f188d69f321edce56403a82261", "filename": "src/test/compile-fail/dep-graph-struct-signature.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-struct-signature.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test cases where a changing struct appears in the signature of fns\n+// and methods.\n+\n+// compile-flags: -Z incr-comp\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+\n+fn main() { }\n+\n+#[rustc_if_this_changed]\n+struct WillChange {\n+    x: u32,\n+    y: u32\n+}\n+\n+struct WontChange {\n+    x: u32,\n+    y: u32\n+}\n+\n+// these are valid dependencies\n+mod signatures {\n+    use WillChange;\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    trait Bar {\n+        fn do_something(x: WillChange);\n+    }\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    fn some_fn(x: WillChange) { }\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    fn new_foo(x: u32, y: u32) -> WillChange {\n+        WillChange { x: x, y: y }\n+    }\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    impl WillChange {\n+        fn new(x: u32, y: u32) -> WillChange { loop { } }\n+    }\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    impl WillChange {\n+        fn method(&self, x: u32) { }\n+    }\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    struct WillChanges {\n+        x: WillChange,\n+        y: WillChange\n+    }\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    fn indirect(x: WillChanges) { }\n+}\n+\n+// these are invalid dependencies, though sometimes we create edges\n+// anyway.\n+mod invalid_signatures {\n+    use WontChange;\n+\n+    // FIXME due to the variance pass having overly conservative edges,\n+    // we incorrectly think changes are needed here\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    trait A {\n+        fn do_something_else_twice(x: WontChange);\n+    }\n+\n+    // FIXME due to the variance pass having overly conservative edges,\n+    // we incorrectly think changes are needed here\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR OK\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR OK\n+    fn b(x: WontChange) { }\n+\n+    #[rustc_then_this_would_need(ItemSignature)] //~ ERROR no path from `WillChange`\n+    #[rustc_then_this_would_need(CollectItem)] //~ ERROR no path from `WillChange`\n+    fn c(x: u32) { }\n+}\n+"}, {"sha": "57e83586d8d37b79c5b32c87fb0c5081b21e8127", "filename": "src/test/compile-fail/dep-graph-trait-impl-two-traits-same-method.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits-same-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits-same-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits-same-method.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that adding an impl to a trait `Foo` DOES affect functions\n+// that only use `Bar` if they have methods in common.\n+\n+// compile-flags: -Z incr-comp\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+fn main() { }\n+\n+pub trait Foo: Sized {\n+    fn method(self) { }\n+}\n+\n+pub trait Bar: Sized {\n+    fn method(self) { }\n+}\n+\n+mod x {\n+    use {Foo, Bar};\n+\n+    #[rustc_if_this_changed]\n+    impl Foo for u32 { }\n+\n+    impl Bar for char { }\n+}\n+\n+mod y {\n+    use {Foo, Bar};\n+\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR OK\n+    pub fn with_char() {\n+        char::method('a');\n+    }\n+}\n+\n+mod z {\n+    use y;\n+\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+    pub fn z() {\n+        y::with_char();\n+    }\n+}"}, {"sha": "ba54a056209454720f1012c6233b723140fb7ed7", "filename": "src/test/compile-fail/dep-graph-trait-impl-two-traits.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl-two-traits.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that adding an impl to a trait `Foo` does not affect functions\n+// that only use `Bar`, so long as they do not have methods in common.\n+\n+// compile-flags: -Z incr-comp\n+\n+#![feature(rustc_attrs)]\n+#![allow(warnings)]\n+\n+fn main() { }\n+\n+pub trait Foo: Sized {\n+    fn foo(self) { }\n+}\n+\n+pub trait Bar: Sized {\n+    fn bar(self) { }\n+}\n+\n+mod x {\n+    use {Foo, Bar};\n+\n+    #[rustc_if_this_changed]\n+    impl Foo for char { }\n+\n+    impl Bar for char { }\n+}\n+\n+mod y {\n+    use {Foo, Bar};\n+\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+    pub fn call_bar() {\n+        char::bar('a');\n+    }\n+}\n+\n+mod z {\n+    use y;\n+\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+    pub fn z() {\n+        y::call_bar();\n+    }\n+}"}, {"sha": "83e924fe06d7dfd223f57744b53fe32a95a9f0a5", "filename": "src/test/compile-fail/dep-graph-trait-impl.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-trait-impl.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that when a trait impl changes, fns whose body uses that trait\n+// must also be recompiled.\n+\n+// compile-flags: -Z incr-comp\n+\n+#![feature(rustc_attrs)]\n+#![allow(warnings)]\n+\n+fn main() { }\n+\n+pub trait Foo: Sized {\n+    fn method(self) { }\n+}\n+\n+mod x {\n+    use Foo;\n+\n+    #[rustc_if_this_changed]\n+    impl Foo for char { }\n+\n+    impl Foo for u32 { }\n+}\n+\n+mod y {\n+    use Foo;\n+\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR OK\n+    pub fn with_char() {\n+        char::method('a');\n+    }\n+\n+    // FIXME(#30741) tcx fulfillment cache not tracked\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR no path\n+    pub fn take_foo_with_char() {\n+        take_foo::<char>('a');\n+    }\n+\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR OK\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR OK\n+    pub fn with_u32() {\n+        u32::method(22);\n+    }\n+\n+    // FIXME(#30741) tcx fulfillment cache not tracked\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR no path\n+    pub fn take_foo_with_u32() {\n+        take_foo::<u32>(22);\n+    }\n+\n+    pub fn take_foo<T:Foo>(t: T) { }\n+}\n+\n+mod z {\n+    use y;\n+\n+    // These are expected to yield errors, because changes to `x`\n+    // affect the BODY of `y`, but not its signature.\n+    #[rustc_then_this_would_need(TypeckItemBody)] //~ ERROR no path\n+    #[rustc_then_this_would_need(TransCrateItem)] //~ ERROR no path\n+    pub fn z() {\n+        y::with_char();\n+        y::with_u32();\n+    }\n+}"}, {"sha": "8feec12a2f76c975d9cb284db890445c65771870", "filename": "src/test/compile-fail/dep-graph-unrelated.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Ftest%2Fcompile-fail%2Fdep-graph-unrelated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8c337b5ca883285e6215f1f669d5556842d1520/src%2Ftest%2Fcompile-fail%2Fdep-graph-unrelated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep-graph-unrelated.rs?ref=e8c337b5ca883285e6215f1f669d5556842d1520", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that two unrelated functions have no trans dependency.\n+\n+// compile-flags: -Z incr-comp\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+#[rustc_if_this_changed]\n+fn main() { }\n+\n+#[rustc_then_this_would_need(TransCrateItem)] //~ ERROR no path from `main`\n+fn bar() { }"}]}