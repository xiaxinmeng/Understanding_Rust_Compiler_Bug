{"sha": "784e28e218a12fcf8fd9caaca62798d7c18068b2", "node_id": "C_kwDOAAsO6NoAKDc4NGUyOGUyMThhMTJmY2Y4ZmQ5Y2FhY2E2Mjc5OGQ3YzE4MDY4YjI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-06-11T20:21:38Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-06-17T03:21:52Z"}, "message": "Subtype FRU fields first in type_changing_struct_update", "tree": {"sha": "473109fb6ce2763a572532be0dbc40a01925e35f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/473109fb6ce2763a572532be0dbc40a01925e35f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/784e28e218a12fcf8fd9caaca62798d7c18068b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/784e28e218a12fcf8fd9caaca62798d7c18068b2", "html_url": "https://github.com/rust-lang/rust/commit/784e28e218a12fcf8fd9caaca62798d7c18068b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/784e28e218a12fcf8fd9caaca62798d7c18068b2/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "349bda2051e94b7aefb33d6541f48f561bf06dbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/349bda2051e94b7aefb33d6541f48f561bf06dbc", "html_url": "https://github.com/rust-lang/rust/commit/349bda2051e94b7aefb33d6541f48f561bf06dbc"}], "stats": {"total": 171, "additions": 93, "deletions": 78}, "files": [{"sha": "37d12b4ed5da4cc9d04fb22cbada32ceec5f60df", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 58, "deletions": 61, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/784e28e218a12fcf8fd9caaca62798d7c18068b2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784e28e218a12fcf8fd9caaca62798d7c18068b2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=784e28e218a12fcf8fd9caaca62798d7c18068b2", "patch": "@@ -1561,73 +1561,70 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // FIXME: We are currently creating two branches here in order to maintain\n             // consistency. But they should be merged as much as possible.\n             let fru_tys = if self.tcx.features().type_changing_struct_update {\n-                if let ty::Adt(adt, substs) = adt_ty.kind() && adt.is_struct() {\n-                    // Make an ADT with fresh inference substitutions. This\n-                    // will allow us to guide inference along so that, e.g.\n+                if adt.is_struct() {\n+                    // Make some fresh substitutions for our ADT type.\n+                    let fresh_substs = self.fresh_substs_for_item(base_expr.span, adt.did());\n+                    // We do subtyping on the FRU fields first, so we can\n+                    // learn exactly what types we expect the base expr\n+                    // needs constrained to be compatible with the struct\n+                    // type we expect from the expectation value.\n+                    let fru_tys = variant\n+                        .fields\n+                        .iter()\n+                        .map(|f| {\n+                            let fru_ty = self.normalize_associated_types_in(\n+                                expr_span,\n+                                self.field_ty(base_expr.span, f, fresh_substs),\n+                            );\n+                            let ident = self.tcx.adjust_ident(f.ident(self.tcx), variant.def_id);\n+                            if let Some(_) = remaining_fields.remove(&ident) {\n+                                let target_ty = self.field_ty(base_expr.span, f, substs);\n+                                let cause = self.misc(base_expr.span);\n+                                match self.at(&cause, self.param_env).sup(target_ty, fru_ty) {\n+                                    Ok(InferOk { obligations, value: () }) => {\n+                                        self.register_predicates(obligations)\n+                                    }\n+                                    Err(_) => {\n+                                        // This should never happen, since we're just subtyping the\n+                                        // remaining_fields, but it's fine to emit this, I guess.\n+                                        self.report_mismatched_types(\n+                                            &cause,\n+                                            target_ty,\n+                                            fru_ty,\n+                                            FieldMisMatch(variant.name, ident.name),\n+                                        )\n+                                        .emit();\n+                                    }\n+                                }\n+                            }\n+                            self.resolve_vars_if_possible(fru_ty)\n+                        })\n+                        .collect();\n+                    // The use of fresh substs that we have subtyped against\n+                    // our base ADT type's fields allows us to guide inference\n+                    // along so that, e.g.\n                     // ```\n-                    // let x = MyStruct<'a, B, const C: usize> {\n-                    //    f: 1,\n-                    //    ..Default::default()\n+                    // MyStruct<'a, F1, F2, const C: usize> {\n+                    //     f: F1,\n+                    //     // Other fields that reference `'a`, `F2`, and `C`\n+                    // }\n+                    //\n+                    // let x = MyStruct {\n+                    //    f: 1usize,\n+                    //    ..other_struct\n                     // };\n                     // ```\n-                    // will have the default base expression constrained to\n-                    // `MyStruct<'_, _, _>`, as opposed to just `_`... This\n-                    // will allow us to then do a subtyping relation on all\n-                    // of the `remaining_fields` below, per the RFC.\n-                    let fresh_substs = self.fresh_substs_for_item(base_expr.span, adt.did());\n+                    // will have the `other_struct` expression constrained to\n+                    // `MyStruct<'a, _, F2, C>`, as opposed to just `_`...\n+                    // This is important to allow coercions to happen in\n+                    // `other_struct` itself. See `coerce-in-base-expr.rs`.\n                     let fresh_base_ty = self.tcx.mk_adt(*adt, fresh_substs);\n-                    let base_ty = self.check_expr_has_type_or_error(\n+                    self.check_expr_has_type_or_error(\n                         base_expr,\n-                        fresh_base_ty,\n-                        |_| {\n-                            error_happened = true;\n-                        },\n+                        self.resolve_vars_if_possible(fresh_base_ty),\n+                        |_| {},\n                     );\n-                    let base_ty = self.shallow_resolve(base_ty);\n-                    if let ty::Adt(base_adt, base_substs) = base_ty.kind() && adt == base_adt {\n-                        variant\n-                            .fields\n-                            .iter()\n-                            .map(|f| {\n-                                let fru_ty = self.normalize_associated_types_in(\n-                                    expr_span,\n-                                    self.field_ty(base_expr.span, f, base_substs),\n-                                );\n-                                let ident = self\n-                                    .tcx\n-                                    .adjust_ident(f.ident(self.tcx), variant.def_id);\n-                                if let Some(_) = remaining_fields.remove(&ident) {\n-                                    let target_ty =\n-                                        self.field_ty(base_expr.span, f, substs);\n-                                    let cause = self.misc(base_expr.span);\n-                                    match self\n-                                        .at(&cause, self.param_env)\n-                                        .sup(target_ty, fru_ty)\n-                                    {\n-                                        Ok(InferOk { obligations, value: () }) => {\n-                                            self.register_predicates(obligations)\n-                                        }\n-                                        // FIXME: Need better diagnostics for `FieldMisMatch` error\n-                                        Err(_) => {\n-                                            self.report_mismatched_types(\n-                                                &cause,\n-                                                target_ty,\n-                                                fru_ty,\n-                                                FieldMisMatch(variant.name, ident.name),\n-                                            )\n-                                            .emit();\n-                                        }\n-                                    }\n-                                }\n-                                self.resolve_vars_if_possible(fru_ty)\n-                            })\n-                            .collect()\n-                    } else {\n-                        if !error_happened && !base_ty.references_error() {\n-                            span_bug!(base_expr.span, \"expected an error to have been reported in `check_expr_has_type_or_error`\");\n-                        }\n-                        return;\n-                    }\n+                    fru_tys\n                 } else {\n                     // Check the base_expr, regardless of a bad expected adt_ty, so we can get\n                     // type errors on that expression, too."}, {"sha": "75e48bf4a482a811581d87a19d96b9133c06f8dd", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/coerce-in-base-expr.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/784e28e218a12fcf8fd9caaca62798d7c18068b2/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Fcoerce-in-base-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784e28e218a12fcf8fd9caaca62798d7c18068b2/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Fcoerce-in-base-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Fcoerce-in-base-expr.rs?ref=784e28e218a12fcf8fd9caaca62798d7c18068b2", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+\n+#![feature(type_changing_struct_update)]\n+#![allow(incomplete_features)]\n+\n+use std::any::Any;\n+\n+struct Foo<A, B: ?Sized, C: ?Sized> {\n+    a: A,\n+    b: Box<B>,\n+    c: Box<C>,\n+}\n+\n+struct B;\n+struct C;\n+\n+fn main() {\n+    let y = Foo::<usize, dyn Any, dyn Any> {\n+        a: 0,\n+        b: Box::new(B),\n+        ..Foo {\n+            a: 0,\n+            b: Box::new(B),\n+            // C needs to be told to coerce to `Box<dyn Any>`\n+            c: Box::new(C),\n+        }\n+    };\n+}"}, {"sha": "dae1241d35a5fc12f6aff1ba378b190b3be26eb2", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/type-generic-update.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/784e28e218a12fcf8fd9caaca62798d7c18068b2/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/784e28e218a12fcf8fd9caaca62798d7c18068b2/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.rs?ref=784e28e218a12fcf8fd9caaca62798d7c18068b2", "patch": "@@ -50,7 +50,6 @@ fn fail_update() {\n     let m3 = Machine::<i32, i32> {\n         ..m1\n         //~^ ERROR mismatched types [E0308]\n-        //~| ERROR mismatched types [E0308]\n     };\n }\n "}, {"sha": "6f31b1a962078509c99bf0331838025fc38ebdca", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/type-generic-update.stderr", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/784e28e218a12fcf8fd9caaca62798d7c18068b2/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/784e28e218a12fcf8fd9caaca62798d7c18068b2/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Ftype-generic-update.stderr?ref=784e28e218a12fcf8fd9caaca62798d7c18068b2", "patch": "@@ -2,29 +2,20 @@ error[E0308]: mismatched types\n   --> $DIR/type-generic-update.rs:46:11\n    |\n LL |         ..m1\n-   |           ^^ field type mismatch: Machine.state\n+   |           ^^ expected `i32`, found `f64`\n    |\n-   = note: expected type `i32`\n-              found type `f64`\n+   = note: expected struct `Machine<'_, i32, _>`\n+              found struct `Machine<'_, f64, _>`\n \n error[E0308]: mismatched types\n   --> $DIR/type-generic-update.rs:51:11\n    |\n LL |         ..m1\n-   |           ^^ field type mismatch: Machine.state\n+   |           ^^ expected `i32`, found `f64`\n    |\n-   = note: expected type `i32`\n-              found type `f64`\n+   = note: expected struct `Machine<'_, i32, i32>`\n+              found struct `Machine<'_, f64, f64>`\n \n-error[E0308]: mismatched types\n-  --> $DIR/type-generic-update.rs:51:11\n-   |\n-LL |         ..m1\n-   |           ^^ field type mismatch: Machine.message\n-   |\n-   = note: expected type `i32`\n-              found type `f64`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}