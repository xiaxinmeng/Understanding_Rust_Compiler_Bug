{"sha": "fc595f1a555d7f43802679511e9fdf1f64f2c49a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNTk1ZjFhNTU1ZDdmNDM4MDI2Nzk1MTFlOWZkZjFmNjRmMmM0OWE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-01-26T20:41:20Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-01-26T20:41:20Z"}, "message": "[WIP] Use FnAbi everywhere instead of our own abi calculations", "tree": {"sha": "e4301fadd2021859eeda2cd2f024750dafb62e85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4301fadd2021859eeda2cd2f024750dafb62e85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc595f1a555d7f43802679511e9fdf1f64f2c49a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc595f1a555d7f43802679511e9fdf1f64f2c49a", "html_url": "https://github.com/rust-lang/rust/commit/fc595f1a555d7f43802679511e9fdf1f64f2c49a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc595f1a555d7f43802679511e9fdf1f64f2c49a/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4555737152c0f68df5596b16d6e996d19caf2a6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4555737152c0f68df5596b16d6e996d19caf2a6a", "html_url": "https://github.com/rust-lang/rust/commit/4555737152c0f68df5596b16d6e996d19caf2a6a"}], "stats": {"total": 672, "additions": 355, "deletions": 317}, "files": [{"sha": "41cb4c627f899440c6a09df0bd2f05d9240ced7f", "filename": "src/abi/comments.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=fc595f1a555d7f43802679511e9fdf1f64f2c49a", "patch": "@@ -4,7 +4,7 @@\n use std::borrow::Cow;\n \n use rustc_middle::mir;\n-use rustc_target::abi::call::ArgAbi;\n+use rustc_target::abi::call::PassMode;\n \n use cranelift_codegen::entity::EntityRef;\n \n@@ -23,7 +23,8 @@ pub(super) fn add_arg_comment<'tcx>(\n     local: Option<mir::Local>,\n     local_field: Option<usize>,\n     params: EmptySinglePair<Value>,\n-    arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n+    arg_abi_mode: PassMode,\n+    arg_layout: TyAndLayout<'tcx>,\n ) {\n     let local = if let Some(local) = local {\n         Cow::Owned(format!(\"{:?}\", local))\n@@ -42,15 +43,15 @@ pub(super) fn add_arg_comment<'tcx>(\n         Pair(param_a, param_b) => Cow::Owned(format!(\"= {:?}, {:?}\", param_a, param_b)),\n     };\n \n-    let pass_mode = format!(\"{:?}\", arg_abi.mode);\n+    let pass_mode = format!(\"{:?}\", arg_abi_mode);\n     fx.add_global_comment(format!(\n         \"{kind:5}{local:>3}{local_field:<5} {params:10} {pass_mode:36} {ty:?}\",\n         kind = kind,\n         local = local,\n         local_field = local_field,\n         params = params,\n         pass_mode = pass_mode,\n-        ty = arg_abi.layout.ty,\n+        ty = arg_layout.ty,\n     ));\n }\n "}, {"sha": "55ebd39e3f132f181ad43c2763778a54e61e9926", "filename": "src/abi/mod.rs", "status": "modified", "additions": 102, "deletions": 125, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=fc595f1a555d7f43802679511e9fdf1f64f2c49a", "patch": "@@ -6,7 +6,8 @@ mod pass_mode;\n mod returning;\n \n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc_target::abi::call::PassMode as RustcPassMode;\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_target::abi::call::{Conv, FnAbi};\n use rustc_target::spec::abi::Abi;\n \n use cranelift_codegen::ir::AbiParam;\n@@ -16,6 +17,7 @@ use crate::prelude::*;\n \n pub(crate) use self::returning::{can_return_to_ssa_var, codegen_return};\n \n+// FIXME remove\n // Copied from https://github.com/rust-lang/rust/blob/f52c72948aa1dd718cc1f168d21c91c584c0a662/src/librustc_middle/ty/layout.rs#L2301\n #[rustfmt::skip]\n pub(crate) fn fn_sig_for_fn_abi<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> ty::PolyFnSig<'tcx> {\n@@ -93,84 +95,38 @@ pub(crate) fn fn_sig_for_fn_abi<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx\n     }\n }\n \n-fn clif_sig_from_fn_sig<'tcx>(\n+fn clif_sig_from_fn_abi<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     triple: &target_lexicon::Triple,\n-    sig: FnSig<'tcx>,\n-    is_vtable_fn: bool,\n-    requires_caller_location: bool,\n+    fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n ) -> Signature {\n-    let abi = match sig.abi {\n-        Abi::System => Abi::C,\n-        abi => abi,\n-    };\n-    let (call_conv, inputs, output): (CallConv, Vec<Ty<'tcx>>, Ty<'tcx>) = match abi {\n-        Abi::Rust => (\n-            CallConv::triple_default(triple),\n-            sig.inputs().to_vec(),\n-            sig.output(),\n-        ),\n-        Abi::C | Abi::Unadjusted => (\n-            CallConv::triple_default(triple),\n-            sig.inputs().to_vec(),\n-            sig.output(),\n-        ),\n-        Abi::SysV64 => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n-        Abi::RustCall => {\n-            assert_eq!(sig.inputs().len(), 2);\n-            let extra_args = match sig.inputs().last().unwrap().kind() {\n-                ty::Tuple(ref tupled_arguments) => tupled_arguments,\n-                _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n-            };\n-            let mut inputs: Vec<Ty<'tcx>> = vec![sig.inputs()[0]];\n-            inputs.extend(extra_args.types());\n-            (CallConv::triple_default(triple), inputs, sig.output())\n+    let call_conv = match fn_abi.conv {\n+        Conv::Rust | Conv::C => CallConv::triple_default(triple),\n+        Conv::X86_64SysV => CallConv::SystemV,\n+        Conv::X86_64Win64 => CallConv::WindowsFastcall,\n+        Conv::ArmAapcs\n+        | Conv::Msp430Intr\n+        | Conv::PtxKernel\n+        | Conv::X86Fastcall\n+        | Conv::X86Intr\n+        | Conv::X86Stdcall\n+        | Conv::X86ThisCall\n+        | Conv::X86VectorCall\n+        | Conv::AmdGpuKernel\n+        | Conv::AvrInterrupt\n+        | Conv::AvrNonBlockingInterrupt => {\n+            todo!(\"{:?}\", fn_abi.conv)\n         }\n-        Abi::System => unreachable!(),\n-        Abi::RustIntrinsic => (\n-            CallConv::triple_default(triple),\n-            sig.inputs().to_vec(),\n-            sig.output(),\n-        ),\n-        _ => unimplemented!(\"unsupported abi {:?}\", sig.abi),\n     };\n-\n-    let inputs = inputs\n-        .into_iter()\n-        .enumerate()\n-        .map(|(i, ty)| {\n-            let mut layout = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n-            if i == 0 && is_vtable_fn {\n-                // Virtual calls turn their self param into a thin pointer.\n-                // See https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src/librustc/ty/layout.rs#L2519-L2572 for more info\n-                layout = tcx\n-                    .layout_of(ParamEnv::reveal_all().and(tcx.mk_mut_ptr(tcx.mk_unit())))\n-                    .unwrap();\n-            }\n-            let mut arg_abi = get_arg_abi(tcx, layout);\n-            if abi != Abi::Rust && abi != Abi::RustCall && abi != Abi::RustIntrinsic {\n-                match arg_abi.mode {\n-                    RustcPassMode::Indirect {\n-                        ref mut on_stack, ..\n-                    } => *on_stack = true,\n-                    _ => {}\n-                }\n-            }\n-            arg_abi.get_abi_param(tcx).into_iter()\n-        })\n+    let inputs = fn_abi\n+        .args\n+        .iter()\n+        .map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter())\n         .flatten();\n \n-    let return_arg_abi = get_arg_abi(\n-        tcx,\n-        tcx.layout_of(ParamEnv::reveal_all().and(output)).unwrap(),\n-    );\n-    let (return_ptr, returns) = return_arg_abi.get_abi_return(tcx);\n+    let (return_ptr, returns) = fn_abi.ret.get_abi_return(tcx);\n     // Sometimes the first param is an pointer to the place where the return value needs to be stored.\n-    let mut params: Vec<_> = return_ptr.into_iter().chain(inputs).collect();\n-\n-    if requires_caller_location {\n-        params.push(AbiParam::new(pointer_ty(tcx)));\n-    }\n+    let params: Vec<_> = return_ptr.into_iter().chain(inputs).collect();\n \n     Signature {\n         params,\n@@ -194,12 +150,11 @@ pub(crate) fn get_function_sig<'tcx>(\n             \"Variadic function definitions are not yet supported\",\n         );\n     }\n-    clif_sig_from_fn_sig(\n+\n+    clif_sig_from_fn_abi(\n         tcx,\n         triple,\n-        fn_sig,\n-        false,\n-        inst.def.requires_caller_location(tcx),\n+        &FnAbi::of_instance(&RevealAllLayoutCx(tcx), inst, &[]),\n     )\n }\n \n@@ -337,6 +292,9 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n         Spread(Vec<Option<CValue<'tcx>>>),\n     }\n \n+    let fn_abi = fx.fn_abi.take().unwrap();\n+    let mut arg_abis_iter = fn_abi.args.iter();\n+\n     let func_params = fx\n         .mir\n         .args_iter()\n@@ -356,14 +314,16 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n                 };\n \n                 let mut params = Vec::new();\n-                for (i, arg_ty) in tupled_arg_tys.types().enumerate() {\n-                    let param = cvalue_for_param(fx, start_block, Some(local), Some(i), arg_ty);\n+                for (i, _arg_ty) in tupled_arg_tys.types().enumerate() {\n+                    let arg_abi = arg_abis_iter.next().unwrap();\n+                    let param = cvalue_for_param(fx, start_block, Some(local), Some(i), arg_abi);\n                     params.push(param);\n                 }\n \n                 (local, ArgKind::Spread(params), arg_ty)\n             } else {\n-                let param = cvalue_for_param(fx, start_block, Some(local), None, arg_ty);\n+                let arg_abi = arg_abis_iter.next().unwrap();\n+                let param = cvalue_for_param(fx, start_block, Some(local), None, arg_abi);\n                 (local, ArgKind::Normal(param), arg_ty)\n             }\n         })\n@@ -372,11 +332,13 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n     assert!(fx.caller_location.is_none());\n     if fx.instance.def.requires_caller_location(fx.tcx) {\n         // Store caller location for `#[track_caller]`.\n-        fx.caller_location = Some(\n-            cvalue_for_param(fx, start_block, None, None, fx.tcx.caller_location_ty()).unwrap(),\n-        );\n+        let arg_abi = arg_abis_iter.next().unwrap();\n+        fx.caller_location = Some(cvalue_for_param(fx, start_block, None, None, arg_abi).unwrap());\n     }\n \n+    assert!(arg_abis_iter.next().is_none(), \"ArgAbi left behind\");\n+    fx.fn_abi = Some(fn_abi);\n+\n     fx.bcx.switch_to_block(start_block);\n     fx.bcx.ins().nop();\n \n@@ -504,6 +466,21 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         None\n     };\n \n+    let extra_args = &args[fn_sig.inputs().len()..];\n+    let extra_args = extra_args\n+        .iter()\n+        .map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx)))\n+        .collect::<Vec<_>>();\n+    let fn_abi = if let Some(instance) = instance {\n+        FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n+    } else {\n+        FnAbi::of_fn_ptr(\n+            &RevealAllLayoutCx(fx.tcx),\n+            fn_ty.fn_sig(fx.tcx),\n+            &extra_args,\n+        )\n+    };\n+\n     let is_cold = instance\n         .map(|inst| {\n             fx.tcx\n@@ -541,8 +518,8 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n     //   | indirect call target\n     //   |         | the first argument to be passed\n-    //   v         v          v virtual calls are special cased below\n-    let (func_ref, first_arg, is_virtual_call) = match instance {\n+    //   v         v\n+    let (func_ref, first_arg) = match instance {\n         // Trait object call\n         Some(Instance {\n             def: InstanceDef::Virtual(_, idx),\n@@ -553,23 +530,19 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(\n                     nop_inst,\n-                    format!(\n-                        \"virtual call; self arg pass mode: {:?}\",\n-                        get_arg_abi(fx.tcx, args[0].layout()).mode,\n-                    ),\n+                    format!(\"virtual call; self arg pass mode: {:?}\", &fn_abi.args[0],),\n                 );\n             }\n             let (ptr, method) = crate::vtable::get_ptr_and_method_ref(fx, args[0], idx);\n-            (Some(method), Single(ptr), true)\n+            (Some(method), Single(ptr))\n         }\n \n         // Normal call\n         Some(_) => (\n             None,\n             args.get(0)\n-                .map(|arg| adjust_arg_for_abi(fx, *arg))\n+                .map(|arg| adjust_arg_for_abi(fx, *arg, &fn_abi.args[0]))\n                 .unwrap_or(Empty),\n-            false,\n         ),\n \n         // Indirect call\n@@ -583,23 +556,27 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             (\n                 Some(func),\n                 args.get(0)\n-                    .map(|arg| adjust_arg_for_abi(fx, *arg))\n+                    .map(|arg| adjust_arg_for_abi(fx, *arg, &fn_abi.args[0]))\n                     .unwrap_or(Empty),\n-                false,\n             )\n         }\n     };\n \n     let ret_place = destination.map(|(place, _)| place);\n-    let (call_inst, call_args) =\n-        self::returning::codegen_with_call_return_arg(fx, fn_sig, ret_place, |fx, return_ptr| {\n+    let (call_inst, call_args) = self::returning::codegen_with_call_return_arg(\n+        fx,\n+        &fn_abi.ret,\n+        ret_place,\n+        |fx, return_ptr| {\n+            let regular_args_count = args.len();\n             let mut call_args: Vec<Value> = return_ptr\n                 .into_iter()\n                 .chain(first_arg.into_iter())\n                 .chain(\n                     args.into_iter()\n+                        .enumerate()\n                         .skip(1)\n-                        .map(|arg| adjust_arg_for_abi(fx, arg).into_iter())\n+                        .map(|(i, arg)| adjust_arg_for_abi(fx, arg, &fn_abi.args[i]).into_iter())\n                         .flatten(),\n                 )\n                 .collect::<Vec<_>>();\n@@ -610,17 +587,17 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             {\n                 // Pass the caller location for `#[track_caller]`.\n                 let caller_location = fx.get_caller_location(span);\n-                call_args.extend(adjust_arg_for_abi(fx, caller_location).into_iter());\n+                call_args.extend(\n+                    adjust_arg_for_abi(fx, caller_location, &fn_abi.args[regular_args_count])\n+                        .into_iter(),\n+                );\n+                assert_eq!(fn_abi.args.len(), regular_args_count + 1);\n+            } else {\n+                assert_eq!(fn_abi.args.len(), regular_args_count);\n             }\n \n             let call_inst = if let Some(func_ref) = func_ref {\n-                let sig = clif_sig_from_fn_sig(\n-                    fx.tcx,\n-                    fx.triple(),\n-                    fn_sig,\n-                    is_virtual_call,\n-                    false, // calls through function pointers never pass the caller location\n-                );\n+                let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n                 let sig = fx.bcx.import_signature(sig);\n                 fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n             } else {\n@@ -630,7 +607,8 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             };\n \n             (call_inst, call_args)\n-        });\n+        },\n+    );\n \n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n@@ -671,36 +649,33 @@ pub(crate) fn codegen_drop<'tcx>(\n     drop_place: CPlace<'tcx>,\n ) {\n     let ty = drop_place.layout().ty;\n-    let drop_fn = Instance::resolve_drop_in_place(fx.tcx, ty).polymorphize(fx.tcx);\n+    let drop_instance = Instance::resolve_drop_in_place(fx.tcx, ty).polymorphize(fx.tcx);\n \n-    if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n+    if let ty::InstanceDef::DropGlue(_, None) = drop_instance.def {\n         // we don't actually need to drop anything\n     } else {\n-        let drop_fn_ty = drop_fn.ty(fx.tcx, ParamEnv::reveal_all());\n-        let fn_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-            ParamEnv::reveal_all(),\n-            drop_fn_ty.fn_sig(fx.tcx),\n-        );\n-        assert_eq!(fn_sig.output(), fx.tcx.mk_unit());\n-\n         match ty.kind() {\n             ty::Dynamic(..) => {\n                 let (ptr, vtable) = drop_place.to_ptr_maybe_unsized();\n                 let ptr = ptr.get_addr(fx);\n                 let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable.unwrap());\n \n-                let sig = clif_sig_from_fn_sig(\n-                    fx.tcx,\n-                    fx.triple(),\n-                    fn_sig,\n-                    true,\n-                    false, // `drop_in_place` is never `#[track_caller]`\n-                );\n+                // FIXME(eddyb) perhaps move some of this logic into\n+                // `Instance::resolve_drop_in_place`?\n+                let virtual_drop = Instance {\n+                    def: ty::InstanceDef::Virtual(drop_instance.def_id(), 0),\n+                    substs: drop_instance.substs,\n+                };\n+                let fn_abi = FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), virtual_drop, &[]);\n+\n+                let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n                 let sig = fx.bcx.import_signature(sig);\n                 fx.bcx.ins().call_indirect(sig, drop_fn, &[ptr]);\n             }\n             _ => {\n-                assert!(!matches!(drop_fn.def, InstanceDef::Virtual(_, _)));\n+                assert!(!matches!(drop_instance.def, InstanceDef::Virtual(_, _)));\n+\n+                let fn_abi = FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), drop_instance, &[]);\n \n                 let arg_value = drop_place.place_ref(\n                     fx,\n@@ -712,17 +687,19 @@ pub(crate) fn codegen_drop<'tcx>(\n                         },\n                     )),\n                 );\n-                let arg_value = adjust_arg_for_abi(fx, arg_value);\n+                let arg_value = adjust_arg_for_abi(fx, arg_value, &fn_abi.args[0]);\n \n                 let mut call_args: Vec<Value> = arg_value.into_iter().collect::<Vec<_>>();\n \n-                if drop_fn.def.requires_caller_location(fx.tcx) {\n+                if drop_instance.def.requires_caller_location(fx.tcx) {\n                     // Pass the caller location for `#[track_caller]`.\n                     let caller_location = fx.get_caller_location(span);\n-                    call_args.extend(adjust_arg_for_abi(fx, caller_location).into_iter());\n+                    call_args.extend(\n+                        adjust_arg_for_abi(fx, caller_location, &fn_abi.args[1]).into_iter(),\n+                    );\n                 }\n \n-                let func_ref = fx.get_function_ref(drop_fn);\n+                let func_ref = fx.get_function_ref(drop_instance);\n                 fx.bcx.ins().call(func_ref, &call_args);\n             }\n         }"}, {"sha": "e2b78bfeac0ba5e7761925db86cd82996891e5c9", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 45, "deletions": 68, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=fc595f1a555d7f43802679511e9fdf1f64f2c49a", "patch": "@@ -1,9 +1,10 @@\n //! Argument passing\n \n use crate::prelude::*;\n+use crate::value_and_place::assert_assignable;\n \n use cranelift_codegen::ir::ArgumentPurpose;\n-use rustc_target::abi::call::{ArgAbi, ArgAttributes, PassMode as RustcPassMode};\n+use rustc_target::abi::call::{ArgAbi, PassMode};\n pub(super) use EmptySinglePair::*;\n \n #[derive(Copy, Clone, Debug)]\n@@ -68,8 +69,8 @@ pub(super) trait ArgAbiExt<'tcx> {\n impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n     fn get_abi_param(&self, tcx: TyCtxt<'tcx>) -> EmptySinglePair<AbiParam> {\n         match self.mode {\n-            RustcPassMode::Ignore => EmptySinglePair::Empty,\n-            RustcPassMode::Direct(_) => match &self.layout.abi {\n+            PassMode::Ignore => EmptySinglePair::Empty,\n+            PassMode::Direct(_) => match &self.layout.abi {\n                 Abi::Scalar(scalar) => {\n                     EmptySinglePair::Single(AbiParam::new(scalar_to_clif_type(tcx, scalar.clone())))\n                 }\n@@ -79,16 +80,16 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            RustcPassMode::Pair(_, _) => match &self.layout.abi {\n+            PassMode::Pair(_, _) => match &self.layout.abi {\n                 Abi::ScalarPair(a, b) => {\n                     let a = scalar_to_clif_type(tcx, a.clone());\n                     let b = scalar_to_clif_type(tcx, b.clone());\n                     EmptySinglePair::Pair(AbiParam::new(a), AbiParam::new(b))\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            RustcPassMode::Cast(_) => EmptySinglePair::Single(AbiParam::new(pointer_ty(tcx))),\n-            RustcPassMode::Indirect {\n+            PassMode::Cast(_) => EmptySinglePair::Single(AbiParam::new(pointer_ty(tcx))),\n+            PassMode::Indirect {\n                 attrs: _,\n                 extra_attrs: None,\n                 on_stack,\n@@ -103,7 +104,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                     EmptySinglePair::Single(AbiParam::new(pointer_ty(tcx)))\n                 }\n             }\n-            RustcPassMode::Indirect {\n+            PassMode::Indirect {\n                 attrs: _,\n                 extra_attrs: Some(_),\n                 on_stack,\n@@ -119,8 +120,8 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n \n     fn get_abi_return(&self, tcx: TyCtxt<'tcx>) -> (Option<AbiParam>, Vec<AbiParam>) {\n         match self.mode {\n-            RustcPassMode::Ignore => (None, vec![]),\n-            RustcPassMode::Direct(_) => match &self.layout.abi {\n+            PassMode::Ignore => (None, vec![]),\n+            PassMode::Direct(_) => match &self.layout.abi {\n                 Abi::Scalar(scalar) => (\n                     None,\n                     vec![AbiParam::new(scalar_to_clif_type(tcx, scalar.clone()))],\n@@ -132,22 +133,22 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            RustcPassMode::Pair(_, _) => match &self.layout.abi {\n+            PassMode::Pair(_, _) => match &self.layout.abi {\n                 Abi::ScalarPair(a, b) => {\n                     let a = scalar_to_clif_type(tcx, a.clone());\n                     let b = scalar_to_clif_type(tcx, b.clone());\n                     (None, vec![AbiParam::new(a), AbiParam::new(b)])\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            RustcPassMode::Cast(_) => (\n+            PassMode::Cast(_) => (\n                 Some(AbiParam::special(\n                     pointer_ty(tcx),\n                     ArgumentPurpose::StructReturn,\n                 )),\n                 vec![],\n             ),\n-            RustcPassMode::Indirect {\n+            PassMode::Indirect {\n                 attrs: _,\n                 extra_attrs: None,\n                 on_stack,\n@@ -161,7 +162,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                     vec![],\n                 )\n             }\n-            RustcPassMode::Indirect {\n+            PassMode::Indirect {\n                 attrs: _,\n                 extra_attrs: Some(_),\n                 on_stack: _,\n@@ -170,56 +171,21 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n     }\n }\n \n-pub(super) fn get_arg_abi<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    layout: TyAndLayout<'tcx>,\n-) -> ArgAbi<'tcx, Ty<'tcx>> {\n-    let mut arg_abi = ArgAbi::new(&tcx, layout, |_, _, _| ArgAttributes::new());\n-    if layout.is_zst() {\n-        // WARNING zst arguments must never be passed, as that will break CastKind::ClosureFnPointer\n-        arg_abi.mode = RustcPassMode::Ignore;\n-    }\n-    match arg_abi.mode {\n-        RustcPassMode::Ignore => {}\n-        RustcPassMode::Direct(_) => match &arg_abi.layout.abi {\n-            Abi::Scalar(_) => {}\n-            // FIXME implement Vector Abi in a cg_llvm compatible way\n-            Abi::Vector { .. } => {\n-                if crate::intrinsics::clif_vector_type(tcx, arg_abi.layout).is_none() {\n-                    arg_abi.make_indirect();\n-                }\n-            }\n-            _ => unreachable!(\"{:?}\", arg_abi.layout.abi),\n-        },\n-        RustcPassMode::Pair(_, _) => match &arg_abi.layout.abi {\n-            Abi::ScalarPair(a, b) => {\n-                let a = scalar_to_clif_type(tcx, a.clone());\n-                let b = scalar_to_clif_type(tcx, b.clone());\n-                if a == types::I128 && b == types::I128 {\n-                    arg_abi.make_indirect();\n-                }\n-            }\n-            _ => unreachable!(\"{:?}\", arg_abi.layout.abi),\n-        },\n-        _ => {}\n-    }\n-    arg_abi\n-}\n-\n /// Get a set of values to be passed as function arguments.\n pub(super) fn adjust_arg_for_abi<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     arg: CValue<'tcx>,\n+    arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n ) -> EmptySinglePair<Value> {\n-    let arg_abi = get_arg_abi(fx.tcx, arg.layout());\n+    assert_assignable(fx, arg.layout().ty, arg_abi.layout.ty);\n     match arg_abi.mode {\n-        RustcPassMode::Ignore => Empty,\n-        RustcPassMode::Direct(_) => Single(arg.load_scalar(fx)),\n-        RustcPassMode::Pair(_, _) => {\n+        PassMode::Ignore => Empty,\n+        PassMode::Direct(_) => Single(arg.load_scalar(fx)),\n+        PassMode::Pair(_, _) => {\n             let (a, b) = arg.load_scalar_pair(fx);\n             Pair(a, b)\n         }\n-        RustcPassMode::Cast(_) | RustcPassMode::Indirect { .. } => match arg.force_stack(fx) {\n+        PassMode::Cast(_) | PassMode::Indirect { .. } => match arg.force_stack(fx) {\n             (ptr, None) => Single(ptr.get_addr(fx)),\n             (ptr, Some(meta)) => Pair(ptr.get_addr(fx), meta),\n         },\n@@ -233,41 +199,52 @@ pub(super) fn cvalue_for_param<'tcx>(\n     start_block: Block,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local: Option<mir::Local>,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local_field: Option<usize>,\n-    arg_ty: Ty<'tcx>,\n+    arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n ) -> Option<CValue<'tcx>> {\n-    let layout = fx.layout_of(arg_ty);\n-    let arg_abi = get_arg_abi(fx.tcx, layout);\n-\n     let clif_types = arg_abi.get_abi_param(fx.tcx);\n     let block_params =\n         clif_types.map(|abi_param| fx.bcx.append_block_param(start_block, abi_param.value_type));\n \n     #[cfg(debug_assertions)]\n-    crate::abi::comments::add_arg_comment(fx, \"arg\", local, local_field, block_params, &arg_abi);\n+    crate::abi::comments::add_arg_comment(\n+        fx,\n+        \"arg\",\n+        local,\n+        local_field,\n+        block_params,\n+        arg_abi.mode,\n+        arg_abi.layout,\n+    );\n \n     match arg_abi.mode {\n-        RustcPassMode::Ignore => None,\n-        RustcPassMode::Direct(_) => Some(CValue::by_val(block_params.assert_single(), layout)),\n-        RustcPassMode::Pair(_, _) => {\n+        PassMode::Ignore => None,\n+        PassMode::Direct(_) => {\n+            Some(CValue::by_val(block_params.assert_single(), arg_abi.layout))\n+        }\n+        PassMode::Pair(_, _) => {\n             let (a, b) = block_params.assert_pair();\n-            Some(CValue::by_val_pair(a, b, layout))\n+            Some(CValue::by_val_pair(a, b, arg_abi.layout))\n         }\n-        RustcPassMode::Cast(_)\n-        | RustcPassMode::Indirect {\n+        PassMode::Cast(_)\n+        | PassMode::Indirect {\n             attrs: _,\n             extra_attrs: None,\n             on_stack: _,\n         } => Some(CValue::by_ref(\n             Pointer::new(block_params.assert_single()),\n-            layout,\n+            arg_abi.layout,\n         )),\n-        RustcPassMode::Indirect {\n+        PassMode::Indirect {\n             attrs: _,\n             extra_attrs: Some(_),\n             on_stack: _,\n         } => {\n             let (ptr, meta) = block_params.assert_pair();\n-            Some(CValue::by_ref_unsized(Pointer::new(ptr), meta, layout))\n+            Some(CValue::by_ref_unsized(\n+                Pointer::new(ptr),\n+                meta,\n+                arg_abi.layout,\n+            ))\n         }\n     }\n }"}, {"sha": "d7a82e0c37703f78bfc9a922bb92b6ab6739236d", "filename": "src/abi/returning.rs", "status": "modified", "additions": 91, "deletions": 47, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=fc595f1a555d7f43802679511e9fdf1f64f2c49a", "patch": "@@ -3,21 +3,55 @@\n use crate::abi::pass_mode::*;\n use crate::prelude::*;\n \n-use rustc_target::abi::call::PassMode as RustcPassMode;\n-\n-fn return_layout<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx, impl Module>) -> TyAndLayout<'tcx> {\n-    fx.layout_of(fx.monomorphize(&fx.mir.local_decls[RETURN_PLACE].ty))\n-}\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n \n /// Can the given type be returned into an ssa var or does it need to be returned on the stack.\n pub(crate) fn can_return_to_ssa_var<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    dest_layout: TyAndLayout<'tcx>,\n+    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    func: &mir::Operand<'tcx>,\n+    args: &[mir::Operand<'tcx>],\n ) -> bool {\n-    match get_arg_abi(tcx, dest_layout).mode {\n-        RustcPassMode::Ignore | RustcPassMode::Direct(_) | RustcPassMode::Pair(_, _) => true,\n+    let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n+    let fn_sig = fx\n+        .tcx\n+        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n+\n+    // Handle special calls like instrinsics and empty drop glue.\n+    let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n+        let instance = ty::Instance::resolve(fx.tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n+            .unwrap()\n+            .unwrap()\n+            .polymorphize(fx.tcx);\n+\n+        match instance.def {\n+            InstanceDef::Intrinsic(_) | InstanceDef::DropGlue(_, _) => {\n+                return true;\n+            }\n+            _ => Some(instance),\n+        }\n+    } else {\n+        None\n+    };\n+\n+    let extra_args = &args[fn_sig.inputs().len()..];\n+    let extra_args = extra_args\n+        .iter()\n+        .map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx)))\n+        .collect::<Vec<_>>();\n+    let fn_abi = if let Some(instance) = instance {\n+        FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n+    } else {\n+        FnAbi::of_fn_ptr(\n+            &RevealAllLayoutCx(fx.tcx),\n+            fn_ty.fn_sig(fx.tcx),\n+            &extra_args,\n+        )\n+    };\n+    match fn_abi.ret.mode {\n+        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) => true,\n         // FIXME Make it possible to return Cast and Indirect to an ssa var.\n-        RustcPassMode::Cast(_) | RustcPassMode::Indirect { .. } => false,\n+        PassMode::Cast(_) | PassMode::Indirect { .. } => false,\n     }\n }\n \n@@ -28,30 +62,39 @@ pub(super) fn codegen_return_param<'tcx>(\n     ssa_analyzed: &rustc_index::vec::IndexVec<Local, crate::analyze::SsaKind>,\n     start_block: Block,\n ) -> CPlace<'tcx> {\n-    let ret_layout = return_layout(fx);\n-    let ret_arg_abi = get_arg_abi(fx.tcx, ret_layout);\n-    let (ret_place, ret_param) = match ret_arg_abi.mode {\n-        RustcPassMode::Ignore => (CPlace::no_place(ret_layout), Empty),\n-        RustcPassMode::Direct(_) | RustcPassMode::Pair(_, _) => {\n+    let (ret_place, ret_param) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n+        PassMode::Ignore => (\n+            CPlace::no_place(fx.fn_abi.as_ref().unwrap().ret.layout),\n+            Empty,\n+        ),\n+        PassMode::Direct(_) | PassMode::Pair(_, _) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n-                super::make_local_place(fx, RETURN_PLACE, ret_layout, is_ssa),\n+                super::make_local_place(\n+                    fx,\n+                    RETURN_PLACE,\n+                    fx.fn_abi.as_ref().unwrap().ret.layout,\n+                    is_ssa,\n+                ),\n                 Empty,\n             )\n         }\n-        RustcPassMode::Cast(_)\n-        | RustcPassMode::Indirect {\n+        PassMode::Cast(_)\n+        | PassMode::Indirect {\n             attrs: _,\n             extra_attrs: None,\n             on_stack: _,\n         } => {\n             let ret_param = fx.bcx.append_block_param(start_block, fx.pointer_type);\n             (\n-                CPlace::for_ptr(Pointer::new(ret_param), ret_layout),\n+                CPlace::for_ptr(\n+                    Pointer::new(ret_param),\n+                    fx.fn_abi.as_ref().unwrap().ret.layout,\n+                ),\n                 Single(ret_param),\n             )\n         }\n-        RustcPassMode::Indirect {\n+        PassMode::Indirect {\n             attrs: _,\n             extra_attrs: Some(_),\n             on_stack: _,\n@@ -68,7 +111,8 @@ pub(super) fn codegen_return_param<'tcx>(\n         Some(RETURN_PLACE),\n         None,\n         ret_param,\n-        &ret_arg_abi,\n+        fx.fn_abi.as_ref().unwrap().ret.mode,\n+        fx.fn_abi.as_ref().unwrap().ret.layout,\n     );\n \n     ret_place\n@@ -78,56 +122,56 @@ pub(super) fn codegen_return_param<'tcx>(\n /// returns the call return value(s) if any are written to the correct place.\n pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n     fx: &mut FunctionCx<'_, 'tcx, M>,\n-    fn_sig: FnSig<'tcx>,\n+    ret_arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     ret_place: Option<CPlace<'tcx>>,\n     f: impl FnOnce(&mut FunctionCx<'_, 'tcx, M>, Option<Value>) -> (Inst, T),\n ) -> (Inst, T) {\n-    let ret_layout = fx.layout_of(fn_sig.output());\n-\n-    let output_arg_abi = get_arg_abi(fx.tcx, ret_layout);\n-    let return_ptr = match output_arg_abi.mode {\n-        RustcPassMode::Ignore => None,\n-        RustcPassMode::Cast(_)\n-        | RustcPassMode::Indirect {\n+    let return_ptr = match ret_arg_abi.mode {\n+        PassMode::Ignore => None,\n+        PassMode::Cast(_)\n+        | PassMode::Indirect {\n             attrs: _,\n             extra_attrs: None,\n             on_stack: _,\n         } => match ret_place {\n             Some(ret_place) => Some(ret_place.to_ptr().get_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)), // FIXME allocate temp stack slot\n         },\n-        RustcPassMode::Indirect {\n+        PassMode::Indirect {\n             attrs: _,\n             extra_attrs: Some(_),\n             on_stack: _,\n         } => unreachable!(\"unsized return value\"),\n-        RustcPassMode::Direct(_) | RustcPassMode::Pair(_, _) => None,\n+        PassMode::Direct(_) | PassMode::Pair(_, _) => None,\n     };\n \n     let (call_inst, meta) = f(fx, return_ptr);\n \n-    match output_arg_abi.mode {\n-        RustcPassMode::Ignore => {}\n-        RustcPassMode::Direct(_) => {\n+    match ret_arg_abi.mode {\n+        PassMode::Ignore => {}\n+        PassMode::Direct(_) => {\n             if let Some(ret_place) = ret_place {\n                 let ret_val = fx.bcx.inst_results(call_inst)[0];\n-                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_layout));\n+                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_arg_abi.layout));\n             }\n         }\n-        RustcPassMode::Pair(_, _) => {\n+        PassMode::Pair(_, _) => {\n             if let Some(ret_place) = ret_place {\n                 let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n                 let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n-                ret_place.write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_layout));\n+                ret_place.write_cvalue(\n+                    fx,\n+                    CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout),\n+                );\n             }\n         }\n-        RustcPassMode::Cast(_)\n-        | RustcPassMode::Indirect {\n+        PassMode::Cast(_)\n+        | PassMode::Indirect {\n             attrs: _,\n             extra_attrs: None,\n             on_stack: _,\n         } => {}\n-        RustcPassMode::Indirect {\n+        PassMode::Indirect {\n             attrs: _,\n             extra_attrs: Some(_),\n             on_stack: _,\n@@ -139,27 +183,27 @@ pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n \n /// Codegen a return instruction with the right return value(s) if any.\n pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    match get_arg_abi(fx.tcx, return_layout(fx)).mode {\n-        RustcPassMode::Ignore\n-        | RustcPassMode::Cast(_)\n-        | RustcPassMode::Indirect {\n+    match fx.fn_abi.as_ref().unwrap().ret.mode {\n+        PassMode::Ignore\n+        | PassMode::Cast(_)\n+        | PassMode::Indirect {\n             attrs: _,\n             extra_attrs: None,\n             on_stack: _,\n         } => {\n             fx.bcx.ins().return_(&[]);\n         }\n-        RustcPassMode::Indirect {\n+        PassMode::Indirect {\n             attrs: _,\n             extra_attrs: Some(_),\n             on_stack: _,\n         } => unreachable!(\"unsized return value\"),\n-        RustcPassMode::Direct(_) => {\n+        PassMode::Direct(_) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx).load_scalar(fx);\n             fx.bcx.ins().return_(&[ret_val]);\n         }\n-        RustcPassMode::Pair(_, _) => {\n+        PassMode::Pair(_, _) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n             fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);"}, {"sha": "dc5e8a7e3049868fc5462fc4eefb95970d438be2", "filename": "src/analyze.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=fc595f1a555d7f43802679511e9fdf1f64f2c49a", "patch": "@@ -40,11 +40,9 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Module>) -> IndexVec<Local, S\n         }\n \n         match &bb.terminator().kind {\n-            TerminatorKind::Call { destination, .. } => {\n+            TerminatorKind::Call { destination, func, args, .. } => {\n                 if let Some((dest_place, _dest_bb)) = destination {\n-                    let dest_layout = fx\n-                        .layout_of(fx.monomorphize(&dest_place.ty(&fx.mir.local_decls, fx.tcx).ty));\n-                    if !crate::abi::can_return_to_ssa_var(fx.tcx, dest_layout) {\n+                    if !crate::abi::can_return_to_ssa_var(fx, func, args) {\n                         not_ssa(&mut flag_map, dest_place.local)\n                     }\n                 }"}, {"sha": "1eff0d4f5167b99f5cad8ca29a2def723e52f270", "filename": "src/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=fc595f1a555d7f43802679511e9fdf1f64f2c49a", "patch": "@@ -2,6 +2,8 @@\n \n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::adjustment::PointerCast;\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_target::abi::call::FnAbi;\n \n use crate::prelude::*;\n \n@@ -51,6 +53,7 @@ pub(crate) fn codegen_fn<'tcx>(\n \n         instance,\n         mir,\n+        fn_abi: Some(FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])),\n \n         bcx,\n         block_map,"}, {"sha": "fbee84e09f7a6e40625dc9728b3eb4dc73e6d20c", "filename": "src/common.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=fc595f1a555d7f43802679511e9fdf1f64f2c49a", "patch": "@@ -1,4 +1,5 @@\n use rustc_index::vec::IndexVec;\n+use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n@@ -294,6 +295,7 @@ pub(crate) struct FunctionCx<'clif, 'tcx, M: Module> {\n \n     pub(crate) instance: Instance<'tcx>,\n     pub(crate) mir: &'tcx Body<'tcx>,\n+    pub(crate) fn_abi: Option<FnAbi<'tcx, Ty<'tcx>>>,\n \n     pub(crate) bcx: FunctionBuilder<'clif>,\n     pub(crate) block_map: IndexVec<BasicBlock, Block>,\n@@ -319,16 +321,7 @@ impl<'tcx, M: Module> LayoutOf for FunctionCx<'_, 'tcx, M> {\n     type TyAndLayout = TyAndLayout<'tcx>;\n \n     fn layout_of(&self, ty: Ty<'tcx>) -> TyAndLayout<'tcx> {\n-        assert!(!ty.still_further_specializable());\n-        self.tcx\n-            .layout_of(ParamEnv::reveal_all().and(&ty))\n-            .unwrap_or_else(|e| {\n-                if let layout::LayoutError::SizeOverflow(_) = e {\n-                    self.tcx.sess.fatal(&e.to_string())\n-                } else {\n-                    bug!(\"failed to get layout for `{}`: {}\", ty, e)\n-                }\n-            })\n+        RevealAllLayoutCx(self.tcx).layout_of(ty)\n     }\n }\n \n@@ -442,3 +435,47 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n         self.bcx.ins().global_value(self.pointer_type, local_msg_id)\n     }\n }\n+\n+pub(crate) struct RevealAllLayoutCx<'tcx>(pub(crate) TyCtxt<'tcx>);\n+\n+impl<'tcx> LayoutOf for RevealAllLayoutCx<'tcx> {\n+    type Ty = Ty<'tcx>;\n+    type TyAndLayout = TyAndLayout<'tcx>;\n+\n+    fn layout_of(&self, ty: Ty<'tcx>) -> TyAndLayout<'tcx> {\n+        assert!(!ty.still_further_specializable());\n+        self.0\n+            .layout_of(ParamEnv::reveal_all().and(&ty))\n+            .unwrap_or_else(|e| {\n+                if let layout::LayoutError::SizeOverflow(_) = e {\n+                    self.0.sess.fatal(&e.to_string())\n+                } else {\n+                    bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+                }\n+            })\n+    }\n+}\n+\n+impl<'tcx> layout::HasTyCtxt<'tcx> for RevealAllLayoutCx<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.0\n+    }\n+}\n+\n+impl<'tcx> rustc_target::abi::HasDataLayout for RevealAllLayoutCx<'tcx> {\n+    fn data_layout(&self) -> &rustc_target::abi::TargetDataLayout {\n+        &self.0.data_layout\n+    }\n+}\n+\n+impl<'tcx> layout::HasParamEnv<'tcx> for RevealAllLayoutCx<'tcx> {\n+    fn param_env(&self) -> ParamEnv<'tcx> {\n+        ParamEnv::reveal_all()\n+    }\n+}\n+\n+impl<'tcx> HasTargetSpec for RevealAllLayoutCx<'tcx> {\n+    fn target_spec(&self) -> &Target {\n+        &self.0.sess.target\n+    }\n+}"}, {"sha": "ed7ee3b536534e648ae7c916c63e95fa2d08e190", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=fc595f1a555d7f43802679511e9fdf1f64f2c49a", "patch": "@@ -90,7 +90,7 @@ mod prelude {\n     pub(crate) use rustc_middle::mir::{self, *};\n     pub(crate) use rustc_middle::ty::layout::{self, TyAndLayout};\n     pub(crate) use rustc_middle::ty::{\n-        self, FnSig, Instance, InstanceDef, ParamEnv, Ty, TyCtxt, TypeAndMut, TypeFoldable,\n+        self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt, TypeAndMut, TypeFoldable,\n     };\n     pub(crate) use rustc_target::abi::{Abi, LayoutOf, Scalar, Size, VariantIdx};\n "}, {"sha": "17cb09d55870748eb405141fc8fc35b2760b8344", "filename": "src/value_and_place.rs", "status": "modified", "additions": 59, "deletions": 58, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc595f1a555d7f43802679511e9fdf1f64f2c49a/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=fc595f1a555d7f43802679511e9fdf1f64f2c49a", "patch": "@@ -450,64 +450,6 @@ impl<'tcx> CPlace<'tcx> {\n         fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n         from: CValue<'tcx>,\n     ) {\n-        fn assert_assignable<'tcx>(\n-            fx: &FunctionCx<'_, 'tcx, impl Module>,\n-            from_ty: Ty<'tcx>,\n-            to_ty: Ty<'tcx>,\n-        ) {\n-            match (from_ty.kind(), to_ty.kind()) {\n-                (ty::Ref(_, a, _), ty::Ref(_, b, _))\n-                | (\n-                    ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n-                    ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n-                ) => {\n-                    assert_assignable(fx, a, b);\n-                }\n-                (ty::FnPtr(_), ty::FnPtr(_)) => {\n-                    let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        from_ty.fn_sig(fx.tcx),\n-                    );\n-                    let to_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        to_ty.fn_sig(fx.tcx),\n-                    );\n-                    assert_eq!(\n-                        from_sig, to_sig,\n-                        \"Can't write fn ptr with incompatible sig {:?} to place with sig {:?}\\n\\n{:#?}\",\n-                        from_sig, to_sig, fx,\n-                    );\n-                    // fn(&T) -> for<'l> fn(&'l T) is allowed\n-                }\n-                (&ty::Dynamic(from_traits, _), &ty::Dynamic(to_traits, _)) => {\n-                    for (from, to) in from_traits.iter().zip(to_traits) {\n-                        let from = fx\n-                            .tcx\n-                            .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n-                        let to = fx\n-                            .tcx\n-                            .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n-                        assert_eq!(\n-                            from, to,\n-                            \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n-                            from_traits, to_traits, fx,\n-                        );\n-                    }\n-                    // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n-                }\n-                _ => {\n-                    assert_eq!(\n-                        from_ty,\n-                        to_ty,\n-                        \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n-                        from_ty,\n-                        to_ty,\n-                        fx,\n-                    );\n-                }\n-            }\n-        }\n-\n         assert_assignable(fx, from.layout().ty, self.layout().ty);\n \n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue\");\n@@ -794,3 +736,62 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n }\n+\n+#[track_caller]\n+pub(crate) fn assert_assignable<'tcx>(\n+    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+) {\n+    match (from_ty.kind(), to_ty.kind()) {\n+        (ty::Ref(_, a, _), ty::Ref(_, b, _))\n+        | (\n+            ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n+            ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n+        ) => {\n+            assert_assignable(fx, a, b);\n+        }\n+        (ty::Ref(_, a, _), ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }))\n+        | (ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }), ty::Ref(_, b, _)) => {\n+            assert_assignable(fx, a, b);\n+        }\n+        (ty::FnPtr(_), ty::FnPtr(_)) => {\n+            let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n+                ParamEnv::reveal_all(),\n+                from_ty.fn_sig(fx.tcx),\n+            );\n+            let to_sig = fx\n+                .tcx\n+                .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to_ty.fn_sig(fx.tcx));\n+            assert_eq!(\n+                from_sig, to_sig,\n+                \"Can't write fn ptr with incompatible sig {:?} to place with sig {:?}\\n\\n{:#?}\",\n+                from_sig, to_sig, fx,\n+            );\n+            // fn(&T) -> for<'l> fn(&'l T) is allowed\n+        }\n+        (&ty::Dynamic(from_traits, _), &ty::Dynamic(to_traits, _)) => {\n+            for (from, to) in from_traits.iter().zip(to_traits) {\n+                let from = fx\n+                    .tcx\n+                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n+                let to = fx\n+                    .tcx\n+                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n+                assert_eq!(\n+                    from, to,\n+                    \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n+                    from_traits, to_traits, fx,\n+                );\n+            }\n+            // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n+        }\n+        _ => {\n+            assert_eq!(\n+                from_ty, to_ty,\n+                \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n+                from_ty, to_ty, fx,\n+            );\n+        }\n+    }\n+}"}]}