{"sha": "275a3864b8d1c612662c5a416b2afa77bbf81499", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NWEzODY0YjhkMWM2MTI2NjJjNWE0MTZiMmFmYTc3YmJmODE0OTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-28T19:20:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-28T19:20:06Z"}, "message": "Auto merge of #3830 - flip1995:unknown_attribute, r=oli-obk\n\nError on unknown or deprecated attributes\n\nThe reason I decided to not make this a lint is, that unknown attributes are always a hard error in rustc and also in rustfmt, which cannot be turned off by an `allow`. This could have been done by introducing a category which would be forbid-by-default. But that would have introduced a new lint category+group for just one lint and also wouldn't be consistent with rustfmt and rustc.", "tree": {"sha": "856b58bef85d2291c0eee28c899c45362935be8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/856b58bef85d2291c0eee28c899c45362935be8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/275a3864b8d1c612662c5a416b2afa77bbf81499", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/275a3864b8d1c612662c5a416b2afa77bbf81499", "html_url": "https://github.com/rust-lang/rust/commit/275a3864b8d1c612662c5a416b2afa77bbf81499", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/275a3864b8d1c612662c5a416b2afa77bbf81499/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f69ec96906d300132ffd33151bf6641b950db96d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f69ec96906d300132ffd33151bf6641b950db96d", "html_url": "https://github.com/rust-lang/rust/commit/f69ec96906d300132ffd33151bf6641b950db96d"}, {"sha": "c4eb7801565fe0c69f3f199f64db40dfdd084590", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4eb7801565fe0c69f3f199f64db40dfdd084590", "html_url": "https://github.com/rust-lang/rust/commit/c4eb7801565fe0c69f3f199f64db40dfdd084590"}], "stats": {"total": 235, "additions": 151, "deletions": 84}, "files": [{"sha": "db086a58e5c98c017d8ff48761f567d44b22accc", "filename": "clippy_lints/src/utils/attrs.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/275a3864b8d1c612662c5a416b2afa77bbf81499/clippy_lints%2Fsrc%2Futils%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/275a3864b8d1c612662c5a416b2afa77bbf81499/clippy_lints%2Fsrc%2Futils%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fattrs.rs?ref=275a3864b8d1c612662c5a416b2afa77bbf81499", "patch": "@@ -0,0 +1,105 @@\n+use rustc::session::Session;\n+use rustc_errors::Applicability;\n+use std::str::FromStr;\n+use syntax::ast;\n+\n+/// Deprecation status of attributes known by Clippy.\n+#[allow(dead_code)]\n+pub enum DeprecationStatus {\n+    /// Attribute is deprecated\n+    Deprecated,\n+    /// Attribute is deprecated and was replaced by the named attribute\n+    Replaced(&'static str),\n+    None,\n+}\n+\n+pub const BUILTIN_ATTRIBUTES: &[(&str, DeprecationStatus)] = &[\n+    (\"author\", DeprecationStatus::None),\n+    (\"cyclomatic_complexity\", DeprecationStatus::None),\n+    (\"dump\", DeprecationStatus::None),\n+];\n+\n+pub struct LimitStack {\n+    stack: Vec<u64>,\n+}\n+\n+impl Drop for LimitStack {\n+    fn drop(&mut self) {\n+        assert_eq!(self.stack.len(), 1);\n+    }\n+}\n+\n+impl LimitStack {\n+    pub fn new(limit: u64) -> Self {\n+        Self { stack: vec![limit] }\n+    }\n+    pub fn limit(&self) -> u64 {\n+        *self.stack.last().expect(\"there should always be a value in the stack\")\n+    }\n+    pub fn push_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n+        let stack = &mut self.stack;\n+        parse_attrs(sess, attrs, name, |val| stack.push(val));\n+    }\n+    pub fn pop_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n+        let stack = &mut self.stack;\n+        parse_attrs(sess, attrs, name, |val| assert_eq!(stack.pop(), Some(val)));\n+    }\n+}\n+\n+pub fn get_attr<'a>(\n+    sess: &'a Session,\n+    attrs: &'a [ast::Attribute],\n+    name: &'static str,\n+) -> impl Iterator<Item = &'a ast::Attribute> {\n+    attrs.iter().filter(move |attr| {\n+        let attr_segments = &attr.path.segments;\n+        if attr_segments.len() == 2 && attr_segments[0].ident.to_string() == \"clippy\" {\n+            if let Some(deprecation_status) = BUILTIN_ATTRIBUTES\n+                .iter()\n+                .find(|(builtin_name, _)| *builtin_name == attr_segments[1].ident.to_string())\n+                .map(|(_, deprecation_status)| deprecation_status)\n+            {\n+                let mut db = sess.struct_span_err(attr_segments[1].ident.span, \"Usage of deprecated attribute\");\n+                match deprecation_status {\n+                    DeprecationStatus::Deprecated => {\n+                        db.emit();\n+                        false\n+                    },\n+                    DeprecationStatus::Replaced(new_name) => {\n+                        db.span_suggestion(\n+                            attr_segments[1].ident.span,\n+                            \"consider using\",\n+                            new_name.to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        db.emit();\n+                        false\n+                    },\n+                    DeprecationStatus::None => {\n+                        db.cancel();\n+                        attr_segments[1].ident.to_string() == name\n+                    },\n+                }\n+            } else {\n+                sess.span_err(attr_segments[1].ident.span, \"Usage of unknown attribute\");\n+                false\n+            }\n+        } else {\n+            false\n+        }\n+    })\n+}\n+\n+fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'static str, mut f: F) {\n+    for attr in get_attr(sess, attrs, name) {\n+        if let Some(ref value) = attr.value_str() {\n+            if let Ok(value) = FromStr::from_str(&value.as_str()) {\n+                f(value)\n+            } else {\n+                sess.span_err(attr.span, \"not a number\");\n+            }\n+        } else {\n+            sess.span_err(attr.span, \"bad clippy attribute\");\n+        }\n+    }\n+}"}, {"sha": "e61fb2bde4b8661b98e1b57c8af048a6ddd511da", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/275a3864b8d1c612662c5a416b2afa77bbf81499/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/275a3864b8d1c612662c5a416b2afa77bbf81499/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=275a3864b8d1c612662c5a416b2afa77bbf81499", "patch": "@@ -5,7 +5,8 @@ use crate::utils::get_attr;\n use rustc::hir;\n use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc::hir::{BindingAnnotation, Expr, ExprKind, Pat, PatKind, QPath, Stmt, StmtKind, TyKind};\n-use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n+use rustc::session::Session;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::{Attribute, LitKind};\n@@ -71,80 +72,80 @@ fn done() {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n-    fn check_item(&mut self, _cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n-        if !has_attr(&item.attrs) {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n+        if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"item\").visit_item(item);\n         done();\n     }\n \n-    fn check_impl_item(&mut self, _cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem) {\n-        if !has_attr(&item.attrs) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem) {\n+        if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"item\").visit_impl_item(item);\n         done();\n     }\n \n-    fn check_trait_item(&mut self, _cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n-        if !has_attr(&item.attrs) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n+        if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"item\").visit_trait_item(item);\n         done();\n     }\n \n-    fn check_variant(&mut self, _cx: &LateContext<'a, 'tcx>, var: &'tcx hir::Variant, generics: &hir::Generics) {\n-        if !has_attr(&var.node.attrs) {\n+    fn check_variant(&mut self, cx: &LateContext<'a, 'tcx>, var: &'tcx hir::Variant, generics: &hir::Generics) {\n+        if !has_attr(cx.sess(), &var.node.attrs) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"var\").visit_variant(var, generics, hir::DUMMY_HIR_ID);\n         done();\n     }\n \n-    fn check_struct_field(&mut self, _cx: &LateContext<'a, 'tcx>, field: &'tcx hir::StructField) {\n-        if !has_attr(&field.attrs) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx hir::StructField) {\n+        if !has_attr(cx.sess(), &field.attrs) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"field\").visit_struct_field(field);\n         done();\n     }\n \n-    fn check_expr(&mut self, _cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n-        if !has_attr(&expr.attrs) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+        if !has_attr(cx.sess(), &expr.attrs) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"expr\").visit_expr(expr);\n         done();\n     }\n \n-    fn check_arm(&mut self, _cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm) {\n-        if !has_attr(&arm.attrs) {\n+    fn check_arm(&mut self, cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm) {\n+        if !has_attr(cx.sess(), &arm.attrs) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"arm\").visit_arm(arm);\n         done();\n     }\n \n-    fn check_stmt(&mut self, _cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n-        if !has_attr(stmt.node.attrs()) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n+        if !has_attr(cx.sess(), stmt.node.attrs()) {\n             return;\n         }\n         prelude();\n         PrintVisitor::new(\"stmt\").visit_stmt(stmt);\n         done();\n     }\n \n-    fn check_foreign_item(&mut self, _cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ForeignItem) {\n-        if !has_attr(&item.attrs) {\n+    fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ForeignItem) {\n+        if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n         prelude();\n@@ -673,8 +674,8 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     }\n }\n \n-fn has_attr(attrs: &[Attribute]) -> bool {\n-    get_attr(attrs, \"author\").count() > 0\n+fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n+    get_attr(sess, attrs, \"author\").count() > 0\n }\n \n fn desugaring_name(des: hir::MatchSource) -> String {"}, {"sha": "c83e1c396bca2d06b230168bcd073ef0f07f08c7", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/275a3864b8d1c612662c5a416b2afa77bbf81499/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/275a3864b8d1c612662c5a416b2afa77bbf81499/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=275a3864b8d1c612662c5a416b2afa77bbf81499", "patch": "@@ -3,7 +3,8 @@\n use crate::utils::get_attr;\n use rustc::hir;\n use rustc::hir::print;\n-use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n+use rustc::session::Session;\n use rustc::{declare_tool_lint, lint_array};\n use syntax::ast::Attribute;\n \n@@ -43,14 +44,14 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n-        if !has_attr(&item.attrs) {\n+        if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n         print_item(cx, item);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem) {\n-        if !has_attr(&item.attrs) {\n+        if !has_attr(cx.sess(), &item.attrs) {\n             return;\n         }\n         println!(\"impl item `{}`\", item.ident.name);\n@@ -100,14 +101,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     //\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n-        if !has_attr(&expr.attrs) {\n+        if !has_attr(cx.sess(), &expr.attrs) {\n             return;\n         }\n         print_expr(cx, expr, 0);\n     }\n \n     fn check_arm(&mut self, cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm) {\n-        if !has_attr(&arm.attrs) {\n+        if !has_attr(cx.sess(), &arm.attrs) {\n             return;\n         }\n         for pat in &arm.pats {\n@@ -122,7 +123,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n-        if !has_attr(stmt.node.attrs()) {\n+        if !has_attr(cx.sess(), stmt.node.attrs()) {\n             return;\n         }\n         match stmt.node {\n@@ -148,8 +149,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     //\n }\n \n-fn has_attr(attrs: &[Attribute]) -> bool {\n-    get_attr(attrs, \"dump\").count() > 0\n+fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n+    get_attr(sess, attrs, \"dump\").count() > 0\n }\n \n #[allow(clippy::similar_names)]"}, {"sha": "d7ed3191ddbe473caf4ff92634946dfb06fc8786", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 4, "deletions": 55, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/275a3864b8d1c612662c5a416b2afa77bbf81499/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/275a3864b8d1c612662c5a416b2afa77bbf81499/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=275a3864b8d1c612662c5a416b2afa77bbf81499", "patch": "@@ -8,7 +8,6 @@ use rustc::hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc::hir::Node;\n use rustc::hir::*;\n use rustc::lint::{LateContext, Level, Lint, LintContext};\n-use rustc::session::Session;\n use rustc::traits;\n use rustc::ty::{\n     self,\n@@ -20,32 +19,31 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::Applicability;\n use std::borrow::Cow;\n use std::mem;\n-use std::str::FromStr;\n use syntax::ast::{self, LitKind};\n use syntax::attr;\n use syntax::source_map::{Span, DUMMY_SP};\n use syntax::symbol;\n use syntax::symbol::{keywords, Symbol};\n \n-pub mod camel_case;\n-\n+pub mod attrs;\n pub mod author;\n+pub mod camel_case;\n pub mod comparisons;\n pub mod conf;\n pub mod constants;\n mod diagnostics;\n+pub mod higher;\n mod hir_utils;\n pub mod inspector;\n pub mod internal_lints;\n pub mod paths;\n pub mod ptr;\n pub mod sugg;\n pub mod usage;\n+pub use self::attrs::*;\n pub use self::diagnostics::*;\n pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n \n-pub mod higher;\n-\n /// Returns true if the two spans come from differing expansions (i.e. one is\n /// from a macro and one\n /// isn't).\n@@ -662,55 +660,6 @@ pub fn is_adjusted(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n     cx.tables.adjustments().get(e.hir_id).is_some()\n }\n \n-pub struct LimitStack {\n-    stack: Vec<u64>,\n-}\n-\n-impl Drop for LimitStack {\n-    fn drop(&mut self) {\n-        assert_eq!(self.stack.len(), 1);\n-    }\n-}\n-\n-impl LimitStack {\n-    pub fn new(limit: u64) -> Self {\n-        Self { stack: vec![limit] }\n-    }\n-    pub fn limit(&self) -> u64 {\n-        *self.stack.last().expect(\"there should always be a value in the stack\")\n-    }\n-    pub fn push_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n-        let stack = &mut self.stack;\n-        parse_attrs(sess, attrs, name, |val| stack.push(val));\n-    }\n-    pub fn pop_attrs(&mut self, sess: &Session, attrs: &[ast::Attribute], name: &'static str) {\n-        let stack = &mut self.stack;\n-        parse_attrs(sess, attrs, name, |val| assert_eq!(stack.pop(), Some(val)));\n-    }\n-}\n-\n-pub fn get_attr<'a>(attrs: &'a [ast::Attribute], name: &'static str) -> impl Iterator<Item = &'a ast::Attribute> {\n-    attrs.iter().filter(move |attr| {\n-        attr.path.segments.len() == 2\n-            && attr.path.segments[0].ident.to_string() == \"clippy\"\n-            && attr.path.segments[1].ident.to_string() == name\n-    })\n-}\n-\n-fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'static str, mut f: F) {\n-    for attr in get_attr(attrs, name) {\n-        if let Some(ref value) = attr.value_str() {\n-            if let Ok(value) = FromStr::from_str(&value.as_str()) {\n-                f(value)\n-            } else {\n-                sess.span_err(attr.span, \"not a number\");\n-            }\n-        } else {\n-            sess.span_err(attr.span, \"bad clippy attribute\");\n-        }\n-    }\n-}\n-\n /// Return the pre-expansion span if is this comes from an expansion of the\n /// macro `name`.\n /// See also `is_direct_expn_of`."}, {"sha": "8d695692863649820aae19e64a909be54cb830a4", "filename": "tests/ui/unknown_attribute.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/275a3864b8d1c612662c5a416b2afa77bbf81499/tests%2Fui%2Funknown_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/275a3864b8d1c612662c5a416b2afa77bbf81499/tests%2Fui%2Funknown_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funknown_attribute.rs?ref=275a3864b8d1c612662c5a416b2afa77bbf81499", "patch": "@@ -0,0 +1,3 @@\n+#[clippy::unknown]\n+#[clippy::cyclomatic_complexity = \"1\"]\n+fn main() {}"}, {"sha": "47e37aed2464e4a5567ddb5ec62d16b2f67d8f50", "filename": "tests/ui/unknown_attribute.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/275a3864b8d1c612662c5a416b2afa77bbf81499/tests%2Fui%2Funknown_attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/275a3864b8d1c612662c5a416b2afa77bbf81499/tests%2Fui%2Funknown_attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funknown_attribute.stderr?ref=275a3864b8d1c612662c5a416b2afa77bbf81499", "patch": "@@ -0,0 +1,8 @@\n+error: Usage of unknown attribute\n+  --> $DIR/unknown_attribute.rs:1:11\n+   |\n+LL | #[clippy::unknown]\n+   |           ^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}