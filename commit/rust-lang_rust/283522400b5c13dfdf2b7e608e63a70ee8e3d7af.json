{"sha": "283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MzUyMjQwMGI1YzEzZGZkZjJiN2U2MDhlNjNhNzBlZThlM2Q3YWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-09T20:56:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-09T20:56:54Z"}, "message": "Auto merge of #72972 - lzutao:clippy, r=Manishearth\n\nPull changes from rust-lang/rust-clippy", "tree": {"sha": "2aa4775e0ce4256904378821fd66c8e337d1a307", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2aa4775e0ce4256904378821fd66c8e337d1a307"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "html_url": "https://github.com/rust-lang/rust/commit/283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "feb3536eba10c2e4585d066629598f03d5ddc7c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/feb3536eba10c2e4585d066629598f03d5ddc7c6", "html_url": "https://github.com/rust-lang/rust/commit/feb3536eba10c2e4585d066629598f03d5ddc7c6"}, {"sha": "41c845efd9c241be1bc506a433b25f5357e5beb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/41c845efd9c241be1bc506a433b25f5357e5beb5", "html_url": "https://github.com/rust-lang/rust/commit/41c845efd9c241be1bc506a433b25f5357e5beb5"}], "stats": {"total": 4857, "additions": 3943, "deletions": 914}, "files": [{"sha": "0c80394f03e3c83851d4f9b83ba4c6bfc7495032", "filename": "src/tools/clippy/.github/workflows/clippy_bors.yml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -232,7 +232,8 @@ jobs:\n       matrix:\n         integration:\n         - 'rust-lang/cargo'\n-        - 'rust-lang/rls'\n+        # FIXME: re-enable once fmt_macros is renamed in RLS\n+        # - 'rust-lang/rls'\n         - 'rust-lang/chalk'\n         - 'rust-lang/rustfmt'\n         - 'Marwes/combine'"}, {"sha": "adc945a69441d5a59fb288d31f98f66c979bb904", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 84, "deletions": 3, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -6,11 +6,88 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[891e1a8...master](https://github.com/rust-lang/rust-clippy/compare/891e1a8...master)\n+[7ea7cd1...master](https://github.com/rust-lang/rust-clippy/compare/7ea7cd1...master)\n+\n+## Rust 1.45\n+\n+Current beta, release 2020-07-16\n+\n+[891e1a8...7ea7cd1](https://github.com/rust-lang/rust-clippy/compare/891e1a8...7ea7cd1)\n+\n+### New lints\n+\n+* [`match_wildcard_for_single_variants`] [#5582](https://github.com/rust-lang/rust-clippy/pull/5582)\n+* [`unsafe_derive_deserialize`] [#5493](https://github.com/rust-lang/rust-clippy/pull/5493)\n+* [`if_let_mutex`] [#5332](https://github.com/rust-lang/rust-clippy/pull/5332)\n+* [`mismatched_target_os`] [#5506](https://github.com/rust-lang/rust-clippy/pull/5506)\n+* [`await_holding_lock`] [#5439](https://github.com/rust-lang/rust-clippy/pull/5439)\n+* [`match_on_vec_items`] [#5522](https://github.com/rust-lang/rust-clippy/pull/5522)\n+* [`manual_async_fn`] [#5576](https://github.com/rust-lang/rust-clippy/pull/5576)\n+* [`reversed_empty_ranges`] [#5583](https://github.com/rust-lang/rust-clippy/pull/5583)\n+* [`manual_non_exhaustive`] [#5550](https://github.com/rust-lang/rust-clippy/pull/5550)\n+\n+### Moves and Deprecations\n+\n+* Downgrade [`match_bool`] to pedantic [#5408](https://github.com/rust-lang/rust-clippy/pull/5408)\n+* Downgrade [`match_wild_err_arm`] to pedantic and update help messages. [#5622](https://github.com/rust-lang/rust-clippy/pull/5622)\n+* Downgrade [`useless_let_if_seq`] to nursery. [#5599](https://github.com/rust-lang/rust-clippy/pull/5599)\n+* Generalize `option_and_then_some` and rename to [`bind_instead_of_map`]. [#5529](https://github.com/rust-lang/rust-clippy/pull/5529)\n+* Rename `identity_conversion` to [`useless_conversion`]. [#5568](https://github.com/rust-lang/rust-clippy/pull/5568)\n+* Merge `block_in_if_condition_expr` and `block_in_if_condition_stmt` into [`blocks_in_if_conditions`].\n+[#5563](https://github.com/rust-lang/rust-clippy/pull/5563)\n+* Merge `option_map_unwrap_or`, `option_map_unwrap_or_else` and `result_map_unwrap_or_else` into [`map_unwrap_or`].\n+[#5563](https://github.com/rust-lang/rust-clippy/pull/5563)\n+* Merge `option_unwrap_used` and `result_unwrap_used` into [`unwrap_used`].\n+[#5563](https://github.com/rust-lang/rust-clippy/pull/5563)\n+* Merge `option_expect_used` and `result_expect_used` into [`expect_used`].\n+[#5563](https://github.com/rust-lang/rust-clippy/pull/5563)\n+* Merge `for_loop_over_option` and `for_loop_over_result` into [`for_loops_over_fallibles`].\n+[#5563](https://github.com/rust-lang/rust-clippy/pull/5563)\n+\n+### Enhancements\n+\n+* Avoid running cargo lints when not enabled to improve performance. [#5505](https://github.com/rust-lang/rust-clippy/pull/5505)\n+* Extend [`useless_conversion`] with `TryFrom` and `TryInto`. [#5631](https://github.com/rust-lang/rust-clippy/pull/5631)\n+* Lint also in type parameters and where clauses in [`unused_unit`]. [#5592](https://github.com/rust-lang/rust-clippy/pull/5592)\n+* Do not suggest deriving `Default` in [`new_without_default`]. [#5616](https://github.com/rust-lang/rust-clippy/pull/5616)\n+\n+### False Positive Fixes\n+\n+* [`while_let_on_iterator`] [#5525](https://github.com/rust-lang/rust-clippy/pull/5525)\n+* [`empty_line_after_outer_attr`] [#5609](https://github.com/rust-lang/rust-clippy/pull/5609)\n+* [`unnecessary_unwrap`] [#5558](https://github.com/rust-lang/rust-clippy/pull/5558)\n+* [`comparison_chain`] [#5596](https://github.com/rust-lang/rust-clippy/pull/5596)\n+* Don't trigger [`used_underscore_binding`] in await desugaring. [#5535](https://github.com/rust-lang/rust-clippy/pull/5535)\n+* Don't trigger [`borrowed_box`] on mutable references. [#5491](https://github.com/rust-lang/rust-clippy/pull/5491)\n+* Allow `1 << 0` in [`identity_op`]. [#5602](https://github.com/rust-lang/rust-clippy/pull/5602)\n+* Allow `use super::*;` glob imports in [`wildcard_imports`]. [#5564](https://github.com/rust-lang/rust-clippy/pull/5564)\n+* Whitelist more words in [`doc_markdown`]. [#5611](https://github.com/rust-lang/rust-clippy/pull/5611)\n+* Skip dev and build deps in [`multiple_crate_versions`]. [#5636](https://github.com/rust-lang/rust-clippy/pull/5636)\n+* Honor `allow` attribute on arguments in [`ptr_arg`]. [#5647](https://github.com/rust-lang/rust-clippy/pull/5647)\n+* Honor lint level attributes for [`redundant_field_names`], [`just_underscores_and_digits`], [`many_single_char_names`]\n+and [`similar_names`]. [#5651](https://github.com/rust-lang/rust-clippy/pull/5651)\n+* Ignore calls to `len` in [`or_fun_call`]. [#4429](https://github.com/rust-lang/rust-clippy/pull/4429)\n+\n+### Suggestion Improvements\n+\n+* Simplify suggestions in [`manual_memcpy`]. [#5536](https://github.com/rust-lang/rust-clippy/pull/5536)\n+* Fix suggestion in [`redundant_pattern_matching`] for macros. [#5511](https://github.com/rust-lang/rust-clippy/pull/5511)\n+* Avoid suggesting `copied()` for mutable references in [`map_clone`]. [#5530](https://github.com/rust-lang/rust-clippy/pull/5530)\n+* Improve help message for [`clone_double_ref`]. [#5547](https://github.com/rust-lang/rust-clippy/pull/5547)\n+\n+### ICE Fixes\n+\n+* Fix ICE caused in unwrap module. [#5590](https://github.com/rust-lang/rust-clippy/pull/5590)\n+* Fix ICE on rustc test issue-69020-assoc-const-arith-overflow.rs [#5499](https://github.com/rust-lang/rust-clippy/pull/5499)\n+\n+### Documentation\n+\n+* Clarify the documentation of [`unnecessary_mut_passed`]. [#5639](https://github.com/rust-lang/rust-clippy/pull/5639)\n+* Extend example for [`unneeded_field_pattern`]. [#5541](https://github.com/rust-lang/rust-clippy/pull/5541)\n \n ## Rust 1.44\n \n-Current beta, release 2020-06-04\n+Current stable, released 2020-06-04\n \n [204bb9b...891e1a8](https://github.com/rust-lang/rust-clippy/compare/204bb9b...891e1a8)\n \n@@ -93,7 +170,7 @@ Current beta, release 2020-06-04\n \n ## Rust 1.43\n \n-Current stable, released 2020-04-23\n+Released 2020-04-23\n \n [4ee1206...204bb9b](https://github.com/rust-lang/rust-clippy/compare/4ee1206...204bb9b)\n \n@@ -1401,6 +1478,7 @@ Released 2018-09-13\n [`items_after_statements`]: https://rust-lang.github.io/rust-clippy/master/index.html#items_after_statements\n [`iter_cloned_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_cloned_collect\n [`iter_next_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_next_loop\n+[`iter_next_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_next_slice\n [`iter_nth`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_nth\n [`iter_nth_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_nth_zero\n [`iter_skip_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_skip_next\n@@ -1601,9 +1679,11 @@ Released 2018-09-13\n [`unnecessary_fold`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_fold\n [`unnecessary_mut_passed`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_mut_passed\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n+[`unnecessary_sort_by`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_sort_by\n [`unnecessary_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_unwrap\n [`unneeded_field_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#unneeded_field_pattern\n [`unneeded_wildcard_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#unneeded_wildcard_pattern\n+[`unnested_or_patterns`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnested_or_patterns\n [`unreachable`]: https://rust-lang.github.io/rust-clippy/master/index.html#unreachable\n [`unreadable_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#unreadable_literal\n [`unsafe_derive_deserialize`]: https://rust-lang.github.io/rust-clippy/master/index.html#unsafe_derive_deserialize\n@@ -1630,6 +1710,7 @@ Released 2018-09-13\n [`useless_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_transmute\n [`useless_vec`]: https://rust-lang.github.io/rust-clippy/master/index.html#useless_vec\n [`vec_box`]: https://rust-lang.github.io/rust-clippy/master/index.html#vec_box\n+[`vec_resize_to_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#vec_resize_to_zero\n [`verbose_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#verbose_bit_mask\n [`verbose_file_reads`]: https://rust-lang.github.io/rust-clippy/master/index.html#verbose_file_reads\n [`vtable_address_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#vtable_address_comparisons"}, {"sha": "9f7bdcb1be7e568183adf643df7cc3798620c985", "filename": "src/tools/clippy/CONTRIBUTING.md", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCONTRIBUTING.md?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -12,14 +12,16 @@ anything, feel free to ask questions on issues or visit the `#clippy` on [Discor\n \n All contributors are expected to follow the [Rust Code of Conduct].\n \n-* [Getting started](#getting-started)\n-  * [Finding something to fix/improve](#finding-something-to-fiximprove)\n-* [Writing code](#writing-code)\n-* [How Clippy works](#how-clippy-works)\n-* [Fixing nightly build failures](#fixing-build-failures-caused-by-rust)\n-* [Issue and PR Triage](#issue-and-pr-triage)\n-* [Bors and Homu](#bors-and-homu)\n-* [Contributions](#contributions)\n+- [Contributing to Clippy](#contributing-to-clippy)\n+  - [Getting started](#getting-started)\n+    - [Finding something to fix/improve](#finding-something-to-fiximprove)\n+  - [Writing code](#writing-code)\n+  - [Getting code-completion for rustc internals to work](#getting-code-completion-for-rustc-internals-to-work)\n+  - [How Clippy works](#how-clippy-works)\n+  - [Fixing build failures caused by Rust](#fixing-build-failures-caused-by-rust)\n+  - [Issue and PR triage](#issue-and-pr-triage)\n+  - [Bors and Homu](#bors-and-homu)\n+  - [Contributions](#contributions)\n \n [Discord]: https://discord.gg/rust-lang\n [Rust Code of Conduct]: https://www.rust-lang.org/policies/code-of-conduct\n@@ -91,6 +93,24 @@ quick read.\n [rfc_stability]: https://github.com/rust-lang/rfcs/blob/master/text/2476-clippy-uno.md#stability-guarantees\n [rfc_lint_cats]: https://github.com/rust-lang/rfcs/blob/master/text/2476-clippy-uno.md#lint-audit-and-categories\n \n+## Getting code-completion for rustc internals to work\n+\n+Unfortunately, [`rust-analyzer`][ra_homepage] does not (yet?) understand how Clippy uses compiler-internals \n+using `extern crate` and it also needs to be able to read the source files of the rustc-compiler which are not \n+available via a `rustup` component at the time of writing.  \n+To work around this, you need to have a copy of the [rustc-repo][rustc_repo] available which can be obtained via  \n+`git clone https://github.com/rust-lang/rust/`.  \n+Then you can run a `cargo dev` command to automatically make Clippy use the rustc-repo via path-dependencies \n+which rust-analyzer will be able to understand.  \n+Run `cargo dev ra-setup --repo-path <repo-path>` where `<repo-path>` is an absolute path to the rustc repo \n+you just cloned.  \n+The command will add path-dependencies pointing towards rustc-crates inside the rustc repo to \n+Clippys `Cargo.toml`s and should allow rust-analyzer to understand most of the types that Clippy uses.\n+Just make sure to remove the dependencies again before finally making a pull request!\n+\n+[ra_homepage]: https://rust-analyzer.github.io/\n+[rustc_repo]: https://github.com/rust-lang/rust/\n+\n ## How Clippy works\n \n [`clippy_lints/src/lib.rs`][lint_crate_entry] imports all the different lint modules and registers in the [`LintStore`]."}, {"sha": "836897927b01530d8227ce135a433c9168829d50", "filename": "src/tools/clippy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCargo.toml?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -37,7 +37,7 @@ tempfile = { version = \"3.1.0\", optional = true }\n lazy_static = \"1.0\"\n \n [dev-dependencies]\n-cargo_metadata = \"0.9.0\"\n+cargo_metadata = \"0.9.1\"\n compiletest_rs = { version = \"0.5.0\", features = [\"tmp\"] }\n tester = \"0.7\"\n lazy_static = \"1.0\""}, {"sha": "5baa31d5cde0cb5f0fd4bc9f5978e0f1955efeb9", "filename": "src/tools/clippy/clippy_dev/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Flib.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -11,6 +11,7 @@ use walkdir::WalkDir;\n \n pub mod fmt;\n pub mod new_lint;\n+pub mod ra_setup;\n pub mod stderr_length_check;\n pub mod update_lints;\n \n@@ -400,7 +401,7 @@ fn test_replace_region_no_changes() {\n         changed: false,\n         new_lines: \"123\\n456\\n789\".to_string(),\n     };\n-    let result = replace_region_in_text(text, r#\"^\\s*123$\"#, r#\"^\\s*456\"#, false, || vec![]);\n+    let result = replace_region_in_text(text, r#\"^\\s*123$\"#, r#\"^\\s*456\"#, false, Vec::new);\n     assert_eq!(expected, result);\n }\n "}, {"sha": "281037ae37c9714b91ab03fa4d3f6b35e667664b", "filename": "src/tools/clippy/clippy_dev/src/main.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fmain.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,7 +1,7 @@\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n \n use clap::{App, Arg, SubCommand};\n-use clippy_dev::{fmt, new_lint, stderr_length_check, update_lints};\n+use clippy_dev::{fmt, new_lint, ra_setup, stderr_length_check, update_lints};\n \n fn main() {\n     let matches = App::new(\"Clippy developer tooling\")\n@@ -87,6 +87,19 @@ fn main() {\n             SubCommand::with_name(\"limit_stderr_length\")\n                 .about(\"Ensures that stderr files do not grow longer than a certain amount of lines.\"),\n         )\n+        .subcommand(\n+            SubCommand::with_name(\"ra-setup\")\n+                .about(\"Alter dependencies so rust-analyzer can find rustc internals\")\n+                .arg(\n+                    Arg::with_name(\"rustc-repo-path\")\n+                        .long(\"repo-path\")\n+                        .short(\"r\")\n+                        .help(\"The path to a rustc repo that will be used for setting the dependencies\")\n+                        .takes_value(true)\n+                        .value_name(\"path\")\n+                        .required(true),\n+                ),\n+        )\n         .get_matches();\n \n     match matches.subcommand() {\n@@ -115,6 +128,7 @@ fn main() {\n         (\"limit_stderr_length\", _) => {\n             stderr_length_check::check();\n         },\n+        (\"ra-setup\", Some(matches)) => ra_setup::run(matches.value_of(\"rustc-repo-path\")),\n         _ => {},\n     }\n }"}, {"sha": "1e032a7bc20cde319cd7442e4d5360d4285f2232", "filename": "src/tools/clippy/clippy_dev/src/new_lint.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fnew_lint.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -147,6 +147,8 @@ fn get_manifest_contents(lint_name: &str, hint: &str) -> String {\n name = \"{}\"\n version = \"0.1.0\"\n publish = false\n+\n+[workspace]\n \"#,\n         hint, lint_name\n     )"}, {"sha": "8617445c8a60030147556c0e221fe9155a09287e", "filename": "src/tools/clippy/clippy_dev/src/ra_setup.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fra_setup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fra_setup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fra_setup.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,90 @@\n+#![allow(clippy::filter_map)]\n+\n+use std::fs;\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::path::PathBuf;\n+\n+// This module takes an absolute path to a rustc repo and alters the dependencies to point towards\n+// the respective rustc subcrates instead of using extern crate xyz.\n+// This allows rust analyzer to analyze rustc internals and show proper information inside clippy\n+// code. See https://github.com/rust-analyzer/rust-analyzer/issues/3517 and https://github.com/rust-lang/rust-clippy/issues/5514 for details\n+\n+pub fn run(rustc_path: Option<&str>) {\n+    // we can unwrap here because the arg is required here\n+    let rustc_path = PathBuf::from(rustc_path.unwrap());\n+    assert!(rustc_path.is_dir(), \"path is not a directory\");\n+    let rustc_source_basedir = rustc_path.join(\"src\");\n+    assert!(\n+        rustc_source_basedir.is_dir(),\n+        \"are you sure the path leads to a rustc repo?\"\n+    );\n+\n+    let clippy_root_manifest = fs::read_to_string(\"Cargo.toml\").expect(\"failed to read ./Cargo.toml\");\n+    let clippy_root_lib_rs = fs::read_to_string(\"src/driver.rs\").expect(\"failed to read ./src/driver.rs\");\n+    inject_deps_into_manifest(\n+        &rustc_source_basedir,\n+        \"Cargo.toml\",\n+        &clippy_root_manifest,\n+        &clippy_root_lib_rs,\n+    )\n+    .expect(\"Failed to inject deps into ./Cargo.toml\");\n+\n+    let clippy_lints_manifest =\n+        fs::read_to_string(\"clippy_lints/Cargo.toml\").expect(\"failed to read ./clippy_lints/Cargo.toml\");\n+    let clippy_lints_lib_rs =\n+        fs::read_to_string(\"clippy_lints/src/lib.rs\").expect(\"failed to read ./clippy_lints/src/lib.rs\");\n+    inject_deps_into_manifest(\n+        &rustc_source_basedir,\n+        \"clippy_lints/Cargo.toml\",\n+        &clippy_lints_manifest,\n+        &clippy_lints_lib_rs,\n+    )\n+    .expect(\"Failed to inject deps into ./clippy_lints/Cargo.toml\");\n+}\n+\n+fn inject_deps_into_manifest(\n+    rustc_source_dir: &PathBuf,\n+    manifest_path: &str,\n+    cargo_toml: &str,\n+    lib_rs: &str,\n+) -> std::io::Result<()> {\n+    let extern_crates = lib_rs\n+        .lines()\n+        // get the deps\n+        .filter(|line| line.starts_with(\"extern crate\"))\n+        // we have something like \"extern crate foo;\", we only care about the \"foo\"\n+        //              \u2193          \u2193\n+        // extern crate rustc_middle;\n+        .map(|s| &s[13..(s.len() - 1)]);\n+\n+    let new_deps = extern_crates.map(|dep| {\n+        // format the dependencies that are going to be put inside the Cargo.toml\n+        format!(\n+            \"{dep} = {{ path = \\\"{source_path}/lib{dep}\\\" }}\\n\",\n+            dep = dep,\n+            source_path = rustc_source_dir.display()\n+        )\n+    });\n+\n+    // format a new [dependencies]-block with the new deps we need to inject\n+    let mut all_deps = String::from(\"[dependencies]\\n\");\n+    new_deps.for_each(|dep_line| {\n+        all_deps.push_str(&dep_line);\n+    });\n+\n+    // replace \"[dependencies]\" with\n+    // [dependencies]\n+    // dep1 = { path = ... }\n+    // dep2 = { path = ... }\n+    // etc\n+    let new_manifest = cargo_toml.replacen(\"[dependencies]\\n\", &all_deps, 1);\n+\n+    // println!(\"{}\", new_manifest);\n+    let mut file = File::create(manifest_path)?;\n+    file.write_all(new_manifest.as_bytes())?;\n+\n+    println!(\"Dependency paths injected: {}\", manifest_path);\n+\n+    Ok(())\n+}"}, {"sha": "e959c1a65112286fc14688e20c3906be95a69d23", "filename": "src/tools/clippy/clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2FCargo.toml?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -17,11 +17,11 @@ keywords = [\"clippy\", \"lint\", \"plugin\"]\n edition = \"2018\"\n \n [dependencies]\n-cargo_metadata = \"0.9.0\"\n+cargo_metadata = \"0.9.1\"\n if_chain = \"1.0.0\"\n itertools = \"0.9\"\n lazy_static = \"1.0.2\"\n-pulldown-cmark = { version = \"0.7\", default-features = false }\n+pulldown-cmark = { version = \"0.7.1\", default-features = false }\n quine-mc_cluskey = \"0.2.2\"\n regex-syntax = \"0.6\"\n serde = { version = \"1.0\", features = [\"derive\"] }"}, {"sha": "13e61fe98bac1d6ff18a1f61dce52ba52acf9a45", "filename": "src/tools/clippy/clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fassign_ops.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -24,7 +24,11 @@ declare_clippy_lint! {\n     /// let mut a = 5;\n     /// let b = 0;\n     /// // ...\n+    /// // Bad\n     /// a = a + b;\n+    ///\n+    /// // Good\n+    /// a += b;\n     /// ```\n     pub ASSIGN_OP_PATTERN,\n     style,"}, {"sha": "a88f922d8e03d32f7efba2c23fc6711f07e29fc2", "filename": "src/tools/clippy/clippy_lints/src/await_holding_lock.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -54,18 +54,13 @@ declare_lint_pass!(AwaitHoldingLock => [AWAIT_HOLDING_LOCK]);\n impl LateLintPass<'_, '_> for AwaitHoldingLock {\n     fn check_body(&mut self, cx: &LateContext<'_, '_>, body: &'_ Body<'_>) {\n         use AsyncGeneratorKind::{Block, Closure, Fn};\n-        match body.generator_kind {\n-            Some(GeneratorKind::Async(Block))\n-            | Some(GeneratorKind::Async(Closure))\n-            | Some(GeneratorKind::Async(Fn)) => {\n-                let body_id = BodyId {\n-                    hir_id: body.value.hir_id,\n-                };\n-                let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n-                let tables = cx.tcx.typeck_tables_of(def_id);\n-                check_interior_types(cx, &tables.generator_interior_types, body.value.span);\n-            },\n-            _ => {},\n+        if let Some(GeneratorKind::Async(Block | Closure | Fn)) = body.generator_kind {\n+            let body_id = BodyId {\n+                hir_id: body.value.hir_id,\n+            };\n+            let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n+            let tables = cx.tcx.typeck_tables_of(def_id);\n+            check_interior_types(cx, &tables.generator_interior_types, body.value.span);\n         }\n     }\n }"}, {"sha": "c40a387d29797b9f6433de48f5fdccd80beb3ce2", "filename": "src/tools/clippy/clippy_lints/src/cargo_common_metadata.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo_common_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcargo_common_metadata.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -36,13 +36,9 @@ declare_clippy_lint! {\n     \"common metadata is defined in `Cargo.toml`\"\n }\n \n-fn warning(cx: &LateContext<'_, '_>, message: &str) {\n-    span_lint(cx, CARGO_COMMON_METADATA, DUMMY_SP, message);\n-}\n-\n fn missing_warning(cx: &LateContext<'_, '_>, package: &cargo_metadata::Package, field: &str) {\n     let message = format!(\"package `{}` is missing `{}` metadata\", package.name, field);\n-    warning(cx, &message);\n+    span_lint(cx, CARGO_COMMON_METADATA, DUMMY_SP, &message);\n }\n \n fn is_empty_str(value: &Option<String>) -> bool {\n@@ -66,12 +62,7 @@ impl LateLintPass<'_, '_> for CargoCommonMetadata {\n             return;\n         }\n \n-        let metadata = if let Ok(metadata) = cargo_metadata::MetadataCommand::new().no_deps().exec() {\n-            metadata\n-        } else {\n-            warning(cx, \"could not read cargo metadata\");\n-            return;\n-        };\n+        let metadata = unwrap_cargo_metadata!(cx, CARGO_COMMON_METADATA, false);\n \n         for package in metadata.packages {\n             if is_empty_vec(&package.authors) {"}, {"sha": "e845ef99c7cc03877eca68e06a37e666e8864360", "filename": "src/tools/clippy/clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -58,24 +58,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CheckedConversions {\n             }\n         };\n \n-        if_chain! {\n-            if let Some(cv) = result;\n-            if let Some(to_type) = cv.to_type;\n-\n-            then {\n+        if let Some(cv) = result {\n+            if let Some(to_type) = cv.to_type {\n                 let mut applicability = Applicability::MachineApplicable;\n-                let snippet = snippet_with_applicability(cx, cv.expr_to_cast.span, \"_\", &mut\n-                                applicability);\n+                let snippet = snippet_with_applicability(cx, cv.expr_to_cast.span, \"_\", &mut applicability);\n                 span_lint_and_sugg(\n                     cx,\n                     CHECKED_CONVERSIONS,\n                     item.span,\n                     \"Checked cast can be simplified.\",\n                     \"try\",\n-                    format!(\"{}::try_from({}).is_ok()\",\n-                            to_type,\n-                            snippet),\n-                    applicability\n+                    format!(\"{}::try_from({}).is_ok()\", to_type, snippet),\n+                    applicability,\n                 );\n             }\n         }\n@@ -184,7 +178,7 @@ fn check_upper_bound<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<Conversion<'tcx>> {\n     if_chain! {\n          if let ExprKind::Binary(ref op, ref left, ref right) = &expr.kind;\n          if let Some((candidate, check)) = normalize_le_ge(op, left, right);\n-         if let Some((from, to)) = get_types_from_cast(check, MAX_VALUE, INTS);\n+         if let Some((from, to)) = get_types_from_cast(check, INTS, \"max_value\", \"MAX\");\n \n          then {\n              Conversion::try_new(candidate, from, to)\n@@ -224,18 +218,24 @@ fn check_lower_bound_zero<'a>(candidate: &'a Expr<'_>, check: &'a Expr<'_>) -> O\n \n /// Check for `expr >= (to_type::MIN as from_type)`\n fn check_lower_bound_min<'a>(candidate: &'a Expr<'_>, check: &'a Expr<'_>) -> Option<Conversion<'a>> {\n-    if let Some((from, to)) = get_types_from_cast(check, MIN_VALUE, SINTS) {\n+    if let Some((from, to)) = get_types_from_cast(check, SINTS, \"min_value\", \"MIN\") {\n         Conversion::try_new(candidate, from, to)\n     } else {\n         None\n     }\n }\n \n /// Tries to extract the from- and to-type from a cast expression\n-fn get_types_from_cast<'a>(expr: &'a Expr<'_>, func: &'a str, types: &'a [&str]) -> Option<(&'a str, &'a str)> {\n-    // `to_type::maxmin_value() as from_type`\n+fn get_types_from_cast<'a>(\n+    expr: &'a Expr<'_>,\n+    types: &'a [&str],\n+    func: &'a str,\n+    assoc_const: &'a str,\n+) -> Option<(&'a str, &'a str)> {\n+    // `to_type::max_value() as from_type`\n+    // or `to_type::MAX as from_type`\n     let call_from_cast: Option<(&Expr<'_>, &str)> = if_chain! {\n-        // to_type::maxmin_value(), from_type\n+        // to_type::max_value(), from_type\n         if let ExprKind::Cast(ref limit, ref from_type) = &expr.kind;\n         if let TyKind::Path(ref from_type_path) = &from_type.kind;\n         if let Some(from_sym) = int_ty_to_sym(from_type_path);\n@@ -247,17 +247,17 @@ fn get_types_from_cast<'a>(expr: &'a Expr<'_>, func: &'a str, types: &'a [&str])\n         }\n     };\n \n-    // `from_type::from(to_type::maxmin_value())`\n+    // `from_type::from(to_type::max_value())`\n     let limit_from: Option<(&Expr<'_>, &str)> = call_from_cast.or_else(|| {\n         if_chain! {\n-            // `from_type::from, to_type::maxmin_value()`\n+            // `from_type::from, to_type::max_value()`\n             if let ExprKind::Call(ref from_func, ref args) = &expr.kind;\n-            // `to_type::maxmin_value()`\n+            // `to_type::max_value()`\n             if args.len() == 1;\n             if let limit = &args[0];\n             // `from_type::from`\n             if let ExprKind::Path(ref path) = &from_func.kind;\n-            if let Some(from_sym) = get_implementing_type(path, INTS, FROM);\n+            if let Some(from_sym) = get_implementing_type(path, INTS, \"from\");\n \n             then {\n                 Some((limit, from_sym))\n@@ -268,22 +268,26 @@ fn get_types_from_cast<'a>(expr: &'a Expr<'_>, func: &'a str, types: &'a [&str])\n     });\n \n     if let Some((limit, from_type)) = limit_from {\n-        if_chain! {\n-            if let ExprKind::Call(ref fun_name, _) = &limit.kind;\n-            // `to_type, maxmin_value`\n-            if let ExprKind::Path(ref path) = &fun_name.kind;\n-            // `to_type`\n-            if let Some(to_type) = get_implementing_type(path, types, func);\n-\n-            then {\n-                Some((from_type, to_type))\n-            } else {\n-                None\n-            }\n+        match limit.kind {\n+            // `from_type::from(_)`\n+            ExprKind::Call(path, _) => {\n+                if let ExprKind::Path(ref path) = path.kind {\n+                    // `to_type`\n+                    if let Some(to_type) = get_implementing_type(path, types, func) {\n+                        return Some((from_type, to_type));\n+                    }\n+                }\n+            },\n+            // `to_type::MAX`\n+            ExprKind::Path(ref path) => {\n+                if let Some(to_type) = get_implementing_type(path, types, assoc_const) {\n+                    return Some((from_type, to_type));\n+                }\n+            },\n+            _ => {},\n         }\n-    } else {\n-        None\n-    }\n+    };\n+    None\n }\n \n /// Gets the type which implements the called function\n@@ -336,10 +340,6 @@ fn normalize_le_ge<'a>(op: &BinOp, left: &'a Expr<'a>, right: &'a Expr<'a>) -> O\n }\n \n // Constants\n-const FROM: &str = \"from\";\n-const MAX_VALUE: &str = \"max_value\";\n-const MIN_VALUE: &str = \"min_value\";\n-\n const UINTS: &[&str] = &[\"u8\", \"u16\", \"u32\", \"u64\", \"usize\"];\n const SINTS: &[&str] = &[\"i8\", \"i16\", \"i32\", \"i64\", \"isize\"];\n const INTS: &[&str] = &[\"u8\", \"u16\", \"u32\", \"u64\", \"usize\", \"i8\", \"i16\", \"i32\", \"i64\", \"isize\"];"}, {"sha": "b6d50bdfa1466f61ea04325ad4bc02c840ba9963", "filename": "src/tools/clippy/clippy_lints/src/copies.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopies.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,9 +1,9 @@\n-use crate::utils::{get_parent_expr, higher, if_sequence, same_tys, snippet, span_lint_and_note, span_lint_and_then};\n+use crate::utils::{get_parent_expr, higher, if_sequence, snippet, span_lint_and_note, span_lint_and_then};\n use crate::utils::{SpanlessEq, SpanlessHash};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{Arm, Block, Expr, ExprKind, MatchSource, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::Symbol;\n use std::collections::hash_map::Entry;\n@@ -242,15 +242,11 @@ fn lint_same_fns_in_if_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n \n /// Implementation of `MATCH_SAME_ARMS`.\n fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr<'_>) {\n-    fn same_bindings<'tcx>(\n-        cx: &LateContext<'_, 'tcx>,\n-        lhs: &FxHashMap<Symbol, Ty<'tcx>>,\n-        rhs: &FxHashMap<Symbol, Ty<'tcx>>,\n-    ) -> bool {\n+    fn same_bindings<'tcx>(lhs: &FxHashMap<Symbol, Ty<'tcx>>, rhs: &FxHashMap<Symbol, Ty<'tcx>>) -> bool {\n         lhs.len() == rhs.len()\n             && lhs\n                 .iter()\n-                .all(|(name, l_ty)| rhs.get(name).map_or(false, |r_ty| same_tys(cx, l_ty, r_ty)))\n+                .all(|(name, l_ty)| rhs.get(name).map_or(false, |r_ty| TyS::same_type(l_ty, r_ty)))\n     }\n \n     if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n@@ -269,7 +265,7 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr<'_>) {\n             (min_index..=max_index).all(|index| arms[index].guard.is_none()) &&\n                 SpanlessEq::new(cx).eq_expr(&lhs.body, &rhs.body) &&\n                 // all patterns should have the same bindings\n-                same_bindings(cx, &bindings(cx, &lhs.pat), &bindings(cx, &rhs.pat))\n+                same_bindings(&bindings(cx, &lhs.pat), &bindings(cx, &rhs.pat))\n         };\n \n         let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();"}, {"sha": "05517f6f9f0ccfe4f8b28bd38e09e19205739316", "filename": "src/tools/clippy/clippy_lints/src/double_parens.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdouble_parens.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -13,10 +13,24 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust\n+    /// // Bad\n+    /// fn simple_double_parens() -> i32 {\n+    ///     ((0))\n+    /// }\n+    ///\n+    /// // Good\n+    /// fn simple_no_parens() -> i32 {\n+    ///     0\n+    /// }\n+    ///\n+    /// // or\n+    ///\n     /// # fn foo(bar: usize) {}\n-    /// ((0));\n+    /// // Bad\n     /// foo((0));\n-    /// ((1, 2));\n+    ///\n+    /// // Good\n+    /// foo(0);\n     /// ```\n     pub DOUBLE_PARENS,\n     complexity,"}, {"sha": "5a7f759486edd2cbe13df1c26235a8f56b1d7184", "filename": "src/tools/clippy/clippy_lints/src/drop_bounds.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_bounds.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -27,6 +27,10 @@ declare_clippy_lint! {\n     /// ```rust\n     /// fn foo<T: Drop>() {}\n     /// ```\n+    /// Could be written as:\n+    /// ```rust\n+    /// fn foo<T>() {}\n+    /// ```\n     pub DROP_BOUNDS,\n     correctness,\n     \"Bounds of the form `T: Drop` are useless\""}, {"sha": "afefa2506381b99f0a108e12b5ee3e09160b12d8", "filename": "src/tools/clippy/clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fduration_subsec.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -22,8 +22,14 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # use std::time::Duration;\n     /// let dur = Duration::new(5, 0);\n+    ///\n+    /// // Bad\n     /// let _micros = dur.subsec_nanos() / 1_000;\n     /// let _millis = dur.subsec_nanos() / 1_000_000;\n+    ///\n+    /// // Good\n+    /// let _micros = dur.subsec_micros();\n+    /// let _millis = dur.subsec_millis();\n     /// ```\n     pub DURATION_SUBSEC,\n     complexity,"}, {"sha": "cb0fd59a2d4079acd2835fb752cd3e045cb43b1f", "filename": "src/tools/clippy/clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -25,31 +25,47 @@ declare_clippy_lint! {\n     ///     BattenbergCake,\n     /// }\n     /// ```\n+    /// Could be written as:\n+    /// ```rust\n+    /// enum Cake {\n+    ///     BlackForest,\n+    ///     Hummingbird,\n+    ///     Battenberg,\n+    /// }\n+    /// ```\n     pub ENUM_VARIANT_NAMES,\n     style,\n     \"enums where all variants share a prefix/postfix\"\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Detects enumeration variants that are prefixed or suffixed\n-    /// by the same characters.\n+    /// **What it does:** Detects public enumeration variants that are\n+    /// prefixed or suffixed by the same characters.\n     ///\n-    /// **Why is this bad?** Enumeration variant names should specify their variant,\n+    /// **Why is this bad?** Public enumeration variant names should specify their variant,\n     /// not repeat the enumeration name.\n     ///\n     /// **Known problems:** None.\n     ///\n     /// **Example:**\n     /// ```rust\n-    /// enum Cake {\n+    /// pub enum Cake {\n     ///     BlackForestCake,\n     ///     HummingbirdCake,\n     ///     BattenbergCake,\n     /// }\n     /// ```\n+    /// Could be written as:\n+    /// ```rust\n+    /// pub enum Cake {\n+    ///     BlackForest,\n+    ///     Hummingbird,\n+    ///     Battenberg,\n+    /// }\n+    /// ```\n     pub PUB_ENUM_VARIANT_NAMES,\n     pedantic,\n-    \"enums where all variants share a prefix/postfix\"\n+    \"public enums where all variants share a prefix/postfix\"\n }\n \n declare_clippy_lint! {\n@@ -66,6 +82,12 @@ declare_clippy_lint! {\n     ///     struct BlackForestCake;\n     /// }\n     /// ```\n+    /// Could be written as:\n+    /// ```rust\n+    /// mod cake {\n+    ///     struct BlackForest;\n+    /// }\n+    /// ```\n     pub MODULE_NAME_REPETITIONS,\n     pedantic,\n     \"type names prefixed/postfixed with their containing module's name\""}, {"sha": "d7819d737ea0445565b4bd67f7b1467b4b6b4f25", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -39,7 +39,11 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```ignore\n+    /// // Bad\n     /// &x == y\n+    ///\n+    /// // Good\n+    /// x == *y\n     /// ```\n     pub OP_REF,\n     style,"}, {"sha": "7227683aa5ac2c0104f1a535c1bbbdbb641da55b", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -28,9 +28,16 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// # fn foo(bar: usize) {}\n+    ///\n+    /// // Bad\n     /// let x = Box::new(1);\n     /// foo(*x);\n     /// println!(\"{}\", *x);\n+    ///\n+    /// // Good\n+    /// let x = 1;\n+    /// foo(x);\n+    /// println!(\"{}\", x);\n     /// ```\n     pub BOXED_LOCAL,\n     perf,"}, {"sha": "d093025fd3d7a912219d96f2975a71a165e4833e", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -26,7 +26,11 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust,ignore\n+    /// // Bad\n     /// xs.map(|x| foo(x))\n+    ///\n+    /// // Good\n+    /// xs.map(foo)\n     /// ```\n     /// where `foo(_)` is a plain function that takes the exact argument type of\n     /// `x`."}, {"sha": "74144fb299de2c6727f1e62429127c56997bf7c4", "filename": "src/tools/clippy/clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -21,11 +21,20 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// let mut x = 0;\n+    ///\n+    /// // Bad\n     /// let a = {\n     ///     x = 1;\n     ///     1\n     /// } + x;\n     /// // Unclear whether a is 1 or 2.\n+    ///\n+    /// // Good\n+    /// let tmp = {\n+    ///     x = 1;\n+    ///     1\n+    /// };\n+    /// let a = tmp + x;\n     /// ```\n     pub EVAL_ORDER_DEPENDENCE,\n     complexity,"}, {"sha": "92812816461c568b75c309da7c2f08853564f75b", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -20,12 +20,31 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// struct Foo(i32);\n+    ///\n+    /// // Bad\n     /// impl From<String> for Foo {\n     ///     fn from(s: String) -> Self {\n     ///         Foo(s.parse().unwrap())\n     ///     }\n     /// }\n     /// ```\n+    ///\n+    /// ```rust\n+    /// // Good\n+    /// struct Foo(i32);\n+    ///\n+    /// use std::convert::TryFrom;\n+    /// impl TryFrom<String> for Foo {\n+    ///     type Error = ();\n+    ///     fn try_from(s: String) -> Result<Self, Self::Error> {\n+    ///         if let Ok(parsed) = s.parse() {\n+    ///             Ok(Foo(parsed))\n+    ///         } else {\n+    ///             Err(())\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n     pub FALLIBLE_IMPL_FROM,\n     nursery,\n     \"Warn on impls of `From<..>` that contain `panic!()` or `unwrap()`\"\n@@ -120,7 +139,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n                         move |diag| {\n                             diag.help(\n                                 \"`From` is intended for infallible conversions only. \\\n-                                 Use `TryFrom` if there's a possibility for the conversion to fail.\");\n+                                Use `TryFrom` if there's a possibility for the conversion to fail.\");\n                             diag.span_note(fpu.result, \"potential failure(s)\");\n                         });\n                 }"}, {"sha": "3a912d928375ddc79e6b620f8e4c23a302a0c4f5", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -28,7 +28,6 @@ declare_clippy_lint! {\n     /// **Example:**\n     ///\n     /// ```rust\n-    ///\n     /// let a = 3f32;\n     /// let _ = a.powf(1.0 / 3.0);\n     /// let _ = (1.0 + a).ln();\n@@ -38,7 +37,6 @@ declare_clippy_lint! {\n     /// is better expressed as\n     ///\n     /// ```rust\n-    ///\n     /// let a = 3f32;\n     /// let _ = a.cbrt();\n     /// let _ = a.ln_1p();"}, {"sha": "1530538aa7d13107f07fce63377a54ce44e6ad0b", "filename": "src/tools/clippy/clippy_lints/src/format.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -25,9 +25,13 @@ declare_clippy_lint! {\n     ///\n     /// **Examples:**\n     /// ```rust\n+    ///\n+    /// // Bad\n     /// # let foo = \"foo\";\n-    /// format!(\"foo\");\n     /// format!(\"{}\", foo);\n+    ///\n+    /// // Good\n+    /// format!(\"foo\");\n     /// ```\n     pub USELESS_FORMAT,\n     complexity,"}, {"sha": "156246fb8bbb01b190871ffc912c76536530c344", "filename": "src/tools/clippy/clippy_lints/src/formatting.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -112,12 +112,8 @@ declare_lint_pass!(Formatting => [\n impl EarlyLintPass for Formatting {\n     fn check_block(&mut self, cx: &EarlyContext<'_>, block: &Block) {\n         for w in block.stmts.windows(2) {\n-            match (&w[0].kind, &w[1].kind) {\n-                (&StmtKind::Expr(ref first), &StmtKind::Expr(ref second))\n-                | (&StmtKind::Expr(ref first), &StmtKind::Semi(ref second)) => {\n-                    check_missing_else(cx, first, second);\n-                },\n-                _ => (),\n+            if let (StmtKind::Expr(first), StmtKind::Expr(second) | StmtKind::Semi(second)) = (&w[0].kind, &w[1].kind) {\n+                check_missing_else(cx, first, second);\n             }\n         }\n     }"}, {"sha": "325b6cf32a3d293a03c0abe2e7337a19c28e4a34", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -49,11 +49,11 @@ declare_clippy_lint! {\n     /// **Known problems:** None.\n     ///\n     /// **Example:**\n-    /// ``` rust\n+    /// ```rust\n     /// fn im_too_long() {\n-    /// println!(\"\");\n-    /// // ... 100 more LoC\n-    /// println!(\"\");\n+    ///     println!(\"\");\n+    ///     // ... 100 more LoC\n+    ///     println!(\"\");\n     /// }\n     /// ```\n     pub TOO_MANY_LINES,\n@@ -79,10 +79,16 @@ declare_clippy_lint! {\n     /// `some_argument.get_raw_ptr()`).\n     ///\n     /// **Example:**\n-    /// ```rust\n+    /// ```rust,ignore\n+    /// // Bad\n     /// pub fn foo(x: *const u8) {\n     ///     println!(\"{}\", unsafe { *x });\n     /// }\n+    ///\n+    /// // Good\n+    /// pub unsafe fn foo(x: *const u8) {\n+    ///     println!(\"{}\", unsafe { *x });\n+    /// }\n     /// ```\n     pub NOT_UNSAFE_PTR_ARG_DEREF,\n     correctness,"}, {"sha": "fdaf37e5e08fa79abb7a21ae94550db6aadfdfd6", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -25,13 +25,6 @@ declare_clippy_lint! {\n     /// if i != 0 {\n     ///     i -= 1;\n     /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let end: u32 = 10;\n-    /// let start: u32 = 5;\n-    ///\n-    /// let mut i: u32 = end - start;\n     ///\n     /// // Good\n     /// i = i.saturating_sub(1);"}, {"sha": "e91fb0c2f27cd0340caf1ace6afb0fb8e70d7098", "filename": "src/tools/clippy/clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fint_plus_one.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -10,7 +10,6 @@ use crate::utils::{snippet_opt, span_lint_and_sugg};\n declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `x >= y + 1` or `x - 1 >= y` (and `<=`) in a block\n     ///\n-    ///\n     /// **Why is this bad?** Readability -- better to use `> y` instead of `>= y + 1`.\n     ///\n     /// **Known problems:** None."}, {"sha": "d537ef3f3238e05c9cb0029d959800fbd1ca145f", "filename": "src/tools/clippy/clippy_lints/src/integer_division.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finteger_division.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -15,10 +15,13 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust\n-    /// fn main() {\n-    ///     let x = 3 / 2;\n-    ///     println!(\"{}\", x);\n-    /// }\n+    /// // Bad\n+    /// let x = 3 / 2;\n+    /// println!(\"{}\", x);\n+    ///\n+    /// // Good\n+    /// let x = 3f32 / 2f32;\n+    /// println!(\"{}\", x);\n     /// ```\n     pub INTEGER_DIVISION,\n     restriction,"}, {"sha": "c8576bcfcb444bfdcd436e005da71d0791ece679", "filename": "src/tools/clippy/clippy_lints/src/items_after_statements.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fitems_after_statements.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -16,6 +16,7 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust\n+    /// // Bad\n     /// fn foo() {\n     ///     println!(\"cake\");\n     /// }\n@@ -28,6 +29,21 @@ declare_clippy_lint! {\n     ///     foo(); // prints \"foo\"\n     /// }\n     /// ```\n+    ///\n+    /// ```rust\n+    /// // Good\n+    /// fn foo() {\n+    ///     println!(\"cake\");\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     fn foo() {\n+    ///         println!(\"foo\");\n+    ///     }\n+    ///     foo(); // prints \"foo\"\n+    ///     foo(); // prints \"foo\"\n+    /// }\n+    /// ```\n     pub ITEMS_AFTER_STATEMENTS,\n     pedantic,\n     \"blocks where an item comes after a statement\""}, {"sha": "f5bfede75a76171a0deed70db698ce938b56b359", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{get_item_name, snippet_with_applicability, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n+use crate::utils::{get_item_name, higher, snippet_with_applicability, span_lint, span_lint_and_sugg, walk_ptrs_ty};\n use rustc_ast::ast::LitKind;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n@@ -259,6 +259,17 @@ fn check_len(\n \n /// Checks if this type has an `is_empty` method.\n fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+    /// Special case ranges until `range_is_empty` is stabilized. See issue 3807.\n+    fn should_skip_range(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+        higher::range(cx, expr).map_or(false, |_| {\n+            !cx.tcx\n+                .features()\n+                .declared_lib_features\n+                .iter()\n+                .any(|(name, _)| name.as_str() == \"range_is_empty\")\n+        })\n+    }\n+\n     /// Gets an `AssocItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext<'_, '_>, item: &ty::AssocItem) -> bool {\n         if let ty::AssocKind::Fn = item.kind {\n@@ -284,6 +295,10 @@ fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n         })\n     }\n \n+    if should_skip_range(cx, expr) {\n+        return false;\n+    }\n+\n     let ty = &walk_ptrs_ty(cx.tables.expr_ty(expr));\n     match ty.kind {\n         ty::Dynamic(ref tt, ..) => {"}, {"sha": "6d3fb317bcfc5fa0f0a612780bb798b6ecab9112", "filename": "src/tools/clippy/clippy_lints/src/let_and_return.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,141 @@\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{Block, Expr, ExprKind, PatKind, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use crate::utils::{in_macro, match_qpath, snippet_opt, span_lint_and_then};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `let`-bindings, which are subsequently\n+    /// returned.\n+    ///\n+    /// **Why is this bad?** It is just extraneous code. Remove it to make your code\n+    /// more rusty.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn foo() -> String {\n+    ///     let x = String::new();\n+    ///     x\n+    /// }\n+    /// ```\n+    /// instead, use\n+    /// ```\n+    /// fn foo() -> String {\n+    ///     String::new()\n+    /// }\n+    /// ```\n+    pub LET_AND_RETURN,\n+    style,\n+    \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\"\n+}\n+\n+declare_lint_pass!(LetReturn => [LET_AND_RETURN]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetReturn {\n+    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block<'_>) {\n+        // we need both a let-binding stmt and an expr\n+        if_chain! {\n+            if let Some(retexpr) = block.expr;\n+            if let Some(stmt) = block.stmts.iter().last();\n+            if let StmtKind::Local(local) = &stmt.kind;\n+            if local.ty.is_none();\n+            if local.attrs.is_empty();\n+            if let Some(initexpr) = &local.init;\n+            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n+            if let ExprKind::Path(qpath) = &retexpr.kind;\n+            if match_qpath(qpath, &[&*ident.name.as_str()]);\n+            if !last_statement_borrows(cx, initexpr);\n+            if !in_external_macro(cx.sess(), initexpr.span);\n+            if !in_external_macro(cx.sess(), retexpr.span);\n+            if !in_external_macro(cx.sess(), local.span);\n+            if !in_macro(local.span);\n+            then {\n+                span_lint_and_then(\n+                    cx,\n+                    LET_AND_RETURN,\n+                    retexpr.span,\n+                    \"returning the result of a `let` binding from a block\",\n+                    |err| {\n+                        err.span_label(local.span, \"unnecessary `let` binding\");\n+\n+                        if let Some(snippet) = snippet_opt(cx, initexpr.span) {\n+                            err.multipart_suggestion(\n+                                \"return the expression directly\",\n+                                vec![\n+                                    (local.span, String::new()),\n+                                    (retexpr.span, snippet),\n+                                ],\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            err.span_help(initexpr.span, \"this expression can be directly returned\");\n+                        }\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn last_statement_borrows<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    let mut visitor = BorrowVisitor { cx, borrows: false };\n+    walk_expr(&mut visitor, expr);\n+    visitor.borrows\n+}\n+\n+struct BorrowVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    borrows: bool,\n+}\n+\n+impl BorrowVisitor<'_, '_> {\n+    fn fn_def_id(&self, expr: &Expr<'_>) -> Option<DefId> {\n+        match &expr.kind {\n+            ExprKind::MethodCall(..) => self.cx.tables.type_dependent_def_id(expr.hir_id),\n+            ExprKind::Call(\n+                Expr {\n+                    kind: ExprKind::Path(qpath),\n+                    ..\n+                },\n+                ..,\n+            ) => self.cx.tables.qpath_res(qpath, expr.hir_id).opt_def_id(),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.borrows {\n+            return;\n+        }\n+\n+        if let Some(def_id) = self.fn_def_id(expr) {\n+            self.borrows = self\n+                .cx\n+                .tcx\n+                .fn_sig(def_id)\n+                .output()\n+                .skip_binder()\n+                .walk()\n+                .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "cd258c7b506c39ccd635b4560fd19004958b0d6e", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,5 +1,6 @@\n // error-pattern:cargo-clippy\n \n+#![feature(bindings_after_at)]\n #![feature(box_syntax)]\n #![feature(box_patterns)]\n #![feature(or_patterns)]\n@@ -12,6 +13,7 @@\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n #![feature(crate_visibility_modifier)]\n #![feature(concat_idents)]\n+#![feature(drain_filter)]\n \n // FIXME: switch to something more ergonomic here, once available.\n // (Currently there is no way to opt into sysroot crates without `extern crate`.)\n@@ -239,6 +241,7 @@ mod large_const_arrays;\n mod large_enum_variant;\n mod large_stack_arrays;\n mod len_zero;\n+mod let_and_return;\n mod let_if_seq;\n mod let_underscore;\n mod lifetimes;\n@@ -318,13 +321,16 @@ mod try_err;\n mod types;\n mod unicode;\n mod unnamed_address;\n+mod unnecessary_sort_by;\n+mod unnested_or_patterns;\n mod unsafe_removed_from_name;\n mod unused_io_amount;\n mod unused_self;\n mod unwrap;\n mod use_self;\n mod useless_conversion;\n mod vec;\n+mod vec_resize_to_zero;\n mod verbose_file_reads;\n mod wildcard_dependencies;\n mod wildcard_imports;\n@@ -594,6 +600,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &large_stack_arrays::LARGE_STACK_ARRAYS,\n         &len_zero::LEN_WITHOUT_IS_EMPTY,\n         &len_zero::LEN_ZERO,\n+        &let_and_return::LET_AND_RETURN,\n         &let_if_seq::USELESS_LET_IF_SEQ,\n         &let_underscore::LET_UNDERSCORE_LOCK,\n         &let_underscore::LET_UNDERSCORE_MUST_USE,\n@@ -664,6 +671,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::INTO_ITER_ON_REF,\n         &methods::ITERATOR_STEP_BY_ZERO,\n         &methods::ITER_CLONED_COLLECT,\n+        &methods::ITER_NEXT_SLICE,\n         &methods::ITER_NTH,\n         &methods::ITER_NTH_ZERO,\n         &methods::ITER_SKIP_NEXT,\n@@ -769,7 +777,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &regex::INVALID_REGEX,\n         &regex::REGEX_MACRO,\n         &regex::TRIVIAL_REGEX,\n-        &returns::LET_AND_RETURN,\n         &returns::NEEDLESS_RETURN,\n         &returns::UNUSED_UNIT,\n         &serde_api::SERDE_API_MISUSE,\n@@ -832,6 +839,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &unicode::ZERO_WIDTH_SPACE,\n         &unnamed_address::FN_ADDRESS_COMPARISONS,\n         &unnamed_address::VTABLE_ADDRESS_COMPARISONS,\n+        &unnecessary_sort_by::UNNECESSARY_SORT_BY,\n+        &unnested_or_patterns::UNNESTED_OR_PATTERNS,\n         &unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,\n         &unused_io_amount::UNUSED_IO_AMOUNT,\n         &unused_self::UNUSED_SELF,\n@@ -847,6 +856,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n         &utils::internal_lints::PRODUCE_ICE,\n         &vec::USELESS_VEC,\n+        &vec_resize_to_zero::VEC_RESIZE_TO_ZERO,\n         &verbose_file_reads::VERBOSE_FILE_READS,\n         &wildcard_dependencies::WILDCARD_DEPENDENCIES,\n         &wildcard_imports::ENUM_GLOB_USE,\n@@ -994,6 +1004,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box ptr_offset_with_cast::PtrOffsetWithCast);\n     store.register_late_pass(|| box redundant_clone::RedundantClone);\n     store.register_late_pass(|| box slow_vector_initialization::SlowVectorInit);\n+    store.register_late_pass(|| box unnecessary_sort_by::UnnecessarySortBy);\n     store.register_late_pass(|| box types::RefToMut);\n     store.register_late_pass(|| box assertions_on_constants::AssertionsOnConstants);\n     store.register_late_pass(|| box missing_const_for_fn::MissingConstForFn);\n@@ -1016,6 +1027,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box formatting::Formatting);\n     store.register_early_pass(|| box misc_early::MiscEarlyLints);\n     store.register_early_pass(|| box returns::Return);\n+    store.register_late_pass(|| box let_and_return::LetReturn);\n     store.register_early_pass(|| box collapsible_if::CollapsibleIf);\n     store.register_early_pass(|| box items_after_statements::ItemsAfterStatements);\n     store.register_early_pass(|| box precedence::Precedence);\n@@ -1062,10 +1074,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box manual_non_exhaustive::ManualNonExhaustive);\n     store.register_late_pass(|| box manual_async_fn::ManualAsyncFn);\n     store.register_early_pass(|| box redundant_field_names::RedundantFieldNames);\n+    store.register_late_pass(|| box vec_resize_to_zero::VecResizeToZero);\n     let single_char_binding_names_threshold = conf.single_char_binding_names_threshold;\n     store.register_early_pass(move || box non_expressive_names::NonExpressiveNames {\n         single_char_binding_names_threshold,\n     });\n+    store.register_early_pass(|| box unnested_or_patterns::UnnestedOrPatterns);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1164,6 +1178,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::CAST_POSSIBLE_TRUNCATION),\n         LintId::of(&types::CAST_POSSIBLE_WRAP),\n         LintId::of(&types::CAST_PRECISION_LOSS),\n+        LintId::of(&types::CAST_PTR_ALIGNMENT),\n         LintId::of(&types::CAST_SIGN_LOSS),\n         LintId::of(&types::IMPLICIT_HASHER),\n         LintId::of(&types::INVALID_UPCAST_COMPARISONS),\n@@ -1257,6 +1272,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&large_enum_variant::LARGE_ENUM_VARIANT),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n+        LintId::of(&let_and_return::LET_AND_RETURN),\n         LintId::of(&let_underscore::LET_UNDERSCORE_LOCK),\n         LintId::of(&lifetimes::EXTRA_UNUSED_LIFETIMES),\n         LintId::of(&lifetimes::NEEDLESS_LIFETIMES),\n@@ -1303,6 +1319,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::INTO_ITER_ON_REF),\n         LintId::of(&methods::ITERATOR_STEP_BY_ZERO),\n         LintId::of(&methods::ITER_CLONED_COLLECT),\n+        LintId::of(&methods::ITER_NEXT_SLICE),\n         LintId::of(&methods::ITER_NTH),\n         LintId::of(&methods::ITER_NTH_ZERO),\n         LintId::of(&methods::ITER_SKIP_NEXT),\n@@ -1381,7 +1398,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&regex::INVALID_REGEX),\n         LintId::of(&regex::REGEX_MACRO),\n         LintId::of(&regex::TRIVIAL_REGEX),\n-        LintId::of(&returns::LET_AND_RETURN),\n         LintId::of(&returns::NEEDLESS_RETURN),\n         LintId::of(&returns::UNUSED_UNIT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n@@ -1410,7 +1426,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::ABSURD_EXTREME_COMPARISONS),\n         LintId::of(&types::BORROWED_BOX),\n         LintId::of(&types::BOX_VEC),\n-        LintId::of(&types::CAST_PTR_ALIGNMENT),\n         LintId::of(&types::CAST_REF_TO_MUT),\n         LintId::of(&types::CHAR_LIT_AS_U8),\n         LintId::of(&types::FN_TO_NUMERIC_CAST),\n@@ -1424,12 +1439,15 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&unicode::ZERO_WIDTH_SPACE),\n         LintId::of(&unnamed_address::FN_ADDRESS_COMPARISONS),\n         LintId::of(&unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n+        LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n+        LintId::of(&unnested_or_patterns::UNNESTED_OR_PATTERNS),\n         LintId::of(&unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n         LintId::of(&unused_io_amount::UNUSED_IO_AMOUNT),\n         LintId::of(&unwrap::PANICKING_UNWRAP),\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n         LintId::of(&useless_conversion::USELESS_CONVERSION),\n         LintId::of(&vec::USELESS_VEC),\n+        LintId::of(&vec_resize_to_zero::VEC_RESIZE_TO_ZERO),\n         LintId::of(&write::PRINTLN_EMPTY_STRING),\n         LintId::of(&write::PRINT_LITERAL),\n         LintId::of(&write::PRINT_WITH_NEWLINE),\n@@ -1464,6 +1482,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n         LintId::of(&len_zero::LEN_ZERO),\n+        LintId::of(&let_and_return::LET_AND_RETURN),\n         LintId::of(&literal_representation::INCONSISTENT_DIGIT_GROUPING),\n         LintId::of(&loops::EMPTY_LOOP),\n         LintId::of(&loops::FOR_KV_MAP),\n@@ -1483,6 +1502,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::CHARS_NEXT_CMP),\n         LintId::of(&methods::INTO_ITER_ON_REF),\n         LintId::of(&methods::ITER_CLONED_COLLECT),\n+        LintId::of(&methods::ITER_NEXT_SLICE),\n         LintId::of(&methods::ITER_NTH_ZERO),\n         LintId::of(&methods::ITER_SKIP_NEXT),\n         LintId::of(&methods::MANUAL_SATURATING_ARITHMETIC),\n@@ -1515,7 +1535,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n         LintId::of(&regex::REGEX_MACRO),\n         LintId::of(&regex::TRIVIAL_REGEX),\n-        LintId::of(&returns::LET_AND_RETURN),\n         LintId::of(&returns::NEEDLESS_RETURN),\n         LintId::of(&returns::UNUSED_UNIT),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n@@ -1604,6 +1623,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&types::UNIT_ARG),\n         LintId::of(&types::UNNECESSARY_CAST),\n         LintId::of(&types::VEC_BOX),\n+        LintId::of(&unnecessary_sort_by::UNNECESSARY_SORT_BY),\n+        LintId::of(&unnested_or_patterns::UNNESTED_OR_PATTERNS),\n         LintId::of(&unwrap::UNNECESSARY_UNWRAP),\n         LintId::of(&useless_conversion::USELESS_CONVERSION),\n         LintId::of(&zero_div_zero::ZERO_DIVIDED_BY_ZERO),\n@@ -1669,14 +1690,14 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&transmute::WRONG_TRANSMUTE),\n         LintId::of(&transmuting_null::TRANSMUTING_NULL),\n         LintId::of(&types::ABSURD_EXTREME_COMPARISONS),\n-        LintId::of(&types::CAST_PTR_ALIGNMENT),\n         LintId::of(&types::CAST_REF_TO_MUT),\n         LintId::of(&types::UNIT_CMP),\n         LintId::of(&unicode::ZERO_WIDTH_SPACE),\n         LintId::of(&unnamed_address::FN_ADDRESS_COMPARISONS),\n         LintId::of(&unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n         LintId::of(&unused_io_amount::UNUSED_IO_AMOUNT),\n         LintId::of(&unwrap::PANICKING_UNWRAP),\n+        LintId::of(&vec_resize_to_zero::VEC_RESIZE_TO_ZERO),\n     ]);\n \n     store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec!["}, {"sha": "7ba43562d7d447b565095ae2b033d1f125df6483", "filename": "src/tools/clippy/clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -24,7 +24,11 @@ declare_clippy_lint! {\n     /// **Example:**\n     ///\n     /// ```rust\n+    /// // Bad\n     /// let x: u64 = 61864918973511;\n+    ///\n+    /// // Good\n+    /// let x: u64 = 61_864_918_973_511;\n     /// ```\n     pub UNREADABLE_LITERAL,\n     pedantic,\n@@ -44,7 +48,11 @@ declare_clippy_lint! {\n     /// **Example:**\n     ///\n     /// ```rust\n+    /// // Probably mistyped\n     /// 2_32;\n+    ///\n+    /// // Good\n+    /// 2_i32;\n     /// ```\n     pub MISTYPED_LITERAL_SUFFIXES,\n     correctness,\n@@ -63,7 +71,11 @@ declare_clippy_lint! {\n     /// **Example:**\n     ///\n     /// ```rust\n+    /// // Bad\n     /// let x: u64 = 618_64_9189_73_511;\n+    ///\n+    /// // Good\n+    /// let x: u64 = 61_864_918_973_511;\n     /// ```\n     pub INCONSISTENT_DIGIT_GROUPING,\n     style,"}, {"sha": "57c62d739640f2c7f4640f08991d8375300bcade", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -8,7 +8,7 @@ use crate::utils::{\n     multispan_sugg, snippet, snippet_opt, snippet_with_applicability, span_lint, span_lint_and_help,\n     span_lint_and_sugg, span_lint_and_then, SpanlessEq,\n };\n-use crate::utils::{is_type_diagnostic_item, qpath_res, same_tys, sugg};\n+use crate::utils::{is_type_diagnostic_item, qpath_res, sugg};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -24,10 +24,10 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::middle::region;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::BytePos;\n+use rustc_span::symbol::Symbol;\n use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Place, PlaceBase};\n use std::iter::{once, Iterator};\n use std::mem;\n@@ -1256,7 +1256,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>, e\n             } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n                 let receiver_ty = cx.tables.expr_ty(&args[0]);\n                 let receiver_ty_adjusted = cx.tables.expr_ty_adjusted(&args[0]);\n-                if same_tys(cx, receiver_ty, receiver_ty_adjusted) {\n+                if TyS::same_type(receiver_ty, receiver_ty_adjusted) {\n                     let mut applicability = Applicability::MachineApplicable;\n                     let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n                     span_lint_and_sugg(\n@@ -1277,7 +1277,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>, e\n                             mutbl: Mutability::Not,\n                         },\n                     );\n-                    if same_tys(cx, receiver_ty_adjusted, ref_receiver_ty) {\n+                    if TyS::same_type(receiver_ty_adjusted, ref_receiver_ty) {\n                         lint_iter_method(cx, args, arg, method_name)\n                     }\n                 }\n@@ -2381,32 +2381,32 @@ fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'a, '\n                 match_type(cx, ty, &paths::BTREEMAP) ||\n                 is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) {\n                 if method.ident.name == sym!(len) {\n-                    let span = shorten_needless_collect_span(expr);\n+                    let span = shorten_span(expr, sym!(collect));\n                     span_lint_and_sugg(\n                         cx,\n                         NEEDLESS_COLLECT,\n                         span,\n                         NEEDLESS_COLLECT_MSG,\n                         \"replace with\",\n-                        \".count()\".to_string(),\n+                        \"count()\".to_string(),\n                         Applicability::MachineApplicable,\n                     );\n                 }\n                 if method.ident.name == sym!(is_empty) {\n-                    let span = shorten_needless_collect_span(expr);\n+                    let span = shorten_span(expr, sym!(iter));\n                     span_lint_and_sugg(\n                         cx,\n                         NEEDLESS_COLLECT,\n                         span,\n                         NEEDLESS_COLLECT_MSG,\n                         \"replace with\",\n-                        \".next().is_none()\".to_string(),\n+                        \"get(0).is_none()\".to_string(),\n                         Applicability::MachineApplicable,\n                     );\n                 }\n                 if method.ident.name == sym!(contains) {\n                     let contains_arg = snippet(cx, args[1].span, \"??\");\n-                    let span = shorten_needless_collect_span(expr);\n+                    let span = shorten_span(expr, sym!(collect));\n                     span_lint_and_then(\n                         cx,\n                         NEEDLESS_COLLECT,\n@@ -2422,7 +2422,7 @@ fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'a, '\n                                 span,\n                                 \"replace with\",\n                                 format!(\n-                                    \".any(|{}| x == {})\",\n+                                    \"any(|{}| x == {})\",\n                                     arg, pred\n                                 ),\n                                 Applicability::MachineApplicable,\n@@ -2435,13 +2435,13 @@ fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'a, '\n     }\n }\n \n-fn shorten_needless_collect_span(expr: &Expr<'_>) -> Span {\n-    if_chain! {\n-        if let ExprKind::MethodCall(_, _, ref args) = expr.kind;\n-        if let ExprKind::MethodCall(_, ref span, _) = args[0].kind;\n-        then {\n-            return expr.span.with_lo(span.lo() - BytePos(1));\n+fn shorten_span(expr: &Expr<'_>, target_fn_name: Symbol) -> Span {\n+    let mut current_expr = expr;\n+    while let ExprKind::MethodCall(ref path, ref span, ref args) = current_expr.kind {\n+        if path.ident.name == target_fn_name {\n+            return expr.span.with_lo(span.lo());\n         }\n+        current_expr = &args[0];\n     }\n     unreachable!()\n }"}, {"sha": "6d7af45a47224d54a99e6949c50185e792acf9bc", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -36,10 +36,17 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # fn bar(stool: &str) {}\n     /// # let x = Some(\"abc\");\n+    ///\n+    /// // Bad\n     /// match x {\n     ///     Some(ref foo) => bar(foo),\n     ///     _ => (),\n     /// }\n+    ///\n+    /// // Good\n+    /// if let Some(ref foo) = x {\n+    ///     bar(foo);\n+    /// }\n     /// ```\n     pub SINGLE_MATCH,\n     style,\n@@ -97,11 +104,19 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust,ignore\n+    /// // Bad\n     /// match x {\n     ///     &A(ref y) => foo(y),\n     ///     &B => bar(),\n     ///     _ => frob(&x),\n     /// }\n+    ///\n+    /// // Good\n+    /// match *x {\n+    ///     A(ref y) => foo(y),\n+    ///     B => bar(),\n+    ///     _ => frob(x),\n+    /// }\n     /// ```\n     pub MATCH_REF_PATS,\n     style,\n@@ -197,10 +212,15 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// let x: Option<()> = None;\n+    ///\n+    /// // Bad\n     /// let r: Option<&()> = match x {\n     ///     None => None,\n     ///     Some(ref v) => Some(v),\n     /// };\n+    ///\n+    /// // Good\n+    /// let r: Option<&()> = x.as_ref();\n     /// ```\n     pub MATCH_AS_REF,\n     complexity,\n@@ -219,10 +239,18 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # enum Foo { A(usize), B(usize) }\n     /// # let x = Foo::B(1);\n+    ///\n+    /// // Bad\n     /// match x {\n     ///     Foo::A(_) => {},\n     ///     _ => {},\n     /// }\n+    ///\n+    /// // Good\n+    /// match x {\n+    ///     Foo::A(_) => {},\n+    ///     Foo::B(_) => {},\n+    /// }\n     /// ```\n     pub WILDCARD_ENUM_MATCH_ARM,\n     restriction,\n@@ -242,16 +270,14 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # enum Foo { A, B, C }\n     /// # let x = Foo::B;\n+    /// // Bad\n     /// match x {\n     ///     Foo::A => {},\n     ///     Foo::B => {},\n     ///     _ => {},\n     /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// # enum Foo { A, B, C }\n-    /// # let x = Foo::B;\n+    ///\n+    /// // Good\n     /// match x {\n     ///     Foo::A => {},\n     ///     Foo::B => {},\n@@ -273,10 +299,17 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust\n+    /// // Bad\n     /// match \"foo\" {\n     ///     \"a\" => {},\n     ///     \"bar\" | _ => {},\n     /// }\n+    ///\n+    /// // Good\n+    /// match \"foo\" {\n+    ///     \"a\" => {},\n+    ///     _ => {},\n+    /// }\n     /// ```\n     pub WILDCARD_IN_OR_PATTERNS,\n     complexity,"}, {"sha": "4f5c06e785c23eeb1eded772c87a595ed1a6a49b", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -57,7 +57,7 @@ pub fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[&[hir::Expr<\n         );\n     } else {\n         match (mm, arith) {\n-            (MinMax::Max, \"add\") | (MinMax::Max, \"mul\") | (MinMax::Min, \"sub\") => (),\n+            (MinMax::Max, \"add\" | \"mul\") | (MinMax::Min, \"sub\") => (),\n             _ => return,\n         }\n "}, {"sha": "214cf0c130f217fe5181ca318e6b7c3444af42a4", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 147, "deletions": 31, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -18,20 +18,20 @@ use rustc_lint::{LateContext, LateLintPass, Lint, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, SymbolStr};\n \n use crate::consts::{constant, Constant};\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n-    get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, implements_trait, in_macro, is_copy,\n+    get_arg_name, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait, in_macro, is_copy,\n     is_ctor_or_promotable_const_function, is_expn_of, is_type_diagnostic_item, iter_input_pats, last_path_segment,\n     match_def_path, match_qpath, match_trait_method, match_type, match_var, method_calls, method_chain_args, paths,\n-    remove_blocks, return_ty, same_tys, single_segment_path, snippet, snippet_with_applicability,\n-    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_note, span_lint_and_sugg,\n-    span_lint_and_then, sugg, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq,\n+    remove_blocks, return_ty, single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n+    span_lint, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then, sugg, walk_ptrs_ty,\n+    walk_ptrs_ty_depth, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -218,7 +218,12 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// # let x = Ok::<_, ()>(());\n-    /// x.ok().expect(\"why did I do this again?\")\n+    ///\n+    /// // Bad\n+    /// x.ok().expect(\"why did I do this again?\");\n+    ///\n+    /// // Good\n+    /// x.expect(\"why did I do this again?\");\n     /// ```\n     pub OK_EXPECT,\n     style,\n@@ -273,8 +278,12 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// # let opt = Some(1);\n-    /// opt.map_or(None, |a| Some(a + 1))\n-    /// # ;\n+    ///\n+    /// // Bad\n+    /// opt.map_or(None, |a| Some(a + 1));\n+    ///\n+    /// // Good\n+    /// opt.and_then(|a| Some(a + 1));\n     /// ```\n     pub OPTION_MAP_OR_NONE,\n     style,\n@@ -390,14 +399,19 @@ declare_clippy_lint! {\n     /// **What it does:** Checks for usage of `_.map(_).flatten(_)`,\n     ///\n     /// **Why is this bad?** Readability, this can be written more concisely as a\n-    /// single method call.\n+    /// single method call using `_.flat_map(_)`\n     ///\n     /// **Known problems:**\n     ///\n     /// **Example:**\n     /// ```rust\n     /// let vec = vec![vec![1]];\n+    ///\n+    /// // Bad\n     /// vec.iter().map(|x| x.iter()).flatten();\n+    ///\n+    /// // Good\n+    /// vec.iter().flat_map(|x| x.iter());\n     /// ```\n     pub MAP_FLATTEN,\n     pedantic,\n@@ -417,7 +431,16 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// let vec = vec![1];\n+    ///\n+    /// // Bad\n     /// vec.iter().filter(|x| **x == 0).map(|x| *x * 2);\n+    ///\n+    /// // Good\n+    /// vec.iter().filter_map(|x| if *x == 0 {\n+    ///     Some(*x * 2)\n+    /// } else {\n+    ///     None\n+    /// });\n     /// ```\n     pub FILTER_MAP,\n     pedantic,\n@@ -634,7 +657,12 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # use std::rc::Rc;\n     /// let x = Rc::new(1);\n+    ///\n+    /// // Bad\n     /// x.clone();\n+    ///\n+    /// // Good\n+    /// Rc::clone(&x);\n     /// ```\n     pub CLONE_ON_REF_PTR,\n     restriction,\n@@ -741,7 +769,12 @@ declare_clippy_lint! {\n     /// **Known problems:** Does not catch multi-byte unicode characters.\n     ///\n     /// **Example:**\n-    /// `_.split(\"x\")` could be `_.split('x')`\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// _.split(\"x\");\n+    ///\n+    /// // Good\n+    /// _.split('x');\n     pub SINGLE_CHAR_PATTERN,\n     perf,\n     \"using a single-character str where a char could be used, e.g., `_.split(\\\"x\\\")`\"\n@@ -964,8 +997,8 @@ declare_clippy_lint! {\n }\n \n declare_clippy_lint! {\n-    /// **What it does:** Checks for usage of `.chars().last()` or\n-    /// `.chars().next_back()` on a `str` to check if it ends with a given char.\n+    /// **What it does:** Checks for usage of `_.chars().last()` or\n+    /// `_.chars().next_back()` on a `str` to check if it ends with a given char.\n     ///\n     /// **Why is this bad?** Readability, this can be written more concisely as\n     /// `_.ends_with(_)`.\n@@ -975,8 +1008,12 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// # let name = \"_\";\n-    /// name.chars().last() == Some('_') || name.chars().next_back() == Some('-')\n-    /// # ;\n+    ///\n+    /// // Bad\n+    /// name.chars().last() == Some('_') || name.chars().next_back() == Some('-');\n+    ///\n+    /// // Good\n+    /// name.ends_with('_') || name.ends_with('-');\n     /// ```\n     pub CHARS_LAST_CMP,\n     style,\n@@ -1044,17 +1081,15 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// let _ = (0..3).filter_map(|x| if x > 2 { Some(x) } else { None });\n-    /// ```\n-    /// As there is no transformation of the argument this could be written as:\n-    /// ```rust\n+    ///\n+    /// // As there is no transformation of the argument this could be written as:\n     /// let _ = (0..3).filter(|&x| x > 2);\n     /// ```\n     ///\n     /// ```rust\n     /// let _ = (0..4).filter_map(|x| Some(x + 1));\n-    /// ```\n-    /// As there is no conditional check on the argument this could be written as:\n-    /// ```rust\n+    ///\n+    /// // As there is no conditional check on the argument this could be written as:\n     /// let _ = (0..4).map(|x| x + 1);\n     /// ```\n     pub UNNECESSARY_FILTER_MAP,\n@@ -1075,7 +1110,11 @@ declare_clippy_lint! {\n     /// **Example:**\n     ///\n     /// ```rust\n+    /// // Bad\n     /// let _ = (&vec![3, 4, 5]).into_iter();\n+    ///\n+    /// // Good\n+    /// let _ = (&vec![3, 4, 5]).iter();\n     /// ```\n     pub INTO_ITER_ON_REF,\n     style,\n@@ -1242,6 +1281,32 @@ declare_clippy_lint! {\n     \"using `as_ref().map(Deref::deref)`, which is more succinctly expressed as `as_deref()`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `iter().next()` on a Slice or an Array\n+    ///\n+    /// **Why is this bad?** These can be shortened into `.get()`\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let a = [1, 2, 3];\n+    /// # let b = vec![1, 2, 3];\n+    /// a[2..].iter().next();\n+    /// b.iter().next();\n+    /// ```\n+    /// should be written as:\n+    /// ```rust\n+    /// # let a = [1, 2, 3];\n+    /// # let b = vec![1, 2, 3];\n+    /// a.get(2);\n+    /// b.get(0);\n+    /// ```\n+    pub ITER_NEXT_SLICE,\n+    style,\n+    \"using `.iter().next()` on a sliced array, which can be shortened to just `.get()`\"\n+}\n+\n declare_lint_pass!(Methods => [\n     UNWRAP_USED,\n     EXPECT_USED,\n@@ -1273,6 +1338,7 @@ declare_lint_pass!(Methods => [\n     FIND_MAP,\n     MAP_FLATTEN,\n     ITERATOR_STEP_BY_ZERO,\n+    ITER_NEXT_SLICE,\n     ITER_NTH,\n     ITER_NTH_ZERO,\n     ITER_SKIP_NEXT,\n@@ -1320,6 +1386,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             },\n             [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n             [\"next\", \"skip_while\"] => lint_skip_while_next(cx, expr, arg_lists[1]),\n+            [\"next\", \"iter\"] => lint_iter_next(cx, expr, arg_lists[1]),\n             [\"map\", \"filter\"] => lint_filter_map(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"map\", \"filter_map\"] => lint_filter_map_map(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"next\", \"filter_map\"] => lint_filter_map_next(cx, expr, arg_lists[1]),\n@@ -1336,9 +1403,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                 lint_search_is_some(cx, expr, \"rposition\", arg_lists[1], arg_lists[0], method_spans[1])\n             },\n             [\"extend\", ..] => lint_extend(cx, expr, arg_lists[0]),\n-            [\"as_ptr\", \"unwrap\"] | [\"as_ptr\", \"expect\"] => {\n-                lint_cstring_as_ptr(cx, expr, &arg_lists[1][0], &arg_lists[0][0])\n-            },\n+            [\"as_ptr\", \"unwrap\" | \"expect\"] => lint_cstring_as_ptr(cx, expr, &arg_lists[1][0], &arg_lists[0][0]),\n             [\"nth\", \"iter\"] => lint_iter_nth(cx, expr, &arg_lists, false),\n             [\"nth\", \"iter_mut\"] => lint_iter_nth(cx, expr, &arg_lists, true),\n             [\"nth\", ..] => lint_iter_nth_zero(cx, expr, arg_lists[0]),\n@@ -1351,12 +1416,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             [\"filter_map\", ..] => unnecessary_filter_map::lint(cx, expr, arg_lists[0]),\n             [\"count\", \"map\"] => lint_suspicious_map(cx, expr),\n             [\"assume_init\"] => lint_maybe_uninit(cx, &arg_lists[0][0], expr),\n-            [\"unwrap_or\", arith @ \"checked_add\"]\n-            | [\"unwrap_or\", arith @ \"checked_sub\"]\n-            | [\"unwrap_or\", arith @ \"checked_mul\"] => {\n+            [\"unwrap_or\", arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\")] => {\n                 manual_saturating_arithmetic::lint(cx, expr, &arg_lists, &arith[\"checked_\".len()..])\n             },\n-            [\"add\"] | [\"offset\"] | [\"sub\"] | [\"wrapping_offset\"] | [\"wrapping_add\"] | [\"wrapping_sub\"] => {\n+            [\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\"] => {\n                 check_pointer_offset(cx, expr, arg_lists[0])\n             },\n             [\"is_file\", ..] => lint_filetype_is_file(cx, expr, arg_lists[0]),\n@@ -1481,7 +1544,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n \n             let contains_self_ty = |ty: Ty<'tcx>| {\n                 ty.walk().any(|inner| match inner.unpack() {\n-                    GenericArgKind::Type(inner_ty) => same_tys(cx, self_ty, inner_ty),\n+                    GenericArgKind::Type(inner_ty) => TyS::same_type(self_ty, inner_ty),\n \n                     GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n                 })\n@@ -1508,7 +1571,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                 }\n             }\n \n-            if name == \"new\" && !same_tys(cx, ret_ty, self_ty) {\n+            if name == \"new\" && !TyS::same_type(ret_ty, self_ty) {\n                 span_lint(\n                     cx,\n                     NEW_RET_NO_SELF,\n@@ -1762,8 +1825,7 @@ fn lint_expect_fun_call(\n             hir::ExprKind::Call(fun, _) => {\n                 if let hir::ExprKind::Path(ref p) = fun.kind {\n                     match cx.tables.qpath_res(p, fun.hir_id) {\n-                        hir::def::Res::Def(hir::def::DefKind::Fn, def_id)\n-                        | hir::def::Res::Def(hir::def::DefKind::AssocFn, def_id) => matches!(\n+                        hir::def::Res::Def(hir::def::DefKind::Fn | hir::def::DefKind::AssocFn, def_id) => matches!(\n                             cx.tcx.fn_sig(def_id).output().skip_binder().kind,\n                             ty::Ref(ty::ReStatic, ..)\n                         ),\n@@ -2199,6 +2261,60 @@ fn lint_step_by<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr<'_>, args\n     }\n }\n \n+fn lint_iter_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>, iter_args: &'tcx [hir::Expr<'_>]) {\n+    let caller_expr = &iter_args[0];\n+\n+    // Skip lint if the `iter().next()` expression is a for loop argument,\n+    // since it is already covered by `&loops::ITER_NEXT_LOOP`\n+    let mut parent_expr_opt = get_parent_expr(cx, expr);\n+    while let Some(parent_expr) = parent_expr_opt {\n+        if higher::for_loop(parent_expr).is_some() {\n+            return;\n+        }\n+        parent_expr_opt = get_parent_expr(cx, parent_expr);\n+    }\n+\n+    if derefs_to_slice(cx, caller_expr, cx.tables.expr_ty(caller_expr)).is_some() {\n+        // caller is a Slice\n+        if_chain! {\n+            if let hir::ExprKind::Index(ref caller_var, ref index_expr) = &caller_expr.kind;\n+            if let Some(higher::Range { start: Some(start_expr), end: None, limits: ast::RangeLimits::HalfOpen })\n+                = higher::range(cx, index_expr);\n+            if let hir::ExprKind::Lit(ref start_lit) = &start_expr.kind;\n+            if let ast::LitKind::Int(start_idx, _) = start_lit.node;\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                span_lint_and_sugg(\n+                    cx,\n+                    ITER_NEXT_SLICE,\n+                    expr.span,\n+                    \"Using `.iter().next()` on a Slice without end index.\",\n+                    \"try calling\",\n+                    format!(\"{}.get({})\", snippet_with_applicability(cx, caller_var.span, \"..\", &mut applicability), start_idx),\n+                    applicability,\n+                );\n+            }\n+        }\n+    } else if is_type_diagnostic_item(cx, cx.tables.expr_ty(caller_expr), sym!(vec_type))\n+        || matches!(&walk_ptrs_ty(cx.tables.expr_ty(caller_expr)).kind, ty::Array(_, _))\n+    {\n+        // caller is a Vec or an Array\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            ITER_NEXT_SLICE,\n+            expr.span,\n+            \"Using `.iter().next()` on an array\",\n+            \"try calling\",\n+            format!(\n+                \"{}.get(0)\",\n+                snippet_with_applicability(cx, caller_expr.span, \"..\", &mut applicability)\n+            ),\n+            applicability,\n+        );\n+    }\n+}\n+\n fn lint_iter_nth<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     expr: &hir::Expr<'_>,"}, {"sha": "f513161bbbc5209630050c5cf82f6b09764c645f", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -38,10 +38,16 @@ declare_clippy_lint! {\n     /// dereferences, e.g., changing `*x` to `x` within the function.\n     ///\n     /// **Example:**\n-    /// ```rust\n+    /// ```rust,ignore\n+    /// // Bad\n     /// fn foo(ref x: u8) -> bool {\n     ///     true\n     /// }\n+    ///\n+    /// // Good\n+    /// fn foo(x: &u8) -> bool {\n+    ///     true\n+    /// }\n     /// ```\n     pub TOPLEVEL_REF_ARG,\n     style,\n@@ -60,7 +66,11 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # let x = 1.0;\n     ///\n+    /// // Bad\n     /// if x == f32::NAN { }\n+    ///\n+    /// // Good\n+    /// if x.is_nan() { }\n     /// ```\n     pub CMP_NAN,\n     correctness,\n@@ -83,8 +93,15 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let x = 1.2331f64;\n     /// let y = 1.2332f64;\n+    ///\n+    /// // Bad\n     /// if y == 1.23f64 { }\n     /// if y != x {} // where both are floats\n+    ///\n+    /// // Good\n+    /// let error = 0.01f64; // Use an epsilon for comparison\n+    /// if (y - 1.23f64).abs() < error { }\n+    /// if (y - x).abs() > error { }\n     /// ```\n     pub FLOAT_CMP,\n     correctness,\n@@ -191,7 +208,11 @@ declare_clippy_lint! {\n     /// **Example:**\n     ///\n     /// ```rust\n+    /// // Bad\n     /// let a = 0 as *const u32;\n+    ///\n+    /// // Good\n+    /// let a = std::ptr::null::<u32>();\n     /// ```\n     pub ZERO_PTR,\n     style,\n@@ -214,7 +235,13 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let x: f64 = 1.0;\n     /// const ONE: f64 = 1.00;\n-    /// x == ONE;  // where both are floats\n+    ///\n+    /// // Bad\n+    /// if x == ONE { }  // where both are floats\n+    ///\n+    /// // Good\n+    /// let error = 0.1f64; // Use an epsilon for comparison\n+    /// if (x - ONE).abs() < error { }\n     /// ```\n     pub FLOAT_CMP_CONST,\n     restriction,\n@@ -248,17 +275,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n             return;\n         }\n         for arg in iter_input_pats(decl, body) {\n-            match arg.pat.kind {\n-                PatKind::Binding(BindingAnnotation::Ref, ..) | PatKind::Binding(BindingAnnotation::RefMut, ..) => {\n-                    span_lint(\n-                        cx,\n-                        TOPLEVEL_REF_ARG,\n-                        arg.pat.span,\n-                        \"`ref` directly on a function argument is ignored. Consider using a reference type \\\n-                         instead.\",\n-                    );\n-                },\n-                _ => {},\n+            if let PatKind::Binding(BindingAnnotation::Ref | BindingAnnotation::RefMut, ..) = arg.pat.kind {\n+                span_lint(\n+                    cx,\n+                    TOPLEVEL_REF_ARG,\n+                    arg.pat.span,\n+                    \"`ref` directly on a function argument is ignored. \\\n+                    Consider using a reference type instead.\",\n+                );\n             }\n         }\n     }"}, {"sha": "ad39e59d0678a29bdac0ae5420e3443869865d33", "filename": "src/tools/clippy/clippy_lints/src/misc_early.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -59,7 +59,11 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust\n+    /// // Bad\n     /// fn foo(a: i32, _a: i32) {}\n+    ///\n+    /// // Good\n+    /// fn bar(a: i32, _b: i32) {}\n     /// ```\n     pub DUPLICATE_UNDERSCORE_ARGUMENT,\n     style,\n@@ -77,7 +81,11 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust,ignore\n-    /// (|| 42)()\n+    /// // Bad\n+    /// let a = (|| 42)()\n+    ///\n+    /// // Good\n+    /// let a = 42\n     /// ```\n     pub REDUNDANT_CLOSURE_CALL,\n     complexity,\n@@ -112,7 +120,11 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust\n+    /// // Bad\n     /// let y = 0x1a9BAcD;\n+    ///\n+    /// // Good\n+    /// let y = 0x1A9BACD;\n     /// ```\n     pub MIXED_CASE_HEX_LITERALS,\n     style,\n@@ -129,7 +141,11 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust\n+    /// // Bad\n     /// let y = 123832i32;\n+    ///\n+    /// // Good\n+    /// let y = 123832_i32;\n     /// ```\n     pub UNSEPARATED_LITERAL_SUFFIX,\n     pedantic,\n@@ -207,9 +223,16 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # let v = Some(\"abc\");\n     ///\n+    /// // Bad\n+    /// match v {\n+    ///     Some(x) => (),\n+    ///     y @ _ => (),\n+    /// }\n+    ///\n+    /// // Good\n     /// match v {\n     ///     Some(x) => (),\n-    ///     y @ _ => (), // easier written as `y`,\n+    ///     y => (),\n     /// }\n     /// ```\n     pub REDUNDANT_PATTERN,\n@@ -235,16 +258,13 @@ declare_clippy_lint! {\n     /// # struct TupleStruct(u32, u32, u32);\n     /// # let t = TupleStruct(1, 2, 3);\n     ///\n+    /// // Bad\n     /// match t {\n     ///     TupleStruct(0, .., _) => (),\n     ///     _ => (),\n     /// }\n-    /// ```\n-    /// can be written as\n-    /// ```rust\n-    /// # struct TupleStruct(u32, u32, u32);\n-    /// # let t = TupleStruct(1, 2, 3);\n     ///\n+    /// // Good\n     /// match t {\n     ///     TupleStruct(0, ..) => (),\n     ///     _ => (),"}, {"sha": "6c42014b4c8a198ef3c61ea5e1bd2e279862014a", "filename": "src/tools/clippy/clippy_lints/src/multiple_crate_versions.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmultiple_crate_versions.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -7,7 +7,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::DUMMY_SP;\n \n-use cargo_metadata::{DependencyKind, MetadataCommand, Node, Package, PackageId};\n+use cargo_metadata::{DependencyKind, Node, Package, PackageId};\n use if_chain::if_chain;\n use itertools::Itertools;\n \n@@ -42,13 +42,7 @@ impl LateLintPass<'_, '_> for MultipleCrateVersions {\n             return;\n         }\n \n-        let metadata = if let Ok(metadata) = MetadataCommand::new().exec() {\n-            metadata\n-        } else {\n-            span_lint(cx, MULTIPLE_CRATE_VERSIONS, DUMMY_SP, \"could not read cargo metadata\");\n-            return;\n-        };\n-\n+        let metadata = unwrap_cargo_metadata!(cx, MULTIPLE_CRATE_VERSIONS, true);\n         let local_name = cx.tcx.crate_name(LOCAL_CRATE).as_str();\n         let mut packages = metadata.packages;\n         packages.sort_by(|a, b| a.name.cmp(&b.name));"}, {"sha": "58a8e1a1064ae7603f46bce495a4a76c70afaff7", "filename": "src/tools/clippy/clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -16,7 +16,11 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```ignore\n+    /// // Bad\n     /// my_vec.push(&mut value)\n+    ///\n+    /// // Good\n+    /// my_vec.push(&value)\n     /// ```\n     pub UNNECESSARY_MUT_PASSED,\n     style,"}, {"sha": "78b15afc5a7fac4105fc5be6e699838bd43f5342", "filename": "src/tools/clippy/clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -22,9 +22,15 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust\n+    /// # let y = true;\n+    ///\n+    /// // Bad\n     /// # use std::sync::Mutex;\n-    /// # let y = 1;\n     /// let x = Mutex::new(&y);\n+    ///\n+    /// // Good\n+    /// # use std::sync::atomic::AtomicBool;\n+    /// let x = AtomicBool::new(y);\n     /// ```\n     pub MUTEX_ATOMIC,\n     perf,\n@@ -46,6 +52,10 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # use std::sync::Mutex;\n     /// let x = Mutex::new(0usize);\n+    ///\n+    /// // Good\n+    /// # use std::sync::atomic::AtomicUsize;\n+    /// let x = AtomicUsize::new(0usize);\n     /// ```\n     pub MUTEX_INTEGER,\n     nursery,"}, {"sha": "15b129fa09802922543c184d3e47d7905dc622c2", "filename": "src/tools/clippy/clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_bool.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -15,8 +15,7 @@ use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for expressions of the form `if c { true } else {\n-    /// false }`\n-    /// (or vice versa) and suggest using the condition directly.\n+    /// false }` (or vice versa) and suggests using the condition directly.\n     ///\n     /// **Why is this bad?** Redundant code.\n     ///"}, {"sha": "5880d1d610206365b77e0be95f1e88af9d7d9d56", "filename": "src/tools/clippy/clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -18,12 +18,16 @@ declare_clippy_lint! {\n     /// **Why is this bad?** Suggests that the receiver of the expression borrows\n     /// the expression.\n     ///\n+    /// **Known problems:** None.\n+    ///\n     /// **Example:**\n     /// ```rust\n+    /// // Bad\n     /// let x: &i32 = &&&&&&5;\n-    /// ```\n     ///\n-    /// **Known problems:** None.\n+    /// // Good\n+    /// let x: &i32 = &5;\n+    /// ```\n     pub NEEDLESS_BORROW,\n     nursery,\n     \"taking a reference that is going to be automatically dereferenced\""}, {"sha": "a971d041ca6613182a5166e70d2b3a31f1792854", "filename": "src/tools/clippy/clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_continue.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -424,7 +424,7 @@ fn erode_from_back(s: &str) -> String {\n }\n \n fn span_of_first_expr_in_block(block: &ast::Block) -> Option<Span> {\n-    block.stmts.iter().next().map(|stmt| stmt.span)\n+    block.stmts.get(0).map(|stmt| stmt.span)\n }\n \n #[cfg(test)]"}, {"sha": "d866bab2f642c46242b92bed638c577612aa062a", "filename": "src/tools/clippy/clippy_lints/src/needless_update.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -21,6 +21,16 @@ declare_clippy_lint! {\n     /// #     z: i32,\n     /// # }\n     /// # let zero_point = Point { x: 0, y: 0, z: 0 };\n+    ///\n+    /// // Bad\n+    /// Point {\n+    ///     x: 1,\n+    ///     y: 1,\n+    ///     z: 1,\n+    ///     ..zero_point\n+    /// };\n+    ///\n+    /// // Ok\n     /// Point {\n     ///     x: 1,\n     ///     y: 1,"}, {"sha": "dd236535c18ad9d6aed4c0fc5105d1b12f598a78", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,13 +1,13 @@\n use crate::utils::paths;\n use crate::utils::sugg::DiagnosticBuilderExt;\n-use crate::utils::{get_trait_def_id, return_ty, same_tys, span_lint_hir_and_then};\n+use crate::utils::{get_trait_def_id, return_ty, span_lint_hir_and_then};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::HirIdSet;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{Ty, TyS};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n declare_clippy_lint! {\n@@ -93,7 +93,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                             let self_def_id = cx.tcx.hir().local_def_id(cx.tcx.hir().get_parent_item(id));\n                             let self_ty = cx.tcx.type_of(self_def_id);\n                             if_chain! {\n-                                if same_tys(cx, self_ty, return_ty(cx, id));\n+                                if TyS::same_type(self_ty, return_ty(cx, id));\n                                 if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n                                 then {\n                                     if self.impling_types.is_none() {"}, {"sha": "2eacd3c80c486ba8d5ba6f436d1ef018f1ec3af4", "filename": "src/tools/clippy/clippy_lints/src/no_effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -147,7 +147,7 @@ fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'a>) -> Option\n             if let ExprKind::Path(ref qpath) = callee.kind {\n                 let res = qpath_res(cx, qpath, callee.hir_id);\n                 match res {\n-                    Res::Def(DefKind::Struct, ..) | Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(..), _)\n+                    Res::Def(DefKind::Struct | DefKind::Variant | DefKind::Ctor(..), ..)\n                         if !has_drop(cx, cx.tables.expr_ty(expr)) =>\n                     {\n                         Some(args.iter().collect())"}, {"sha": "c77b44e0c99c710381a39bebcfe9b6e88d6557df", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -47,7 +47,11 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```ignore\n+    /// // Bad\n     /// fn foo(&Vec<u32>) { .. }\n+    ///\n+    /// // Good\n+    /// fn foo(&[u32]) { .. }\n     /// ```\n     pub PTR_ARG,\n     style,\n@@ -65,9 +69,15 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```ignore\n+    /// // Bad\n     /// if x == ptr::null {\n     ///     ..\n     /// }\n+    ///\n+    /// // Good\n+    /// if x.is_null() {\n+    ///     ..\n+    /// }\n     /// ```\n     pub CMP_NULL,\n     style,\n@@ -76,19 +86,16 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// **What it does:** This lint checks for functions that take immutable\n-    /// references and return\n-    /// mutable ones.\n+    /// references and return mutable ones.\n     ///\n     /// **Why is this bad?** This is trivially unsound, as one can create two\n-    /// mutable references\n-    /// from the same (immutable!) source. This\n-    /// [error](https://github.com/rust-lang/rust/issues/39465)\n+    /// mutable references from the same (immutable!) source.\n+    /// This [error](https://github.com/rust-lang/rust/issues/39465)\n     /// actually lead to an interim Rust release 1.15.1.\n     ///\n     /// **Known problems:** To be on the conservative side, if there's at least one\n-    /// mutable reference\n-    /// with the output lifetime, this lint will not trigger. In practice, this\n-    /// case is unlikely anyway.\n+    /// mutable reference with the output lifetime, this lint will not trigger.\n+    /// In practice, this case is unlikely anyway.\n     ///\n     /// **Example:**\n     /// ```ignore"}, {"sha": "e4361b00fb4c2df025c79612ca2baf87a4888c66", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -88,7 +88,7 @@ impl QuestionMark {\n                         replacement_str,\n                         applicability,\n                     )\n-               }\n+                }\n             }\n         }\n     }"}, {"sha": "52e540d4e00dbeca87b1c5110de9537565650c86", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -241,14 +241,26 @@ fn check_inclusive_range_minus_one(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n }\n \n fn check_reversed_empty_range(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n-    fn inside_indexing_expr<'a>(cx: &'a LateContext<'_, '_>, expr: &Expr<'_>) -> Option<&'a Expr<'a>> {\n-        match get_parent_expr(cx, expr) {\n-            parent_expr @ Some(Expr {\n+    fn inside_indexing_expr(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+        matches!(\n+            get_parent_expr(cx, expr),\n+            Some(Expr {\n                 kind: ExprKind::Index(..),\n                 ..\n-            }) => parent_expr,\n-            _ => None,\n+            })\n+        )\n+    }\n+\n+    fn is_for_loop_arg(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n+        let mut cur_expr = expr;\n+        while let Some(parent_expr) = get_parent_expr(cx, cur_expr) {\n+            match higher::for_loop(parent_expr) {\n+                Some((_, args, _)) if args.hir_id == expr.hir_id => return true,\n+                _ => cur_expr = parent_expr,\n+            }\n         }\n+\n+        false\n     }\n \n     fn is_empty_range(limits: RangeLimits, ordering: Ordering) -> bool {\n@@ -267,34 +279,18 @@ fn check_reversed_empty_range(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         if let Some(ordering) = Constant::partial_cmp(cx.tcx, ty, &start_idx, &end_idx);\n         if is_empty_range(limits, ordering);\n         then {\n-            if let Some(parent_expr) = inside_indexing_expr(cx, expr) {\n-                let (reason, outcome) = if ordering == Ordering::Equal {\n-                    (\"empty\", \"always yield an empty slice\")\n-                } else {\n-                    (\"reversed\", \"panic at run-time\")\n-                };\n-\n-                span_lint_and_then(\n-                    cx,\n-                    REVERSED_EMPTY_RANGES,\n-                    expr.span,\n-                    &format!(\"this range is {} and using it to index a slice will {}\", reason, outcome),\n-                    |diag| {\n-                        if_chain! {\n-                            if ordering == Ordering::Equal;\n-                            if let ty::Slice(slice_ty) = cx.tables.expr_ty(parent_expr).kind;\n-                            then {\n-                                diag.span_suggestion(\n-                                    parent_expr.span,\n-                                    \"if you want an empty slice, use\",\n-                                    format!(\"[] as &[{}]\", slice_ty),\n-                                    Applicability::MaybeIncorrect\n-                                );\n-                            }\n-                        }\n-                    }\n-                );\n-            } else {\n+            if inside_indexing_expr(cx, expr) {\n+                // Avoid linting `N..N` as it has proven to be useful, see #5689 and #5628 ...\n+                if ordering != Ordering::Equal {\n+                    span_lint(\n+                        cx,\n+                        REVERSED_EMPTY_RANGES,\n+                        expr.span,\n+                        \"this range is reversed and using it to index a slice will panic at run-time\",\n+                    );\n+                }\n+            // ... except in for loop arguments for backwards compatibility with `reverse_range_loop`\n+            } else if ordering != Ordering::Equal || is_for_loop_arg(cx, expr) {\n                 span_lint_and_then(\n                     cx,\n                     REVERSED_EMPTY_RANGES,"}, {"sha": "fe457aad50e368adb6605b7fbcfc912bfcb1cd17", "filename": "src/tools/clippy/clippy_lints/src/reference.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freference.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -16,8 +16,13 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust,ignore\n+    /// // Bad\n     /// let a = f(*&mut b);\n     /// let c = *&d;\n+    ///\n+    /// // Good\n+    /// let a = f(b);\n+    /// let c = d;\n     /// ```\n     pub DEREF_ADDROF,\n     complexity,"}, {"sha": "a2c35c4267344a95eef43abf696e465d4d7d2b22", "filename": "src/tools/clippy/clippy_lints/src/regex.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -86,11 +86,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Regex {\n             if let Some(span) = is_expn_of(expr.span, \"regex\");\n             then {\n                 if !self.spans.contains(&span) {\n-                    span_lint(cx,\n-                              REGEX_MACRO,\n-                              span,\n-                              \"`regex!(_)` found. \\\n-                              Please use `Regex::new(_)`, which is faster for now.\");\n+                    span_lint(\n+                        cx,\n+                        REGEX_MACRO,\n+                        span,\n+                        \"`regex!(_)` found. \\\n+                        Please use `Regex::new(_)`, which is faster for now.\"\n+                    );\n                     self.spans.insert(span);\n                 }\n                 self.last = Some(block.hir_id);"}, {"sha": "3c939744173562515d8419edffabca457ec08e11", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 3, "deletions": 79, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -8,7 +8,7 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::BytePos;\n \n-use crate::utils::{in_macro, match_path_ast, snippet_opt, span_lint_and_sugg, span_lint_and_then};\n+use crate::utils::{snippet_opt, span_lint_and_sugg, span_lint_and_then};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for return statements at the end of a block.\n@@ -36,33 +36,6 @@ declare_clippy_lint! {\n     \"using a return statement like `return expr;` where an expression would suffice\"\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for `let`-bindings, which are subsequently\n-    /// returned.\n-    ///\n-    /// **Why is this bad?** It is just extraneous code. Remove it to make your code\n-    /// more rusty.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// fn foo() -> String {\n-    ///     let x = String::new();\n-    ///     x\n-    /// }\n-    /// ```\n-    /// instead, use\n-    /// ```\n-    /// fn foo() -> String {\n-    ///     String::new()\n-    /// }\n-    /// ```\n-    pub LET_AND_RETURN,\n-    style,\n-    \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\"\n-}\n-\n declare_clippy_lint! {\n     /// **What it does:** Checks for unit (`()`) expressions that can be removed.\n     ///\n@@ -90,7 +63,7 @@ enum RetReplacement {\n     Block,\n }\n \n-declare_lint_pass!(Return => [NEEDLESS_RETURN, LET_AND_RETURN, UNUSED_UNIT]);\n+declare_lint_pass!(Return => [NEEDLESS_RETURN, UNUSED_UNIT]);\n \n impl Return {\n     // Check the final stmt or expr in a block for unnecessary return.\n@@ -105,7 +78,7 @@ impl Return {\n         }\n     }\n \n-    // Check a the final expression in a block if it's a return.\n+    // Check the final expression in a block if it's a return.\n     fn check_final_expr(\n         &mut self,\n         cx: &EarlyContext<'_>,\n@@ -186,54 +159,6 @@ impl Return {\n             },\n         }\n     }\n-\n-    // Check for \"let x = EXPR; x\"\n-    fn check_let_return(cx: &EarlyContext<'_>, block: &ast::Block) {\n-        let mut it = block.stmts.iter();\n-\n-        // we need both a let-binding stmt and an expr\n-        if_chain! {\n-            if let Some(retexpr) = it.next_back();\n-            if let ast::StmtKind::Expr(ref retexpr) = retexpr.kind;\n-            if let Some(stmt) = it.next_back();\n-            if let ast::StmtKind::Local(ref local) = stmt.kind;\n-            // don't lint in the presence of type inference\n-            if local.ty.is_none();\n-            if local.attrs.is_empty();\n-            if let Some(ref initexpr) = local.init;\n-            if let ast::PatKind::Ident(_, ident, _) = local.pat.kind;\n-            if let ast::ExprKind::Path(_, ref path) = retexpr.kind;\n-            if match_path_ast(path, &[&*ident.name.as_str()]);\n-            if !in_external_macro(cx.sess(), initexpr.span);\n-            if !in_external_macro(cx.sess(), retexpr.span);\n-            if !in_external_macro(cx.sess(), local.span);\n-            if !in_macro(local.span);\n-            then {\n-                span_lint_and_then(\n-                    cx,\n-                    LET_AND_RETURN,\n-                    retexpr.span,\n-                    \"returning the result of a `let` binding from a block\",\n-                    |err| {\n-                        err.span_label(local.span, \"unnecessary `let` binding\");\n-\n-                        if let Some(snippet) = snippet_opt(cx, initexpr.span) {\n-                            err.multipart_suggestion(\n-                                \"return the expression directly\",\n-                                vec![\n-                                    (local.span, String::new()),\n-                                    (retexpr.span, snippet),\n-                                ],\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            err.span_help(initexpr.span, \"this expression can be directly returned\");\n-                        }\n-                    },\n-                );\n-            }\n-        }\n-    }\n }\n \n impl EarlyLintPass for Return {\n@@ -254,7 +179,6 @@ impl EarlyLintPass for Return {\n     }\n \n     fn check_block(&mut self, cx: &EarlyContext<'_>, block: &ast::Block) {\n-        Self::check_let_return(cx, block);\n         if_chain! {\n             if let Some(ref stmt) = block.stmts.last();\n             if let ast::StmtKind::Expr(ref expr) = stmt.kind;"}, {"sha": "68c36f918918438a79f80bf4b3ff7a9a34b50ef7", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -25,7 +25,12 @@ declare_clippy_lint! {\n     /// **Example:**\n     /// ```rust\n     /// # let x = 1;\n+    ///\n+    /// // Bad\n     /// let x = &x;\n+    ///\n+    /// // Good\n+    /// let y = &x; // use different variable name\n     /// ```\n     pub SHADOW_SAME,\n     restriction,\n@@ -77,7 +82,12 @@ declare_clippy_lint! {\n     /// # let y = 1;\n     /// # let z = 2;\n     /// let x = y;\n+    ///\n+    /// // Bad\n     /// let x = z; // shadows the earlier binding\n+    ///\n+    /// // Good\n+    /// let w = z; // use different variable name\n     /// ```\n     pub SHADOW_UNRELATED,\n     pedantic,"}, {"sha": "2e853e8301d6999ac2ef1313787ab1129e338bfd", "filename": "src/tools/clippy/clippy_lints/src/single_component_path_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -16,15 +16,15 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     ///\n-    /// ```rust, ignore\n+    /// ```rust,ignore\n     /// use regex;\n     ///\n     /// fn main() {\n     ///     regex::Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}$\").unwrap();\n     /// }\n     /// ```\n     /// Better as\n-    /// ```rust, ignore\n+    /// ```rust,ignore\n     /// fn main() {\n     ///     regex::Regex::new(r\"^\\d{4}-\\d{2}-\\d{2}$\").unwrap();\n     /// }"}, {"sha": "a7c4f2c2291f12f0ef1582cbba569d9d4cd6a55c", "filename": "src/tools/clippy/clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -22,11 +22,17 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # use core::iter::repeat;\n     /// # let len = 4;\n+    ///\n+    /// // Bad\n     /// let mut vec1 = Vec::with_capacity(len);\n     /// vec1.resize(len, 0);\n     ///\n     /// let mut vec2 = Vec::with_capacity(len);\n-    /// vec2.extend(repeat(0).take(len))\n+    /// vec2.extend(repeat(0).take(len));\n+    ///\n+    /// // Good\n+    /// let mut vec1 = vec![0; len];\n+    /// let mut vec2 = vec![0; len];\n     /// ```\n     pub SLOW_VECTOR_INITIALIZATION,\n     perf,"}, {"sha": "f84566ef707a8e41dbc8a2b00275d7d55c07aeb6", "filename": "src/tools/clippy/clippy_lints/src/strings.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrings.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -24,6 +24,10 @@ declare_clippy_lint! {\n     /// ```rust\n     /// let mut x = \"Hello\".to_owned();\n     /// x = x + \", World\";\n+    ///\n+    /// // More readable\n+    /// x += \", World\";\n+    /// x.push_str(\", World\");\n     /// ```\n     pub STRING_ADD_ASSIGN,\n     pedantic,\n@@ -69,7 +73,11 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust\n+    /// // Bad\n     /// let bs = \"a byte string\".as_bytes();\n+    ///\n+    /// // Good\n+    /// let bs = b\"a byte string\";\n     /// ```\n     pub STRING_LIT_AS_BYTES,\n     style,"}, {"sha": "a9e6fa329c0f03ab2681222320afcce1f6fcfbb9", "filename": "src/tools/clippy/clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -71,8 +71,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n                 if let hir::Node::Expr(e) = cx.tcx.hir().get(parent_expr) {\n                     match e.kind {\n                         hir::ExprKind::Binary(..)\n-                        | hir::ExprKind::Unary(hir::UnOp::UnNot, _)\n-                        | hir::ExprKind::Unary(hir::UnOp::UnNeg, _)\n+                        | hir::ExprKind::Unary(hir::UnOp::UnNot | hir::UnOp::UnNeg, _)\n                         | hir::ExprKind::AssignOp(..) => return,\n                         _ => {},\n                     }\n@@ -191,8 +190,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BinaryExprVisitor {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n         match expr.kind {\n             hir::ExprKind::Binary(..)\n-            | hir::ExprKind::Unary(hir::UnOp::UnNot, _)\n-            | hir::ExprKind::Unary(hir::UnOp::UnNeg, _)\n+            | hir::ExprKind::Unary(hir::UnOp::UnNot | hir::UnOp::UnNeg, _)\n             | hir::ExprKind::AssignOp(..) => self.in_binary_expr = true,\n             _ => {},\n         }"}, {"sha": "1869638f6ffb11b5b196eae87d659a4a996acdd3", "filename": "src/tools/clippy/clippy_lints/src/transmute.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                         e.span,\n                         &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n                     ),\n-                    (&ty::Ref(_, rty, rty_mutbl), &ty::RawPtr(ptr_ty)) => span_lint_and_then(\n+                    (ty::Ref(_, rty, rty_mutbl), ty::RawPtr(ptr_ty)) => span_lint_and_then(\n                         cx,\n                         USELESS_TRANSMUTE,\n                         e.span,\n@@ -321,10 +321,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                             if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n                                 let rty_and_mut = ty::TypeAndMut {\n                                     ty: rty,\n-                                    mutbl: rty_mutbl,\n+                                    mutbl: *rty_mutbl,\n                                 };\n \n-                                let sugg = if ptr_ty == rty_and_mut {\n+                                let sugg = if *ptr_ty == rty_and_mut {\n                                     arg.as_ty(to_ty)\n                                 } else {\n                                     arg.as_ty(cx.tcx.mk_ptr(rty_and_mut)).as_ty(to_ty)\n@@ -334,7 +334,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                             }\n                         },\n                     ),\n-                    (&ty::Int(_), &ty::RawPtr(_)) | (&ty::Uint(_), &ty::RawPtr(_)) => span_lint_and_then(\n+                    (ty::Int(_) | ty::Uint(_), ty::RawPtr(_)) => span_lint_and_then(\n                         cx,\n                         USELESS_TRANSMUTE,\n                         e.span,\n@@ -350,16 +350,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                             }\n                         },\n                     ),\n-                    (&ty::Float(_), &ty::Ref(..))\n-                    | (&ty::Float(_), &ty::RawPtr(_))\n-                    | (&ty::Char, &ty::Ref(..))\n-                    | (&ty::Char, &ty::RawPtr(_)) => span_lint(\n+                    (ty::Float(_) | ty::Char, ty::Ref(..) | ty::RawPtr(_)) => span_lint(\n                         cx,\n                         WRONG_TRANSMUTE,\n                         e.span,\n                         &format!(\"transmute from a `{}` to a pointer\", from_ty),\n                     ),\n-                    (&ty::RawPtr(from_ptr), _) if from_ptr.ty == to_ty => span_lint(\n+                    (ty::RawPtr(from_ptr), _) if from_ptr.ty == to_ty => span_lint(\n                         cx,\n                         CROSSPOINTER_TRANSMUTE,\n                         e.span,\n@@ -368,7 +365,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                             from_ty, to_ty\n                         ),\n                     ),\n-                    (_, &ty::RawPtr(to_ptr)) if to_ptr.ty == from_ty => span_lint(\n+                    (_, ty::RawPtr(to_ptr)) if to_ptr.ty == from_ty => span_lint(\n                         cx,\n                         CROSSPOINTER_TRANSMUTE,\n                         e.span,\n@@ -377,7 +374,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                             from_ty, to_ty\n                         ),\n                     ),\n-                    (&ty::RawPtr(from_pty), &ty::Ref(_, to_ref_ty, mutbl)) => span_lint_and_then(\n+                    (ty::RawPtr(from_pty), ty::Ref(_, to_ref_ty, mutbl)) => span_lint_and_then(\n                         cx,\n                         TRANSMUTE_PTR_TO_REF,\n                         e.span,\n@@ -388,13 +385,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                         ),\n                         |diag| {\n                             let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                            let (deref, cast) = if mutbl == Mutability::Mut {\n+                            let (deref, cast) = if *mutbl == Mutability::Mut {\n                                 (\"&mut *\", \"*mut\")\n                             } else {\n                                 (\"&*\", \"*const\")\n                             };\n \n-                            let arg = if from_pty.ty == to_ref_ty {\n+                            let arg = if from_pty.ty == *to_ref_ty {\n                                 arg\n                             } else {\n                                 arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_ref_ty)))\n@@ -408,7 +405,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                             );\n                         },\n                     ),\n-                    (&ty::Int(ast::IntTy::I32), &ty::Char) | (&ty::Uint(ast::UintTy::U32), &ty::Char) => {\n+                    (ty::Int(ast::IntTy::I32) | ty::Uint(ast::UintTy::U32), &ty::Char) => {\n                         span_lint_and_then(\n                             cx,\n                             TRANSMUTE_INT_TO_CHAR,\n@@ -430,13 +427,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                             },\n                         )\n                     },\n-                    (&ty::Ref(_, ty_from, from_mutbl), &ty::Ref(_, ty_to, to_mutbl)) => {\n+                    (ty::Ref(_, ty_from, from_mutbl), ty::Ref(_, ty_to, to_mutbl)) => {\n                         if_chain! {\n                             if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.kind, &ty_to.kind);\n                             if let ty::Uint(ast::UintTy::U8) = slice_ty.kind;\n                             if from_mutbl == to_mutbl;\n                             then {\n-                                let postfix = if from_mutbl == Mutability::Mut {\n+                                let postfix = if *from_mutbl == Mutability::Mut {\n                                     \"_mut\"\n                                 } else {\n                                     \"\"\n@@ -465,13 +462,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                         |diag| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n                                             let ty_from_and_mut = ty::TypeAndMut {\n                                                 ty: ty_from,\n-                                                mutbl: from_mutbl\n+                                                mutbl: *from_mutbl\n                                             };\n-                                            let ty_to_and_mut = ty::TypeAndMut { ty: ty_to, mutbl: to_mutbl };\n+                                            let ty_to_and_mut = ty::TypeAndMut { ty: ty_to, mutbl: *to_mutbl };\n                                             let sugg_paren = arg\n                                                 .as_ty(cx.tcx.mk_ptr(ty_from_and_mut))\n                                                 .as_ty(cx.tcx.mk_ptr(ty_to_and_mut));\n-                                            let sugg = if to_mutbl == Mutability::Mut {\n+                                            let sugg = if *to_mutbl == Mutability::Mut {\n                                                 sugg_paren.mut_addr_deref()\n                                             } else {\n                                                 sugg_paren.addr_deref()\n@@ -488,19 +485,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                             }\n                         }\n                     },\n-                    (&ty::RawPtr(_), &ty::RawPtr(to_ty)) => span_lint_and_then(\n+                    (ty::RawPtr(_), ty::RawPtr(to_ty)) => span_lint_and_then(\n                         cx,\n                         TRANSMUTE_PTR_TO_PTR,\n                         e.span,\n                         \"transmute from a pointer to a pointer\",\n                         |diag| {\n                             if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                let sugg = arg.as_ty(cx.tcx.mk_ptr(to_ty));\n+                                let sugg = arg.as_ty(cx.tcx.mk_ptr(*to_ty));\n                                 diag.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n                             }\n                         },\n                     ),\n-                    (&ty::Int(ast::IntTy::I8), &ty::Bool) | (&ty::Uint(ast::UintTy::U8), &ty::Bool) => {\n+                    (ty::Int(ast::IntTy::I8) | ty::Uint(ast::UintTy::U8), ty::Bool) => {\n                         span_lint_and_then(\n                             cx,\n                             TRANSMUTE_INT_TO_BOOL,\n@@ -518,7 +515,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                             },\n                         )\n                     },\n-                    (&ty::Int(_), &ty::Float(_)) | (&ty::Uint(_), &ty::Float(_)) => span_lint_and_then(\n+                    (ty::Int(_) | ty::Uint(_), ty::Float(_)) => span_lint_and_then(\n                         cx,\n                         TRANSMUTE_INT_TO_FLOAT,\n                         e.span,\n@@ -541,7 +538,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                             );\n                         },\n                     ),\n-                    (&ty::Float(float_ty), &ty::Int(_)) | (&ty::Float(float_ty), &ty::Uint(_)) => span_lint_and_then(\n+                    (ty::Float(float_ty), ty::Int(_) | ty::Uint(_)) => span_lint_and_then(\n                         cx,\n                         TRANSMUTE_FLOAT_TO_INT,\n                         e.span,\n@@ -585,7 +582,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                             );\n                         },\n                     ),\n-                    (&ty::Adt(ref from_adt, ref from_substs), &ty::Adt(ref to_adt, ref to_substs)) => {\n+                    (ty::Adt(from_adt, from_substs), ty::Adt(to_adt, to_substs)) => {\n                         if from_adt.did != to_adt.did ||\n                                 !COLLECTIONS.iter().any(|path| match_def_path(cx, to_adt.did, path)) {\n                             return;"}, {"sha": "bc5fe44b30f8f9868421600d2b29043ee30247e9", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 118, "deletions": 24, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -10,14 +10,14 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n+    BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n     ImplItemKind, Item, ItemKind, Lifetime, Local, MatchSource, MutTy, Mutability, QPath, Stmt, StmtKind, TraitFn,\n     TraitItem, TraitItemKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, InferTy, Ty, TyCtxt, TypeckTables};\n+use rustc_middle::ty::{self, InferTy, Ty, TyCtxt, TyS, TypeckTables};\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::Span;\n@@ -29,10 +29,10 @@ use rustc_typeck::hir_ty_to_ty;\n use crate::consts::{constant, Constant};\n use crate::utils::paths;\n use crate::utils::{\n-    clip, comparisons, differing_macro_contexts, higher, in_constant, int_bits, is_type_diagnostic_item,\n+    clip, comparisons, differing_macro_contexts, higher, in_constant, indent_of, int_bits, is_type_diagnostic_item,\n     last_path_segment, match_def_path, match_path, method_chain_args, multispan_sugg, numeric_literal::NumericLiteral,\n-    qpath_res, same_tys, sext, snippet, snippet_opt, snippet_with_applicability, snippet_with_macro_callsite,\n-    span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, unsext,\n+    qpath_res, sext, snippet, snippet_block_with_applicability, snippet_opt, snippet_with_applicability,\n+    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, unsext,\n };\n \n declare_clippy_lint! {\n@@ -779,31 +779,124 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n \n         match expr.kind {\n             ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args) => {\n-                for arg in args {\n-                    if is_unit(cx.tables.expr_ty(arg)) && !is_unit_literal(arg) {\n-                        if let ExprKind::Match(.., match_source) = &arg.kind {\n-                            if *match_source == MatchSource::TryDesugar {\n-                                continue;\n+                let args_to_recover = args\n+                    .iter()\n+                    .filter(|arg| {\n+                        if is_unit(cx.tables.expr_ty(arg)) && !is_unit_literal(arg) {\n+                            if let ExprKind::Match(.., MatchSource::TryDesugar) = &arg.kind {\n+                                false\n+                            } else {\n+                                true\n                             }\n+                        } else {\n+                            false\n                         }\n-\n-                        span_lint_and_sugg(\n-                            cx,\n-                            UNIT_ARG,\n-                            arg.span,\n-                            \"passing a unit value to a function\",\n-                            \"if you intended to pass a unit value, use a unit literal instead\",\n-                            \"()\".to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+                    })\n+                    .collect::<Vec<_>>();\n+                if !args_to_recover.is_empty() {\n+                    lint_unit_args(cx, expr, &args_to_recover);\n                 }\n             },\n             _ => (),\n         }\n     }\n }\n \n+fn lint_unit_args(cx: &LateContext<'_, '_>, expr: &Expr<'_>, args_to_recover: &[&Expr<'_>]) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    let (singular, plural) = if args_to_recover.len() > 1 {\n+        (\"\", \"s\")\n+    } else {\n+        (\"a \", \"\")\n+    };\n+    span_lint_and_then(\n+        cx,\n+        UNIT_ARG,\n+        expr.span,\n+        &format!(\"passing {}unit value{} to a function\", singular, plural),\n+        |db| {\n+            let mut or = \"\";\n+            args_to_recover\n+                .iter()\n+                .filter_map(|arg| {\n+                    if_chain! {\n+                        if let ExprKind::Block(block, _) = arg.kind;\n+                        if block.expr.is_none();\n+                        if let Some(last_stmt) = block.stmts.iter().last();\n+                        if let StmtKind::Semi(last_expr) = last_stmt.kind;\n+                        if let Some(snip) = snippet_opt(cx, last_expr.span);\n+                        then {\n+                            Some((\n+                                last_stmt.span,\n+                                snip,\n+                            ))\n+                        }\n+                        else {\n+                            None\n+                        }\n+                    }\n+                })\n+                .for_each(|(span, sugg)| {\n+                    db.span_suggestion(\n+                        span,\n+                        \"remove the semicolon from the last statement in the block\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    or = \"or \";\n+                });\n+            let sugg = args_to_recover\n+                .iter()\n+                .filter(|arg| !is_empty_block(arg))\n+                .enumerate()\n+                .map(|(i, arg)| {\n+                    let indent = if i == 0 {\n+                        0\n+                    } else {\n+                        indent_of(cx, expr.span).unwrap_or(0)\n+                    };\n+                    format!(\n+                        \"{}{};\",\n+                        \" \".repeat(indent),\n+                        snippet_block_with_applicability(cx, arg.span, \"..\", Some(expr.span), &mut applicability)\n+                    )\n+                })\n+                .collect::<Vec<String>>();\n+            let mut and = \"\";\n+            if !sugg.is_empty() {\n+                let plural = if sugg.len() > 1 { \"s\" } else { \"\" };\n+                db.span_suggestion(\n+                    expr.span.with_hi(expr.span.lo()),\n+                    &format!(\"{}move the expression{} in front of the call...\", or, plural),\n+                    format!(\"{}\\n\", sugg.join(\"\\n\")),\n+                    applicability,\n+                );\n+                and = \"...and \"\n+            }\n+            db.multipart_suggestion(\n+                &format!(\"{}use {}unit literal{} instead\", and, singular, plural),\n+                args_to_recover\n+                    .iter()\n+                    .map(|arg| (arg.span, \"()\".to_string()))\n+                    .collect::<Vec<_>>(),\n+                applicability,\n+            );\n+        },\n+    );\n+}\n+\n+fn is_empty_block(expr: &Expr<'_>) -> bool {\n+    matches!(\n+        expr.kind,\n+        ExprKind::Block(\n+            Block {\n+                stmts: &[], expr: None, ..\n+            },\n+            _,\n+        )\n+    )\n+}\n+\n fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n     use rustc_span::hygiene::DesugaringKind;\n     if let ExprKind::Call(ref callee, _) = expr.kind {\n@@ -974,15 +1067,16 @@ declare_clippy_lint! {\n     /// behavior.\n     ///\n     /// **Known problems:** Using `std::ptr::read_unaligned` and `std::ptr::write_unaligned` or similar\n-    /// on the resulting pointer is fine.\n+    /// on the resulting pointer is fine. Is over-zealous: Casts with manual alignment checks or casts like\n+    /// u64-> u8 -> u16 can be fine. Miri is able to do a more in-depth analysis.\n     ///\n     /// **Example:**\n     /// ```rust\n     /// let _ = (&1u8 as *const u8) as *const u16;\n     /// let _ = (&mut 1u8 as *mut u8) as *mut u16;\n     /// ```\n     pub CAST_PTR_ALIGNMENT,\n-    correctness,\n+    pedantic,\n     \"cast from a pointer to a more-strictly-aligned pointer\"\n }\n \n@@ -2462,7 +2556,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n             if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.kind;\n             if let TyKind::Path(QPath::Resolved(None, ty_path)) = ty.kind;\n             then {\n-                if !same_tys(self.cx, self.target.ty(), self.body.expr_ty(e)) {\n+                if !TyS::same_type(self.target.ty(), self.body.expr_ty(e)) {\n                     return;\n                 }\n "}, {"sha": "33d8331c2923c4b376b7964217abd9272c18ee4f", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,267 @@\n+use crate::utils;\n+use crate::utils::paths;\n+use crate::utils::sugg::Sugg;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, Mutability, Param, Pat, PatKind, Path, PathSegment, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Ident;\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Detects when people use `Vec::sort_by` and pass in a function\n+    /// which compares the two arguments, either directly or indirectly.\n+    ///\n+    /// **Why is this bad?**\n+    /// It is more clear to use `Vec::sort_by_key` (or `Vec::sort` if\n+    /// possible) than to use `Vec::sort_by` and and a more complicated\n+    /// closure.\n+    ///\n+    /// **Known problems:**\n+    /// If the suggested `Vec::sort_by_key` uses Reverse and it isn't\n+    /// imported by a use statement in the current frame, then a `use`\n+    /// statement that imports it will need to be added (which this lint\n+    /// can't do).\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// # struct A;\n+    /// # impl A { fn foo(&self) {} }\n+    /// # let mut vec: Vec<A> = Vec::new();\n+    /// vec.sort_by(|a, b| a.foo().cmp(&b.foo()));\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # struct A;\n+    /// # impl A { fn foo(&self) {} }\n+    /// # let mut vec: Vec<A> = Vec::new();\n+    /// vec.sort_by_key(|a| a.foo());\n+    /// ```\n+    pub UNNECESSARY_SORT_BY,\n+    complexity,\n+    \"Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer\"\n+}\n+\n+declare_lint_pass!(UnnecessarySortBy => [UNNECESSARY_SORT_BY]);\n+\n+enum LintTrigger {\n+    Sort(SortDetection),\n+    SortByKey(SortByKeyDetection),\n+}\n+\n+struct SortDetection {\n+    vec_name: String,\n+    unstable: bool,\n+}\n+\n+struct SortByKeyDetection {\n+    vec_name: String,\n+    closure_arg: String,\n+    closure_body: String,\n+    reverse: bool,\n+    unstable: bool,\n+}\n+\n+/// Detect if the two expressions are mirrored (identical, except one\n+/// contains a and the other replaces it with b)\n+fn mirrored_exprs(\n+    cx: &LateContext<'_, '_>,\n+    a_expr: &Expr<'_>,\n+    a_ident: &Ident,\n+    b_expr: &Expr<'_>,\n+    b_ident: &Ident,\n+) -> bool {\n+    match (&a_expr.kind, &b_expr.kind) {\n+        // Two boxes with mirrored contents\n+        (ExprKind::Box(left_expr), ExprKind::Box(right_expr)) => {\n+            mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+        },\n+        // Two arrays with mirrored contents\n+        (ExprKind::Array(left_exprs), ExprKind::Array(right_exprs)) => left_exprs\n+            .iter()\n+            .zip(right_exprs.iter())\n+            .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n+        // The two exprs are function calls.\n+        // Check to see that the function itself and its arguments are mirrored\n+        (ExprKind::Call(left_expr, left_args), ExprKind::Call(right_expr, right_args)) => {\n+            mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+                && left_args\n+                    .iter()\n+                    .zip(right_args.iter())\n+                    .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+        },\n+        // The two exprs are method calls.\n+        // Check to see that the function is the same and the arguments are mirrored\n+        // This is enough because the receiver of the method is listed in the arguments\n+        (ExprKind::MethodCall(left_segment, _, left_args), ExprKind::MethodCall(right_segment, _, right_args)) => {\n+            left_segment.ident == right_segment.ident\n+                && left_args\n+                    .iter()\n+                    .zip(right_args.iter())\n+                    .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+        },\n+        // Two tuples with mirrored contents\n+        (ExprKind::Tup(left_exprs), ExprKind::Tup(right_exprs)) => left_exprs\n+            .iter()\n+            .zip(right_exprs.iter())\n+            .all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n+        // Two binary ops, which are the same operation and which have mirrored arguments\n+        (ExprKind::Binary(left_op, left_left, left_right), ExprKind::Binary(right_op, right_left, right_right)) => {\n+            left_op.node == right_op.node\n+                && mirrored_exprs(cx, left_left, a_ident, right_left, b_ident)\n+                && mirrored_exprs(cx, left_right, a_ident, right_right, b_ident)\n+        },\n+        // Two unary ops, which are the same operation and which have the same argument\n+        (ExprKind::Unary(left_op, left_expr), ExprKind::Unary(right_op, right_expr)) => {\n+            left_op == right_op && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+        },\n+        // The two exprs are literals of some kind\n+        (ExprKind::Lit(left_lit), ExprKind::Lit(right_lit)) => left_lit.node == right_lit.node,\n+        (ExprKind::Cast(left, _), ExprKind::Cast(right, _)) => mirrored_exprs(cx, left, a_ident, right, b_ident),\n+        (ExprKind::DropTemps(left_block), ExprKind::DropTemps(right_block)) => {\n+            mirrored_exprs(cx, left_block, a_ident, right_block, b_ident)\n+        },\n+        (ExprKind::Field(left_expr, left_ident), ExprKind::Field(right_expr, right_ident)) => {\n+            left_ident.name == right_ident.name && mirrored_exprs(cx, left_expr, a_ident, right_expr, right_ident)\n+        },\n+        // Two paths: either one is a and the other is b, or they're identical to each other\n+        (\n+            ExprKind::Path(QPath::Resolved(\n+                _,\n+                Path {\n+                    segments: left_segments,\n+                    ..\n+                },\n+            )),\n+            ExprKind::Path(QPath::Resolved(\n+                _,\n+                Path {\n+                    segments: right_segments,\n+                    ..\n+                },\n+            )),\n+        ) => {\n+            (left_segments\n+                .iter()\n+                .zip(right_segments.iter())\n+                .all(|(left, right)| left.ident == right.ident)\n+                && left_segments\n+                    .iter()\n+                    .all(|seg| &seg.ident != a_ident && &seg.ident != b_ident))\n+                || (left_segments.len() == 1\n+                    && &left_segments[0].ident == a_ident\n+                    && right_segments.len() == 1\n+                    && &right_segments[0].ident == b_ident)\n+        },\n+        // Matching expressions, but one or both is borrowed\n+        (\n+            ExprKind::AddrOf(left_kind, Mutability::Not, left_expr),\n+            ExprKind::AddrOf(right_kind, Mutability::Not, right_expr),\n+        ) => left_kind == right_kind && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n+        (_, ExprKind::AddrOf(_, Mutability::Not, right_expr)) => {\n+            mirrored_exprs(cx, a_expr, a_ident, right_expr, b_ident)\n+        },\n+        (ExprKind::AddrOf(_, Mutability::Not, left_expr), _) => mirrored_exprs(cx, left_expr, a_ident, b_expr, b_ident),\n+        _ => false,\n+    }\n+}\n+\n+fn detect_lint(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(name_ident, _, args) = &expr.kind;\n+        if let name = name_ident.ident.name.to_ident_string();\n+        if name == \"sort_by\" || name == \"sort_unstable_by\";\n+        if let [vec, Expr { kind: ExprKind::Closure(_, _, closure_body_id, _, _), .. }] = args;\n+        if utils::match_type(cx, &cx.tables.expr_ty(vec), &paths::VEC);\n+        if let closure_body = cx.tcx.hir().body(*closure_body_id);\n+        if let &[\n+            Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},\n+            Param { pat: Pat { kind: PatKind::Binding(_, _, right_ident, _), .. }, .. }\n+        ] = &closure_body.params;\n+        if let ExprKind::MethodCall(method_path, _, [ref left_expr, ref right_expr]) = &closure_body.value.kind;\n+        if method_path.ident.name.to_ident_string() == \"cmp\";\n+        then {\n+            let (closure_body, closure_arg, reverse) = if mirrored_exprs(\n+                &cx,\n+                &left_expr,\n+                &left_ident,\n+                &right_expr,\n+                &right_ident\n+            ) {\n+                (Sugg::hir(cx, &left_expr, \"..\").to_string(), left_ident.name.to_string(), false)\n+            } else if mirrored_exprs(&cx, &left_expr, &right_ident, &right_expr, &left_ident) {\n+                (Sugg::hir(cx, &left_expr, \"..\").to_string(), right_ident.name.to_string(), true)\n+            } else {\n+                return None;\n+            };\n+            let vec_name = Sugg::hir(cx, &args[0], \"..\").to_string();\n+            let unstable = name == \"sort_unstable_by\";\n+            if_chain! {\n+                if let ExprKind::Path(QPath::Resolved(_, Path {\n+                    segments: [PathSegment { ident: left_name, .. }], ..\n+                })) = &left_expr.kind;\n+                if left_name == left_ident;\n+                then {\n+                    Some(LintTrigger::Sort(SortDetection { vec_name, unstable }))\n+                }\n+                else {\n+                    Some(LintTrigger::SortByKey(SortByKeyDetection {\n+                        vec_name,\n+                        unstable,\n+                        closure_arg,\n+                        closure_body,\n+                        reverse\n+                    }))\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl LateLintPass<'_, '_> for UnnecessarySortBy {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+        match detect_lint(cx, expr) {\n+            Some(LintTrigger::SortByKey(trigger)) => utils::span_lint_and_sugg(\n+                cx,\n+                UNNECESSARY_SORT_BY,\n+                expr.span,\n+                \"use Vec::sort_by_key here instead\",\n+                \"try\",\n+                format!(\n+                    \"{}.sort{}_by_key(|&{}| {})\",\n+                    trigger.vec_name,\n+                    if trigger.unstable { \"_unstable\" } else { \"\" },\n+                    trigger.closure_arg,\n+                    if trigger.reverse {\n+                        format!(\"Reverse({})\", trigger.closure_body)\n+                    } else {\n+                        trigger.closure_body.to_string()\n+                    },\n+                ),\n+                if trigger.reverse {\n+                    Applicability::MaybeIncorrect\n+                } else {\n+                    Applicability::MachineApplicable\n+                },\n+            ),\n+            Some(LintTrigger::Sort(trigger)) => utils::span_lint_and_sugg(\n+                cx,\n+                UNNECESSARY_SORT_BY,\n+                expr.span,\n+                \"use Vec::sort here instead\",\n+                \"try\",\n+                format!(\n+                    \"{}.sort{}()\",\n+                    trigger.vec_name,\n+                    if trigger.unstable { \"_unstable\" } else { \"\" },\n+                ),\n+                Applicability::MachineApplicable,\n+            ),\n+            None => {},\n+        }\n+    }\n+}"}, {"sha": "8c281126c32bf8c954b7e1c057e6ced0c8573e49", "filename": "src/tools/clippy/clippy_lints/src/unnested_or_patterns.rs", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,407 @@\n+#![allow(clippy::wildcard_imports, clippy::enum_glob_use)]\n+\n+use crate::utils::ast_utils::{eq_field_pat, eq_id, eq_pat, eq_path};\n+use crate::utils::{over, span_lint_and_then};\n+use rustc_ast::ast::{self, Pat, PatKind, PatKind::*, DUMMY_NODE_ID};\n+use rustc_ast::mut_visit::*;\n+use rustc_ast::ptr::P;\n+use rustc_ast_pretty::pprust;\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::DUMMY_SP;\n+\n+use std::cell::Cell;\n+use std::mem;\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    ///\n+    /// Checks for unnested or-patterns, e.g., `Some(0) | Some(2)` and\n+    /// suggests replacing the pattern with a nested one, `Some(0 | 2)`.\n+    ///\n+    /// Another way to think of this is that it rewrites patterns in\n+    /// *disjunctive normal form (DNF)* into *conjunctive normal form (CNF)*.\n+    ///\n+    /// **Why is this bad?**\n+    ///\n+    /// In the example above, `Some` is repeated, which unncessarily complicates the pattern.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// fn main() {\n+    ///     if let Some(0) | Some(2) = Some(0) {}\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// #![feature(or_patterns)]\n+    ///\n+    /// fn main() {\n+    ///     if let Some(0 | 2) = Some(0) {}\n+    /// }\n+    /// ```\n+    pub UNNESTED_OR_PATTERNS,\n+    complexity,\n+    \"unnested or-patterns, e.g., `Foo(Bar) | Foo(Baz) instead of `Foo(Bar | Baz)`\"\n+}\n+\n+declare_lint_pass!(UnnestedOrPatterns => [UNNESTED_OR_PATTERNS]);\n+\n+impl EarlyLintPass for UnnestedOrPatterns {\n+    fn check_arm(&mut self, cx: &EarlyContext<'_>, a: &ast::Arm) {\n+        lint_unnested_or_patterns(cx, &a.pat);\n+    }\n+\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        if let ast::ExprKind::Let(pat, _) = &e.kind {\n+            lint_unnested_or_patterns(cx, pat);\n+        }\n+    }\n+\n+    fn check_param(&mut self, cx: &EarlyContext<'_>, p: &ast::Param) {\n+        lint_unnested_or_patterns(cx, &p.pat);\n+    }\n+\n+    fn check_local(&mut self, cx: &EarlyContext<'_>, l: &ast::Local) {\n+        lint_unnested_or_patterns(cx, &l.pat);\n+    }\n+}\n+\n+fn lint_unnested_or_patterns(cx: &EarlyContext<'_>, pat: &Pat) {\n+    if !cx.sess.opts.unstable_features.is_nightly_build() {\n+        // User cannot do `#![feature(or_patterns)]`, so bail.\n+        return;\n+    }\n+\n+    if let Ident(.., None) | Lit(_) | Wild | Path(..) | Range(..) | Rest | MacCall(_) = pat.kind {\n+        // This is a leaf pattern, so cloning is unprofitable.\n+        return;\n+    }\n+\n+    let mut pat = P(pat.clone());\n+\n+    // Nix all the paren patterns everywhere so that they aren't in our way.\n+    remove_all_parens(&mut pat);\n+\n+    // Transform all unnested or-patterns into nested ones, and if there were none, quit.\n+    if !unnest_or_patterns(&mut pat) {\n+        return;\n+    }\n+\n+    span_lint_and_then(cx, UNNESTED_OR_PATTERNS, pat.span, \"unnested or-patterns\", |db| {\n+        insert_necessary_parens(&mut pat);\n+        db.span_suggestion_verbose(\n+            pat.span,\n+            \"nest the patterns\",\n+            pprust::pat_to_string(&pat),\n+            Applicability::MachineApplicable,\n+        );\n+    });\n+}\n+\n+/// Remove all `(p)` patterns in `pat`.\n+fn remove_all_parens(pat: &mut P<Pat>) {\n+    struct Visitor;\n+    impl MutVisitor for Visitor {\n+        fn visit_pat(&mut self, pat: &mut P<Pat>) {\n+            noop_visit_pat(pat, self);\n+            let inner = match &mut pat.kind {\n+                Paren(i) => mem::replace(&mut i.kind, Wild),\n+                _ => return,\n+            };\n+            pat.kind = inner;\n+        }\n+    }\n+    Visitor.visit_pat(pat);\n+}\n+\n+/// Insert parens where necessary according to Rust's precedence rules for patterns.\n+fn insert_necessary_parens(pat: &mut P<Pat>) {\n+    struct Visitor;\n+    impl MutVisitor for Visitor {\n+        fn visit_pat(&mut self, pat: &mut P<Pat>) {\n+            use ast::{BindingMode::*, Mutability::*};\n+            noop_visit_pat(pat, self);\n+            let target = match &mut pat.kind {\n+                // `i @ a | b`, `box a | b`, and `& mut? a | b`.\n+                Ident(.., Some(p)) | Box(p) | Ref(p, _) if matches!(&p.kind, Or(ps) if ps.len() > 1) => p,\n+                Ref(p, Not) if matches!(p.kind, Ident(ByValue(Mut), ..)) => p, // `&(mut x)`\n+                _ => return,\n+            };\n+            target.kind = Paren(P(take_pat(target)));\n+        }\n+    }\n+    Visitor.visit_pat(pat);\n+}\n+\n+/// Unnest or-patterns `p0 | ... | p1` in the pattern `pat`.\n+/// For example, this would transform `Some(0) | FOO | Some(2)` into `Some(0 | 2) | FOO`.\n+fn unnest_or_patterns(pat: &mut P<Pat>) -> bool {\n+    struct Visitor {\n+        changed: bool,\n+    }\n+    impl MutVisitor for Visitor {\n+        fn visit_pat(&mut self, p: &mut P<Pat>) {\n+            // This is a bottom up transformation, so recurse first.\n+            noop_visit_pat(p, self);\n+\n+            // Don't have an or-pattern? Just quit early on.\n+            let alternatives = match &mut p.kind {\n+                Or(ps) => ps,\n+                _ => return,\n+            };\n+\n+            // Collapse or-patterns directly nested in or-patterns.\n+            let mut idx = 0;\n+            let mut this_level_changed = false;\n+            while idx < alternatives.len() {\n+                let inner = if let Or(ps) = &mut alternatives[idx].kind {\n+                    mem::take(ps)\n+                } else {\n+                    idx += 1;\n+                    continue;\n+                };\n+                this_level_changed = true;\n+                alternatives.splice(idx..=idx, inner);\n+            }\n+\n+            // Focus on `p_n` and then try to transform all `p_i` where `i > n`.\n+            let mut focus_idx = 0;\n+            while focus_idx < alternatives.len() {\n+                this_level_changed |= transform_with_focus_on_idx(alternatives, focus_idx);\n+                focus_idx += 1;\n+            }\n+            self.changed |= this_level_changed;\n+\n+            // Deal with `Some(Some(0)) | Some(Some(1))`.\n+            if this_level_changed {\n+                noop_visit_pat(p, self);\n+            }\n+        }\n+    }\n+\n+    let mut visitor = Visitor { changed: false };\n+    visitor.visit_pat(pat);\n+    visitor.changed\n+}\n+\n+/// Match `$scrutinee` against `$pat` and extract `$then` from it.\n+/// Panics if there is no match.\n+macro_rules! always_pat {\n+    ($scrutinee:expr, $pat:pat => $then:expr) => {\n+        match $scrutinee {\n+            $pat => $then,\n+            _ => unreachable!(),\n+        }\n+    };\n+}\n+\n+/// Focus on `focus_idx` in `alternatives`,\n+/// attempting to extend it with elements of the same constructor `C`\n+/// in `alternatives[focus_idx + 1..]`.\n+fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize) -> bool {\n+    // Extract the kind; we'll need to make some changes in it.\n+    let mut focus_kind = mem::replace(&mut alternatives[focus_idx].kind, PatKind::Wild);\n+    // We'll focus on `alternatives[focus_idx]`,\n+    // so we're draining from `alternatives[focus_idx + 1..]`.\n+    let start = focus_idx + 1;\n+\n+    // We're trying to find whatever kind (~\"constructor\") we found in `alternatives[start..]`.\n+    let changed = match &mut focus_kind {\n+        // These pattern forms are \"leafs\" and do not have sub-patterns.\n+        // Therefore they are not some form of constructor `C`,\n+        // with which a pattern `C(p_0)` may be formed,\n+        // which we would want to join with other `C(p_j)`s.\n+        Ident(.., None) | Lit(_) | Wild | Path(..) | Range(..) | Rest | MacCall(_)\n+        // Dealt with elsewhere.\n+        | Or(_) | Paren(_) => false,\n+        // Transform `box x | ... | box y` into `box (x | y)`.\n+        //\n+        // The cases below until `Slice(...)` deal with *singleton* products.\n+        // These patterns have the shape `C(p)`, and not e.g., `C(p0, ..., pn)`.\n+        Box(target) => extend_with_matching(\n+            target, start, alternatives,\n+            |k| matches!(k, Box(_)),\n+            |k| always_pat!(k, Box(p) => p),\n+        ),\n+        // Transform `&m x | ... | &m y` into `&m (x | y)`.\n+        Ref(target, m1) => extend_with_matching(\n+            target, start, alternatives,\n+            |k| matches!(k, Ref(_, m2) if m1 == m2), // Mutabilities must match.\n+            |k| always_pat!(k, Ref(p, _) => p),\n+        ),\n+        // Transform `b @ p0 | ... b @ p1` into `b @ (p0 | p1)`.\n+        Ident(b1, i1, Some(target)) => extend_with_matching(\n+            target, start, alternatives,\n+            // Binding names must match.\n+            |k| matches!(k, Ident(b2, i2, Some(_)) if b1 == b2 && eq_id(*i1, *i2)),\n+            |k| always_pat!(k, Ident(_, _, Some(p)) => p),\n+        ),\n+        // Transform `[pre, x, post] | ... | [pre, y, post]` into `[pre, x | y, post]`.\n+        Slice(ps1) => extend_with_matching_product(\n+            ps1, start, alternatives,\n+            |k, ps1, idx| matches!(k, Slice(ps2) if eq_pre_post(ps1, ps2, idx)),\n+            |k| always_pat!(k, Slice(ps) => ps),\n+        ),\n+        // Transform `(pre, x, post) | ... | (pre, y, post)` into `(pre, x | y, post)`.\n+        Tuple(ps1) => extend_with_matching_product(\n+            ps1, start, alternatives,\n+            |k, ps1, idx| matches!(k, Tuple(ps2) if eq_pre_post(ps1, ps2, idx)),\n+            |k| always_pat!(k, Tuple(ps) => ps),\n+        ),\n+        // Transform `S(pre, x, post) | ... | S(pre, y, post)` into `S(pre, x | y, post)`.\n+        TupleStruct(path1, ps1) => extend_with_matching_product(\n+            ps1, start, alternatives,\n+            |k, ps1, idx| matches!(\n+                k,\n+                TupleStruct(path2, ps2) if eq_path(path1, path2) && eq_pre_post(ps1, ps2, idx)\n+            ),\n+            |k| always_pat!(k, TupleStruct(_, ps) => ps),\n+        ),\n+        // Transform a record pattern `S { fp_0, ..., fp_n }`.\n+        Struct(path1, fps1, rest1) => extend_with_struct_pat(path1, fps1, *rest1, start, alternatives),\n+    };\n+\n+    alternatives[focus_idx].kind = focus_kind;\n+    changed\n+}\n+\n+/// Here we focusing on a record pattern `S { fp_0, ..., fp_n }`.\n+/// In particular, for a record pattern, the order in which the field patterns is irrelevant.\n+/// So when we fixate on some `ident_k: pat_k`, we try to find `ident_k` in the other pattern\n+/// and check that all `fp_i` where `i \u2208 ((0...n) \\ k)` between two patterns are equal.\n+fn extend_with_struct_pat(\n+    path1: &ast::Path,\n+    fps1: &mut Vec<ast::FieldPat>,\n+    rest1: bool,\n+    start: usize,\n+    alternatives: &mut Vec<P<Pat>>,\n+) -> bool {\n+    (0..fps1.len()).any(|idx| {\n+        let pos_in_2 = Cell::new(None); // The element `k`.\n+        let tail_or = drain_matching(\n+            start,\n+            alternatives,\n+            |k| {\n+                matches!(k, Struct(path2, fps2, rest2)\n+                if rest1 == *rest2 // If one struct pattern has `..` so must the other.\n+                && eq_path(path1, path2)\n+                && fps1.len() == fps2.len()\n+                && fps1.iter().enumerate().all(|(idx_1, fp1)| {\n+                    if idx_1 == idx {\n+                        // In the case of `k`, we merely require identical field names\n+                        // so that we will transform into `ident_k: p1_k | p2_k`.\n+                        let pos = fps2.iter().position(|fp2| eq_id(fp1.ident, fp2.ident));\n+                        pos_in_2.set(pos);\n+                        pos.is_some()\n+                    } else {\n+                        fps2.iter().any(|fp2| eq_field_pat(fp1, fp2))\n+                    }\n+                }))\n+            },\n+            // Extract `p2_k`.\n+            |k| always_pat!(k, Struct(_, mut fps, _) => fps.swap_remove(pos_in_2.take().unwrap()).pat),\n+        );\n+        extend_with_tail_or(&mut fps1[idx].pat, tail_or)\n+    })\n+}\n+\n+/// Like `extend_with_matching` but for products with > 1 factor, e.g., `C(p_0, ..., p_n)`.\n+/// Here, the idea is that we fixate on some `p_k` in `C`,\n+/// allowing it to vary between two `targets` and `ps2` (returned by `extract`),\n+/// while also requiring `ps1[..n] ~ ps2[..n]` (pre) and `ps1[n + 1..] ~ ps2[n + 1..]` (post),\n+/// where `~` denotes semantic equality.\n+fn extend_with_matching_product(\n+    targets: &mut Vec<P<Pat>>,\n+    start: usize,\n+    alternatives: &mut Vec<P<Pat>>,\n+    predicate: impl Fn(&PatKind, &[P<Pat>], usize) -> bool,\n+    extract: impl Fn(PatKind) -> Vec<P<Pat>>,\n+) -> bool {\n+    (0..targets.len()).any(|idx| {\n+        let tail_or = drain_matching(\n+            start,\n+            alternatives,\n+            |k| predicate(k, targets, idx),\n+            |k| extract(k).swap_remove(idx),\n+        );\n+        extend_with_tail_or(&mut targets[idx], tail_or)\n+    })\n+}\n+\n+/// Extract the pattern from the given one and replace it with `Wild`.\n+/// This is meant for temporarily swapping out the pattern for manipulation.\n+fn take_pat(from: &mut Pat) -> Pat {\n+    let dummy = Pat {\n+        id: DUMMY_NODE_ID,\n+        kind: Wild,\n+        span: DUMMY_SP,\n+    };\n+    mem::replace(from, dummy)\n+}\n+\n+/// Extend `target` as an or-pattern with the alternatives\n+/// in `tail_or` if there are any and return if there were.\n+fn extend_with_tail_or(target: &mut Pat, tail_or: Vec<P<Pat>>) -> bool {\n+    fn extend(target: &mut Pat, mut tail_or: Vec<P<Pat>>) {\n+        match target {\n+            // On an existing or-pattern in the target, append to it.\n+            Pat { kind: Or(ps), .. } => ps.append(&mut tail_or),\n+            // Otherwise convert the target to an or-pattern.\n+            target => {\n+                let mut init_or = vec![P(take_pat(target))];\n+                init_or.append(&mut tail_or);\n+                target.kind = Or(init_or);\n+            },\n+        }\n+    }\n+\n+    let changed = !tail_or.is_empty();\n+    if changed {\n+        // Extend the target.\n+        extend(target, tail_or);\n+    }\n+    changed\n+}\n+\n+// Extract all inner patterns in `alternatives` matching our `predicate`.\n+// Only elements beginning with `start` are considered for extraction.\n+fn drain_matching(\n+    start: usize,\n+    alternatives: &mut Vec<P<Pat>>,\n+    predicate: impl Fn(&PatKind) -> bool,\n+    extract: impl Fn(PatKind) -> P<Pat>,\n+) -> Vec<P<Pat>> {\n+    let mut tail_or = vec![];\n+    let mut idx = 0;\n+    for pat in alternatives.drain_filter(|p| {\n+        // Check if we should extract, but only if `idx >= start`.\n+        idx += 1;\n+        idx > start && predicate(&p.kind)\n+    }) {\n+        tail_or.push(extract(pat.into_inner().kind));\n+    }\n+    tail_or\n+}\n+\n+fn extend_with_matching(\n+    target: &mut Pat,\n+    start: usize,\n+    alternatives: &mut Vec<P<Pat>>,\n+    predicate: impl Fn(&PatKind) -> bool,\n+    extract: impl Fn(PatKind) -> P<Pat>,\n+) -> bool {\n+    extend_with_tail_or(target, drain_matching(start, alternatives, predicate, extract))\n+}\n+\n+/// Are the patterns in `ps1` and `ps2` equal save for `ps1[idx]` compared to `ps2[idx]`?\n+fn eq_pre_post(ps1: &[P<Pat>], ps2: &[P<Pat>], idx: usize) -> bool {\n+    ps1[idx].is_rest() == ps2[idx].is_rest() // Avoid `[x, ..] | [x, 0]` => `[x, .. | 0]`.\n+        && ps1.len() == ps2.len()\n+        && over(&ps1[..idx], &ps2[..idx], |l, r| eq_pat(l, r))\n+        && over(&ps1[idx + 1..], &ps2[idx + 1..], |l, r| eq_pat(l, r))\n+}"}, {"sha": "036dd16a224af53586df43ebf81fc813a6a2ca55", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -101,7 +101,7 @@ fn collect_unwrap_info<'a, 'tcx>(\n \n     if let ExprKind::Binary(op, left, right) = &expr.kind {\n         match (invert, op.node) {\n-            (false, BinOpKind::And) | (false, BinOpKind::BitAnd) | (true, BinOpKind::Or) | (true, BinOpKind::BitOr) => {\n+            (false, BinOpKind::And | BinOpKind::BitAnd) | (true, BinOpKind::Or | BinOpKind::BitOr) => {\n                 let mut unwrap_info = collect_unwrap_info(cx, left, branch, invert);\n                 unwrap_info.append(&mut collect_unwrap_info(cx, right, branch, invert));\n                 return unwrap_info;"}, {"sha": "141035a980adeabcc50cb47f7e0627c3a32fd8b5", "filename": "src/tools/clippy/clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,12 +1,12 @@\n use crate::utils::{\n-    is_type_diagnostic_item, match_def_path, match_trait_method, paths, same_tys, snippet, snippet_with_macro_callsite,\n+    is_type_diagnostic_item, match_def_path, match_trait_method, paths, snippet, snippet_with_macro_callsite,\n     span_lint_and_help, span_lint_and_sugg,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, HirId, MatchSource};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, TyS};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n declare_clippy_lint! {\n@@ -65,7 +65,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n                 if match_trait_method(cx, e, &paths::INTO) && &*name.ident.as_str() == \"into\" {\n                     let a = cx.tables.expr_ty(e);\n                     let b = cx.tables.expr_ty(&args[0]);\n-                    if same_tys(cx, a, b) {\n+                    if TyS::same_type(a, b) {\n                         let sugg = snippet_with_macro_callsite(cx, args[0].span, \"<expr>\").to_string();\n                         span_lint_and_sugg(\n                             cx,\n@@ -81,7 +81,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n                 if match_trait_method(cx, e, &paths::INTO_ITERATOR) && &*name.ident.as_str() == \"into_iter\" {\n                     let a = cx.tables.expr_ty(e);\n                     let b = cx.tables.expr_ty(&args[0]);\n-                    if same_tys(cx, a, b) {\n+                    if TyS::same_type(a, b) {\n                         let sugg = snippet(cx, args[0].span, \"<expr>\").into_owned();\n                         span_lint_and_sugg(\n                             cx,\n@@ -101,7 +101,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n                         if is_type_diagnostic_item(cx, a, sym!(result_type));\n                         if let ty::Adt(_, substs) = a.kind;\n                         if let Some(a_type) = substs.types().next();\n-                        if same_tys(cx, a_type, b);\n+                        if TyS::same_type(a_type, b);\n \n                         then {\n                             span_lint_and_help(\n@@ -131,7 +131,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n                             if is_type_diagnostic_item(cx, a, sym!(result_type));\n                             if let ty::Adt(_, substs) = a.kind;\n                             if let Some(a_type) = substs.types().next();\n-                            if same_tys(cx, a_type, b);\n+                            if TyS::same_type(a_type, b);\n \n                             then {\n                                 let hint = format!(\"consider removing `{}()`\", snippet(cx, path.span, \"TryFrom::try_from\"));\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n \n                         if_chain! {\n                             if match_def_path(cx, def_id, &paths::FROM_FROM);\n-                            if same_tys(cx, a, b);\n+                            if TyS::same_type(a, b);\n \n                             then {\n                                 let sugg = snippet(cx, args[0].span.source_callsite(), \"<expr>\").into_owned();"}, {"sha": "dcf09da198e2fe4965b93944796d485c696ae602", "filename": "src/tools/clippy/clippy_lints/src/utils/ast_utils.rs", "status": "added", "additions": 526, "deletions": 0, "changes": 526, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,526 @@\n+//! Utilities for manipulating and extracting information from `rustc_ast::ast`.\n+//!\n+//! - The `eq_foobar` functions test for semantic equality but ignores `NodeId`s and `Span`s.\n+\n+#![allow(clippy::similar_names, clippy::wildcard_imports, clippy::enum_glob_use)]\n+\n+use crate::utils::{both, over};\n+use rustc_ast::ast::{self, *};\n+use rustc_ast::ptr::P;\n+use rustc_span::symbol::Ident;\n+use std::mem;\n+\n+/// Checks if each element in the first slice is contained within the latter as per `eq_fn`.\n+pub fn unordered_over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -> bool {\n+    left.len() == right.len() && left.iter().all(|l| right.iter().any(|r| eq_fn(l, r)))\n+}\n+\n+pub fn eq_id(l: Ident, r: Ident) -> bool {\n+    l.name == r.name\n+}\n+\n+pub fn eq_pat(l: &Pat, r: &Pat) -> bool {\n+    use PatKind::*;\n+    match (&l.kind, &r.kind) {\n+        (Paren(l), _) => eq_pat(l, r),\n+        (_, Paren(r)) => eq_pat(l, r),\n+        (Wild, Wild) | (Rest, Rest) => true,\n+        (Lit(l), Lit(r)) => eq_expr(l, r),\n+        (Ident(b1, i1, s1), Ident(b2, i2, s2)) => b1 == b2 && eq_id(*i1, *i2) && both(s1, s2, |l, r| eq_pat(l, r)),\n+        (Range(lf, lt, le), Range(rf, rt, re)) => {\n+            eq_expr_opt(lf, rf) && eq_expr_opt(lt, rt) && eq_range_end(&le.node, &re.node)\n+        },\n+        (Box(l), Box(r))\n+        | (Ref(l, Mutability::Not), Ref(r, Mutability::Not))\n+        | (Ref(l, Mutability::Mut), Ref(r, Mutability::Mut)) => eq_pat(l, r),\n+        (Tuple(l), Tuple(r)) | (Slice(l), Slice(r)) => over(l, r, |l, r| eq_pat(l, r)),\n+        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n+        (TupleStruct(lp, lfs), TupleStruct(rp, rfs)) => eq_path(lp, rp) && over(lfs, rfs, |l, r| eq_pat(l, r)),\n+        (Struct(lp, lfs, lr), Struct(rp, rfs, rr)) => {\n+            lr == rr && eq_path(lp, rp) && unordered_over(lfs, rfs, |lf, rf| eq_field_pat(lf, rf))\n+        },\n+        (Or(ls), Or(rs)) => unordered_over(ls, rs, |l, r| eq_pat(l, r)),\n+        (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_range_end(l: &RangeEnd, r: &RangeEnd) -> bool {\n+    match (l, r) {\n+        (RangeEnd::Excluded, RangeEnd::Excluded) => true,\n+        (RangeEnd::Included(l), RangeEnd::Included(r)) => {\n+            matches!(l, RangeSyntax::DotDotEq) == matches!(r, RangeSyntax::DotDotEq)\n+        },\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_field_pat(l: &FieldPat, r: &FieldPat) -> bool {\n+    l.is_placeholder == r.is_placeholder\n+        && eq_id(l.ident, r.ident)\n+        && eq_pat(&l.pat, &r.pat)\n+        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+}\n+\n+pub fn eq_qself(l: &QSelf, r: &QSelf) -> bool {\n+    l.position == r.position && eq_ty(&l.ty, &r.ty)\n+}\n+\n+pub fn eq_path(l: &Path, r: &Path) -> bool {\n+    over(&l.segments, &r.segments, |l, r| eq_path_seg(l, r))\n+}\n+\n+pub fn eq_path_seg(l: &PathSegment, r: &PathSegment) -> bool {\n+    eq_id(l.ident, r.ident) && both(&l.args, &r.args, |l, r| eq_generic_args(l, r))\n+}\n+\n+pub fn eq_generic_args(l: &GenericArgs, r: &GenericArgs) -> bool {\n+    match (l, r) {\n+        (GenericArgs::AngleBracketed(l), GenericArgs::AngleBracketed(r)) => {\n+            over(&l.args, &r.args, |l, r| eq_angle_arg(l, r))\n+        },\n+        (GenericArgs::Parenthesized(l), GenericArgs::Parenthesized(r)) => {\n+            over(&l.inputs, &r.inputs, |l, r| eq_ty(l, r)) && eq_fn_ret_ty(&l.output, &r.output)\n+        },\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_angle_arg(l: &AngleBracketedArg, r: &AngleBracketedArg) -> bool {\n+    match (l, r) {\n+        (AngleBracketedArg::Arg(l), AngleBracketedArg::Arg(r)) => eq_generic_arg(l, r),\n+        (AngleBracketedArg::Constraint(l), AngleBracketedArg::Constraint(r)) => eq_assoc_constraint(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_generic_arg(l: &GenericArg, r: &GenericArg) -> bool {\n+    match (l, r) {\n+        (GenericArg::Lifetime(l), GenericArg::Lifetime(r)) => eq_id(l.ident, r.ident),\n+        (GenericArg::Type(l), GenericArg::Type(r)) => eq_ty(l, r),\n+        (GenericArg::Const(l), GenericArg::Const(r)) => eq_expr(&l.value, &r.value),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_expr_opt(l: &Option<P<Expr>>, r: &Option<P<Expr>>) -> bool {\n+    both(l, r, |l, r| eq_expr(l, r))\n+}\n+\n+pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n+    use ExprKind::*;\n+    if !over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r)) {\n+        return false;\n+    }\n+    match (&l.kind, &r.kind) {\n+        (Paren(l), _) => eq_expr(l, r),\n+        (_, Paren(r)) => eq_expr(l, r),\n+        (Err, Err) => true,\n+        (Box(l), Box(r)) | (Try(l), Try(r)) | (Await(l), Await(r)) => eq_expr(l, r),\n+        (Array(l), Array(r)) | (Tup(l), Tup(r)) => over(l, r, |l, r| eq_expr(l, r)),\n+        (Repeat(le, ls), Repeat(re, rs)) => eq_expr(le, re) && eq_expr(&ls.value, &rs.value),\n+        (Call(lc, la), Call(rc, ra)) => eq_expr(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n+        (MethodCall(lc, la), MethodCall(rc, ra)) => eq_path_seg(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n+        (Binary(lo, ll, lr), Binary(ro, rl, rr)) => lo.node == ro.node && eq_expr(ll, rl) && eq_expr(lr, rr),\n+        (Unary(lo, l), Unary(ro, r)) => mem::discriminant(lo) == mem::discriminant(ro) && eq_expr(l, r),\n+        (Lit(l), Lit(r)) => l.kind == r.kind,\n+        (Cast(l, lt), Cast(r, rt)) | (Type(l, lt), Type(r, rt)) => eq_expr(l, r) && eq_ty(lt, rt),\n+        (Let(lp, le), Let(rp, re)) => eq_pat(lp, rp) && eq_expr(le, re),\n+        (If(lc, lt, le), If(rc, rt, re)) => eq_expr(lc, rc) && eq_block(lt, rt) && eq_expr_opt(le, re),\n+        (While(lc, lt, ll), While(rc, rt, rl)) => eq_label(ll, rl) && eq_expr(lc, rc) && eq_block(lt, rt),\n+        (ForLoop(lp, li, lt, ll), ForLoop(rp, ri, rt, rl)) => {\n+            eq_label(ll, rl) && eq_pat(lp, rp) && eq_expr(li, ri) && eq_block(lt, rt)\n+        },\n+        (Loop(lt, ll), Loop(rt, rl)) => eq_label(ll, rl) && eq_block(lt, rt),\n+        (Block(lb, ll), Block(rb, rl)) => eq_label(ll, rl) && eq_block(lb, rb),\n+        (TryBlock(l), TryBlock(r)) => eq_block(l, r),\n+        (Yield(l), Yield(r)) | (Ret(l), Ret(r)) => eq_expr_opt(l, r),\n+        (Break(ll, le), Break(rl, re)) => eq_label(ll, rl) && eq_expr_opt(le, re),\n+        (Continue(ll), Continue(rl)) => eq_label(ll, rl),\n+        (Assign(l1, l2, _), Assign(r1, r2, _)) | (Index(l1, l2), Index(r1, r2)) => eq_expr(l1, r1) && eq_expr(l2, r2),\n+        (AssignOp(lo, lp, lv), AssignOp(ro, rp, rv)) => lo.node == ro.node && eq_expr(lp, rp) && eq_expr(lv, rv),\n+        (Field(lp, lf), Field(rp, rf)) => eq_id(*lf, *rf) && eq_expr(lp, rp),\n+        (Match(ls, la), Match(rs, ra)) => eq_expr(ls, rs) && over(la, ra, |l, r| eq_arm(l, r)),\n+        (Closure(lc, la, lm, lf, lb, _), Closure(rc, ra, rm, rf, rb, _)) => {\n+            lc == rc && la.is_async() == ra.is_async() && lm == rm && eq_fn_decl(lf, rf) && eq_expr(lb, rb)\n+        },\n+        (Async(lc, _, lb), Async(rc, _, rb)) => lc == rc && eq_block(lb, rb),\n+        (Range(lf, lt, ll), Range(rf, rt, rl)) => ll == rl && eq_expr_opt(lf, rf) && eq_expr_opt(lt, rt),\n+        (AddrOf(lbk, lm, le), AddrOf(rbk, rm, re)) => lbk == rbk && lm == rm && eq_expr(le, re),\n+        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n+        (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n+        (Struct(lp, lfs, lb), Struct(rp, rfs, rb)) => {\n+            eq_path(lp, rp) && eq_expr_opt(lb, rb) && unordered_over(lfs, rfs, |l, r| eq_field(l, r))\n+        },\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_field(l: &Field, r: &Field) -> bool {\n+    l.is_placeholder == r.is_placeholder\n+        && eq_id(l.ident, r.ident)\n+        && eq_expr(&l.expr, &r.expr)\n+        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+}\n+\n+pub fn eq_arm(l: &Arm, r: &Arm) -> bool {\n+    l.is_placeholder == r.is_placeholder\n+        && eq_pat(&l.pat, &r.pat)\n+        && eq_expr(&l.body, &r.body)\n+        && eq_expr_opt(&l.guard, &r.guard)\n+        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+}\n+\n+pub fn eq_label(l: &Option<Label>, r: &Option<Label>) -> bool {\n+    both(l, r, |l, r| eq_id(l.ident, r.ident))\n+}\n+\n+pub fn eq_block(l: &Block, r: &Block) -> bool {\n+    l.rules == r.rules && over(&l.stmts, &r.stmts, |l, r| eq_stmt(l, r))\n+}\n+\n+pub fn eq_stmt(l: &Stmt, r: &Stmt) -> bool {\n+    use StmtKind::*;\n+    match (&l.kind, &r.kind) {\n+        (Local(l), Local(r)) => {\n+            eq_pat(&l.pat, &r.pat)\n+                && both(&l.ty, &r.ty, |l, r| eq_ty(l, r))\n+                && eq_expr_opt(&l.init, &r.init)\n+                && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        },\n+        (Item(l), Item(r)) => eq_item(l, r, eq_item_kind),\n+        (Expr(l), Expr(r)) | (Semi(l), Semi(r)) => eq_expr(l, r),\n+        (Empty, Empty) => true,\n+        (MacCall(l), MacCall(r)) => l.1 == r.1 && eq_mac_call(&l.0, &r.0) && over(&l.2, &r.2, |l, r| eq_attr(l, r)),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_item<K>(l: &Item<K>, r: &Item<K>, mut eq_kind: impl FnMut(&K, &K) -> bool) -> bool {\n+    eq_id(l.ident, r.ident)\n+        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && eq_vis(&l.vis, &r.vis)\n+        && eq_kind(&l.kind, &r.kind)\n+}\n+\n+pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n+    use ItemKind::*;\n+    match (l, r) {\n+        (ExternCrate(l), ExternCrate(r)) => l == r,\n+        (Use(l), Use(r)) => eq_use_tree(l, r),\n+        (Static(lt, lm, le), Static(rt, rm, re)) => lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (Const(ld, lt, le), Const(rd, rt, re)) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (Fn(ld, lf, lg, lb), Fn(rd, rf, rg, rb)) => {\n+            eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n+        },\n+        (Mod(l), Mod(r)) => l.inline == r.inline && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_item_kind)),\n+        (ForeignMod(l), ForeignMod(r)) => {\n+            both(&l.abi, &r.abi, |l, r| eq_str_lit(l, r))\n+                && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_foreign_item_kind))\n+        },\n+        (TyAlias(ld, lg, lb, lt), TyAlias(rd, rg, rb, rt)) => {\n+            eq_defaultness(*ld, *rd)\n+                && eq_generics(lg, rg)\n+                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && both(lt, rt, |l, r| eq_ty(l, r))\n+        },\n+        (Enum(le, lg), Enum(re, rg)) => {\n+            over(&le.variants, &re.variants, |l, r| eq_variant(l, r)) && eq_generics(lg, rg)\n+        },\n+        (Struct(lv, lg), Struct(rv, rg)) | (Union(lv, lg), Union(rv, rg)) => {\n+            eq_variant_data(lv, rv) && eq_generics(lg, rg)\n+        },\n+        (Trait(la, lu, lg, lb, li), Trait(ra, ru, rg, rb, ri)) => {\n+            la == ra\n+                && matches!(lu, Unsafe::No) == matches!(ru, Unsafe::No)\n+                && eq_generics(lg, rg)\n+                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && over(li, ri, |l, r| eq_item(l, r, eq_assoc_item_kind))\n+        },\n+        (TraitAlias(lg, lb), TraitAlias(rg, rb)) => eq_generics(lg, rg) && over(lb, rb, |l, r| eq_generic_bound(l, r)),\n+        (\n+            Impl {\n+                unsafety: lu,\n+                polarity: lp,\n+                defaultness: ld,\n+                constness: lc,\n+                generics: lg,\n+                of_trait: lot,\n+                self_ty: lst,\n+                items: li,\n+            },\n+            Impl {\n+                unsafety: ru,\n+                polarity: rp,\n+                defaultness: rd,\n+                constness: rc,\n+                generics: rg,\n+                of_trait: rot,\n+                self_ty: rst,\n+                items: ri,\n+            },\n+        ) => {\n+            matches!(lu, Unsafe::No) == matches!(ru, Unsafe::No)\n+                && matches!(lp, ImplPolarity::Positive) == matches!(rp, ImplPolarity::Positive)\n+                && eq_defaultness(*ld, *rd)\n+                && matches!(lc, ast::Const::No) == matches!(rc, ast::Const::No)\n+                && eq_generics(lg, rg)\n+                && both(lot, rot, |l, r| eq_path(&l.path, &r.path))\n+                && eq_ty(lst, rst)\n+                && over(li, ri, |l, r| eq_item(l, r, eq_assoc_item_kind))\n+        },\n+        (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n+        (MacroDef(l), MacroDef(r)) => l.macro_rules == r.macro_rules && eq_mac_args(&l.body, &r.body),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_foreign_item_kind(l: &ForeignItemKind, r: &ForeignItemKind) -> bool {\n+    use ForeignItemKind::*;\n+    match (l, r) {\n+        (Static(lt, lm, le), Static(rt, rm, re)) => lm == rm && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (Fn(ld, lf, lg, lb), Fn(rd, rf, rg, rb)) => {\n+            eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n+        },\n+        (TyAlias(ld, lg, lb, lt), TyAlias(rd, rg, rb, rt)) => {\n+            eq_defaultness(*ld, *rd)\n+                && eq_generics(lg, rg)\n+                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && both(lt, rt, |l, r| eq_ty(l, r))\n+        },\n+        (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_assoc_item_kind(l: &AssocItemKind, r: &AssocItemKind) -> bool {\n+    use AssocItemKind::*;\n+    match (l, r) {\n+        (Const(ld, lt, le), Const(rd, rt, re)) => eq_defaultness(*ld, *rd) && eq_ty(lt, rt) && eq_expr_opt(le, re),\n+        (Fn(ld, lf, lg, lb), Fn(rd, rf, rg, rb)) => {\n+            eq_defaultness(*ld, *rd) && eq_fn_sig(lf, rf) && eq_generics(lg, rg) && both(lb, rb, |l, r| eq_block(l, r))\n+        },\n+        (TyAlias(ld, lg, lb, lt), TyAlias(rd, rg, rb, rt)) => {\n+            eq_defaultness(*ld, *rd)\n+                && eq_generics(lg, rg)\n+                && over(lb, rb, |l, r| eq_generic_bound(l, r))\n+                && both(lt, rt, |l, r| eq_ty(l, r))\n+        },\n+        (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_variant(l: &Variant, r: &Variant) -> bool {\n+    l.is_placeholder == r.is_placeholder\n+        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && eq_vis(&l.vis, &r.vis)\n+        && eq_id(l.ident, r.ident)\n+        && eq_variant_data(&l.data, &r.data)\n+        && both(&l.disr_expr, &r.disr_expr, |l, r| eq_expr(&l.value, &r.value))\n+}\n+\n+pub fn eq_variant_data(l: &VariantData, r: &VariantData) -> bool {\n+    use VariantData::*;\n+    match (l, r) {\n+        (Unit(_), Unit(_)) => true,\n+        (Struct(l, _), Struct(r, _)) | (Tuple(l, _), Tuple(r, _)) => over(l, r, |l, r| eq_struct_field(l, r)),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_struct_field(l: &StructField, r: &StructField) -> bool {\n+    l.is_placeholder == r.is_placeholder\n+        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        && eq_vis(&l.vis, &r.vis)\n+        && both(&l.ident, &r.ident, |l, r| eq_id(*l, *r))\n+        && eq_ty(&l.ty, &r.ty)\n+}\n+\n+pub fn eq_fn_sig(l: &FnSig, r: &FnSig) -> bool {\n+    eq_fn_decl(&l.decl, &r.decl) && eq_fn_header(&l.header, &r.header)\n+}\n+\n+pub fn eq_fn_header(l: &FnHeader, r: &FnHeader) -> bool {\n+    matches!(l.unsafety, Unsafe::No) == matches!(r.unsafety, Unsafe::No)\n+        && l.asyncness.is_async() == r.asyncness.is_async()\n+        && matches!(l.constness, Const::No) == matches!(r.constness, Const::No)\n+        && eq_ext(&l.ext, &r.ext)\n+}\n+\n+pub fn eq_generics(l: &Generics, r: &Generics) -> bool {\n+    over(&l.params, &r.params, |l, r| eq_generic_param(l, r))\n+        && over(&l.where_clause.predicates, &r.where_clause.predicates, |l, r| {\n+            eq_where_predicate(l, r)\n+        })\n+}\n+\n+pub fn eq_where_predicate(l: &WherePredicate, r: &WherePredicate) -> bool {\n+    use WherePredicate::*;\n+    match (l, r) {\n+        (BoundPredicate(l), BoundPredicate(r)) => {\n+            over(&l.bound_generic_params, &r.bound_generic_params, |l, r| {\n+                eq_generic_param(l, r)\n+            }) && eq_ty(&l.bounded_ty, &r.bounded_ty)\n+                && over(&l.bounds, &r.bounds, |l, r| eq_generic_bound(l, r))\n+        },\n+        (RegionPredicate(l), RegionPredicate(r)) => {\n+            eq_id(l.lifetime.ident, r.lifetime.ident) && over(&l.bounds, &r.bounds, |l, r| eq_generic_bound(l, r))\n+        },\n+        (EqPredicate(l), EqPredicate(r)) => eq_ty(&l.lhs_ty, &r.lhs_ty) && eq_ty(&l.rhs_ty, &r.rhs_ty),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_use_tree(l: &UseTree, r: &UseTree) -> bool {\n+    eq_path(&l.prefix, &r.prefix) && eq_use_tree_kind(&l.kind, &r.kind)\n+}\n+\n+pub fn eq_use_tree_kind(l: &UseTreeKind, r: &UseTreeKind) -> bool {\n+    use UseTreeKind::*;\n+    match (l, r) {\n+        (Glob, Glob) => true,\n+        (Simple(l, _, _), Simple(r, _, _)) => both(l, r, |l, r| eq_id(*l, *r)),\n+        (Nested(l), Nested(r)) => over(l, r, |(l, _), (r, _)| eq_use_tree(l, r)),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_defaultness(l: Defaultness, r: Defaultness) -> bool {\n+    match (l, r) {\n+        (Defaultness::Final, Defaultness::Final) | (Defaultness::Default(_), Defaultness::Default(_)) => true,\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_vis(l: &Visibility, r: &Visibility) -> bool {\n+    use VisibilityKind::*;\n+    match (&l.node, &r.node) {\n+        (Public, Public) | (Inherited, Inherited) | (Crate(_), Crate(_)) => true,\n+        (Restricted { path: l, .. }, Restricted { path: r, .. }) => eq_path(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_fn_decl(l: &FnDecl, r: &FnDecl) -> bool {\n+    eq_fn_ret_ty(&l.output, &r.output)\n+        && over(&l.inputs, &r.inputs, |l, r| {\n+            l.is_placeholder == r.is_placeholder\n+                && eq_pat(&l.pat, &r.pat)\n+                && eq_ty(&l.ty, &r.ty)\n+                && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+        })\n+}\n+\n+pub fn eq_fn_ret_ty(l: &FnRetTy, r: &FnRetTy) -> bool {\n+    match (l, r) {\n+        (FnRetTy::Default(_), FnRetTy::Default(_)) => true,\n+        (FnRetTy::Ty(l), FnRetTy::Ty(r)) => eq_ty(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_ty(l: &Ty, r: &Ty) -> bool {\n+    use TyKind::*;\n+    match (&l.kind, &r.kind) {\n+        (Paren(l), _) => eq_ty(l, r),\n+        (_, Paren(r)) => eq_ty(l, r),\n+        (Never, Never) | (Infer, Infer) | (ImplicitSelf, ImplicitSelf) | (Err, Err) | (CVarArgs, CVarArgs) => true,\n+        (Slice(l), Slice(r)) => eq_ty(l, r),\n+        (Array(le, ls), Array(re, rs)) => eq_ty(le, re) && eq_expr(&ls.value, &rs.value),\n+        (Ptr(l), Ptr(r)) => l.mutbl == r.mutbl && eq_ty(&l.ty, &r.ty),\n+        (Rptr(ll, l), Rptr(rl, r)) => {\n+            both(ll, rl, |l, r| eq_id(l.ident, r.ident)) && l.mutbl == r.mutbl && eq_ty(&l.ty, &r.ty)\n+        },\n+        (BareFn(l), BareFn(r)) => {\n+            l.unsafety == r.unsafety\n+                && eq_ext(&l.ext, &r.ext)\n+                && over(&l.generic_params, &r.generic_params, |l, r| eq_generic_param(l, r))\n+                && eq_fn_decl(&l.decl, &r.decl)\n+        },\n+        (Tup(l), Tup(r)) => over(l, r, |l, r| eq_ty(l, r)),\n+        (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n+        (TraitObject(lg, ls), TraitObject(rg, rs)) => ls == rs && over(lg, rg, |l, r| eq_generic_bound(l, r)),\n+        (ImplTrait(_, lg), ImplTrait(_, rg)) => over(lg, rg, |l, r| eq_generic_bound(l, r)),\n+        (Typeof(l), Typeof(r)) => eq_expr(&l.value, &r.value),\n+        (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_ext(l: &Extern, r: &Extern) -> bool {\n+    use Extern::*;\n+    match (l, r) {\n+        (None, None) | (Implicit, Implicit) => true,\n+        (Explicit(l), Explicit(r)) => eq_str_lit(l, r),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_str_lit(l: &StrLit, r: &StrLit) -> bool {\n+    l.style == r.style && l.symbol == r.symbol && l.suffix == r.suffix\n+}\n+\n+pub fn eq_poly_ref_trait(l: &PolyTraitRef, r: &PolyTraitRef) -> bool {\n+    eq_path(&l.trait_ref.path, &r.trait_ref.path)\n+        && over(&l.bound_generic_params, &r.bound_generic_params, |l, r| {\n+            eq_generic_param(l, r)\n+        })\n+}\n+\n+pub fn eq_generic_param(l: &GenericParam, r: &GenericParam) -> bool {\n+    use GenericParamKind::*;\n+    l.is_placeholder == r.is_placeholder\n+        && eq_id(l.ident, r.ident)\n+        && over(&l.bounds, &r.bounds, |l, r| eq_generic_bound(l, r))\n+        && match (&l.kind, &r.kind) {\n+            (Lifetime, Lifetime) => true,\n+            (Type { default: l }, Type { default: r }) => both(l, r, |l, r| eq_ty(l, r)),\n+            (Const { ty: l }, Const { ty: r }) => eq_ty(l, r),\n+            _ => false,\n+        }\n+        && over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r))\n+}\n+\n+pub fn eq_generic_bound(l: &GenericBound, r: &GenericBound) -> bool {\n+    use GenericBound::*;\n+    match (l, r) {\n+        (Trait(ptr1, tbm1), Trait(ptr2, tbm2)) => tbm1 == tbm2 && eq_poly_ref_trait(ptr1, ptr2),\n+        (Outlives(l), Outlives(r)) => eq_id(l.ident, r.ident),\n+        _ => false,\n+    }\n+}\n+\n+pub fn eq_assoc_constraint(l: &AssocTyConstraint, r: &AssocTyConstraint) -> bool {\n+    use AssocTyConstraintKind::*;\n+    eq_id(l.ident, r.ident)\n+        && match (&l.kind, &r.kind) {\n+            (Equality { ty: l }, Equality { ty: r }) => eq_ty(l, r),\n+            (Bound { bounds: l }, Bound { bounds: r }) => over(l, r, |l, r| eq_generic_bound(l, r)),\n+            _ => false,\n+        }\n+}\n+\n+pub fn eq_mac_call(l: &MacCall, r: &MacCall) -> bool {\n+    eq_path(&l.path, &r.path) && eq_mac_args(&l.args, &r.args)\n+}\n+\n+pub fn eq_attr(l: &Attribute, r: &Attribute) -> bool {\n+    use AttrKind::*;\n+    l.style == r.style\n+        && match (&l.kind, &r.kind) {\n+            (DocComment(l), DocComment(r)) => l == r,\n+            (Normal(l), Normal(r)) => eq_path(&l.path, &r.path) && eq_mac_args(&l.args, &r.args),\n+            _ => false,\n+        }\n+}\n+\n+pub fn eq_mac_args(l: &MacArgs, r: &MacArgs) -> bool {\n+    use MacArgs::*;\n+    match (l, r) {\n+        (Empty, Empty) => true,\n+        (Delimited(_, ld, lts), Delimited(_, rd, rts)) => ld == rd && lts.eq_unspanned(rts),\n+        (Eq(_, lts), Eq(_, rts)) => lts.eq_unspanned(rts),\n+        _ => false,\n+    }\n+}"}, {"sha": "f8d197c15e8d698986a466e9bcfcf0d8fdf0cb76", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -332,19 +332,13 @@ fn swap_binop<'a>(\n \n /// Checks if the two `Option`s are both `None` or some equal values as per\n /// `eq_fn`.\n-fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n-where\n-    F: FnMut(&X, &X) -> bool,\n-{\n+pub fn both<X>(l: &Option<X>, r: &Option<X>, mut eq_fn: impl FnMut(&X, &X) -> bool) -> bool {\n     l.as_ref()\n         .map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false, |y| eq_fn(x, y)))\n }\n \n /// Checks if two slices are equal as per `eq_fn`.\n-fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n-where\n-    F: FnMut(&X, &X) -> bool,\n-{\n+pub fn over<X>(left: &[X], right: &[X], mut eq_fn: impl FnMut(&X, &X) -> bool) -> bool {\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n "}, {"sha": "7b59917c2bbfc37d2d35a4af4dd0a0aa8aefa063", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,6 +1,8 @@\n #[macro_use]\n pub mod sym;\n \n+#[allow(clippy::module_name_repetitions)]\n+pub mod ast_utils;\n pub mod attrs;\n pub mod author;\n pub mod camel_case;\n@@ -19,7 +21,7 @@ pub mod sugg;\n pub mod usage;\n pub use self::attrs::*;\n pub use self::diagnostics::*;\n-pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n+pub use self::hir_utils::{both, over, SpanlessEq, SpanlessHash};\n \n use std::borrow::Cow;\n use std::mem;\n@@ -40,7 +42,7 @@ use rustc_hir::{\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::{self, layout::IntegerExt, subst::GenericArg, Binder, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, layout::IntegerExt, subst::GenericArg, Ty, TyCtxt, TypeFoldable};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n use rustc_span::symbol::{self, kw, Symbol};\n@@ -72,7 +74,7 @@ pub fn in_constant(cx: &LateContext<'_, '_>, id: HirId) -> bool {\n     let parent_id = cx.tcx.hir().get_parent_item(id);\n     match cx.tcx.hir().get(parent_id) {\n         Node::Item(&Item {\n-            kind: ItemKind::Const(..),\n+            kind: ItemKind::Const(..) | ItemKind::Static(..),\n             ..\n         })\n         | Node::TraitItem(&TraitItem {\n@@ -83,11 +85,7 @@ pub fn in_constant(cx: &LateContext<'_, '_>, id: HirId) -> bool {\n             kind: ImplItemKind::Const(..),\n             ..\n         })\n-        | Node::AnonConst(_)\n-        | Node::Item(&Item {\n-            kind: ItemKind::Static(..),\n-            ..\n-        }) => true,\n+        | Node::AnonConst(_) => true,\n         Node::Item(&Item {\n             kind: ItemKind::Fn(ref sig, ..),\n             ..\n@@ -165,8 +163,8 @@ pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr<'_>, path: &[&st\n /// Checks if an expression references a variable of the given name.\n pub fn match_var(expr: &Expr<'_>, var: Name) -> bool {\n     if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n-        if path.segments.len() == 1 && path.segments[0].ident.name == var {\n-            return true;\n+        if let [p] = path.segments {\n+            return p.ident.name == var;\n         }\n     }\n     false\n@@ -181,8 +179,7 @@ pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n \n pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n     match *path {\n-        QPath::Resolved(_, ref path) if path.segments.len() == 1 => Some(&path.segments[0]),\n-        QPath::Resolved(..) => None,\n+        QPath::Resolved(_, ref path) => path.segments.get(0),\n         QPath::TypeRelative(_, ref seg) => Some(seg),\n     }\n }\n@@ -201,9 +198,12 @@ pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n         QPath::Resolved(_, ref path) => match_path(path, segments),\n         QPath::TypeRelative(ref ty, ref segment) => match ty.kind {\n             TyKind::Path(ref inner_path) => {\n-                !segments.is_empty()\n-                    && match_qpath(inner_path, &segments[..(segments.len() - 1)])\n-                    && segment.ident.name.as_str() == segments[segments.len() - 1]\n+                if let [prefix @ .., end] = segments {\n+                    if match_qpath(inner_path, prefix) {\n+                        return segment.ident.name.as_str() == *end;\n+                    }\n+                }\n+                false\n             },\n             _ => false,\n         },\n@@ -398,7 +398,7 @@ pub fn method_calls<'tcx>(\n /// Matches an `Expr` against a chain of methods, and return the matched `Expr`s.\n ///\n /// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,\n-/// `matched_method_chain(expr, &[\"bar\", \"baz\"])` will return a `Vec`\n+/// `method_chain_args(expr, &[\"bar\", \"baz\"])` will return a `Vec`\n /// containing the `Expr`s for\n /// `.bar()` and `.baz()`\n pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec<&'a [Expr<'a>]>> {\n@@ -882,20 +882,6 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: hir::HirId) -> T\n     cx.tcx.erase_late_bound_regions(&ret_ty)\n }\n \n-/// Checks if two types are the same.\n-///\n-/// This discards any lifetime annotations, too.\n-//\n-// FIXME: this works correctly for lifetimes bounds (`for <'a> Foo<'a>` ==\n-// `for <'b> Foo<'b>`, but not for type parameters).\n-pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-    let a = cx.tcx.erase_late_bound_regions(&Binder::bind(a));\n-    let b = cx.tcx.erase_late_bound_regions(&Binder::bind(b));\n-    cx.tcx\n-        .infer_ctxt()\n-        .enter(|infcx| infcx.can_eq(cx.param_env, a, b).is_ok())\n-}\n-\n /// Returns `true` if the given type is an `unsafe` function.\n pub fn type_is_unsafe_function<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind {\n@@ -1408,6 +1394,24 @@ pub fn run_lints(cx: &LateContext<'_, '_>, lints: &[&'static Lint], id: HirId) -\n     })\n }\n \n+#[macro_export]\n+macro_rules! unwrap_cargo_metadata {\n+    ($cx: ident, $lint: ident, $deps: expr) => {{\n+        let mut command = cargo_metadata::MetadataCommand::new();\n+        if !$deps {\n+            command.no_deps();\n+        }\n+\n+        match command.exec() {\n+            Ok(metadata) => metadata,\n+            Err(err) => {\n+                span_lint($cx, $lint, DUMMY_SP, &format!(\"could not read cargo metadata: {}\", err));\n+                return;\n+            },\n+        }\n+    }};\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::{trim_multiline, without_block_comments};"}, {"sha": "3b7e9739211b0520cca61321ff7498bcc90c97ef", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -138,5 +138,6 @@ pub const VEC_AS_SLICE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"as_slice\"];\n pub const VEC_DEQUE: [&str; 4] = [\"alloc\", \"collections\", \"vec_deque\", \"VecDeque\"];\n pub const VEC_FROM_ELEM: [&str; 3] = [\"alloc\", \"vec\", \"from_elem\"];\n pub const VEC_NEW: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"new\"];\n+pub const VEC_RESIZE: [&str; 4] = [\"alloc\", \"vec\", \"Vec\", \"resize\"];\n pub const WEAK_ARC: [&str; 3] = [\"alloc\", \"sync\", \"Weak\"];\n pub const WEAK_RC: [&str; 3] = [\"alloc\", \"rc\", \"Weak\"];"}, {"sha": "a8d4c7620b1ef11e92ed9ac0368a145b39bec76d", "filename": "src/tools/clippy/clippy_lints/src/vec.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -17,8 +17,14 @@ declare_clippy_lint! {\n     /// **Known problems:** None.\n     ///\n     /// **Example:**\n-    /// ```rust,ignore\n-    /// foo(&vec![1, 2])\n+    /// ```rust\n+    /// # fn foo(my_vec: &[u8]) {}\n+    ///\n+    /// // Bad\n+    /// foo(&vec![1, 2]);\n+    ///\n+    /// // Good\n+    /// foo(&[1, 2]);\n     /// ```\n     pub USELESS_VEC,\n     perf,"}, {"sha": "86cbfa8203d54679500f47b854add4b1d18de784", "filename": "src/tools/clippy/clippy_lints/src/vec_resize_to_zero.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec_resize_to_zero.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,59 @@\n+use crate::utils::span_lint_and_then;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Spanned;\n+\n+use crate::utils::{match_def_path, paths};\n+use rustc_ast::ast::LitKind;\n+use rustc_hir as hir;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Finds occurences of `Vec::resize(0, an_int)`\n+    ///\n+    /// **Why is this bad?** This is probably an argument inversion mistake.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// vec!(1, 2, 3, 4, 5).resize(0, 5)\n+    /// ```\n+    pub VEC_RESIZE_TO_ZERO,\n+    correctness,\n+    \"emptying a vector with `resize(0, an_int)` instead of `clear()` is probably an argument inversion mistake\"\n+}\n+\n+declare_lint_pass!(VecResizeToZero => [VEC_RESIZE_TO_ZERO]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VecResizeToZero {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let hir::ExprKind::MethodCall(path_segment, _, ref args) = expr.kind;\n+            if let Some(method_def_id) = cx.tables.type_dependent_def_id(expr.hir_id);\n+            if match_def_path(cx, method_def_id, &paths::VEC_RESIZE) && args.len() == 3;\n+            if let ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = args[1].kind;\n+            if let ExprKind::Lit(Spanned { node: LitKind::Int(..), .. }) = args[2].kind;\n+            then {\n+                let method_call_span = expr.span.with_lo(path_segment.ident.span.lo());\n+                span_lint_and_then(\n+                    cx,\n+                    VEC_RESIZE_TO_ZERO,\n+                    expr.span,\n+                    \"emptying a vector with `resize`\",\n+                    |db| {\n+                        db.help(\"the arguments may be inverted...\");\n+                        db.span_suggestion(\n+                            method_call_span,\n+                            \"...or you can empty the vector with\",\n+                            \"clear()\".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "7247518e19b9dd8aa69f87951b8f1b004f65fad2", "filename": "src/tools/clippy/clippy_lints/src/verbose_file_reads.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fverbose_file_reads.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -9,6 +9,7 @@ declare_clippy_lint! {\n     ///\n     /// **Why is this bad?** `fs::{read, read_to_string}` provide the same functionality when `buf` is empty with fewer imports and no intermediate values.\n     /// See also: [fs::read docs](https://doc.rust-lang.org/std/fs/fn.read.html), [fs::read_to_string docs](https://doc.rust-lang.org/std/fs/fn.read_to_string.html)\n+    ///\n     /// **Known problems:** None.\n     ///\n     /// **Example:**"}, {"sha": "511518082bec12d52e56920daf19e88948a621cf", "filename": "src/tools/clippy/clippy_lints/src/wildcard_dependencies.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_dependencies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_dependencies.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -34,12 +34,7 @@ impl LateLintPass<'_, '_> for WildcardDependencies {\n             return;\n         }\n \n-        let metadata = if let Ok(metadata) = cargo_metadata::MetadataCommand::new().no_deps().exec() {\n-            metadata\n-        } else {\n-            span_lint(cx, WILDCARD_DEPENDENCIES, DUMMY_SP, \"could not read cargo metadata\");\n-            return;\n-        };\n+        let metadata = unwrap_cargo_metadata!(cx, WILDCARD_DEPENDENCIES, false);\n \n         for dep in &metadata.packages[0].dependencies {\n             // VersionReq::any() does not work"}, {"sha": "b637253bd0264666418adde8d5c4c86f6f55beee", "filename": "src/tools/clippy/clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -19,8 +19,14 @@ declare_clippy_lint! {\n     /// still around.\n     ///\n     /// **Example:**\n-    /// ```rust\n+    /// ```rust,ignore\n+    /// // Bad\n     /// use std::cmp::Ordering::*;\n+    /// foo(Less);\n+    ///\n+    /// // Good\n+    /// use std::cmp::Ordering;\n+    /// foo(Ordering::Less)\n     /// ```\n     pub ENUM_GLOB_USE,\n     pedantic,\n@@ -60,15 +66,15 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     ///\n-    /// Bad:\n     /// ```rust,ignore\n+    /// // Bad\n     /// use crate1::*;\n     ///\n     /// foo();\n     /// ```\n     ///\n-    /// Good:\n     /// ```rust,ignore\n+    /// // Good\n     /// use crate1::foo;\n     ///\n     /// foo();"}, {"sha": "0820385e01bb5f68d940a2da8e7f433a137dd55a", "filename": "src/tools/clippy/clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -14,7 +14,11 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust\n-    /// 0.0f32 / 0.0;\n+    /// // Bad\n+    /// let nan = 0.0f32 / 0.0;\n+    ///\n+    /// // Good\n+    /// let nan = f32::NAN;\n     /// ```\n     pub ZERO_DIVIDED_BY_ZERO,\n     complexity,"}, {"sha": "497264649573018a92df83380ad4308709979fea", "filename": "src/tools/clippy/doc/changelog_update.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fdoc%2Fchangelog_update.md", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fdoc%2Fchangelog_update.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fchangelog_update.md?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -18,7 +18,7 @@ been very rare that Clippy changes were included in a patch release.\n \n ### 1. Finding the relevant Clippy commits\n \n-Each Rust release ships with its own version of Clippy. The Clippy submodule can\n+Each Rust release ships with its own version of Clippy. The Clippy subtree can\n be found in the `tools` directory of the Rust repository.\n \n Depending on the current time and what exactly you want to update, the following\n@@ -32,8 +32,10 @@ bullet points might be helpful:\n   need to select the Rust release tag from the dropdown and then check the\n   commit of the Clippy directory:\n \n-  ![Explanation of how to find the commit hash](https://user-images.githubusercontent.com/2042399/62846160-1f8b0480-bcce-11e9-9da8-7964ca034e7a.png)\n-\n+To find the commit hash, issue the following command when in a `rust-lang/rust` checkout:\n+```\n+git log --oneline -- src/tools/clippy/ | grep -o \"Merge commit '[a-f0-9]*' into .*\" | head -1 | sed -e \"s/Merge commit '\\([a-f0-9]*\\)' into .*/\\1/g\"\n+```\n \n ### 2. Fetching the PRs between those commits\n \n@@ -74,5 +76,5 @@ relevant commit ranges.\n \n [changelog]: https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md\n [forge]: https://forge.rust-lang.org/\n-[rust_master_tools]: https://github.com/rust-lang/rust/tree/master/src/tools\n-[rust_beta_tools]: https://github.com/rust-lang/rust/tree/beta/src/tools\n+[rust_master_tools]: https://github.com/rust-lang/rust/tree/master/src/tools/clippy\n+[rust_beta_tools]: https://github.com/rust-lang/rust/tree/beta/src/tools/clippy"}, {"sha": "dbc434505947d4e39d05b8fcd753bb8e78cc76d2", "filename": "src/tools/clippy/doc/common_tools_writing_lints.md", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -4,7 +4,9 @@ You may need following tooltips to catch up with common operations.\n \n - [Common tools for writing lints](#common-tools-for-writing-lints)\n   - [Retrieving the type of an expression](#retrieving-the-type-of-an-expression)\n+  - [Checking if an expression is calling a specific method](#checking-if-an-expr-is-calling-a-specific-method)\n   - [Checking if a type implements a specific trait](#checking-if-a-type-implements-a-specific-trait)\n+  - [Checking if a type defines a method](#checking-if-a-type-defines-a-method)\n   - [Dealing with macros](#dealing-with-macros)\n \n Useful Rustc dev guide links:\n@@ -49,6 +51,26 @@ Two noticeable items here:\n - `tables` is [`TypeckTables`][TypeckTables] and is created by type checking step, \n   it includes useful information such as types of expressions, ways to resolve methods and so on.\n \n+# Checking if an expr is calling a specific method\n+\n+Starting with an `expr`, you can check whether it is calling a specific method `some_method`:\n+\n+```rust\n+impl LateLintPass<'_, '_> for MyStructLint {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if_chain! {\n+            // Check our expr is calling a method\n+            if let hir::ExprKind::MethodCall(path, _, _args) = &expr.kind;\n+            // Check the name of this method is `some_method`\n+            if path.ident.name == sym!(some_method);\n+            then {\n+                // ...\n+            }\n+        }\n+    }\n+}\n+```\n+\n # Checking if a type implements a specific trait\n \n There are two ways to do this, depending if the target trait is part of lang items.\n@@ -83,6 +105,32 @@ A list of defined paths for Clippy can be found in [paths.rs][paths]\n \n We access lang items through the type context `tcx`. `tcx` is of type [`TyCtxt`][TyCtxt] and is defined in the `rustc_middle` crate.\n \n+# Checking if a type defines a specific method\n+\n+To check if our type defines a method called `some_method`:\n+\n+```rust\n+use crate::utils::{is_type_diagnostic_item, return_ty};\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MyTypeImpl {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx ImplItem<'_>) {\n+        if_chain! {\n+            // Check if item is a method/function\n+            if let ImplItemKind::Fn(ref signature, _) = impl_item.kind;\n+            // Check the method is named `some_method`\n+            if impl_item.ident.name == sym!(some_method);\n+            // We can also check it has a parameter `self`\n+            if signature.decl.implicit_self.has_implicit_self();\n+            // We can go further and even check if its return type is `String`\n+            if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id), sym!(string_type));\n+            then {\n+                // ...\n+            }\n+        }\n+    }\n+}\n+```\n+\n # Dealing with macros\n \n There are several helpers in Clippy's utils to deal with macros:"}, {"sha": "391952ea6b14f8bcfb6fde52f597161bbb5cd193", "filename": "src/tools/clippy/doc/release.md", "status": "modified", "additions": 43, "deletions": 45, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fdoc%2Frelease.md", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fdoc%2Frelease.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Frelease.md?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -7,55 +7,18 @@ Clippy is released together with stable Rust releases. The dates for these\n releases can be found at the [Rust Forge]. This document explains the necessary\n steps to create a Clippy release.\n \n-1. [Find the Clippy commit](#find-the-clippy-commit)\n-2. [Tag the stable commit](#tag-the-stable-commit)\n-3. [Update `CHANGELOG.md`](#update-changelogmd)\n-4. [Remerge the `beta` branch](#remerge-the-beta-branch)\n-5. [Update the `beta` branch](#update-the-beta-branch)\n+1. [Remerge the `beta` branch](#remerge-the-beta-branch)\n+2. [Update the `beta` branch](#update-the-beta-branch)\n+3. [Find the Clippy commit](#find-the-clippy-commit)\n+4. [Tag the stable commit](#tag-the-stable-commit)\n+5. [Update `CHANGELOG.md`](#update-changelogmd)\n \n _NOTE: This document is for stable Rust releases, not for point releases. For\n point releases, step 1. and 2. should be enough._\n \n [Rust Forge]: https://forge.rust-lang.org/\n \n \n-## Find the Clippy commit\n-\n-The first step is to tag the Clippy commit, that is included in the stable Rust\n-release. This commit can be found in the Rust repository.\n-\n-```bash\n-# Assuming the current directory corresponds to the Rust repository\n-$ git fetch upstream    # `upstream` is the `rust-lang/rust` remote\n-$ git checkout 1.XX.0   # XX should be exchanged with the corresponding version\n-$ git submodule update\n-$ SHA=$(git submodule status src/tools/clippy | awk '{print $1}')\n-```\n-\n-\n-## Tag the stable commit\n-\n-After finding the Clippy commit, it can be tagged with the release number.\n-\n-```bash\n-# Assuming the current directory corresponds to the Clippy repository\n-$ git checkout $SHA\n-$ git tag rust-1.XX.0               # XX should be exchanged with the corresponding version\n-$ git push upstream master --tags   # `upstream` is the `rust-lang/rust-clippy` remote\n-```\n-\n-After this, the release should be available on the Clippy [release page].\n-\n-[release page]: https://github.com/rust-lang/rust-clippy/releases\n-\n-\n-## Update `CHANGELOG.md`\n-\n-For this see the document on [how to update the changelog].\n-\n-[how to update the changelog]: https://github.com/rust-lang/rust-clippy/blob/master/doc/changelog_update.md\n-\n-\n ## Remerge the `beta` branch\n \n This step is only necessary, if since the last release something was backported\n@@ -76,7 +39,7 @@ If this command outputs `master`, this step is **not** necessary.\n ```bash\n # Assuming `HEAD` is the current `master` branch of rust-lang/rust-clippy\n $ git checkout -b backport_remerge\n-$ git merge beta\n+$ git merge upstream/beta\n $ git diff  # This diff has to be empty, otherwise something with the remerge failed\n $ git push origin backport_remerge  # This can be pushed to your fork\n ```\n@@ -96,8 +59,7 @@ determined.\n ```bash\n # Assuming the current directory corresponds to the Rust repository\n $ git checkout beta\n-$ git submodule update\n-$ BETA_SHA=$(git submodule status src/tools/clippy | awk '{print $1}')\n+$ BETA_SHA=$(git log --oneline -- src/tools/clippy/ | grep -o \"Merge commit '[a-f0-9]*' into .*\" | head -1 | sed -e \"s/Merge commit '\\([a-f0-9]*\\)' into .*/\\1/g\")\n ```\n \n After finding the Clippy commit, the `beta` branch in the Clippy repository can\n@@ -109,3 +71,39 @@ $ git checkout beta\n $ git rebase $BETA_SHA\n $ git push upstream beta\n ```\n+\n+\n+## Find the Clippy commit\n+\n+The first step is to tag the Clippy commit, that is included in the stable Rust\n+release. This commit can be found in the Rust repository.\n+\n+```bash\n+# Assuming the current directory corresponds to the Rust repository\n+$ git fetch upstream    # `upstream` is the `rust-lang/rust` remote\n+$ git checkout 1.XX.0   # XX should be exchanged with the corresponding version\n+$ SHA=$(git log --oneline -- src/tools/clippy/ | grep -o \"Merge commit '[a-f0-9]*' into .*\" | head -1 | sed -e \"s/Merge commit '\\([a-f0-9]*\\)' into .*/\\1/g\")\n+```\n+\n+\n+## Tag the stable commit\n+\n+After finding the Clippy commit, it can be tagged with the release number.\n+\n+```bash\n+# Assuming the current directory corresponds to the Clippy repository\n+$ git checkout $SHA\n+$ git tag rust-1.XX.0               # XX should be exchanged with the corresponding version\n+$ git push upstream master --tags   # `upstream` is the `rust-lang/rust-clippy` remote\n+```\n+\n+After this, the release should be available on the Clippy [release page].\n+\n+[release page]: https://github.com/rust-lang/rust-clippy/releases\n+\n+\n+## Update `CHANGELOG.md`\n+\n+For this see the document on [how to update the changelog].\n+\n+[how to update the changelog]: https://github.com/rust-lang/rust-clippy/blob/master/doc/changelog_update.md"}, {"sha": "cac3cc6bdb316eb2891ff3b4d99d1001371ebfbd", "filename": "src/tools/clippy/src/lintlist/mod.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -166,7 +166,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     },\n     Lint {\n         name: \"cast_ptr_alignment\",\n-        group: \"correctness\",\n+        group: \"pedantic\",\n         desc: \"cast from a pointer to a more-strictly-aligned pointer\",\n         deprecation: None,\n         module: \"types\",\n@@ -934,6 +934,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"loops\",\n     },\n+    Lint {\n+        name: \"iter_next_slice\",\n+        group: \"style\",\n+        desc: \"using `.iter().next()` on a sliced array, which can be shortened to just `.get()`\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n     Lint {\n         name: \"iter_nth\",\n         group: \"perf\",\n@@ -1016,7 +1023,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         group: \"style\",\n         desc: \"creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\",\n         deprecation: None,\n-        module: \"returns\",\n+        module: \"let_and_return\",\n     },\n     Lint {\n         name: \"let_underscore_lock\",\n@@ -1735,7 +1742,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     Lint {\n         name: \"pub_enum_variant_names\",\n         group: \"pedantic\",\n-        desc: \"enums where all variants share a prefix/postfix\",\n+        desc: \"public enums where all variants share a prefix/postfix\",\n         deprecation: None,\n         module: \"enum_variants\",\n     },\n@@ -2292,6 +2299,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"no_effect\",\n     },\n+    Lint {\n+        name: \"unnecessary_sort_by\",\n+        group: \"complexity\",\n+        desc: \"Use of `Vec::sort_by` when `Vec::sort_by_key` or `Vec::sort` would be clearer\",\n+        deprecation: None,\n+        module: \"unnecessary_sort_by\",\n+    },\n     Lint {\n         name: \"unnecessary_unwrap\",\n         group: \"complexity\",\n@@ -2313,6 +2327,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"misc_early\",\n     },\n+    Lint {\n+        name: \"unnested_or_patterns\",\n+        group: \"complexity\",\n+        desc: \"unnested or-patterns, e.g., `Foo(Bar) | Foo(Baz) instead of `Foo(Bar | Baz)`\",\n+        deprecation: None,\n+        module: \"unnested_or_patterns\",\n+    },\n     Lint {\n         name: \"unreachable\",\n         group: \"restriction\",\n@@ -2460,6 +2481,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"types\",\n     },\n+    Lint {\n+        name: \"vec_resize_to_zero\",\n+        group: \"correctness\",\n+        desc: \"emptying a vector with `resize(0, an_int)` instead of `clear()` is probably an argument inversion mistake\",\n+        deprecation: None,\n+        module: \"vec_resize_to_zero\",\n+    },\n     Lint {\n         name: \"verbose_bit_mask\",\n         group: \"style\","}, {"sha": "f28aedbf0ab8b71adc9fcf1f47478edf47a8c1b1", "filename": "src/tools/clippy/tests/compile-test.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -184,8 +184,15 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n                 }\n \n                 let src_path = case.path().join(\"src\");\n-                env::set_current_dir(&src_path)?;\n \n+                // When switching between branches, if the previous branch had a test\n+                // that the current branch does not have, the directory is not removed\n+                // because an ignored Cargo.lock file exists.\n+                if !src_path.exists() {\n+                    continue;\n+                }\n+\n+                env::set_current_dir(&src_path)?;\n                 for file in fs::read_dir(&src_path)? {\n                     let file = file?;\n                     if file.file_type()?.is_dir() {"}, {"sha": "ae0a603299629613cd51e8bf506f209cd5a10e1b", "filename": "src/tools/clippy/tests/ui-cargo/cargo_common_metadata/fail/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_common_metadata%2Ffail%2FCargo.toml?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -2,3 +2,5 @@\n name = \"cargo_common_metadata\"\n version = \"0.1.0\"\n publish = false\n+\n+[workspace]"}, {"sha": "737e84e963c9512d85d69acd1171854fb3dc1257", "filename": "src/tools/clippy/tests/ui-cargo/cargo_common_metadata/pass/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_common_metadata%2Fpass%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_common_metadata%2Fpass%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fcargo_common_metadata%2Fpass%2FCargo.toml?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -9,3 +9,5 @@ readme = \"README.md\"\n license = \"MIT OR Apache-2.0\"\n keywords = [\"metadata\", \"lint\", \"clippy\"]\n categories = [\"development-tools::testing\"]\n+\n+[workspace]"}, {"sha": "278bebbbd9e83db1246f38196a34056be5af99e9", "filename": "src/tools/clippy/tests/ui-cargo/multiple_crate_versions/5041_allow_dev_build/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2F5041_allow_dev_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2F5041_allow_dev_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2F5041_allow_dev_build%2FCargo.toml?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -5,6 +5,8 @@ name = \"multiple_crate_versions\"\n version = \"0.1.0\"\n publish = false\n \n+[workspace]\n+\n # One of the versions of winapi is only a dev dependency: allowed\n [dependencies]\n ctrlc = \"=3.1.0\""}, {"sha": "4f97b011334021e8de7b2506509b11da1bf22f86", "filename": "src/tools/clippy/tests/ui-cargo/multiple_crate_versions/fail/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2FCargo.toml?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -3,6 +3,8 @@ name = \"multiple_crate_versions\"\n version = \"0.1.0\"\n publish = false\n \n+[workspace]\n+\n [dependencies]\n ctrlc = \"=3.1.0\"\n ansi_term = \"=0.11.0\""}, {"sha": "b4b49bb369acd41162e95fff181084d4b1100d1d", "filename": "src/tools/clippy/tests/ui-cargo/multiple_crate_versions/pass/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Fpass%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Fpass%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Fpass%2FCargo.toml?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -3,6 +3,8 @@ name = \"cargo_common_metadata\"\n version = \"0.1.0\"\n publish = false\n \n+[workspace]\n+\n [dependencies]\n regex = \"1.3.7\"\n serde = \"1.0.110\""}, {"sha": "3e1a02cbb3c5bc6fd2b874f4237efdd0fb21ab91", "filename": "src/tools/clippy/tests/ui-cargo/wildcard_dependencies/fail/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fwildcard_dependencies%2Ffail%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fwildcard_dependencies%2Ffail%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fwildcard_dependencies%2Ffail%2FCargo.toml?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -3,5 +3,7 @@ name = \"wildcard_dependencies\"\n version = \"0.1.0\"\n publish = false\n \n+[workspace]\n+\n [dependencies]\n regex = \"*\""}, {"sha": "f844cab09ba7c99a157d3347ce491d1c56834b18", "filename": "src/tools/clippy/tests/ui-cargo/wildcard_dependencies/pass/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fwildcard_dependencies%2Fpass%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fwildcard_dependencies%2Fpass%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fwildcard_dependencies%2Fpass%2FCargo.toml?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -3,5 +3,7 @@ name = \"wildcard_dependencies\"\n version = \"0.1.0\"\n publish = false\n \n+[workspace]\n+\n [dependencies]\n regex = \"1\""}, {"sha": "12290db3dcf52adb00bbb3232d74234be2ab06fc", "filename": "src/tools/clippy/tests/ui/checked_conversions.fixed", "status": "modified", "additions": 38, "deletions": 68, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_conversions.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_conversions.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_conversions.fixed?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,106 +1,76 @@\n // run-rustfix\n \n+#![allow(\n+    clippy::cast_lossless,\n+    // Int::max_value will be deprecated in the future\n+    deprecated,\n+)]\n #![warn(clippy::checked_conversions)]\n-#![allow(clippy::cast_lossless)]\n-#![allow(dead_code)]\n+\n use std::convert::TryFrom;\n \n // Positive tests\n \n // Signed to unsigned\n \n-fn i64_to_u32(value: i64) -> Option<u32> {\n-    if u32::try_from(value).is_ok() {\n-        Some(value as u32)\n-    } else {\n-        None\n-    }\n+pub fn i64_to_u32(value: i64) {\n+    let _ = u32::try_from(value).is_ok();\n+    let _ = u32::try_from(value).is_ok();\n }\n \n-fn i64_to_u16(value: i64) -> Option<u16> {\n-    if u16::try_from(value).is_ok() {\n-        Some(value as u16)\n-    } else {\n-        None\n-    }\n+pub fn i64_to_u16(value: i64) {\n+    let _ = u16::try_from(value).is_ok();\n+    let _ = u16::try_from(value).is_ok();\n }\n \n-fn isize_to_u8(value: isize) -> Option<u8> {\n-    if u8::try_from(value).is_ok() {\n-        Some(value as u8)\n-    } else {\n-        None\n-    }\n+pub fn isize_to_u8(value: isize) {\n+    let _ = u8::try_from(value).is_ok();\n+    let _ = u8::try_from(value).is_ok();\n }\n \n // Signed to signed\n \n-fn i64_to_i32(value: i64) -> Option<i32> {\n-    if i32::try_from(value).is_ok() {\n-        Some(value as i32)\n-    } else {\n-        None\n-    }\n+pub fn i64_to_i32(value: i64) {\n+    let _ = i32::try_from(value).is_ok();\n+    let _ = i32::try_from(value).is_ok();\n }\n \n-fn i64_to_i16(value: i64) -> Option<i16> {\n-    if i16::try_from(value).is_ok() {\n-        Some(value as i16)\n-    } else {\n-        None\n-    }\n+pub fn i64_to_i16(value: i64) {\n+    let _ = i16::try_from(value).is_ok();\n+    let _ = i16::try_from(value).is_ok();\n }\n \n // Unsigned to X\n \n-fn u32_to_i32(value: u32) -> Option<i32> {\n-    if i32::try_from(value).is_ok() {\n-        Some(value as i32)\n-    } else {\n-        None\n-    }\n+pub fn u32_to_i32(value: u32) {\n+    let _ = i32::try_from(value).is_ok();\n+    let _ = i32::try_from(value).is_ok();\n }\n \n-fn usize_to_isize(value: usize) -> isize {\n-    if isize::try_from(value).is_ok() && value as i32 == 5 {\n-        5\n-    } else {\n-        1\n-    }\n+pub fn usize_to_isize(value: usize) {\n+    let _ = isize::try_from(value).is_ok() && value as i32 == 5;\n+    let _ = isize::try_from(value).is_ok() && value as i32 == 5;\n }\n \n-fn u32_to_u16(value: u32) -> isize {\n-    if u16::try_from(value).is_ok() && value as i32 == 5 {\n-        5\n-    } else {\n-        1\n-    }\n+pub fn u32_to_u16(value: u32) {\n+    let _ = u16::try_from(value).is_ok() && value as i32 == 5;\n+    let _ = u16::try_from(value).is_ok() && value as i32 == 5;\n }\n \n // Negative tests\n \n-fn no_i64_to_i32(value: i64) -> Option<i32> {\n-    if value <= (i32::max_value() as i64) && value >= 0 {\n-        Some(value as i32)\n-    } else {\n-        None\n-    }\n+pub fn no_i64_to_i32(value: i64) {\n+    let _ = value <= (i32::max_value() as i64) && value >= 0;\n+    let _ = value <= (i32::MAX as i64) && value >= 0;\n }\n \n-fn no_isize_to_u8(value: isize) -> Option<u8> {\n-    if value <= (u8::max_value() as isize) && value >= (u8::min_value() as isize) {\n-        Some(value as u8)\n-    } else {\n-        None\n-    }\n+pub fn no_isize_to_u8(value: isize) {\n+    let _ = value <= (u8::max_value() as isize) && value >= (u8::min_value() as isize);\n+    let _ = value <= (u8::MAX as isize) && value >= (u8::MIN as isize);\n }\n \n-fn i8_to_u8(value: i8) -> Option<u8> {\n-    if value >= 0 {\n-        Some(value as u8)\n-    } else {\n-        None\n-    }\n+pub fn i8_to_u8(value: i8) {\n+    let _ = value >= 0;\n }\n \n fn main() {}"}, {"sha": "895a301e82126084346a6c56231cf854e86a3f48", "filename": "src/tools/clippy/tests/ui/checked_conversions.rs", "status": "modified", "additions": 38, "deletions": 68, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_conversions.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,106 +1,76 @@\n // run-rustfix\n \n+#![allow(\n+    clippy::cast_lossless,\n+    // Int::max_value will be deprecated in the future\n+    deprecated,\n+)]\n #![warn(clippy::checked_conversions)]\n-#![allow(clippy::cast_lossless)]\n-#![allow(dead_code)]\n+\n use std::convert::TryFrom;\n \n // Positive tests\n \n // Signed to unsigned\n \n-fn i64_to_u32(value: i64) -> Option<u32> {\n-    if value <= (u32::max_value() as i64) && value >= 0 {\n-        Some(value as u32)\n-    } else {\n-        None\n-    }\n+pub fn i64_to_u32(value: i64) {\n+    let _ = value <= (u32::max_value() as i64) && value >= 0;\n+    let _ = value <= (u32::MAX as i64) && value >= 0;\n }\n \n-fn i64_to_u16(value: i64) -> Option<u16> {\n-    if value <= i64::from(u16::max_value()) && value >= 0 {\n-        Some(value as u16)\n-    } else {\n-        None\n-    }\n+pub fn i64_to_u16(value: i64) {\n+    let _ = value <= i64::from(u16::max_value()) && value >= 0;\n+    let _ = value <= i64::from(u16::MAX) && value >= 0;\n }\n \n-fn isize_to_u8(value: isize) -> Option<u8> {\n-    if value <= (u8::max_value() as isize) && value >= 0 {\n-        Some(value as u8)\n-    } else {\n-        None\n-    }\n+pub fn isize_to_u8(value: isize) {\n+    let _ = value <= (u8::max_value() as isize) && value >= 0;\n+    let _ = value <= (u8::MAX as isize) && value >= 0;\n }\n \n // Signed to signed\n \n-fn i64_to_i32(value: i64) -> Option<i32> {\n-    if value <= (i32::max_value() as i64) && value >= (i32::min_value() as i64) {\n-        Some(value as i32)\n-    } else {\n-        None\n-    }\n+pub fn i64_to_i32(value: i64) {\n+    let _ = value <= (i32::max_value() as i64) && value >= (i32::min_value() as i64);\n+    let _ = value <= (i32::MAX as i64) && value >= (i32::MIN as i64);\n }\n \n-fn i64_to_i16(value: i64) -> Option<i16> {\n-    if value <= i64::from(i16::max_value()) && value >= i64::from(i16::min_value()) {\n-        Some(value as i16)\n-    } else {\n-        None\n-    }\n+pub fn i64_to_i16(value: i64) {\n+    let _ = value <= i64::from(i16::max_value()) && value >= i64::from(i16::min_value());\n+    let _ = value <= i64::from(i16::MAX) && value >= i64::from(i16::MIN);\n }\n \n // Unsigned to X\n \n-fn u32_to_i32(value: u32) -> Option<i32> {\n-    if value <= i32::max_value() as u32 {\n-        Some(value as i32)\n-    } else {\n-        None\n-    }\n+pub fn u32_to_i32(value: u32) {\n+    let _ = value <= i32::max_value() as u32;\n+    let _ = value <= i32::MAX as u32;\n }\n \n-fn usize_to_isize(value: usize) -> isize {\n-    if value <= isize::max_value() as usize && value as i32 == 5 {\n-        5\n-    } else {\n-        1\n-    }\n+pub fn usize_to_isize(value: usize) {\n+    let _ = value <= isize::max_value() as usize && value as i32 == 5;\n+    let _ = value <= isize::MAX as usize && value as i32 == 5;\n }\n \n-fn u32_to_u16(value: u32) -> isize {\n-    if value <= u16::max_value() as u32 && value as i32 == 5 {\n-        5\n-    } else {\n-        1\n-    }\n+pub fn u32_to_u16(value: u32) {\n+    let _ = value <= u16::max_value() as u32 && value as i32 == 5;\n+    let _ = value <= u16::MAX as u32 && value as i32 == 5;\n }\n \n // Negative tests\n \n-fn no_i64_to_i32(value: i64) -> Option<i32> {\n-    if value <= (i32::max_value() as i64) && value >= 0 {\n-        Some(value as i32)\n-    } else {\n-        None\n-    }\n+pub fn no_i64_to_i32(value: i64) {\n+    let _ = value <= (i32::max_value() as i64) && value >= 0;\n+    let _ = value <= (i32::MAX as i64) && value >= 0;\n }\n \n-fn no_isize_to_u8(value: isize) -> Option<u8> {\n-    if value <= (u8::max_value() as isize) && value >= (u8::min_value() as isize) {\n-        Some(value as u8)\n-    } else {\n-        None\n-    }\n+pub fn no_isize_to_u8(value: isize) {\n+    let _ = value <= (u8::max_value() as isize) && value >= (u8::min_value() as isize);\n+    let _ = value <= (u8::MAX as isize) && value >= (u8::MIN as isize);\n }\n \n-fn i8_to_u8(value: i8) -> Option<u8> {\n-    if value >= 0 {\n-        Some(value as u8)\n-    } else {\n-        None\n-    }\n+pub fn i8_to_u8(value: i8) {\n+    let _ = value >= 0;\n }\n \n fn main() {}"}, {"sha": "648ba3ccd01dbfbc4e9af53ef7301df4de88d355", "filename": "src/tools/clippy/tests/ui/checked_conversions.stderr", "status": "modified", "additions": 73, "deletions": 25, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_conversions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_conversions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_conversions.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,52 +1,100 @@\n error: Checked cast can be simplified.\n-  --> $DIR/checked_conversions.rs:13:8\n+  --> $DIR/checked_conversions.rs:17:13\n    |\n-LL |     if value <= (u32::max_value() as i64) && value >= 0 {\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u32::try_from(value).is_ok()`\n+LL |     let _ = value <= (u32::max_value() as i64) && value >= 0;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u32::try_from(value).is_ok()`\n    |\n    = note: `-D clippy::checked-conversions` implied by `-D warnings`\n \n error: Checked cast can be simplified.\n-  --> $DIR/checked_conversions.rs:21:8\n+  --> $DIR/checked_conversions.rs:18:13\n    |\n-LL |     if value <= i64::from(u16::max_value()) && value >= 0 {\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u16::try_from(value).is_ok()`\n+LL |     let _ = value <= (u32::MAX as i64) && value >= 0;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u32::try_from(value).is_ok()`\n \n error: Checked cast can be simplified.\n-  --> $DIR/checked_conversions.rs:29:8\n+  --> $DIR/checked_conversions.rs:22:13\n    |\n-LL |     if value <= (u8::max_value() as isize) && value >= 0 {\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u8::try_from(value).is_ok()`\n+LL |     let _ = value <= i64::from(u16::max_value()) && value >= 0;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u16::try_from(value).is_ok()`\n \n error: Checked cast can be simplified.\n-  --> $DIR/checked_conversions.rs:39:8\n+  --> $DIR/checked_conversions.rs:23:13\n    |\n-LL |     if value <= (i32::max_value() as i64) && value >= (i32::min_value() as i64) {\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i32::try_from(value).is_ok()`\n+LL |     let _ = value <= i64::from(u16::MAX) && value >= 0;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u16::try_from(value).is_ok()`\n \n error: Checked cast can be simplified.\n-  --> $DIR/checked_conversions.rs:47:8\n+  --> $DIR/checked_conversions.rs:27:13\n    |\n-LL |     if value <= i64::from(i16::max_value()) && value >= i64::from(i16::min_value()) {\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i16::try_from(value).is_ok()`\n+LL |     let _ = value <= (u8::max_value() as isize) && value >= 0;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u8::try_from(value).is_ok()`\n \n error: Checked cast can be simplified.\n-  --> $DIR/checked_conversions.rs:57:8\n+  --> $DIR/checked_conversions.rs:28:13\n    |\n-LL |     if value <= i32::max_value() as u32 {\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i32::try_from(value).is_ok()`\n+LL |     let _ = value <= (u8::MAX as isize) && value >= 0;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u8::try_from(value).is_ok()`\n \n error: Checked cast can be simplified.\n-  --> $DIR/checked_conversions.rs:65:8\n+  --> $DIR/checked_conversions.rs:34:13\n    |\n-LL |     if value <= isize::max_value() as usize && value as i32 == 5 {\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `isize::try_from(value).is_ok()`\n+LL |     let _ = value <= (i32::max_value() as i64) && value >= (i32::min_value() as i64);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i32::try_from(value).is_ok()`\n \n error: Checked cast can be simplified.\n-  --> $DIR/checked_conversions.rs:73:8\n+  --> $DIR/checked_conversions.rs:35:13\n    |\n-LL |     if value <= u16::max_value() as u32 && value as i32 == 5 {\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u16::try_from(value).is_ok()`\n+LL |     let _ = value <= (i32::MAX as i64) && value >= (i32::MIN as i64);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i32::try_from(value).is_ok()`\n \n-error: aborting due to 8 previous errors\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:39:13\n+   |\n+LL |     let _ = value <= i64::from(i16::max_value()) && value >= i64::from(i16::min_value());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i16::try_from(value).is_ok()`\n+\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:40:13\n+   |\n+LL |     let _ = value <= i64::from(i16::MAX) && value >= i64::from(i16::MIN);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i16::try_from(value).is_ok()`\n+\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:46:13\n+   |\n+LL |     let _ = value <= i32::max_value() as u32;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i32::try_from(value).is_ok()`\n+\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:47:13\n+   |\n+LL |     let _ = value <= i32::MAX as u32;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i32::try_from(value).is_ok()`\n+\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:51:13\n+   |\n+LL |     let _ = value <= isize::max_value() as usize && value as i32 == 5;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `isize::try_from(value).is_ok()`\n+\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:52:13\n+   |\n+LL |     let _ = value <= isize::MAX as usize && value as i32 == 5;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `isize::try_from(value).is_ok()`\n+\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:56:13\n+   |\n+LL |     let _ = value <= u16::max_value() as u32 && value as i32 == 5;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u16::try_from(value).is_ok()`\n+\n+error: Checked cast can be simplified.\n+  --> $DIR/checked_conversions.rs:57:13\n+   |\n+LL |     let _ = value <= u16::MAX as u32 && value as i32 == 5;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u16::try_from(value).is_ok()`\n+\n+error: aborting due to 16 previous errors\n "}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/clippy/tests/ui/checked_conversions.stdout", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/feb3536eba10c2e4585d066629598f03d5ddc7c6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_conversions.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/feb3536eba10c2e4585d066629598f03d5ddc7c6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_conversions.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fchecked_conversions.stdout?ref=feb3536eba10c2e4585d066629598f03d5ddc7c6"}, {"sha": "4feab7910b7445da53bf0c73ac25bea9ce160a66", "filename": "src/tools/clippy/tests/ui/crashes/ice-3969.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-3969.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-3969.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-3969.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,51 @@\n+// https://github.com/rust-lang/rust-clippy/issues/3969\n+// used to crash: error: internal compiler error:\n+// src/librustc_traits/normalize_erasing_regions.rs:43: could not fully normalize `<i32 as\n+// std::iter::Iterator>::Item test from rustc ./ui/trivial-bounds/trivial-bounds-inconsistent.rs\n+\n+// Check that tautalogically false bounds are accepted, and are used\n+// in type inference.\n+#![feature(trivial_bounds)]\n+#![allow(unused)]\n+\n+trait A {}\n+\n+impl A for i32 {}\n+\n+struct Dst<X: ?Sized> {\n+    x: X,\n+}\n+\n+struct TwoStrs(str, str)\n+where\n+    str: Sized;\n+\n+fn unsized_local()\n+where\n+    for<'a> Dst<A + 'a>: Sized,\n+{\n+    let x: Dst<A> = *(Box::new(Dst { x: 1 }) as Box<Dst<A>>);\n+}\n+\n+fn return_str() -> str\n+where\n+    str: Sized,\n+{\n+    *\"Sized\".to_string().into_boxed_str()\n+}\n+\n+fn use_op(s: String) -> String\n+where\n+    String: ::std::ops::Neg<Output = String>,\n+{\n+    -s\n+}\n+\n+fn use_for()\n+where\n+    i32: Iterator,\n+{\n+    for _ in 2i32 {}\n+}\n+\n+fn main() {}"}, {"sha": "923db0664a714f53804c76a9e08986e2f8e50327", "filename": "src/tools/clippy/tests/ui/crashes/ice-3969.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-3969.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-3969.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-3969.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,22 @@\n+error: trait objects without an explicit `dyn` are deprecated\n+  --> $DIR/ice-3969.rs:25:17\n+   |\n+LL |     for<'a> Dst<A + 'a>: Sized,\n+   |                 ^^^^^^ help: use `dyn`: `dyn A + 'a`\n+   |\n+   = note: `-D bare-trait-objects` implied by `-D warnings`\n+\n+error: trait objects without an explicit `dyn` are deprecated\n+  --> $DIR/ice-3969.rs:27:16\n+   |\n+LL |     let x: Dst<A> = *(Box::new(Dst { x: 1 }) as Box<Dst<A>>);\n+   |                ^ help: use `dyn`: `dyn A`\n+\n+error: trait objects without an explicit `dyn` are deprecated\n+  --> $DIR/ice-3969.rs:27:57\n+   |\n+LL |     let x: Dst<A> = *(Box::new(Dst { x: 1 }) as Box<Dst<A>>);\n+   |                                                         ^ help: use `dyn`: `dyn A`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "3d5063d1a3a7d783de946c6aa0c9fe3bb04f2f6e", "filename": "src/tools/clippy/tests/ui/crashes/regressions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fregressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fregressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fregressions.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -6,4 +6,8 @@ pub fn foo(bar: *const u8) {\n     println!(\"{:#p}\", bar);\n }\n \n+// Regression test for https://github.com/rust-lang/rust-clippy/issues/4917\n+/// <foo\n+struct A {}\n+\n fn main() {}"}, {"sha": "7f92d0dbdc973a50fd4964ed0312600e49c02619", "filename": "src/tools/clippy/tests/ui/into_iter_on_ref.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finto_iter_on_ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finto_iter_on_ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finto_iter_on_ref.fixed?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -40,4 +40,6 @@ fn main() {\n     let _ = (&HashSet::<i32>::new()).iter(); //~ WARN equivalent to .iter()\n     let _ = std::path::Path::new(\"12/34\").iter(); //~ WARN equivalent to .iter()\n     let _ = std::path::PathBuf::from(\"12/34\").iter(); //~ ERROR equivalent to .iter()\n+\n+    let _ = (&[1, 2, 3]).iter().next(); //~ WARN equivalent to .iter()\n }"}, {"sha": "416056d3fdb9cb3fd2bc5aec5234e9ea0d0630d1", "filename": "src/tools/clippy/tests/ui/into_iter_on_ref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finto_iter_on_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finto_iter_on_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finto_iter_on_ref.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -40,4 +40,6 @@ fn main() {\n     let _ = (&HashSet::<i32>::new()).into_iter(); //~ WARN equivalent to .iter()\n     let _ = std::path::Path::new(\"12/34\").into_iter(); //~ WARN equivalent to .iter()\n     let _ = std::path::PathBuf::from(\"12/34\").into_iter(); //~ ERROR equivalent to .iter()\n+\n+    let _ = (&[1, 2, 3]).into_iter().next(); //~ WARN equivalent to .iter()\n }"}, {"sha": "1cd6400b0195baedc7a1e09d8849859d2361f1a1", "filename": "src/tools/clippy/tests/ui/into_iter_on_ref.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finto_iter_on_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finto_iter_on_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finto_iter_on_ref.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -156,5 +156,11 @@ error: this `.into_iter()` call is equivalent to `.iter()` and will not move the\n LL |     let _ = std::path::PathBuf::from(\"12/34\").into_iter(); //~ ERROR equivalent to .iter()\n    |                                               ^^^^^^^^^ help: call directly: `iter`\n \n-error: aborting due to 26 previous errors\n+error: this `.into_iter()` call is equivalent to `.iter()` and will not move the `array`\n+  --> $DIR/into_iter_on_ref.rs:44:26\n+   |\n+LL |     let _ = (&[1, 2, 3]).into_iter().next(); //~ WARN equivalent to .iter()\n+   |                          ^^^^^^^^^ help: call directly: `iter`\n+\n+error: aborting due to 27 previous errors\n "}, {"sha": "79c1db87ac3c43c4ac97ba7d85bbc53e7d3ce3de", "filename": "src/tools/clippy/tests/ui/iter_next_slice.fixed", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_next_slice.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_next_slice.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_next_slice.fixed?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,24 @@\n+// run-rustfix\n+#![warn(clippy::iter_next_slice)]\n+\n+fn main() {\n+    // test code goes here\n+    let s = [1, 2, 3];\n+    let v = vec![1, 2, 3];\n+\n+    s.get(0);\n+    // Should be replaced by s.get(0)\n+\n+    s.get(2);\n+    // Should be replaced by s.get(2)\n+\n+    v.get(5);\n+    // Should be replaced by v.get(5)\n+\n+    v.get(0);\n+    // Should be replaced by v.get(0)\n+\n+    let o = Some(5);\n+    o.iter().next();\n+    // Shouldn't be linted since this is not a Slice or an Array\n+}"}, {"sha": "ef9a55f3d997c1cb9916d8653786f3d7c609fcdd", "filename": "src/tools/clippy/tests/ui/iter_next_slice.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_next_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_next_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_next_slice.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,24 @@\n+// run-rustfix\n+#![warn(clippy::iter_next_slice)]\n+\n+fn main() {\n+    // test code goes here\n+    let s = [1, 2, 3];\n+    let v = vec![1, 2, 3];\n+\n+    s.iter().next();\n+    // Should be replaced by s.get(0)\n+\n+    s[2..].iter().next();\n+    // Should be replaced by s.get(2)\n+\n+    v[5..].iter().next();\n+    // Should be replaced by v.get(5)\n+\n+    v.iter().next();\n+    // Should be replaced by v.get(0)\n+\n+    let o = Some(5);\n+    o.iter().next();\n+    // Shouldn't be linted since this is not a Slice or an Array\n+}"}, {"sha": "bbf61df0cda68523debcdea9309072eeb61a73e6", "filename": "src/tools/clippy/tests/ui/iter_next_slice.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_next_slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_next_slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fiter_next_slice.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,28 @@\n+error: Using `.iter().next()` on an array\n+  --> $DIR/iter_next_slice.rs:9:5\n+   |\n+LL |     s.iter().next();\n+   |     ^^^^^^^^^^^^^^^ help: try calling: `s.get(0)`\n+   |\n+   = note: `-D clippy::iter-next-slice` implied by `-D warnings`\n+\n+error: Using `.iter().next()` on a Slice without end index.\n+  --> $DIR/iter_next_slice.rs:12:5\n+   |\n+LL |     s[2..].iter().next();\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: try calling: `s.get(2)`\n+\n+error: Using `.iter().next()` on a Slice without end index.\n+  --> $DIR/iter_next_slice.rs:15:5\n+   |\n+LL |     v[5..].iter().next();\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: try calling: `v.get(5)`\n+\n+error: Using `.iter().next()` on an array\n+  --> $DIR/iter_next_slice.rs:18:5\n+   |\n+LL |     v.iter().next();\n+   |     ^^^^^^^^^^^^^^^ help: try calling: `v.get(0)`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "a29b832eb6019af0dda1ffc160fe49ebfac08f32", "filename": "src/tools/clippy/tests/ui/len_zero.fixed", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero.fixed?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -141,3 +141,11 @@ fn main() {\n fn test_slice(b: &[u8]) {\n     if !b.is_empty() {}\n }\n+\n+mod issue_3807 {\n+    // Avoid suggesting changes to ranges if the user did not enable `range_is_empty`.\n+    // See https://github.com/rust-lang/rust/issues/48111#issuecomment-445132965\n+    fn no_suggestion() {\n+        let _ = (0..42).len() == 0;\n+    }\n+}"}, {"sha": "8fd0093f4fdbbc13e31205003209de35fa9a21df", "filename": "src/tools/clippy/tests/ui/len_zero.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -141,3 +141,11 @@ fn main() {\n fn test_slice(b: &[u8]) {\n     if b.len() != 0 {}\n }\n+\n+mod issue_3807 {\n+    // Avoid suggesting changes to ranges if the user did not enable `range_is_empty`.\n+    // See https://github.com/rust-lang/rust/issues/48111#issuecomment-445132965\n+    fn no_suggestion() {\n+        let _ = (0..42).len() == 0;\n+    }\n+}"}, {"sha": "7da26f8ff4d477b9ab0cde400eb834b44ee24cde", "filename": "src/tools/clippy/tests/ui/len_zero_ranges.fixed", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.fixed?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+\n+#![feature(range_is_empty)]\n+#![warn(clippy::len_zero)]\n+#![allow(unused)]\n+\n+mod issue_3807 {\n+    // With the feature enabled, `is_empty` should be suggested\n+    fn suggestion_is_fine() {\n+        let _ = (0..42).is_empty();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "be7b4244bc06c4d27463f35de2181ca23ab2c20a", "filename": "src/tools/clippy/tests/ui/len_zero_ranges.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+\n+#![feature(range_is_empty)]\n+#![warn(clippy::len_zero)]\n+#![allow(unused)]\n+\n+mod issue_3807 {\n+    // With the feature enabled, `is_empty` should be suggested\n+    fn suggestion_is_fine() {\n+        let _ = (0..42).len() == 0;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6e5fa41fb08a55c127f9bb7a8e34624498e018d5", "filename": "src/tools/clippy/tests/ui/len_zero_ranges.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flen_zero_ranges.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,10 @@\n+error: length comparison to zero\n+  --> $DIR/len_zero_ranges.rs:10:17\n+   |\n+LL |         let _ = (0..42).len() == 0;\n+   |                 ^^^^^^^^^^^^^^^^^^ help: using `is_empty` is clearer and more explicit: `(0..42).is_empty()`\n+   |\n+   = note: `-D clippy::len-zero` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "09614b8c1ad787d98975f9c800279a1817a7d3b3", "filename": "src/tools/clippy/tests/ui/let_and_return.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_and_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_and_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_and_return.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,138 @@\n+#![allow(unused)]\n+#![warn(clippy::let_and_return)]\n+\n+fn test() -> i32 {\n+    let _y = 0; // no warning\n+    let x = 5;\n+    x\n+}\n+\n+fn test_inner() -> i32 {\n+    if true {\n+        let x = 5;\n+        x\n+    } else {\n+        0\n+    }\n+}\n+\n+fn test_nowarn_1() -> i32 {\n+    let mut x = 5;\n+    x += 1;\n+    x\n+}\n+\n+fn test_nowarn_2() -> i32 {\n+    let x = 5;\n+    x + 1\n+}\n+\n+fn test_nowarn_3() -> (i32, i32) {\n+    // this should technically warn, but we do not compare complex patterns\n+    let (x, y) = (5, 9);\n+    (x, y)\n+}\n+\n+fn test_nowarn_4() -> i32 {\n+    // this should technically warn, but not b/c of clippy::let_and_return, but b/c of useless type\n+    let x: i32 = 5;\n+    x\n+}\n+\n+fn test_nowarn_5(x: i16) -> u16 {\n+    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]\n+    let x = x as u16;\n+    x\n+}\n+\n+// False positive example\n+trait Decode {\n+    fn decode<D: std::io::Read>(d: D) -> Result<Self, ()>\n+    where\n+        Self: Sized;\n+}\n+\n+macro_rules! tuple_encode {\n+    ($($x:ident),*) => (\n+        impl<$($x: Decode),*> Decode for ($($x),*) {\n+            #[inline]\n+            #[allow(non_snake_case)]\n+            fn decode<D: std::io::Read>(mut d: D) -> Result<Self, ()> {\n+                // Shouldn't trigger lint\n+                Ok(($({let $x = Decode::decode(&mut d)?; $x }),*))\n+            }\n+        }\n+    );\n+}\n+\n+tuple_encode!(T0, T1, T2, T3, T4, T5, T6, T7);\n+\n+mod no_lint_if_stmt_borrows {\n+    mod issue_3792 {\n+        use std::io::{self, BufRead, Stdin};\n+\n+        fn read_line() -> String {\n+            let stdin = io::stdin();\n+            let line = stdin.lock().lines().next().unwrap().unwrap();\n+            line\n+        }\n+    }\n+\n+    mod issue_3324 {\n+        use std::cell::RefCell;\n+        use std::rc::{Rc, Weak};\n+\n+        fn test(value: Weak<RefCell<Bar>>) -> u32 {\n+            let value = value.upgrade().unwrap();\n+            let ret = value.borrow().baz();\n+            ret\n+        }\n+\n+        struct Bar {}\n+\n+        impl Bar {\n+            fn new() -> Self {\n+                Bar {}\n+            }\n+            fn baz(&self) -> u32 {\n+                0\n+            }\n+        }\n+\n+        fn main() {\n+            let a = Rc::new(RefCell::new(Bar::new()));\n+            let b = Rc::downgrade(&a);\n+            test(b);\n+        }\n+    }\n+\n+    mod free_function {\n+        struct Inner;\n+\n+        struct Foo<'a> {\n+            inner: &'a Inner,\n+        }\n+\n+        impl Drop for Foo<'_> {\n+            fn drop(&mut self) {}\n+        }\n+\n+        impl Foo<'_> {\n+            fn value(&self) -> i32 {\n+                42\n+            }\n+        }\n+\n+        fn some_foo(inner: &Inner) -> Foo<'_> {\n+            Foo { inner }\n+        }\n+\n+        fn test() -> i32 {\n+            let x = Inner {};\n+            let value = some_foo(&x).value();\n+            value\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "eacf948b3927a5ee28cd67b3756941d811868764", "filename": "src/tools/clippy/tests/ui/let_and_return.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_and_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_and_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_and_return.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,5 +1,5 @@\n error: returning the result of a `let` binding from a block\n-  --> $DIR/let_return.rs:7:5\n+  --> $DIR/let_and_return.rs:7:5\n    |\n LL |     let x = 5;\n    |     ---------- unnecessary `let` binding\n@@ -14,7 +14,7 @@ LL |     5\n    |\n \n error: returning the result of a `let` binding from a block\n-  --> $DIR/let_return.rs:13:9\n+  --> $DIR/let_and_return.rs:13:9\n    |\n LL |         let x = 5;\n    |         ---------- unnecessary `let` binding", "previous_filename": "src/tools/clippy/tests/ui/let_return.stderr"}, {"sha": "23645d48fe79913acf7f7c856ca5fa846ee2ee72", "filename": "src/tools/clippy/tests/ui/let_return.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/feb3536eba10c2e4585d066629598f03d5ddc7c6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feb3536eba10c2e4585d066629598f03d5ddc7c6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flet_return.rs?ref=feb3536eba10c2e4585d066629598f03d5ddc7c6", "patch": "@@ -1,70 +0,0 @@\n-#![allow(unused)]\n-#![warn(clippy::let_and_return)]\n-\n-fn test() -> i32 {\n-    let _y = 0; // no warning\n-    let x = 5;\n-    x\n-}\n-\n-fn test_inner() -> i32 {\n-    if true {\n-        let x = 5;\n-        x\n-    } else {\n-        0\n-    }\n-}\n-\n-fn test_nowarn_1() -> i32 {\n-    let mut x = 5;\n-    x += 1;\n-    x\n-}\n-\n-fn test_nowarn_2() -> i32 {\n-    let x = 5;\n-    x + 1\n-}\n-\n-fn test_nowarn_3() -> (i32, i32) {\n-    // this should technically warn, but we do not compare complex patterns\n-    let (x, y) = (5, 9);\n-    (x, y)\n-}\n-\n-fn test_nowarn_4() -> i32 {\n-    // this should technically warn, but not b/c of clippy::let_and_return, but b/c of useless type\n-    let x: i32 = 5;\n-    x\n-}\n-\n-fn test_nowarn_5(x: i16) -> u16 {\n-    #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]\n-    let x = x as u16;\n-    x\n-}\n-\n-// False positive example\n-trait Decode {\n-    fn decode<D: std::io::Read>(d: D) -> Result<Self, ()>\n-    where\n-        Self: Sized;\n-}\n-\n-macro_rules! tuple_encode {\n-    ($($x:ident),*) => (\n-        impl<$($x: Decode),*> Decode for ($($x),*) {\n-            #[inline]\n-            #[allow(non_snake_case)]\n-            fn decode<D: std::io::Read>(mut d: D) -> Result<Self, ()> {\n-                // Shouldn't trigger lint\n-                Ok(($({let $x = Decode::decode(&mut d)?; $x }),*))\n-            }\n-        }\n-    );\n-}\n-\n-tuple_encode!(T0, T1, T2, T3, T4, T5, T6, T7);\n-\n-fn main() {}"}, {"sha": "be37dc16b9a3effcc6aec5b4fd92f1de7a2412c5", "filename": "src/tools/clippy/tests/ui/needless_collect.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.fixed?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -9,7 +9,7 @@ use std::collections::{BTreeSet, HashMap, HashSet};\n fn main() {\n     let sample = [1; 5];\n     let len = sample.iter().count();\n-    if sample.iter().next().is_none() {\n+    if sample.get(0).is_none() {\n         // Empty\n     }\n     sample.iter().cloned().any(|x| x == 1);"}, {"sha": "9113aad90dd7cc120e89748f5df590f74878f174", "filename": "src/tools/clippy/tests/ui/needless_collect.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneedless_collect.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,28 +1,28 @@\n error: avoid using `collect()` when not needed\n-  --> $DIR/needless_collect.rs:11:28\n+  --> $DIR/needless_collect.rs:11:29\n    |\n LL |     let len = sample.iter().collect::<Vec<_>>().len();\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `.count()`\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `count()`\n    |\n    = note: `-D clippy::needless-collect` implied by `-D warnings`\n \n error: avoid using `collect()` when not needed\n-  --> $DIR/needless_collect.rs:12:21\n+  --> $DIR/needless_collect.rs:12:15\n    |\n LL |     if sample.iter().collect::<Vec<_>>().is_empty() {\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `.next().is_none()`\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `get(0).is_none()`\n \n error: avoid using `collect()` when not needed\n-  --> $DIR/needless_collect.rs:15:27\n+  --> $DIR/needless_collect.rs:15:28\n    |\n LL |     sample.iter().cloned().collect::<Vec<_>>().contains(&1);\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `.any(|x| x == 1)`\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `any(|x| x == 1)`\n \n error: avoid using `collect()` when not needed\n-  --> $DIR/needless_collect.rs:16:34\n+  --> $DIR/needless_collect.rs:16:35\n    |\n LL |     sample.iter().map(|x| (x, x)).collect::<HashMap<_, _>>().len();\n-   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `.count()`\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `count()`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "ca70e3b7148efd20c55403dff54ab2ed3515337a", "filename": "src/tools/clippy/tests/ui/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -4,6 +4,7 @@\n \n use std::cmp::Ordering;\n \n+#[allow(clippy::unnested_or_patterns)]\n #[warn(clippy::neg_cmp_op_on_partial_ord)]\n fn main() {\n     let a_value = 1.0;"}, {"sha": "8c5d548222e0dc789aeb3bc980bb980cc21058d4", "filename": "src/tools/clippy/tests/ui/neg_cmp_op_on_partial_ord.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,25 +1,25 @@\n error: The use of negated comparison operators on partially ordered types produces code that is hard to read and refactor. Please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable.\n-  --> $DIR/neg_cmp_op_on_partial_ord.rs:15:21\n+  --> $DIR/neg_cmp_op_on_partial_ord.rs:16:21\n    |\n LL |     let _not_less = !(a_value < another_value);\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::neg-cmp-op-on-partial-ord` implied by `-D warnings`\n \n error: The use of negated comparison operators on partially ordered types produces code that is hard to read and refactor. Please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable.\n-  --> $DIR/neg_cmp_op_on_partial_ord.rs:18:30\n+  --> $DIR/neg_cmp_op_on_partial_ord.rs:19:30\n    |\n LL |     let _not_less_or_equal = !(a_value <= another_value);\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: The use of negated comparison operators on partially ordered types produces code that is hard to read and refactor. Please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable.\n-  --> $DIR/neg_cmp_op_on_partial_ord.rs:21:24\n+  --> $DIR/neg_cmp_op_on_partial_ord.rs:22:24\n    |\n LL |     let _not_greater = !(a_value > another_value);\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: The use of negated comparison operators on partially ordered types produces code that is hard to read and refactor. Please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable.\n-  --> $DIR/neg_cmp_op_on_partial_ord.rs:24:33\n+  --> $DIR/neg_cmp_op_on_partial_ord.rs:25:33\n    |\n LL |     let _not_greater_or_equal = !(a_value >= another_value);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "2045ffdb5f09d38996c36d57ffc9c56967859d96", "filename": "src/tools/clippy/tests/ui/or_fun_call.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.fixed?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -29,7 +29,7 @@ fn or_fun_call() {\n     with_enum.unwrap_or(Enum::A(5));\n \n     let with_const_fn = Some(Duration::from_secs(1));\n-    with_const_fn.unwrap_or(Duration::from_secs(5));\n+    with_const_fn.unwrap_or_else(|| Duration::from_secs(5));\n \n     let with_constructor = Some(vec![1]);\n     with_constructor.unwrap_or_else(make);\n@@ -94,7 +94,7 @@ fn test_or_with_ctors() {\n \n     let b = \"b\".to_string();\n     let _ = Some(Bar(\"a\".to_string(), Duration::from_secs(1)))\n-        .or(Some(Bar(b, Duration::from_secs(2))));\n+        .or_else(|| Some(Bar(b, Duration::from_secs(2))));\n \n     let vec = vec![\"foo\"];\n     let _ = opt.ok_or(vec.len());"}, {"sha": "bc5978b538f16f69901c7d59576e840a95f95e23", "filename": "src/tools/clippy/tests/ui/or_fun_call.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_fun_call.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,10 +1,16 @@\n+error: use of `unwrap_or` followed by a function call\n+  --> $DIR/or_fun_call.rs:32:19\n+   |\n+LL |     with_const_fn.unwrap_or(Duration::from_secs(5));\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| Duration::from_secs(5))`\n+   |\n+   = note: `-D clippy::or-fun-call` implied by `-D warnings`\n+\n error: use of `unwrap_or` followed by a function call\n   --> $DIR/or_fun_call.rs:35:22\n    |\n LL |     with_constructor.unwrap_or(make());\n    |                      ^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(make)`\n-   |\n-   = note: `-D clippy::or-fun-call` implied by `-D warnings`\n \n error: use of `unwrap_or` followed by a call to `new`\n   --> $DIR/or_fun_call.rs:38:5\n@@ -78,5 +84,11 @@ error: use of `or` followed by a function call\n LL |     let _ = Some(\"a\".to_string()).or(Some(\"b\".to_string()));\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_else(|| Some(\"b\".to_string()))`\n \n-error: aborting due to 13 previous errors\n+error: use of `or` followed by a function call\n+  --> $DIR/or_fun_call.rs:97:10\n+   |\n+LL |         .or(Some(Bar(b, Duration::from_secs(2))));\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `or_else(|| Some(Bar(b, Duration::from_secs(2))))`\n+\n+error: aborting due to 15 previous errors\n "}, {"sha": "79e482eec3037d416ded2082f509c28c4097cf8c", "filename": "src/tools/clippy/tests/ui/reversed_empty_ranges_fixable.fixed", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_fixable.fixed?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -4,8 +4,6 @@\n const ANSWER: i32 = 42;\n \n fn main() {\n-    let arr = [1, 2, 3, 4, 5];\n-\n     // These should be linted:\n \n     (21..=42).rev().for_each(|x| println!(\"{}\", x));\n@@ -14,16 +12,18 @@ fn main() {\n     for _ in (-42..=-21).rev() {}\n     for _ in (21u32..42u32).rev() {}\n \n-    let _ = &[] as &[i32];\n-\n     // These should be ignored as they are not empty ranges:\n \n     (21..=42).for_each(|x| println!(\"{}\", x));\n     (21..42).for_each(|x| println!(\"{}\", x));\n \n+    let arr = [1, 2, 3, 4, 5];\n     let _ = &arr[1..=3];\n     let _ = &arr[1..3];\n \n     for _ in 21..=42 {}\n     for _ in 21..42 {}\n+\n+    // This range is empty but should be ignored, see issue #5689\n+    let _ = &arr[0..0];\n }"}, {"sha": "b2e8bf33771acac68610d046227101c281dccaa5", "filename": "src/tools/clippy/tests/ui/reversed_empty_ranges_fixable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_fixable.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -4,8 +4,6 @@\n const ANSWER: i32 = 42;\n \n fn main() {\n-    let arr = [1, 2, 3, 4, 5];\n-\n     // These should be linted:\n \n     (42..=21).for_each(|x| println!(\"{}\", x));\n@@ -14,16 +12,18 @@ fn main() {\n     for _ in -21..=-42 {}\n     for _ in 42u32..21u32 {}\n \n-    let _ = &arr[3..3];\n-\n     // These should be ignored as they are not empty ranges:\n \n     (21..=42).for_each(|x| println!(\"{}\", x));\n     (21..42).for_each(|x| println!(\"{}\", x));\n \n+    let arr = [1, 2, 3, 4, 5];\n     let _ = &arr[1..=3];\n     let _ = &arr[1..3];\n \n     for _ in 21..=42 {}\n     for _ in 21..42 {}\n+\n+    // This range is empty but should be ignored, see issue #5689\n+    let _ = &arr[0..0];\n }"}, {"sha": "de83c4f3d633c141e502bf1cadbcab2eae61f6cc", "filename": "src/tools/clippy/tests/ui/reversed_empty_ranges_fixable.stderr", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_fixable.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,5 +1,5 @@\n error: this range is empty so it will yield no values\n-  --> $DIR/reversed_empty_ranges_fixable.rs:11:5\n+  --> $DIR/reversed_empty_ranges_fixable.rs:9:5\n    |\n LL |     (42..=21).for_each(|x| println!(\"{}\", x));\n    |     ^^^^^^^^^\n@@ -11,7 +11,7 @@ LL |     (21..=42).rev().for_each(|x| println!(\"{}\", x));\n    |     ^^^^^^^^^^^^^^^\n \n error: this range is empty so it will yield no values\n-  --> $DIR/reversed_empty_ranges_fixable.rs:12:13\n+  --> $DIR/reversed_empty_ranges_fixable.rs:10:13\n    |\n LL |     let _ = (ANSWER..21).filter(|x| x % 2 == 0).take(10).collect::<Vec<_>>();\n    |             ^^^^^^^^^^^^\n@@ -22,7 +22,7 @@ LL |     let _ = (21..ANSWER).rev().filter(|x| x % 2 == 0).take(10).collect::<Ve\n    |             ^^^^^^^^^^^^^^^^^^\n \n error: this range is empty so it will yield no values\n-  --> $DIR/reversed_empty_ranges_fixable.rs:14:14\n+  --> $DIR/reversed_empty_ranges_fixable.rs:12:14\n    |\n LL |     for _ in -21..=-42 {}\n    |              ^^^^^^^^^\n@@ -33,7 +33,7 @@ LL |     for _ in (-42..=-21).rev() {}\n    |              ^^^^^^^^^^^^^^^^^\n \n error: this range is empty so it will yield no values\n-  --> $DIR/reversed_empty_ranges_fixable.rs:15:14\n+  --> $DIR/reversed_empty_ranges_fixable.rs:13:14\n    |\n LL |     for _ in 42u32..21u32 {}\n    |              ^^^^^^^^^^^^\n@@ -43,11 +43,5 @@ help: consider using the following if you are attempting to iterate over this ra\n LL |     for _ in (21u32..42u32).rev() {}\n    |              ^^^^^^^^^^^^^^^^^^^^\n \n-error: this range is empty and using it to index a slice will always yield an empty slice\n-  --> $DIR/reversed_empty_ranges_fixable.rs:17:18\n-   |\n-LL |     let _ = &arr[3..3];\n-   |              ----^^^^- help: if you want an empty slice, use: `[] as &[i32]`\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "264d3d1e95af4d5062d396523c76bd1611b60c89", "filename": "src/tools/clippy/tests/ui/reversed_empty_ranges_unfixable.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_unfixable.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -4,11 +4,12 @@ const ANSWER: i32 = 42;\n const SOME_NUM: usize = 3;\n \n fn main() {\n-    let _ = (42 + 10..42 + 10).map(|x| x / 2).find(|&x| x == 21);\n-\n     let arr = [1, 2, 3, 4, 5];\n     let _ = &arr[3usize..=1usize];\n     let _ = &arr[SOME_NUM..1];\n \n     for _ in ANSWER..ANSWER {}\n+\n+    // Should not be linted, see issue #5689\n+    let _ = (42 + 10..42 + 10).map(|x| x / 2).find(|&x| x == 21);\n }"}, {"sha": "f23d4eb0f9ca4e12e68f31bb26f424be8c9b8859", "filename": "src/tools/clippy/tests/ui/reversed_empty_ranges_unfixable.stderr", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Freversed_empty_ranges_unfixable.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,28 +1,22 @@\n-error: this range is empty so it will yield no values\n-  --> $DIR/reversed_empty_ranges_unfixable.rs:7:13\n-   |\n-LL |     let _ = (42 + 10..42 + 10).map(|x| x / 2).find(|&x| x == 21);\n-   |             ^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::reversed-empty-ranges` implied by `-D warnings`\n-\n error: this range is reversed and using it to index a slice will panic at run-time\n-  --> $DIR/reversed_empty_ranges_unfixable.rs:10:18\n+  --> $DIR/reversed_empty_ranges_unfixable.rs:8:18\n    |\n LL |     let _ = &arr[3usize..=1usize];\n    |                  ^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::reversed-empty-ranges` implied by `-D warnings`\n \n error: this range is reversed and using it to index a slice will panic at run-time\n-  --> $DIR/reversed_empty_ranges_unfixable.rs:11:18\n+  --> $DIR/reversed_empty_ranges_unfixable.rs:9:18\n    |\n LL |     let _ = &arr[SOME_NUM..1];\n    |                  ^^^^^^^^^^^\n \n error: this range is empty so it will yield no values\n-  --> $DIR/reversed_empty_ranges_unfixable.rs:13:14\n+  --> $DIR/reversed_empty_ranges_unfixable.rs:11:14\n    |\n LL |     for _ in ANSWER..ANSWER {}\n    |              ^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "ccf8f61c4a92c7528944a3c1cf6066b9e1c969d3", "filename": "src/tools/clippy/tests/ui/string_lit_as_bytes.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.fixed?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -14,6 +14,8 @@ fn str_lit_as_bytes() {\n \n     let strify = stringify!(foobar).as_bytes();\n \n+    let current_version = env!(\"CARGO_PKG_VERSION\").as_bytes();\n+\n     let includestr = include_bytes!(\"entry_unfixable.rs\");\n \n     let _ = b\"string with newline\\t\\n\";"}, {"sha": "178df08e249ef3c2e20c9d1fc7e2267115b5fa85", "filename": "src/tools/clippy/tests/ui/string_lit_as_bytes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -14,6 +14,8 @@ fn str_lit_as_bytes() {\n \n     let strify = stringify!(foobar).as_bytes();\n \n+    let current_version = env!(\"CARGO_PKG_VERSION\").as_bytes();\n+\n     let includestr = include_str!(\"entry_unfixable.rs\").as_bytes();\n \n     let _ = \"string with newline\\t\\n\".as_bytes();"}, {"sha": "99c512354d589f722d47003325412ee1b6432bb1", "filename": "src/tools/clippy/tests/ui/string_lit_as_bytes.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstring_lit_as_bytes.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -13,13 +13,13 @@ LL |     let bs = r###\"raw string with 3# plus \" \"\"###.as_bytes();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using a byte string literal instead: `br###\"raw string with 3# plus \" \"\"###`\n \n error: calling `as_bytes()` on `include_str!(..)`\n-  --> $DIR/string_lit_as_bytes.rs:17:22\n+  --> $DIR/string_lit_as_bytes.rs:19:22\n    |\n LL |     let includestr = include_str!(\"entry_unfixable.rs\").as_bytes();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `include_bytes!(..)` instead: `include_bytes!(\"entry_unfixable.rs\")`\n \n error: calling `as_bytes()` on a string literal\n-  --> $DIR/string_lit_as_bytes.rs:19:13\n+  --> $DIR/string_lit_as_bytes.rs:21:13\n    |\n LL |     let _ = \"string with newline/t/n\".as_bytes();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using a byte string literal instead: `b\"string with newline/t/n\"`"}, {"sha": "a739cf7ad814eb8f399734e0acdc8db418244be7", "filename": "src/tools/clippy/tests/ui/unit_arg.fixed", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/feb3536eba10c2e4585d066629598f03d5ddc7c6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/feb3536eba10c2e4585d066629598f03d5ddc7c6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg.fixed?ref=feb3536eba10c2e4585d066629598f03d5ddc7c6", "patch": "@@ -1,64 +0,0 @@\n-// run-rustfix\n-#![warn(clippy::unit_arg)]\n-#![allow(unused_braces, clippy::no_effect, unused_must_use)]\n-\n-use std::fmt::Debug;\n-\n-fn foo<T: Debug>(t: T) {\n-    println!(\"{:?}\", t);\n-}\n-\n-fn foo3<T1: Debug, T2: Debug, T3: Debug>(t1: T1, t2: T2, t3: T3) {\n-    println!(\"{:?}, {:?}, {:?}\", t1, t2, t3);\n-}\n-\n-struct Bar;\n-\n-impl Bar {\n-    fn bar<T: Debug>(&self, t: T) {\n-        println!(\"{:?}\", t);\n-    }\n-}\n-\n-fn bad() {\n-    foo(());\n-    foo(());\n-    foo(());\n-    foo(());\n-    foo3((), 2, 2);\n-    let b = Bar;\n-    b.bar(());\n-}\n-\n-fn ok() {\n-    foo(());\n-    foo(1);\n-    foo({ 1 });\n-    foo3(\"a\", 3, vec![3]);\n-    let b = Bar;\n-    b.bar({ 1 });\n-    b.bar(());\n-    question_mark();\n-}\n-\n-fn question_mark() -> Result<(), ()> {\n-    Ok(Ok(())?)?;\n-    Ok(Ok(()))??;\n-    Ok(())\n-}\n-\n-#[allow(dead_code)]\n-mod issue_2945 {\n-    fn unit_fn() -> Result<(), i32> {\n-        Ok(())\n-    }\n-\n-    fn fallible() -> Result<(), i32> {\n-        Ok(unit_fn()?)\n-    }\n-}\n-\n-fn main() {\n-    bad();\n-    ok();\n-}"}, {"sha": "2992abae775b8ffb438f5ae4e645899698a1302e", "filename": "src/tools/clippy/tests/ui/unit_arg.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,6 +1,5 @@\n-// run-rustfix\n #![warn(clippy::unit_arg)]\n-#![allow(unused_braces, clippy::no_effect, unused_must_use)]\n+#![allow(clippy::no_effect, unused_must_use, unused_variables)]\n \n use std::fmt::Debug;\n \n@@ -21,7 +20,6 @@ impl Bar {\n }\n \n fn bad() {\n-    foo({});\n     foo({\n         1;\n     });\n@@ -30,11 +28,25 @@ fn bad() {\n         foo(1);\n         foo(2);\n     });\n-    foo3({}, 2, 2);\n     let b = Bar;\n     b.bar({\n         1;\n     });\n+    taking_multiple_units(foo(0), foo(1));\n+    taking_multiple_units(foo(0), {\n+        foo(1);\n+        foo(2);\n+    });\n+    taking_multiple_units(\n+        {\n+            foo(0);\n+            foo(1);\n+        },\n+        {\n+            foo(2);\n+            foo(3);\n+        },\n+    );\n }\n \n fn ok() {\n@@ -65,6 +77,13 @@ mod issue_2945 {\n     }\n }\n \n+#[allow(dead_code)]\n+fn returning_expr() -> Option<()> {\n+    Some(foo(1))\n+}\n+\n+fn taking_multiple_units(a: (), b: ()) {}\n+\n fn main() {\n     bad();\n     ok();"}, {"sha": "56f6a855dfa554d725aa29f6cb3ba12cf5d58175", "filename": "src/tools/clippy/tests/ui/unit_arg.stderr", "status": "modified", "additions": 140, "deletions": 38, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,79 +1,181 @@\n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:24:9\n+  --> $DIR/unit_arg.rs:23:5\n    |\n-LL |     foo({});\n-   |         ^^\n+LL | /     foo({\n+LL | |         1;\n+LL | |     });\n+   | |______^\n    |\n    = note: `-D clippy::unit-arg` implied by `-D warnings`\n-help: if you intended to pass a unit value, use a unit literal instead\n+help: remove the semicolon from the last statement in the block\n    |\n-LL |     foo(());\n-   |         ^^\n-\n-error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:25:9\n+LL |         1\n    |\n-LL |       foo({\n-   |  _________^\n-LL | |         1;\n-LL | |     });\n-   | |_____^\n+help: or move the expression in front of the call...\n    |\n-help: if you intended to pass a unit value, use a unit literal instead\n+LL |     {\n+LL |         1;\n+LL |     };\n+   |\n+help: ...and use a unit literal instead\n    |\n LL |     foo(());\n    |         ^^\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:28:9\n+  --> $DIR/unit_arg.rs:26:5\n    |\n LL |     foo(foo(1));\n-   |         ^^^^^^\n+   |     ^^^^^^^^^^^\n+   |\n+help: move the expression in front of the call...\n    |\n-help: if you intended to pass a unit value, use a unit literal instead\n+LL |     foo(1);\n+   |\n+help: ...and use a unit literal instead\n    |\n LL |     foo(());\n    |         ^^\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:29:9\n+  --> $DIR/unit_arg.rs:27:5\n    |\n-LL |       foo({\n-   |  _________^\n+LL | /     foo({\n LL | |         foo(1);\n LL | |         foo(2);\n LL | |     });\n-   | |_____^\n+   | |______^\n+   |\n+help: remove the semicolon from the last statement in the block\n+   |\n+LL |         foo(2)\n    |\n-help: if you intended to pass a unit value, use a unit literal instead\n+help: or move the expression in front of the call...\n+   |\n+LL |     {\n+LL |         foo(1);\n+LL |         foo(2);\n+LL |     };\n+   |\n+help: ...and use a unit literal instead\n    |\n LL |     foo(());\n    |         ^^\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:33:10\n+  --> $DIR/unit_arg.rs:32:5\n    |\n-LL |     foo3({}, 2, 2);\n-   |          ^^\n+LL | /     b.bar({\n+LL | |         1;\n+LL | |     });\n+   | |______^\n    |\n-help: if you intended to pass a unit value, use a unit literal instead\n+help: remove the semicolon from the last statement in the block\n    |\n-LL |     foo3((), 2, 2);\n-   |          ^^\n+LL |         1\n+   |\n+help: or move the expression in front of the call...\n+   |\n+LL |     {\n+LL |         1;\n+LL |     };\n+   |\n+help: ...and use a unit literal instead\n+   |\n+LL |     b.bar(());\n+   |           ^^\n \n-error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:35:11\n+error: passing unit values to a function\n+  --> $DIR/unit_arg.rs:35:5\n    |\n-LL |       b.bar({\n-   |  ___________^\n-LL | |         1;\n+LL |     taking_multiple_units(foo(0), foo(1));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: move the expressions in front of the call...\n+   |\n+LL |     foo(0);\n+LL |     foo(1);\n+   |\n+help: ...and use unit literals instead\n+   |\n+LL |     taking_multiple_units((), ());\n+   |                           ^^  ^^\n+\n+error: passing unit values to a function\n+  --> $DIR/unit_arg.rs:36:5\n+   |\n+LL | /     taking_multiple_units(foo(0), {\n+LL | |         foo(1);\n+LL | |         foo(2);\n LL | |     });\n+   | |______^\n+   |\n+help: remove the semicolon from the last statement in the block\n+   |\n+LL |         foo(2)\n+   |\n+help: or move the expressions in front of the call...\n+   |\n+LL |     foo(0);\n+LL |     {\n+LL |         foo(1);\n+LL |         foo(2);\n+LL |     };\n+   |\n+help: ...and use unit literals instead\n+   |\n+LL |     taking_multiple_units((), ());\n+   |                           ^^  ^^\n+\n+error: passing unit values to a function\n+  --> $DIR/unit_arg.rs:40:5\n+   |\n+LL | /     taking_multiple_units(\n+LL | |         {\n+LL | |             foo(0);\n+LL | |             foo(1);\n+...  |\n+LL | |         },\n+LL | |     );\n    | |_____^\n    |\n-help: if you intended to pass a unit value, use a unit literal instead\n+help: remove the semicolon from the last statement in the block\n    |\n-LL |     b.bar(());\n-   |           ^^\n+LL |             foo(1)\n+   |\n+help: remove the semicolon from the last statement in the block\n+   |\n+LL |             foo(3)\n+   |\n+help: or move the expressions in front of the call...\n+   |\n+LL |     {\n+LL |         foo(0);\n+LL |         foo(1);\n+LL |     };\n+LL |     {\n+LL |         foo(2);\n+ ...\n+help: ...and use unit literals instead\n+   |\n+LL |         (),\n+LL |         (),\n+   |\n+\n+error: passing a unit value to a function\n+  --> $DIR/unit_arg.rs:82:5\n+   |\n+LL |     Some(foo(1))\n+   |     ^^^^^^^^^^^^\n+   |\n+help: move the expression in front of the call...\n+   |\n+LL |     foo(1);\n+   |\n+help: ...and use a unit literal instead\n+   |\n+LL |     Some(())\n+   |          ^^\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "18a31eb3deee26f400f9266c8bb6741017826d15", "filename": "src/tools/clippy/tests/ui/unit_arg_empty_blocks.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg_empty_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg_empty_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg_empty_blocks.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,26 @@\n+#![warn(clippy::unit_arg)]\n+#![allow(clippy::no_effect, unused_must_use, unused_variables)]\n+\n+use std::fmt::Debug;\n+\n+fn foo<T: Debug>(t: T) {\n+    println!(\"{:?}\", t);\n+}\n+\n+fn foo3<T1: Debug, T2: Debug, T3: Debug>(t1: T1, t2: T2, t3: T3) {\n+    println!(\"{:?}, {:?}, {:?}\", t1, t2, t3);\n+}\n+\n+fn bad() {\n+    foo({});\n+    foo3({}, 2, 2);\n+    taking_two_units({}, foo(0));\n+    taking_three_units({}, foo(0), foo(1));\n+}\n+\n+fn taking_two_units(a: (), b: ()) {}\n+fn taking_three_units(a: (), b: (), c: ()) {}\n+\n+fn main() {\n+    bad();\n+}"}, {"sha": "bb58483584b3e9bf419df2506de17a6d52c3b0cd", "filename": "src/tools/clippy/tests/ui/unit_arg_empty_blocks.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg_empty_blocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg_empty_blocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funit_arg_empty_blocks.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,51 @@\n+error: passing a unit value to a function\n+  --> $DIR/unit_arg_empty_blocks.rs:15:5\n+   |\n+LL |     foo({});\n+   |     ^^^^--^\n+   |         |\n+   |         help: use a unit literal instead: `()`\n+   |\n+   = note: `-D clippy::unit-arg` implied by `-D warnings`\n+\n+error: passing a unit value to a function\n+  --> $DIR/unit_arg_empty_blocks.rs:16:5\n+   |\n+LL |     foo3({}, 2, 2);\n+   |     ^^^^^--^^^^^^^\n+   |          |\n+   |          help: use a unit literal instead: `()`\n+\n+error: passing unit values to a function\n+  --> $DIR/unit_arg_empty_blocks.rs:17:5\n+   |\n+LL |     taking_two_units({}, foo(0));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: move the expression in front of the call...\n+   |\n+LL |     foo(0);\n+   |\n+help: ...and use unit literals instead\n+   |\n+LL |     taking_two_units((), ());\n+   |                      ^^  ^^\n+\n+error: passing unit values to a function\n+  --> $DIR/unit_arg_empty_blocks.rs:18:5\n+   |\n+LL |     taking_three_units({}, foo(0), foo(1));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: move the expressions in front of the call...\n+   |\n+LL |     foo(0);\n+LL |     foo(1);\n+   |\n+help: ...and use unit literals instead\n+   |\n+LL |     taking_three_units((), (), ());\n+   |                        ^^  ^^  ^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "779fd57707ad4f517e9ec9e6b235c728f5996008", "filename": "src/tools/clippy/tests/ui/unnecessary_sort_by.fixed", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.fixed?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,26 @@\n+// run-rustfix\n+\n+use std::cmp::Reverse;\n+\n+fn id(x: isize) -> isize {\n+    x\n+}\n+\n+fn main() {\n+    let mut vec: Vec<isize> = vec![3, 6, 1, 2, 5];\n+    // Forward examples\n+    vec.sort();\n+    vec.sort_unstable();\n+    vec.sort_by_key(|&a| (a + 5).abs());\n+    vec.sort_unstable_by_key(|&a| id(-a));\n+    // Reverse examples\n+    vec.sort_by_key(|&b| Reverse(b));\n+    vec.sort_by_key(|&b| Reverse((b + 5).abs()));\n+    vec.sort_unstable_by_key(|&b| Reverse(id(-b)));\n+    // Negative examples (shouldn't be changed)\n+    let c = &7;\n+    vec.sort_by(|a, b| (b - a).cmp(&(a - b)));\n+    vec.sort_by(|_, b| b.cmp(&5));\n+    vec.sort_by(|_, b| b.cmp(c));\n+    vec.sort_unstable_by(|a, _| a.cmp(c));\n+}"}, {"sha": "0485a5630afef682c80e9729bbf2855c9d782b62", "filename": "src/tools/clippy/tests/ui/unnecessary_sort_by.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,26 @@\n+// run-rustfix\n+\n+use std::cmp::Reverse;\n+\n+fn id(x: isize) -> isize {\n+    x\n+}\n+\n+fn main() {\n+    let mut vec: Vec<isize> = vec![3, 6, 1, 2, 5];\n+    // Forward examples\n+    vec.sort_by(|a, b| a.cmp(b));\n+    vec.sort_unstable_by(|a, b| a.cmp(b));\n+    vec.sort_by(|a, b| (a + 5).abs().cmp(&(b + 5).abs()));\n+    vec.sort_unstable_by(|a, b| id(-a).cmp(&id(-b)));\n+    // Reverse examples\n+    vec.sort_by(|a, b| b.cmp(a));\n+    vec.sort_by(|a, b| (b + 5).abs().cmp(&(a + 5).abs()));\n+    vec.sort_unstable_by(|a, b| id(-b).cmp(&id(-a)));\n+    // Negative examples (shouldn't be changed)\n+    let c = &7;\n+    vec.sort_by(|a, b| (b - a).cmp(&(a - b)));\n+    vec.sort_by(|_, b| b.cmp(&5));\n+    vec.sort_by(|_, b| b.cmp(c));\n+    vec.sort_unstable_by(|a, _| a.cmp(c));\n+}"}, {"sha": "903b6e5099ce8b68c9aa1363a8b7999418ca52ee", "filename": "src/tools/clippy/tests/ui/unnecessary_sort_by.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,46 @@\n+error: use Vec::sort here instead\n+  --> $DIR/unnecessary_sort_by.rs:12:5\n+   |\n+LL |     vec.sort_by(|a, b| a.cmp(b));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort()`\n+   |\n+   = note: `-D clippy::unnecessary-sort-by` implied by `-D warnings`\n+\n+error: use Vec::sort here instead\n+  --> $DIR/unnecessary_sort_by.rs:13:5\n+   |\n+LL |     vec.sort_unstable_by(|a, b| a.cmp(b));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable()`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:14:5\n+   |\n+LL |     vec.sort_by(|a, b| (a + 5).abs().cmp(&(b + 5).abs()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&a| (a + 5).abs())`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:15:5\n+   |\n+LL |     vec.sort_unstable_by(|a, b| id(-a).cmp(&id(-b)));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|&a| id(-a))`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:17:5\n+   |\n+LL |     vec.sort_by(|a, b| b.cmp(a));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&b| Reverse(b))`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:18:5\n+   |\n+LL |     vec.sort_by(|a, b| (b + 5).abs().cmp(&(a + 5).abs()));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&b| Reverse((b + 5).abs()))`\n+\n+error: use Vec::sort_by_key here instead\n+  --> $DIR/unnecessary_sort_by.rs:19:5\n+   |\n+LL |     vec.sort_unstable_by(|a, b| id(-b).cmp(&id(-a)));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|&b| Reverse(id(-b)))`\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "b39e891094fd93fb12a53ea73018ed33745a9e8d", "filename": "src/tools/clippy/tests/ui/unnested_or_patterns.fixed", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns.fixed?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,33 @@\n+// run-rustfix\n+\n+#![feature(or_patterns)]\n+#![feature(box_patterns)]\n+#![warn(clippy::unnested_or_patterns)]\n+#![allow(clippy::cognitive_complexity, clippy::match_ref_pats)]\n+#![allow(unreachable_patterns, irrefutable_let_patterns, unused_variables)]\n+\n+fn main() {\n+    if let box (0 | 2) = Box::new(0) {}\n+    if let box (0 | 1 | 2 | 3 | 4) = Box::new(0) {}\n+    const C0: &u8 = &1;\n+    if let &(0 | 2) | C0 = &0 {}\n+    if let &mut (0 | 2) = &mut 0 {}\n+    if let x @ (0 | 2) = 0 {}\n+    if let (0, 1 | 2 | 3) = (0, 0) {}\n+    if let (1 | 2 | 3, 0) = (0, 0) {}\n+    if let (x, ..) | (x, 1 | 2) = (0, 1) {}\n+    if let [0 | 1] = [0] {}\n+    if let [x, 0 | 1] = [0, 1] {}\n+    if let [x, 0 | 1 | 2] = [0, 1] {}\n+    if let [x, ..] | [x, 1 | 2] = [0, 1] {}\n+    struct TS(u8, u8);\n+    if let TS(0 | 1, x) = TS(0, 0) {}\n+    if let TS(1 | 2 | 3, 0) = TS(0, 0) {}\n+    if let TS(x, ..) | TS(x, 1 | 2) = TS(0, 0) {}\n+    struct S {\n+        x: u8,\n+        y: u8,\n+    }\n+    if let S { x: 0 | 1, y } = (S { x: 0, y: 1 }) {}\n+    if let S { x: 0, y, .. } | S { y, x: 1 } = (S { x: 0, y: 1 }) {}\n+}"}, {"sha": "096f5a71150b88712d81ec2441c4964a0535e173", "filename": "src/tools/clippy/tests/ui/unnested_or_patterns.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,33 @@\n+// run-rustfix\n+\n+#![feature(or_patterns)]\n+#![feature(box_patterns)]\n+#![warn(clippy::unnested_or_patterns)]\n+#![allow(clippy::cognitive_complexity, clippy::match_ref_pats)]\n+#![allow(unreachable_patterns, irrefutable_let_patterns, unused_variables)]\n+\n+fn main() {\n+    if let box 0 | box 2 = Box::new(0) {}\n+    if let box ((0 | 1)) | box (2 | 3) | box 4 = Box::new(0) {}\n+    const C0: &u8 = &1;\n+    if let &0 | C0 | &2 = &0 {}\n+    if let &mut 0 | &mut 2 = &mut 0 {}\n+    if let x @ 0 | x @ 2 = 0 {}\n+    if let (0, 1) | (0, 2) | (0, 3) = (0, 0) {}\n+    if let (1, 0) | (2, 0) | (3, 0) = (0, 0) {}\n+    if let (x, ..) | (x, 1) | (x, 2) = (0, 1) {}\n+    if let [0] | [1] = [0] {}\n+    if let [x, 0] | [x, 1] = [0, 1] {}\n+    if let [x, 0] | [x, 1] | [x, 2] = [0, 1] {}\n+    if let [x, ..] | [x, 1] | [x, 2] = [0, 1] {}\n+    struct TS(u8, u8);\n+    if let TS(0, x) | TS(1, x) = TS(0, 0) {}\n+    if let TS(1, 0) | TS(2, 0) | TS(3, 0) = TS(0, 0) {}\n+    if let TS(x, ..) | TS(x, 1) | TS(x, 2) = TS(0, 0) {}\n+    struct S {\n+        x: u8,\n+        y: u8,\n+    }\n+    if let S { x: 0, y } | S { y, x: 1 } = (S { x: 0, y: 1 }) {}\n+    if let S { x: 0, y, .. } | S { y, x: 1 } = (S { x: 0, y: 1 }) {}\n+}"}, {"sha": "1899dc657dfee45931a7934e172dc952ce4c8745", "filename": "src/tools/clippy/tests/ui/unnested_or_patterns.stderr", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,179 @@\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:10:12\n+   |\n+LL |     if let box 0 | box 2 = Box::new(0) {}\n+   |            ^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::unnested-or-patterns` implied by `-D warnings`\n+help: nest the patterns\n+   |\n+LL |     if let box (0 | 2) = Box::new(0) {}\n+   |            ^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:11:12\n+   |\n+LL |     if let box ((0 | 1)) | box (2 | 3) | box 4 = Box::new(0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let box (0 | 1 | 2 | 3 | 4) = Box::new(0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:13:12\n+   |\n+LL |     if let &0 | C0 | &2 = &0 {}\n+   |            ^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let &(0 | 2) | C0 = &0 {}\n+   |            ^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:14:12\n+   |\n+LL |     if let &mut 0 | &mut 2 = &mut 0 {}\n+   |            ^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let &mut (0 | 2) = &mut 0 {}\n+   |            ^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:15:12\n+   |\n+LL |     if let x @ 0 | x @ 2 = 0 {}\n+   |            ^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let x @ (0 | 2) = 0 {}\n+   |            ^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:16:12\n+   |\n+LL |     if let (0, 1) | (0, 2) | (0, 3) = (0, 0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let (0, 1 | 2 | 3) = (0, 0) {}\n+   |            ^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:17:12\n+   |\n+LL |     if let (1, 0) | (2, 0) | (3, 0) = (0, 0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let (1 | 2 | 3, 0) = (0, 0) {}\n+   |            ^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:18:12\n+   |\n+LL |     if let (x, ..) | (x, 1) | (x, 2) = (0, 1) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let (x, ..) | (x, 1 | 2) = (0, 1) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:19:12\n+   |\n+LL |     if let [0] | [1] = [0] {}\n+   |            ^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let [0 | 1] = [0] {}\n+   |            ^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:20:12\n+   |\n+LL |     if let [x, 0] | [x, 1] = [0, 1] {}\n+   |            ^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let [x, 0 | 1] = [0, 1] {}\n+   |            ^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:21:12\n+   |\n+LL |     if let [x, 0] | [x, 1] | [x, 2] = [0, 1] {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let [x, 0 | 1 | 2] = [0, 1] {}\n+   |            ^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:22:12\n+   |\n+LL |     if let [x, ..] | [x, 1] | [x, 2] = [0, 1] {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let [x, ..] | [x, 1 | 2] = [0, 1] {}\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:24:12\n+   |\n+LL |     if let TS(0, x) | TS(1, x) = TS(0, 0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let TS(0 | 1, x) = TS(0, 0) {}\n+   |            ^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:25:12\n+   |\n+LL |     if let TS(1, 0) | TS(2, 0) | TS(3, 0) = TS(0, 0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let TS(1 | 2 | 3, 0) = TS(0, 0) {}\n+   |            ^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:26:12\n+   |\n+LL |     if let TS(x, ..) | TS(x, 1) | TS(x, 2) = TS(0, 0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let TS(x, ..) | TS(x, 1 | 2) = TS(0, 0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns.rs:31:12\n+   |\n+LL |     if let S { x: 0, y } | S { y, x: 1 } = (S { x: 0, y: 1 }) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let S { x: 0 | 1, y } = (S { x: 0, y: 1 }) {}\n+   |            ^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 16 previous errors\n+"}, {"sha": "02a129c55a3f56f69fa0326087bf0fb3760dcfaa", "filename": "src/tools/clippy/tests/ui/unnested_or_patterns2.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns2.fixed?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#![feature(or_patterns)]\n+#![feature(box_patterns)]\n+#![warn(clippy::unnested_or_patterns)]\n+#![allow(clippy::cognitive_complexity, clippy::match_ref_pats)]\n+#![allow(unreachable_patterns, irrefutable_let_patterns, unused_variables)]\n+\n+fn main() {\n+    if let Some(Some(0 | 1)) = None {}\n+    if let Some(Some(0 | 1 | 2)) = None {}\n+    if let Some(Some(0 | 1 | 2 | 3 | 4)) = None {}\n+    if let Some(Some(0 | 1 | 2)) = None {}\n+    if let ((0 | 1 | 2,),) = ((0,),) {}\n+    if let 0 | 1 | 2 = 0 {}\n+    if let box (0 | 1 | 2 | 3 | 4) = Box::new(0) {}\n+    if let box box (0 | 2 | 4) = Box::new(Box::new(0)) {}\n+}"}, {"sha": "acf3158989dcc3db5bf6275930cb37e2839b183c", "filename": "src/tools/clippy/tests/ui/unnested_or_patterns2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns2.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#![feature(or_patterns)]\n+#![feature(box_patterns)]\n+#![warn(clippy::unnested_or_patterns)]\n+#![allow(clippy::cognitive_complexity, clippy::match_ref_pats)]\n+#![allow(unreachable_patterns, irrefutable_let_patterns, unused_variables)]\n+\n+fn main() {\n+    if let Some(Some(0)) | Some(Some(1)) = None {}\n+    if let Some(Some(0)) | Some(Some(1) | Some(2)) = None {}\n+    if let Some(Some(0 | 1) | Some(2)) | Some(Some(3) | Some(4)) = None {}\n+    if let Some(Some(0) | Some(1 | 2)) = None {}\n+    if let ((0,),) | ((1,) | (2,),) = ((0,),) {}\n+    if let 0 | (1 | 2) = 0 {}\n+    if let box (0 | 1) | (box 2 | box (3 | 4)) = Box::new(0) {}\n+    if let box box 0 | box (box 2 | box 4) = Box::new(Box::new(0)) {}\n+}"}, {"sha": "1847fd8e098c714305bceb449df0300405b81bb5", "filename": "src/tools/clippy/tests/ui/unnested_or_patterns2.stderr", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns2.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,91 @@\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns2.rs:10:12\n+   |\n+LL |     if let Some(Some(0)) | Some(Some(1)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::unnested-or-patterns` implied by `-D warnings`\n+help: nest the patterns\n+   |\n+LL |     if let Some(Some(0 | 1)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns2.rs:11:12\n+   |\n+LL |     if let Some(Some(0)) | Some(Some(1) | Some(2)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let Some(Some(0 | 1 | 2)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns2.rs:12:12\n+   |\n+LL |     if let Some(Some(0 | 1) | Some(2)) | Some(Some(3) | Some(4)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let Some(Some(0 | 1 | 2 | 3 | 4)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns2.rs:13:12\n+   |\n+LL |     if let Some(Some(0) | Some(1 | 2)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let Some(Some(0 | 1 | 2)) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns2.rs:14:12\n+   |\n+LL |     if let ((0,),) | ((1,) | (2,),) = ((0,),) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let ((0 | 1 | 2,),) = ((0,),) {}\n+   |            ^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns2.rs:15:12\n+   |\n+LL |     if let 0 | (1 | 2) = 0 {}\n+   |            ^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let 0 | 1 | 2 = 0 {}\n+   |            ^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns2.rs:16:12\n+   |\n+LL |     if let box (0 | 1) | (box 2 | box (3 | 4)) = Box::new(0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let box (0 | 1 | 2 | 3 | 4) = Box::new(0) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unnested or-patterns\n+  --> $DIR/unnested_or_patterns2.rs:17:12\n+   |\n+LL |     if let box box 0 | box (box 2 | box 4) = Box::new(Box::new(0)) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: nest the patterns\n+   |\n+LL |     if let box box (0 | 2 | 4) = Box::new(Box::new(0)) {}\n+   |            ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "0263e2f5f20c113920111ee6b41e62f89a1944ed", "filename": "src/tools/clippy/tests/ui/vec_resize_to_zero.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_resize_to_zero.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,15 @@\n+#![warn(clippy::vec_resize_to_zero)]\n+\n+fn main() {\n+    // applicable here\n+    vec![1, 2, 3, 4, 5].resize(0, 5);\n+\n+    // not applicable\n+    vec![1, 2, 3, 4, 5].resize(2, 5);\n+\n+    // applicable here, but only implemented for integer litterals for now\n+    vec![\"foo\", \"bar\", \"baz\"].resize(0, \"bar\");\n+\n+    // not applicable\n+    vec![\"foo\", \"bar\", \"baz\"].resize(2, \"bar\")\n+}"}, {"sha": "feb846298c656878246193fd8968b2c67127b260", "filename": "src/tools/clippy/tests/ui/vec_resize_to_zero.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_resize_to_zero.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_resize_to_zero.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fvec_resize_to_zero.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -0,0 +1,13 @@\n+error: emptying a vector with `resize`\n+  --> $DIR/vec_resize_to_zero.rs:5:5\n+   |\n+LL |     vec![1, 2, 3, 4, 5].resize(0, 5);\n+   |     ^^^^^^^^^^^^^^^^^^^^------------\n+   |                         |\n+   |                         help: ...or you can empty the vector with: `clear()`\n+   |\n+   = note: `-D clippy::vec-resize-to-zero` implied by `-D warnings`\n+   = help: the arguments may be inverted...\n+\n+error: aborting due to previous error\n+"}, {"sha": "4f8754a930120ecb55e1675788fa9b6d042d2369", "filename": "src/tools/clippy/tests/ui/wildcard_enum_match_arm.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_enum_match_arm.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_enum_match_arm.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_enum_match_arm.fixed?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -6,7 +6,8 @@\n     unused_variables,\n     dead_code,\n     clippy::single_match,\n-    clippy::wildcard_in_or_patterns\n+    clippy::wildcard_in_or_patterns,\n+    clippy::unnested_or_patterns\n )]\n \n use std::io::ErrorKind;"}, {"sha": "5e66644ceca0ff202a14b221730e905e7bc8d1bb", "filename": "src/tools/clippy/tests/ui/wildcard_enum_match_arm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_enum_match_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_enum_match_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_enum_match_arm.rs?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -6,7 +6,8 @@\n     unused_variables,\n     dead_code,\n     clippy::single_match,\n-    clippy::wildcard_in_or_patterns\n+    clippy::wildcard_in_or_patterns,\n+    clippy::unnested_or_patterns\n )]\n \n use std::io::ErrorKind;"}, {"sha": "e03b3be43ed236ddc1bbe5e82234054f3f16263a", "filename": "src/tools/clippy/tests/ui/wildcard_enum_match_arm.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_enum_match_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/283522400b5c13dfdf2b7e608e63a70ee8e3d7af/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_enum_match_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fwildcard_enum_match_arm.stderr?ref=283522400b5c13dfdf2b7e608e63a70ee8e3d7af", "patch": "@@ -1,5 +1,5 @@\n error: wildcard match will miss any future added variants\n-  --> $DIR/wildcard_enum_match_arm.rs:37:9\n+  --> $DIR/wildcard_enum_match_arm.rs:38:9\n    |\n LL |         _ => eprintln!(\"Not red\"),\n    |         ^ help: try this: `Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan`\n@@ -11,25 +11,25 @@ LL | #![deny(clippy::wildcard_enum_match_arm)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: wildcard match will miss any future added variants\n-  --> $DIR/wildcard_enum_match_arm.rs:41:9\n+  --> $DIR/wildcard_enum_match_arm.rs:42:9\n    |\n LL |         _not_red => eprintln!(\"Not red\"),\n    |         ^^^^^^^^ help: try this: `_not_red @ Color::Green | _not_red @ Color::Blue | _not_red @ Color::Rgb(..) | _not_red @ Color::Cyan`\n \n error: wildcard match will miss any future added variants\n-  --> $DIR/wildcard_enum_match_arm.rs:45:9\n+  --> $DIR/wildcard_enum_match_arm.rs:46:9\n    |\n LL |         not_red => format!(\"{:?}\", not_red),\n    |         ^^^^^^^ help: try this: `not_red @ Color::Green | not_red @ Color::Blue | not_red @ Color::Rgb(..) | not_red @ Color::Cyan`\n \n error: wildcard match will miss any future added variants\n-  --> $DIR/wildcard_enum_match_arm.rs:61:9\n+  --> $DIR/wildcard_enum_match_arm.rs:62:9\n    |\n LL |         _ => \"No red\",\n    |         ^ help: try this: `Color::Red | Color::Green | Color::Blue | Color::Rgb(..) | Color::Cyan`\n \n error: match on non-exhaustive enum doesn't explicitly match all known variants\n-  --> $DIR/wildcard_enum_match_arm.rs:78:9\n+  --> $DIR/wildcard_enum_match_arm.rs:79:9\n    |\n LL |         _ => {},\n    |         ^ help: try this: `std::io::ErrorKind::PermissionDenied | std::io::ErrorKind::ConnectionRefused | std::io::ErrorKind::ConnectionReset | std::io::ErrorKind::ConnectionAborted | std::io::ErrorKind::NotConnected | std::io::ErrorKind::AddrInUse | std::io::ErrorKind::AddrNotAvailable | std::io::ErrorKind::BrokenPipe | std::io::ErrorKind::AlreadyExists | std::io::ErrorKind::WouldBlock | std::io::ErrorKind::InvalidInput | std::io::ErrorKind::InvalidData | std::io::ErrorKind::TimedOut | std::io::ErrorKind::WriteZero | std::io::ErrorKind::Interrupted | std::io::ErrorKind::Other | std::io::ErrorKind::UnexpectedEof | _`"}]}