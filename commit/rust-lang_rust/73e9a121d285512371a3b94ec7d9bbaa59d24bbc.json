{"sha": "73e9a121d285512371a3b94ec7d9bbaa59d24bbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZTlhMTIxZDI4NTUxMjM3MWEzYjk0ZWM3ZDliYmFhNTlkMjRiYmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-21T18:22:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-21T18:22:38Z"}, "message": "auto merge of #7921 : bytewiseand/rust/smallint-iter, r=huonw\n\nMade the `iter` and `mut_iter` methods on SmallIntMap and SmallIntSet return double-ended-iterators. These iterators now implement `size_hint`.\r\n\r\nAlso the iterator tests only tested dense maps/sets, which aren't very useful. So they were changed to iterate over sparse maps/sets.\r\n\r\nFixes #7721", "tree": {"sha": "1d989ba6b6c615909eb53dbbb2af3fa84a4d92dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d989ba6b6c615909eb53dbbb2af3fa84a4d92dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73e9a121d285512371a3b94ec7d9bbaa59d24bbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73e9a121d285512371a3b94ec7d9bbaa59d24bbc", "html_url": "https://github.com/rust-lang/rust/commit/73e9a121d285512371a3b94ec7d9bbaa59d24bbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73e9a121d285512371a3b94ec7d9bbaa59d24bbc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4b6216943eebbf17e6ea5641a0f32976633c4f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4b6216943eebbf17e6ea5641a0f32976633c4f2", "html_url": "https://github.com/rust-lang/rust/commit/c4b6216943eebbf17e6ea5641a0f32976633c4f2"}, {"sha": "51649b763e9115db8c95eaf1c0a3ba55c147ad9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/51649b763e9115db8c95eaf1c0a3ba55c147ad9d", "html_url": "https://github.com/rust-lang/rust/commit/51649b763e9115db8c95eaf1c0a3ba55c147ad9d"}], "stats": {"total": 316, "additions": 177, "deletions": 139}, "files": [{"sha": "47d7fca4076b26ad010f6decb26a36f90e09d8f1", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 177, "deletions": 139, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/73e9a121d285512371a3b94ec7d9bbaa59d24bbc/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73e9a121d285512371a3b94ec7d9bbaa59d24bbc/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=73e9a121d285512371a3b94ec7d9bbaa59d24bbc", "patch": "@@ -17,11 +17,10 @@\n \n \n use std::cmp;\n-use std::iterator::{Iterator,IteratorUtil,ZipIterator,Counter,EnumerateIterator,FilterMapIterator};\n+use std::iterator::{Iterator, IteratorUtil, EnumerateIterator, FilterMapIterator, InvertIterator};\n use std::uint;\n use std::util::replace;\n-use std::vec::{VecIterator,VecMutIterator,VecRevIterator,VecMutRevIterator};\n-use std::vec::VecConsumeIterator;\n+use std::vec::{VecIterator, VecMutIterator, VecConsumeIterator};\n \n #[allow(missing_doc)]\n pub struct SmallIntMap<T> {\n@@ -177,7 +176,9 @@ impl<V> SmallIntMap<V> {\n     /// Iterator element type is (uint, &'r V)\n     pub fn iter<'r>(&'r self) -> SmallIntMapIterator<'r, V> {\n         SmallIntMapIterator {\n-            iter: Counter::new(0,1).zip(self.v.iter())\n+            front: 0,\n+            back: self.v.len(),\n+            iter: self.v.iter()\n         }\n     }\n \n@@ -186,25 +187,23 @@ impl<V> SmallIntMap<V> {\n     /// Iterator element type is (uint, &'r mut V)\n     pub fn mut_iter<'r>(&'r mut self) -> SmallIntMapMutIterator<'r, V> {\n         SmallIntMapMutIterator {\n-            iter: Counter::new(0,1).zip(self.v.mut_iter())\n+            front: 0,\n+            back: self.v.len(),\n+            iter: self.v.mut_iter()\n         }\n     }\n \n     /// An iterator visiting all key-value pairs in descending order by the keys.\n     /// Iterator element type is (uint, &'r V)\n     pub fn rev_iter<'r>(&'r self) -> SmallIntMapRevIterator<'r, V> {\n-        SmallIntMapRevIterator {\n-            iter: Counter::new(self.len() as int - 1, -1).zip(self.v.rev_iter())\n-        }\n+        self.iter().invert()\n     }\n \n     /// An iterator visiting all key-value pairs in descending order by the keys,\n     /// with mutable references to the values\n     /// Iterator element type is (uint, &'r mut V)\n     pub fn mut_rev_iter<'r>(&'r mut self) -> SmallIntMapMutRevIterator <'r, V> {\n-        SmallIntMapMutRevIterator {\n-            iter: Counter::new(self.len() as int - 1, -1).zip(self.v.mut_rev_iter())\n-        }\n+        self.mut_iter().invert()\n     }\n \n     /// Empties the hash map, moving all values into the specified closure\n@@ -237,92 +236,79 @@ impl<V:Clone> SmallIntMap<V> {\n \n \n macro_rules! iterator {\n-    /* FIXME: #4375 Cannot attach documentation/attributes to a macro generated struct.\n-    (struct $name:ident -> $ptr:ty, $elem:ty) => {\n-        pub struct $name<'self, T> {\n-            priv ptr: $ptr,\n-            priv end: $ptr,\n-            priv lifetime: $elem // FIXME: #5922\n-        }\n-    };*/\n-    (impl $name:ident -> $elem:ty) => {\n-        impl<'self, T> Iterator<(uint, $elem)> for $name<'self, T> {\n+    (impl $name:ident -> $elem:ty, $getter:ident) => {\n+        impl<'self, T> Iterator<$elem> for $name<'self, T> {\n             #[inline]\n-            pub fn next(&mut self) -> Option<(uint, $elem)> {\n-                for self.iter.advance |(idx, elem)| {\n-                    match elem {\n-                        &None => {}\n-                        &Some(ref e) => { return Some((idx as uint, e)) }\n+            fn next(&mut self) -> Option<$elem> {\n+                while self.front < self.back {\n+                    match self.iter.next() {\n+                        Some(elem) => {\n+                            if elem.is_some() {\n+                                let index = self.front;\n+                                self.front += 1;\n+                                return Some((index, elem. $getter ()));\n+                            }\n+                        }\n+                        _ => ()\n                     }\n+                    self.front += 1;\n                 }\n-\n                 None\n             }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                (0, Some(self.back - self.front))\n+            }\n         }\n     }\n }\n \n-macro_rules! mut_iterator {\n-    /* FIXME: #4375 Cannot attach documentation/attributes to a macro generated struct.\n-    (struct $name:ident -> $ptr:ty, $elem:ty) => {\n-        pub struct $name<'self, T> {\n-            priv ptr: $ptr,\n-            priv end: $ptr,\n-            priv lifetime: $elem // FIXME: #5922\n-        }\n-    };*/\n-    (impl $name:ident -> $elem:ty) => {\n-        impl<'self, T> Iterator<(uint, $elem)> for $name<'self, T> {\n+macro_rules! double_ended_iterator {\n+    (impl $name:ident -> $elem:ty, $getter:ident) => {\n+        impl<'self, T> DoubleEndedIterator<$elem> for $name<'self, T> {\n             #[inline]\n-            pub fn next(&mut self) -> Option<(uint, $elem)> {\n-                for self.iter.advance |(idx, elem)| {\n-                    match elem {\n-                        &None => {}\n-                        &Some(ref mut e) => { return Some((idx as uint, e)) }\n+            fn next_back(&mut self) -> Option<$elem> {\n+                while self.front < self.back {\n+                    match self.iter.next_back() {\n+                        Some(elem) => {\n+                            if elem.is_some() {\n+                                self.back -= 1;\n+                                return Some((self.back, elem. $getter ()));\n+                            }\n+                        }\n+                        _ => ()\n                     }\n+                    self.back -= 1;\n                 }\n-\n                 None\n             }\n         }\n     }\n }\n \n pub struct SmallIntMapIterator<'self, T> {\n-    priv iter: ZipIterator<int,\n-                           Counter<int>,\n-                           &'self Option<T>,\n-                           VecIterator<'self, Option<T> > >\n+    priv front: uint,\n+    priv back: uint,\n+    priv iter: VecIterator<'self, Option<T>>\n }\n \n-iterator!{impl SmallIntMapIterator -> &'self T}\n+iterator!(impl SmallIntMapIterator -> (uint, &'self T), get_ref)\n+double_ended_iterator!(impl SmallIntMapIterator -> (uint, &'self T), get_ref)\n+pub type SmallIntMapRevIterator<'self, T> = InvertIterator<(uint, &'self T),\n+                                                           SmallIntMapIterator<'self, T>>;\n \n pub struct SmallIntMapMutIterator<'self, T> {\n-    priv iter: ZipIterator<int,\n-                           Counter<int>,\n-                           &'self mut Option<T>,\n-                           VecMutIterator<'self, Option<T> > >\n+    priv front: uint,\n+    priv back: uint,\n+    priv iter: VecMutIterator<'self, Option<T>>\n }\n \n-mut_iterator!{impl SmallIntMapMutIterator -> &'self mut T}\n-\n-pub struct SmallIntMapRevIterator<'self, T> {\n-    priv iter: ZipIterator<int,\n-                           Counter<int>,\n-                           &'self Option<T>,\n-                           VecRevIterator<'self, Option<T> > >\n-}\n-\n-iterator!{impl SmallIntMapRevIterator -> &'self T}\n-\n-pub struct SmallIntMapMutRevIterator<'self, T> {\n-    priv iter: ZipIterator<int,\n-                           Counter<int>,\n-                           &'self mut Option<T>,\n-                           VecMutRevIterator<'self, Option<T> > >\n-}\n+iterator!(impl SmallIntMapMutIterator -> (uint, &'self mut T), get_mut_ref)\n+double_ended_iterator!(impl SmallIntMapMutIterator -> (uint, &'self mut T), get_mut_ref)\n+pub type SmallIntMapMutRevIterator<'self, T> = InvertIterator<(uint, &'self mut T),\n+                                                              SmallIntMapMutIterator<'self, T>>;\n \n-mut_iterator!{impl SmallIntMapMutRevIterator -> &'self mut T}\n \n /// A set implemented on top of the SmallIntMap type. This set is always a set\n /// of integers, and the space requirements are on the order of the highest\n@@ -433,9 +419,7 @@ impl SmallIntSet {\n     /// An iterator visiting all set members in descending order.\n     /// Iterator element type is uint\n     pub fn rev_iter<'r>(&'r mut self) -> SmallIntSetRevIterator<'r> {\n-        SmallIntSetRevIterator {\n-            iter: self.map.rev_iter()\n-        }\n+        self.iter().invert()\n     }\n \n }\n@@ -444,36 +428,38 @@ pub struct SmallIntSetIterator<'self> {\n     priv iter: SmallIntMapIterator<'self, ()>\n }\n \n-pub struct SmallIntSetRevIterator<'self> {\n-    priv iter: SmallIntMapRevIterator<'self,()>\n-}\n-\n impl<'self> Iterator<uint> for SmallIntSetIterator<'self> {\n     #[inline]\n-    pub fn next(&mut self) -> Option<uint> {\n+    fn next(&mut self) -> Option<uint> {\n         let next_opt = self.iter.next();\n         match next_opt {\n             None => { None }\n             Some((idx, _)) => { Some(idx) }\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        self.iter.size_hint()\n+    }\n }\n \n-impl<'self> Iterator<uint> for SmallIntSetRevIterator<'self> {\n+impl<'self> DoubleEndedIterator<uint> for SmallIntSetIterator<'self> {\n     #[inline]\n-    pub fn next(&mut self) -> Option<uint> {\n-        let next_opt = self.iter.next();\n+    fn next_back(&mut self) -> Option<uint> {\n+        let next_opt = self.iter.next_back();\n         match next_opt {\n             None => { None }\n             Some((idx, _)) => { Some(idx) }\n         }\n     }\n }\n \n+pub type SmallIntSetRevIterator<'self> = InvertIterator<uint, SmallIntSetIterator<'self>>;\n \n \n #[cfg(test)]\n-mod tests {\n+mod test_map {\n \n     use super::SmallIntMap;\n \n@@ -567,78 +553,108 @@ mod tests {\n \n     #[test]\n     fn test_iterator() {\n-        let mut a = SmallIntMap::new();\n+        let mut m = SmallIntMap::new();\n \n-        assert!(a.insert(0,1));\n-        assert!(a.insert(1,2));\n-        assert!(a.insert(2,5));\n-        assert!(a.insert(3,10));\n-        assert!(a.insert(4,11));\n+        assert!(m.insert(0, 1));\n+        assert!(m.insert(1, 2));\n+        assert!(m.insert(3, 5));\n+        assert!(m.insert(6, 10));\n+        assert!(m.insert(10, 11));\n \n-        let mut it = a.iter();\n+        let mut it = m.iter();\n+        assert_eq!(it.size_hint(), (0, Some(11)));\n         assert_eq!(it.next().unwrap(), (0, &1));\n+        assert_eq!(it.size_hint(), (0, Some(10)));\n         assert_eq!(it.next().unwrap(), (1, &2));\n-        assert_eq!(it.next().unwrap(), (2, &5));\n-        assert_eq!(it.next().unwrap(), (3, &10));\n-        assert_eq!(it.next().unwrap(), (4, &11));\n+        assert_eq!(it.size_hint(), (0, Some(9)));\n+        assert_eq!(it.next().unwrap(), (3, &5));\n+        assert_eq!(it.size_hint(), (0, Some(7)));\n+        assert_eq!(it.next().unwrap(), (6, &10));\n+        assert_eq!(it.size_hint(), (0, Some(4)));\n+        assert_eq!(it.next().unwrap(), (10, &11));\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n         assert!(it.next().is_none());\n     }\n \n+    #[test]\n+    fn test_iterator_size_hints() {\n+        let mut m = SmallIntMap::new();\n+\n+        assert!(m.insert(0, 1));\n+        assert!(m.insert(1, 2));\n+        assert!(m.insert(3, 5));\n+        assert!(m.insert(6, 10));\n+        assert!(m.insert(10, 11));\n+\n+        assert_eq!(m.iter().size_hint(), (0, Some(11)));\n+        assert_eq!(m.rev_iter().size_hint(), (0, Some(11)));\n+        assert_eq!(m.mut_iter().size_hint(), (0, Some(11)));\n+        assert_eq!(m.mut_rev_iter().size_hint(), (0, Some(11)));\n+    }\n+\n     #[test]\n     fn test_mut_iterator() {\n-        let mut a = SmallIntMap::new();\n+        let mut m = SmallIntMap::new();\n \n-        assert!(a.insert(0,1));\n-        assert!(a.insert(1,1));\n-        assert!(a.insert(2,1));\n-        assert!(a.insert(3,1));\n-        assert!(a.insert(4,1));\n+        assert!(m.insert(0, 1));\n+        assert!(m.insert(1, 2));\n+        assert!(m.insert(3, 5));\n+        assert!(m.insert(6, 10));\n+        assert!(m.insert(10, 11));\n \n-        for a.mut_iter().advance |(_,v)| {\n-            *v += 1;\n+        for m.mut_iter().advance |(k, v)| {\n+            *v += k as int;\n         }\n \n-       assert!(a.iter().all(|(_,v)| *v == 2));\n+        let mut it = m.iter();\n+        assert_eq!(it.next().unwrap(), (0, &1));\n+        assert_eq!(it.next().unwrap(), (1, &3));\n+        assert_eq!(it.next().unwrap(), (3, &8));\n+        assert_eq!(it.next().unwrap(), (6, &16));\n+        assert_eq!(it.next().unwrap(), (10, &21));\n+        assert!(it.next().is_none());\n     }\n \n     #[test]\n     fn test_rev_iterator() {\n-       let mut a = SmallIntMap::new();\n-\n-        assert!(a.insert(0,1));\n-        assert!(a.insert(1,2));\n-        assert!(a.insert(2,5));\n-        assert!(a.insert(3,10));\n-        assert!(a.insert(4,11));\n-\n-        let mut b = SmallIntMap::new();\n-\n-        assert!(b.insert(0,11));\n-        assert!(b.insert(1,10));\n-        assert!(b.insert(2,5));\n-        assert!(b.insert(3,2));\n-        assert!(b.insert(4,1));\n+        let mut m = SmallIntMap::new();\n \n-        let (a_it, b_it) = (a.iter(), b.rev_iter());\n+        assert!(m.insert(0, 1));\n+        assert!(m.insert(1, 2));\n+        assert!(m.insert(3, 5));\n+        assert!(m.insert(6, 10));\n+        assert!(m.insert(10, 11));\n \n-        assert!(a_it.zip(b_it).all(|( (_ ,v1), (_, v2) )| *v1 == *v2));\n+        let mut it = m.rev_iter();\n+        assert_eq!(it.next().unwrap(), (10, &11));\n+        assert_eq!(it.next().unwrap(), (6, &10));\n+        assert_eq!(it.next().unwrap(), (3, &5));\n+        assert_eq!(it.next().unwrap(), (1, &2));\n+        assert_eq!(it.next().unwrap(), (0, &1));\n+        assert!(it.next().is_none());\n     }\n \n     #[test]\n     fn test_mut_rev_iterator() {\n-        let mut a = SmallIntMap::new();\n+        let mut m = SmallIntMap::new();\n \n-        assert!(a.insert(0,5));\n-        assert!(a.insert(1,4));\n-        assert!(a.insert(2,3));\n-        assert!(a.insert(3,2));\n-        assert!(a.insert(4,1));\n+        assert!(m.insert(0, 1));\n+        assert!(m.insert(1, 2));\n+        assert!(m.insert(3, 5));\n+        assert!(m.insert(6, 10));\n+        assert!(m.insert(10, 11));\n \n-        for a.mut_rev_iter().advance |(i,v)| {\n-            *v += i as int;\n+        for m.mut_rev_iter().advance |(k, v)| {\n+            *v += k as int;\n         }\n \n-        assert!(a.iter().all(|(_,v)| *v == 5 ));\n+        let mut it = m.iter();\n+        assert_eq!(it.next().unwrap(), (0, &1));\n+        assert_eq!(it.next().unwrap(), (1, &3));\n+        assert_eq!(it.next().unwrap(), (3, &8));\n+        assert_eq!(it.next().unwrap(), (6, &16));\n+        assert_eq!(it.next().unwrap(), (10, &21));\n+        assert!(it.next().is_none());\n     }\n \n     #[test]\n@@ -882,33 +898,55 @@ mod test_set {\n \n         assert!(a.insert(0));\n         assert!(a.insert(1));\n-        assert!(a.insert(2));\n         assert!(a.insert(3));\n-        assert!(a.insert(4));\n+        assert!(a.insert(6));\n+        assert!(a.insert(10));\n \n         let mut it = a.iter();\n+        assert_eq!(it.size_hint(), (0, Some(11)));\n         assert_eq!(it.next().unwrap(), 0);\n+        assert_eq!(it.size_hint(), (0, Some(10)));\n         assert_eq!(it.next().unwrap(), 1);\n-        assert_eq!(it.next().unwrap(), 2);\n+        assert_eq!(it.size_hint(), (0, Some(9)));\n         assert_eq!(it.next().unwrap(), 3);\n-        assert_eq!(it.next().unwrap(), 4);\n+        assert_eq!(it.size_hint(), (0, Some(7)));\n+        assert_eq!(it.next().unwrap(), 6);\n+        assert_eq!(it.size_hint(), (0, Some(4)));\n+        assert_eq!(it.next().unwrap(), 10);\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n         assert!(it.next().is_none());\n     }\n \n+    #[test]\n+    fn test_iterator_size_hints() {\n+        let mut a = SmallIntSet::new();\n+\n+        assert!(a.insert(0));\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(6));\n+        assert!(a.insert(10));\n+\n+        assert_eq!(a.iter().size_hint(), (0, Some(11)));\n+        assert_eq!(a.rev_iter().size_hint(), (0, Some(11)));\n+    }\n+\n     #[test]\n     fn test_rev_iterator() {\n        let mut a = SmallIntSet::new();\n \n         assert!(a.insert(0));\n         assert!(a.insert(1));\n-        assert!(a.insert(2));\n         assert!(a.insert(3));\n-        assert!(a.insert(4));\n+        assert!(a.insert(6));\n+        assert!(a.insert(10));\n \n-        let a_it = a.rev_iter();\n-\n-        assert!(do a_it.enumerate().all |( i, v2 )| {\n-            i + v2 == 4\n-        });\n+        let mut it = a.rev_iter();\n+        assert_eq!(it.next().unwrap(), 10);\n+        assert_eq!(it.next().unwrap(), 6);\n+        assert_eq!(it.next().unwrap(), 3);\n+        assert_eq!(it.next().unwrap(), 1);\n+        assert_eq!(it.next().unwrap(), 0);\n+        assert!(it.next().is_none());\n     }\n }"}]}