{"sha": "e09e6df787df074becd7b1b5b1138f517dd788d5", "node_id": "C_kwDOAAsO6NoAKGUwOWU2ZGY3ODdkZjA3NGJlY2Q3YjFiNWIxMTM4ZjUxN2RkNzg4ZDU", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-10-29T04:54:09Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-01-21T07:11:39Z"}, "message": "rustdoc: compute maximum Levenshtein distance based on the query\n\nThe heuristic is pretty close to the name resolver.\n\nFixes #103357", "tree": {"sha": "6844ba62fb6cc2d9edcb468ac5d9bffe1ba7660a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6844ba62fb6cc2d9edcb468ac5d9bffe1ba7660a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e09e6df787df074becd7b1b5b1138f517dd788d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e09e6df787df074becd7b1b5b1138f517dd788d5", "html_url": "https://github.com/rust-lang/rust/commit/e09e6df787df074becd7b1b5b1138f517dd788d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e09e6df787df074becd7b1b5b1138f517dd788d5/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ce39f42bd2c8bca9c570f0560ebe1fce4eddb14", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ce39f42bd2c8bca9c570f0560ebe1fce4eddb14", "html_url": "https://github.com/rust-lang/rust/commit/5ce39f42bd2c8bca9c570f0560ebe1fce4eddb14"}], "stats": {"total": 154, "additions": 84, "deletions": 70}, "files": [{"sha": "251e806c2d90d086c5bec0a25ba4769ec3a7ba46", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 84, "deletions": 65, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/e09e6df787df074becd7b1b5b1138f517dd788d5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/e09e6df787df074becd7b1b5b1138f517dd788d5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=e09e6df787df074becd7b1b5b1138f517dd788d5", "patch": "@@ -112,7 +112,6 @@ function levenshtein(s1, s2) {\n }\n \n function initSearch(rawSearchIndex) {\n-    const MAX_LEV_DISTANCE = 3;\n     const MAX_RESULTS = 200;\n     const NO_TYPE_FILTER = -1;\n     /**\n@@ -897,13 +896,13 @@ function initSearch(rawSearchIndex) {\n          * @param {QueryElement} elem  - The element from the parsed query.\n          * @param {integer} defaultLev - This is the value to return in case there are no generics.\n          *\n-         * @return {integer}           - Returns the best match (if any) or `MAX_LEV_DISTANCE + 1`.\n+         * @return {integer}           - Returns the best match (if any) or `maxLevDistance + 1`.\n          */\n-        function checkGenerics(row, elem, defaultLev) {\n+        function checkGenerics(row, elem, defaultLev, maxLevDistance) {\n             if (row.generics.length === 0) {\n-                return elem.generics.length === 0 ? defaultLev : MAX_LEV_DISTANCE + 1;\n+                return elem.generics.length === 0 ? defaultLev : maxLevDistance + 1;\n             } else if (row.generics.length > 0 && row.generics[0].name === null) {\n-                return checkGenerics(row.generics[0], elem, defaultLev);\n+                return checkGenerics(row.generics[0], elem, defaultLev, maxLevDistance);\n             }\n             // The names match, but we need to be sure that all generics kinda\n             // match as well.\n@@ -914,8 +913,8 @@ function initSearch(rawSearchIndex) {\n                     elem_name = entry.name;\n                     if (elem_name === \"\") {\n                         // Pure generic, needs to check into it.\n-                        if (checkGenerics(entry, elem, MAX_LEV_DISTANCE + 1) !== 0) {\n-                            return MAX_LEV_DISTANCE + 1;\n+                        if (checkGenerics(entry, elem, maxLevDistance + 1, maxLevDistance) !== 0) {\n+                            return maxLevDistance + 1;\n                         }\n                         continue;\n                     }\n@@ -942,7 +941,7 @@ function initSearch(rawSearchIndex) {\n                         }\n                     }\n                     if (match === null) {\n-                        return MAX_LEV_DISTANCE + 1;\n+                        return maxLevDistance + 1;\n                     }\n                     elems[match] -= 1;\n                     if (elems[match] === 0) {\n@@ -951,7 +950,7 @@ function initSearch(rawSearchIndex) {\n                 }\n                 return 0;\n             }\n-            return MAX_LEV_DISTANCE + 1;\n+            return maxLevDistance + 1;\n         }\n \n         /**\n@@ -963,10 +962,10 @@ function initSearch(rawSearchIndex) {\n           *\n           * @return {integer} - Returns a Levenshtein distance to the best match.\n           */\n-        function checkIfInGenerics(row, elem) {\n-            let lev = MAX_LEV_DISTANCE + 1;\n+        function checkIfInGenerics(row, elem, maxLevDistance) {\n+            let lev = maxLevDistance + 1;\n             for (const entry of row.generics) {\n-                lev = Math.min(checkType(entry, elem, true), lev);\n+                lev = Math.min(checkType(entry, elem, true, maxLevDistance), lev);\n                 if (lev === 0) {\n                     break;\n                 }\n@@ -983,15 +982,15 @@ function initSearch(rawSearchIndex) {\n           * @param {boolean} literalSearch\n           *\n           * @return {integer} - Returns a Levenshtein distance to the best match. If there is\n-          *                     no match, returns `MAX_LEV_DISTANCE + 1`.\n+          *                     no match, returns `maxLevDistance + 1`.\n           */\n-        function checkType(row, elem, literalSearch) {\n+        function checkType(row, elem, literalSearch, maxLevDistance) {\n             if (row.name === null) {\n                 // This is a pure \"generic\" search, no need to run other checks.\n                 if (row.generics.length > 0) {\n-                    return checkIfInGenerics(row, elem);\n+                    return checkIfInGenerics(row, elem, maxLevDistance);\n                 }\n-                return MAX_LEV_DISTANCE + 1;\n+                return maxLevDistance + 1;\n             }\n \n             let lev = levenshtein(row.name, elem.name);\n@@ -1005,9 +1004,9 @@ function initSearch(rawSearchIndex) {\n                             return 0;\n                         }\n                     }\n-                    return MAX_LEV_DISTANCE + 1;\n+                    return maxLevDistance + 1;\n                 } else if (elem.generics.length > 0) {\n-                    return checkGenerics(row, elem, MAX_LEV_DISTANCE + 1);\n+                    return checkGenerics(row, elem, maxLevDistance + 1, maxLevDistance);\n                 }\n                 return 0;\n             } else if (row.generics.length > 0) {\n@@ -1017,30 +1016,28 @@ function initSearch(rawSearchIndex) {\n                     }\n                     // The name didn't match so we now check if the type we're looking for is inside\n                     // the generics!\n-                    lev = checkIfInGenerics(row, elem);\n-                    // Now whatever happens, the returned distance is \"less good\" so we should mark\n-                    // it as such, and so we add 0.5 to the distance to make it \"less good\".\n-                    return lev + 0.5;\n-                } else if (lev > MAX_LEV_DISTANCE) {\n+                    lev = Math.min(lev, checkIfInGenerics(row, elem, maxLevDistance));\n+                    return lev;\n+                } else if (lev > maxLevDistance) {\n                     // So our item's name doesn't match at all and has generics.\n                     //\n                     // Maybe it's present in a sub generic? For example \"f<A<B<C>>>()\", if we're\n                     // looking for \"B<C>\", we'll need to go down.\n-                    return checkIfInGenerics(row, elem);\n+                    return checkIfInGenerics(row, elem, maxLevDistance);\n                 } else {\n                     // At this point, the name kinda match and we have generics to check, so\n                     // let's go!\n-                    const tmp_lev = checkGenerics(row, elem, lev);\n-                    if (tmp_lev > MAX_LEV_DISTANCE) {\n-                        return MAX_LEV_DISTANCE + 1;\n+                    const tmp_lev = checkGenerics(row, elem, lev, maxLevDistance);\n+                    if (tmp_lev > maxLevDistance) {\n+                        return maxLevDistance + 1;\n                     }\n                     // We compute the median value of both checks and return it.\n                     return (tmp_lev + lev) / 2;\n                 }\n             } else if (elem.generics.length > 0) {\n                 // In this case, we were expecting generics but there isn't so we simply reject this\n                 // one.\n-                return MAX_LEV_DISTANCE + 1;\n+                return maxLevDistance + 1;\n             }\n             // No generics on our query or on the target type so we can return without doing\n             // anything else.\n@@ -1055,23 +1052,26 @@ function initSearch(rawSearchIndex) {\n          * @param {integer} typeFilter\n          *\n          * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n-         *                      match, returns `MAX_LEV_DISTANCE + 1`.\n+         *                      match, returns `maxLevDistance + 1`.\n          */\n-        function findArg(row, elem, typeFilter) {\n-            let lev = MAX_LEV_DISTANCE + 1;\n+        function findArg(row, elem, typeFilter, maxLevDistance) {\n+            let lev = maxLevDistance + 1;\n \n             if (row && row.type && row.type.inputs && row.type.inputs.length > 0) {\n                 for (const input of row.type.inputs) {\n                     if (!typePassesFilter(typeFilter, input.ty)) {\n                         continue;\n                     }\n-                    lev = Math.min(lev, checkType(input, elem, parsedQuery.literalSearch));\n+                    lev = Math.min(\n+                        lev,\n+                        checkType(input, elem, parsedQuery.literalSearch, maxLevDistance)\n+                    );\n                     if (lev === 0) {\n                         return 0;\n                     }\n                 }\n             }\n-            return parsedQuery.literalSearch ? MAX_LEV_DISTANCE + 1 : lev;\n+            return parsedQuery.literalSearch ? maxLevDistance + 1 : lev;\n         }\n \n         /**\n@@ -1082,31 +1082,34 @@ function initSearch(rawSearchIndex) {\n          * @param {integer} typeFilter\n          *\n          * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n-         *                      match, returns `MAX_LEV_DISTANCE + 1`.\n+         *                      match, returns `maxLevDistance + 1`.\n          */\n-        function checkReturned(row, elem, typeFilter) {\n-            let lev = MAX_LEV_DISTANCE + 1;\n+        function checkReturned(row, elem, typeFilter, maxLevDistance) {\n+            let lev = maxLevDistance + 1;\n \n             if (row && row.type && row.type.output.length > 0) {\n                 const ret = row.type.output;\n                 for (const ret_ty of ret) {\n                     if (!typePassesFilter(typeFilter, ret_ty.ty)) {\n                         continue;\n                     }\n-                    lev = Math.min(lev, checkType(ret_ty, elem, parsedQuery.literalSearch));\n+                    lev = Math.min(\n+                        lev,\n+                        checkType(ret_ty, elem, parsedQuery.literalSearch, maxLevDistance)\n+                    );\n                     if (lev === 0) {\n                         return 0;\n                     }\n                 }\n             }\n-            return parsedQuery.literalSearch ? MAX_LEV_DISTANCE + 1 : lev;\n+            return parsedQuery.literalSearch ? maxLevDistance + 1 : lev;\n         }\n \n-        function checkPath(contains, ty) {\n+        function checkPath(contains, ty, maxLevDistance) {\n             if (contains.length === 0) {\n                 return 0;\n             }\n-            let ret_lev = MAX_LEV_DISTANCE + 1;\n+            let ret_lev = maxLevDistance + 1;\n             const path = ty.path.split(\"::\");\n \n             if (ty.parent && ty.parent.name) {\n@@ -1116,7 +1119,7 @@ function initSearch(rawSearchIndex) {\n             const length = path.length;\n             const clength = contains.length;\n             if (clength > length) {\n-                return MAX_LEV_DISTANCE + 1;\n+                return maxLevDistance + 1;\n             }\n             for (let i = 0; i < length; ++i) {\n                 if (i + clength > length) {\n@@ -1126,7 +1129,7 @@ function initSearch(rawSearchIndex) {\n                 let aborted = false;\n                 for (let x = 0; x < clength; ++x) {\n                     const lev = levenshtein(path[i + x], contains[x]);\n-                    if (lev > MAX_LEV_DISTANCE) {\n+                    if (lev > maxLevDistance) {\n                         aborted = true;\n                         break;\n                     }\n@@ -1231,7 +1234,7 @@ function initSearch(rawSearchIndex) {\n          * following condition:\n          *\n          * * If it is a \"literal search\" (`parsedQuery.literalSearch`), then `lev` must be 0.\n-         * * If it is not a \"literal search\", `lev` must be <= `MAX_LEV_DISTANCE`.\n+         * * If it is not a \"literal search\", `lev` must be <= `maxLevDistance`.\n          *\n          * The `results` map contains information which will be used to sort the search results:\n          *\n@@ -1249,8 +1252,8 @@ function initSearch(rawSearchIndex) {\n          * @param {integer} lev\n          * @param {integer} path_lev\n          */\n-        function addIntoResults(results, fullId, id, index, lev, path_lev) {\n-            const inBounds = lev <= MAX_LEV_DISTANCE || index !== -1;\n+        function addIntoResults(results, fullId, id, index, lev, path_lev, maxLevDistance) {\n+            const inBounds = lev <= maxLevDistance || index !== -1;\n             if (lev === 0 || (!parsedQuery.literalSearch && inBounds)) {\n                 if (results[fullId] !== undefined) {\n                     const result = results[fullId];\n@@ -1289,7 +1292,8 @@ function initSearch(rawSearchIndex) {\n             elem,\n             results_others,\n             results_in_args,\n-            results_returned\n+            results_returned,\n+            maxLevDistance\n         ) {\n             if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n@@ -1298,13 +1302,13 @@ function initSearch(rawSearchIndex) {\n             const fullId = row.id;\n             const searchWord = searchWords[pos];\n \n-            const in_args = findArg(row, elem, parsedQuery.typeFilter);\n-            const returned = checkReturned(row, elem, parsedQuery.typeFilter);\n+            const in_args = findArg(row, elem, parsedQuery.typeFilter, maxLevDistance);\n+            const returned = checkReturned(row, elem, parsedQuery.typeFilter, maxLevDistance);\n \n             // path_lev is 0 because no parent path information is currently stored\n             // in the search index\n-            addIntoResults(results_in_args, fullId, pos, -1, in_args, 0);\n-            addIntoResults(results_returned, fullId, pos, -1, returned, 0);\n+            addIntoResults(results_in_args, fullId, pos, -1, in_args, 0, maxLevDistance);\n+            addIntoResults(results_returned, fullId, pos, -1, returned, 0, maxLevDistance);\n \n             if (!typePassesFilter(parsedQuery.typeFilter, row.ty)) {\n                 return;\n@@ -1328,16 +1332,16 @@ function initSearch(rawSearchIndex) {\n             // No need to check anything else if it's a \"pure\" generics search.\n             if (elem.name.length === 0) {\n                 if (row.type !== null) {\n-                    lev = checkGenerics(row.type, elem, MAX_LEV_DISTANCE + 1);\n+                    lev = checkGenerics(row.type, elem, maxLevDistance + 1, maxLevDistance);\n                     // path_lev is 0 because we know it's empty\n-                    addIntoResults(results_others, fullId, pos, index, lev, 0);\n+                    addIntoResults(results_others, fullId, pos, index, lev, 0, maxLevDistance);\n                 }\n                 return;\n             }\n \n             if (elem.fullPath.length > 1) {\n-                path_lev = checkPath(elem.pathWithoutLast, row);\n-                if (path_lev > MAX_LEV_DISTANCE) {\n+                path_lev = checkPath(elem.pathWithoutLast, row, maxLevDistance);\n+                if (path_lev > maxLevDistance) {\n                     return;\n                 }\n             }\n@@ -1351,11 +1355,11 @@ function initSearch(rawSearchIndex) {\n \n             lev = levenshtein(searchWord, elem.pathLast);\n \n-            if (index === -1 && lev + path_lev > MAX_LEV_DISTANCE) {\n+            if (index === -1 && lev + path_lev > maxLevDistance) {\n                 return;\n             }\n \n-            addIntoResults(results_others, fullId, pos, index, lev, path_lev);\n+            addIntoResults(results_others, fullId, pos, index, lev, path_lev, maxLevDistance);\n         }\n \n         /**\n@@ -1367,7 +1371,7 @@ function initSearch(rawSearchIndex) {\n          * @param {integer} pos      - Position in the `searchIndex`.\n          * @param {Object} results\n          */\n-        function handleArgs(row, pos, results) {\n+        function handleArgs(row, pos, results, maxLevDistance) {\n             if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n             }\n@@ -1379,7 +1383,7 @@ function initSearch(rawSearchIndex) {\n             function checkArgs(elems, callback) {\n                 for (const elem of elems) {\n                     // There is more than one parameter to the query so all checks should be \"exact\"\n-                    const lev = callback(row, elem, NO_TYPE_FILTER);\n+                    const lev = callback(row, elem, NO_TYPE_FILTER, maxLevDistance);\n                     if (lev <= 1) {\n                         nbLev += 1;\n                         totalLev += lev;\n@@ -1400,12 +1404,21 @@ function initSearch(rawSearchIndex) {\n                 return;\n             }\n             const lev = Math.round(totalLev / nbLev);\n-            addIntoResults(results, row.id, pos, 0, lev, 0);\n+            addIntoResults(results, row.id, pos, 0, lev, 0, maxLevDistance);\n         }\n \n         function innerRunQuery() {\n             let elem, i, nSearchWords, in_returned, row;\n \n+            let queryLen = 0;\n+            for (const elem of parsedQuery.elems) {\n+                queryLen += elem.name.length;\n+            }\n+            for (const elem of parsedQuery.returned) {\n+                queryLen += elem.name.length;\n+            }\n+            const maxLevDistance = Math.floor(queryLen / 3);\n+\n             if (parsedQuery.foundElems === 1) {\n                 if (parsedQuery.elems.length === 1) {\n                     elem = parsedQuery.elems[0];\n@@ -1418,21 +1431,27 @@ function initSearch(rawSearchIndex) {\n                             elem,\n                             results_others,\n                             results_in_args,\n-                            results_returned\n+                            results_returned,\n+                            maxLevDistance\n                         );\n                     }\n                 } else if (parsedQuery.returned.length === 1) {\n                     // We received one returned argument to check, so looking into returned values.\n                     elem = parsedQuery.returned[0];\n                     for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n                         row = searchIndex[i];\n-                        in_returned = checkReturned(row, elem, parsedQuery.typeFilter);\n-                        addIntoResults(results_others, row.id, i, -1, in_returned);\n+                        in_returned = checkReturned(\n+                            row,\n+                            elem,\n+                            parsedQuery.typeFilter,\n+                            maxLevDistance\n+                        );\n+                        addIntoResults(results_others, row.id, i, -1, in_returned, maxLevDistance);\n                     }\n                 }\n             } else if (parsedQuery.foundElems > 0) {\n                 for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n-                    handleArgs(searchIndex[i], i, results_others);\n+                    handleArgs(searchIndex[i], i, results_others, maxLevDistance);\n                 }\n             }\n         }\n@@ -1470,7 +1489,7 @@ function initSearch(rawSearchIndex) {\n      *\n      * @return {boolean}       - Whether the result is valid or not\n      */\n-    function validateResult(name, path, keys, parent) {\n+    function validateResult(name, path, keys, parent, maxLevDistance) {\n         if (!keys || !keys.length) {\n             return true;\n         }\n@@ -1485,7 +1504,7 @@ function initSearch(rawSearchIndex) {\n                 (parent !== undefined && parent.name !== undefined &&\n                     parent.name.toLowerCase().indexOf(key) > -1) ||\n                 // lastly check to see if the name was a levenshtein match\n-                levenshtein(name, key) <= MAX_LEV_DISTANCE)) {\n+                levenshtein(name, key) <= maxLevDistance)) {\n                 return false;\n             }\n         }"}, {"sha": "9d7e73a7999c97e29fbabe844fc2f0e0d1458776", "filename": "tests/rustdoc-js-std/typed-query.js", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e09e6df787df074becd7b1b5b1138f517dd788d5/tests%2Frustdoc-js-std%2Ftyped-query.js", "raw_url": "https://github.com/rust-lang/rust/raw/e09e6df787df074becd7b1b5b1138f517dd788d5/tests%2Frustdoc-js-std%2Ftyped-query.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Ftyped-query.js?ref=e09e6df787df074becd7b1b5b1138f517dd788d5", "patch": "@@ -10,8 +10,5 @@ const EXPECTED = {\n         { 'path': 'std', 'name': 'eprint' },\n         { 'path': 'std', 'name': 'eprintln' },\n         { 'path': 'std::pin', 'name': 'pin' },\n-        { 'path': 'std::future', 'name': 'join' },\n-        { 'path': 'std', 'name': 'line' },\n-        { 'path': 'std', 'name': 'write' },\n     ],\n };"}, {"sha": "62c8e7a74b9405ed2a22075ec9464d189fce2228", "filename": "tests/rustdoc-js/doc-alias.js", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e09e6df787df074becd7b1b5b1138f517dd788d5/tests%2Frustdoc-js%2Fdoc-alias.js", "raw_url": "https://github.com/rust-lang/rust/raw/e09e6df787df074becd7b1b5b1138f517dd788d5/tests%2Frustdoc-js%2Fdoc-alias.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fdoc-alias.js?ref=e09e6df787df074becd7b1b5b1138f517dd788d5", "patch": "@@ -1,5 +1,3 @@\n-// exact-check\n-\n const QUERY = [\n     'StructItem',\n     'StructFieldItem',"}]}