{"sha": "111324e17cd5d6c1181ea592051583a88bbe0f18", "node_id": "C_kwDOAAsO6NoAKDExMTMyNGUxN2NkNWQ2YzExODFlYTU5MjA1MTU4M2E4OGJiZTBmMTg", "commit": {"author": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-10-06T22:09:36Z"}, "committer": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-11-07T09:35:20Z"}, "message": "Prevent registration inside references if target is !Freeze", "tree": {"sha": "6dbf3c20cc6add2df3916c08e95bd5336d6bd9d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dbf3c20cc6add2df3916c08e95bd5336d6bd9d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/111324e17cd5d6c1181ea592051583a88bbe0f18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/111324e17cd5d6c1181ea592051583a88bbe0f18", "html_url": "https://github.com/rust-lang/rust/commit/111324e17cd5d6c1181ea592051583a88bbe0f18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/111324e17cd5d6c1181ea592051583a88bbe0f18/comments", "author": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4478a87018d59a1945b0c462d0584fc03edc6e3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4478a87018d59a1945b0c462d0584fc03edc6e3b", "html_url": "https://github.com/rust-lang/rust/commit/4478a87018d59a1945b0c462d0584fc03edc6e3b"}], "stats": {"total": 61, "additions": 41, "deletions": 20}, "files": [{"sha": "f72e236eda1332cd4013315af28a120909cdfbfb", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/111324e17cd5d6c1181ea592051583a88bbe0f18/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111324e17cd5d6c1181ea592051583a88bbe0f18/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=111324e17cd5d6c1181ea592051583a88bbe0f18", "patch": "@@ -849,7 +849,7 @@ impl<'tcx> Ty<'tcx> {\n     ///\n     /// Returning true means the type is known to be `Freeze`. Returning\n     /// `false` means nothing -- could be `Freeze`, might not be.\n-    pub fn is_trivially_freeze(self) -> bool {\n+    fn is_trivially_freeze(self) -> bool {\n         match self.kind() {\n             ty::Int(_)\n             | ty::Uint(_)"}, {"sha": "fbaaee48148d04b2a944ec907e70606d214d757d", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/111324e17cd5d6c1181ea592051583a88bbe0f18/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111324e17cd5d6c1181ea592051583a88bbe0f18/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=111324e17cd5d6c1181ea592051583a88bbe0f18", "patch": "@@ -72,6 +72,7 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::DUMMY_SP;\n use rustc_target::abi::VariantIdx;\n \n use crate::{\n@@ -550,7 +551,7 @@ pub struct Map {\n }\n \n impl Map {\n-    pub fn new() -> Self {\n+    fn new() -> Self {\n         Self {\n             locals: IndexVec::new(),\n             projections: FxHashMap::default(),\n@@ -559,23 +560,35 @@ impl Map {\n         }\n     }\n \n-    /// Register all places with suitable types up to a certain derefence depth (to prevent cycles).\n-    pub fn register_with_filter<'tcx>(\n+    /// Register all suitable places with matching types (up to a certain depth).\n+    pub fn from_filter<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        body: &Body<'tcx>,\n+        filter: impl FnMut(Ty<'tcx>) -> bool,\n+    ) -> Self {\n+        let mut map = Self::new();\n+        map.register_with_filter(tcx, body, 3, filter);\n+        map\n+    }\n+\n+    fn register_with_filter<'tcx>(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        source: &impl HasLocalDecls<'tcx>,\n+        body: &Body<'tcx>,\n         max_derefs: u32,\n         mut filter: impl FnMut(Ty<'tcx>) -> bool,\n     ) {\n+        let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n         let mut projection = Vec::new();\n-        for (local, decl) in source.local_decls().iter_enumerated() {\n+        for (local, decl) in body.local_decls.iter_enumerated() {\n             self.register_with_filter_rec(\n                 tcx,\n                 max_derefs,\n                 local,\n                 &mut projection,\n                 decl.ty,\n                 &mut filter,\n+                param_env,\n             );\n         }\n     }\n@@ -588,16 +601,28 @@ impl Map {\n         projection: &mut Vec<PlaceElem<'tcx>>,\n         ty: Ty<'tcx>,\n         filter: &mut impl FnMut(Ty<'tcx>) -> bool,\n+        param_env: ty::ParamEnv<'tcx>,\n     ) {\n         if filter(ty) {\n             // This might fail if `ty` is not scalar.\n             let _ = self.register_with_ty(local, projection, ty);\n         }\n         if max_derefs > 0 {\n-            if let Some(ty::TypeAndMut { ty, .. }) = ty.builtin_deref(false) {\n-                projection.push(PlaceElem::Deref);\n-                self.register_with_filter_rec(tcx, max_derefs - 1, local, projection, ty, filter);\n-                projection.pop();\n+            if let Some(ty::TypeAndMut { ty: deref_ty, .. }) = ty.builtin_deref(false) {\n+                // References can only be tracked if the target is `!Freeze`.\n+                if deref_ty.is_freeze(tcx.at(DUMMY_SP), param_env) {\n+                    projection.push(PlaceElem::Deref);\n+                    self.register_with_filter_rec(\n+                        tcx,\n+                        max_derefs - 1,\n+                        local,\n+                        projection,\n+                        deref_ty,\n+                        filter,\n+                        param_env,\n+                    );\n+                    projection.pop();\n+                }\n             }\n         }\n         iter_fields(ty, tcx, |variant, field, ty| {\n@@ -606,7 +631,9 @@ impl Map {\n                 return;\n             }\n             projection.push(PlaceElem::Field(field, ty));\n-            self.register_with_filter_rec(tcx, max_derefs, local, projection, ty, filter);\n+            self.register_with_filter_rec(\n+                tcx, max_derefs, local, projection, ty, filter, param_env,\n+            );\n             projection.pop();\n         });\n     }\n@@ -639,7 +666,8 @@ impl Map {\n         Ok(index)\n     }\n \n-    pub fn register<'tcx>(\n+    #[allow(unused)]\n+    fn register<'tcx>(\n         &mut self,\n         local: Local,\n         projection: &[PlaceElem<'tcx>],\n@@ -671,12 +699,6 @@ impl Map {\n             return Err(());\n         }\n \n-        if !ty.is_trivially_freeze() {\n-            // Due to the way we deal with shared references, only `Freeze` types may be tracked.\n-            // We are a little bit to restrictive here by only allowing trivially `Freeze` types.\n-            return Err(());\n-        }\n-\n         let place = self.make_place(local, projection)?;\n \n         // Allocate a value slot if it doesn't have one."}, {"sha": "8f77b2b0081a87c3bd1d35565be6362803faddb9", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/111324e17cd5d6c1181ea592051583a88bbe0f18/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/111324e17cd5d6c1181ea592051583a88bbe0f18/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=111324e17cd5d6c1181ea592051583a88bbe0f18", "patch": "@@ -21,8 +21,7 @@ impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // Decide which places to track during the analysis.\n-        let mut map = Map::new();\n-        map.register_with_filter(tcx, body, 3, |ty| ty.is_scalar() && !ty.is_unsafe_ptr());\n+        let map = Map::from_filter(tcx, body, |ty| ty.is_scalar() && !ty.is_unsafe_ptr());\n \n         // Perform the actual dataflow analysis.\n         let analysis = ConstAnalysis::new(tcx, body, map);"}]}