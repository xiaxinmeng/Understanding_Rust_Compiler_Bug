{"sha": "bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMWRhMThiMDRhZmJhNWRmYzA5YWQxYjU2ZGYzMjg1ZjFkMDM5YzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-17T21:30:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-17T21:30:10Z"}, "message": "Auto merge of #63671 - Centril:rollup-zufavt5, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #62451 (Add APIs for uninitialized Box, Rc, and Arc. (Plus get_mut_unchecked))\n - #63487 (Remove meaningless comments in src/test)\n - #63657 (Crank up invalid value lint)\n - #63667 (resolve: Properly integrate derives and `macro_rules` scopes)\n - #63669 (fix typos in mir/interpret)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "7c2b00aa9055aa3b9cfc721c604bf54e2eccdf0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c2b00aa9055aa3b9cfc721c604bf54e2eccdf0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "html_url": "https://github.com/rust-lang/rust/commit/bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2111aed0a38c819acb140c7153e9366964a37f2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2111aed0a38c819acb140c7153e9366964a37f2f", "html_url": "https://github.com/rust-lang/rust/commit/2111aed0a38c819acb140c7153e9366964a37f2f"}, {"sha": "4ec9703467c6934bf0bc8be922f242226c32d0aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ec9703467c6934bf0bc8be922f242226c32d0aa", "html_url": "https://github.com/rust-lang/rust/commit/4ec9703467c6934bf0bc8be922f242226c32d0aa"}], "stats": {"total": 1214, "additions": 924, "deletions": 290}, "files": [{"sha": "c61e3183409f267fcf83a9565ece1b58efdd096f", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -91,8 +91,10 @@ use core::ops::{\n     CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Receiver, Generator, GeneratorState\n };\n use core::ptr::{self, NonNull, Unique};\n+use core::slice;\n use core::task::{Context, Poll};\n \n+use crate::alloc::{self, Global, Alloc};\n use crate::vec::Vec;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n@@ -121,6 +123,34 @@ impl<T> Box<T> {\n         box x\n     }\n \n+    /// Constructs a new box with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut five = Box::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n+        let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n+        let ptr = unsafe {\n+            Global.alloc(layout)\n+                .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n+        };\n+        Box(ptr.cast().into())\n+    }\n+\n     /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n     /// `x` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -130,6 +160,111 @@ impl<T> Box<T> {\n     }\n }\n \n+impl<T> Box<[T]> {\n+    /// Constructs a new boxed slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     values[0].as_mut_ptr().write(1);\n+    ///     values[1].as_mut_ptr().write(2);\n+    ///     values[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n+        let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n+        let ptr = unsafe { alloc::alloc(layout) };\n+        let unique = Unique::new(ptr).unwrap_or_else(|| alloc::handle_alloc_error(layout));\n+        let slice = unsafe { slice::from_raw_parts_mut(unique.cast().as_ptr(), len) };\n+        Box(Unique::from(slice))\n+    }\n+}\n+\n+impl<T> Box<mem::MaybeUninit<T>> {\n+    /// Converts to `Box<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut five = Box::<u32>::new_uninit();\n+    ///\n+    /// let five: Box<u32> = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Box<T> {\n+        Box(Box::into_unique(self).cast())\n+    }\n+}\n+\n+impl<T> Box<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Box<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the values\n+    /// really are in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     values[0].as_mut_ptr().write(1);\n+    ///     values[1].as_mut_ptr().write(2);\n+    ///     values[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Box<[T]> {\n+        Box(Unique::new_unchecked(Box::into_raw(self) as _))\n+    }\n+}\n+\n impl<T: ?Sized> Box<T> {\n     /// Constructs a box from a raw pointer.\n     ///"}, {"sha": "2b222caf13f3d48c3333aa35ff78a01e1ced57b1", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 181, "deletions": 5, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -327,6 +327,37 @@ impl<T> Rc<T> {\n         }))\n     }\n \n+    /// Constructs a new `Rc` with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Rc<mem::MaybeUninit<T>> {\n+        unsafe {\n+            Rc::from_ptr(Rc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n+            ))\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Rc<T>>`. If `T` does not implement `Unpin`, then\n     /// `value` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -377,6 +408,118 @@ impl<T> Rc<T> {\n     }\n }\n \n+impl<T> Rc<[T]> {\n+    /// Constructs a new reference-counted slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut values = Rc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {\n+        unsafe {\n+            Rc::from_ptr(Rc::allocate_for_slice(len))\n+        }\n+    }\n+}\n+\n+impl<T> Rc<mem::MaybeUninit<T>> {\n+    /// Converts to `Rc<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Rc<T> {\n+        Rc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())\n+    }\n+}\n+\n+impl<T> Rc<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Rc<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut values = Rc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Rc<[T]> {\n+        Rc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _)\n+    }\n+}\n+\n impl<T: ?Sized> Rc<T> {\n     /// Consumes the `Rc`, returning the wrapped pointer.\n     ///\n@@ -560,13 +703,46 @@ impl<T: ?Sized> Rc<T> {\n     pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n         if Rc::is_unique(this) {\n             unsafe {\n-                Some(&mut this.ptr.as_mut().value)\n+                Some(Rc::get_mut_unchecked(this))\n             }\n         } else {\n             None\n         }\n     }\n \n+    /// Returns a mutable reference to the inner value,\n+    /// without any check.\n+    ///\n+    /// See also [`get_mut`], which is safe and does appropriate checks.\n+    ///\n+    /// [`get_mut`]: struct.Rc.html#method.get_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// Any other `Rc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// for the duration of the returned borrow.\n+    /// This is trivially the case if no such pointers exist,\n+    /// for example immediately after `Rc::new`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut x = Rc::new(String::new());\n+    /// unsafe {\n+    ///     Rc::get_mut_unchecked(&mut x).push_str(\"foo\")\n+    /// }\n+    /// assert_eq!(*x, \"foo\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n+    pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n+        &mut this.ptr.as_mut().value\n+    }\n+\n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n     /// Returns `true` if the two `Rc`s point to the same value (not\n@@ -704,11 +880,11 @@ impl Rc<dyn Any> {\n \n impl<T: ?Sized> Rc<T> {\n     /// Allocates an `RcBox<T>` with sufficient space for\n-    /// an unsized value where the value has the layout provided.\n+    /// a possibly-unsized value where the value has the layout provided.\n     ///\n     /// The function `mem_to_rcbox` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n-    unsafe fn allocate_for_unsized(\n+    unsafe fn allocate_for_layout(\n         value_layout: Layout,\n         mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>\n     ) -> *mut RcBox<T> {\n@@ -737,7 +913,7 @@ impl<T: ?Sized> Rc<T> {\n     /// Allocates an `RcBox<T>` with sufficient space for an unsized value\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::for_value(&*ptr),\n             |mem| set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>,\n         )\n@@ -768,7 +944,7 @@ impl<T: ?Sized> Rc<T> {\n impl<T> Rc<[T]> {\n     /// Allocates an `RcBox<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut RcBox<[T]> {\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::array::<T>(len).unwrap(),\n             |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>,\n         )"}, {"sha": "341172136e25833f87837dd8aa5066b14d5b61de", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 181, "deletions": 5, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -311,6 +311,37 @@ impl<T> Arc<T> {\n         Self::from_inner(Box::into_raw_non_null(x))\n     }\n \n+    /// Constructs a new `Arc` with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Arc<mem::MaybeUninit<T>> {\n+        unsafe {\n+            Arc::from_ptr(Arc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n+            ))\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Arc<T>>`. If `T` does not implement `Unpin`, then\n     /// `data` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -361,6 +392,118 @@ impl<T> Arc<T> {\n     }\n }\n \n+impl<T> Arc<[T]> {\n+    /// Constructs a new reference-counted slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut values = Arc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n+        unsafe {\n+            Arc::from_ptr(Arc::allocate_for_slice(len))\n+        }\n+    }\n+}\n+\n+impl<T> Arc<mem::MaybeUninit<T>> {\n+    /// Converts to `Arc<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Arc<T> {\n+        Arc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())\n+    }\n+}\n+\n+impl<T> Arc<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Arc<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut values = Arc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Arc<[T]> {\n+        Arc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _)\n+    }\n+}\n+\n impl<T: ?Sized> Arc<T> {\n     /// Consumes the `Arc`, returning the wrapped pointer.\n     ///\n@@ -593,11 +736,11 @@ impl<T: ?Sized> Arc<T> {\n \n impl<T: ?Sized> Arc<T> {\n     /// Allocates an `ArcInner<T>` with sufficient space for\n-    /// an unsized value where the value has the layout provided.\n+    /// a possibly-unsized value where the value has the layout provided.\n     ///\n     /// The function `mem_to_arcinner` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n-    unsafe fn allocate_for_unsized(\n+    unsafe fn allocate_for_layout(\n         value_layout: Layout,\n         mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>\n     ) -> *mut ArcInner<T> {\n@@ -625,7 +768,7 @@ impl<T: ?Sized> Arc<T> {\n     /// Allocates an `ArcInner<T>` with sufficient space for an unsized value.\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::for_value(&*ptr),\n             |mem| set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>,\n         )\n@@ -656,7 +799,7 @@ impl<T: ?Sized> Arc<T> {\n impl<T> Arc<[T]> {\n     /// Allocates an `ArcInner<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut ArcInner<[T]> {\n-        Self::allocate_for_unsized(\n+        Self::allocate_for_layout(\n             Layout::array::<T>(len).unwrap(),\n             |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>,\n         )\n@@ -945,13 +1088,46 @@ impl<T: ?Sized> Arc<T> {\n             // the Arc itself to be `mut`, so we're returning the only possible\n             // reference to the inner data.\n             unsafe {\n-                Some(&mut this.ptr.as_mut().data)\n+                Some(Arc::get_mut_unchecked(this))\n             }\n         } else {\n             None\n         }\n     }\n \n+    /// Returns a mutable reference to the inner value,\n+    /// without any check.\n+    ///\n+    /// See also [`get_mut`], which is safe and does appropriate checks.\n+    ///\n+    /// [`get_mut`]: struct.Arc.html#method.get_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// Any other `Arc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// for the duration of the returned borrow.\n+    /// This is trivially the case if no such pointers exist,\n+    /// for example immediately after `Arc::new`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut x = Arc::new(String::new());\n+    /// unsafe {\n+    ///     Arc::get_mut_unchecked(&mut x).push_str(\"foo\")\n+    /// }\n+    /// assert_eq!(*x, \"foo\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n+    pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n+        &mut this.ptr.as_mut().data\n+    }\n+\n     /// Determine whether this is the unique reference (including weak refs) to\n     /// the underlying data.\n     ///"}, {"sha": "3521dd799795672ab379af6cc25dab307f8ee91e", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -122,6 +122,14 @@ impl<T: ?Sized> Unique<T> {\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n         &mut *self.as_ptr()\n     }\n+\n+    /// Casts to a pointer of another type.\n+    #[inline]\n+    pub const fn cast<U>(self) -> Unique<U> {\n+        unsafe {\n+            Unique::new_unchecked(self.as_ptr() as *mut U)\n+        }\n+    }\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]"}, {"sha": "d725afa40521253843e70072e0abf35324f22f9b", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -74,7 +74,7 @@ impl<'a> DefCollector<'a> {\n         })\n     }\n \n-    fn visit_macro_invoc(&mut self, id: NodeId) {\n+    pub fn visit_macro_invoc(&mut self, id: NodeId) {\n         self.definitions.set_invocation_parent(id.placeholder_to_expn_id(), self.parent_def);\n     }\n }"}, {"sha": "84b4cd914563e6574a28d2d94392833d75dfb3be", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -306,7 +306,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///\n     /// zsts can't be read out of two reasons:\n     /// * byteorder cannot work with zero element buffers\n-    /// * in oder to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n+    /// * in order to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n     ///   being valid for ZSTs\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand."}, {"sha": "ce7681c974a5dcf73d1bd6bdcda0a75f8ba2e46d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 111, "deletions": 43, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1876,25 +1876,101 @@ declare_lint_pass!(InvalidValue => [INVALID_VALUE]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &hir::Expr) {\n \n-        const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n-        const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n+        #[derive(Debug, Copy, Clone, PartialEq)]\n+        enum InitKind { Zeroed, Uninit };\n \n         /// Information about why a type cannot be initialized this way.\n         /// Contains an error message and optionally a span to point at.\n         type InitError = (String, Option<Span>);\n \n+        /// Test if this constant is all-0.\n+        fn is_zero(expr: &hir::Expr) -> bool {\n+            use hir::ExprKind::*;\n+            use syntax::ast::LitKind::*;\n+            match &expr.node {\n+                Lit(lit) =>\n+                    if let Int(i, _) = lit.node {\n+                        i == 0\n+                    } else {\n+                        false\n+                    },\n+                Tup(tup) =>\n+                    tup.iter().all(is_zero),\n+                _ =>\n+                    false\n+            }\n+        }\n+\n+        /// Determine if this expression is a \"dangerous initialization\".\n+        fn is_dangerous_init(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<InitKind> {\n+            const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n+            const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n+            // `transmute` is inside an anonymous module (the `extern` block?);\n+            // `Invalid` represents the empty string and matches that.\n+            const TRANSMUTE_PATH: &[Symbol] =\n+                &[sym::core, sym::intrinsics, kw::Invalid, sym::transmute];\n+\n+            if let hir::ExprKind::Call(ref path_expr, ref args) = expr.node {\n+                if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n+                    let def_id = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id()?;\n+\n+                    if cx.match_def_path(def_id, ZEROED_PATH) {\n+                        return Some(InitKind::Zeroed);\n+                    }\n+                    if cx.match_def_path(def_id, UININIT_PATH) {\n+                        return Some(InitKind::Uninit);\n+                    }\n+                    if cx.match_def_path(def_id, TRANSMUTE_PATH) {\n+                        if is_zero(&args[0]) {\n+                            return Some(InitKind::Zeroed);\n+                        }\n+                    }\n+                    // FIXME: Also detect `MaybeUninit::zeroed().assume_init()` and\n+                    // `MaybeUninit::uninit().assume_init()`.\n+                }\n+            }\n+\n+            None\n+        }\n+\n         /// Return `Some` only if we are sure this type does *not*\n         /// allow zero initialization.\n-        fn ty_find_init_error<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<InitError> {\n+        fn ty_find_init_error<'tcx>(\n+            tcx: TyCtxt<'tcx>,\n+            ty: Ty<'tcx>,\n+            init: InitKind,\n+        ) -> Option<InitError> {\n             use rustc::ty::TyKind::*;\n             match ty.sty {\n                 // Primitive types that don't like 0 as a value.\n                 Ref(..) => Some((format!(\"References must be non-null\"), None)),\n                 Adt(..) if ty.is_box() => Some((format!(\"`Box` must be non-null\"), None)),\n                 FnPtr(..) => Some((format!(\"Function pointers must be non-null\"), None)),\n                 Never => Some((format!(\"The never type (`!`) has no valid value\"), None)),\n-                // Recurse for some compound types.\n+                // Primitive types with other constraints.\n+                Bool if init == InitKind::Uninit =>\n+                    Some((format!(\"Booleans must be `true` or `false`\"), None)),\n+                Char if init == InitKind::Uninit =>\n+                    Some((format!(\"Characters must be a valid unicode codepoint\"), None)),\n+                // Recurse and checks for some compound types.\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n+                    // First check f this ADT has a layout attribute (like `NonNull` and friends).\n+                    use std::ops::Bound;\n+                    match tcx.layout_scalar_valid_range(adt_def.did) {\n+                        // We exploit here that `layout_scalar_valid_range` will never\n+                        // return `Bound::Excluded`.  (And we have tests checking that we\n+                        // handle the attribute correctly.)\n+                        (Bound::Included(lo), _) if lo > 0 =>\n+                            return Some((format!(\"{} must be non-null\", ty), None)),\n+                        (Bound::Included(_), _) | (_, Bound::Included(_))\n+                        if init == InitKind::Uninit =>\n+                            return Some((\n+                                format!(\"{} must be initialized inside its custom valid range\", ty),\n+                                None,\n+                            )),\n+                        _ => {}\n+                    }\n+                    // Now, recurse.\n                     match adt_def.variants.len() {\n                         0 => Some((format!(\"0-variant enums have no valid value\"), None)),\n                         1 => {\n@@ -1905,6 +1981,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                                 ty_find_init_error(\n                                     tcx,\n                                     field.ty(tcx, substs),\n+                                    init,\n                                 ).map(|(mut msg, span)| if span.is_none() {\n                                     // Point to this field, should be helpful for figuring\n                                     // out where the source of the error is.\n@@ -1918,57 +1995,48 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                                 })\n                             })\n                         }\n+                        // Multi-variant enums are tricky: if all but one variant are\n+                        // uninhabited, we might actually do layout like for a single-variant\n+                        // enum, and then even leaving them uninitialized could be okay.\n                         _ => None, // Conservative fallback for multi-variant enum.\n                     }\n                 }\n                 Tuple(..) => {\n                     // Proceed recursively, check all fields.\n-                    ty.tuple_fields().find_map(|field| ty_find_init_error(tcx, field))\n+                    ty.tuple_fields().find_map(|field| ty_find_init_error(tcx, field, init))\n                 }\n-                // FIXME: Would be nice to also warn for `NonNull`/`NonZero*`.\n-                // FIXME: *Only for `mem::uninitialized`*, we could also warn for `bool`,\n-                //        `char`, and any multivariant enum.\n                 // Conservative fallback.\n                 _ => None,\n             }\n         }\n \n-        if let hir::ExprKind::Call(ref path_expr, ref _args) = expr.node {\n-            if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n-                if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n-                    if cx.match_def_path(def_id, &ZEROED_PATH) ||\n-                        cx.match_def_path(def_id, &UININIT_PATH)\n-                    {\n-                        // This conjures an instance of a type out of nothing,\n-                        // using zeroed or uninitialized memory.\n-                        // We are extremely conservative with what we warn about.\n-                        let conjured_ty = cx.tables.expr_ty(expr);\n-                        if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty) {\n-                            let mut err = cx.struct_span_lint(\n-                                INVALID_VALUE,\n-                                expr.span,\n-                                &format!(\n-                                    \"the type `{}` does not permit {}\",\n-                                    conjured_ty,\n-                                    if cx.match_def_path(def_id, &ZEROED_PATH) {\n-                                        \"zero-initialization\"\n-                                    } else {\n-                                        \"being left uninitialized\"\n-                                    }\n-                                ),\n-                            );\n-                            err.span_label(expr.span,\n-                                \"this code causes undefined behavior when executed\");\n-                            err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead\");\n-                            if let Some(span) = span {\n-                                err.span_note(span, &msg);\n-                            } else {\n-                                err.note(&msg);\n-                            }\n-                            err.emit();\n-                        }\n-                    }\n+        if let Some(init) = is_dangerous_init(cx, expr) {\n+            // This conjures an instance of a type out of nothing,\n+            // using zeroed or uninitialized memory.\n+            // We are extremely conservative with what we warn about.\n+            let conjured_ty = cx.tables.expr_ty(expr);\n+            if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty, init) {\n+                let mut err = cx.struct_span_lint(\n+                    INVALID_VALUE,\n+                    expr.span,\n+                    &format!(\n+                        \"the type `{}` does not permit {}\",\n+                        conjured_ty,\n+                        match init {\n+                            InitKind::Zeroed => \"zero-initialization\",\n+                            InitKind::Uninit => \"being left uninitialized\",\n+                        },\n+                    ),\n+                );\n+                err.span_label(expr.span,\n+                    \"this code causes undefined behavior when executed\");\n+                err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead\");\n+                if let Some(span) = span {\n+                    err.span_note(span, &msg);\n+                } else {\n+                    err.note(&msg);\n                 }\n+                err.emit();\n             }\n         }\n     }"}, {"sha": "87d36dabb04721b36508d673e9828f1164e4eaf4", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -297,7 +297,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// and `align`. On success, returns `None` for zero-sized accesses (where\n     /// nothing else is left to do) and a `Pointer` to use for the actual access otherwise.\n     /// Crucially, if the input is a `Pointer`, we will test it for liveness\n-    /// *even of* the size is 0.\n+    /// *even if* the size is 0.\n     ///\n     /// Everyone accessing memory based on a `Scalar` should use this method to get the\n     /// `Pointer` they need. And even if you already have a `Pointer`, call this method"}, {"sha": "42428456b6eec39de4c2640a129c0428714a18c4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -160,12 +160,25 @@ impl<'a> Resolver<'a> {\n         Some(ext)\n     }\n \n+    // FIXME: `extra_placeholders` should be included into the `fragment` as regular placeholders.\n     crate fn build_reduced_graph(\n-        &mut self, fragment: &AstFragment, parent_scope: ParentScope<'a>\n+        &mut self,\n+        fragment: &AstFragment,\n+        extra_placeholders: &[NodeId],\n+        parent_scope: ParentScope<'a>,\n     ) -> LegacyScope<'a> {\n-        fragment.visit_with(&mut DefCollector::new(&mut self.definitions, parent_scope.expansion));\n+        let mut def_collector = DefCollector::new(&mut self.definitions, parent_scope.expansion);\n+        fragment.visit_with(&mut def_collector);\n+        for placeholder in extra_placeholders {\n+            def_collector.visit_macro_invoc(*placeholder);\n+        }\n+\n         let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n         fragment.visit_with(&mut visitor);\n+        for placeholder in extra_placeholders {\n+            visitor.parent_scope.legacy = visitor.visit_invoc(*placeholder);\n+        }\n+\n         visitor.parent_scope.legacy\n     }\n \n@@ -871,7 +884,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<ast::NodeId>) {\n+    fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<NodeId>) {\n         let parent = self.parent_scope.module;\n         let Export { ident, res, vis, span } = child;\n         // FIXME: We shouldn't create the gensym here, it should come from metadata,\n@@ -1060,10 +1073,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         false\n     }\n \n-    fn visit_invoc(&mut self, id: ast::NodeId) -> LegacyScope<'a> {\n+    fn visit_invoc(&mut self, id: NodeId) -> LegacyScope<'a> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n-        self.parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n+        self.parent_scope.module.unexpanded_invocations.borrow_mut().insert(invoc_id);\n \n         let old_parent_scope = self.r.invocation_parent_scopes.insert(invoc_id, self.parent_scope);\n         assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");"}, {"sha": "2dd0ad13c526d80b4d653db5df3e474b69a94d01", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -448,7 +448,7 @@ pub struct ModuleData<'a> {\n     populate_on_access: Cell<bool>,\n \n     // Macro invocations that can expand into items in this module.\n-    unresolved_invocations: RefCell<FxHashSet<ExpnId>>,\n+    unexpanded_invocations: RefCell<FxHashSet<ExpnId>>,\n \n     no_implicit_prelude: bool,\n \n@@ -478,7 +478,7 @@ impl<'a> ModuleData<'a> {\n             normal_ancestor_id,\n             lazy_resolutions: Default::default(),\n             populate_on_access: Cell::new(!normal_ancestor_id.is_local()),\n-            unresolved_invocations: Default::default(),\n+            unexpanded_invocations: Default::default(),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new(Vec::new()),"}, {"sha": "01ad67252a387886f630a7e01ed12f14ad33bd15", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -10,7 +10,7 @@ use crate::resolve_imports::ImportResolver;\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n-use syntax::ast::{self, Ident};\n+use syntax::ast::{self, NodeId, Ident};\n use syntax::attr::StabilityLevel;\n use syntax::edition::Edition;\n use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n@@ -26,7 +26,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use std::{mem, ptr};\n use rustc_data_structures::sync::Lrc;\n \n-type Res = def::Res<ast::NodeId>;\n+type Res = def::Res<NodeId>;\n \n /// Binding produced by a `macro_rules` item.\n /// Not modularized, can shadow previous legacy bindings, etc.\n@@ -91,11 +91,11 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n }\n \n impl<'a> base::Resolver for Resolver<'a> {\n-    fn next_node_id(&mut self) -> ast::NodeId {\n+    fn next_node_id(&mut self) -> NodeId {\n         self.session.next_node_id()\n     }\n \n-    fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId {\n+    fn get_module_scope(&mut self, id: NodeId) -> ExpnId {\n         let expn_id = ExpnId::fresh(Some(ExpnData::default(\n             ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n         )));\n@@ -115,23 +115,18 @@ impl<'a> base::Resolver for Resolver<'a> {\n         });\n     }\n \n+    // FIXME: `extra_placeholders` should be included into the `fragment` as regular placeholders.\n     fn visit_ast_fragment_with_placeholders(\n-        &mut self, expansion: ExpnId, fragment: &AstFragment, derives: &[ExpnId]\n+        &mut self, expansion: ExpnId, fragment: &AstFragment, extra_placeholders: &[NodeId]\n     ) {\n-        // Fill in some data for derives if the fragment is from a derive container.\n+        // Integrate the new AST fragment into all the definition and module structures.\n         // We are inside the `expansion` now, but other parent scope components are still the same.\n         let parent_scope = ParentScope { expansion, ..self.invocation_parent_scopes[&expansion] };\n-        let parent_def = self.definitions.invocation_parent(expansion);\n-        self.invocation_parent_scopes.extend(derives.iter().map(|&derive| (derive, parent_scope)));\n-        for &derive_invoc_id in derives {\n-            self.definitions.set_invocation_parent(derive_invoc_id, parent_def);\n-        }\n-        parent_scope.module.unresolved_invocations.borrow_mut().remove(&expansion);\n-        parent_scope.module.unresolved_invocations.borrow_mut().extend(derives);\n-\n-        // Integrate the new AST fragment into all the definition and module structures.\n-        let output_legacy_scope = self.build_reduced_graph(fragment, parent_scope);\n+        let output_legacy_scope =\n+            self.build_reduced_graph(fragment, extra_placeholders, parent_scope);\n         self.output_legacy_scopes.insert(expansion, output_legacy_scope);\n+\n+        parent_scope.module.unexpanded_invocations.borrow_mut().remove(&expansion);\n     }\n \n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension) {\n@@ -485,7 +480,7 @@ impl<'a> Resolver<'a> {\n                 Scope::MacroUsePrelude => match this.macro_use_prelude.get(&ident.name).cloned() {\n                     Some(binding) => Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n                     None => Err(Determinacy::determined(\n-                        this.graph_root.unresolved_invocations.borrow().is_empty()\n+                        this.graph_root.unexpanded_invocations.borrow().is_empty()\n                     ))\n                 }\n                 Scope::BuiltinAttrs => if is_builtin_attr_name(ident.name) {\n@@ -508,7 +503,7 @@ impl<'a> Resolver<'a> {\n                 Scope::ExternPrelude => match this.extern_prelude_get(ident, !record_used) {\n                     Some(binding) => Ok((binding, Flags::PRELUDE)),\n                     None => Err(Determinacy::determined(\n-                        this.graph_root.unresolved_invocations.borrow().is_empty()\n+                        this.graph_root.unexpanded_invocations.borrow().is_empty()\n                     )),\n                 }\n                 Scope::ToolPrelude => if KNOWN_TOOLS.contains(&ident.name) {"}, {"sha": "fd222a132a3f8589c53df38bff1849c8edb759e5", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -202,7 +202,7 @@ impl<'a> Resolver<'a> {\n                     Err((Determined, Weak::No))\n                 } else if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n                     Ok(binding)\n-                } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n+                } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {\n                     // Macro-expanded `extern crate` items can add names to extern prelude.\n                     Err((Undetermined, Weak::No))\n                 } else {\n@@ -348,7 +348,7 @@ impl<'a> Resolver<'a> {\n         // progress, we have to ignore those potential unresolved invocations from other modules\n         // and prohibit access to macro-expanded `macro_export` macros instead (unless restricted\n         // shadowing is enabled, see `macro_expanded_macro_export_errors`).\n-        let unexpanded_macros = !module.unresolved_invocations.borrow().is_empty();\n+        let unexpanded_macros = !module.unexpanded_invocations.borrow().is_empty();\n         if let Some(binding) = resolution.binding {\n             if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n                 return check_usable(self, binding);"}, {"sha": "b0a4a6af9839c4fd91e6f33541b241c3f313593c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,4 +1,4 @@\n-use crate::ast::{self, Attribute, Name, PatKind};\n+use crate::ast::{self, NodeId, Attribute, Name, PatKind};\n use crate::attr::{HasAttrs, Stability, Deprecation};\n use crate::source_map::SourceMap;\n use crate::edition::Edition;\n@@ -671,13 +671,13 @@ bitflags::bitflags! {\n }\n \n pub trait Resolver {\n-    fn next_node_id(&mut self) -> ast::NodeId;\n+    fn next_node_id(&mut self) -> NodeId;\n \n-    fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId;\n+    fn get_module_scope(&mut self, id: NodeId) -> ExpnId;\n \n     fn resolve_dollar_crates(&mut self);\n     fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n-                                            derives: &[ExpnId]);\n+                                            extra_placeholders: &[NodeId]);\n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension);\n \n     fn resolve_imports(&mut self);"}, {"sha": "c1d52c9745529125ddcfed00d900d8bd5d65731c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -291,7 +291,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         // Unresolved macros produce dummy outputs as a recovery measure.\n         invocations.reverse();\n         let mut expanded_fragments = Vec::new();\n-        let mut derives: FxHashMap<ExpnId, Vec<_>> = FxHashMap::default();\n+        let mut all_derive_placeholders: FxHashMap<ExpnId, Vec<_>> = FxHashMap::default();\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n         loop {\n@@ -347,13 +347,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n                 let mut item = self.fully_configure(item);\n                 item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n-                let derives = derives.entry(invoc.expansion_data.id).or_default();\n+                let derive_placeholders =\n+                    all_derive_placeholders.entry(invoc.expansion_data.id).or_default();\n \n-                derives.reserve(traits.len());\n+                derive_placeholders.reserve(traits.len());\n                 invocations.reserve(traits.len());\n                 for path in traits {\n                     let expn_id = ExpnId::fresh(None);\n-                    derives.push(expn_id);\n+                    derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n                     invocations.push(Invocation {\n                         kind: InvocationKind::Derive { path, item: item.clone() },\n                         fragment_kind: invoc.fragment_kind,\n@@ -365,7 +366,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 let fragment = invoc.fragment_kind\n                     .expect_from_annotatables(::std::iter::once(item));\n-                self.collect_invocations(fragment, derives)\n+                self.collect_invocations(fragment, derive_placeholders)\n             } else {\n                 unreachable!()\n             };\n@@ -384,10 +385,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         // Finally incorporate all the expanded macros into the input AST fragment.\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n         while let Some(expanded_fragments) = expanded_fragments.pop() {\n-            for (mark, expanded_fragment) in expanded_fragments.into_iter().rev() {\n-                let derives = derives.remove(&mark).unwrap_or_else(Vec::new);\n-                placeholder_expander.add(NodeId::placeholder_from_expn_id(mark),\n-                                         expanded_fragment, derives);\n+            for (expn_id, expanded_fragment) in expanded_fragments.into_iter().rev() {\n+                let derive_placeholders =\n+                    all_derive_placeholders.remove(&expn_id).unwrap_or_else(Vec::new);\n+                placeholder_expander.add(NodeId::placeholder_from_expn_id(expn_id),\n+                                         expanded_fragment, derive_placeholders);\n             }\n         }\n         fragment_with_placeholders.mut_visit_with(&mut placeholder_expander);\n@@ -404,7 +406,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// them with \"placeholders\" - dummy macro invocations with specially crafted `NodeId`s.\n     /// Then call into resolver that builds a skeleton (\"reduced graph\") of the fragment and\n     /// prepares data for resolving paths of macro invocations.\n-    fn collect_invocations(&mut self, mut fragment: AstFragment, derives: &[ExpnId])\n+    fn collect_invocations(&mut self, mut fragment: AstFragment, extra_placeholders: &[NodeId])\n                            -> (AstFragment, Vec<Invocation>) {\n         // Resolve `$crate`s in the fragment for pretty-printing.\n         self.cx.resolver.resolve_dollar_crates();\n@@ -423,9 +425,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             collector.invocations\n         };\n \n+        // FIXME: Merge `extra_placeholders` into the `fragment` as regular placeholders.\n         if self.monotonic {\n             self.cx.resolver.visit_ast_fragment_with_placeholders(\n-                self.cx.current_expansion.id, &fragment, derives);\n+                self.cx.current_expansion.id, &fragment, extra_placeholders);\n         }\n \n         (fragment, invocations)"}, {"sha": "d800cfedcfb4b27796b7a01f34ba3081479f0a2e", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -2,7 +2,6 @@ use crate::ast::{self, NodeId};\n use crate::source_map::{DUMMY_SP, dummy_spanned};\n use crate::ext::base::ExtCtxt;\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n-use crate::ext::hygiene::ExpnId;\n use crate::tokenstream::TokenStream;\n use crate::mut_visit::*;\n use crate::ptr::P;\n@@ -86,11 +85,11 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n         }\n     }\n \n-    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, derives: Vec<ExpnId>) {\n+    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, placeholders: Vec<NodeId>) {\n         fragment.mut_visit_with(self);\n         if let AstFragment::Items(mut items) = fragment {\n-            for derive in derives {\n-                match self.remove(NodeId::placeholder_from_expn_id(derive)) {\n+            for placeholder in placeholders {\n+                match self.remove(placeholder) {\n                     AstFragment::Items(derived_items) => items.extend(derived_items),\n                     _ => unreachable!(),\n                 }"}, {"sha": "619cce685d75f581a9c204f7bfefba50c9e55dde", "filename": "src/test/pretty/stmt_expr_attributes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -259,8 +259,6 @@ fn _12() {\n     }\n }\n \n-/////////////////\n-\n fn foo() { }\n fn foo3(_: i32, _: (), _: ()) { }\n fn qux(_: i32) { }"}, {"sha": "7e05bcd309a4ff3efa52d1da6c915a0f58d67736", "filename": "src/test/ui/associated-type/associated-type-projection-from-supertrait.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-supertrait.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -12,30 +12,22 @@ pub trait Car : Vehicle {\n     fn chip_paint(&self, c: Self::Color) { }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct Black;\n struct ModelT;\n impl Vehicle for ModelT { type Color = Black; }\n impl Car for ModelT { }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct Blue;\n struct ModelU;\n impl Vehicle for ModelU { type Color = Blue; }\n impl Car for ModelU { }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n fn dent<C:Car>(c: C, color: C::Color) { c.chip_paint(color) }\n fn a() { dent(ModelT, Black); }\n fn b() { dent(ModelT, Blue); } //~ ERROR mismatched types\n fn c() { dent(ModelU, Black); } //~ ERROR mismatched types\n fn d() { dent(ModelU, Blue); }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n fn e() { ModelT.chip_paint(Black); }\n fn f() { ModelT.chip_paint(Blue); } //~ ERROR mismatched types\n fn g() { ModelU.chip_paint(Black); } //~ ERROR mismatched types"}, {"sha": "4ba4925ef1b378c8dd91d9c648c34096c6a029e6", "filename": "src/test/ui/associated-type/associated-type-projection-from-supertrait.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-supertrait.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/associated-type-projection-from-supertrait.rs:33:23\n+  --> $DIR/associated-type-projection-from-supertrait.rs:27:23\n    |\n LL | fn b() { dent(ModelT, Blue); }\n    |                       ^^^^ expected struct `Black`, found struct `Blue`\n@@ -8,7 +8,7 @@ LL | fn b() { dent(ModelT, Blue); }\n               found type `Blue`\n \n error[E0308]: mismatched types\n-  --> $DIR/associated-type-projection-from-supertrait.rs:34:23\n+  --> $DIR/associated-type-projection-from-supertrait.rs:28:23\n    |\n LL | fn c() { dent(ModelU, Black); }\n    |                       ^^^^^ expected struct `Blue`, found struct `Black`\n@@ -17,7 +17,7 @@ LL | fn c() { dent(ModelU, Black); }\n               found type `Black`\n \n error[E0308]: mismatched types\n-  --> $DIR/associated-type-projection-from-supertrait.rs:40:28\n+  --> $DIR/associated-type-projection-from-supertrait.rs:32:28\n    |\n LL | fn f() { ModelT.chip_paint(Blue); }\n    |                            ^^^^ expected struct `Black`, found struct `Blue`\n@@ -26,7 +26,7 @@ LL | fn f() { ModelT.chip_paint(Blue); }\n               found type `Blue`\n \n error[E0308]: mismatched types\n-  --> $DIR/associated-type-projection-from-supertrait.rs:41:28\n+  --> $DIR/associated-type-projection-from-supertrait.rs:33:28\n    |\n LL | fn g() { ModelU.chip_paint(Black); }\n    |                            ^^^^^ expected struct `Blue`, found struct `Black`"}, {"sha": "6b2bbbe2e4fb971632055ec1740587d66bd6c6ef", "filename": "src/test/ui/associated-types/associated-types-binding-to-type-defined-in-supertrait.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -11,22 +11,16 @@ pub trait Car : Vehicle {\n     fn honk(&self) { }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct Black;\n struct ModelT;\n impl Vehicle for ModelT { type Color = Black; }\n impl Car for ModelT { }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct Blue;\n struct ModelU;\n impl Vehicle for ModelU { type Color = Blue; }\n impl Car for ModelU { }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n fn black_car<C:Car<Color=Black>>(c: C) {\n }\n "}, {"sha": "89c48d50cdb65334d40bc14bcb5fb0da926774e4", "filename": "src/test/ui/associated-types/associated-types-binding-to-type-defined-in-supertrait.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-binding-to-type-defined-in-supertrait.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,27 +1,27 @@\n error[E0271]: type mismatch resolving `<ModelT as Vehicle>::Color == Blue`\n-  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:37:10\n+  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:31:10\n    |\n LL | fn b() { blue_car(ModelT); }\n    |          ^^^^^^^^ expected struct `Black`, found struct `Blue`\n    |\n    = note: expected type `Black`\n               found type `Blue`\n note: required by `blue_car`\n-  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:33:1\n+  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:27:1\n    |\n LL | fn blue_car<C:Car<Color=Blue>>(c: C) {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0271]: type mismatch resolving `<ModelU as Vehicle>::Color == Black`\n-  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:38:10\n+  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:32:10\n    |\n LL | fn c() { black_car(ModelU); }\n    |          ^^^^^^^^^ expected struct `Blue`, found struct `Black`\n    |\n    = note: expected type `Blue`\n               found type `Black`\n note: required by `black_car`\n-  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:30:1\n+  --> $DIR/associated-types-binding-to-type-defined-in-supertrait.rs:24:1\n    |\n LL | fn black_car<C:Car<Color=Black>>(c: C) {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "c89f6046e6bf2cae138912276c9110d60ea44cd1", "filename": "src/test/ui/associated-types/associated-types-ref-from-struct.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-ref-from-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-ref-from-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-ref-from-struct.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -9,8 +9,6 @@ trait Test {\n     fn test(&self, value: &Self::V) -> bool;\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct TesterPair<T:Test> {\n     tester: T,\n     value: T::V,\n@@ -26,8 +24,6 @@ impl<T:Test> TesterPair<T> {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct EqU32(u32);\n impl Test for EqU32 {\n     type V = u32;"}, {"sha": "9edae1965ce1609f51706e775585d225a8fbee5c", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,5 +1,5 @@\n #![feature(rustc_attrs, const_transmute)]\n-#![allow(const_err)] // make sure we cannot allow away the errors tested here\n+#![allow(const_err, invalid_value)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n use std::ptr::NonNull;"}, {"sha": "bbab85c2121a5b3fc9963fa84291cd3a92a540b7", "filename": "src/test/ui/consts/const-eval/ub-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,6 +1,6 @@\n // ignore-tidy-linelength\n #![feature(const_transmute)]\n-#![allow(const_err)] // make sure we cannot allow away the errors tested here\n+#![allow(const_err, invalid_value)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n "}, {"sha": "baab14dc161412e5fa34f03f9e578f48f61f5f0e", "filename": "src/test/ui/consts/const-eval/ub-upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,5 +1,5 @@\n #![feature(const_transmute)]\n-#![allow(const_err)] // make sure we cannot allow away the errors tested here\n+#![allow(const_err, invalid_value)] // make sure we cannot allow away the errors tested here\n \n use std::mem;\n "}, {"sha": "88d396101dba23106de9a1daf0e6e3c325e9f8f6", "filename": "src/test/ui/higher-rank-trait-bounds/hrtb-type-outlives.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-type-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-type-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fhrtb-type-outlives.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -14,7 +14,6 @@ fn want_foo<T>()\n {\n }\n \n-///////////////////////////////////////////////////////////////////////////\n // Expressed as a where clause\n \n struct SomeStruct<X> {\n@@ -30,7 +29,6 @@ fn one() {\n     want_foo::<SomeStruct<usize>>();\n }\n \n-///////////////////////////////////////////////////////////////////////////\n // Expressed as shorthand\n \n struct AnotherStruct<X> {"}, {"sha": "004d62ac513ffe86bfc0917c1844cc4dd69284d1", "filename": "src/test/ui/hrtb/hrtb-conflate-regions.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -15,7 +15,6 @@ fn want_foo1<T>()\n {\n }\n \n-///////////////////////////////////////////////////////////////////////////\n // Expressed as a where clause\n \n struct SomeStruct;"}, {"sha": "20265d66c6f43abdc1b8f5ad3f9d58879a18fe46", "filename": "src/test/ui/hrtb/hrtb-conflate-regions.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `for<'a, 'b> SomeStruct: Foo<(&'a isize, &'b isize)>` is not satisfied\n-  --> $DIR/hrtb-conflate-regions.rs:28:10\n+  --> $DIR/hrtb-conflate-regions.rs:27:10\n    |\n LL | fn b() { want_foo2::<SomeStruct>(); }\n    |          ^^^^^^^^^^^^^^^^^^^^^^^ the trait `for<'a, 'b> Foo<(&'a isize, &'b isize)>` is not implemented for `SomeStruct`"}, {"sha": "ce1550568c19dd4c53a5f8273c58b7415ac7b068", "filename": "src/test/ui/impl-trait/bound-normalization-fail.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -8,7 +8,6 @@\n \n // See issue 60414\n \n-/////////////////////////////////////////////\n // Reduction to `impl Trait`\n \n struct Foo<T>(T);\n@@ -33,7 +32,6 @@ mod impl_trait {\n     }\n }\n \n-/////////////////////////////////////////////\n // Same with lifetimes in the trait\n \n mod lifetimes {"}, {"sha": "4811b1e0ff39ebef500c8a0e0eb14d0e8c588f77", "filename": "src/test/ui/impl-trait/bound-normalization-fail.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -7,7 +7,7 @@ LL | #![feature(impl_trait_in_bindings)]\n    = note: `#[warn(incomplete_features)]` on by default\n \n error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as impl_trait::Trait>::Assoc`\n-  --> $DIR/bound-normalization-fail.rs:30:32\n+  --> $DIR/bound-normalization-fail.rs:29:32\n    |\n LL |     fn foo_fail<T: Trait>() -> impl FooLike<Output=T::Assoc> {\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found associated type\n@@ -17,13 +17,13 @@ LL |     fn foo_fail<T: Trait>() -> impl FooLike<Output=T::Assoc> {\n    = note: the return type of a function must have a statically known size\n \n error: `impl Trait` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n-  --> $DIR/bound-normalization-fail.rs:47:41\n+  --> $DIR/bound-normalization-fail.rs:45:41\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output=T::Assoc> {\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n-  --> $DIR/bound-normalization-fail.rs:47:41\n+  --> $DIR/bound-normalization-fail.rs:45:41\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output=T::Assoc> {\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found associated type"}, {"sha": "b0ed4be54b8999cd8487396ba6482cfffc8a2cc6", "filename": "src/test/ui/impl-trait/bound-normalization-pass.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-pass.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -8,7 +8,6 @@\n \n // See issue 60414\n \n-/////////////////////////////////////////////\n // Reduction to `impl Trait`\n \n struct Foo<T>(T);\n@@ -32,7 +31,6 @@ mod impl_trait {\n     }\n }\n \n-/////////////////////////////////////////////\n // Same with lifetimes in the trait\n \n mod lifetimes {\n@@ -59,7 +57,6 @@ mod lifetimes {\n     }\n }\n \n-/////////////////////////////////////////////\n // Reduction using `impl Trait` in bindings\n \n mod impl_trait_in_bindings {\n@@ -80,7 +77,6 @@ mod impl_trait_in_bindings {\n     }\n }\n \n-/////////////////////////////////////////////\n // The same applied to `type Foo = impl Bar`s\n \n mod opaque_types {"}, {"sha": "7c2b0d69c8b2568de550058321ddd25a69600b8b", "filename": "src/test/ui/issues/issue-12028.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fissues%2Fissue-12028.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fissues%2Fissue-12028.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12028.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -17,8 +17,6 @@ trait StreamHasher {\n     fn stream(&self) -> Self::S;\n }\n \n-//////////////////////////////////////////////////////////////////////////////\n-\n trait StreamHash<H: StreamHasher>: Hash<H> {\n     fn input_stream(&self, stream: &mut H::S);\n }"}, {"sha": "24aa88c3fa379f42c3888943a879edfd63d5943f", "filename": "src/test/ui/issues/issue-12028.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,5 +1,5 @@\n error[E0284]: type annotations required: cannot resolve `<_ as StreamHasher>::S == <H as StreamHasher>::S`\n-  --> $DIR/issue-12028.rs:29:14\n+  --> $DIR/issue-12028.rs:27:14\n    |\n LL |         self.input_stream(&mut stream);\n    |              ^^^^^^^^^^^^"}, {"sha": "94da2ca5cab815e2bc2251f8e7a7d8666633dc74", "filename": "src/test/ui/issues/issue-16739.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fissues%2Fissue-16739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fissues%2Fissue-16739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16739.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -16,8 +16,6 @@ impl FnOnce<()> for Foo {\n     extern \"rust-call\" fn call_once(mut self, _: ()) -> u32 { self.call_mut(()) }\n }\n \n-/////////////////////////////////////////////////////////////////////////\n-\n impl FnMut<(u32,)> for Foo {\n     extern \"rust-call\" fn call_mut(&mut self, (x,): (u32,)) -> u32 { self.foo + x }\n }\n@@ -27,8 +25,6 @@ impl FnOnce<(u32,)> for Foo {\n     extern \"rust-call\" fn call_once(mut self, args: (u32,)) -> u32 { self.call_mut(args) }\n }\n \n-/////////////////////////////////////////////////////////////////////////\n-\n impl FnMut<(u32,u32)> for Foo {\n     extern \"rust-call\" fn call_mut(&mut self, (x, y): (u32, u32)) -> u32 { self.foo + x + y }\n }"}, {"sha": "5cf62b869123975f0a7c43568a0f5199c8475e92", "filename": "src/test/ui/lint/uninitialized-zeroed.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -2,11 +2,13 @@\n // This test checks that calling `mem::{uninitialized,zeroed}` with certain types results\n // in a lint.\n \n-#![feature(never_type)]\n+#![feature(never_type, rustc_attrs)]\n #![allow(deprecated)]\n #![deny(invalid_value)]\n \n use std::mem::{self, MaybeUninit};\n+use std::ptr::NonNull;\n+use std::num::NonZeroU32;\n \n enum Void {}\n \n@@ -16,6 +18,11 @@ struct RefPair((&'static i32, i32));\n struct Wrap<T> { wrapped: T }\n enum WrapEnum<T> { Wrapped(T) }\n \n+#[rustc_layout_scalar_valid_range_start(0)]\n+#[rustc_layout_scalar_valid_range_end(128)]\n+#[repr(transparent)]\n+pub(crate) struct NonBig(u64);\n+\n #[allow(unused)]\n fn generic<T: 'static>() {\n     unsafe {\n@@ -29,6 +36,7 @@ fn generic<T: 'static>() {\n \n fn main() {\n     unsafe {\n+        // Things that cannot even be zero.\n         let _val: ! = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: ! = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n@@ -56,11 +64,28 @@ fn main() {\n         let _val: Wrap<(RefPair, i32)> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n         let _val: Wrap<(RefPair, i32)> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n-        // Some types that should work just fine.\n+        let _val: NonNull<i32> = mem::zeroed(); //~ ERROR: does not permit zero-initialization\n+        let _val: NonNull<i32> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        // Things that can be zero, but not uninit.\n+        let _val: bool = mem::zeroed();\n+        let _val: bool = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: Wrap<char> = mem::zeroed();\n+        let _val: Wrap<char> = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        let _val: NonBig = mem::zeroed();\n+        let _val: NonBig = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n+\n+        // Transmute-from-0\n+        let _val: &'static i32 = mem::transmute(0usize); //~ ERROR: does not permit zero-initialization\n+        let _val: &'static [i32] = mem::transmute((0usize, 0usize)); //~ ERROR: does not permit zero-initialization\n+        let _val: NonZeroU32 = mem::transmute(0); //~ ERROR: does not permit zero-initialization\n+\n+        // Some more types that should work just fine.\n         let _val: Option<&'static i32> = mem::zeroed();\n         let _val: Option<fn()> = mem::zeroed();\n         let _val: MaybeUninit<&'static i32> = mem::zeroed();\n-        let _val: bool = mem::zeroed();\n         let _val: i32 = mem::zeroed();\n     }\n }"}, {"sha": "a36a32a39a11b3ab2675883f838ce6bca3ef0e2b", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 125, "deletions": 33, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,5 +1,5 @@\n error: the type `&'static T` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:22:32\n+  --> $DIR/uninitialized-zeroed.rs:29:32\n    |\n LL |         let _val: &'static T = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -15,7 +15,7 @@ LL | #![deny(invalid_value)]\n    = note: References must be non-null\n \n error: the type `&'static T` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:23:32\n+  --> $DIR/uninitialized-zeroed.rs:30:32\n    |\n LL |         let _val: &'static T = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |         let _val: &'static T = mem::uninitialized();\n    = note: References must be non-null\n \n error: the type `Wrap<&'static T>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:25:38\n+  --> $DIR/uninitialized-zeroed.rs:32:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      ^^^^^^^^^^^^^\n@@ -35,13 +35,13 @@ LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<&'static T>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:26:38\n+  --> $DIR/uninitialized-zeroed.rs:33:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n@@ -50,13 +50,13 @@ LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `!` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:32:23\n+  --> $DIR/uninitialized-zeroed.rs:40:23\n    |\n LL |         let _val: ! = mem::zeroed();\n    |                       ^^^^^^^^^^^^^\n@@ -67,7 +67,7 @@ LL |         let _val: ! = mem::zeroed();\n    = note: The never type (`!`) has no valid value\n \n error: the type `!` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:33:23\n+  --> $DIR/uninitialized-zeroed.rs:41:23\n    |\n LL |         let _val: ! = mem::uninitialized();\n    |                       ^^^^^^^^^^^^^^^^^^^^\n@@ -78,7 +78,7 @@ LL |         let _val: ! = mem::uninitialized();\n    = note: The never type (`!`) has no valid value\n \n error: the type `(i32, !)` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:35:30\n+  --> $DIR/uninitialized-zeroed.rs:43:30\n    |\n LL |         let _val: (i32, !) = mem::zeroed();\n    |                              ^^^^^^^^^^^^^\n@@ -89,7 +89,7 @@ LL |         let _val: (i32, !) = mem::zeroed();\n    = note: The never type (`!`) has no valid value\n \n error: the type `(i32, !)` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:36:30\n+  --> $DIR/uninitialized-zeroed.rs:44:30\n    |\n LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              ^^^^^^^^^^^^^^^^^^^^\n@@ -100,7 +100,7 @@ LL |         let _val: (i32, !) = mem::uninitialized();\n    = note: The never type (`!`) has no valid value\n \n error: the type `Void` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:38:26\n+  --> $DIR/uninitialized-zeroed.rs:46:26\n    |\n LL |         let _val: Void = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -111,7 +111,7 @@ LL |         let _val: Void = mem::zeroed();\n    = note: 0-variant enums have no valid value\n \n error: the type `Void` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:39:26\n+  --> $DIR/uninitialized-zeroed.rs:47:26\n    |\n LL |         let _val: Void = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -122,7 +122,7 @@ LL |         let _val: Void = mem::uninitialized();\n    = note: 0-variant enums have no valid value\n \n error: the type `&'static i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:41:34\n+  --> $DIR/uninitialized-zeroed.rs:49:34\n    |\n LL |         let _val: &'static i32 = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -133,7 +133,7 @@ LL |         let _val: &'static i32 = mem::zeroed();\n    = note: References must be non-null\n \n error: the type `&'static i32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:42:34\n+  --> $DIR/uninitialized-zeroed.rs:50:34\n    |\n LL |         let _val: &'static i32 = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -144,7 +144,7 @@ LL |         let _val: &'static i32 = mem::uninitialized();\n    = note: References must be non-null\n \n error: the type `Ref` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:44:25\n+  --> $DIR/uninitialized-zeroed.rs:52:25\n    |\n LL |         let _val: Ref = mem::zeroed();\n    |                         ^^^^^^^^^^^^^\n@@ -153,13 +153,13 @@ LL |         let _val: Ref = mem::zeroed();\n    |                         help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:13:12\n+  --> $DIR/uninitialized-zeroed.rs:15:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `Ref` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:45:25\n+  --> $DIR/uninitialized-zeroed.rs:53:25\n    |\n LL |         let _val: Ref = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -168,13 +168,13 @@ LL |         let _val: Ref = mem::uninitialized();\n    |                         help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:13:12\n+  --> $DIR/uninitialized-zeroed.rs:15:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `fn()` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:47:26\n+  --> $DIR/uninitialized-zeroed.rs:55:26\n    |\n LL |         let _val: fn() = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -185,7 +185,7 @@ LL |         let _val: fn() = mem::zeroed();\n    = note: Function pointers must be non-null\n \n error: the type `fn()` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:48:26\n+  --> $DIR/uninitialized-zeroed.rs:56:26\n    |\n LL |         let _val: fn() = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -196,7 +196,7 @@ LL |         let _val: fn() = mem::uninitialized();\n    = note: Function pointers must be non-null\n \n error: the type `Wrap<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:50:32\n+  --> $DIR/uninitialized-zeroed.rs:58:32\n    |\n LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -205,13 +205,13 @@ LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:51:32\n+  --> $DIR/uninitialized-zeroed.rs:59:32\n    |\n LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -220,13 +220,13 @@ LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `WrapEnum<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:53:36\n+  --> $DIR/uninitialized-zeroed.rs:61:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n@@ -235,13 +235,13 @@ LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this enum field)\n-  --> $DIR/uninitialized-zeroed.rs:17:28\n+  --> $DIR/uninitialized-zeroed.rs:19:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `WrapEnum<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:54:36\n+  --> $DIR/uninitialized-zeroed.rs:62:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n@@ -250,13 +250,13 @@ LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this enum field)\n-  --> $DIR/uninitialized-zeroed.rs:17:28\n+  --> $DIR/uninitialized-zeroed.rs:19:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:56:42\n+  --> $DIR/uninitialized-zeroed.rs:64:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          ^^^^^^^^^^^^^\n@@ -265,13 +265,13 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:14:16\n+  --> $DIR/uninitialized-zeroed.rs:16:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:57:42\n+  --> $DIR/uninitialized-zeroed.rs:65:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          ^^^^^^^^^^^^^^^^^^^^\n@@ -280,10 +280,102 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:14:16\n+  --> $DIR/uninitialized-zeroed.rs:16:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 22 previous errors\n+error: the type `std::ptr::NonNull<i32>` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:67:34\n+   |\n+LL |         let _val: NonNull<i32> = mem::zeroed();\n+   |                                  ^^^^^^^^^^^^^\n+   |                                  |\n+   |                                  this code causes undefined behavior when executed\n+   |                                  help: use `MaybeUninit<T>` instead\n+   |\n+   = note: std::ptr::NonNull<i32> must be non-null\n+\n+error: the type `std::ptr::NonNull<i32>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:68:34\n+   |\n+LL |         let _val: NonNull<i32> = mem::uninitialized();\n+   |                                  ^^^^^^^^^^^^^^^^^^^^\n+   |                                  |\n+   |                                  this code causes undefined behavior when executed\n+   |                                  help: use `MaybeUninit<T>` instead\n+   |\n+   = note: std::ptr::NonNull<i32> must be non-null\n+\n+error: the type `bool` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:72:26\n+   |\n+LL |         let _val: bool = mem::uninitialized();\n+   |                          ^^^^^^^^^^^^^^^^^^^^\n+   |                          |\n+   |                          this code causes undefined behavior when executed\n+   |                          help: use `MaybeUninit<T>` instead\n+   |\n+   = note: Booleans must be `true` or `false`\n+\n+error: the type `Wrap<char>` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:75:32\n+   |\n+LL |         let _val: Wrap<char> = mem::uninitialized();\n+   |                                ^^^^^^^^^^^^^^^^^^^^\n+   |                                |\n+   |                                this code causes undefined behavior when executed\n+   |                                help: use `MaybeUninit<T>` instead\n+   |\n+note: Characters must be a valid unicode codepoint (in this struct field)\n+  --> $DIR/uninitialized-zeroed.rs:18:18\n+   |\n+LL | struct Wrap<T> { wrapped: T }\n+   |                  ^^^^^^^^^^\n+\n+error: the type `NonBig` does not permit being left uninitialized\n+  --> $DIR/uninitialized-zeroed.rs:78:28\n+   |\n+LL |         let _val: NonBig = mem::uninitialized();\n+   |                            ^^^^^^^^^^^^^^^^^^^^\n+   |                            |\n+   |                            this code causes undefined behavior when executed\n+   |                            help: use `MaybeUninit<T>` instead\n+   |\n+   = note: NonBig must be initialized inside its custom valid range\n+\n+error: the type `&'static i32` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:81:34\n+   |\n+LL |         let _val: &'static i32 = mem::transmute(0usize);\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^\n+   |                                  |\n+   |                                  this code causes undefined behavior when executed\n+   |                                  help: use `MaybeUninit<T>` instead\n+   |\n+   = note: References must be non-null\n+\n+error: the type `&'static [i32]` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:82:36\n+   |\n+LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    this code causes undefined behavior when executed\n+   |                                    help: use `MaybeUninit<T>` instead\n+   |\n+   = note: References must be non-null\n+\n+error: the type `std::num::NonZeroU32` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:83:32\n+   |\n+LL |         let _val: NonZeroU32 = mem::transmute(0);\n+   |                                ^^^^^^^^^^^^^^^^^\n+   |                                |\n+   |                                this code causes undefined behavior when executed\n+   |                                help: use `MaybeUninit<T>` instead\n+   |\n+   = note: std::num::NonZeroU32 must be non-null\n+\n+error: aborting due to 30 previous errors\n "}, {"sha": "21d983f192ab6b490ffc34fdeab5165056665714", "filename": "src/test/ui/methods/method-projection.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fmethods%2Fmethod-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fmethods%2Fmethod-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-projection.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -2,9 +2,6 @@\n // Test that we can use method notation to call methods based on a\n // projection bound from a trait. Issue #20469.\n \n-///////////////////////////////////////////////////////////////////////////\n-\n-\n trait MakeString {\n     fn make_string(&self) -> String;\n }\n@@ -21,8 +18,6 @@ impl MakeString for usize {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n trait Foo {\n     type F: MakeString;\n \n@@ -33,8 +28,6 @@ fn foo<F:Foo>(f: &F) -> String {\n     f.get().make_string()\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct SomeStruct {\n     field: isize,\n }\n@@ -47,8 +40,6 @@ impl Foo for SomeStruct {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct SomeOtherStruct {\n     field: usize,\n }"}, {"sha": "d4b67d6b0b07c419a2a72ef63aec4ef7a348473e", "filename": "src/test/ui/proc-macro/auxiliary/gen-macro-rules.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgen-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgen-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fgen-macro-rules.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -0,0 +1,12 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(repro)]\n+pub fn proc_macro_hack_expr(_input: TokenStream) -> TokenStream {\n+    \"macro_rules! m {()=>{}}\".parse().unwrap()\n+}"}, {"sha": "13ad27f9372521acd2dfe32f864efd04526ec21e", "filename": "src/test/ui/proc-macro/gen-macro-rules.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgen-macro-rules.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -0,0 +1,13 @@\n+// Derive macros can generate `macro_rules` items, regression test for issue #63651.\n+\n+// check-pass\n+// aux-build:gen-macro-rules.rs\n+\n+extern crate gen_macro_rules as repro;\n+\n+#[derive(repro::repro)]\n+pub struct S;\n+\n+m!(); // OK\n+\n+fn main() {}"}, {"sha": "eed9934be121dc0bdf5f564f0c51470348403208", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.migrate.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.nll.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:35:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:30:12\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               -- -- lifetime `'b` defined here\n@@ -10,7 +10,7 @@ LL |     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n \n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:57:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:50:12\n    |\n LL | fn with_assoc_sub<'a,'b>() {\n    |                   -- -- lifetime `'b` defined here"}, {"sha": "ed5800940ee3192597abbceea1d05fdba9d45078", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.migrate.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.migrate.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,33 +1,33 @@\n error[E0491]: in type `&'a WithHrAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:35:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:30:12\n    |\n LL |     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 32:15\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:32:15\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 27:15\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:27:15\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 32:18\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:32:18\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 27:18\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:27:18\n    |\n LL | fn with_assoc<'a,'b>() {\n    |                  ^^\n \n error[E0491]: in type `&'a WithHrAssocSub<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:57:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:50:12\n    |\n LL |     let _: &'a WithHrAssocSub<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 53:19\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:53:19\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 46:19\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:46:19\n    |\n LL | fn with_assoc_sub<'a,'b>() {\n    |                   ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 53:22\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:53:22\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 46:22\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:46:22\n    |\n LL | fn with_assoc_sub<'a,'b>() {\n    |                      ^^"}, {"sha": "eed9934be121dc0bdf5f564f0c51470348403208", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.nll.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:35:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:30:12\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               -- -- lifetime `'b` defined here\n@@ -10,7 +10,7 @@ LL |     let _: &'a WithHrAssoc<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n \n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-hrtb.rs:57:12\n+  --> $DIR/regions-outlives-projection-container-hrtb.rs:50:12\n    |\n LL | fn with_assoc_sub<'a,'b>() {\n    |                   -- -- lifetime `'b` defined here"}, {"sha": "cee741184ca2ab68a0ddb8b35bf7864274b13533", "filename": "src/test/ui/regions/regions-outlives-projection-container-hrtb.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-hrtb.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -6,9 +6,6 @@\n \n #![allow(dead_code)]\n \n-\n-///////////////////////////////////////////////////////////////////////////\n-\n pub trait TheTrait<'b> {\n     type TheAssocType;\n }\n@@ -21,8 +18,6 @@ impl<'a,'b> TheTrait<'a> for TheType<'b> {\n     type TheAssocType = &'b ();\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n pub struct WithHrAssoc<T>\n     where for<'a> T : TheTrait<'a>\n {\n@@ -37,8 +32,6 @@ fn with_assoc<'a,'b>() {\n     //[nll]~^^ ERROR lifetime may not live long enough\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n pub trait TheSubTrait : for<'a> TheTrait<'a> {\n }\n "}, {"sha": "8c54d8da0a06395ec758611beed2908be37d665f", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.migrate.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.nll.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-wc.rs:37:12\n+  --> $DIR/regions-outlives-projection-container-wc.rs:33:12\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               -- -- lifetime `'b` defined here"}, {"sha": "152e6c5600c4e63e7ab775abe989d05cd30613f0", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.migrate.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.migrate.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,16 +1,16 @@\n error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container-wc.rs:37:12\n+  --> $DIR/regions-outlives-projection-container-wc.rs:33:12\n    |\n LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 31:15\n-  --> $DIR/regions-outlives-projection-container-wc.rs:31:15\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 27:15\n+  --> $DIR/regions-outlives-projection-container-wc.rs:27:15\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 31:18\n-  --> $DIR/regions-outlives-projection-container-wc.rs:31:18\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 27:18\n+  --> $DIR/regions-outlives-projection-container-wc.rs:27:18\n    |\n LL | fn with_assoc<'a,'b>() {\n    |                  ^^"}, {"sha": "8c54d8da0a06395ec758611beed2908be37d665f", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.nll.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container-wc.rs:37:12\n+  --> $DIR/regions-outlives-projection-container-wc.rs:33:12\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               -- -- lifetime `'b` defined here"}, {"sha": "99965f333907bff77772640989900ecc090fc93d", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -8,8 +8,6 @@\n \n #![allow(dead_code)]\n \n-///////////////////////////////////////////////////////////////////////////\n-\n pub trait TheTrait {\n     type TheAssocType;\n }\n@@ -22,8 +20,6 @@ impl<'b> TheTrait for TheType<'b> {\n     type TheAssocType = &'b ();\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n pub struct WithAssoc<T> where T : TheTrait {\n     m: [T; 0]\n }"}, {"sha": "2cf6e245d19f65a506f84261a087dbefeddb3352", "filename": "src/test/ui/regions/regions-outlives-projection-container.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.nll.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container.rs:40:13\n+  --> $DIR/regions-outlives-projection-container.rs:36:13\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               -- -- lifetime `'b` defined here\n@@ -10,7 +10,7 @@ LL |     let _x: &'a WithAssoc<TheType<'b>> = loop { };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n \n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container.rs:58:13\n+  --> $DIR/regions-outlives-projection-container.rs:54:13\n    |\n LL | fn without_assoc<'a,'b>() {\n    |                  -- -- lifetime `'b` defined here\n@@ -21,7 +21,7 @@ LL |     let _x: &'a WithoutAssoc<TheType<'b>> = loop { };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'b` must outlive `'a`\n \n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container.rs:67:5\n+  --> $DIR/regions-outlives-projection-container.rs:63:5\n    |\n LL | fn call_with_assoc<'a,'b>() {\n    |                    -- -- lifetime `'b` defined here\n@@ -32,7 +32,7 @@ LL |     call::<&'a WithAssoc<TheType<'b>>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'b` must outlive `'a`\n \n error: lifetime may not live long enough\n-  --> $DIR/regions-outlives-projection-container.rs:74:5\n+  --> $DIR/regions-outlives-projection-container.rs:70:5\n    |\n LL | fn call_without_assoc<'a,'b>() {\n    |                       -- -- lifetime `'b` defined here"}, {"sha": "3afc600becb6e4c7309b65b5d2e7ef251b24c1cf", "filename": "src/test/ui/regions/regions-outlives-projection-container.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -5,8 +5,6 @@\n #![allow(dead_code)]\n #![feature(rustc_attrs)]\n \n-///////////////////////////////////////////////////////////////////////////\n-\n pub trait TheTrait {\n     type TheAssocType;\n }\n@@ -19,8 +17,6 @@ impl<'b> TheTrait for TheType<'b> {\n     type TheAssocType = &'b ();\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n pub struct WithAssoc<T:TheTrait> {\n     m: [T; 0]\n }"}, {"sha": "3c1a98a3c018fa589a358ef0dd2ee58d46bbdbb6", "filename": "src/test/ui/regions/regions-outlives-projection-container.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,67 +1,67 @@\n error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container.rs:40:13\n+  --> $DIR/regions-outlives-projection-container.rs:36:13\n    |\n LL |     let _x: &'a WithAssoc<TheType<'b>> = loop { };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 32:15\n-  --> $DIR/regions-outlives-projection-container.rs:32:15\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 28:15\n+  --> $DIR/regions-outlives-projection-container.rs:28:15\n    |\n LL | fn with_assoc<'a,'b>() {\n    |               ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 32:18\n-  --> $DIR/regions-outlives-projection-container.rs:32:18\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 28:18\n+  --> $DIR/regions-outlives-projection-container.rs:28:18\n    |\n LL | fn with_assoc<'a,'b>() {\n    |                  ^^\n \n error[E0491]: in type `&'a WithoutAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container.rs:58:13\n+  --> $DIR/regions-outlives-projection-container.rs:54:13\n    |\n LL |     let _x: &'a WithoutAssoc<TheType<'b>> = loop { };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 54:18\n-  --> $DIR/regions-outlives-projection-container.rs:54:18\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 50:18\n+  --> $DIR/regions-outlives-projection-container.rs:50:18\n    |\n LL | fn without_assoc<'a,'b>() {\n    |                  ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 54:21\n-  --> $DIR/regions-outlives-projection-container.rs:54:21\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 50:21\n+  --> $DIR/regions-outlives-projection-container.rs:50:21\n    |\n LL | fn without_assoc<'a,'b>() {\n    |                     ^^\n \n error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container.rs:67:12\n+  --> $DIR/regions-outlives-projection-container.rs:63:12\n    |\n LL |     call::<&'a WithAssoc<TheType<'b>>>();\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 62:20\n-  --> $DIR/regions-outlives-projection-container.rs:62:20\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 58:20\n+  --> $DIR/regions-outlives-projection-container.rs:58:20\n    |\n LL | fn call_with_assoc<'a,'b>() {\n    |                    ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 62:23\n-  --> $DIR/regions-outlives-projection-container.rs:62:23\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 58:23\n+  --> $DIR/regions-outlives-projection-container.rs:58:23\n    |\n LL | fn call_with_assoc<'a,'b>() {\n    |                       ^^\n \n error[E0491]: in type `&'a WithoutAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container.rs:74:12\n+  --> $DIR/regions-outlives-projection-container.rs:70:12\n    |\n LL |     call::<&'a WithoutAssoc<TheType<'b>>>();\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the pointer is valid for the lifetime 'a as defined on the function body at 71:23\n-  --> $DIR/regions-outlives-projection-container.rs:71:23\n+note: the pointer is valid for the lifetime 'a as defined on the function body at 67:23\n+  --> $DIR/regions-outlives-projection-container.rs:67:23\n    |\n LL | fn call_without_assoc<'a,'b>() {\n    |                       ^^\n-note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 71:26\n-  --> $DIR/regions-outlives-projection-container.rs:71:26\n+note: but the referenced data is only valid for the lifetime 'b as defined on the function body at 67:26\n+  --> $DIR/regions-outlives-projection-container.rs:67:26\n    |\n LL | fn call_without_assoc<'a,'b>() {\n    |                          ^^"}, {"sha": "37005f839d4889225f682689417af88a55fc234d", "filename": "src/test/ui/specialization/defaultimpl/specialization-no-default.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -3,9 +3,7 @@\n // Check a number of scenarios in which one impl tries to override another,\n // without correctly using `default`.\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 1: one layer of specialization, multiple methods, missing `default`\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Foo {\n     fn foo(&self);\n@@ -25,9 +23,7 @@ impl Foo for u32 {\n     fn bar(&self) {} //~ ERROR E0520\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 2: one layer of specialization, missing `default` on associated type\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Bar {\n     type T;\n@@ -41,9 +37,7 @@ impl Bar for u8 {\n     type T = (); //~ ERROR E0520\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 3a: multiple layers of specialization, missing interior `default`\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Baz {\n     fn baz(&self);\n@@ -61,10 +55,8 @@ impl Baz for i32 {\n     fn baz(&self) {} //~ ERROR E0520\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 3b: multiple layers of specialization, missing interior `default`,\n // redundant `default` in bottom layer.\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Redundant {\n     fn redundant(&self);"}, {"sha": "13636b28b126c675f5e54eb7ea75b733a3e0310d", "filename": "src/test/ui/specialization/defaultimpl/specialization-no-default.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-no-default.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,5 +1,5 @@\n error[E0520]: `foo` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:22:5\n+  --> $DIR/specialization-no-default.rs:20:5\n    |\n LL | / impl<T> Foo for T {\n LL | |     fn foo(&self) {}\n@@ -13,7 +13,7 @@ LL |       fn foo(&self) {}\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n \n error[E0520]: `bar` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:25:5\n+  --> $DIR/specialization-no-default.rs:23:5\n    |\n LL | / impl<T> Foo for T {\n LL | |     fn foo(&self) {}\n@@ -27,7 +27,7 @@ LL |       fn bar(&self) {}\n    = note: to specialize, `bar` in the parent `impl` must be marked `default`\n \n error[E0520]: `T` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:41:5\n+  --> $DIR/specialization-no-default.rs:37:5\n    |\n LL | / impl<T> Bar for T {\n LL | |     type T = u8;\n@@ -40,7 +40,7 @@ LL |       type T = ();\n    = note: to specialize, `T` in the parent `impl` must be marked `default`\n \n error[E0520]: `baz` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:61:5\n+  --> $DIR/specialization-no-default.rs:55:5\n    |\n LL | / impl<T: Clone> Baz for T {\n LL | |     fn baz(&self) {}\n@@ -53,7 +53,7 @@ LL |       fn baz(&self) {}\n    = note: to specialize, `baz` in the parent `impl` must be marked `default`\n \n error[E0520]: `redundant` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:82:5\n+  --> $DIR/specialization-no-default.rs:74:5\n    |\n LL | / impl<T: Clone> Redundant for T {\n LL | |     fn redundant(&self) {}"}, {"sha": "57346b26d24ec2d8e85544aee516d8261e75dd1d", "filename": "src/test/ui/specialization/specialization-no-default.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fspecialization%2Fspecialization-no-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fspecialization%2Fspecialization-no-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fspecialization-no-default.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -3,9 +3,7 @@\n // Check a number of scenarios in which one impl tries to override another,\n // without correctly using `default`.\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 1: one layer of specialization, multiple methods, missing `default`\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Foo {\n     fn foo(&self);\n@@ -25,9 +23,7 @@ impl Foo for u32 {\n     fn bar(&self) {} //~ ERROR E0520\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 2: one layer of specialization, missing `default` on associated type\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Bar {\n     type T;\n@@ -41,9 +37,7 @@ impl Bar for u8 {\n     type T = (); //~ ERROR E0520\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 3a: multiple layers of specialization, missing interior `default`\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Baz {\n     fn baz(&self);\n@@ -61,10 +55,8 @@ impl Baz for i32 {\n     fn baz(&self) {} //~ ERROR E0520\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n // Test 3b: multiple layers of specialization, missing interior `default`,\n // redundant `default` in bottom layer.\n-////////////////////////////////////////////////////////////////////////////////\n \n trait Redundant {\n     fn redundant(&self);"}, {"sha": "992e9abbd4ce2e4db90a339393e1dc94e95bf2b9", "filename": "src/test/ui/specialization/specialization-no-default.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fspecialization%2Fspecialization-no-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Fspecialization%2Fspecialization-no-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fspecialization-no-default.stderr?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -1,5 +1,5 @@\n error[E0520]: `foo` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:22:5\n+  --> $DIR/specialization-no-default.rs:20:5\n    |\n LL | / impl<T> Foo for T {\n LL | |     fn foo(&self) {}\n@@ -13,7 +13,7 @@ LL |       fn foo(&self) {}\n    = note: to specialize, `foo` in the parent `impl` must be marked `default`\n \n error[E0520]: `bar` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:25:5\n+  --> $DIR/specialization-no-default.rs:23:5\n    |\n LL | / impl<T> Foo for T {\n LL | |     fn foo(&self) {}\n@@ -27,7 +27,7 @@ LL |       fn bar(&self) {}\n    = note: to specialize, `bar` in the parent `impl` must be marked `default`\n \n error[E0520]: `T` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:41:5\n+  --> $DIR/specialization-no-default.rs:37:5\n    |\n LL | / impl<T> Bar for T {\n LL | |     type T = u8;\n@@ -40,7 +40,7 @@ LL |       type T = ();\n    = note: to specialize, `T` in the parent `impl` must be marked `default`\n \n error[E0520]: `baz` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:61:5\n+  --> $DIR/specialization-no-default.rs:55:5\n    |\n LL | / impl<T: Clone> Baz for T {\n LL | |     fn baz(&self) {}\n@@ -53,7 +53,7 @@ LL |       fn baz(&self) {}\n    = note: to specialize, `baz` in the parent `impl` must be marked `default`\n \n error[E0520]: `redundant` specializes an item from a parent `impl`, but that item is not marked `default`\n-  --> $DIR/specialization-no-default.rs:82:5\n+  --> $DIR/specialization-no-default.rs:74:5\n    |\n LL | / impl<T: Clone> Redundant for T {\n LL | |     fn redundant(&self) {}"}, {"sha": "afdfb96394bd0d8e1c4bc13d1c137ee46ec2760a", "filename": "src/test/ui/traits/traits-conditional-model-fn.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Ftraits%2Ftraits-conditional-model-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd1da18b04afba5dfc09ad1b56df3285f1d039c3/src%2Ftest%2Fui%2Ftraits%2Ftraits-conditional-model-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftraits-conditional-model-fn.rs?ref=bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "patch": "@@ -14,8 +14,6 @@ use go_trait::{Go, GoMut, GoOnce, go, go_mut, go_once};\n use std::rc::Rc;\n use std::cell::Cell;\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct SomeGoableThing {\n     counter: Rc<Cell<isize>>\n }\n@@ -26,8 +24,6 @@ impl Go for SomeGoableThing {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n struct SomeGoOnceableThing {\n     counter: Rc<Cell<isize>>\n }\n@@ -38,8 +34,6 @@ impl GoOnce for SomeGoOnceableThing {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-\n fn main() {\n     let counter = Rc::new(Cell::new(0));\n     let mut x = SomeGoableThing { counter: counter.clone() };"}]}