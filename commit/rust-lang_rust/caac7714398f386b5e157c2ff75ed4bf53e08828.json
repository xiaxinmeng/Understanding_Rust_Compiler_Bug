{"sha": "caac7714398f386b5e157c2ff75ed4bf53e08828", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYWM3NzE0Mzk4ZjM4NmI1ZTE1N2MyZmY3NWVkNGJmNTNlMDg4Mjg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-09T10:21:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-09T10:21:14Z"}, "message": "Merge #9735\n\n9735: Add assist to sort members alphabetically. r=matklad a=vsrs\n\nSupports traits, impls, structs, unions and enums (including inner struct variants). Does not support modules yet.\r\n\r\n```rust\r\nen\u2503um Animal {\r\n  Dog(String, f64),\r\n  Cat { weight: f64, name: String },\r\n}\r\n```\r\n->\r\n```rust\r\nenum Animal {\r\n  Cat { weight: f64, name: String },\r\n  Dog(String, f64),\r\n}\r\n```\r\n---\r\n```rust\r\nenum Animal {\r\n  Dog(String, f64),\r\n  Cat {\u2503 weight: f64, name: String },\r\n}\r\n```\r\n->\r\n```rust\r\nenum Animal {\r\n  Dog(String, f64),\r\n  Cat { name: String, weight: f64 },\r\n}\r\n```\r\n---\r\nMore samples in docs https://github.com/vsrs/rust-analyzer/blob/0b7835619a3ec7fdc5c11e6ab001ad452314a3f2/crates/ide_assists/src/handlers/sort_items.rs#L12-L83.\r\n\r\nRelates #6110\r\n\n\nCo-authored-by: vsrs <vit@conrlab.com>", "tree": {"sha": "7694793ae3252bb71d9554f58d29b638ee8f2946", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7694793ae3252bb71d9554f58d29b638ee8f2946"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caac7714398f386b5e157c2ff75ed4bf53e08828", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhEQGaCRBK7hj4Ov3rIwAAq6kIAB+6Nd1+87iuNXglnl56L7CF\nA/gnxF+IVfkql073H/LAqy6GPBnDwI+/6OHoeAUOqztH58B/Gnn+clbshgZeob6s\n2L5AdyBupLWE26bGgKaM5YcQFmw5PiUrYGNm7lV1OSTKXXawtYeNSm57ZxVWfqcm\nvNDPLBPcEJGR4XL/a7KYk+8W1VknoCadoFht9em8KEugdVsdFxKHNgm0cnnxKnIP\nCKWjs0cBQkXWTnHYYgXINnO0uTOGUdn61SZ/Z4+4go02L9zXW+blrcK5aTQAf8ie\nMkHYbyarbXHGZRJwwx2nDN3gBw5upnvdzVkQqe3wJC+VTuW3tHWF4VrnxGAkKCw=\n=YFsH\n-----END PGP SIGNATURE-----\n", "payload": "tree 7694793ae3252bb71d9554f58d29b638ee8f2946\nparent 70081619294e049eab863ddd0f0a23426b03fe57\nparent cc33b0dc82c119434967aa9609e6a7a08e38cd14\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1628504474 +0000\ncommitter GitHub <noreply@github.com> 1628504474 +0000\n\nMerge #9735\n\n9735: Add assist to sort members alphabetically. r=matklad a=vsrs\n\nSupports traits, impls, structs, unions and enums (including inner struct variants). Does not support modules yet.\r\n\r\n```rust\r\nen\u2503um Animal {\r\n  Dog(String, f64),\r\n  Cat { weight: f64, name: String },\r\n}\r\n```\r\n->\r\n```rust\r\nenum Animal {\r\n  Cat { weight: f64, name: String },\r\n  Dog(String, f64),\r\n}\r\n```\r\n---\r\n```rust\r\nenum Animal {\r\n  Dog(String, f64),\r\n  Cat {\u2503 weight: f64, name: String },\r\n}\r\n```\r\n->\r\n```rust\r\nenum Animal {\r\n  Dog(String, f64),\r\n  Cat { name: String, weight: f64 },\r\n}\r\n```\r\n---\r\nMore samples in docs https://github.com/vsrs/rust-analyzer/blob/0b7835619a3ec7fdc5c11e6ab001ad452314a3f2/crates/ide_assists/src/handlers/sort_items.rs#L12-L83.\r\n\r\nRelates #6110\r\n\n\nCo-authored-by: vsrs <vit@conrlab.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caac7714398f386b5e157c2ff75ed4bf53e08828", "html_url": "https://github.com/rust-lang/rust/commit/caac7714398f386b5e157c2ff75ed4bf53e08828", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caac7714398f386b5e157c2ff75ed4bf53e08828/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70081619294e049eab863ddd0f0a23426b03fe57", "url": "https://api.github.com/repos/rust-lang/rust/commits/70081619294e049eab863ddd0f0a23426b03fe57", "html_url": "https://github.com/rust-lang/rust/commit/70081619294e049eab863ddd0f0a23426b03fe57"}, {"sha": "cc33b0dc82c119434967aa9609e6a7a08e38cd14", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc33b0dc82c119434967aa9609e6a7a08e38cd14", "html_url": "https://github.com/rust-lang/rust/commit/cc33b0dc82c119434967aa9609e6a7a08e38cd14"}], "stats": {"total": 779, "additions": 728, "deletions": 51}, "files": [{"sha": "aa32c698a2b0518367a08fc96e371cdd9dacb75d", "filename": "crates/ide_assists/src/handlers/introduce_named_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs?ref=caac7714398f386b5e157c2ff75ed4bf53e08828", "patch": "@@ -33,9 +33,9 @@ static ASSIST_LABEL: &str = \"Introduce named lifetime\";\n //     }\n // }\n // ```\n-// FIXME: How can we handle renaming any one of multiple anonymous lifetimes?\n-// FIXME: should also add support for the case fun(f: &Foo) -> &$0Foo\n pub(crate) fn introduce_named_lifetime(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    // FIXME: How can we handle renaming any one of multiple anonymous lifetimes?\n+    // FIXME: should also add support for the case fun(f: &Foo) -> &$0Foo\n     let lifetime =\n         ctx.find_node_at_offset::<ast::Lifetime>().filter(|lifetime| lifetime.text() == \"'_\")?;\n     let lifetime_loc = lifetime.lifetime_ident_token()?.text_range();"}, {"sha": "cd4eb7c15e9085ff1ee83b6e9bf3b5b7404d45fd", "filename": "crates/ide_assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=caac7714398f386b5e157c2ff75ed4bf53e08828", "patch": "@@ -20,7 +20,6 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // struct Foo {foo: i32, bar: i32};\n // const test: Foo = Foo {foo: 1, bar: 0}\n // ```\n-//\n pub(crate) fn reorder_fields(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let record = ctx\n         .find_node_at_offset::<ast::RecordExpr>()"}, {"sha": "d398373c3413b342bef7dd3362b40f25dd23d7c4", "filename": "crates/ide_assists/src/handlers/reorder_impl.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freorder_impl.rs?ref=caac7714398f386b5e157c2ff75ed4bf53e08828", "patch": "@@ -8,7 +8,7 @@ use syntax::{\n     ted, AstNode,\n };\n \n-use crate::{AssistContext, AssistId, AssistKind, Assists};\n+use crate::{utils::get_methods, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: reorder_impl\n //\n@@ -44,7 +44,6 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //     fn c() {}\n // }\n // ```\n-//\n pub(crate) fn reorder_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let impl_ast = ctx.find_node_at_offset::<ast::Impl>()?;\n     let items = impl_ast.assoc_item_list()?;\n@@ -76,7 +75,7 @@ pub(crate) fn reorder_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let target = items.syntax().text_range();\n     acc.add(\n         AssistId(\"reorder_impl\", AssistKind::RefactorRewrite),\n-        \"Sort methods\",\n+        \"Sort methods by trait definition\",\n         target,\n         |builder| {\n             let methods = methods.into_iter().map(|fn_| builder.make_mut(fn_)).collect::<Vec<_>>();\n@@ -111,17 +110,6 @@ fn trait_definition(path: &ast::Path, sema: &Semantics<RootDatabase>) -> Option<\n     }\n }\n \n-fn get_methods(items: &ast::AssocItemList) -> Vec<ast::Fn> {\n-    items\n-        .assoc_items()\n-        .flat_map(|i| match i {\n-            ast::AssocItem::Fn(f) => Some(f),\n-            _ => None,\n-        })\n-        .filter(|f| f.name().is_some())\n-        .collect()\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};"}, {"sha": "2ca4a19ec409555f0aadc7e982964cac8b4f80d2", "filename": "crates/ide_assists/src/handlers/sort_items.rs", "status": "added", "additions": 565, "deletions": 0, "changes": 565, "blob_url": "https://github.com/rust-lang/rust/blob/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fsort_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fsort_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fsort_items.rs?ref=caac7714398f386b5e157c2ff75ed4bf53e08828", "patch": "@@ -0,0 +1,565 @@\n+use std::cmp::Ordering;\n+\n+use itertools::Itertools;\n+\n+use syntax::{\n+    ast::{self, NameOwner},\n+    ted, AstNode, TextRange,\n+};\n+\n+use crate::{utils::get_methods, AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: sort_items\n+//\n+// Sorts item members alphabetically: fields, enum variants and methods.\n+//\n+// ```\n+// struct $0Foo$0 { second: u32, first: String }\n+// ```\n+// ->\n+// ```\n+// struct Foo { first: String, second: u32 }\n+// ```\n+// ---\n+// ```\n+// trait $0Bar$0 {\n+//     fn second(&self) -> u32;\n+//     fn first(&self) -> String;\n+// }\n+// ```\n+// ->\n+// ```\n+// trait Bar {\n+//     fn first(&self) -> String;\n+//     fn second(&self) -> u32;\n+// }\n+// ```\n+// ---\n+// ```\n+// struct Baz;\n+// impl $0Baz$0 {\n+//     fn second(&self) -> u32;\n+//     fn first(&self) -> String;\n+// }\n+// ```\n+// ->\n+// ```\n+// struct Baz;\n+// impl Baz {\n+//     fn first(&self) -> String;\n+//     fn second(&self) -> u32;\n+// }\n+// ```\n+// ---\n+// There is a difference between sorting enum variants:\n+//\n+// ```\n+// enum $0Animal$0 {\n+//   Dog(String, f64),\n+//   Cat { weight: f64, name: String },\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Animal {\n+//   Cat { weight: f64, name: String },\n+//   Dog(String, f64),\n+// }\n+// ```\n+// and sorting a single enum struct variant:\n+//\n+// ```\n+// enum Animal {\n+//   Dog(String, f64),\n+//   Cat $0{ weight: f64, name: String }$0,\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Animal {\n+//   Dog(String, f64),\n+//   Cat { name: String, weight: f64 },\n+// }\n+// ```\n+pub(crate) fn sort_items(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    if ctx.frange.range.is_empty() {\n+        cov_mark::hit!(not_applicable_if_no_selection);\n+        return None;\n+    }\n+\n+    if let Some(trait_ast) = ctx.find_node_at_offset::<ast::Trait>() {\n+        add_sort_methods_assist(acc, trait_ast.assoc_item_list()?)\n+    } else if let Some(impl_ast) = ctx.find_node_at_offset::<ast::Impl>() {\n+        add_sort_methods_assist(acc, impl_ast.assoc_item_list()?)\n+    } else if let Some(struct_ast) = ctx.find_node_at_offset::<ast::Struct>() {\n+        match struct_ast.field_list() {\n+            Some(ast::FieldList::RecordFieldList(it)) => add_sort_fields_assist(acc, it),\n+            _ => {\n+                cov_mark::hit!(not_applicable_if_sorted_or_empty_or_single);\n+                None\n+            }\n+        }\n+    } else if let Some(union_ast) = ctx.find_node_at_offset::<ast::Union>() {\n+        add_sort_fields_assist(acc, union_ast.record_field_list()?)\n+    } else if let Some(enum_struct_variant_ast) = ctx.find_node_at_offset::<ast::RecordFieldList>()\n+    {\n+        // should be above enum and below struct\n+        add_sort_fields_assist(acc, enum_struct_variant_ast)\n+    } else if let Some(enum_ast) = ctx.find_node_at_offset::<ast::Enum>() {\n+        add_sort_variants_assist(acc, enum_ast.variant_list()?)\n+    } else {\n+        None\n+    }\n+}\n+\n+trait AddRewrite {\n+    fn add_rewrite<T: AstNode>(\n+        &mut self,\n+        label: &str,\n+        old: Vec<T>,\n+        new: Vec<T>,\n+        target: TextRange,\n+    ) -> Option<()>;\n+}\n+\n+impl AddRewrite for Assists {\n+    fn add_rewrite<T: AstNode>(\n+        &mut self,\n+        label: &str,\n+        old: Vec<T>,\n+        new: Vec<T>,\n+        target: TextRange,\n+    ) -> Option<()> {\n+        self.add(AssistId(\"sort_items\", AssistKind::RefactorRewrite), label, target, |builder| {\n+            let mutable: Vec<_> = old.into_iter().map(|it| builder.make_mut(it)).collect();\n+            mutable\n+                .into_iter()\n+                .zip(new)\n+                .for_each(|(old, new)| ted::replace(old.syntax(), new.clone_for_update().syntax()));\n+        })\n+    }\n+}\n+\n+fn add_sort_methods_assist(acc: &mut Assists, item_list: ast::AssocItemList) -> Option<()> {\n+    let methods = get_methods(&item_list);\n+    let sorted = sort_by_name(&methods);\n+\n+    if methods == sorted {\n+        cov_mark::hit!(not_applicable_if_sorted_or_empty_or_single);\n+        return None;\n+    }\n+\n+    acc.add_rewrite(\"Sort methods alphabetically\", methods, sorted, item_list.syntax().text_range())\n+}\n+\n+fn add_sort_fields_assist(\n+    acc: &mut Assists,\n+    record_field_list: ast::RecordFieldList,\n+) -> Option<()> {\n+    let fields: Vec<_> = record_field_list.fields().collect();\n+    let sorted = sort_by_name(&fields);\n+\n+    if fields == sorted {\n+        cov_mark::hit!(not_applicable_if_sorted_or_empty_or_single);\n+        return None;\n+    }\n+\n+    acc.add_rewrite(\n+        \"Sort fields alphabetically\",\n+        fields,\n+        sorted,\n+        record_field_list.syntax().text_range(),\n+    )\n+}\n+\n+fn add_sort_variants_assist(acc: &mut Assists, variant_list: ast::VariantList) -> Option<()> {\n+    let variants: Vec<_> = variant_list.variants().collect();\n+    let sorted = sort_by_name(&variants);\n+\n+    if variants == sorted {\n+        cov_mark::hit!(not_applicable_if_sorted_or_empty_or_single);\n+        return None;\n+    }\n+\n+    acc.add_rewrite(\n+        \"Sort variants alphabetically\",\n+        variants,\n+        sorted,\n+        variant_list.syntax().text_range(),\n+    )\n+}\n+\n+fn sort_by_name<T: NameOwner + Clone>(initial: &[T]) -> Vec<T> {\n+    initial\n+        .iter()\n+        .cloned()\n+        .sorted_by(|a, b| match (a.name(), b.name()) {\n+            (Some(a), Some(b)) => Ord::cmp(&a.to_string(), &b.to_string()),\n+\n+            // unexpected, but just in case\n+            (None, None) => Ordering::Equal,\n+            (None, Some(_)) => Ordering::Less,\n+            (Some(_), None) => Ordering::Greater,\n+        })\n+        .collect()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn not_applicable_if_no_selection() {\n+        cov_mark::check!(not_applicable_if_no_selection);\n+\n+        check_assist_not_applicable(\n+            sort_items,\n+            r#\"\n+t$0rait Bar {\n+    fn b();\n+    fn a();\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_trait_empty() {\n+        cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);\n+\n+        check_assist_not_applicable(\n+            sort_items,\n+            r#\"\n+t$0rait Bar$0 {\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_impl_empty() {\n+        cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);\n+\n+        check_assist_not_applicable(\n+            sort_items,\n+            r#\"\n+struct Bar;\n+$0impl Bar$0 {\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_struct_empty() {\n+        cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);\n+\n+        check_assist_not_applicable(\n+            sort_items,\n+            r#\"\n+$0struct Bar$0 ;\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_struct_empty2() {\n+        cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);\n+\n+        check_assist_not_applicable(\n+            sort_items,\n+            r#\"\n+$0struct Bar$0 { };\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_enum_empty() {\n+        cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);\n+\n+        check_assist_not_applicable(\n+            sort_items,\n+            r#\"\n+$0enum ZeroVariants$0 {};\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_trait_sorted() {\n+        cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);\n+\n+        check_assist_not_applicable(\n+            sort_items,\n+            r#\"\n+t$0rait Bar$0 {\n+    fn a() {}\n+    fn b() {}\n+    fn c() {}\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_impl_sorted() {\n+        cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);\n+\n+        check_assist_not_applicable(\n+            sort_items,\n+            r#\"\n+struct Bar;\n+$0impl Bar$0 {\n+    fn a() {}\n+    fn b() {}\n+    fn c() {}\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_struct_sorted() {\n+        cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);\n+\n+        check_assist_not_applicable(\n+            sort_items,\n+            r#\"\n+$0struct Bar$0 {\n+    a: u32,\n+    b: u8,\n+    c: u64,\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_union_sorted() {\n+        cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);\n+\n+        check_assist_not_applicable(\n+            sort_items,\n+            r#\"\n+$0union Bar$0 {\n+    a: u32,\n+    b: u8,\n+    c: u64,\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_enum_sorted() {\n+        cov_mark::check!(not_applicable_if_sorted_or_empty_or_single);\n+\n+        check_assist_not_applicable(\n+            sort_items,\n+            r#\"\n+$0enum Bar$0 {\n+    a,\n+    b,\n+    c,\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn sort_trait() {\n+        check_assist(\n+            sort_items,\n+            r#\"\n+$0trait Bar$0 {\n+    fn a() {\n+\n+    }\n+\n+    // comment for c\n+    fn c() {}\n+    fn z() {}\n+    fn b() {}\n+}\n+        \"#,\n+            r#\"\n+trait Bar {\n+    fn a() {\n+\n+    }\n+\n+    fn b() {}\n+    // comment for c\n+    fn c() {}\n+    fn z() {}\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn sort_impl() {\n+        check_assist(\n+            sort_items,\n+            r#\"\n+struct Bar;\n+$0impl Bar$0 {\n+    fn c() {}\n+    fn a() {}\n+    /// long\n+    /// doc\n+    /// comment\n+    fn z() {}\n+    fn d() {}\n+}\n+        \"#,\n+            r#\"\n+struct Bar;\n+impl Bar {\n+    fn a() {}\n+    fn c() {}\n+    fn d() {}\n+    /// long\n+    /// doc\n+    /// comment\n+    fn z() {}\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn sort_struct() {\n+        check_assist(\n+            sort_items,\n+            r#\"\n+$0struct Bar$0 {\n+    b: u8,\n+    a: u32,\n+    c: u64,\n+}\n+        \"#,\n+            r#\"\n+struct Bar {\n+    a: u32,\n+    b: u8,\n+    c: u64,\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn sort_generic_struct_with_lifetime() {\n+        check_assist(\n+            sort_items,\n+            r#\"\n+$0struct Bar<'a,$0 T> {\n+    d: &'a str,\n+    b: u8,\n+    a: T,\n+    c: u64,\n+}\n+        \"#,\n+            r#\"\n+struct Bar<'a, T> {\n+    a: T,\n+    b: u8,\n+    c: u64,\n+    d: &'a str,\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn sort_struct_fields_diff_len() {\n+        check_assist(\n+            sort_items,\n+            r#\"\n+$0struct Bar $0{\n+    aaa: u8,\n+    a: usize,\n+    b: u8,\n+}\n+        \"#,\n+            r#\"\n+struct Bar {\n+    a: usize,\n+    aaa: u8,\n+    b: u8,\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn sort_union() {\n+        check_assist(\n+            sort_items,\n+            r#\"\n+$0union Bar$0 {\n+    b: u8,\n+    a: u32,\n+    c: u64,\n+}\n+        \"#,\n+            r#\"\n+union Bar {\n+    a: u32,\n+    b: u8,\n+    c: u64,\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn sort_enum() {\n+        check_assist(\n+            sort_items,\n+            r#\"\n+$0enum Bar $0{\n+    d{ first: u32, second: usize},\n+    b = 14,\n+    a,\n+    c(u32, usize),\n+}\n+        \"#,\n+            r#\"\n+enum Bar {\n+    a,\n+    b = 14,\n+    c(u32, usize),\n+    d{ first: u32, second: usize},\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn sort_struct_enum_variant() {\n+        check_assist(\n+            sort_items,\n+            r#\"\n+enum Bar {\n+    d$0{ second: usize, first: u32 }$0,\n+    b = 14,\n+    a,\n+    c(u32, usize),\n+}\n+        \"#,\n+            r#\"\n+enum Bar {\n+    d{ first: u32, second: usize },\n+    b = 14,\n+    a,\n+    c(u32, usize),\n+}\n+        \"#,\n+        )\n+    }\n+}"}, {"sha": "bb9d5dd9915d2a842340859dfe5a42c2267e13c3", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=caac7714398f386b5e157c2ff75ed4bf53e08828", "patch": "@@ -111,6 +111,7 @@ mod handlers {\n     mod replace_qualified_name_with_use;\n     mod replace_string_with_char;\n     mod split_import;\n+    mod sort_items;\n     mod toggle_ignore;\n     mod unmerge_use;\n     mod unwrap_block;\n@@ -183,6 +184,7 @@ mod handlers {\n             replace_impl_trait_with_generic::replace_impl_trait_with_generic,\n             replace_let_with_if_let::replace_let_with_if_let,\n             replace_qualified_name_with_use::replace_qualified_name_with_use,\n+            sort_items::sort_items,\n             split_import::split_import,\n             toggle_ignore::toggle_ignore,\n             unmerge_use::unmerge_use,"}, {"sha": "794bd0f3d7b10cf905c1aae98c29df6e52d61229", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=caac7714398f386b5e157c2ff75ed4bf53e08828", "patch": "@@ -1545,6 +1545,97 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_sort_items() {\n+    check_doc_test(\n+        \"sort_items\",\n+        r#####\"\n+struct $0Foo$0 { second: u32, first: String }\n+\"#####,\n+        r#####\"\n+struct Foo { first: String, second: u32 }\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_sort_items_1() {\n+    check_doc_test(\n+        \"sort_items\",\n+        r#####\"\n+trait $0Bar$0 {\n+    fn second(&self) -> u32;\n+    fn first(&self) -> String;\n+}\n+\"#####,\n+        r#####\"\n+trait Bar {\n+    fn first(&self) -> String;\n+    fn second(&self) -> u32;\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_sort_items_2() {\n+    check_doc_test(\n+        \"sort_items\",\n+        r#####\"\n+struct Baz;\n+impl $0Baz$0 {\n+    fn second(&self) -> u32;\n+    fn first(&self) -> String;\n+}\n+\"#####,\n+        r#####\"\n+struct Baz;\n+impl Baz {\n+    fn first(&self) -> String;\n+    fn second(&self) -> u32;\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_sort_items_3() {\n+    check_doc_test(\n+        \"sort_items\",\n+        r#####\"\n+enum $0Animal$0 {\n+  Dog(String, f64),\n+  Cat { weight: f64, name: String },\n+}\n+\"#####,\n+        r#####\"\n+enum Animal {\n+  Cat { weight: f64, name: String },\n+  Dog(String, f64),\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_sort_items_4() {\n+    check_doc_test(\n+        \"sort_items\",\n+        r#####\"\n+enum Animal {\n+  Dog(String, f64),\n+  Cat $0{ weight: f64, name: String }$0,\n+}\n+\"#####,\n+        r#####\"\n+enum Animal {\n+  Dog(String, f64),\n+  Cat { name: String, weight: f64 },\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_split_import() {\n     check_doc_test("}, {"sha": "2af1de66fadbe0205d188ac604360ae09add8a11", "filename": "crates/ide_assists/src/tests/sourcegen.rs", "status": "modified", "additions": 55, "deletions": 34, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Ftests%2Fsourcegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Ftests%2Fsourcegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fsourcegen.rs?ref=caac7714398f386b5e157c2ff75ed4bf53e08828", "patch": "@@ -16,8 +16,11 @@ use super::check_doc_test;\n \"\n         .to_string();\n         for assist in assists.iter() {\n-            let test = format!(\n-                r######\"\n+            for (idx, section) in assist.sections.iter().enumerate() {\n+                let test_id =\n+                    if idx == 0 { assist.id.clone() } else { format!(\"{}_{}\", &assist.id, idx) };\n+                let test = format!(\n+                    r######\"\n #[test]\n fn doctest_{}() {{\n     check_doc_test(\n@@ -27,13 +30,14 @@ r#####\"\n {}\"#####)\n }}\n \"######,\n-                assist.id,\n-                assist.id,\n-                reveal_hash_comments(&assist.before),\n-                reveal_hash_comments(&assist.after)\n-            );\n+                    &test_id,\n+                    &assist.id,\n+                    reveal_hash_comments(&section.before),\n+                    reveal_hash_comments(&section.after)\n+                );\n \n-            buf.push_str(&test)\n+                buf.push_str(&test)\n+            }\n         }\n         let buf = sourcegen::add_preamble(\"sourcegen_assists_docs\", sourcegen::reformat(buf));\n         sourcegen::ensure_file_contents(\n@@ -55,14 +59,18 @@ r#####\"\n         fs::write(dst, contents).unwrap();\n     }\n }\n+#[derive(Debug)]\n+struct Section {\n+    doc: String,\n+    before: String,\n+    after: String,\n+}\n \n #[derive(Debug)]\n struct Assist {\n     id: String,\n     location: sourcegen::Location,\n-    doc: String,\n-    before: String,\n-    after: String,\n+    sections: Vec<Section>,\n }\n \n impl Assist {\n@@ -89,22 +97,28 @@ impl Assist {\n                     \"invalid assist id: {:?}\",\n                     id\n                 );\n-                let mut lines = block.contents.iter();\n+                let mut lines = block.contents.iter().peekable();\n+                let location = sourcegen::Location { file: path.to_path_buf(), line: block.line };\n+                let mut assist = Assist { id, location, sections: Vec::new() };\n \n-                let doc = take_until(lines.by_ref(), \"```\").trim().to_string();\n-                assert!(\n-                    doc.chars().next().unwrap().is_ascii_uppercase() && doc.ends_with('.'),\n-                    \"\\n\\n{}: assist docs should be proper sentences, with capitalization and a full stop at the end.\\n\\n{}\\n\\n\",\n-                    id, doc,\n-                );\n+                while lines.peek().is_some() {\n+                    let doc = take_until(lines.by_ref(), \"```\").trim().to_string();\n+                    assert!(\n+                        (doc.chars().next().unwrap().is_ascii_uppercase() && doc.ends_with('.')) || assist.sections.len() > 0,\n+                        \"\\n\\n{}: assist docs should be proper sentences, with capitalization and a full stop at the end.\\n\\n{}\\n\\n\",\n+                        &assist.id, doc,\n+                    );\n \n-                let before = take_until(lines.by_ref(), \"```\");\n+                    let before = take_until(lines.by_ref(), \"```\");\n \n-                assert_eq!(lines.next().unwrap().as_str(), \"->\");\n-                assert_eq!(lines.next().unwrap().as_str(), \"```\");\n-                let after = take_until(lines.by_ref(), \"```\");\n-                let location = sourcegen::Location { file: path.to_path_buf(), line: block.line };\n-                acc.push(Assist { id, location, doc, before, after })\n+                    assert_eq!(lines.next().unwrap().as_str(), \"->\");\n+                    assert_eq!(lines.next().unwrap().as_str(), \"```\");\n+                    let after = take_until(lines.by_ref(), \"```\");\n+\n+                    assist.sections.push(Section { doc, before, after });\n+                }\n+\n+                acc.push(assist)\n             }\n         }\n \n@@ -123,13 +137,19 @@ impl Assist {\n \n impl fmt::Display for Assist {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let before = self.before.replace(\"$0\", \"\u2503\"); // Unicode pseudo-graphics bar\n-        let after = self.after.replace(\"$0\", \"\u2503\");\n-        writeln!(\n+        let _ = writeln!(\n             f,\n             \"[discrete]\\n=== `{}`\n-**Source:** {}\n+**Source:** {}\",\n+            self.id, self.location,\n+        );\n \n+        for section in &self.sections {\n+            let before = section.before.replace(\"$0\", \"\u2503\"); // Unicode pseudo-graphics bar\n+            let after = section.after.replace(\"$0\", \"\u2503\");\n+            let _ = writeln!(\n+                f,\n+                \"\n {}\n \n .Before\n@@ -139,12 +159,13 @@ impl fmt::Display for Assist {\n .After\n ```rust\n {}```\",\n-            self.id,\n-            self.location,\n-            self.doc,\n-            hide_hash_comments(&before),\n-            hide_hash_comments(&after)\n-        )\n+                section.doc,\n+                hide_hash_comments(&before),\n+                hide_hash_comments(&after)\n+            );\n+        }\n+\n+        Ok(())\n     }\n }\n "}, {"sha": "bcd7501724ff2ea3e84450f2233230fa75a854b0", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caac7714398f386b5e157c2ff75ed4bf53e08828/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=caac7714398f386b5e157c2ff75ed4bf53e08828", "patch": "@@ -516,3 +516,14 @@ fn ty_ctor(ty: &String, ctor: &str) -> Option<String> {\n     let res = ty.to_string().strip_prefix(ctor)?.strip_prefix('<')?.strip_suffix('>')?.to_string();\n     Some(res)\n }\n+\n+pub(crate) fn get_methods(items: &ast::AssocItemList) -> Vec<ast::Fn> {\n+    items\n+        .assoc_items()\n+        .flat_map(|i| match i {\n+            ast::AssocItem::Fn(f) => Some(f),\n+            _ => None,\n+        })\n+        .filter(|f| f.name().is_some())\n+        .collect()\n+}"}]}