{"sha": "51001b35bd4079ea40536a264e054eec9b4f11bd", "node_id": "C_kwDOAAsO6NoAKDUxMDAxYjM1YmQ0MDc5ZWE0MDUzNmEyNjRlMDU0ZWVjOWI0ZjExYmQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-09T12:38:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-09T12:38:32Z"}, "message": "Rollup merge of #92608 - petrochenkov:doctrscope3, r=CraftSpider\n\nrustdoc: Introduce a resolver cache for sharing data between early doc link resolution and later passes\n\nThe refactoring parts of https://github.com/rust-lang/rust/pull/88679, shouldn't cause any slowdowns.\nr? `@jyn514`", "tree": {"sha": "14be46fbc02db5e31f03fcd737c154bd637535ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14be46fbc02db5e31f03fcd737c154bd637535ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51001b35bd4079ea40536a264e054eec9b4f11bd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh2tdICRBK7hj4Ov3rIwAA1eEIAHVMumDBpS88AzPAQJoAeRUy\n/FGb3rFtPy5pPNsdXY7bznD6fUolEQvYay3P7Re+HiO3tcx8HxX7zDfRd9Sytzhw\nOX4+XRuE9fKMI24P0Nj9ZBwPMGwpKD1AiUZbqXUo1ib9pwF9FGIvkcPWPWUQaT2f\nwE4itTw51xjmXLaAqxnYDksl0Q7YtEIqZ+5lrwZY/cnt+/7RPYTJWV+zb0PVUxEO\nYkhjNd6pz0e7b+czo2soFOYzucd01eXN5OOx7X+u88fuwc3P9gMaxqqJnGF6i7IM\nCdOhh95wu/f7+RErDp4Wj8pWIeERyLHAWw6UQ3jPiCknYnnMzZrYCT04fAeqgNE=\n=0AwJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 14be46fbc02db5e31f03fcd737c154bd637535ec\nparent b681dc2af419c5b7f200e44a3604a8dab9ebe3a6\nparent 5acd1f91a01eacbe1f7feccf6f1c6775d3c4d1b4\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1641731912 +0100\ncommitter GitHub <noreply@github.com> 1641731912 +0100\n\nRollup merge of #92608 - petrochenkov:doctrscope3, r=CraftSpider\n\nrustdoc: Introduce a resolver cache for sharing data between early doc link resolution and later passes\n\nThe refactoring parts of https://github.com/rust-lang/rust/pull/88679, shouldn't cause any slowdowns.\nr? `@jyn514`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51001b35bd4079ea40536a264e054eec9b4f11bd", "html_url": "https://github.com/rust-lang/rust/commit/51001b35bd4079ea40536a264e054eec9b4f11bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51001b35bd4079ea40536a264e054eec9b4f11bd/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b681dc2af419c5b7f200e44a3604a8dab9ebe3a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6", "html_url": "https://github.com/rust-lang/rust/commit/b681dc2af419c5b7f200e44a3604a8dab9ebe3a6"}, {"sha": "5acd1f91a01eacbe1f7feccf6f1c6775d3c4d1b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5acd1f91a01eacbe1f7feccf6f1c6775d3c4d1b4", "html_url": "https://github.com/rust-lang/rust/commit/5acd1f91a01eacbe1f7feccf6f1c6775d3c4d1b4"}], "stats": {"total": 549, "additions": 290, "deletions": 259}, "files": [{"sha": "f54e68ed4da26b5f9f3011fb6708de3aba363a3b", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/51001b35bd4079ea40536a264e054eec9b4f11bd/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51001b35bd4079ea40536a264e054eec9b4f11bd/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=51001b35bd4079ea40536a264e054eec9b4f11bd", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_middle::hir::exports::Export;\n use rustc_middle::middle::exported_symbols::ExportedSymbol;\n use rustc_middle::middle::stability::DeprecationEntry;\n+use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::{self, TyCtxt, Visibility};\n use rustc_session::cstore::{CrateSource, CrateStore, ForeignModule};\n@@ -187,8 +188,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     extra_filename => { cdata.root.extra_filename.clone() }\n \n     traits_in_crate => { tcx.arena.alloc_from_iter(cdata.get_traits()) }\n-    all_trait_implementations => { tcx.arena.alloc_from_iter(cdata.get_trait_impls()) }\n-\n     implementations_of_trait => { cdata.get_implementations_of_trait(tcx, other) }\n \n     visibility => { cdata.get_visibility(def_id.index) }\n@@ -468,6 +467,17 @@ impl CStore {\n     ) -> Span {\n         self.get_crate_data(cnum).get_proc_macro_quoted_span(id, sess)\n     }\n+\n+    pub fn traits_in_crate_untracked(&self, cnum: CrateNum) -> Vec<DefId> {\n+        self.get_crate_data(cnum).get_traits().collect()\n+    }\n+\n+    pub fn trait_impls_in_crate_untracked(\n+        &self,\n+        cnum: CrateNum,\n+    ) -> Vec<(DefId, Option<SimplifiedType>)> {\n+        self.get_crate_data(cnum).get_trait_impls().collect()\n+    }\n }\n \n impl CrateStore for CStore {"}, {"sha": "b6ffb92c53099c50d51a63331ba2fdf4e82251cf", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51001b35bd4079ea40536a264e054eec9b4f11bd/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51001b35bd4079ea40536a264e054eec9b4f11bd/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=51001b35bd4079ea40536a264e054eec9b4f11bd", "patch": "@@ -1442,13 +1442,6 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    /// Given a crate, look up all trait impls in that crate.\n-    /// Return `(impl_id, self_ty)`.\n-    query all_trait_implementations(_: CrateNum) -> &'tcx [(DefId, Option<SimplifiedType>)] {\n-        desc { \"looking up all (?) trait implementations\" }\n-        separate_provide_extern\n-    }\n-\n     query is_dllimport_foreign_item(def_id: DefId) -> bool {\n         desc { |tcx| \"is_dllimport_foreign_item({})\", tcx.def_path_str(def_id) }\n     }"}, {"sha": "eafc74b9945baf21b485c226eb36cd738213643f", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 101, "deletions": 100, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=51001b35bd4079ea40536a264e054eec9b4f11bd", "patch": "@@ -19,118 +19,119 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n \n         trace!(\"get_blanket_impls({:?})\", ty);\n         let mut impls = Vec::new();\n-        for trait_def_id in self.cx.tcx.all_traits() {\n-            if !self.cx.cache.access_levels.is_public(trait_def_id)\n-                || self.cx.generated_synthetics.get(&(ty, trait_def_id)).is_some()\n-            {\n-                continue;\n-            }\n-            // NOTE: doesn't use `for_each_relevant_impl` to avoid looking at anything besides blanket impls\n-            let trait_impls = self.cx.tcx.trait_impls_of(trait_def_id);\n-            for &impl_def_id in trait_impls.blanket_impls() {\n-                trace!(\n-                    \"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n-                    trait_def_id,\n-                    impl_def_id\n-                );\n-                let trait_ref = self.cx.tcx.impl_trait_ref(impl_def_id).unwrap();\n-                let is_param = matches!(trait_ref.self_ty().kind(), ty::Param(_));\n-                let may_apply = is_param && self.cx.tcx.infer_ctxt().enter(|infcx| {\n-                    let substs = infcx.fresh_substs_for_item(DUMMY_SP, item_def_id);\n-                    let ty = ty.subst(infcx.tcx, substs);\n-                    let param_env = param_env.subst(infcx.tcx, substs);\n+        self.cx.with_all_traits(|cx, all_traits| {\n+            for &trait_def_id in all_traits {\n+                if !cx.cache.access_levels.is_public(trait_def_id)\n+                    || cx.generated_synthetics.get(&(ty, trait_def_id)).is_some()\n+                {\n+                    continue;\n+                }\n+                // NOTE: doesn't use `for_each_relevant_impl` to avoid looking at anything besides blanket impls\n+                let trait_impls = cx.tcx.trait_impls_of(trait_def_id);\n+                for &impl_def_id in trait_impls.blanket_impls() {\n+                    trace!(\n+                        \"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n+                        trait_def_id,\n+                        impl_def_id\n+                    );\n+                    let trait_ref = cx.tcx.impl_trait_ref(impl_def_id).unwrap();\n+                    let is_param = matches!(trait_ref.self_ty().kind(), ty::Param(_));\n+                    let may_apply = is_param && cx.tcx.infer_ctxt().enter(|infcx| {\n+                        let substs = infcx.fresh_substs_for_item(DUMMY_SP, item_def_id);\n+                        let ty = ty.subst(infcx.tcx, substs);\n+                        let param_env = param_env.subst(infcx.tcx, substs);\n \n-                    let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n-                    let trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n+                        let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+                        let trait_ref = trait_ref.subst(infcx.tcx, impl_substs);\n \n-                    // Require the type the impl is implemented on to match\n-                    // our type, and ignore the impl if there was a mismatch.\n-                    let cause = traits::ObligationCause::dummy();\n-                    let eq_result = infcx.at(&cause, param_env).eq(trait_ref.self_ty(), ty);\n-                    if let Ok(InferOk { value: (), obligations }) = eq_result {\n-                        // FIXME(eddyb) ignoring `obligations` might cause false positives.\n-                        drop(obligations);\n+                        // Require the type the impl is implemented on to match\n+                        // our type, and ignore the impl if there was a mismatch.\n+                        let cause = traits::ObligationCause::dummy();\n+                        let eq_result = infcx.at(&cause, param_env).eq(trait_ref.self_ty(), ty);\n+                        if let Ok(InferOk { value: (), obligations }) = eq_result {\n+                            // FIXME(eddyb) ignoring `obligations` might cause false positives.\n+                            drop(obligations);\n \n-                        trace!(\n-                            \"invoking predicate_may_hold: param_env={:?}, trait_ref={:?}, ty={:?}\",\n-                            param_env,\n-                            trait_ref,\n-                            ty\n-                        );\n-                        let predicates = self\n-                            .cx\n-                            .tcx\n-                            .predicates_of(impl_def_id)\n-                            .instantiate(self.cx.tcx, impl_substs)\n-                            .predicates\n-                            .into_iter()\n-                            .chain(Some(\n-                                ty::Binder::dummy(trait_ref)\n-                                    .to_poly_trait_predicate()\n-                                    .map_bound(ty::PredicateKind::Trait)\n-                                    .to_predicate(infcx.tcx),\n-                            ));\n-                        for predicate in predicates {\n-                            debug!(\"testing predicate {:?}\", predicate);\n-                            let obligation = traits::Obligation::new(\n-                                traits::ObligationCause::dummy(),\n+                            trace!(\n+                                \"invoking predicate_may_hold: param_env={:?}, trait_ref={:?}, ty={:?}\",\n                                 param_env,\n-                                predicate,\n+                                trait_ref,\n+                                ty\n                             );\n-                            match infcx.evaluate_obligation(&obligation) {\n-                                Ok(eval_result) if eval_result.may_apply() => {}\n-                                Err(traits::OverflowError::Canonical) => {}\n-                                Err(traits::OverflowError::ErrorReporting) => {}\n-                                _ => {\n-                                    return false;\n+                            let predicates = cx\n+                                .tcx\n+                                .predicates_of(impl_def_id)\n+                                .instantiate(cx.tcx, impl_substs)\n+                                .predicates\n+                                .into_iter()\n+                                .chain(Some(\n+                                    ty::Binder::dummy(trait_ref)\n+                                        .to_poly_trait_predicate()\n+                                        .map_bound(ty::PredicateKind::Trait)\n+                                        .to_predicate(infcx.tcx),\n+                                ));\n+                            for predicate in predicates {\n+                                debug!(\"testing predicate {:?}\", predicate);\n+                                let obligation = traits::Obligation::new(\n+                                    traits::ObligationCause::dummy(),\n+                                    param_env,\n+                                    predicate,\n+                                );\n+                                match infcx.evaluate_obligation(&obligation) {\n+                                    Ok(eval_result) if eval_result.may_apply() => {}\n+                                    Err(traits::OverflowError::Canonical) => {}\n+                                    Err(traits::OverflowError::ErrorReporting) => {}\n+                                    _ => {\n+                                        return false;\n+                                    }\n                                 }\n                             }\n+                            true\n+                        } else {\n+                            false\n                         }\n-                        true\n-                    } else {\n-                        false\n+                    });\n+                    debug!(\n+                        \"get_blanket_impls: found applicable impl: {} for trait_ref={:?}, ty={:?}\",\n+                        may_apply, trait_ref, ty\n+                    );\n+                    if !may_apply {\n+                        continue;\n                     }\n-                });\n-                debug!(\n-                    \"get_blanket_impls: found applicable impl: {} for trait_ref={:?}, ty={:?}\",\n-                    may_apply, trait_ref, ty\n-                );\n-                if !may_apply {\n-                    continue;\n-                }\n \n-                self.cx.generated_synthetics.insert((ty, trait_def_id));\n+                    cx.generated_synthetics.insert((ty, trait_def_id));\n \n-                impls.push(Item {\n-                    name: None,\n-                    attrs: Default::default(),\n-                    visibility: Inherited,\n-                    def_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n-                    kind: box ImplItem(Impl {\n-                        unsafety: hir::Unsafety::Normal,\n-                        generics: clean_ty_generics(\n-                            self.cx,\n-                            self.cx.tcx.generics_of(impl_def_id),\n-                            self.cx.tcx.explicit_predicates_of(impl_def_id),\n-                        ),\n-                        // FIXME(eddyb) compute both `trait_` and `for_` from\n-                        // the post-inference `trait_ref`, as it's more accurate.\n-                        trait_: Some(trait_ref.clean(self.cx)),\n-                        for_: ty.clean(self.cx),\n-                        items: self\n-                            .cx\n-                            .tcx\n-                            .associated_items(impl_def_id)\n-                            .in_definition_order()\n-                            .map(|x| x.clean(self.cx))\n-                            .collect::<Vec<_>>(),\n-                        polarity: ty::ImplPolarity::Positive,\n-                        kind: ImplKind::Blanket(box trait_ref.self_ty().clean(self.cx)),\n-                    }),\n-                    cfg: None,\n-                });\n+                    impls.push(Item {\n+                        name: None,\n+                        attrs: Default::default(),\n+                        visibility: Inherited,\n+                        def_id: ItemId::Blanket { impl_id: impl_def_id, for_: item_def_id },\n+                        kind: box ImplItem(Impl {\n+                            unsafety: hir::Unsafety::Normal,\n+                            generics: clean_ty_generics(\n+                                cx,\n+                                cx.tcx.generics_of(impl_def_id),\n+                                cx.tcx.explicit_predicates_of(impl_def_id),\n+                            ),\n+                            // FIXME(eddyb) compute both `trait_` and `for_` from\n+                            // the post-inference `trait_ref`, as it's more accurate.\n+                            trait_: Some(trait_ref.clean(cx)),\n+                            for_: ty.clean(cx),\n+                            items: cx\n+                                .tcx\n+                                .associated_items(impl_def_id)\n+                                .in_definition_order()\n+                                .map(|x| x.clean(cx))\n+                                .collect::<Vec<_>>(),\n+                            polarity: ty::ImplPolarity::Positive,\n+                            kind: ImplKind::Blanket(box trait_ref.self_ty().clean(cx)),\n+                        }),\n+                        cfg: None,\n+                    });\n+                }\n             }\n-        }\n+        });\n+\n         impls\n     }\n }"}, {"sha": "a8101845fb647fc8aeec6c6eee455b3b2c5e2ad8", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=51001b35bd4079ea40536a264e054eec9b4f11bd", "patch": "@@ -291,6 +291,7 @@ crate fn build_impls(\n     attrs: Option<Attrs<'_>>,\n     ret: &mut Vec<clean::Item>,\n ) {\n+    let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_inherent_impls\");\n     let tcx = cx.tcx;\n \n     // for each implementation of an item represented by `did`, build the clean::Item for that impl\n@@ -338,7 +339,7 @@ crate fn build_impl(\n         return;\n     }\n \n-    let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_extern_trait_impl\");\n+    let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_impl\");\n \n     let tcx = cx.tcx;\n     let associated_trait = tcx.impl_trait_ref(did);"}, {"sha": "f0e9b716081ac7b31a7246060ecbe0f1d96d1ca9", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=51001b35bd4079ea40536a264e054eec9b4f11bd", "patch": "@@ -179,6 +179,7 @@ crate fn build_deref_target_impls(cx: &mut DocContext<'_>, items: &[Item], ret:\n         };\n \n         if let Some(prim) = target.primitive_type() {\n+            let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_primitive_inherent_impls\");\n             for &did in prim.impls(tcx).iter().filter(|did| !did.is_local()) {\n                 inline::build_impl(cx, None, did, None, ret);\n             }"}, {"sha": "22f59d39799c4fbb56353affc95856af16f2ea47", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 34, "deletions": 56, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=51001b35bd4079ea40536a264e054eec9b4f11bd", "patch": "@@ -1,30 +1,23 @@\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n-use rustc_driver::abort_on_err;\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n use rustc_feature::UnstableFeatures;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::HirId;\n-use rustc_hir::{\n-    intravisit::{self, NestedVisitorMap, Visitor},\n-    Path,\n-};\n-use rustc_interface::{interface, Queries};\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::{HirId, Path};\n+use rustc_interface::interface;\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_resolve as resolve;\n-use rustc_resolve::Namespace::TypeNS;\n use rustc_session::config::{self, CrateType, ErrorOutputType};\n use rustc_session::lint;\n use rustc_session::DiagnosticOutput;\n use rustc_session::Session;\n-use rustc_span::def_id::CRATE_DEF_INDEX;\n-use rustc_span::source_map;\n use rustc_span::symbol::sym;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::{source_map, Span};\n \n use std::cell::RefCell;\n use std::lazy::SyncLazy;\n@@ -39,14 +32,20 @@ use crate::passes::{self, Condition::*};\n \n crate use rustc_session::config::{DebuggingOptions, Input, Options};\n \n+crate struct ResolverCaches {\n+    pub all_traits: Option<Vec<DefId>>,\n+    pub all_trait_impls: Option<Vec<DefId>>,\n+}\n+\n crate struct DocContext<'tcx> {\n     crate tcx: TyCtxt<'tcx>,\n     /// Name resolver. Used for intra-doc links.\n     ///\n     /// The `Rc<RefCell<...>>` wrapping is needed because that is what's returned by\n-    /// [`Queries::expansion()`].\n+    /// [`rustc_interface::Queries::expansion()`].\n     // FIXME: see if we can get rid of this RefCell somehow\n     crate resolver: Rc<RefCell<interface::BoxedResolver>>,\n+    crate resolver_caches: ResolverCaches,\n     /// Used for normalization.\n     ///\n     /// Most of this logic is copied from rustc_lint::late.\n@@ -123,6 +122,18 @@ impl<'tcx> DocContext<'tcx> {\n             _ => None,\n         }\n     }\n+\n+    crate fn with_all_traits(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n+        let all_traits = self.resolver_caches.all_traits.take();\n+        f(self, all_traits.as_ref().expect(\"`all_traits` are already borrowed\"));\n+        self.resolver_caches.all_traits = all_traits;\n+    }\n+\n+    crate fn with_all_trait_impls(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n+        let all_trait_impls = self.resolver_caches.all_trait_impls.take();\n+        f(self, all_trait_impls.as_ref().expect(\"`all_trait_impls` are already borrowed\"));\n+        self.resolver_caches.all_trait_impls = all_trait_impls;\n+    }\n }\n \n /// Creates a new diagnostic `Handler` that can be used to emit warnings and errors.\n@@ -284,49 +295,10 @@ crate fn create_config(\n     }\n }\n \n-crate fn create_resolver<'a>(\n-    externs: config::Externs,\n-    queries: &Queries<'a>,\n-    sess: &Session,\n-) -> Rc<RefCell<interface::BoxedResolver>> {\n-    let (krate, resolver, _) = &*abort_on_err(queries.expansion(), sess).peek();\n-    let resolver = resolver.clone();\n-\n-    let resolver = crate::passes::collect_intra_doc_links::load_intra_link_crates(resolver, krate);\n-\n-    // FIXME: somehow rustdoc is still missing crates even though we loaded all\n-    // the known necessary crates. Load them all unconditionally until we find a way to fix this.\n-    // DO NOT REMOVE THIS without first testing on the reproducer in\n-    // https://github.com/jyn514/objr/commit/edcee7b8124abf0e4c63873e8422ff81beb11ebb\n-    let extern_names: Vec<String> = externs\n-        .iter()\n-        .filter(|(_, entry)| entry.add_prelude)\n-        .map(|(name, _)| name)\n-        .cloned()\n-        .collect();\n-    resolver.borrow_mut().access(|resolver| {\n-        sess.time(\"load_extern_crates\", || {\n-            for extern_name in &extern_names {\n-                debug!(\"loading extern crate {}\", extern_name);\n-                if let Err(()) = resolver\n-                    .resolve_str_path_error(\n-                        DUMMY_SP,\n-                        extern_name,\n-                        TypeNS,\n-                        LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id(),\n-                  ) {\n-                    warn!(\"unable to resolve external crate {} (do you have an unused `--extern` crate?)\", extern_name)\n-                  }\n-            }\n-        });\n-    });\n-\n-    resolver\n-}\n-\n crate fn run_global_ctxt(\n     tcx: TyCtxt<'_>,\n     resolver: Rc<RefCell<interface::BoxedResolver>>,\n+    resolver_caches: ResolverCaches,\n     show_coverage: bool,\n     render_options: RenderOptions,\n     output_format: OutputFormat,\n@@ -355,23 +327,29 @@ crate fn run_global_ctxt(\n     });\n     rustc_passes::stability::check_unused_or_stable_features(tcx);\n \n+    let auto_traits = resolver_caches\n+        .all_traits\n+        .as_ref()\n+        .expect(\"`all_traits` are already borrowed\")\n+        .iter()\n+        .copied()\n+        .filter(|&trait_def_id| tcx.trait_is_auto(trait_def_id))\n+        .collect();\n     let access_levels = AccessLevels {\n         map: tcx.privacy_access_levels(()).map.iter().map(|(k, v)| (k.to_def_id(), *v)).collect(),\n     };\n \n     let mut ctxt = DocContext {\n         tcx,\n         resolver,\n+        resolver_caches,\n         param_env: ParamEnv::empty(),\n         external_traits: Default::default(),\n         active_extern_traits: Default::default(),\n         substs: Default::default(),\n         impl_trait_bounds: Default::default(),\n         generated_synthetics: Default::default(),\n-        auto_traits: tcx\n-            .all_traits()\n-            .filter(|&trait_def_id| tcx.trait_is_auto(trait_def_id))\n-            .collect(),\n+        auto_traits,\n         module_trait_cache: FxHashMap::default(),\n         cache: Cache::new(access_levels, render_options.document_private),\n         inlined: FxHashSet::default(),"}, {"sha": "d7741c4fde2391a0cb75c3e8c44d3c71f13b2cce", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=51001b35bd4079ea40536a264e054eec9b4f11bd", "patch": "@@ -82,6 +82,7 @@ use rustc_session::getopts;\n use rustc_session::{early_error, early_warn};\n \n use crate::clean::utils::DOC_RUST_LANG_ORG_CHANNEL;\n+use crate::passes::collect_intra_doc_links;\n \n /// A macro to create a FxHashMap.\n ///\n@@ -798,7 +799,15 @@ fn main_options(options: config::Options) -> MainResult {\n             // We need to hold on to the complete resolver, so we cause everything to be\n             // cloned for the analysis passes to use. Suboptimal, but necessary in the\n             // current architecture.\n-            let resolver = core::create_resolver(externs, queries, sess);\n+            // FIXME(#83761): Resolver cloning can lead to inconsistencies between data in the\n+            // two copies because one of the copies can be modified after `TyCtxt` construction.\n+            let (resolver, resolver_caches) = {\n+                let (krate, resolver, _) = &*abort_on_err(queries.expansion(), sess).peek();\n+                let resolver_caches = resolver.borrow_mut().access(|resolver| {\n+                    collect_intra_doc_links::early_resolve_intra_doc_links(resolver, krate, externs)\n+                });\n+                (resolver.clone(), resolver_caches)\n+            };\n \n             if sess.diagnostic().has_errors_or_lint_errors() {\n                 sess.fatal(\"Compilation failed, aborting rustdoc\");\n@@ -811,6 +820,7 @@ fn main_options(options: config::Options) -> MainResult {\n                     core::run_global_ctxt(\n                         tcx,\n                         resolver,\n+                        resolver_caches,\n                         show_coverage,\n                         render_options,\n                         output_format,"}, {"sha": "49ff4517a4eb01d4f6b3ab8f48b95b9940d55b17", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=51001b35bd4079ea40536a264e054eec9b4f11bd", "patch": "@@ -38,7 +38,7 @@ use crate::passes::Pass;\n use crate::visit::DocVisitor;\n \n mod early;\n-crate use early::load_intra_link_crates;\n+crate use early::early_resolve_intra_doc_links;\n \n crate const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n     name: \"collect-intra-doc-links\","}, {"sha": "31d6ac44a9460c732ee288d4750c8915dc363d13", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 91, "deletions": 53, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=51001b35bd4079ea40536a264e054eec9b4f11bd", "patch": "@@ -1,98 +1,136 @@\n-use ast::visit;\n-use rustc_ast as ast;\n+use crate::clean;\n+use crate::core::ResolverCaches;\n+use crate::html::markdown::markdown_links;\n+use crate::passes::collect_intra_doc_links::preprocess_link;\n+\n+use rustc_ast::visit::{self, AssocCtxt, Visitor};\n+use rustc_ast::{self as ast, ItemKind};\n+use rustc_ast_lowering::ResolverAstLowering;\n use rustc_hir::def::Namespace::TypeNS;\n-use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n-use rustc_interface::interface;\n-use rustc_span::Span;\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n+use rustc_resolve::Resolver;\n+use rustc_session::config::Externs;\n+use rustc_span::{Span, DUMMY_SP};\n \n-use std::cell::RefCell;\n use std::mem;\n-use std::rc::Rc;\n-\n-type Resolver = Rc<RefCell<interface::BoxedResolver>>;\n-// Letting the resolver escape at the end of the function leads to inconsistencies between the\n-// crates the TyCtxt sees and the resolver sees (because the resolver could load more crates\n-// after escaping). Hopefully `IntraLinkCrateLoader` gets all the crates we need ...\n-crate fn load_intra_link_crates(resolver: Resolver, krate: &ast::Crate) -> Resolver {\n-    let mut loader = IntraLinkCrateLoader { current_mod: CRATE_DEF_ID, resolver };\n-    // `walk_crate` doesn't visit the crate itself for some reason.\n+\n+crate fn early_resolve_intra_doc_links(\n+    resolver: &mut Resolver<'_>,\n+    krate: &ast::Crate,\n+    externs: Externs,\n+) -> ResolverCaches {\n+    let mut loader = IntraLinkCrateLoader {\n+        resolver,\n+        current_mod: CRATE_DEF_ID,\n+        all_traits: Default::default(),\n+        all_trait_impls: Default::default(),\n+    };\n+\n+    // Overridden `visit_item` below doesn't apply to the crate root,\n+    // so we have to visit its attributes and exports separately.\n     loader.load_links_in_attrs(&krate.attrs, krate.span);\n     visit::walk_crate(&mut loader, krate);\n-    loader.resolver\n+    loader.fill_resolver_caches();\n+\n+    // FIXME: somehow rustdoc is still missing crates even though we loaded all\n+    // the known necessary crates. Load them all unconditionally until we find a way to fix this.\n+    // DO NOT REMOVE THIS without first testing on the reproducer in\n+    // https://github.com/jyn514/objr/commit/edcee7b8124abf0e4c63873e8422ff81beb11ebb\n+    for (extern_name, _) in externs.iter().filter(|(_, entry)| entry.add_prelude) {\n+        let _ = loader.resolver.resolve_str_path_error(\n+            DUMMY_SP,\n+            extern_name,\n+            TypeNS,\n+            CRATE_DEF_ID.to_def_id(),\n+        );\n+    }\n+\n+    ResolverCaches {\n+        all_traits: Some(loader.all_traits),\n+        all_trait_impls: Some(loader.all_trait_impls),\n+    }\n }\n \n-struct IntraLinkCrateLoader {\n+struct IntraLinkCrateLoader<'r, 'ra> {\n+    resolver: &'r mut Resolver<'ra>,\n     current_mod: LocalDefId,\n-    resolver: Rc<RefCell<interface::BoxedResolver>>,\n+    all_traits: Vec<DefId>,\n+    all_trait_impls: Vec<DefId>,\n }\n \n-impl IntraLinkCrateLoader {\n-    fn load_links_in_attrs(&mut self, attrs: &[ast::Attribute], span: Span) {\n-        use crate::html::markdown::markdown_links;\n-        use crate::passes::collect_intra_doc_links::preprocess_link;\n+impl IntraLinkCrateLoader<'_, '_> {\n+    fn fill_resolver_caches(&mut self) {\n+        for cnum in self.resolver.cstore().crates_untracked() {\n+            let all_traits = self.resolver.cstore().traits_in_crate_untracked(cnum);\n+            let all_trait_impls = self.resolver.cstore().trait_impls_in_crate_untracked(cnum);\n \n-        // FIXME: this probably needs to consider inlining\n-        let attrs = crate::clean::Attributes::from_ast(attrs, None);\n+            self.all_traits.extend(all_traits);\n+            self.all_trait_impls.extend(all_trait_impls.into_iter().map(|(def_id, _)| def_id));\n+        }\n+    }\n+\n+    fn load_links_in_attrs(&mut self, attrs: &[ast::Attribute], span: Span) {\n+        // FIXME: this needs to consider export inlining.\n+        let attrs = clean::Attributes::from_ast(attrs, None);\n         for (parent_module, doc) in attrs.collapsed_doc_value_by_module_level() {\n-            debug!(?doc);\n-            for link in markdown_links(doc.as_str()) {\n-                debug!(?link.link);\n+            let module_id = parent_module.unwrap_or(self.current_mod.to_def_id());\n+\n+            for link in markdown_links(&doc.as_str()) {\n                 let path_str = if let Some(Ok(x)) = preprocess_link(&link) {\n                     x.path_str\n                 } else {\n                     continue;\n                 };\n-                self.resolver.borrow_mut().access(|resolver| {\n-                    let _ = resolver.resolve_str_path_error(\n-                        span,\n-                        &path_str,\n-                        TypeNS,\n-                        parent_module.unwrap_or_else(|| self.current_mod.to_def_id()),\n-                    );\n-                });\n+                let _ = self.resolver.resolve_str_path_error(span, &path_str, TypeNS, module_id);\n             }\n         }\n     }\n }\n \n-impl visit::Visitor<'_> for IntraLinkCrateLoader {\n-    fn visit_foreign_item(&mut self, item: &ast::ForeignItem) {\n-        self.load_links_in_attrs(&item.attrs, item.span);\n-        visit::walk_foreign_item(self, item)\n-    }\n-\n+impl Visitor<'_> for IntraLinkCrateLoader<'_, '_> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        use rustc_ast_lowering::ResolverAstLowering;\n-\n-        if let ast::ItemKind::Mod(..) = item.kind {\n-            let new_mod =\n-                self.resolver.borrow_mut().access(|resolver| resolver.local_def_id(item.id));\n-            let old_mod = mem::replace(&mut self.current_mod, new_mod);\n+        if let ItemKind::Mod(..) = item.kind {\n+            let old_mod = mem::replace(&mut self.current_mod, self.resolver.local_def_id(item.id));\n \n             self.load_links_in_attrs(&item.attrs, item.span);\n             visit::walk_item(self, item);\n \n             self.current_mod = old_mod;\n         } else {\n+            match item.kind {\n+                ItemKind::Trait(..) => {\n+                    self.all_traits.push(self.resolver.local_def_id(item.id).to_def_id());\n+                }\n+                ItemKind::Impl(box ast::Impl { of_trait: Some(..), .. }) => {\n+                    self.all_trait_impls.push(self.resolver.local_def_id(item.id).to_def_id());\n+                }\n+                _ => {}\n+            }\n             self.load_links_in_attrs(&item.attrs, item.span);\n             visit::walk_item(self, item);\n         }\n     }\n \n-    // NOTE: if doc-comments are ever allowed on function parameters, this will have to implement `visit_param` too.\n-\n-    fn visit_assoc_item(&mut self, item: &ast::AssocItem, ctxt: visit::AssocCtxt) {\n+    fn visit_assoc_item(&mut self, item: &ast::AssocItem, ctxt: AssocCtxt) {\n         self.load_links_in_attrs(&item.attrs, item.span);\n         visit::walk_assoc_item(self, item, ctxt)\n     }\n \n-    fn visit_field_def(&mut self, field: &ast::FieldDef) {\n-        self.load_links_in_attrs(&field.attrs, field.span);\n-        visit::walk_field_def(self, field)\n+    fn visit_foreign_item(&mut self, item: &ast::ForeignItem) {\n+        self.load_links_in_attrs(&item.attrs, item.span);\n+        visit::walk_foreign_item(self, item)\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant) {\n         self.load_links_in_attrs(&v.attrs, v.span);\n         visit::walk_variant(self, v)\n     }\n+\n+    fn visit_field_def(&mut self, field: &ast::FieldDef) {\n+        self.load_links_in_attrs(&field.attrs, field.span);\n+        visit::walk_field_def(self, field)\n+    }\n+\n+    // NOTE: if doc-comments are ever allowed on other nodes (e.g. function parameters),\n+    // then this will have to implement other visitor methods too.\n }"}, {"sha": "66ac612ea37c40d0011d8ca00598fb31c6f300c0", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51001b35bd4079ea40536a264e054eec9b4f11bd/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=51001b35bd4079ea40536a264e054eec9b4f11bd", "patch": "@@ -34,26 +34,28 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n \n     let mut new_items = Vec::new();\n \n-    for &cnum in cx.tcx.crates(()).iter() {\n-        for &(did, _) in cx.tcx.all_trait_implementations(cnum).iter() {\n-            inline::build_impl(cx, None, did, None, &mut new_items);\n+    // External trait impls.\n+    cx.with_all_trait_impls(|cx, all_trait_impls| {\n+        let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_extern_trait_impls\");\n+        for &impl_def_id in all_trait_impls.iter().skip_while(|def_id| def_id.is_local()) {\n+            inline::build_impl(cx, None, impl_def_id, None, &mut new_items);\n         }\n-    }\n+    });\n \n     // Also try to inline primitive impls from other crates.\n-    for &def_id in PrimitiveType::all_impls(cx.tcx).values().flatten() {\n-        if !def_id.is_local() {\n-            cx.tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n+    cx.tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n+        for &def_id in PrimitiveType::all_impls(cx.tcx).values().flatten() {\n+            if !def_id.is_local() {\n                 inline::build_impl(cx, None, def_id, None, &mut new_items);\n \n                 // FIXME(eddyb) is this `doc(hidden)` check needed?\n                 if !cx.tcx.is_doc_hidden(def_id) {\n                     let impls = get_auto_trait_and_blanket_impls(cx, def_id);\n                     new_items.extend(impls.filter(|i| cx.inlined.insert(i.def_id)));\n                 }\n-            });\n+            }\n         }\n-    }\n+    });\n \n     let mut cleaner = BadImplStripper { prims, items: crate_items };\n     let mut type_did_to_deref_target: FxHashMap<DefId, &Type> = FxHashMap::default();\n@@ -126,36 +128,33 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n         }\n     });\n \n-    // `tcx.crates(())` doesn't include the local crate, and `tcx.all_trait_implementations`\n-    // doesn't work with it anyway, so pull them from the HIR map instead\n-    let mut extra_attrs = Vec::new();\n-    for trait_did in cx.tcx.all_traits() {\n-        for &impl_did in cx.tcx.hir().trait_impls(trait_did) {\n-            let impl_did = impl_did.to_def_id();\n-            cx.tcx.sess.prof.generic_activity(\"build_local_trait_impl\").run(|| {\n-                let mut parent = cx.tcx.parent(impl_did);\n-                while let Some(did) = parent {\n-                    extra_attrs.extend(\n-                        cx.tcx\n-                            .get_attrs(did)\n-                            .iter()\n-                            .filter(|attr| attr.has_name(sym::doc))\n-                            .filter(|attr| {\n-                                if let Some([attr]) = attr.meta_item_list().as_deref() {\n-                                    attr.has_name(sym::cfg)\n-                                } else {\n-                                    false\n-                                }\n-                            })\n-                            .cloned(),\n-                    );\n-                    parent = cx.tcx.parent(did);\n-                }\n-                inline::build_impl(cx, None, impl_did, Some(&extra_attrs), &mut new_items);\n-                extra_attrs.clear();\n-            });\n+    // Local trait impls.\n+    cx.with_all_trait_impls(|cx, all_trait_impls| {\n+        let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_local_trait_impls\");\n+        let mut attr_buf = Vec::new();\n+        for &impl_def_id in all_trait_impls.iter().take_while(|def_id| def_id.is_local()) {\n+            let mut parent = cx.tcx.parent(impl_def_id);\n+            while let Some(did) = parent {\n+                attr_buf.extend(\n+                    cx.tcx\n+                        .get_attrs(did)\n+                        .iter()\n+                        .filter(|attr| attr.has_name(sym::doc))\n+                        .filter(|attr| {\n+                            if let Some([attr]) = attr.meta_item_list().as_deref() {\n+                                attr.has_name(sym::cfg)\n+                            } else {\n+                                false\n+                            }\n+                        })\n+                        .cloned(),\n+                );\n+                parent = cx.tcx.parent(did);\n+            }\n+            inline::build_impl(cx, None, impl_def_id, Some(&attr_buf), &mut new_items);\n+            attr_buf.clear();\n         }\n-    }\n+    });\n \n     if let ModuleItem(Module { items, .. }) = &mut *krate.module.kind {\n         items.extend(synth_impls);"}]}