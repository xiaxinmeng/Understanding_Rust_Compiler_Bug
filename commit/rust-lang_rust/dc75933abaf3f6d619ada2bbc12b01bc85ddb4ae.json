{"sha": "dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNzU5MzNhYmFmM2Y2ZDYxOWFkYTJiYmMxMmIwMWJjODVkZGI0YWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-15T13:14:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-15T13:14:26Z"}, "message": "Auto merge of #36491 - Manishearth:rollup, r=Manishearth\n\nRollup of 9 pull requests\n\n- Successful merges: #36384, #36405, #36425, #36429, #36438, #36454, #36459, #36461, #36463\n- Failed merges: #36444", "tree": {"sha": "034d03910e6757b5455e0792aacf4ed021c72383", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/034d03910e6757b5455e0792aacf4ed021c72383"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "html_url": "https://github.com/rust-lang/rust/commit/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2c64d16906dbb29763d6cbf022164a09247ef9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2c64d16906dbb29763d6cbf022164a09247ef9f", "html_url": "https://github.com/rust-lang/rust/commit/e2c64d16906dbb29763d6cbf022164a09247ef9f"}, {"sha": "ec08128882b165a93b3fd1f99c9606ad5e09b3dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec08128882b165a93b3fd1f99c9606ad5e09b3dc", "html_url": "https://github.com/rust-lang/rust/commit/ec08128882b165a93b3fd1f99c9606ad5e09b3dc"}], "stats": {"total": 2376, "additions": 1399, "deletions": 977}, "files": [{"sha": "0b800cacfc19adbd41909051c8c233b1ef5f83f1", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -113,10 +113,23 @@ pub trait Clone : Sized {\n     }\n }\n \n-// FIXME(aburka): this method is used solely by #[derive] to\n-// assert that every component of a type implements Clone.\n+// FIXME(aburka): these structs are used solely by #[derive] to\n+// assert that every component of a type implements Clone or Copy.\n //\n-// This should never be called by user code.\n+// These structs should never appear in user code.\n+#[doc(hidden)]\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"derive_clone_copy\",\n+           reason = \"deriving hack, should not be public\",\n+           issue = \"0\")]\n+pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: ::marker::PhantomData<T> }\n+#[doc(hidden)]\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"derive_clone_copy\",\n+           reason = \"deriving hack, should not be public\",\n+           issue = \"0\")]\n+pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T> }\n+#[cfg(stage0)]\n #[doc(hidden)]\n #[inline(always)]\n #[unstable(feature = \"derive_clone_copy\","}, {"sha": "f990a27e52b3190b8a00fd6840b7ad75ee546f62", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -129,7 +129,7 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// This trait can be used with `#[derive]`. When `derive`d, because `Eq` has\n /// no extra methods, it is only informing the compiler that this is an\n /// equivalence relation rather than a partial equivalence relation. Note that\n-/// the `derive` strategy requires all fields are `PartialEq`, which isn't\n+/// the `derive` strategy requires all fields are `Eq`, which isn't\n /// always desired.\n ///\n /// ## How can I implement `Eq`?\n@@ -165,6 +165,17 @@ pub trait Eq: PartialEq<Self> {\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n+// FIXME: this struct is used solely by #[derive] to\n+// assert that every component of a type implements Eq.\n+//\n+// This struct should never appear in user code.\n+#[doc(hidden)]\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"derive_eq\",\n+           reason = \"deriving hack, should not be public\",\n+           issue = \"0\")]\n+pub struct AssertParamIsEq<T: Eq + ?Sized> { _field: ::marker::PhantomData<T> }\n+\n /// An `Ordering` is the result of a comparison between two values.\n ///\n /// # Examples"}, {"sha": "d1df56905df2401cdb3d6d48923dc404f1fb59d4", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -520,8 +520,8 @@ impl<T> ops::Index<usize> for [T] {\n     type Output = T;\n \n     fn index(&self, index: usize) -> &T {\n-        assert!(index < self.len());\n-        unsafe { self.get_unchecked(index) }\n+        // NB built-in indexing\n+        &(*self)[index]\n     }\n }\n \n@@ -530,8 +530,8 @@ impl<T> ops::Index<usize> for [T] {\n impl<T> ops::IndexMut<usize> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: usize) -> &mut T {\n-        assert!(index < self.len());\n-        unsafe { self.get_unchecked_mut(index) }\n+        // NB built-in indexing\n+        &mut (*self)[index]\n     }\n }\n "}, {"sha": "39fc50666a8ce73f1a7403131c61397b45317208", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -830,6 +830,33 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n+    // Clear the \"obligations in snapshot\" flag, invoke the closure,\n+    // then restore the flag to its original value. This flag is a\n+    // debugging measure designed to detect cases where we start a\n+    // snapshot, create type variables, register obligations involving\n+    // those type variables in the fulfillment cx, and then have to\n+    // unroll the snapshot, leaving \"dangling type variables\" behind.\n+    // In such cases, the flag will be set by the fulfillment cx, and\n+    // an assertion will fail when rolling the snapshot back.  Very\n+    // useful, much better than grovelling through megabytes of\n+    // RUST_LOG output.\n+    //\n+    // HOWEVER, in some cases the flag is wrong. In particular, we\n+    // sometimes create a \"mini-fulfilment-cx\" in which we enroll\n+    // obligations. As long as this fulfillment cx is fully drained\n+    // before we return, this is not a problem, as there won't be any\n+    // escaping obligations in the main cx. In those cases, you can\n+    // use this function.\n+    pub fn save_and_restore_obligations_in_snapshot_flag<F, R>(&self, func: F) -> R\n+        where F: FnOnce(&Self) -> R\n+    {\n+        let flag = self.obligations_in_snapshot.get();\n+        self.obligations_in_snapshot.set(false);\n+        let result = func(self);\n+        self.obligations_in_snapshot.set(flag);\n+        result\n+    }\n+\n     fn start_snapshot(&self) -> CombinedSnapshot {\n         debug!(\"start_snapshot()\");\n "}, {"sha": "b2c293a290ab39238ee8dd7af21480b6d0eb9c16", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -39,6 +39,7 @@ use std::rc::Rc;\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n+use syntax::ext::base::LoadedMacro;\n use syntax::ptr::P;\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n@@ -492,6 +493,9 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n+pub trait MacroLoader {\n+     fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n+}\n \n /// Metadata encoding and decoding can make use of thread-local encoding and\n /// decoding contexts. These allow implementers of serialize::Encodable and"}, {"sha": "49686d63ee43b8d288275d48770cae3429d50467", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -21,7 +21,7 @@ use util::nodemap::{NodeMap, FnvHashMap};\n use util::common::duration_to_secs_str;\n use mir::transform as mir_pass;\n \n-use syntax::ast::{NodeId, Name};\n+use syntax::ast::NodeId;\n use errors::{self, DiagnosticBuilder};\n use errors::emitter::{Emitter, EmitterWriter};\n use syntax::json::JsonEmitter;\n@@ -39,7 +39,7 @@ use llvm;\n \n use std::path::{Path, PathBuf};\n use std::cell::{self, Cell, RefCell};\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::env;\n use std::ffi::CString;\n use std::rc::Rc;\n@@ -96,10 +96,6 @@ pub struct Session {\n     pub injected_allocator: Cell<Option<ast::CrateNum>>,\n     pub injected_panic_runtime: Cell<Option<ast::CrateNum>>,\n \n-    /// Names of all bang-style macros and syntax extensions\n-    /// available in this crate\n-    pub available_macros: RefCell<HashSet<Name>>,\n-\n     /// Map from imported macro spans (which consist of\n     /// the localized span for the macro body) to the\n     /// macro name and defintion span in the source crate.\n@@ -552,7 +548,6 @@ pub fn build_session_(sopts: config::Options,\n         next_node_id: Cell::new(1),\n         injected_allocator: Cell::new(None),\n         injected_panic_runtime: Cell::new(None),\n-        available_macros: RefCell::new(HashSet::new()),\n         imported_macro_spans: RefCell::new(HashMap::new()),\n         incr_comp_session: RefCell::new(IncrCompSession::NotInitialized),\n         perf_stats: PerfStats {"}, {"sha": "2f63526bf6c270d493b32329d3c3827e1c9a644d", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -203,32 +203,34 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     // attempt to prove all of the predicates for impl2 given those for impl1\n     // (which are packed up in penv)\n \n-    let mut fulfill_cx = FulfillmentContext::new();\n-    for oblig in obligations.into_iter() {\n-        fulfill_cx.register_predicate_obligation(&infcx, oblig);\n-    }\n-    match fulfill_cx.select_all_or_error(infcx) {\n-        Err(errors) => {\n-            // no dice!\n-            debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n-                    {:?}\",\n-                   source_trait_ref,\n-                   target_trait_ref,\n-                   errors,\n-                   infcx.parameter_environment.caller_bounds);\n-            Err(())\n+    infcx.save_and_restore_obligations_in_snapshot_flag(|infcx| {\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        for oblig in obligations.into_iter() {\n+            fulfill_cx.register_predicate_obligation(&infcx, oblig);\n         }\n+        match fulfill_cx.select_all_or_error(infcx) {\n+            Err(errors) => {\n+                // no dice!\n+                debug!(\"fulfill_implication: for impls on {:?} and {:?}, \\\n+                        could not fulfill: {:?} given {:?}\",\n+                       source_trait_ref,\n+                       target_trait_ref,\n+                       errors,\n+                       infcx.parameter_environment.caller_bounds);\n+                Err(())\n+            }\n \n-        Ok(()) => {\n-            debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\",\n-                   source_trait_ref,\n-                   target_trait_ref);\n+            Ok(()) => {\n+                debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\",\n+                       source_trait_ref,\n+                       target_trait_ref);\n \n-            // Now resolve the *substitution* we built for the target earlier, replacing\n-            // the inference variables inside with whatever we got from fulfillment.\n-            Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n+                // Now resolve the *substitution* we built for the target earlier, replacing\n+                // the inference variables inside with whatever we got from fulfillment.\n+                Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n+            }\n         }\n-    }\n+    })\n }\n \n pub struct SpecializesCache {"}, {"sha": "6d7a2d6cba1c761640e53bde00f84c17b0cec0ca", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -1303,7 +1303,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_trait(self, mut obj: TraitObject<'tcx>) -> Ty<'tcx> {\n-        obj.projection_bounds.sort_by(|a, b| a.sort_key().cmp(&b.sort_key()));\n+        obj.projection_bounds.sort_by_key(|b| b.sort_key(self));\n         self.mk_ty(TyTrait(box obj))\n     }\n "}, {"sha": "14eb2fb7914c36f30dd03f60ac26415dce349f74", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -1018,10 +1018,6 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n     pub fn item_name(&self) -> Name {\n         self.0.projection_ty.item_name // safe to skip the binder to access a name\n     }\n-\n-    pub fn sort_key(&self) -> (DefId, Name) {\n-        self.0.projection_ty.sort_key()\n-    }\n }\n \n pub trait ToPolyTraitRef<'tcx> {"}, {"sha": "5fdc7abc0af5b0631f1b804bd6bfcfae28aaa586", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -23,7 +23,7 @@ use std::mem;\n use std::ops;\n use syntax::abi;\n use syntax::ast::{self, Name};\n-use syntax::parse::token::keywords;\n+use syntax::parse::token::{keywords, InternedString};\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n \n@@ -440,12 +440,6 @@ pub struct ProjectionTy<'tcx> {\n     pub item_name: Name,\n }\n \n-impl<'tcx> ProjectionTy<'tcx> {\n-    pub fn sort_key(&self) -> (DefId, Name) {\n-        (self.trait_ref.def_id, self.item_name)\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct BareFnTy<'tcx> {\n     pub unsafety: hir::Unsafety,\n@@ -738,8 +732,17 @@ impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n         self.0.item_name // safe to skip the binder to access a name\n     }\n \n-    pub fn sort_key(&self) -> (DefId, Name) {\n-        (self.0.trait_ref.def_id, self.0.item_name)\n+    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (u64, InternedString) {\n+        // We want something here that is stable across crate boundaries.\n+        // The DefId isn't but the `deterministic_hash` of the corresponding\n+        // DefPath is.\n+        let trait_def = tcx.lookup_trait_def(self.0.trait_ref.def_id);\n+        let def_path_hash = trait_def.def_path_hash;\n+\n+        // An `ast::Name` is also not stable (it's just an index into an\n+        // interning table), so map to the corresponding `InternedString`.\n+        let item_name = self.0.item_name.as_str();\n+        (def_path_hash, item_name)\n     }\n \n     pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,"}, {"sha": "268b2fcaa4adbb8687b833a9a06ee6f4cdddab90", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -70,15 +70,20 @@ pub struct TraitDef<'tcx> {\n     pub specialization_graph: RefCell<traits::specialization_graph::Graph>,\n \n     /// Various flags\n-    pub flags: Cell<TraitFlags>\n+    pub flags: Cell<TraitFlags>,\n+\n+    /// The ICH of this trait's DefPath, cached here so it doesn't have to be\n+    /// recomputed all the time.\n+    pub def_path_hash: u64,\n }\n \n impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n     pub fn new(unsafety: hir::Unsafety,\n                paren_sugar: bool,\n                generics: &'tcx ty::Generics<'tcx>,\n                trait_ref: ty::TraitRef<'tcx>,\n-               associated_type_names: Vec<Name>)\n+               associated_type_names: Vec<Name>,\n+               def_path_hash: u64)\n                -> TraitDef<'tcx> {\n         TraitDef {\n             paren_sugar: paren_sugar,\n@@ -90,6 +95,7 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n             blanket_impls: RefCell::new(vec![]),\n             flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n             specialization_graph: RefCell::new(traits::specialization_graph::Graph::new()),\n+            def_path_hash: def_path_hash,\n         }\n     }\n "}, {"sha": "d34fdaa7d71cd3f92c41267be69eee3a06cc0871", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 5, "deletions": 34, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -411,15 +411,11 @@ impl<'a, 'gcx, 'tcx> TypeIdHasher<'a, 'gcx, 'tcx> {\n     }\n \n     fn def_id(&mut self, did: DefId) {\n-        // Hash the crate identification information.\n-        let name = self.tcx.crate_name(did.krate);\n-        let disambiguator = self.tcx.crate_disambiguator(did.krate);\n-        self.hash((name, disambiguator));\n-\n-        // Hash the item path within that crate.\n-        // FIXME(#35379) This should use a deterministic\n-        // DefPath hashing mechanism, not the DefIndex.\n-        self.hash(did.index);\n+        // Hash the DefPath corresponding to the DefId, which is independent\n+        // of compiler internal state.\n+        let tcx = self.tcx;\n+        let def_path = tcx.def_path(did);\n+        def_path.deterministic_hash_to(tcx, &mut self.state);\n     }\n }\n \n@@ -445,33 +441,8 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n                 self.hash(f.sig.variadic());\n             }\n             TyTrait(ref data) => {\n-                // Trait objects have a list of projection bounds\n-                // that are not guaranteed to be sorted in an order\n-                // that gets preserved across crates, so we need\n-                // to sort them again by the name, in string form.\n-\n-                // Hash the whole principal trait ref.\n                 self.def_id(data.principal.def_id());\n-                data.principal.visit_with(self);\n-\n-                // Hash region and builtin bounds.\n-                data.region_bound.visit_with(self);\n                 self.hash(data.builtin_bounds);\n-\n-                // Only projection bounds are left, sort and hash them.\n-                let mut projection_bounds: Vec<_> = data.projection_bounds\n-                                                        .iter()\n-                                                        .map(|b| (b.item_name().as_str(), b))\n-                                                        .collect();\n-                projection_bounds.sort_by_key(|&(ref name, _)| name.clone());\n-                for (name, bound) in projection_bounds {\n-                    self.def_id(bound.0.trait_ref.def_id);\n-                    self.hash(name);\n-                    bound.visit_with(self);\n-                }\n-\n-                // Bypass super_visit_with, we've visited everything.\n-                return false;\n             }\n             TyTuple(tys) => {\n                 self.hash(tys.len());"}, {"sha": "36e9fccdf5fd8d3783cb64792a0ec29644e1d97f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -50,6 +50,7 @@ use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n use syntax::{ast, diagnostics, visit};\n use syntax::attr;\n+use syntax::ext::base::ExtCtxt;\n use syntax::parse::{self, PResult, token};\n use syntax::util::node_count::NodeCounter;\n use syntax;\n@@ -638,6 +639,13 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     }\n     sess.track_errors(|| sess.lint_store.borrow_mut().process_command_line(sess))?;\n \n+    let mut macro_loader =\n+        macro_import::MacroLoader::new(sess, &cstore, crate_name, krate.config.clone());\n+\n+    let resolver_arenas = Resolver::arenas();\n+    let mut resolver = Resolver::new(sess, make_glob_map, &mut macro_loader, &resolver_arenas);\n+    syntax_ext::register_builtins(&mut resolver, sess.features.borrow().quote);\n+\n     krate = time(time_passes, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n         // dependencies. It's up to us to tell the system where to find all the\n@@ -672,25 +680,17 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n             trace_mac: sess.opts.debugging_opts.trace_macros,\n             should_test: sess.opts.test,\n         };\n-        let mut loader = macro_import::MacroLoader::new(sess,\n-                                                        &cstore,\n-                                                        crate_name,\n-                                                        krate.config.clone());\n-        let mut ecx = syntax::ext::base::ExtCtxt::new(&sess.parse_sess,\n-                                                      krate.config.clone(),\n-                                                      cfg,\n-                                                      &mut loader);\n-        syntax_ext::register_builtins(&mut ecx.syntax_env);\n+        let mut ecx = ExtCtxt::new(&sess.parse_sess, krate.config.clone(), cfg, &mut resolver);\n         let ret = syntax::ext::expand::expand_crate(&mut ecx, syntax_exts, krate);\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);\n         }\n-        *sess.available_macros.borrow_mut() = ecx.syntax_env.names;\n         ret\n     });\n \n     krate = time(time_passes, \"maybe building test harness\", || {\n         syntax::test::modify_for_testing(&sess.parse_sess,\n+                                         &mut resolver,\n                                          sess.opts.test,\n                                          krate,\n                                          sess.diagnostic())\n@@ -701,18 +701,14 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n         let is_rustc_macro_crate = crate_types.contains(&config::CrateTypeRustcMacro);\n         let num_crate_types = crate_types.len();\n         syntax_ext::rustc_macro_registrar::modify(&sess.parse_sess,\n+                                                  &mut resolver,\n                                                   krate,\n                                                   is_rustc_macro_crate,\n                                                   num_crate_types,\n                                                   sess.diagnostic(),\n                                                   &sess.features.borrow())\n     });\n \n-    let resolver_arenas = Resolver::arenas();\n-    let mut resolver = Resolver::new(sess, make_glob_map, &resolver_arenas);\n-\n-    let krate = time(sess.time_passes(), \"assigning node ids\", || resolver.assign_node_ids(krate));\n-\n     if sess.opts.debugging_opts.input_stats {\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }"}, {"sha": "e8d9e90456efc65d6e4228e53625eaddd36944a9", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -569,7 +569,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::TyTuple(_) => {\n                 FfiUnsafe(\"found Rust tuple type in foreign module; \\\n-                           consider using a struct instead`\")\n+                           consider using a struct instead\")\n             }\n \n             ty::TyRawPtr(ref m) | ty::TyRef(_, ref m) => {"}, {"sha": "624bffb7e036962c7324ed93a819b6f603d7c725", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -385,12 +385,14 @@ pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n     let unsafety = parse_unsafety(item_doc);\n     let associated_type_names = parse_associated_type_names(item_doc);\n     let paren_sugar = parse_paren_sugar(item_doc);\n+    let def_path = def_path(cdata, item_id).unwrap();\n \n     ty::TraitDef::new(unsafety,\n                       paren_sugar,\n                       generics,\n                       item_trait_ref(item_doc, tcx, cdata),\n-                      associated_type_names)\n+                      associated_type_names,\n+                      def_path.deterministic_hash(tcx))\n }\n \n pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,"}, {"sha": "e41f076d64a80bea5abc8e227509d937d3fe05b1", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -18,6 +18,7 @@ use creader::{CrateReader, Macros};\n use cstore::CStore;\n \n use rustc::hir::def_id::DefIndex;\n+use rustc::middle;\n use rustc::session::Session;\n use rustc::util::nodemap::FnvHashMap;\n use rustc_back::dynamic_lib::DynamicLibrary;\n@@ -26,7 +27,6 @@ use rustc_macro::__internal::Registry;\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::LoadedMacro;\n-use syntax::ext;\n use syntax::parse::token;\n use syntax_ext::deriving::custom::CustomDerive;\n use syntax_pos::Span;\n@@ -55,7 +55,7 @@ pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n \n pub type MacroSelection = FnvHashMap<token::InternedString, Span>;\n \n-impl<'a> ext::base::MacroLoader for MacroLoader<'a> {\n+impl<'a> middle::cstore::MacroLoader for MacroLoader<'a> {\n     fn load_crate(&mut self,\n                   extern_crate: &ast::Item,\n                   allows_macros: bool) -> Vec<LoadedMacro> {"}, {"sha": "dbefd3eacc24aabeac7df1a3d5fee51fa7f891ce", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -104,14 +104,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n \n             enc_region(w, cx, obj.region_bound);\n \n-            // Encode projection_bounds in a stable order\n-            let mut projection_bounds: Vec<_> = obj.projection_bounds\n-                                                .iter()\n-                                                .map(|b| (b.item_name().as_str(), b))\n-                                                .collect();\n-            projection_bounds.sort_by_key(|&(ref name, _)| name.clone());\n-\n-            for tp in projection_bounds.iter().map(|&(_, tp)| tp) {\n+            for tp in &obj.projection_bounds {\n                 write!(w, \"P\");\n                 enc_existential_projection(w, cx, &tp.0);\n             }"}, {"sha": "a9e3c6ffe9ed887d028208dab5d64fa7e49d70e3", "filename": "src/librustc_resolve/assign_ids.rs", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e2c64d16906dbb29763d6cbf022164a09247ef9f/src%2Flibrustc_resolve%2Fassign_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2c64d16906dbb29763d6cbf022164a09247ef9f/src%2Flibrustc_resolve%2Fassign_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fassign_ids.rs?ref=e2c64d16906dbb29763d6cbf022164a09247ef9f", "patch": "@@ -1,92 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use Resolver;\n-use rustc::session::Session;\n-use rustc::util::nodemap::FnvHashMap;\n-use syntax::ast;\n-use syntax::ext::hygiene::Mark;\n-use syntax::fold::{self, Folder};\n-use syntax::ptr::P;\n-use syntax::util::move_map::MoveMap;\n-use syntax::util::small_vector::SmallVector;\n-\n-use std::mem;\n-\n-impl<'a> Resolver<'a> {\n-    pub fn assign_node_ids(&mut self, krate: ast::Crate) -> ast::Crate {\n-        NodeIdAssigner {\n-            sess: self.session,\n-            macros_at_scope: &mut self.macros_at_scope,\n-        }.fold_crate(krate)\n-    }\n-}\n-\n-struct NodeIdAssigner<'a> {\n-    sess: &'a Session,\n-    macros_at_scope: &'a mut FnvHashMap<ast::NodeId, Vec<Mark>>,\n-}\n-\n-impl<'a> Folder for NodeIdAssigner<'a> {\n-    fn new_id(&mut self, old_id: ast::NodeId) -> ast::NodeId {\n-        assert_eq!(old_id, ast::DUMMY_NODE_ID);\n-        self.sess.next_node_id()\n-    }\n-\n-    fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n-        block.map(|mut block| {\n-            block.id = self.new_id(block.id);\n-\n-            let stmt = block.stmts.pop();\n-            let mut macros = Vec::new();\n-            block.stmts = block.stmts.move_flat_map(|stmt| {\n-                if let ast::StmtKind::Item(ref item) = stmt.node {\n-                    if let ast::ItemKind::Mac(..) = item.node {\n-                        macros.push(item.ident.ctxt.data().outer_mark);\n-                        return None;\n-                    }\n-                }\n-\n-                let stmt = self.fold_stmt(stmt).pop().unwrap();\n-                if !macros.is_empty() {\n-                    self.macros_at_scope.insert(stmt.id, mem::replace(&mut macros, Vec::new()));\n-                }\n-                Some(stmt)\n-            });\n-\n-            stmt.and_then(|mut stmt| {\n-                // Avoid wasting a node id on a trailing expression statement,\n-                // which shares a HIR node with the expression itself.\n-                if let ast::StmtKind::Expr(expr) = stmt.node {\n-                    let expr = self.fold_expr(expr);\n-                    stmt.id = expr.id;\n-                    stmt.node = ast::StmtKind::Expr(expr);\n-                    Some(stmt)\n-                } else {\n-                    self.fold_stmt(stmt).pop()\n-                }\n-            }).map(|stmt| {\n-                if !macros.is_empty() {\n-                    self.macros_at_scope.insert(stmt.id, mem::replace(&mut macros, Vec::new()));\n-                }\n-                block.stmts.push(stmt);\n-            });\n-\n-            block\n-        })\n-    }\n-\n-    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        match item.node {\n-            ast::ItemKind::Mac(..) => SmallVector::zero(),\n-            _ => fold::noop_fold_item(item, self),\n-        }\n-    }\n-}"}, {"sha": "912b39cafff36505c790a3f16a15d664dfd8676c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -45,6 +45,7 @@ use self::ParentLink::*;\n \n use rustc::hir::map::Definitions;\n use rustc::hir::{self, PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n+use rustc::middle::cstore::MacroLoader;\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::*;\n@@ -79,10 +80,10 @@ use resolve_imports::{ImportDirective, NameResolution};\n // registered before they are used.\n mod diagnostics;\n \n+mod macros;\n mod check_unused;\n mod build_reduced_graph;\n mod resolve_imports;\n-mod assign_ids;\n \n enum SuggestionType {\n     Macro(String),\n@@ -247,7 +248,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                                            \"method `{}` is not a member of trait `{}`\",\n                                            method,\n                                            trait_);\n-            err.span_label(span, &format!(\"not a member of `{}`\", trait_));\n+            err.span_label(span, &format!(\"not a member of trait `{}`\", trait_));\n             err\n         }\n         ResolutionError::TypeNotMemberOfTrait(type_, trait_) => {\n@@ -257,7 +258,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                              \"type `{}` is not a member of trait `{}`\",\n                              type_,\n                              trait_);\n-            err.span_label(span, &format!(\"not a member of trait `Foo`\"));\n+            err.span_label(span, &format!(\"not a member of trait `{}`\", trait_));\n             err\n         }\n         ResolutionError::ConstNotMemberOfTrait(const_, trait_) => {\n@@ -267,7 +268,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                              \"const `{}` is not a member of trait `{}`\",\n                              const_,\n                              trait_);\n-            err.span_label(span, &format!(\"not a member of trait `Foo`\"));\n+            err.span_label(span, &format!(\"not a member of trait `{}`\", trait_));\n             err\n         }\n         ResolutionError::VariableNotBoundInPattern(variable_name, from, to) => {\n@@ -1068,6 +1069,12 @@ pub struct Resolver<'a> {\n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n     new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n+\n+    macro_loader: &'a mut MacroLoader,\n+    macro_names: FnvHashSet<Name>,\n+\n+    // Maps the `Mark` of an expansion to its containing module or block.\n+    expansion_data: Vec<macros::ExpansionData>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1166,7 +1173,10 @@ impl Named for hir::PathSegment {\n }\n \n impl<'a> Resolver<'a> {\n-    pub fn new(session: &'a Session, make_glob_map: MakeGlobMap, arenas: &'a ResolverArenas<'a>)\n+    pub fn new(session: &'a Session,\n+               make_glob_map: MakeGlobMap,\n+               macro_loader: &'a mut MacroLoader,\n+               arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n         let root_def_id = DefId::local(CRATE_DEF_INDEX);\n         let graph_root =\n@@ -1227,6 +1237,10 @@ impl<'a> Resolver<'a> {\n                 vis: ty::Visibility::Public,\n             }),\n             new_import_semantics: session.features.borrow().item_like_imports,\n+\n+            macro_loader: macro_loader,\n+            macro_names: FnvHashSet(),\n+            expansion_data: vec![macros::ExpansionData::default()],\n         }\n     }\n \n@@ -2768,8 +2782,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn find_best_match(&mut self, name: &str) -> SuggestionType {\n-        if let Some(macro_name) = self.session.available_macros\n-                                  .borrow().iter().find(|n| n.as_str() == name) {\n+        if let Some(macro_name) = self.macro_names.iter().find(|n| n.as_str() == name) {\n             return SuggestionType::Macro(format!(\"{}!\", macro_name));\n         }\n "}, {"sha": "67ee4c307d3c33a493182ad1577a907264e2fcd0", "filename": "src/librustc_resolve/macros.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -0,0 +1,217 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use Resolver;\n+use rustc::util::nodemap::FnvHashMap;\n+use std::cell::RefCell;\n+use std::mem;\n+use std::rc::Rc;\n+use syntax::ast::{self, Name};\n+use syntax::errors::DiagnosticBuilder;\n+use syntax::ext::base::{self, LoadedMacro, MultiModifier, MultiDecorator};\n+use syntax::ext::base::{NormalTT, SyntaxExtension};\n+use syntax::ext::expand::{Expansion, Invocation, InvocationKind};\n+use syntax::ext::hygiene::Mark;\n+use syntax::parse::token::intern;\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::visit::{self, Visitor};\n+\n+#[derive(Clone, Default)]\n+pub struct ExpansionData {\n+    module: Rc<ModuleData>,\n+}\n+\n+// FIXME(jseyfried): merge with `::ModuleS`.\n+#[derive(Default)]\n+struct ModuleData {\n+    parent: Option<Rc<ModuleData>>,\n+    macros: RefCell<FnvHashMap<Name, Rc<SyntaxExtension>>>,\n+    macros_escape: bool,\n+}\n+\n+impl<'a> base::Resolver for Resolver<'a> {\n+    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro> {\n+        self.macro_loader.load_crate(extern_crate, allows_macros)\n+    }\n+\n+    fn next_node_id(&mut self) -> ast::NodeId {\n+        self.session.next_node_id()\n+    }\n+\n+    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n+        expansion.visit_with(&mut ExpansionVisitor {\n+            current_module: self.expansion_data[mark.as_u32() as usize].module.clone(),\n+            resolver: self,\n+        });\n+    }\n+\n+    fn add_macro(&mut self, scope: Mark, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n+        if let NormalTT(..) = *ext {\n+            self.macro_names.insert(ident.name);\n+        }\n+\n+        let mut module = self.expansion_data[scope.as_u32() as usize].module.clone();\n+        while module.macros_escape {\n+            module = module.parent.clone().unwrap();\n+        }\n+        module.macros.borrow_mut().insert(ident.name, ext);\n+    }\n+\n+    fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n+        self.macros_at_scope.insert(id, macros);\n+    }\n+\n+    fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n+        for i in 0..attrs.len() {\n+            let name = intern(&attrs[i].name());\n+            match self.expansion_data[0].module.macros.borrow().get(&name) {\n+                Some(ext) => match **ext {\n+                    MultiModifier(..) | MultiDecorator(..) => return Some(attrs.remove(i)),\n+                    _ => {}\n+                },\n+                None => {}\n+            }\n+        }\n+        None\n+    }\n+\n+    fn resolve_invoc(&mut self, invoc: &Invocation) -> Option<Rc<SyntaxExtension>> {\n+        let (name, span) = match invoc.kind {\n+            InvocationKind::Bang { ref mac, .. } => {\n+                let path = &mac.node.path;\n+                if path.segments.len() > 1 || path.global ||\n+                   !path.segments[0].parameters.is_empty() {\n+                    self.session.span_err(path.span,\n+                                          \"expected macro name without module separators\");\n+                    return None;\n+                }\n+                (path.segments[0].identifier.name, path.span)\n+            }\n+            InvocationKind::Attr { ref attr, .. } => (intern(&*attr.name()), attr.span),\n+        };\n+\n+        let mut module = self.expansion_data[invoc.mark().as_u32() as usize].module.clone();\n+        loop {\n+            if let Some(ext) = module.macros.borrow().get(&name) {\n+                return Some(ext.clone());\n+            }\n+            match module.parent.clone() {\n+                Some(parent) => module = parent,\n+                None => break,\n+            }\n+        }\n+\n+        let mut err =\n+            self.session.struct_span_err(span, &format!(\"macro undefined: '{}!'\", name));\n+        self.suggest_macro_name(&name.as_str(), &mut err);\n+        err.emit();\n+        None\n+    }\n+}\n+\n+impl<'a> Resolver<'a> {\n+    fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {\n+        if let Some(suggestion) = find_best_match_for_name(self.macro_names.iter(), name, None) {\n+            if suggestion != name {\n+                err.help(&format!(\"did you mean `{}!`?\", suggestion));\n+            } else {\n+                err.help(&format!(\"have you added the `#[macro_use]` on the module/import?\"));\n+            }\n+        }\n+    }\n+}\n+\n+struct ExpansionVisitor<'b, 'a: 'b> {\n+    resolver: &'b mut Resolver<'a>,\n+    current_module: Rc<ModuleData>,\n+}\n+\n+impl<'a, 'b> ExpansionVisitor<'a, 'b> {\n+    fn visit_invoc(&mut self, id: ast::NodeId) {\n+        assert_eq!(id, self.resolver.expansion_data.len() as u32);\n+        self.resolver.expansion_data.push(ExpansionData {\n+            module: self.current_module.clone(),\n+        });\n+    }\n+\n+    // does this attribute list contain \"macro_use\"?\n+    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n+        for attr in attrs {\n+            if attr.check_name(\"macro_escape\") {\n+                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n+                let mut err = self.resolver.session.struct_span_warn(attr.span, msg);\n+                if let ast::AttrStyle::Inner = attr.node.style {\n+                    err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n+                } else {\n+                    err.emit();\n+                }\n+            } else if !attr.check_name(\"macro_use\") {\n+                continue;\n+            }\n+\n+            if !attr.is_word() {\n+                self.resolver.session.span_err(attr.span,\n+                                               \"arguments to macro_use are not allowed here\");\n+            }\n+            return true;\n+        }\n+\n+        false\n+    }\n+}\n+\n+macro_rules! method {\n+    ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n+        fn $visit(&mut self, node: &$ty) {\n+            match node.node {\n+                $invoc(..) => self.visit_invoc(node.id),\n+                _ => visit::$walk(self, node),\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'b> Visitor for ExpansionVisitor<'a, 'b>  {\n+    method!(visit_trait_item: ast::TraitItem, ast::TraitItemKind::Macro, walk_trait_item);\n+    method!(visit_impl_item:  ast::ImplItem,  ast::ImplItemKind::Macro,  walk_impl_item);\n+    method!(visit_stmt:       ast::Stmt,      ast::StmtKind::Mac,        walk_stmt);\n+    method!(visit_expr:       ast::Expr,      ast::ExprKind::Mac,        walk_expr);\n+    method!(visit_pat:        ast::Pat,       ast::PatKind::Mac,         walk_pat);\n+    method!(visit_ty:         ast::Ty,        ast::TyKind::Mac,          walk_ty);\n+\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        match item.node {\n+            ast::ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => {} // Scope placeholder\n+            ast::ItemKind::Mac(..) => self.visit_invoc(item.id),\n+            ast::ItemKind::Mod(..) => {\n+                let module_data = ModuleData {\n+                    parent: Some(self.current_module.clone()),\n+                    macros: RefCell::new(FnvHashMap()),\n+                    macros_escape: self.contains_macro_use(&item.attrs),\n+                };\n+                let orig_module = mem::replace(&mut self.current_module, Rc::new(module_data));\n+                visit::walk_item(self, item);\n+                self.current_module = orig_module;\n+            }\n+            _ => visit::walk_item(self, item),\n+        }\n+    }\n+\n+    fn visit_block(&mut self, block: &ast::Block) {\n+        let module_data = ModuleData {\n+            parent: Some(self.current_module.clone()),\n+            macros: RefCell::new(FnvHashMap()),\n+            macros_escape: false,\n+        };\n+        let orig_module = mem::replace(&mut self.current_module, Rc::new(module_data));\n+        visit::walk_block(self, block);\n+        self.current_module = orig_module;\n+    }\n+}"}, {"sha": "3073b1dbfaeebcd09d90d2daff23dd6816149a95", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -296,6 +296,7 @@ fn trans_custom_dtor<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         sized_args = [v0];\n         &sized_args\n     } else {\n+        // FIXME(#36457) -- we should pass unsized values to drop glue as two arguments\n         unsized_args = [\n             Load(bcx, get_dataptr(bcx, v0)),\n             Load(bcx, get_meta(bcx, v0))\n@@ -440,7 +441,9 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n     }\n }\n \n-fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueKind<'tcx>)\n+fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              v0: ValueRef,\n+                              g: DropGlueKind<'tcx>)\n                               -> Block<'blk, 'tcx> {\n     let t = g.ty();\n \n@@ -463,6 +466,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n                 let llval = get_dataptr(bcx, v0);\n                 let llbox = Load(bcx, llval);\n                 let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n+                // FIXME(#36457) -- we should pass unsized values to drop glue as two arguments\n                 let info = get_meta(bcx, v0);\n                 let info = Load(bcx, info);\n                 let (llsize, llalign) =\n@@ -488,6 +492,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n             // No support in vtable for distinguishing destroying with\n             // versus without calling Drop::drop. Assert caller is\n             // okay with always calling the Drop impl, if any.\n+            // FIXME(#36457) -- we should pass unsized values to drop glue as two arguments\n             assert!(!skip_dtor);\n             let data_ptr = get_dataptr(bcx, v0);\n             let vtable_ptr = Load(bcx, get_meta(bcx, v0));\n@@ -543,6 +548,7 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     let value = if type_is_sized(cx.tcx(), t) {\n         adt::MaybeSizedValue::sized(av)\n     } else {\n+        // FIXME(#36457) -- we should pass unsized values as two arguments\n         let data = Load(cx, get_dataptr(cx, av));\n         let info = Load(cx, get_meta(cx, av));\n         adt::MaybeSizedValue::unsized_(data, info)\n@@ -586,6 +592,7 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                     let val = if type_is_sized(cx.tcx(), field_ty) {\n                         llfld_a\n                     } else {\n+                        // FIXME(#36457) -- we should pass unsized values as two arguments\n                         let scratch = alloc_ty(cx, field_ty, \"__fat_ptr_iter\");\n                         Store(cx, llfld_a, get_dataptr(cx, scratch));\n                         Store(cx, value.meta, get_meta(cx, scratch));"}, {"sha": "0d919cb77570170687c1398852a38c410a26bd0f", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -194,6 +194,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let ptr = if is_sized {\n                 llargs[0]\n             } else {\n+                // FIXME(#36457) -- we should pass unsized values as two arguments\n                 let scratch = alloc_ty(bcx, tp_ty, \"drop\");\n                 call_lifetime_start(bcx, scratch);\n                 Store(bcx, llargs[0], get_dataptr(bcx, scratch));"}, {"sha": "baeafbe3e346f221462bac0a0bea64538fa06f5a", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -242,10 +242,28 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let lvalue = self.trans_lvalue(&bcx, location);\n                 let drop_fn = glue::get_drop_glue(bcx.ccx(), ty);\n                 let drop_ty = glue::get_drop_glue_type(bcx.tcx(), ty);\n-                let llvalue = if drop_ty != ty {\n-                    bcx.pointercast(lvalue.llval, type_of::type_of(bcx.ccx(), drop_ty).ptr_to())\n+                let is_sized = common::type_is_sized(bcx.tcx(), ty);\n+                let llvalue = if is_sized {\n+                    if drop_ty != ty {\n+                        bcx.pointercast(lvalue.llval, type_of::type_of(bcx.ccx(), drop_ty).ptr_to())\n+                    } else {\n+                        lvalue.llval\n+                    }\n                 } else {\n-                    lvalue.llval\n+                    // FIXME(#36457) Currently drop glue takes sized\n+                    // values as a `*(data, meta)`, but elsewhere in\n+                    // MIR we pass `(data, meta)` as two separate\n+                    // arguments. It would be better to fix drop glue,\n+                    // but I am shooting for a quick fix to #35546\n+                    // here that can be cleanly backported to beta, so\n+                    // I want to avoid touching all of trans.\n+                    bcx.with_block(|bcx| {\n+                        let scratch = base::alloc_ty(bcx, ty, \"drop\");\n+                        base::call_lifetime_start(bcx, scratch);\n+                        build::Store(bcx, lvalue.llval, base::get_dataptr(bcx, scratch));\n+                        build::Store(bcx, lvalue.llextra, base::get_meta(bcx, scratch));\n+                        scratch\n+                    })\n                 };\n                 if let Some(unwind) = unwind {\n                     bcx.invoke(drop_fn,"}, {"sha": "04aca8c0947caa7e603a9bbfd8efe499c965d4df", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -1290,12 +1290,15 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     }).collect();\n \n+    let def_path_hash = tcx.def_path(def_id).deterministic_hash(tcx);\n+\n     let trait_ref = ty::TraitRef::new(def_id, substs);\n     let trait_def = ty::TraitDef::new(unsafety,\n                                       paren_sugar,\n                                       ty_generics,\n                                       trait_ref,\n-                                      associated_type_names);\n+                                      associated_type_names,\n+                                      def_path_hash);\n \n     tcx.intern_trait_def(trait_def)\n }"}, {"sha": "246c57ab238713e2b1b7056e3bcb327cddd581cf", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 182, "deletions": 35, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -97,22 +97,154 @@ impl Duration {\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n     pub fn subsec_nanos(&self) -> u32 { self.nanos }\n+\n+    /// Checked duration addition. Computes `self + other`, returning `None`\n+    /// if overflow occurred.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(duration_checked_ops)]\n+    ///\n+    /// use std::time::Duration;\n+    ///\n+    /// assert_eq!(Duration::new(0, 0).checked_add(Duration::new(0, 1)), Some(Duration::new(0, 1)));\n+    /// assert_eq!(Duration::new(1, 0).checked_add(Duration::new(std::u64::MAX, 0)), None);\n+    /// ```\n+    #[unstable(feature = \"duration_checked_ops\", issue = \"35774\")]\n+    #[inline]\n+    pub fn checked_add(self, rhs: Duration) -> Option<Duration> {\n+        if let Some(mut secs) = self.secs.checked_add(rhs.secs) {\n+            let mut nanos = self.nanos + rhs.nanos;\n+            if nanos >= NANOS_PER_SEC {\n+                nanos -= NANOS_PER_SEC;\n+                if let Some(new_secs) = secs.checked_add(1) {\n+                    secs = new_secs;\n+                } else {\n+                    return None;\n+                }\n+            }\n+            debug_assert!(nanos < NANOS_PER_SEC);\n+            Some(Duration {\n+                secs: secs,\n+                nanos: nanos,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Checked duration subtraction. Computes `self + other`, returning `None`\n+    /// if the result would be negative or if underflow occurred.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(duration_checked_ops)]\n+    ///\n+    /// use std::time::Duration;\n+    ///\n+    /// assert_eq!(Duration::new(0, 1).checked_sub(Duration::new(0, 0)), Some(Duration::new(0, 1)));\n+    /// assert_eq!(Duration::new(0, 0).checked_sub(Duration::new(0, 1)), None);\n+    /// ```\n+    #[unstable(feature = \"duration_checked_ops\", issue = \"35774\")]\n+    #[inline]\n+    pub fn checked_sub(self, rhs: Duration) -> Option<Duration> {\n+        if let Some(mut secs) = self.secs.checked_sub(rhs.secs) {\n+            let nanos = if self.nanos >= rhs.nanos {\n+                self.nanos - rhs.nanos\n+            } else {\n+                if let Some(sub_secs) = secs.checked_sub(1) {\n+                    secs = sub_secs;\n+                    self.nanos + NANOS_PER_SEC - rhs.nanos\n+                } else {\n+                    return None;\n+                }\n+            };\n+            debug_assert!(nanos < NANOS_PER_SEC);\n+            Some(Duration { secs: secs, nanos: nanos })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Checked duration multiplication. Computes `self * other`, returning\n+    /// `None` if underflow or overflow occurred.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(duration_checked_ops)]\n+    ///\n+    /// use std::time::Duration;\n+    ///\n+    /// assert_eq!(Duration::new(0, 500_000_001).checked_mul(2), Some(Duration::new(1, 2)));\n+    /// assert_eq!(Duration::new(std::u64::MAX - 1, 0).checked_mul(2), None);\n+    /// ```\n+    #[unstable(feature = \"duration_checked_ops\", issue = \"35774\")]\n+    #[inline]\n+    pub fn checked_mul(self, rhs: u32) -> Option<Duration> {\n+        // Multiply nanoseconds as u64, because it cannot overflow that way.\n+        let total_nanos = self.nanos as u64 * rhs as u64;\n+        let extra_secs = total_nanos / (NANOS_PER_SEC as u64);\n+        let nanos = (total_nanos % (NANOS_PER_SEC as u64)) as u32;\n+        if let Some(secs) = self.secs\n+            .checked_mul(rhs as u64)\n+            .and_then(|s| s.checked_add(extra_secs)) {\n+            debug_assert!(nanos < NANOS_PER_SEC);\n+            Some(Duration {\n+                secs: secs,\n+                nanos: nanos,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Checked duration division. Computes `self / other`, returning `None`\n+    /// if `other == 0` or the operation results in underflow or overflow.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(duration_checked_ops)]\n+    ///\n+    /// use std::time::Duration;\n+    ///\n+    /// assert_eq!(Duration::new(2, 0).checked_div(2), Some(Duration::new(1, 0)));\n+    /// assert_eq!(Duration::new(1, 0).checked_div(2), Some(Duration::new(0, 500_000_000)));\n+    /// assert_eq!(Duration::new(2, 0).checked_div(0), None);\n+    /// ```\n+    #[unstable(feature = \"duration_checked_ops\", issue = \"35774\")]\n+    #[inline]\n+    pub fn checked_div(self, rhs: u32) -> Option<Duration> {\n+        if rhs != 0 {\n+            let secs = self.secs / (rhs as u64);\n+            let carry = self.secs - secs * (rhs as u64);\n+            let extra_nanos = carry * (NANOS_PER_SEC as u64) / (rhs as u64);\n+            let nanos = self.nanos / rhs + (extra_nanos as u32);\n+            debug_assert!(nanos < NANOS_PER_SEC);\n+            Some(Duration { secs: secs, nanos: nanos })\n+        } else {\n+            None\n+        }\n+    }\n }\n \n #[stable(feature = \"duration\", since = \"1.3.0\")]\n impl Add for Duration {\n     type Output = Duration;\n \n     fn add(self, rhs: Duration) -> Duration {\n-        let mut secs = self.secs.checked_add(rhs.secs)\n-                           .expect(\"overflow when adding durations\");\n-        let mut nanos = self.nanos + rhs.nanos;\n-        if nanos >= NANOS_PER_SEC {\n-            nanos -= NANOS_PER_SEC;\n-            secs = secs.checked_add(1).expect(\"overflow when adding durations\");\n-        }\n-        debug_assert!(nanos < NANOS_PER_SEC);\n-        Duration { secs: secs, nanos: nanos }\n+        self.checked_add(rhs).expect(\"overflow when adding durations\")\n     }\n }\n \n@@ -128,17 +260,7 @@ impl Sub for Duration {\n     type Output = Duration;\n \n     fn sub(self, rhs: Duration) -> Duration {\n-        let mut secs = self.secs.checked_sub(rhs.secs)\n-                           .expect(\"overflow when subtracting durations\");\n-        let nanos = if self.nanos >= rhs.nanos {\n-            self.nanos - rhs.nanos\n-        } else {\n-            secs = secs.checked_sub(1)\n-                       .expect(\"overflow when subtracting durations\");\n-            self.nanos + NANOS_PER_SEC - rhs.nanos\n-        };\n-        debug_assert!(nanos < NANOS_PER_SEC);\n-        Duration { secs: secs, nanos: nanos }\n+        self.checked_sub(rhs).expect(\"overflow when subtracting durations\")\n     }\n }\n \n@@ -154,15 +276,7 @@ impl Mul<u32> for Duration {\n     type Output = Duration;\n \n     fn mul(self, rhs: u32) -> Duration {\n-        // Multiply nanoseconds as u64, because it cannot overflow that way.\n-        let total_nanos = self.nanos as u64 * rhs as u64;\n-        let extra_secs = total_nanos / (NANOS_PER_SEC as u64);\n-        let nanos = (total_nanos % (NANOS_PER_SEC as u64)) as u32;\n-        let secs = self.secs.checked_mul(rhs as u64)\n-                       .and_then(|s| s.checked_add(extra_secs))\n-                       .expect(\"overflow when multiplying duration\");\n-        debug_assert!(nanos < NANOS_PER_SEC);\n-        Duration { secs: secs, nanos: nanos }\n+        self.checked_mul(rhs).expect(\"overflow when multiplying duration by scalar\")\n     }\n }\n \n@@ -178,12 +292,7 @@ impl Div<u32> for Duration {\n     type Output = Duration;\n \n     fn div(self, rhs: u32) -> Duration {\n-        let secs = self.secs / (rhs as u64);\n-        let carry = self.secs - secs * (rhs as u64);\n-        let extra_nanos = carry * (NANOS_PER_SEC as u64) / (rhs as u64);\n-        let nanos = self.nanos / rhs + (extra_nanos as u32);\n-        debug_assert!(nanos < NANOS_PER_SEC);\n-        Duration { secs: secs, nanos: nanos }\n+        self.checked_div(rhs).expect(\"divide by zero error when dividing duration by scalar\")\n     }\n }\n \n@@ -234,6 +343,15 @@ mod tests {\n                    Duration::new(1, 1));\n     }\n \n+    #[test]\n+    fn checked_add() {\n+        assert_eq!(Duration::new(0, 0).checked_add(Duration::new(0, 1)),\n+                   Some(Duration::new(0, 1)));\n+        assert_eq!(Duration::new(0, 500_000_000).checked_add(Duration::new(0, 500_000_001)),\n+                   Some(Duration::new(1, 1)));\n+        assert_eq!(Duration::new(1, 0).checked_add(Duration::new(::u64::MAX, 0)), None);\n+    }\n+\n     #[test]\n     fn sub() {\n         assert_eq!(Duration::new(0, 1) - Duration::new(0, 0),\n@@ -244,6 +362,18 @@ mod tests {\n                    Duration::new(0, 999_999_999));\n     }\n \n+    #[test]\n+    fn checked_sub() {\n+        let zero = Duration::new(0, 0);\n+        let one_nano = Duration::new(0, 1);\n+        let one_sec = Duration::new(1, 0);\n+        assert_eq!(one_nano.checked_sub(zero), Some(Duration::new(0, 1)));\n+        assert_eq!(one_sec.checked_sub(one_nano),\n+                   Some(Duration::new(0, 999_999_999)));\n+        assert_eq!(zero.checked_sub(one_nano), None);\n+        assert_eq!(zero.checked_sub(one_sec), None);\n+    }\n+\n     #[test] #[should_panic]\n     fn sub_bad1() {\n         Duration::new(0, 0) - Duration::new(0, 1);\n@@ -263,11 +393,28 @@ mod tests {\n                    Duration::new(2000, 4000));\n     }\n \n+    #[test]\n+    fn checked_mul() {\n+        assert_eq!(Duration::new(0, 1).checked_mul(2), Some(Duration::new(0, 2)));\n+        assert_eq!(Duration::new(1, 1).checked_mul(3), Some(Duration::new(3, 3)));\n+        assert_eq!(Duration::new(0, 500_000_001).checked_mul(4), Some(Duration::new(2, 4)));\n+        assert_eq!(Duration::new(0, 500_000_001).checked_mul(4000),\n+                   Some(Duration::new(2000, 4000)));\n+        assert_eq!(Duration::new(::u64::MAX - 1, 0).checked_mul(2), None);\n+    }\n+\n     #[test]\n     fn div() {\n         assert_eq!(Duration::new(0, 1) / 2, Duration::new(0, 0));\n         assert_eq!(Duration::new(1, 1) / 3, Duration::new(0, 333_333_333));\n         assert_eq!(Duration::new(99, 999_999_000) / 100,\n                    Duration::new(0, 999_999_990));\n     }\n+\n+    #[test]\n+    fn checked_div() {\n+        assert_eq!(Duration::new(2, 0).checked_div(2), Some(Duration::new(1, 0)));\n+        assert_eq!(Duration::new(1, 0).checked_div(2), Some(Duration::new(0, 500_000_000)));\n+        assert_eq!(Duration::new(2, 0).checked_div(0), None);\n+    }\n }"}, {"sha": "fb4816d3847ed772a60ea54553d3f8826a194d44", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 87, "deletions": 249, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -10,27 +10,25 @@\n \n pub use self::SyntaxExtension::*;\n \n-use ast;\n-use ast::{Name, PatKind};\n+use ast::{self, Attribute, Name, PatKind};\n use attr::HasAttrs;\n-use codemap::{self, CodeMap, ExpnInfo};\n+use codemap::{self, CodeMap, ExpnInfo, Spanned, respan};\n use syntax_pos::{Span, ExpnId, NO_EXPANSION};\n use errors::DiagnosticBuilder;\n-use ext;\n-use ext::expand;\n+use ext::expand::{self, Invocation, Expansion};\n+use ext::hygiene::Mark;\n use ext::tt::macro_rules;\n use parse;\n use parse::parser;\n use parse::token;\n-use parse::token::{InternedString, intern, str_to_ident};\n+use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n use std_inject;\n use util::small_vector::SmallVector;\n-use util::lev_distance::find_best_match_for_name;\n use fold::Folder;\n use feature_gate;\n \n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::path::PathBuf;\n use std::rc::Rc;\n use tokenstream;\n@@ -44,15 +42,15 @@ pub enum Annotatable {\n }\n \n impl HasAttrs for Annotatable {\n-    fn attrs(&self) -> &[ast::Attribute] {\n+    fn attrs(&self) -> &[Attribute] {\n         match *self {\n             Annotatable::Item(ref item) => &item.attrs,\n             Annotatable::TraitItem(ref trait_item) => &trait_item.attrs,\n             Annotatable::ImplItem(ref impl_item) => &impl_item.attrs,\n         }\n     }\n \n-    fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self {\n+    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n         match self {\n             Annotatable::Item(item) => Annotatable::Item(item.map_attrs(f)),\n             Annotatable::TraitItem(trait_item) => Annotatable::TraitItem(trait_item.map_attrs(f)),\n@@ -464,103 +462,52 @@ pub enum SyntaxExtension {\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n-/// The base map of methods for expanding syntax extension\n-/// AST nodes into full ASTs\n-fn initial_syntax_expander_table<'feat>(ecfg: &expand::ExpansionConfig<'feat>)\n-                                        -> SyntaxEnv {\n-    // utility function to simplify creating NormalTT syntax extensions\n-    fn builtin_normal_expander(f: MacroExpanderFn) -> SyntaxExtension {\n-        NormalTT(Box::new(f), None, false)\n-    }\n-\n-    let mut syntax_expanders = SyntaxEnv::new();\n-    syntax_expanders.insert(intern(\"macro_rules\"), MacroRulesTT);\n-\n-    if ecfg.enable_quotes() {\n-        // Quasi-quoting expanders\n-        syntax_expanders.insert(intern(\"quote_tokens\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_tokens));\n-        syntax_expanders.insert(intern(\"quote_expr\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_expr));\n-        syntax_expanders.insert(intern(\"quote_ty\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_ty));\n-        syntax_expanders.insert(intern(\"quote_item\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_item));\n-        syntax_expanders.insert(intern(\"quote_pat\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_pat));\n-        syntax_expanders.insert(intern(\"quote_arm\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_arm));\n-        syntax_expanders.insert(intern(\"quote_stmt\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_stmt));\n-        syntax_expanders.insert(intern(\"quote_matcher\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_matcher));\n-        syntax_expanders.insert(intern(\"quote_attr\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_attr));\n-        syntax_expanders.insert(intern(\"quote_arg\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_arg));\n-        syntax_expanders.insert(intern(\"quote_block\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_block));\n-        syntax_expanders.insert(intern(\"quote_meta_item\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_meta_item));\n-        syntax_expanders.insert(intern(\"quote_path\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_path));\n-    }\n-\n-    syntax_expanders.insert(intern(\"line\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_line));\n-    syntax_expanders.insert(intern(\"column\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_column));\n-    syntax_expanders.insert(intern(\"file\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_file));\n-    syntax_expanders.insert(intern(\"stringify\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_stringify));\n-    syntax_expanders.insert(intern(\"include\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_include));\n-    syntax_expanders.insert(intern(\"include_str\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_include_str));\n-    syntax_expanders.insert(intern(\"include_bytes\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_include_bytes));\n-    syntax_expanders.insert(intern(\"module_path\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_mod));\n-    syntax_expanders\n-}\n-\n-pub trait MacroLoader {\n-    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool)\n-                  -> Vec<LoadedMacro>;\n+pub trait Resolver {\n+    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n+    fn next_node_id(&mut self) -> ast::NodeId;\n+\n+    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion);\n+    fn add_macro(&mut self, scope: Mark, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n+    fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n+\n+    fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n+    fn resolve_invoc(&mut self, invoc: &Invocation) -> Option<Rc<SyntaxExtension>>;\n }\n \n pub enum LoadedMacro {\n     Def(ast::MacroDef),\n     CustomDerive(String, Box<MultiItemModifier>),\n }\n \n-pub struct DummyMacroLoader;\n-impl MacroLoader for DummyMacroLoader {\n-    fn load_crate(&mut self, _: &ast::Item, _: bool) -> Vec<LoadedMacro> {\n+pub struct DummyResolver;\n+\n+impl Resolver for DummyResolver {\n+    fn load_crate(&mut self, _extern_crate: &ast::Item, _allows_macros: bool) -> Vec<LoadedMacro> {\n         Vec::new()\n     }\n+    fn next_node_id(&mut self) -> ast::NodeId { ast::DUMMY_NODE_ID }\n+\n+    fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion) {}\n+    fn add_macro(&mut self, _scope: Mark, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n+    fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n+\n+    fn find_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n+    fn resolve_invoc(&mut self, _invoc: &Invocation) -> Option<Rc<SyntaxExtension>> { None }\n+}\n+\n+#[derive(Clone)]\n+pub struct ModuleData {\n+    pub mod_path: Vec<ast::Ident>,\n+    pub directory: PathBuf,\n+}\n+\n+#[derive(Clone)]\n+pub struct ExpansionData {\n+    pub mark: Mark,\n+    pub depth: usize,\n+    pub backtrace: ExpnId,\n+    pub module: Rc<ModuleData>,\n+    pub in_block: bool,\n }\n \n /// One of these is made during expansion and incrementally updated as we go;\n@@ -569,63 +516,68 @@ impl MacroLoader for DummyMacroLoader {\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub cfg: ast::CrateConfig,\n-    pub backtrace: ExpnId,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub crate_root: Option<&'static str>,\n-    pub loader: &'a mut MacroLoader,\n-\n+    pub resolver: &'a mut Resolver,\n     pub exported_macros: Vec<ast::MacroDef>,\n-\n-    pub syntax_env: SyntaxEnv,\n     pub derive_modes: HashMap<InternedString, Box<MultiItemModifier>>,\n-    pub recursion_count: usize,\n+    pub current_expansion: ExpansionData,\n }\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n                ecfg: expand::ExpansionConfig<'a>,\n-               loader: &'a mut MacroLoader)\n+               resolver: &'a mut Resolver)\n                -> ExtCtxt<'a> {\n         ExtCtxt {\n-            syntax_env: initial_syntax_expander_table(&ecfg),\n             parse_sess: parse_sess,\n             cfg: cfg,\n-            backtrace: NO_EXPANSION,\n             ecfg: ecfg,\n             crate_root: None,\n             exported_macros: Vec::new(),\n-            loader: loader,\n+            resolver: resolver,\n             derive_modes: HashMap::new(),\n-            recursion_count: 0,\n+            current_expansion: ExpansionData {\n+                mark: Mark::root(),\n+                depth: 0,\n+                backtrace: NO_EXPANSION,\n+                module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n+                in_block: false,\n+            },\n         }\n     }\n \n     /// Returns a `Folder` for deeply expanding all macros in an AST node.\n     pub fn expander<'b>(&'b mut self) -> expand::MacroExpander<'b, 'a> {\n-        expand::MacroExpander::new(self, false, false)\n+        expand::MacroExpander::new(self, false)\n+    }\n+\n+    /// Returns a `Folder` that deeply expands all macros and assigns all node ids in an AST node.\n+    /// Once node ids are assigned, the node may not be expanded, removed, or otherwise modified.\n+    pub fn monotonic_expander<'b>(&'b mut self) -> expand::MacroExpander<'b, 'a> {\n+        expand::MacroExpander::new(self, true)\n     }\n \n     pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree])\n         -> parser::Parser<'a> {\n         parse::tts_to_parser(self.parse_sess, tts.to_vec(), self.cfg())\n     }\n-\n     pub fn codemap(&self) -> &'a CodeMap { self.parse_sess.codemap() }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n     pub fn call_site(&self) -> Span {\n-        self.codemap().with_expn_info(self.backtrace, |ei| match ei {\n+        self.codemap().with_expn_info(self.backtrace(), |ei| match ei {\n             Some(expn_info) => expn_info.call_site,\n             None => self.bug(\"missing top span\")\n         })\n     }\n-    pub fn backtrace(&self) -> ExpnId { self.backtrace }\n+    pub fn backtrace(&self) -> ExpnId { self.current_expansion.backtrace }\n \n     /// Returns span for the macro which originally caused the current expansion to happen.\n     ///\n     /// Stops backtracing at include! boundary.\n     pub fn expansion_cause(&self) -> Span {\n-        let mut expn_id = self.backtrace;\n+        let mut expn_id = self.backtrace();\n         let mut last_macro = None;\n         loop {\n             if self.codemap().with_expn_info(expn_id, |info| {\n@@ -646,15 +598,15 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn bt_push(&mut self, ei: ExpnInfo) {\n-        if self.recursion_count > self.ecfg.recursion_limit {\n+        if self.current_expansion.depth > self.ecfg.recursion_limit {\n             self.span_fatal(ei.call_site,\n                             &format!(\"recursion limit reached while expanding the macro `{}`\",\n                                     ei.callee.name()));\n         }\n \n         let mut call_site = ei.call_site;\n-        call_site.expn_id = self.backtrace;\n-        self.backtrace = self.codemap().record_expansion(ExpnInfo {\n+        call_site.expn_id = self.backtrace();\n+        self.current_expansion.backtrace = self.codemap().record_expansion(ExpnInfo {\n             call_site: call_site,\n             callee: ei.callee\n         });\n@@ -667,14 +619,11 @@ impl<'a> ExtCtxt<'a> {\n         }\n         if def.use_locally {\n             let ext = macro_rules::compile(self, &def);\n-            self.syntax_env.insert(def.ident.name, ext);\n+            self.resolver.add_macro(self.current_expansion.mark, def.ident, Rc::new(ext));\n         }\n     }\n \n-    pub fn insert_custom_derive(&mut self,\n-                                name: &str,\n-                                ext: Box<MultiItemModifier>,\n-                                sp: Span) {\n+    pub fn insert_custom_derive(&mut self, name: &str, ext: Box<MultiItemModifier>, sp: Span) {\n         if !self.ecfg.enable_rustc_macro() {\n             feature_gate::emit_feature_err(&self.parse_sess.span_diagnostic,\n                                            \"rustc_macro\",\n@@ -685,8 +634,7 @@ impl<'a> ExtCtxt<'a> {\n         }\n         let name = token::intern_and_get_ident(name);\n         if self.derive_modes.insert(name.clone(), ext).is_some() {\n-            self.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\",\n-                                       name));\n+            self.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\", name));\n         }\n     }\n \n@@ -765,20 +713,6 @@ impl<'a> ExtCtxt<'a> {\n         token::intern(st)\n     }\n \n-    pub fn suggest_macro_name(&mut self,\n-                              name: &str,\n-                              err: &mut DiagnosticBuilder<'a>) {\n-        let names = &self.syntax_env.names;\n-        if let Some(suggestion) = find_best_match_for_name(names.iter(), name, None) {\n-            if suggestion != name {\n-                err.help(&format!(\"did you mean `{}!`?\", suggestion));\n-            } else {\n-                err.help(&format!(\"have you added the `#[macro_use]` on the \\\n-                                   module/import?\"));\n-            }\n-        }\n-    }\n-\n     pub fn initialize(&mut self, user_exts: Vec<NamedSyntaxExtension>, krate: &ast::Crate) {\n         if std_inject::no_core(&krate) {\n             self.crate_root = None;\n@@ -789,42 +723,47 @@ impl<'a> ExtCtxt<'a> {\n         }\n \n         for (name, extension) in user_exts {\n-            self.syntax_env.insert(name, extension);\n+            let ident = ast::Ident::with_empty_ctxt(name);\n+            self.resolver.add_macro(Mark::root(), ident, Rc::new(extension));\n         }\n \n-        self.syntax_env.current_module = Module(0);\n-        let mut paths = ModulePaths {\n+        let mut module = ModuleData {\n             mod_path: vec![token::str_to_ident(&self.ecfg.crate_name)],\n             directory: PathBuf::from(self.parse_sess.codemap().span_to_filename(krate.span)),\n         };\n-        paths.directory.pop();\n-        self.syntax_env.module_data[0].paths = Rc::new(paths);\n+        module.directory.pop();\n+        self.current_expansion.module = Rc::new(module);\n     }\n }\n \n /// Extract a string literal from the macro expanded version of `expr`,\n /// emitting `err_msg` if `expr` is not a string literal. This does not stop\n /// compilation on error, merely emits a non-fatal error and returns None.\n-pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n-                      -> Option<(InternedString, ast::StrStyle)> {\n+pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n+                              -> Option<Spanned<(InternedString, ast::StrStyle)>> {\n     // Update `expr.span`'s expn_id now in case expr is an `include!` macro invocation.\n     let expr = expr.map(|mut expr| {\n-        expr.span.expn_id = cx.backtrace;\n+        expr.span.expn_id = cx.backtrace();\n         expr\n     });\n \n     // we want to be able to handle e.g. concat(\"foo\", \"bar\")\n     let expr = cx.expander().fold_expr(expr);\n     match expr.node {\n         ast::ExprKind::Lit(ref l) => match l.node {\n-            ast::LitKind::Str(ref s, style) => return Some(((*s).clone(), style)),\n+            ast::LitKind::Str(ref s, style) => return Some(respan(expr.span, (s.clone(), style))),\n             _ => cx.span_err(l.span, err_msg)\n         },\n         _ => cx.span_err(expr.span, err_msg)\n     }\n     None\n }\n \n+pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n+                      -> Option<(InternedString, ast::StrStyle)> {\n+    expr_to_spanned_string(cx, expr, err_msg).map(|s| s.node)\n+}\n+\n /// Non-fatally assert that `tts` is empty. Note that this function\n /// returns even when `tts` is non-empty, macros that *need* to stop\n /// compilation should call\n@@ -851,7 +790,7 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n         return None\n     }\n-    let ret = cx.expander().fold_expr(panictry!(p.parse_expr()));\n+    let ret = panictry!(p.parse_expr());\n     if p.token != token::Eof {\n         cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n     }\n@@ -879,104 +818,3 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n     }\n     Some(es)\n }\n-\n-/// In order to have some notion of scoping for macros,\n-/// we want to implement the notion of a transformation\n-/// environment.\n-///\n-/// This environment maps Names to SyntaxExtensions.\n-pub struct SyntaxEnv {\n-    module_data: Vec<ModuleData>,\n-    pub current_module: Module,\n-\n-    /// All bang-style macro/extension names\n-    /// encountered so far; to be used for diagnostics in resolve\n-    pub names: HashSet<Name>,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq)]\n-pub struct Module(u32);\n-\n-struct ModuleData {\n-    parent: Module,\n-    paths: Rc<ModulePaths>,\n-    macros: HashMap<Name, Rc<SyntaxExtension>>,\n-    macros_escape: bool,\n-    in_block: bool,\n-}\n-\n-#[derive(Clone)]\n-pub struct ModulePaths {\n-    pub mod_path: Vec<ast::Ident>,\n-    pub directory: PathBuf,\n-}\n-\n-impl SyntaxEnv {\n-    fn new() -> SyntaxEnv {\n-        let mut env = SyntaxEnv {\n-            current_module: Module(0),\n-            module_data: Vec::new(),\n-            names: HashSet::new(),\n-        };\n-        let paths = Rc::new(ModulePaths { mod_path: Vec::new(), directory: PathBuf::new() });\n-        env.add_module(false, false, paths);\n-        env\n-    }\n-\n-    fn data(&self, module: Module) -> &ModuleData {\n-        &self.module_data[module.0 as usize]\n-    }\n-\n-    pub fn paths(&self) -> Rc<ModulePaths> {\n-        self.data(self.current_module).paths.clone()\n-    }\n-\n-    pub fn in_block(&self) -> bool {\n-        self.data(self.current_module).in_block\n-    }\n-\n-    pub fn add_module(&mut self, macros_escape: bool, in_block: bool, paths: Rc<ModulePaths>)\n-                      -> Module {\n-        let data = ModuleData {\n-            parent: self.current_module,\n-            paths: paths,\n-            macros: HashMap::new(),\n-            macros_escape: macros_escape,\n-            in_block: in_block,\n-        };\n-\n-        self.module_data.push(data);\n-        Module(self.module_data.len() as u32 - 1)\n-    }\n-\n-    pub fn find(&self, name: Name) -> Option<Rc<SyntaxExtension>> {\n-        let mut module = self.current_module;\n-        let mut module_data;\n-        loop {\n-            module_data = self.data(module);\n-            if let Some(ext) = module_data.macros.get(&name) {\n-                return Some(ext.clone());\n-            }\n-            if module == module_data.parent {\n-                return None;\n-            }\n-            module = module_data.parent;\n-        }\n-    }\n-\n-    pub fn insert(&mut self, name: Name, ext: SyntaxExtension) {\n-        if let NormalTT(..) = ext {\n-            self.names.insert(name);\n-        }\n-\n-        let mut module = self.current_module;\n-        while self.data(module).macros_escape {\n-            module = self.data(module).parent;\n-        }\n-        self.module_data[module.0 as usize].macros.insert(name, Rc::new(ext));\n-    }\n-\n-    pub fn is_crate_root(&mut self) -> bool {\n-        self.current_module == Module(0)\n-    }\n-}"}, {"sha": "b81d95a6998c310e01006df4c6733d0f81d28684", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -97,6 +97,7 @@ pub trait AstBuilder {\n                       typ: P<ast::Ty>,\n                       ex: P<ast::Expr>)\n                       -> P<ast::Stmt>;\n+    fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt;\n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt;\n \n     // blocks\n@@ -577,6 +578,23 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n+    // Generate `let _: Type;`, usually used for type assertions.\n+    fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt {\n+        let local = P(ast::Local {\n+            pat: self.pat_wild(span),\n+            ty: Some(ty),\n+            init: None,\n+            id: ast::DUMMY_NODE_ID,\n+            span: span,\n+            attrs: ast::ThinVec::new(),\n+        });\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Local(local),\n+            span: span,\n+        }\n+    }\n+\n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt {\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,"}, {"sha": "62e299684b7602929435a15d63f04bb4ee1f87f2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 122, "deletions": 226, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -25,14 +25,16 @@ use parse::token::{intern, keywords};\n use ptr::P;\n use tokenstream::TokenTree;\n use util::small_vector::SmallVector;\n+use visit::Visitor;\n \n use std::mem;\n use std::path::PathBuf;\n use std::rc::Rc;\n \n macro_rules! expansions {\n     ($($kind:ident: $ty:ty [$($vec:ident, $ty_elt:ty)*], $kind_name:expr, .$make:ident,\n-            $(.$fold:ident)*  $(lift .$fold_elt:ident)*;)*) => {\n+            $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n+            $(.$visit:ident)*  $(lift .$visit_elt:ident)*;)*) => {\n         #[derive(Copy, Clone)]\n         pub enum ExpansionKind { OptExpr, $( $kind, )*  }\n         pub enum Expansion { OptExpr(Option<P<ast::Expr>>), $( $kind($ty), )* }\n@@ -77,6 +79,17 @@ macro_rules! expansions {\n                     }, )*)*\n                 }\n             }\n+\n+            pub fn visit_with<V: Visitor>(&self, visitor: &mut V) {\n+                match *self {\n+                    Expansion::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n+                    Expansion::OptExpr(None) => {}\n+                    $($( Expansion::$kind(ref ast) => visitor.$visit(ast), )*)*\n+                    $($( Expansion::$kind(ref ast) => for ast in ast.as_slice() {\n+                        visitor.$visit_elt(ast);\n+                    }, )*)*\n+                }\n+            }\n         }\n \n         impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n@@ -94,17 +107,17 @@ macro_rules! expansions {\n }\n \n expansions! {\n-    Expr: P<ast::Expr> [], \"expression\", .make_expr, .fold_expr;\n-    Pat: P<ast::Pat>   [], \"pattern\",    .make_pat,  .fold_pat;\n-    Ty: P<ast::Ty>     [], \"type\",       .make_ty,   .fold_ty;\n+    Expr: P<ast::Expr> [], \"expression\", .make_expr, .fold_expr, .visit_expr;\n+    Pat: P<ast::Pat>   [], \"pattern\",    .make_pat,  .fold_pat,  .visit_pat;\n+    Ty: P<ast::Ty>     [], \"type\",       .make_ty,   .fold_ty,   .visit_ty;\n     Stmts: SmallVector<ast::Stmt> [SmallVector, ast::Stmt],\n-        \"statement\",  .make_stmts,       lift .fold_stmt;\n+        \"statement\",  .make_stmts,       lift .fold_stmt, lift .visit_stmt;\n     Items: SmallVector<P<ast::Item>> [SmallVector, P<ast::Item>],\n-        \"item\",       .make_items,       lift .fold_item;\n+        \"item\",       .make_items,       lift .fold_item, lift .visit_item;\n     TraitItems: SmallVector<ast::TraitItem> [SmallVector, ast::TraitItem],\n-        \"trait item\", .make_trait_items, lift .fold_trait_item;\n+        \"trait item\", .make_trait_items, lift .fold_trait_item, lift .visit_trait_item;\n     ImplItems: SmallVector<ast::ImplItem> [SmallVector, ast::ImplItem],\n-        \"impl item\",  .make_impl_items,  lift .fold_impl_item;\n+        \"impl item\",  .make_impl_items,  lift .fold_impl_item,  lift .visit_impl_item;\n }\n \n impl ExpansionKind {\n@@ -127,15 +140,12 @@ impl ExpansionKind {\n }\n \n pub struct Invocation {\n-    kind: InvocationKind,\n+    pub kind: InvocationKind,\n     expansion_kind: ExpansionKind,\n-    mark: Mark,\n-    module: Module,\n-    backtrace: ExpnId,\n-    depth: usize,\n+    expansion_data: ExpansionData,\n }\n \n-enum InvocationKind {\n+pub enum InvocationKind {\n     Bang {\n         attrs: Vec<ast::Attribute>,\n         mac: ast::Mac,\n@@ -148,29 +158,53 @@ enum InvocationKind {\n     },\n }\n \n+impl Invocation {\n+    fn span(&self) -> Span {\n+        match self.kind {\n+            InvocationKind::Bang { span, .. } => span,\n+            InvocationKind::Attr { ref attr, .. } => attr.span,\n+        }\n+    }\n+\n+    pub fn mark(&self) -> Mark {\n+        self.expansion_data.mark\n+    }\n+}\n+\n pub struct MacroExpander<'a, 'b:'a> {\n     pub cx: &'a mut ExtCtxt<'b>,\n     pub single_step: bool,\n     pub keep_macs: bool,\n+    monotonic: bool, // c.f. `cx.monotonic_expander()`\n }\n \n impl<'a, 'b> MacroExpander<'a, 'b> {\n-    pub fn new(cx: &'a mut ExtCtxt<'b>,\n-               single_step: bool,\n-               keep_macs: bool) -> MacroExpander<'a, 'b> {\n+    pub fn new(cx: &'a mut ExtCtxt<'b>, monotonic: bool) -> Self {\n         MacroExpander {\n             cx: cx,\n-            single_step: single_step,\n-            keep_macs: keep_macs\n+            monotonic: monotonic,\n+            single_step: false,\n+            keep_macs: false,\n         }\n     }\n \n     fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n         let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n \n-        let items = Expansion::Items(SmallVector::many(krate.module.items));\n-        krate.module.items = self.expand(items).make_items().into();\n-        krate.exported_macros = self.cx.exported_macros.clone();\n+        let mut krate_item = placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n+            .make_items().pop().unwrap().unwrap();\n+        krate_item.node = ast::ItemKind::Mod(krate.module);\n+        let krate_item = Expansion::Items(SmallVector::one(P(krate_item)));\n+\n+        krate.module = match self.expand(krate_item).make_items().pop().unwrap().unwrap().node {\n+            ast::ItemKind::Mod(module) => module,\n+            _ => unreachable!(),\n+        };\n+        krate.exported_macros = mem::replace(&mut self.cx.exported_macros, Vec::new());\n+\n+        for def in &mut krate.exported_macros {\n+            def.id = self.cx.resolver.next_node_id()\n+        }\n \n         if self.cx.parse_sess.span_diagnostic.err_count() > err_count {\n             self.cx.parse_sess.span_diagnostic.abort_if_errors();\n@@ -181,21 +215,23 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n     // Fully expand all the invocations in `expansion`.\n     fn expand(&mut self, expansion: Expansion) -> Expansion {\n-        self.cx.recursion_count = 0;\n+        let orig_expansion_data = self.cx.current_expansion.clone();\n+        self.cx.current_expansion.depth = 0;\n+\n         let (expansion, mut invocations) = self.collect_invocations(expansion);\n         invocations.reverse();\n \n         let mut expansions = vec![vec![(0, expansion)]];\n         while let Some(invoc) = invocations.pop() {\n-            let Invocation { mark, module, depth, backtrace, .. } = invoc;\n-            self.cx.syntax_env.current_module = module;\n-            self.cx.recursion_count = depth;\n-            self.cx.backtrace = backtrace;\n+            let ExpansionData { depth, mark, .. } = invoc.expansion_data;\n+            self.cx.current_expansion = invoc.expansion_data.clone();\n \n-            let expansion = self.expand_invoc(invoc);\n+            let expansion = match self.cx.resolver.resolve_invoc(&invoc) {\n+                Some(ext) => self.expand_invoc(invoc, ext),\n+                None => invoc.expansion_kind.dummy(invoc.span()),\n+            };\n \n-            self.cx.syntax_env.current_module = module;\n-            self.cx.recursion_count = depth + 1;\n+            self.cx.current_expansion.depth = depth + 1;\n             let (expansion, new_invocations) = self.collect_invocations(expansion);\n \n             if expansions.len() == depth {\n@@ -207,7 +243,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n         }\n \n-        let mut placeholder_expander = PlaceholderExpander::new();\n+        self.cx.current_expansion = orig_expansion_data;\n+\n+        let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n         while let Some(expansions) = expansions.pop() {\n             for (mark, expansion) in expansions.into_iter().rev() {\n                 let expansion = expansion.fold_with(&mut placeholder_expander);\n@@ -230,33 +268,31 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 },\n                 cx: self.cx,\n                 invocations: Vec::new(),\n+                monotonic: self.monotonic,\n             };\n             (expansion.fold_with(&mut collector), collector.invocations)\n         };\n-\n         self.cx.cfg = crate_config;\n+\n+        let mark = self.cx.current_expansion.mark;\n+        self.cx.resolver.visit_expansion(mark, &result.0);\n         result\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation) -> Expansion {\n+    fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         match invoc.kind {\n-            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc),\n-            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc),\n+            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n+            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext),\n         }\n     }\n \n-    fn expand_attr_invoc(&mut self, invoc: Invocation) -> Expansion {\n+    fn expand_attr_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         let Invocation { expansion_kind: kind, .. } = invoc;\n         let (attr, item) = match invoc.kind {\n             InvocationKind::Attr { attr, item } => (attr, item),\n             _ => unreachable!(),\n         };\n \n-        let extension = match self.cx.syntax_env.find(intern(&attr.name())) {\n-            Some(extension) => extension,\n-            None => unreachable!(),\n-        };\n-\n         attr::mark_used(&attr);\n         self.cx.bt_push(ExpnInfo {\n             call_site: attr.span,\n@@ -267,7 +303,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n         });\n \n-        match *extension {\n+        match *ext {\n             MultiModifier(ref mac) => {\n                 let item = mac.expand(self.cx, attr.span, &attr.node.value, item);\n                 kind.expect_from_annotatables(item)\n@@ -284,8 +320,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     /// Expand a macro invocation. Returns the result of expansion.\n-    fn expand_bang_invoc(&mut self, invoc: Invocation) -> Expansion {\n-        let Invocation { mark, expansion_kind: kind, .. } = invoc;\n+    fn expand_bang_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n+        let (mark, kind) = (invoc.mark(), invoc.expansion_kind);\n         let (attrs, mac, ident, span) = match invoc.kind {\n             InvocationKind::Bang { attrs, mac, ident, span } => (attrs, mac, ident, span),\n             _ => unreachable!(),\n@@ -306,19 +342,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         let extname = path.segments[0].identifier.name;\n-        let extension = if let Some(extension) = self.cx.syntax_env.find(extname) {\n-            extension\n-        } else {\n-            let mut err =\n-                self.cx.struct_span_err(path.span, &format!(\"macro undefined: '{}!'\", &extname));\n-            self.cx.suggest_macro_name(&extname.as_str(), &mut err);\n-            err.emit();\n-            return kind.dummy(span);\n-        };\n-\n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n         let marked_tts = mark_tts(&tts, mark);\n-        let opt_expanded = match *extension {\n+        let opt_expanded = match *ext {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg =\n@@ -425,6 +451,7 @@ struct InvocationCollector<'a, 'b: 'a> {\n     cx: &'a mut ExtCtxt<'b>,\n     cfg: StripUnconfigured<'a>,\n     invocations: Vec<Invocation>,\n+    monotonic: bool,\n }\n \n macro_rules! fully_configure {\n@@ -442,10 +469,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         self.invocations.push(Invocation {\n             kind: kind,\n             expansion_kind: expansion_kind,\n-            mark: mark,\n-            module: self.cx.syntax_env.current_module,\n-            backtrace: self.cx.backtrace,\n-            depth: self.cx.recursion_count,\n+            expansion_data: ExpansionData { mark: mark, ..self.cx.current_expansion.clone() },\n         });\n         placeholder(expansion_kind, mark.as_u32())\n     }\n@@ -462,50 +486,15 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n \n     // If `item` is an attr invocation, remove and return the macro attribute.\n-    fn classify_item<T: HasAttrs>(&self, mut item: T) -> (T, Option<ast::Attribute>) {\n+    fn classify_item<T: HasAttrs>(&mut self, mut item: T) -> (T, Option<ast::Attribute>) {\n         let mut attr = None;\n         item = item.map_attrs(|mut attrs| {\n-            for i in 0..attrs.len() {\n-                if let Some(extension) = self.cx.syntax_env.find(intern(&attrs[i].name())) {\n-                    match *extension {\n-                        MultiModifier(..) | MultiDecorator(..) => {\n-                            attr = Some(attrs.remove(i));\n-                            break;\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n+            attr = self.cx.resolver.find_attr_invoc(&mut attrs);\n             attrs\n         });\n         (item, attr)\n     }\n \n-    // does this attribute list contain \"macro_use\" ?\n-    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n-        for attr in attrs {\n-            let mut is_use = attr.check_name(\"macro_use\");\n-            if attr.check_name(\"macro_escape\") {\n-                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n-                let mut err = self.cx.struct_span_warn(attr.span, msg);\n-                is_use = true;\n-                if let ast::AttrStyle::Inner = attr.node.style {\n-                    err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n-                } else {\n-                    err.emit();\n-                }\n-            };\n-\n-            if is_use {\n-                if !attr.is_word() {\n-                    self.cx.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n-                }\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n@@ -554,9 +543,14 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             None => return SmallVector::zero(),\n         };\n \n-        let (mac, style, attrs) = match stmt.node {\n-            StmtKind::Mac(mac) => mac.unwrap(),\n-            _ => return noop_fold_stmt(stmt, self),\n+        let (mac, style, attrs) = if let StmtKind::Mac(mac) = stmt.node {\n+            mac.unwrap()\n+        } else {\n+            // The placeholder expander gives ids to statements, so we avoid folding the id here.\n+            let ast::Stmt { id, node, span } = stmt;\n+            return noop_fold_stmt_kind(node, self).into_iter().map(|node| {\n+                ast::Stmt { id: id, node: node, span: span }\n+            }).collect()\n         };\n \n         let mut placeholder =\n@@ -574,11 +568,9 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        let paths = self.cx.syntax_env.paths();\n-        let module = self.cx.syntax_env.add_module(false, true, paths);\n-        let orig_module = mem::replace(&mut self.cx.syntax_env.current_module, module);\n+        let orig_in_block = mem::replace(&mut self.cx.current_expansion.in_block, true);\n         let result = noop_fold_block(block, self);\n-        self.cx.syntax_env.current_module = orig_module;\n+        self.cx.current_expansion.in_block = orig_in_block;\n         result\n     }\n \n@@ -613,46 +605,48 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 })\n             }\n             ast::ItemKind::Mod(ast::Mod { inner, .. }) => {\n-                let mut paths = (*self.cx.syntax_env.paths()).clone();\n-                paths.mod_path.push(item.ident);\n+                if item.ident == keywords::Invalid.ident() {\n+                    return noop_fold_item(item, self);\n+                }\n+\n+                let mut module = (*self.cx.current_expansion.module).clone();\n+                module.mod_path.push(item.ident);\n \n                 // Detect if this is an inline module (`mod m { ... }` as opposed to `mod m;`).\n                 // In the non-inline case, `inner` is never the dummy span (c.f. `parse_item_mod`).\n                 // Thus, if `inner` is the dummy span, we know the module is inline.\n                 let inline_module = item.span.contains(inner) || inner == syntax_pos::DUMMY_SP;\n \n                 if inline_module {\n-                    paths.directory.push(&*{\n+                    module.directory.push(&*{\n                         ::attr::first_attr_value_str_by_name(&item.attrs, \"path\")\n                             .unwrap_or(item.ident.name.as_str())\n                     });\n                 } else {\n-                    paths.directory =\n+                    module.directory =\n                         PathBuf::from(self.cx.parse_sess.codemap().span_to_filename(inner));\n-                    paths.directory.pop();\n+                    module.directory.pop();\n                 }\n \n-                let macro_use = self.contains_macro_use(&item.attrs);\n-                let in_block = self.cx.syntax_env.in_block();\n-                let module = self.cx.syntax_env.add_module(macro_use, in_block, Rc::new(paths));\n-                let module = mem::replace(&mut self.cx.syntax_env.current_module, module);\n+                let orig_module =\n+                    mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n                 let result = noop_fold_item(item, self);\n-                self.cx.syntax_env.current_module = module;\n-                result\n-            },\n+                self.cx.current_expansion.module = orig_module;\n+                return result;\n+            }\n             ast::ItemKind::ExternCrate(..) => {\n                 // We need to error on `#[macro_use] extern crate` when it isn't at the\n                 // crate root, because `$crate` won't work properly.\n-                let is_crate_root = self.cx.syntax_env.is_crate_root();\n-                for def in self.cx.loader.load_crate(&*item, is_crate_root) {\n+                let is_crate_root = self.cx.current_expansion.module.mod_path.len() == 1;\n+                for def in self.cx.resolver.load_crate(&*item, is_crate_root) {\n                     match def {\n                         LoadedMacro::Def(def) => self.cx.insert_macro(def),\n                         LoadedMacro::CustomDerive(name, ext) => {\n                             self.cx.insert_custom_derive(&name, ext, item.span);\n                         }\n                     }\n                 }\n-                SmallVector::one(item)\n+                noop_fold_item(item, self)\n             },\n             _ => noop_fold_item(item, self),\n         }\n@@ -715,6 +709,15 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n         noop_fold_item_kind(self.cfg.configure_item_kind(item), self)\n     }\n+\n+    fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n+        if self.monotonic {\n+            assert_eq!(id, ast::DUMMY_NODE_ID);\n+            self.cx.resolver.next_node_id()\n+        } else {\n+            id\n+        }\n+    }\n }\n \n pub struct ExpansionConfig<'feat> {\n@@ -766,7 +769,7 @@ pub fn expand_crate(cx: &mut ExtCtxt,\n                     user_exts: Vec<NamedSyntaxExtension>,\n                     c: Crate) -> Crate {\n     cx.initialize(user_exts, &c);\n-    cx.expander().expand_crate(c)\n+    cx.monotonic_expander().expand_crate(c)\n }\n \n // Expands crate using supplied MacroExpander - allows for\n@@ -803,110 +806,3 @@ impl Folder for Marker {\n fn mark_tts(tts: &[TokenTree], m: Mark) -> Vec<TokenTree> {\n     noop_fold_tts(tts, &mut Marker{mark:m, expn_id: None})\n }\n-\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{expand_crate, ExpansionConfig};\n-    use ast;\n-    use ext::base::{ExtCtxt, DummyMacroLoader};\n-    use parse;\n-    use util::parser_testing::{string_to_parser};\n-    use visit;\n-    use visit::Visitor;\n-\n-    // a visitor that extracts the paths\n-    // from a given thingy and puts them in a mutable\n-    // array (passed in to the traversal)\n-    #[derive(Clone)]\n-    struct PathExprFinderContext {\n-        path_accumulator: Vec<ast::Path> ,\n-    }\n-\n-    impl Visitor for PathExprFinderContext {\n-        fn visit_expr(&mut self, expr: &ast::Expr) {\n-            if let ast::ExprKind::Path(None, ref p) = expr.node {\n-                self.path_accumulator.push(p.clone());\n-            }\n-            visit::walk_expr(self, expr);\n-        }\n-    }\n-\n-    // these following tests are quite fragile, in that they don't test what\n-    // *kind* of failure occurs.\n-\n-    fn test_ecfg() -> ExpansionConfig<'static> {\n-        ExpansionConfig::default(\"test\".to_string())\n-    }\n-\n-    // make sure that macros can't escape fns\n-    #[should_panic]\n-    #[test] fn macros_cant_escape_fns_test () {\n-        let src = \"fn bogus() {macro_rules! z (() => (3+4));}\\\n-                   fn inty() -> i32 { z!() }\".to_string();\n-        let sess = parse::ParseSess::new();\n-        let crate_ast = parse::parse_crate_from_source_str(\n-            \"<test>\".to_string(),\n-            src,\n-            Vec::new(), &sess).unwrap();\n-        // should fail:\n-        let mut loader = DummyMacroLoader;\n-        let mut ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n-        expand_crate(&mut ecx, vec![], crate_ast);\n-    }\n-\n-    // make sure that macros can't escape modules\n-    #[should_panic]\n-    #[test] fn macros_cant_escape_mods_test () {\n-        let src = \"mod foo {macro_rules! z (() => (3+4));}\\\n-                   fn inty() -> i32 { z!() }\".to_string();\n-        let sess = parse::ParseSess::new();\n-        let crate_ast = parse::parse_crate_from_source_str(\n-            \"<test>\".to_string(),\n-            src,\n-            Vec::new(), &sess).unwrap();\n-        let mut loader = DummyMacroLoader;\n-        let mut ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n-        expand_crate(&mut ecx, vec![], crate_ast);\n-    }\n-\n-    // macro_use modules should allow macros to escape\n-    #[test] fn macros_can_escape_flattened_mods_test () {\n-        let src = \"#[macro_use] mod foo {macro_rules! z (() => (3+4));}\\\n-                   fn inty() -> i32 { z!() }\".to_string();\n-        let sess = parse::ParseSess::new();\n-        let crate_ast = parse::parse_crate_from_source_str(\n-            \"<test>\".to_string(),\n-            src,\n-            Vec::new(), &sess).unwrap();\n-        let mut loader = DummyMacroLoader;\n-        let mut ecx = ExtCtxt::new(&sess, vec![], test_ecfg(), &mut loader);\n-        expand_crate(&mut ecx, vec![], crate_ast);\n-    }\n-\n-    fn expand_crate_str(crate_str: String) -> ast::Crate {\n-        let ps = parse::ParseSess::new();\n-        let crate_ast = panictry!(string_to_parser(&ps, crate_str).parse_crate_mod());\n-        // the cfg argument actually does matter, here...\n-        let mut loader = DummyMacroLoader;\n-        let mut ecx = ExtCtxt::new(&ps, vec![], test_ecfg(), &mut loader);\n-        expand_crate(&mut ecx, vec![], crate_ast)\n-    }\n-\n-    #[test] fn macro_tokens_should_match(){\n-        expand_crate_str(\n-            \"macro_rules! m((a)=>(13)) ;fn main(){m!(a);}\".to_string());\n-    }\n-\n-    // should be able to use a bound identifier as a literal in a macro definition:\n-    #[test] fn self_macro_parsing(){\n-        expand_crate_str(\n-            \"macro_rules! foo ((zz) => (287;));\n-            fn f(zz: i32) {foo!(zz);}\".to_string()\n-            );\n-    }\n-\n-    // create a really evil test case where a $x appears inside a binding of $x\n-    // but *shouldn't* bind because it was inserted by a different macro....\n-    // can't write this test case until we have macro-generating macros.\n-}"}, {"sha": "34126fac4ac784c888a282a0e947ba8685998400", "filename": "src/libsyntax/ext/hygiene.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Fext%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Fext%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fhygiene.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -29,7 +29,7 @@ pub struct SyntaxContextData {\n     pub prev_ctxt: SyntaxContext,\n }\n \n-/// A mark represents a unique id associated with a macro expansion.\n+/// A mark is a unique id associated with a macro expansion.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Default)]\n pub struct Mark(u32);\n \n@@ -41,6 +41,11 @@ impl Mark {\n         })\n     }\n \n+    /// The mark of the theoretical expansion that generates freshly parsed, unexpanded AST.\n+    pub fn root() -> Self {\n+        Mark(0)\n+    }\n+\n     pub fn as_u32(&self) -> u32 {\n         self.0\n     }\n@@ -56,8 +61,8 @@ impl HygieneData {\n     fn new() -> Self {\n         HygieneData {\n             syntax_contexts: vec![SyntaxContextData {\n-                outer_mark: Mark(0), // the null mark\n-                prev_ctxt: SyntaxContext(0), // the empty context\n+                outer_mark: Mark::root(),\n+                prev_ctxt: SyntaxContext::empty(),\n             }],\n             markings: HashMap::new(),\n             next_mark: Mark(1),"}, {"sha": "47f366a88768ecc45565ef0ed2cab495da1c13a1", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 61, "deletions": 4, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -10,13 +10,16 @@\n \n use ast;\n use codemap::{DUMMY_SP, dummy_spanned};\n+use ext::base::ExtCtxt;\n use ext::expand::{Expansion, ExpansionKind};\n use fold::*;\n use parse::token::keywords;\n use ptr::P;\n+use util::move_map::MoveMap;\n use util::small_vector::SmallVector;\n \n use std::collections::HashMap;\n+use std::mem;\n \n pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n     fn mac_placeholder() -> ast::Mac {\n@@ -69,14 +72,18 @@ pub fn macro_scope_placeholder() -> Expansion {\n     placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n }\n \n-pub struct PlaceholderExpander {\n+pub struct PlaceholderExpander<'a, 'b: 'a> {\n     expansions: HashMap<ast::NodeId, Expansion>,\n+    cx: &'a mut ExtCtxt<'b>,\n+    monotonic: bool,\n }\n \n-impl PlaceholderExpander {\n-    pub fn new() -> Self {\n+impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n+    pub fn new(cx: &'a mut ExtCtxt<'b>, monotonic: bool) -> Self {\n         PlaceholderExpander {\n+            cx: cx,\n             expansions: HashMap::new(),\n+            monotonic: monotonic,\n         }\n     }\n \n@@ -89,7 +96,7 @@ impl PlaceholderExpander {\n     }\n }\n \n-impl Folder for PlaceholderExpander {\n+impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         match item.node {\n             // Scope placeholder\n@@ -155,6 +162,56 @@ impl Folder for PlaceholderExpander {\n             _ => noop_fold_ty(ty, self),\n         }\n     }\n+\n+    fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n+        noop_fold_block(block, self).map(|mut block| {\n+            let mut macros = Vec::new();\n+            let mut remaining_stmts = block.stmts.len();\n+\n+            block.stmts = block.stmts.move_flat_map(|mut stmt| {\n+                remaining_stmts -= 1;\n+\n+                // Scope placeholder\n+                if let ast::StmtKind::Item(ref item) = stmt.node {\n+                    if let ast::ItemKind::Mac(..) = item.node {\n+                        macros.push(item.ident.ctxt.data().outer_mark);\n+                        return None;\n+                    }\n+                }\n+\n+                match stmt.node {\n+                    // Avoid wasting a node id on a trailing expression statement,\n+                    // which shares a HIR node with the expression itself.\n+                    ast::StmtKind::Expr(ref expr) if remaining_stmts == 0 => stmt.id = expr.id,\n+\n+                    _ if self.monotonic => {\n+                        assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n+                        stmt.id = self.cx.resolver.next_node_id();\n+                    }\n+\n+                    _ => {}\n+                }\n+\n+                if self.monotonic && !macros.is_empty() {\n+                    let macros = mem::replace(&mut macros, Vec::new());\n+                    self.cx.resolver.add_expansions_at_stmt(stmt.id, macros);\n+                }\n+\n+                Some(stmt)\n+            });\n+\n+            block\n+        })\n+    }\n+\n+    fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod {\n+        let mut module = noop_fold_mod(module, self);\n+        module.items = module.items.move_flat_map(|item| match item.node {\n+            ast::ItemKind::Mac(_) => None, // remove scope placeholders from modules\n+            _ => Some(item),\n+        });\n+        module\n+    }\n }\n \n pub fn reconstructed_macro_rules(def: &ast::MacroDef, path: &ast::Path) -> Expansion {"}, {"sha": "e75e41d0c2d4bf61238d35b61ebe895d824fac8a", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -74,8 +74,8 @@ pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTre\n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                   -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n-    let paths = cx.syntax_env.paths();\n-    let string = paths.mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n+    let mod_path = &cx.current_expansion.module.mod_path;\n+    let string = mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n \n     base::MacEager::expr(cx.expr_str(\n             sp,"}, {"sha": "51ef45b97be6f336aef5e6e510b15d57b62f6887", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -211,8 +211,8 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                                            imported_from,\n                                            rhs);\n                 let mut p = Parser::new(cx.parse_sess(), cx.cfg(), Box::new(trncbr));\n-                p.directory = cx.syntax_env.paths().directory.clone();\n-                p.restrictions = match cx.syntax_env.in_block() {\n+                p.directory = cx.current_expansion.module.directory.clone();\n+                p.restrictions = match cx.current_expansion.in_block {\n                     true => Restrictions::NO_NONINLINE_MOD,\n                     false => Restrictions::empty(),\n                 };"}, {"sha": "9fb4d0203f41e28b3904b29878b11dfdf0f4b7ba", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 13, "deletions": 37, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -1320,51 +1320,27 @@ pub fn noop_fold_exprs<T: Folder>(es: Vec<P<Expr>>, folder: &mut T) -> Vec<P<Exp\n     es.move_flat_map(|e| folder.fold_opt_expr(e))\n }\n \n-pub fn noop_fold_stmt<T: Folder>(Stmt {node, span, id}: Stmt, folder: &mut T)\n-                                 -> SmallVector<Stmt> {\n+pub fn noop_fold_stmt<T: Folder>(Stmt {node, span, id}: Stmt, folder: &mut T) -> SmallVector<Stmt> {\n     let id = folder.new_id(id);\n     let span = folder.new_span(span);\n+    noop_fold_stmt_kind(node, folder).into_iter().map(|node| {\n+        Stmt { id: id, node: node, span: span }\n+    }).collect()\n+}\n \n+pub fn noop_fold_stmt_kind<T: Folder>(node: StmtKind, folder: &mut T) -> SmallVector<StmtKind> {\n     match node {\n-        StmtKind::Local(local) => SmallVector::one(Stmt {\n-            id: id,\n-            node: StmtKind::Local(folder.fold_local(local)),\n-            span: span,\n-        }),\n-        StmtKind::Item(item) => folder.fold_item(item).into_iter().map(|item| Stmt {\n-            id: id,\n-            node: StmtKind::Item(item),\n-            span: span,\n-        }).collect(),\n+        StmtKind::Local(local) => SmallVector::one(StmtKind::Local(folder.fold_local(local))),\n+        StmtKind::Item(item) => folder.fold_item(item).into_iter().map(StmtKind::Item).collect(),\n         StmtKind::Expr(expr) => {\n-            if let Some(expr) = folder.fold_opt_expr(expr) {\n-                SmallVector::one(Stmt {\n-                    id: id,\n-                    node: StmtKind::Expr(expr),\n-                    span: span,\n-                })\n-            } else {\n-                SmallVector::zero()\n-            }\n+            folder.fold_opt_expr(expr).into_iter().map(StmtKind::Expr).collect()\n         }\n         StmtKind::Semi(expr) => {\n-            if let Some(expr) = folder.fold_opt_expr(expr) {\n-                SmallVector::one(Stmt {\n-                    id: id,\n-                    node: StmtKind::Semi(expr),\n-                    span: span,\n-                })\n-            } else {\n-                SmallVector::zero()\n-            }\n+            folder.fold_opt_expr(expr).into_iter().map(StmtKind::Semi).collect()\n         }\n-        StmtKind::Mac(mac) => SmallVector::one(Stmt {\n-            id: id,\n-            node: StmtKind::Mac(mac.map(|(mac, semi, attrs)| {\n-                (folder.fold_mac(mac), semi, fold_attrs(attrs.into(), folder).into())\n-            })),\n-            span: span,\n-        })\n+        StmtKind::Mac(mac) => SmallVector::one(StmtKind::Mac(mac.map(|(mac, semi, attrs)| {\n+            (folder.fold_mac(mac), semi, fold_attrs(attrs.into(), folder).into())\n+        }))),\n     }\n }\n "}, {"sha": "6327e8f71bcd5f211dff79f24754a3974ff1e3cd", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -28,7 +28,7 @@ use errors;\n use errors::snippet::{SnippetData};\n use config;\n use entry::{self, EntryPointType};\n-use ext::base::{ExtCtxt, DummyMacroLoader};\n+use ext::base::{ExtCtxt, Resolver};\n use ext::build::AstBuilder;\n use ext::expand::ExpansionConfig;\n use fold::Folder;\n@@ -70,6 +70,7 @@ struct TestCtxt<'a> {\n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n pub fn modify_for_testing(sess: &ParseSess,\n+                          resolver: &mut Resolver,\n                           should_test: bool,\n                           krate: ast::Crate,\n                           span_diagnostic: &errors::Handler) -> ast::Crate {\n@@ -82,7 +83,7 @@ pub fn modify_for_testing(sess: &ParseSess,\n                                            \"reexport_test_harness_main\");\n \n     if should_test {\n-        generate_test_harness(sess, reexport_test_harness_main, krate, span_diagnostic)\n+        generate_test_harness(sess, resolver, reexport_test_harness_main, krate, span_diagnostic)\n     } else {\n         krate\n     }\n@@ -248,41 +249,39 @@ fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n     }).chain(tested_submods.into_iter().map(|(r, sym)| {\n         let path = cx.ext_cx.path(DUMMY_SP, vec![super_, r, sym]);\n         cx.ext_cx.item_use_simple_(DUMMY_SP, ast::Visibility::Public, r, path)\n-    }));\n+    })).collect();\n \n     let reexport_mod = ast::Mod {\n         inner: DUMMY_SP,\n-        items: items.collect(),\n+        items: items,\n     };\n \n     let sym = token::gensym_ident(\"__test_reexports\");\n-    let it = P(ast::Item {\n+    let it = cx.ext_cx.monotonic_expander().fold_item(P(ast::Item {\n         ident: sym.clone(),\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ItemKind::Mod(reexport_mod),\n         vis: ast::Visibility::Public,\n         span: DUMMY_SP,\n-    });\n+    })).pop().unwrap();\n \n     (it, sym)\n }\n \n fn generate_test_harness(sess: &ParseSess,\n+                         resolver: &mut Resolver,\n                          reexport_test_harness_main: Option<InternedString>,\n                          krate: ast::Crate,\n                          sd: &errors::Handler) -> ast::Crate {\n     // Remove the entry points\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     let krate = cleaner.fold_crate(krate);\n \n-    let mut loader = DummyMacroLoader;\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n         span_diagnostic: sd,\n-        ext_cx: ExtCtxt::new(sess, vec![],\n-                             ExpansionConfig::default(\"test\".to_string()),\n-                             &mut loader),\n+        ext_cx: ExtCtxt::new(sess, vec![], ExpansionConfig::default(\"test\".to_string()), resolver),\n         path: Vec::new(),\n         testfns: Vec::new(),\n         reexport_test_harness_main: reexport_test_harness_main,\n@@ -511,16 +510,17 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         items: vec![import, mainfn, tests],\n     };\n     let item_ = ast::ItemKind::Mod(testmod);\n-\n     let mod_ident = token::gensym_ident(\"__test\");\n-    let item = P(ast::Item {\n+\n+    let mut expander = cx.ext_cx.monotonic_expander();\n+    let item = expander.fold_item(P(ast::Item {\n         id: ast::DUMMY_NODE_ID,\n         ident: mod_ident,\n         attrs: vec![],\n         node: item_,\n         vis: ast::Visibility::Public,\n         span: DUMMY_SP,\n-    });\n+    })).pop().unwrap();\n     let reexport = cx.reexport_test_harness_main.as_ref().map(|s| {\n         // building `use <ident> = __test::main`\n         let reexport_ident = token::str_to_ident(&s);\n@@ -529,14 +529,14 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n             nospan(ast::ViewPathSimple(reexport_ident,\n                                        path_node(vec![mod_ident, token::str_to_ident(\"main\")])));\n \n-        P(ast::Item {\n+        expander.fold_item(P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n             ident: keywords::Invalid.ident(),\n             attrs: vec![],\n             node: ast::ItemKind::Use(P(use_path)),\n             vis: ast::Visibility::Inherited,\n             span: DUMMY_SP\n-        })\n+        })).pop().unwrap()\n     });\n \n     debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&item));"}, {"sha": "d7bc2a6faeeb993f29f60007b80e88e07815bdb4", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 96, "deletions": 70, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -11,20 +11,14 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{Expr, Generics, ItemKind, MetaItem, VariantData};\n+use syntax::ast::{self, Expr, Generics, ItemKind, MetaItem, VariantData};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n-#[derive(PartialEq)]\n-enum Mode {\n-    Deep,\n-    Shallow,\n-}\n-\n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              span: Span,\n                              mitem: &MetaItem,\n@@ -40,29 +34,38 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n     //      if we used the short form with generics, we'd have to bound the generics with\n     //      Clone + Copy, and then there'd be no Clone impl at all if the user fills in something\n     //      that is Clone but not Copy. and until specialization we can't write both impls.\n+    // - the item is a union with Copy fields\n+    //      Unions with generic parameters still can derive Clone because they require Copy\n+    //      for deriving, Clone alone is not enough.\n+    //      Whever Clone is implemented for fields is irrelevant so we don't assert it.\n     let bounds;\n-    let unify_fieldless_variants;\n     let substructure;\n+    let is_shallow;\n     match *item {\n         Annotatable::Item(ref annitem) => {\n             match annitem.node {\n                 ItemKind::Struct(_, Generics { ref ty_params, .. }) |\n                 ItemKind::Enum(_, Generics { ref ty_params, .. })\n-                    if ty_params.is_empty() &&\n-                       attr::contains_name(&annitem.attrs, \"rustc_copy_clone_marker\") => {\n-\n+                        if attr::contains_name(&annitem.attrs, \"rustc_copy_clone_marker\") &&\n+                           ty_params.is_empty() => {\n+                    bounds = vec![];\n+                    is_shallow = true;\n+                    substructure = combine_substructure(Box::new(|c, s, sub| {\n+                        cs_clone_shallow(\"Clone\", c, s, sub, false)\n+                    }));\n+                }\n+                ItemKind::Union(..) => {\n                     bounds = vec![Literal(path_std!(cx, core::marker::Copy))];\n-                    unify_fieldless_variants = true;\n+                    is_shallow = true;\n                     substructure = combine_substructure(Box::new(|c, s, sub| {\n-                        cs_clone(\"Clone\", c, s, sub, Mode::Shallow)\n+                        cs_clone_shallow(\"Clone\", c, s, sub, true)\n                     }));\n                 }\n-\n                 _ => {\n                     bounds = vec![];\n-                    unify_fieldless_variants = false;\n+                    is_shallow = false;\n                     substructure = combine_substructure(Box::new(|c, s, sub| {\n-                        cs_clone(\"Clone\", c, s, sub, Mode::Deep)\n+                        cs_clone(\"Clone\", c, s, sub)\n                     }));\n                 }\n             }\n@@ -80,7 +83,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n         additional_bounds: bounds,\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        supports_unions: false,\n+        supports_unions: true,\n         methods: vec![MethodDef {\n                           name: \"clone\",\n                           generics: LifetimeBounds::empty(),\n@@ -89,37 +92,72 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                           ret_ty: Self_,\n                           attributes: attrs,\n                           is_unsafe: false,\n-                          unify_fieldless_variants: unify_fieldless_variants,\n+                          unify_fieldless_variants: false,\n                           combine_substructure: substructure,\n                       }],\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand_ext(cx, mitem, item, push, is_shallow)\n+}\n+\n+fn cs_clone_shallow(name: &str,\n+                    cx: &mut ExtCtxt,\n+                    trait_span: Span,\n+                    substr: &Substructure,\n+                    is_union: bool)\n+                    -> P<Expr> {\n+    fn assert_ty_bounds(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>,\n+                        ty: P<ast::Ty>, span: Span, helper_name: &str) {\n+        // Generate statement `let _: helper_name<ty>;`,\n+        // set the expn ID so we can use the unstable struct.\n+        let span = super::allow_unstable(cx, span, \"derive(Clone)\");\n+        let assert_path = cx.path_all(span, true,\n+                                        cx.std_path(&[\"clone\", helper_name]),\n+                                        vec![], vec![ty], vec![]);\n+        stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n+    }\n+    fn process_variant(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>, variant: &VariantData) {\n+        for field in variant.fields() {\n+            // let _: AssertParamIsClone<FieldTy>;\n+            assert_ty_bounds(cx, stmts, field.ty.clone(), field.span, \"AssertParamIsClone\");\n+        }\n+    }\n+\n+    let mut stmts = Vec::new();\n+    if is_union {\n+        // let _: AssertParamIsCopy<Self>;\n+        let self_ty = cx.ty_path(cx.path_ident(trait_span, keywords::SelfType.ident()));\n+        assert_ty_bounds(cx, &mut stmts, self_ty, trait_span, \"AssertParamIsCopy\");\n+    } else {\n+        match *substr.fields {\n+            StaticStruct(vdata, ..) => {\n+                process_variant(cx, &mut stmts, vdata);\n+            }\n+            StaticEnum(enum_def, ..) => {\n+                for variant in &enum_def.variants {\n+                    process_variant(cx, &mut stmts, &variant.node.data);\n+                }\n+            }\n+            _ => cx.span_bug(trait_span, &format!(\"unexpected substructure in \\\n+                                                    shallow `derive({})`\", name))\n+        }\n+    }\n+    stmts.push(cx.stmt_expr(cx.expr_deref(trait_span, cx.expr_self(trait_span))));\n+    cx.expr_block(cx.block(trait_span, stmts))\n }\n \n fn cs_clone(name: &str,\n             cx: &mut ExtCtxt,\n             trait_span: Span,\n-            substr: &Substructure,\n-            mode: Mode)\n+            substr: &Substructure)\n             -> P<Expr> {\n     let ctor_path;\n     let all_fields;\n-    let fn_path = match mode {\n-        Mode::Shallow => cx.std_path(&[\"clone\", \"assert_receiver_is_clone\"]),\n-        Mode::Deep => cx.std_path(&[\"clone\", \"Clone\", \"clone\"]),\n-    };\n+    let fn_path = cx.std_path(&[\"clone\", \"Clone\", \"clone\"]);\n     let subcall = |cx: &mut ExtCtxt, field: &FieldInfo| {\n         let args = vec![cx.expr_addr_of(field.span, field.self_.clone())];\n-\n-        let span = if mode == Mode::Shallow {\n-            // set the expn ID so we can call the unstable method\n-            super::allow_unstable(cx, field.span, \"derive(Clone)\")\n-        } else {\n-            field.span\n-        };\n-        cx.expr_call_global(span, fn_path.clone(), args)\n+        cx.expr_call_global(field.span, fn_path.clone(), args)\n     };\n \n     let vdata;\n@@ -145,43 +183,31 @@ fn cs_clone(name: &str,\n         }\n     }\n \n-    match mode {\n-        Mode::Shallow => {\n-            let mut stmts = all_fields.iter().map(|f| {\n-                let call = subcall(cx, f);\n-                cx.stmt_expr(call)\n-            }).collect::<Vec<_>>();\n-            stmts.push(cx.stmt_expr(cx.expr_deref(trait_span, cx.expr_self(trait_span))));\n-            cx.expr_block(cx.block(trait_span, stmts))\n-        }\n-        Mode::Deep => {\n-            match *vdata {\n-                VariantData::Struct(..) => {\n-                    let fields = all_fields.iter()\n-                        .map(|field| {\n-                            let ident = match field.name {\n-                                Some(i) => i,\n-                                None => {\n-                                    cx.span_bug(trait_span,\n-                                                &format!(\"unnamed field in normal struct in \\\n-                                                     `derive({})`\",\n-                                                         name))\n-                                }\n-                            };\n-                            let call = subcall(cx, field);\n-                            cx.field_imm(field.span, ident, call)\n-                        })\n-                        .collect::<Vec<_>>();\n+    match *vdata {\n+        VariantData::Struct(..) => {\n+            let fields = all_fields.iter()\n+                .map(|field| {\n+                    let ident = match field.name {\n+                        Some(i) => i,\n+                        None => {\n+                            cx.span_bug(trait_span,\n+                                        &format!(\"unnamed field in normal struct in \\\n+                                                `derive({})`\",\n+                                                    name))\n+                        }\n+                    };\n+                    let call = subcall(cx, field);\n+                    cx.field_imm(field.span, ident, call)\n+                })\n+                .collect::<Vec<_>>();\n \n-                    cx.expr_struct(trait_span, ctor_path, fields)\n-                }\n-                VariantData::Tuple(..) => {\n-                    let subcalls = all_fields.iter().map(|f| subcall(cx, f)).collect();\n-                    let path = cx.expr_path(ctor_path);\n-                    cx.expr_call(trait_span, path, subcalls)\n-                }\n-                VariantData::Unit(..) => cx.expr_path(ctor_path),\n-            }\n+            cx.expr_struct(trait_span, ctor_path, fields)\n+        }\n+        VariantData::Tuple(..) => {\n+            let subcalls = all_fields.iter().map(|f| subcall(cx, f)).collect();\n+            let path = cx.expr_path(ctor_path);\n+            cx.expr_call(trait_span, path, subcalls)\n         }\n+        VariantData::Unit(..) => cx.expr_path(ctor_path),\n     }\n }"}, {"sha": "fa0fb2492c551c439287a6be89795bbe1cbc758d", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -11,7 +11,7 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{Expr, MetaItem};\n+use syntax::ast::{self, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n@@ -23,22 +23,6 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           mitem: &MetaItem,\n                           item: &Annotatable,\n                           push: &mut FnMut(Annotatable)) {\n-    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_same_method(|cx, span, exprs| {\n-            // create `a.<method>(); b.<method>(); c.<method>(); ...`\n-            // (where method is `assert_receiver_is_total_eq`)\n-            let stmts = exprs.into_iter().map(|e| cx.stmt_expr(e)).collect();\n-            let block = cx.block(span, stmts);\n-            cx.expr_block(block)\n-        },\n-                       Box::new(|cx, sp, _, _| {\n-                           cx.span_bug(sp, \"non matching enums in derive(Eq)?\")\n-                       }),\n-                       cx,\n-                       span,\n-                       substr)\n-    }\n-\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let hidden = cx.meta_list_item_word(span, InternedString::new(\"hidden\"));\n     let doc = cx.meta_list(span, InternedString::new(\"doc\"), vec![hidden]);\n@@ -50,7 +34,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        supports_unions: false,\n+        supports_unions: true,\n         methods: vec![MethodDef {\n                           name: \"assert_receiver_is_total_eq\",\n                           generics: LifetimeBounds::empty(),\n@@ -66,5 +50,38 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                       }],\n         associated_types: Vec::new(),\n     };\n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand_ext(cx, mitem, item, push, true)\n+}\n+\n+fn cs_total_eq_assert(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n+    fn assert_ty_bounds(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>,\n+                        ty: P<ast::Ty>, span: Span, helper_name: &str) {\n+        // Generate statement `let _: helper_name<ty>;`,\n+        // set the expn ID so we can use the unstable struct.\n+        let span = super::allow_unstable(cx, span, \"derive(Eq)\");\n+        let assert_path = cx.path_all(span, true,\n+                                        cx.std_path(&[\"cmp\", helper_name]),\n+                                        vec![], vec![ty], vec![]);\n+        stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n+    }\n+    fn process_variant(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>, variant: &ast::VariantData) {\n+        for field in variant.fields() {\n+            // let _: AssertParamIsEq<FieldTy>;\n+            assert_ty_bounds(cx, stmts, field.ty.clone(), field.span, \"AssertParamIsEq\");\n+        }\n+    }\n+\n+    let mut stmts = Vec::new();\n+    match *substr.fields {\n+        StaticStruct(vdata, ..) => {\n+            process_variant(cx, &mut stmts, vdata);\n+        }\n+        StaticEnum(enum_def, ..) => {\n+            for variant in &enum_def.variants {\n+                process_variant(cx, &mut stmts, &variant.node.data);\n+            }\n+        }\n+        _ => cx.span_bug(trait_span, \"unexpected substructure in `derive(Eq)`\")\n+    }\n+    cx.expr_block(cx.block(trait_span, stmts))\n }"}, {"sha": "339a6c477ccd5df1a55fecfd3f91a357c12d9fbc", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -401,18 +401,29 @@ impl<'a> TraitDef<'a> {\n                   mitem: &ast::MetaItem,\n                   item: &'a Annotatable,\n                   push: &mut FnMut(Annotatable)) {\n+        self.expand_ext(cx, mitem, item, push, false);\n+    }\n+\n+    pub fn expand_ext(&self,\n+                      cx: &mut ExtCtxt,\n+                      mitem: &ast::MetaItem,\n+                      item: &'a Annotatable,\n+                      push: &mut FnMut(Annotatable),\n+                      from_scratch: bool) {\n         match *item {\n             Annotatable::Item(ref item) => {\n                 let newitem = match item.node {\n                     ast::ItemKind::Struct(ref struct_def, ref generics) => {\n-                        self.expand_struct_def(cx, &struct_def, item.ident, generics)\n+                        self.expand_struct_def(cx, &struct_def, item.ident, generics, from_scratch)\n                     }\n                     ast::ItemKind::Enum(ref enum_def, ref generics) => {\n-                        self.expand_enum_def(cx, enum_def, &item.attrs, item.ident, generics)\n+                        self.expand_enum_def(cx, enum_def, &item.attrs,\n+                                             item.ident, generics, from_scratch)\n                     }\n                     ast::ItemKind::Union(ref struct_def, ref generics) => {\n                         if self.supports_unions {\n-                            self.expand_struct_def(cx, &struct_def, item.ident, generics)\n+                            self.expand_struct_def(cx, &struct_def, item.ident,\n+                                                   generics, from_scratch)\n                         } else {\n                             cx.span_err(mitem.span,\n                                         \"this trait cannot be derived for unions\");\n@@ -661,7 +672,8 @@ impl<'a> TraitDef<'a> {\n                          cx: &mut ExtCtxt,\n                          struct_def: &'a VariantData,\n                          type_ident: Ident,\n-                         generics: &Generics)\n+                         generics: &Generics,\n+                         from_scratch: bool)\n                          -> P<ast::Item> {\n         let field_tys: Vec<P<ast::Ty>> = struct_def.fields()\n             .iter()\n@@ -674,7 +686,7 @@ impl<'a> TraitDef<'a> {\n                 let (explicit_self, self_args, nonself_args, tys) =\n                     method_def.split_self_nonself_args(cx, self, type_ident, generics);\n \n-                let body = if method_def.is_static() {\n+                let body = if from_scratch || method_def.is_static() {\n                     method_def.expand_static_struct_method_body(cx,\n                                                                 self,\n                                                                 struct_def,\n@@ -709,7 +721,8 @@ impl<'a> TraitDef<'a> {\n                        enum_def: &'a EnumDef,\n                        type_attrs: &[ast::Attribute],\n                        type_ident: Ident,\n-                       generics: &Generics)\n+                       generics: &Generics,\n+                       from_scratch: bool)\n                        -> P<ast::Item> {\n         let mut field_tys = Vec::new();\n \n@@ -727,7 +740,7 @@ impl<'a> TraitDef<'a> {\n                 let (explicit_self, self_args, nonself_args, tys) =\n                     method_def.split_self_nonself_args(cx, self, type_ident, generics);\n \n-                let body = if method_def.is_static() {\n+                let body = if from_scratch || method_def.is_static() {\n                     method_def.expand_static_enum_method_body(cx,\n                                                               self,\n                                                               enum_def,"}, {"sha": "6162beb80eccc7d9eb53c92cabd9c8e7b5f9e251", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -11,8 +11,7 @@\n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n use syntax::ast::{self, MetaItem};\n-use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxEnv};\n-use syntax::ext::base::MultiModifier;\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n use syntax::codemap;\n@@ -89,7 +88,7 @@ fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n     }\n }\n \n-fn expand_derive(cx: &mut ExtCtxt,\n+pub fn expand_derive(cx: &mut ExtCtxt,\n                  span: Span,\n                  mitem: &MetaItem,\n                  annotatable: Annotatable)\n@@ -243,10 +242,6 @@ fn expand_derive(cx: &mut ExtCtxt,\n \n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n-        pub fn register_all(env: &mut SyntaxEnv) {\n-            env.insert(intern(\"derive\"), MultiModifier(Box::new(expand_derive)));\n-        }\n-\n         pub fn is_builtin_trait(name: &str) -> bool {\n             match name {\n                 $( $name )|+ => true,"}, {"sha": "892ebcfa76129ee468188419c22db46ebf7b81ec", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -17,7 +17,6 @@ use syntax::ast;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n-use syntax::fold::Folder;\n use syntax::parse::token::{self, keywords};\n use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -702,10 +701,12 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     let arg_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let macsp = ecx.call_site();\n-    // Expand the format literal so that efmt.span will have a backtrace. This\n-    // is essential for locating a bug when the format literal is generated in\n-    // a macro. (e.g. println!(\"{}\"), which uses concat!($fmt, \"\\n\")).\n-    let efmt = ecx.expander().fold_expr(efmt);\n+    let msg = \"format argument must be a string literal.\";\n+    let fmt = match expr_to_spanned_string(ecx, efmt, msg) {\n+        Some(fmt) => fmt,\n+        None => return DummyResult::raw_expr(sp),\n+    };\n+\n     let mut cx = Context {\n         ecx: ecx,\n         args: args,\n@@ -723,14 +724,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         str_pieces: Vec::new(),\n         all_pieces_simple: true,\n         macsp: macsp,\n-        fmtsp: efmt.span,\n-    };\n-    let fmt = match expr_to_string(cx.ecx, efmt, \"format argument must be a string literal.\") {\n-        Some((fmt, _)) => fmt,\n-        None => return DummyResult::raw_expr(sp),\n+        fmtsp: fmt.span,\n     };\n \n-    let mut parser = parse::Parser::new(&fmt);\n+    let mut parser = parse::Parser::new(&fmt.node.0);\n     let mut pieces = vec![];\n \n     loop {"}, {"sha": "3a6212e5445ce6d687940e3e36a1ea37369d0be6", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 61, "deletions": 27, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -34,11 +34,6 @@ extern crate syntax_pos;\n extern crate rustc_macro;\n extern crate rustc_errors as errors;\n \n-use syntax::ext::base::{MacroExpanderFn, NormalTT};\n-use syntax::ext::base::{SyntaxEnv, SyntaxExtension};\n-use syntax::parse::token::intern;\n-\n-\n mod asm;\n mod cfg;\n mod concat;\n@@ -53,28 +48,67 @@ pub mod rustc_macro_registrar;\n // for custom_derive\n pub mod deriving;\n \n-pub fn register_builtins(env: &mut SyntaxEnv) {\n-    // utility function to simplify creating NormalTT syntax extensions\n-    fn builtin_normal_expander(f: MacroExpanderFn) -> SyntaxExtension {\n-        NormalTT(Box::new(f), None, false)\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax::ext::base::{MacroExpanderFn, MacroRulesTT, NormalTT, MultiModifier};\n+use syntax::ext::hygiene::Mark;\n+use syntax::parse::token::intern;\n+\n+pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver, enable_quotes: bool) {\n+    let mut register = |name, ext| {\n+        resolver.add_macro(Mark::root(), ast::Ident::with_empty_ctxt(intern(name)), Rc::new(ext));\n+    };\n+\n+    register(\"macro_rules\", MacroRulesTT);\n+\n+    macro_rules! register {\n+        ($( $name:ident: $f:expr, )*) => { $(\n+            register(stringify!($name), NormalTT(Box::new($f as MacroExpanderFn), None, false));\n+        )* }\n     }\n \n-    env.insert(intern(\"asm\"), builtin_normal_expander(asm::expand_asm));\n-    env.insert(intern(\"cfg\"), builtin_normal_expander(cfg::expand_cfg));\n-    env.insert(intern(\"concat\"),\n-               builtin_normal_expander(concat::expand_syntax_ext));\n-    env.insert(intern(\"concat_idents\"),\n-               builtin_normal_expander(concat_idents::expand_syntax_ext));\n-    env.insert(intern(\"env\"), builtin_normal_expander(env::expand_env));\n-    env.insert(intern(\"option_env\"),\n-               builtin_normal_expander(env::expand_option_env));\n-    env.insert(intern(\"format_args\"),\n-               // format_args uses `unstable` things internally.\n-               NormalTT(Box::new(format::expand_format_args), None, true));\n-    env.insert(intern(\"log_syntax\"),\n-               builtin_normal_expander(log_syntax::expand_syntax_ext));\n-    env.insert(intern(\"trace_macros\"),\n-               builtin_normal_expander(trace_macros::expand_trace_macros));\n-\n-    deriving::register_all(env);\n+    if enable_quotes {\n+        use syntax::ext::quote::*;\n+        register! {\n+            quote_tokens: expand_quote_tokens,\n+            quote_expr: expand_quote_expr,\n+            quote_ty: expand_quote_ty,\n+            quote_item: expand_quote_item,\n+            quote_pat: expand_quote_pat,\n+            quote_arm: expand_quote_arm,\n+            quote_stmt: expand_quote_stmt,\n+            quote_matcher: expand_quote_matcher,\n+            quote_attr: expand_quote_attr,\n+            quote_arg: expand_quote_arg,\n+            quote_block: expand_quote_block,\n+            quote_meta_item: expand_quote_meta_item,\n+            quote_path: expand_quote_path,\n+        }\n+    }\n+\n+    use syntax::ext::source_util::*;\n+    register! {\n+        line: expand_line,\n+        column: expand_column,\n+        file: expand_file,\n+        stringify: expand_stringify,\n+        include: expand_include,\n+        include_str: expand_include_str,\n+        include_bytes: expand_include_bytes,\n+        module_path: expand_mod,\n+\n+        asm: asm::expand_asm,\n+        cfg: cfg::expand_cfg,\n+        concat: concat::expand_syntax_ext,\n+        concat_idents: concat_idents::expand_syntax_ext,\n+        env: env::expand_env,\n+        option_env: env::expand_option_env,\n+        log_syntax: log_syntax::expand_syntax_ext,\n+        trace_macros: trace_macros::expand_trace_macros,\n+    }\n+\n+    // format_args uses `unstable` things internally.\n+    register(\"format_args\", NormalTT(Box::new(format::expand_format_args), None, true));\n+\n+    register(\"derive\", MultiModifier(Box::new(deriving::expand_derive)));\n }"}, {"sha": "ce3e53cdf97f4ec7382da1842b4cc037114b77bd", "filename": "src/libsyntax_ext/rustc_macro_registrar.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax_ext%2Frustc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Flibsyntax_ext%2Frustc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Frustc_macro_registrar.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -13,12 +13,13 @@ use std::mem;\n use errors;\n use syntax::ast::{self, Ident, NodeId};\n use syntax::codemap::{ExpnInfo, NameAndSpan, MacroAttribute};\n-use syntax::ext::base::{ExtCtxt, DummyMacroLoader};\n+use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::parse::ParseSess;\n use syntax::parse::token::{self, InternedString};\n use syntax::feature_gate::Features;\n+use syntax::fold::Folder;\n use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::visit::{self, Visitor};\n@@ -39,16 +40,14 @@ struct CollectCustomDerives<'a> {\n }\n \n pub fn modify(sess: &ParseSess,\n+              resolver: &mut ::syntax::ext::base::Resolver,\n               mut krate: ast::Crate,\n               is_rustc_macro_crate: bool,\n               num_crate_types: usize,\n               handler: &errors::Handler,\n               features: &Features) -> ast::Crate {\n-    let mut loader = DummyMacroLoader;\n-    let mut cx = ExtCtxt::new(sess,\n-                              Vec::new(),\n-                              ExpansionConfig::default(\"rustc_macro\".to_string()),\n-                              &mut loader);\n+    let ecfg = ExpansionConfig::default(\"rustc_macro\".to_string());\n+    let mut cx = ExtCtxt::new(sess, Vec::new(), ecfg, resolver);\n \n     let mut collect = CollectCustomDerives {\n         derives: Vec::new(),\n@@ -268,13 +267,11 @@ fn mk_registrar(cx: &mut ExtCtxt,\n         i.vis = ast::Visibility::Public;\n         i\n     });\n-    let module = cx.item_mod(span,\n-                             span,\n-                             ast::Ident::with_empty_ctxt(token::gensym(\"registrar\")),\n-                             Vec::new(),\n-                             vec![krate, func]);\n-    module.map(|mut i| {\n+    let ident = ast::Ident::with_empty_ctxt(token::gensym(\"registrar\"));\n+    let module = cx.item_mod(span, span, ident, Vec::new(), vec![krate, func]).map(|mut i| {\n         i.vis = ast::Visibility::Public;\n         i\n-    })\n+    });\n+\n+    cx.monotonic_expander().fold_item(module).pop().unwrap()\n }"}, {"sha": "3e5d17e2ffb17a582a96507019964331a7c4e6e3", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -22,11 +22,11 @@ use syntax_pos::DUMMY_SP;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n-    let mut loader = syntax::ext::base::DummyMacroLoader;\n+    let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut loader);\n+        &mut resolver);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}, {"sha": "c207dbfca5565753f8f79b8a705af0e5b6e4a404", "filename": "src/test/compile-fail/E0407.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2FE0407.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2FE0407.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0407.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -18,7 +18,7 @@ impl Foo for Bar {\n     fn a() {}\n     fn b() {}\n     //~^ ERROR E0407\n-    //~| NOTE not a member of `Foo`\n+    //~| NOTE not a member of trait `Foo`\n }\n \n fn main() {"}, {"sha": "2e2df4bee5a35242caa2451d02dac642e9a9d436", "filename": "src/test/compile-fail/E0438.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2FE0438.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2FE0438.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0438.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -10,11 +10,11 @@\n \n #![feature(associated_consts)]\n \n-trait Foo {}\n+trait Bar {}\n \n-impl Foo for i32 {\n+impl Bar for i32 {\n     const BAR: bool = true; //~ ERROR E0438\n-        //~| NOTE not a member of trait `Foo`\n+        //~| NOTE not a member of trait `Bar`\n }\n \n fn main () {"}, {"sha": "8b6b8d9ecb08ed08c098bf2f2284a569a4df238a", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow-nested.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow-nested.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -18,16 +18,12 @@ struct S {\n     b: u16,\n }\n \n+#[derive(Clone, Copy)]\n union U {\n     s: S,\n     c: u32,\n }\n \n-impl Clone for U {\n-    fn clone(&self) -> Self { *self }\n-}\n-impl Copy for U {}\n-\n fn main() {\n     unsafe {\n         {"}, {"sha": "ecc698acc317f7f09b7223757a83b74a87f5f433", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -12,16 +12,12 @@\n \n #![feature(untagged_unions)]\n \n+#[derive(Clone, Copy)]\n union U {\n     a: u8,\n     b: u64,\n }\n \n-impl Clone for U {\n-    fn clone(&self) -> Self { *self }\n-}\n-impl Copy for U {}\n-\n fn main() {\n     unsafe {\n         let mut u = U { b: 0 };"}, {"sha": "7da529487aa86f74238e5ccff96970818c9b916d", "filename": "src/test/compile-fail/issue-36053-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Fissue-36053-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Fissue-36053-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-36053-2.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #36053. ICE was caused due to obligations\n+// being added to a special, dedicated fulfillment cx during\n+// a probe.\n+\n+use std::iter::once;\n+fn main() {\n+    once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n+    //~^ ERROR no method named `count`\n+    //~| ERROR E0281\n+    //~| ERROR E0281\n+}"}, {"sha": "a064e69bc6d59f3f661edc468b3b7ceb91a42e8d", "filename": "src/test/compile-fail/macro-expansion-tests.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod macros_cant_escape_fns {\n+    fn f() {\n+        macro_rules! m { () => { 3 + 4 } }\n+    }\n+    fn g() -> i32 { m!() } //~ ERROR macro undefined\n+}\n+\n+mod macros_cant_escape_mods {\n+    mod f {\n+        macro_rules! m { () => { 3 + 4 } }\n+    }\n+    fn g() -> i32 { m!() } //~ ERROR macro undefined\n+}\n+\n+mod macros_can_escape_flattened_mods_test {\n+    #[macro_use]\n+    mod f {\n+        macro_rules! m { () => { 3 + 4 } }\n+    }\n+    fn g() -> i32 { m!() }\n+}\n+\n+fn macro_tokens_should_match() {\n+    macro_rules! m { (a) => { 13 } }\n+    m!(a);\n+}\n+\n+// should be able to use a bound identifier as a literal in a macro definition:\n+fn self_macro_parsing() {\n+    macro_rules! foo { (zz) => { 287; } }\n+    fn f(zz: i32) {\n+        foo!(zz);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9014b3f2956b7e7751c97a44d9d49ea1ee4f6637", "filename": "src/test/compile-fail/union/union-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Funion%2Funion-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Funion%2Funion-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-copy.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -10,16 +10,16 @@\n \n #![feature(untagged_unions)]\n \n+#[derive(Clone)]\n union U {\n     a: u8\n }\n \n+#[derive(Clone)]\n union W {\n     a: String\n }\n \n-impl Clone for U { fn clone(&self) { panic!(); } }\n-impl Clone for W { fn clone(&self) { panic!(); } }\n impl Copy for U {} // OK\n impl Copy for W {} //~ ERROR the trait `Copy` may not be implemented for this type\n "}, {"sha": "6e226d7d79f9f1faa12338fb94344bc47dc09c0a", "filename": "src/test/compile-fail/union/union-derive-clone.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-clone.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+#[derive(Clone)] //~ ERROR the trait bound `U1: std::marker::Copy` is not satisfied\n+union U1 {\n+    a: u8,\n+}\n+\n+#[derive(Clone)]\n+union U2 {\n+    a: u8, // OK\n+}\n+\n+impl Copy for U2 {}\n+\n+#[derive(Clone, Copy)]\n+union U3 {\n+    a: u8, // OK\n+}\n+\n+#[derive(Clone, Copy)]\n+union U4<T> {\n+    a: T, // OK\n+}\n+\n+#[derive(Clone)]\n+struct CloneNoCopy;\n+\n+fn main() {\n+    let u = U4 { a: CloneNoCopy };\n+    let w = u.clone(); //~ ERROR no method named `clone` found for type `U4<CloneNoCopy>`\n+}"}, {"sha": "9dfec288c157208697e8160d364ddf149aea8d51", "filename": "src/test/compile-fail/union/union-derive-eq.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-eq.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+#[derive(Eq)] // OK\n+union U1 {\n+    a: u8,\n+}\n+\n+impl PartialEq for U1 { fn eq(&self, rhs: &Self) -> bool { true } }\n+\n+#[derive(PartialEq)]\n+struct PartialEqNotEq;\n+\n+#[derive(Eq)]\n+union U2 {\n+    a: PartialEqNotEq, //~ ERROR the trait bound `PartialEqNotEq: std::cmp::Eq` is not satisfied\n+}\n+\n+impl PartialEq for U2 { fn eq(&self, rhs: &Self) -> bool { true } }\n+\n+fn main() {}"}, {"sha": "26dbdfd0b411847a26b1855813b7119a1568d0fa", "filename": "src/test/compile-fail/union/union-derive.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -13,9 +13,7 @@\n #![feature(untagged_unions)]\n \n #[derive(\n-    Clone, //~ ERROR this trait cannot be derived for unions\n     PartialEq, //~ ERROR this trait cannot be derived for unions\n-    Eq, //~ ERROR this trait cannot be derived for unions\n     PartialOrd, //~ ERROR this trait cannot be derived for unions\n     Ord, //~ ERROR this trait cannot be derived for unions\n     Hash, //~ ERROR this trait cannot be derived for unions"}, {"sha": "1458583ff58303a50dba9d82cf12122e54f8ce90", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -25,11 +25,11 @@ use syntax_pos::DUMMY_SP;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n-    let mut loader = syntax::ext::base::DummyMacroLoader;\n+    let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut loader);\n+        &mut resolver);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}, {"sha": "3d1cbb446e848da4089af0eee941ee3b01c13ae4", "filename": "src/test/run-fail/bounds-check-no-overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbounds-check-no-overflow.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:assertion failed: index < self.len()\n+// error-pattern:index out of bounds\n \n use std::usize;\n use std::mem::size_of;"}, {"sha": "2a53a62a5ab60d5757b7da4c0b25f9ddfb2e732e", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -21,11 +21,11 @@ use syntax_pos::DUMMY_SP;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n-    let mut loader = syntax::ext::base::DummyMacroLoader;\n+    let mut resolver = syntax::ext::base::DummyResolver;\n     let mut cx = syntax::ext::base::ExtCtxt::new(\n         &ps, vec![],\n         syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut loader);\n+        &mut resolver);\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {"}, {"sha": "10e315f269f971af023e23a5148a1f72b90b96a0", "filename": "src/test/run-pass/auxiliary/typeid-intrinsic-aux1.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftypeid-intrinsic-aux1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftypeid-intrinsic-aux1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftypeid-intrinsic-aux1.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -22,6 +22,8 @@ pub type F = Option<isize>;\n pub type G = usize;\n pub type H = &'static str;\n pub type I = Box<Fn()>;\n+pub type I32Iterator = Iterator<Item=i32>;\n+pub type U32Iterator = Iterator<Item=u32>;\n \n pub fn id_A() -> TypeId { TypeId::of::<A>() }\n pub fn id_B() -> TypeId { TypeId::of::<B>() }\n@@ -34,3 +36,6 @@ pub fn id_H() -> TypeId { TypeId::of::<H>() }\n pub fn id_I() -> TypeId { TypeId::of::<I>() }\n \n pub fn foo<T: Any>() -> TypeId { TypeId::of::<T>() }\n+\n+pub fn id_i32_iterator() -> TypeId { TypeId::of::<I32Iterator>() }\n+pub fn id_u32_iterator() -> TypeId { TypeId::of::<U32Iterator>() }"}, {"sha": "10e315f269f971af023e23a5148a1f72b90b96a0", "filename": "src/test/run-pass/auxiliary/typeid-intrinsic-aux2.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftypeid-intrinsic-aux2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftypeid-intrinsic-aux2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Ftypeid-intrinsic-aux2.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -22,6 +22,8 @@ pub type F = Option<isize>;\n pub type G = usize;\n pub type H = &'static str;\n pub type I = Box<Fn()>;\n+pub type I32Iterator = Iterator<Item=i32>;\n+pub type U32Iterator = Iterator<Item=u32>;\n \n pub fn id_A() -> TypeId { TypeId::of::<A>() }\n pub fn id_B() -> TypeId { TypeId::of::<B>() }\n@@ -34,3 +36,6 @@ pub fn id_H() -> TypeId { TypeId::of::<H>() }\n pub fn id_I() -> TypeId { TypeId::of::<I>() }\n \n pub fn foo<T: Any>() -> TypeId { TypeId::of::<T>() }\n+\n+pub fn id_i32_iterator() -> TypeId { TypeId::of::<I32Iterator>() }\n+pub fn id_u32_iterator() -> TypeId { TypeId::of::<U32Iterator>() }"}, {"sha": "e8d14f1d421460fd093fbd82fcbef027137a7a7a", "filename": "src/test/run-pass/issue-35546.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass%2Fissue-35546.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass%2Fissue-35546.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-35546.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #35546. Check that we are able to codegen\n+// this. Before we had problems because of the drop glue signature\n+// around dropping a trait object (specifically, when dropping the\n+// `value` field of `Node<Send>`).\n+\n+struct Node<T: ?Sized + Send> {\n+    next: Option<Box<Node<Send>>>,\n+    value: T,\n+}\n+\n+fn clear(head: &mut Option<Box<Node<Send>>>) {\n+    match head.take() {\n+        Some(node) => *head = node.next,\n+        None => (),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2411996cf054b0187fac11434f4dc0300e014ff7", "filename": "src/test/run-pass/issue-36053.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass%2Fissue-36053.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass%2Fissue-36053.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-36053.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #36053. ICE was caused due to obligations being\n+// added to a special, dedicated fulfillment cx during a\n+// probe. Problem seems to be related to the particular definition of\n+// `FusedIterator` in std but I was not able to isolate that into an\n+// external crate.\n+\n+#![feature(fused)]\n+use std::iter::FusedIterator;\n+\n+struct Thing<'a>(&'a str);\n+impl<'a> Iterator for Thing<'a> {\n+    type Item = &'a str;\n+    fn next(&mut self) -> Option<&'a str> {\n+        None\n+    }\n+}\n+\n+impl<'a> FusedIterator for Thing<'a> {}\n+\n+fn main() {\n+    Thing(\"test\").fuse().filter(|_| true).count();\n+}"}, {"sha": "36650368d57be58b003be1cfc777fe3eff1f5152", "filename": "src/test/run-pass/typeid-intrinsic.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -78,4 +78,13 @@ pub fn main() {\n     b.hash(&mut s2);\n \n     assert_eq!(s1.finish(), s2.finish());\n+\n+    // Check projections\n+\n+    assert_eq!(TypeId::of::<other1::I32Iterator>(), other1::id_i32_iterator());\n+    assert_eq!(TypeId::of::<other1::U32Iterator>(), other1::id_u32_iterator());\n+    assert_eq!(other1::id_i32_iterator(), other2::id_i32_iterator());\n+    assert_eq!(other1::id_u32_iterator(), other2::id_u32_iterator());\n+    assert!(other1::id_i32_iterator() != other1::id_u32_iterator());\n+    assert!(TypeId::of::<other1::I32Iterator>() != TypeId::of::<other1::U32Iterator>());\n }"}, {"sha": "bea4d5f923e21f314f9caa22cd725c5bf21c0319", "filename": "src/test/run-pass/union/union-c-interop.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -10,24 +10,21 @@\n \n #![feature(untagged_unions)]\n \n-#[derive(Copy)]\n+#[derive(Clone, Copy)]\n #[repr(C)]\n struct LARGE_INTEGER_U {\n     LowPart: u32,\n     HighPart: u32,\n }\n \n-#[derive(Copy)]\n+#[derive(Clone, Copy)]\n #[repr(C)]\n union LARGE_INTEGER {\n   __unnamed__: LARGE_INTEGER_U,\n   u: LARGE_INTEGER_U,\n   QuadPart: u64,\n }\n \n-impl Clone for LARGE_INTEGER_U { fn clone(&self) -> Self { *self } }\n-impl Clone for LARGE_INTEGER { fn clone(&self) -> Self { *self } }\n-\n #[link(name = \"rust_test_helpers\")]\n extern \"C\" {\n     fn increment_all_parts(_: LARGE_INTEGER) -> LARGE_INTEGER;"}, {"sha": "8ff6f17394f9e91ba7ca8eae612f48c25455f971", "filename": "src/test/run-pass/union/union-derive.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs?ref=dc75933abaf3f6d619ada2bbc12b01bc85ddb4ae", "patch": "@@ -14,18 +14,34 @@\n \n #[derive(\n     Copy,\n+    Clone,\n+    Eq,\n )]\n union U {\n     a: u8,\n     b: u16,\n }\n \n-impl Clone for U {\n-    fn clone(&self) -> Self { *self }\n+impl PartialEq for U { fn eq(&self, rhs: &Self) -> bool { true } }\n+\n+#[derive(\n+    Clone,\n+    Copy,\n+    Eq\n+)]\n+union W<T> {\n+    a: T,\n }\n \n+impl<T> PartialEq for W<T> { fn eq(&self, rhs: &Self) -> bool { true } }\n+\n fn main() {\n     let u = U { b: 0 };\n     let u1 = u;\n     let u2 = u.clone();\n+    assert!(u1 == u2);\n+\n+    let w = W { a: 0 };\n+    let w1 = w.clone();\n+    assert!(w == w1);\n }"}]}