{"sha": "abe7874b35d8b5020e2d1f8e5eca6b460cef98fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZTc4NzRiMzVkOGI1MDIwZTJkMWY4ZTVlY2E2YjQ2MGNlZjk4ZmM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-10-06T17:59:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-10-08T19:49:52Z"}, "message": "book: Add documentation on custom allocators\n\nThis adds a chapter to the nightly section of the book on leveraging and\nimplementing the `#![allocator]` attribute to write custom allocators as well as\nexplaining the current situation with allocators.", "tree": {"sha": "858676d4556eabbcce7d8dc7367dd122a1950c3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/858676d4556eabbcce7d8dc7367dd122a1950c3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abe7874b35d8b5020e2d1f8e5eca6b460cef98fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abe7874b35d8b5020e2d1f8e5eca6b460cef98fc", "html_url": "https://github.com/rust-lang/rust/commit/abe7874b35d8b5020e2d1f8e5eca6b460cef98fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abe7874b35d8b5020e2d1f8e5eca6b460cef98fc/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e50298f7b53d4f51c936c0f61e282d6cb7ff2a19", "url": "https://api.github.com/repos/rust-lang/rust/commits/e50298f7b53d4f51c936c0f61e282d6cb7ff2a19", "html_url": "https://github.com/rust-lang/rust/commit/e50298f7b53d4f51c936c0f61e282d6cb7ff2a19"}], "stats": {"total": 171, "additions": 171, "deletions": 0}, "files": [{"sha": "fd02a7b1afa5b0f944014ed6cfefc35eb8c3a7b0", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abe7874b35d8b5020e2d1f8e5eca6b460cef98fc/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/abe7874b35d8b5020e2d1f8e5eca6b460cef98fc/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=abe7874b35d8b5020e2d1f8e5eca6b460cef98fc", "patch": "@@ -68,5 +68,6 @@\n     * [Box Syntax and Patterns](box-syntax-and-patterns.md)\n     * [Slice Patterns](slice-patterns.md)\n     * [Associated Constants](associated-constants.md)\n+    * [Custom Allocators](custom-allocators.md)\n * [Glossary](glossary.md)\n * [Bibliography](bibliography.md)"}, {"sha": "4fd05e87a7e69877f17c4a9e0b75e7b052f7951f", "filename": "src/doc/trpl/custom-allocators.md", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/abe7874b35d8b5020e2d1f8e5eca6b460cef98fc/src%2Fdoc%2Ftrpl%2Fcustom-allocators.md", "raw_url": "https://github.com/rust-lang/rust/raw/abe7874b35d8b5020e2d1f8e5eca6b460cef98fc/src%2Fdoc%2Ftrpl%2Fcustom-allocators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcustom-allocators.md?ref=abe7874b35d8b5020e2d1f8e5eca6b460cef98fc", "patch": "@@ -0,0 +1,170 @@\n+% Custom Allocators\n+\n+Allocating memory isn't always the easiest thing to do, and while Rust generally\n+takes care of this by default it often becomes necessary to customize how\n+allocation occurs. The compiler and standard library currently allow switching\n+out the default global allocator in use at compile time. The design is currently\n+spelled out in [RFC 1183][rfc] but this will walk you through how to get your\n+own allocator up and running.\n+\n+[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1183-swap-out-jemalloc.md\n+\n+# Default Allocator\n+\n+The compiler currently ships two default allocators: `alloc_system` and\n+`alloc_jemalloc` (some targets don't have jemalloc, however). These allocators\n+are just normal Rust crates and contain an implementation of the routines to\n+allocate and deallocate memory. The standard library is not compiled assuming\n+either one, and the compiler will decide which allocator is in use at\n+compile-time depending on the type of output artifact being produced.\n+\n+Binaries generated by the compiler will use `alloc_jemalloc` by default (where\n+available). In this situation the compiler \"controls the world\" in the sense of\n+it has power over the final link. Primarily this means that the allocator\n+decision can be left up the compiler.\n+\n+Dynamic and static libraries, however, will use `alloc_system` by default. Here\n+Rust is typically a 'guest' in another application or another world where it\n+cannot authoritatively decide what allocator is in use. As a result it resorts\n+back to the standard APIs (e.g. `malloc` and `free`) for acquiring and releasing\n+memory.\n+\n+# Switching Allocators\n+\n+Although the compiler's default choices may work most of the time, it's often\n+necessary to tweak certain aspects. Overriding the compiler's decision about\n+which allocator is in use is done simply by linking to the desired allocator:\n+\n+```rust,no_run\n+#![feature(alloc_system)]\n+\n+extern crate alloc_system;\n+\n+fn main() {\n+    let a = Box::new(4); // allocates from the system allocator\n+    println!(\"{}\", a);\n+}\n+```\n+\n+In this example the binary generated will not link to jemalloc by default but\n+instead use the system allocator. Conversely to generate a dynamic library which\n+uses jemalloc by default one would write:\n+\n+```rust,ignore\n+#![feature(alloc_jemalloc)]\n+#![crate_type = \"dylib\"]\n+\n+extern crate alloc_jemalloc;\n+\n+pub fn foo() {\n+    let a = Box::new(4); // allocates from jemalloc\n+    println!(\"{}\", a);\n+}\n+# fn main() {}\n+```\n+\n+# Writing a custom allocator\n+\n+Sometimes even the choices of jemalloc vs the system allocator aren't enough and\n+an entirely new custom allocator is required. In this you'll write your own\n+crate which implements the allocator API (e.g. the same as `alloc_system` or\n+`alloc_jemalloc`). As an example, let's take a look at a simplified and\n+annotated version of `alloc_system`\n+\n+```rust,no_run\n+# // only needed for rustdoc --test down below\n+# #![feature(lang_items)]\n+// The compiler needs to be instructed that this crate is an allocator in order\n+// to realize that when this is linked in another allocator like jemalloc should\n+// not be linked in\n+#![feature(allocator)]\n+#![allocator]\n+\n+// Allocators are not allowed to depend on the standard library which in turn\n+// requires an allocator in order to avoid circular dependencies. This crate,\n+// however, can use all of libcore.\n+#![feature(no_std)]\n+#![no_std]\n+\n+// Let's give a unique name to our custom allocator\n+#![crate_name = \"my_allocator\"]\n+#![crate_type = \"rlib\"]\n+\n+// Our system allocator will use the in-tree libc crate for FFI bindings. Note\n+// that currently the external (crates.io) libc cannot be used because it links\n+// to the standard library (e.g. `#![no_std]` isn't stable yet), so that's why\n+// this specifically requires the in-tree version.\n+#![feature(libc)]\n+extern crate libc;\n+\n+// Listed below are the five allocation functions currently required by custom\n+// allocators. Their signatures and symbol names are not currently typechecked\n+// by the compiler, but this is a future extension and are required to match\n+// what is found below.\n+//\n+// Note that the standard `malloc` and `realloc` functions do not provide a way\n+// to communicate alignment so this implementation would need to be improved\n+// with respect to alignment in that aspect.\n+\n+#[no_mangle]\n+pub extern fn __rust_allocate(size: usize, _align: usize) -> *mut u8 {\n+    unsafe { libc::malloc(size as libc::size_t) as *mut u8 }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {\n+    unsafe { libc::free(ptr as *mut libc::c_void) }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_reallocate(ptr: *mut u8, _old_size: usize, size: usize,\n+                                _align: usize) -> *mut u8 {\n+    unsafe {\n+        libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_reallocate_inplace(_ptr: *mut u8, old_size: usize,\n+                                        _size: usize, _align: usize) -> usize {\n+    old_size // this api is not supported by libc\n+}\n+\n+#[no_mangle]\n+pub extern fn __rust_usable_size(size: usize, _align: usize) -> usize {\n+    size\n+}\n+\n+# // just needed to get rustdoc to test this\n+# fn main() {}\n+# #[lang = \"panic_fmt\"] fn panic_fmt() {}\n+# #[lang = \"eh_personality\"] fn eh_personality() {}\n+# #[lang = \"eh_unwind_resume\"] extern fn eh_unwind_resume() {}\n+```\n+\n+After we compile this crate, it can be used as follows:\n+\n+```rust,ignore\n+extern crate my_allocator;\n+\n+fn main() {\n+    let a = Box::new(8); // allocates memory via our custom allocator crate\n+    println!(\"{}\", a);\n+}\n+```\n+\n+# Custom allocator limitations\n+\n+There are a few restrictions when working with custom allocators which may cause\n+compiler errors:\n+\n+* Any one artifact may only be linked to at most one allocator. Binaries,\n+  dylibs, and staticlibs must link to exactly one allocator, and if none have\n+  been explicitly chosen the compiler will choose one. On the other than rlibs\n+  do not need to link to an allocator (but still can).\n+\n+* A consumer of an allocator is tagged with `#![needs_allocator]` (e.g. the\n+  `liballoc` crate currently) and an `#[allocator]` crate cannot transitively\n+  depend on a crate which needs an allocator (e.g. circular dependencies are not\n+  allowed). This basically means that allocators must restrict themselves to\n+  libcore currently."}]}