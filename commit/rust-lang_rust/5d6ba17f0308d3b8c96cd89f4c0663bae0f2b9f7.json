{"sha": "5d6ba17f0308d3b8c96cd89f4c0663bae0f2b9f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNmJhMTdmMDMwOGQzYjhjOTZjZDg5ZjRjMDY2M2JhZTBmMmI5Zjc=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2016-02-27T23:02:48Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2016-02-28T17:41:33Z"}, "message": "Add UDP functionality from net2", "tree": {"sha": "1cfc6836392f7bbf4c9d941b31896184bf54c883", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cfc6836392f7bbf4c9d941b31896184bf54c883"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d6ba17f0308d3b8c96cd89f4c0663bae0f2b9f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d6ba17f0308d3b8c96cd89f4c0663bae0f2b9f7", "html_url": "https://github.com/rust-lang/rust/commit/5d6ba17f0308d3b8c96cd89f4c0663bae0f2b9f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d6ba17f0308d3b8c96cd89f4c0663bae0f2b9f7/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "827be2de0d753afb3e5a00e66afe6e3c3ac79494", "url": "https://api.github.com/repos/rust-lang/rust/commits/827be2de0d753afb3e5a00e66afe6e3c3ac79494", "html_url": "https://github.com/rust-lang/rust/commit/827be2de0d753afb3e5a00e66afe6e3c3ac79494"}], "stats": {"total": 391, "additions": 387, "deletions": 4}, "files": [{"sha": "bce82565fdf4c55bc75b9a8fba06e21f69fb98b7", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 252, "deletions": 1, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/5d6ba17f0308d3b8c96cd89f4c0663bae0f2b9f7/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d6ba17f0308d3b8c96cd89f4c0663bae0f2b9f7/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=5d6ba17f0308d3b8c96cd89f4c0663bae0f2b9f7", "patch": "@@ -10,7 +10,7 @@\n \n use fmt;\n use io::{self, Error, ErrorKind};\n-use net::{ToSocketAddrs, SocketAddr};\n+use net::{ToSocketAddrs, SocketAddr, Ipv4Addr, Ipv6Addr};\n use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n@@ -140,6 +140,221 @@ impl UdpSocket {\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.write_timeout()\n     }\n+\n+    /// Sets the value of the `SO_BROADCAST` option for this socket.\n+    ///\n+    /// When enabled, this socket is allowed to send packets to a broadcast\n+    /// address.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_broadcast(&self, broadcast: bool) -> io::Result<()> {\n+        self.0.set_broadcast(broadcast)\n+    }\n+\n+    /// Gets the value of the `SO_BROADCAST` option for this socket.\n+    ///\n+    /// For more information about this option, see\n+    /// [`set_broadcast`][link].\n+    ///\n+    /// [link]: #tymethod.set_broadcast\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn broadcast(&self) -> io::Result<bool> {\n+        self.0.broadcast()\n+    }\n+\n+    /// Sets the value of the `IP_MULTICAST_LOOP` option for this socket.\n+    ///\n+    /// If enabled, multicast packets will be looped back to the local socket.\n+    /// Note that this may not have any affect on IPv6 sockets.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n+        self.0.set_multicast_loop_v4(multicast_loop_v4)\n+    }\n+\n+    /// Gets the value of the `IP_MULTICAST_LOOP` option for this socket.\n+    ///\n+    /// For more information about this option, see\n+    /// [`set_multicast_loop_v4`][link].\n+    ///\n+    /// [link]: #tymethod.set_multicast_loop_v4\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+        self.0.multicast_loop_v4()\n+    }\n+\n+    /// Sets the value of the `IP_MULTICAST_TTL` option for this socket.\n+    ///\n+    /// Indicates the time-to-live value of outgoing multicast packets for\n+    /// this socket. The default value is 1 which means that multicast packets\n+    /// don't leave the local network unless explicitly requested.\n+    ///\n+    /// Note that this may not have any affect on IPv6 sockets.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n+        self.0.set_multicast_ttl_v4(multicast_ttl_v4)\n+    }\n+\n+    /// Gets the value of the `IP_MULTICAST_TTL` option for this socket.\n+    ///\n+    /// For more information about this option, see\n+    /// [`set_multicast_ttl_v4`][link].\n+    ///\n+    /// [link]: #tymethod.set_multicast_ttl_v4\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+        self.0.multicast_ttl_v4()\n+    }\n+\n+    /// Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.\n+    ///\n+    /// Controls whether this socket sees the multicast packets it sends itself.\n+    /// Note that this may not have any affect on IPv4 sockets.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> {\n+        self.0.set_multicast_loop_v6(multicast_loop_v6)\n+    }\n+\n+    /// Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.\n+    ///\n+    /// For more information about this option, see\n+    /// [`set_multicast_loop_v6`][link].\n+    ///\n+    /// [link]: #tymethod.set_multicast_loop_v6\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n+        self.0.multicast_loop_v6()\n+    }\n+\n+    /// Sets the value for the `IP_TTL` option on this socket.\n+    ///\n+    /// This value sets the time-to-live field that is used in every packet sent\n+    /// from this socket.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n+        self.0.set_ttl(ttl)\n+    }\n+\n+    /// Gets the value of the `IP_TTL` option for this socket.\n+    ///\n+    /// For more information about this option, see [`set_ttl`][link].\n+    ///\n+    /// [link]: #tymethod.set_ttl\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        self.0.ttl()\n+    }\n+\n+    /// Sets the value for the `IPV6_V6ONLY` option on this socket.\n+    ///\n+    /// If this is set to `true` then the socket is restricted to sending and\n+    /// receiving IPv6 packets only. If this is the case, an IPv4 and an IPv6\n+    /// application can each bind the same port at the same time.\n+    ///\n+    /// If this is set to `false` then the socket can be used to send and\n+    /// receive packets from an IPv4-mapped IPv6 address.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n+        self.0.set_only_v6(only_v6)\n+    }\n+\n+    /// Gets the value of the `IPV6_V6ONLY` option for this socket.\n+    ///\n+    /// For more information about this option, see [`set_only_v6`][link].\n+    ///\n+    /// [link]: #tymethod.set_only_v6\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        self.0.only_v6()\n+    }\n+\n+    /// Executes an operation of the `IP_ADD_MEMBERSHIP` type.\n+    ///\n+    /// This function specifies a new multicast group for this socket to join.\n+    /// The address must be a valid multicast address, and `interface` is the\n+    /// address of the local interface with which the system should join the\n+    /// multicast group. If it's equal to `INADDR_ANY` then an appropriate\n+    /// interface is chosen by the system.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {\n+        self.0.join_multicast_v4(multiaddr, interface)\n+    }\n+\n+    /// Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.\n+    ///\n+    /// This function specifies a new multicast group for this socket to join.\n+    /// The address must be a valid multicast address, and `interface` is the\n+    /// index of the interface to join/leave (or 0 to indicate any interface).\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n+        self.0.join_multicast_v6(multiaddr, interface)\n+    }\n+\n+    /// Executes an operation of the `IP_DROP_MEMBERSHIP` type.\n+    ///\n+    /// For more information about this option, see\n+    /// [`join_multicast_v4`][link].\n+    ///\n+    /// [link]: #tymethod.join_multicast_v4\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {\n+        self.0.leave_multicast_v4(multiaddr, interface)\n+    }\n+\n+    /// Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.\n+    ///\n+    /// For more information about this option, see\n+    /// [`join_multicast_v6`][link].\n+    ///\n+    /// [link]: #tymethod.join_multicast_v6\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n+        self.0.leave_multicast_v6(multiaddr, interface)\n+    }\n+\n+    /// Get the value of the `SO_ERROR` option on this socket.\n+    ///\n+    /// This will retrieve the stored error in the underlying socket, clearing\n+    /// the field in the process. This can be useful for checking errors between\n+    /// calls.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Connects this UDP socket to a remote address, allowing the `send` and\n+    /// `recv` syscalls to be used to send data and also applies filters to only\n+    /// receive data from the specified address.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> {\n+        super::each_addr(addr, |addr| self.0.connect(addr))\n+    }\n+\n+    /// Sends data on the socket to the remote address to which it is connected.\n+    ///\n+    /// The `connect` method will connect this socket to a remote address. This\n+    /// method will fail if the socket is not connected.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.send(buf)\n+    }\n+\n+    /// Receives data on the socket from the remote address to which it is\n+    /// connected.\n+    ///\n+    /// The `connect` method will connect this socket to a remote address. This\n+    /// method will fail if the socket is not connected.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.recv(buf)\n+    }\n+\n+    /// Moves this TCP stream into or out of nonblocking mode.\n+    ///\n+    /// On Unix this corresponds to calling fcntl, and on Windows this\n+    /// corresponds to calling ioctlsocket.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n }\n \n impl AsInner<net_imp::UdpSocket> for UdpSocket {\n@@ -400,4 +615,40 @@ mod tests {\n         assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut);\n         assert!(start.elapsed() > Duration::from_millis(400));\n     }\n+\n+    #[test]\n+    fn connect_send_recv() {\n+        let addr = next_test_ip4();\n+\n+        let socket = t!(UdpSocket::bind(&addr));\n+        t!(socket.connect(addr));\n+\n+        t!(socket.send(b\"hello world\"));\n+\n+        let mut buf = [0; 11];\n+        t!(socket.recv(&mut buf));\n+        assert_eq!(b\"hello world\", &buf[..]);\n+    }\n+\n+    #[test]\n+    fn ttl() {\n+        let ttl = 100;\n+\n+        let addr = next_test_ip4();\n+\n+        let stream = t!(UdpSocket::bind(&addr));\n+\n+        t!(stream.set_ttl(ttl));\n+        assert_eq!(ttl, t!(stream.ttl()));\n+    }\n+\n+    #[test]\n+    fn set_nonblocking() {\n+        let addr = next_test_ip4();\n+\n+        let stream = t!(UdpSocket::bind(&addr));\n+\n+        t!(stream.set_nonblocking(true));\n+        t!(stream.set_nonblocking(false));\n+    }\n }"}, {"sha": "31d3be453725c2f89634d5f31208f0f3f5f34647", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 135, "deletions": 3, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/5d6ba17f0308d3b8c96cd89f4c0663bae0f2b9f7/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d6ba17f0308d3b8c96cd89f4c0663bae0f2b9f7/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=5d6ba17f0308d3b8c96cd89f4c0663bae0f2b9f7", "patch": "@@ -17,7 +17,7 @@ use io::{self, Error, ErrorKind};\n use libc::{c_int, c_char, c_void};\n use mem;\n #[allow(deprecated)]\n-use net::{SocketAddr, Shutdown, IpAddr};\n+use net::{SocketAddr, Shutdown, IpAddr, Ipv4Addr, Ipv6Addr};\n use ptr;\n use str::from_utf8;\n use sys::net::{cvt, cvt_r, cvt_gai, Socket, init, wrlen_t};\n@@ -40,8 +40,7 @@ pub fn setsockopt<T>(sock: &Socket, opt: c_int, val: c_int,\n }\n \n pub fn getsockopt<T: Copy>(sock: &Socket, opt: c_int,\n-                       val: c_int) -> io::Result<T> {\n-    unsafe {\n+                       val: c_int) -> io::Result<T> { unsafe {\n         let mut slot: T = mem::zeroed();\n         let mut len = mem::size_of::<T>() as c::socklen_t;\n         try!(cvt(c::getsockopt(*sock.as_inner(), opt, val,\n@@ -84,6 +83,16 @@ fn sockaddr_to_addr(storage: &c::sockaddr_storage,\n     }\n }\n \n+#[cfg(target_os = \"android\")]\n+fn to_ipv6mr_interface(value: u32) -> c::c_int {\n+    value as c::c_int\n+}\n+\n+#[cfg(not(target_os = \"android\"))]\n+fn to_ipv6mr_interface(value: u32) -> c::c_uint {\n+    value as c::c_uint\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // get_host_addresses\n ////////////////////////////////////////////////////////////////////////////////\n@@ -480,6 +489,129 @@ impl UdpSocket {\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.inner.timeout(c::SO_SNDTIMEO)\n     }\n+\n+    pub fn set_broadcast(&self, broadcast: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::SOL_SOCKET, c::SO_BROADCAST, broadcast as c_int)\n+    }\n+\n+    pub fn broadcast(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::SOL_SOCKET, c::SO_BROADCAST));\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP, multicast_loop_v4 as c_int)\n+    }\n+\n+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP));\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL, multicast_ttl_v4 as c_int)\n+    }\n+\n+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL));\n+        Ok(raw as u32)\n+    }\n+\n+    pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_MULTICAST_LOOP, multicast_loop_v6 as c_int)\n+    }\n+\n+    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_MULTICAST_LOOP));\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr)\n+                         -> io::Result<()> {\n+        let mreq = c::ip_mreq {\n+            imr_multiaddr: *multiaddr.as_inner(),\n+            imr_interface: *interface.as_inner(),\n+        };\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_ADD_MEMBERSHIP, mreq)\n+    }\n+\n+    pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32)\n+                         -> io::Result<()> {\n+        let mreq = c::ipv6_mreq {\n+            ipv6mr_multiaddr: *multiaddr.as_inner(),\n+            ipv6mr_interface: to_ipv6mr_interface(interface),\n+        };\n+        setsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_ADD_MEMBERSHIP, mreq)\n+    }\n+\n+    pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr)\n+                          -> io::Result<()> {\n+        let mreq = c::ip_mreq {\n+            imr_multiaddr: *multiaddr.as_inner(),\n+            imr_interface: *interface.as_inner(),\n+        };\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_DROP_MEMBERSHIP, mreq)\n+    }\n+\n+    pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32)\n+                          -> io::Result<()> {\n+        let mreq = c::ipv6_mreq {\n+            ipv6mr_multiaddr: *multiaddr.as_inner(),\n+            ipv6mr_interface: to_ipv6mr_interface(interface),\n+        };\n+        setsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_DROP_MEMBERSHIP, mreq)\n+    }\n+\n+    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL, ttl as c_int)\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL));\n+        Ok(raw as u32)\n+    }\n+\n+    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY, only_v6 as c_int)\n+    }\n+\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY));\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::SOL_SOCKET, c::SO_ERROR));\n+        if raw == 0 {\n+            Ok(None)\n+        } else {\n+            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n+        }\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.inner.set_nonblocking(nonblocking)\n+    }\n+\n+    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.read(buf)\n+    }\n+\n+    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n+        let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n+        let ret = try!(cvt(unsafe {\n+            c::send(*self.inner.as_inner(),\n+                    buf.as_ptr() as *const c_void,\n+                    len,\n+                    0)\n+        }));\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn connect(&self, addr: &SocketAddr) -> io::Result<()> {\n+        let (addrp, len) = addr.into_inner();\n+        cvt_r(|| unsafe { c::connect(*self.inner.as_inner(), addrp, len) }).map(|_| ())\n+    }\n }\n \n impl FromInner<Socket> for UdpSocket {"}]}