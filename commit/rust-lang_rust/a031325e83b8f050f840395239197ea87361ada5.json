{"sha": "a031325e83b8f050f840395239197ea87361ada5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMzEzMjVlODNiOGYwNTBmODQwMzk1MjM5MTk3ZWE4NzM2MWFkYTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-05-05T23:39:46Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-05-07T16:30:00Z"}, "message": "std: Remove unused helper_thread.rs file\n\nThis module has been removed for quite some time!", "tree": {"sha": "db16512f6978ff82b82cc2b8438f589bc4504c7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db16512f6978ff82b82cc2b8438f589bc4504c7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a031325e83b8f050f840395239197ea87361ada5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a031325e83b8f050f840395239197ea87361ada5", "html_url": "https://github.com/rust-lang/rust/commit/a031325e83b8f050f840395239197ea87361ada5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a031325e83b8f050f840395239197ea87361ada5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "377b1adc36af65ed79be2b79a4e1caf240fc457a", "url": "https://api.github.com/repos/rust-lang/rust/commits/377b1adc36af65ed79be2b79a4e1caf240fc457a", "html_url": "https://github.com/rust-lang/rust/commit/377b1adc36af65ed79be2b79a4e1caf240fc457a"}], "stats": {"total": 170, "additions": 0, "deletions": 170}, "files": [{"sha": "34a58f6c83aa73002f781376b81c0bc049f211a5", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "removed", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/377b1adc36af65ed79be2b79a4e1caf240fc457a/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/377b1adc36af65ed79be2b79a4e1caf240fc457a/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=377b1adc36af65ed79be2b79a4e1caf240fc457a", "patch": "@@ -1,170 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementation of the helper thread for the timer module\n-//!\n-//! This module contains the management necessary for the timer worker thread.\n-//! This thread is responsible for performing the send()s on channels for timers\n-//! that are using channels instead of a blocking call.\n-//!\n-//! The timer thread is lazily initialized, and it's shut down via the\n-//! `shutdown` function provided. It must be maintained as an invariant that\n-//! `shutdown` is only called when the entire program is finished. No new timers\n-//! can be created in the future and there must be no active timers at that\n-//! time.\n-\n-use prelude::v1::*;\n-\n-use boxed;\n-use cell::UnsafeCell;\n-use rt;\n-use sync::{StaticMutex, StaticCondvar};\n-use sync::mpsc::{channel, Sender, Receiver};\n-use sys::helper_signal;\n-\n-use thread;\n-\n-/// A structure for management of a helper thread.\n-///\n-/// This is generally a static structure which tracks the lifetime of a helper\n-/// thread.\n-///\n-/// The fields of this helper are all public, but they should not be used, this\n-/// is for static initialization.\n-pub struct Helper<M:Send> {\n-    /// Internal lock which protects the remaining fields\n-    pub lock: StaticMutex,\n-    pub cond: StaticCondvar,\n-\n-    // You'll notice that the remaining fields are UnsafeCell<T>, and this is\n-    // because all helper thread operations are done through &self, but we need\n-    // these to be mutable (once `lock` is held).\n-\n-    /// Lazily allocated channel to send messages to the helper thread.\n-    pub chan: UnsafeCell<*mut Sender<M>>,\n-\n-    /// OS handle used to wake up a blocked helper thread\n-    pub signal: UnsafeCell<usize>,\n-\n-    /// Flag if this helper thread has booted and been initialized yet.\n-    pub initialized: UnsafeCell<bool>,\n-\n-    /// Flag if this helper thread has shut down\n-    pub shutdown: UnsafeCell<bool>,\n-}\n-\n-unsafe impl<M:Send> Send for Helper<M> { }\n-\n-unsafe impl<M:Send> Sync for Helper<M> { }\n-\n-struct RaceBox(helper_signal::signal);\n-\n-unsafe impl Send for RaceBox {}\n-unsafe impl Sync for RaceBox {}\n-\n-macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n-    static $name: Helper<$m> = Helper {\n-        lock: ::sync::MUTEX_INIT,\n-        cond: ::sync::CONDVAR_INIT,\n-        chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n-        signal: ::cell::UnsafeCell { value: 0 },\n-        initialized: ::cell::UnsafeCell { value: false },\n-        shutdown: ::cell::UnsafeCell { value: false },\n-    };\n-) }\n-\n-impl<M: Send> Helper<M> {\n-    /// Lazily boots a helper thread, becoming a no-op if the helper has already\n-    /// been spawned.\n-    ///\n-    /// This function will check to see if the thread has been initialized, and\n-    /// if it has it returns quickly. If initialization has not happened yet,\n-    /// the closure `f` will be run (inside of the initialization lock) and\n-    /// passed to the helper thread in a separate task.\n-    ///\n-    /// This function is safe to be called many times.\n-    pub fn boot<T, F>(&'static self, f: F, helper: fn(helper_signal::signal, Receiver<M>, T)) where\n-        T: Send + 'static,\n-        F: FnOnce() -> T,\n-    {\n-        unsafe {\n-            let _guard = self.lock.lock().unwrap();\n-            if *self.chan.get() as usize == 0 {\n-                let (tx, rx) = channel();\n-                *self.chan.get() = boxed::into_raw(box tx);\n-                let (receive, send) = helper_signal::new();\n-                *self.signal.get() = send as usize;\n-\n-                let receive = RaceBox(receive);\n-\n-                let t = f();\n-                thread::spawn(move || {\n-                    helper(receive.0, rx, t);\n-                    let _g = self.lock.lock().unwrap();\n-                    *self.shutdown.get() = true;\n-                    self.cond.notify_one()\n-                });\n-\n-                let _ = rt::at_exit(move || { self.shutdown() });\n-                *self.initialized.get() = true;\n-            } else if *self.chan.get() as usize == 1 {\n-                panic!(\"cannot continue usage after shutdown\");\n-            }\n-        }\n-    }\n-\n-    /// Sends a message to a spawned worker thread.\n-    ///\n-    /// This is only valid if the worker thread has previously booted\n-    pub fn send(&'static self, msg: M) {\n-        unsafe {\n-            let _guard = self.lock.lock().unwrap();\n-\n-            // Must send and *then* signal to ensure that the child receives the\n-            // message. Otherwise it could wake up and go to sleep before we\n-            // send the message.\n-            assert!(*self.chan.get() as usize != 0);\n-            assert!(*self.chan.get() as usize != 1,\n-                    \"cannot continue usage after shutdown\");\n-            (**self.chan.get()).send(msg).unwrap();\n-            helper_signal::signal(*self.signal.get() as helper_signal::signal);\n-        }\n-    }\n-\n-    fn shutdown(&'static self) {\n-        unsafe {\n-            // Shut down, but make sure this is done inside our lock to ensure\n-            // that we'll always receive the exit signal when the thread\n-            // returns.\n-            let mut guard = self.lock.lock().unwrap();\n-\n-            let ptr = *self.chan.get();\n-            if ptr as usize == 1 {\n-                panic!(\"cannot continue usage after shutdown\");\n-            }\n-            // Close the channel by destroying it\n-            let chan = Box::from_raw(*self.chan.get());\n-            *self.chan.get() = 1 as *mut Sender<M>;\n-            drop(chan);\n-            helper_signal::signal(*self.signal.get() as helper_signal::signal);\n-\n-            // Wait for the child to exit\n-            while !*self.shutdown.get() {\n-                guard = self.cond.wait(guard).unwrap();\n-            }\n-            drop(guard);\n-\n-            // Clean up after ourselves\n-            self.lock.destroy();\n-            helper_signal::close(*self.signal.get() as helper_signal::signal);\n-            *self.signal.get() = 0;\n-        }\n-    }\n-}"}]}