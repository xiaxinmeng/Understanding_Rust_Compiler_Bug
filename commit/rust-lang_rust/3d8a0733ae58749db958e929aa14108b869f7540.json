{"sha": "3d8a0733ae58749db958e929aa14108b869f7540", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkOGEwNzMzYWU1ODc0OWRiOTU4ZTkyOWFhMTQxMDhiODY5Zjc1NDA=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-05-19T20:26:18Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-05-22T17:03:08Z"}, "message": "Remove dead ScopeTree code", "tree": {"sha": "50a467bcf703484d261db37c3068b776dde876aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50a467bcf703484d261db37c3068b776dde876aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d8a0733ae58749db958e929aa14108b869f7540", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d8a0733ae58749db958e929aa14108b869f7540", "html_url": "https://github.com/rust-lang/rust/commit/3d8a0733ae58749db958e929aa14108b869f7540", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d8a0733ae58749db958e929aa14108b869f7540/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52d628f250d96941affb01f09cc951f802f15d7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/52d628f250d96941affb01f09cc951f802f15d7e", "html_url": "https://github.com/rust-lang/rust/commit/52d628f250d96941affb01f09cc951f802f15d7e"}], "stats": {"total": 431, "additions": 57, "deletions": 374}, "files": [{"sha": "cc479aa17ce95e94735d73cbac12d0dabc453766", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 38, "deletions": 101, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3d8a0733ae58749db958e929aa14108b869f7540", "patch": "@@ -61,7 +61,6 @@ use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n-use rustc_middle::middle::region;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::{\n     self,\n@@ -81,7 +80,6 @@ pub mod nice_region_error;\n \n pub(super) fn note_and_explain_region(\n     tcx: TyCtxt<'tcx>,\n-    region_scope_tree: &region::ScopeTree,\n     err: &mut DiagnosticBuilder<'_>,\n     prefix: &str,\n     region: ty::Region<'tcx>,\n@@ -239,7 +237,6 @@ fn explain_span(tcx: TyCtxt<'tcx>, heading: &str, span: Span) -> (String, Option\n \n pub fn unexpected_hidden_region_diagnostic(\n     tcx: TyCtxt<'tcx>,\n-    region_scope_tree: Option<&region::ScopeTree>,\n     span: Span,\n     hidden_ty: Ty<'tcx>,\n     hidden_region: ty::Region<'tcx>,\n@@ -264,78 +261,53 @@ pub fn unexpected_hidden_region_diagnostic(\n             err.span_note(span, &message);\n         }\n         ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty(_) => {\n-        // Assuming regionck succeeded (*), we ought to always be\n-        // capturing *some* region from the fn header, and hence it\n-        // ought to be free. So under normal circumstances, we will go\n-        // down this path which gives a decent human readable\n-        // explanation.\n-        //\n-        // (*) if not, the `tainted_by_errors` field would be set to\n-        // `Some(ErrorReported)` in any case, so we wouldn't be here at all.\n-        note_and_explain_free_region(\n-            tcx,\n-            &mut err,\n-            &format!(\"hidden type `{}` captures \", hidden_ty),\n-            hidden_region,\n-            \"\",\n-        );\n+            // Assuming regionck succeeded (*), we ought to always be\n+            // capturing *some* region from the fn header, and hence it\n+            // ought to be free. So under normal circumstances, we will go\n+            // down this path which gives a decent human readable\n+            // explanation.\n+            //\n+            // (*) if not, the `tainted_by_errors` field would be set to\n+            // `Some(ErrorReported)` in any case, so we wouldn't be here at all.\n+            note_and_explain_free_region(\n+                tcx,\n+                &mut err,\n+                &format!(\"hidden type `{}` captures \", hidden_ty),\n+                hidden_region,\n+                \"\",\n+            );\n         }\n         _ => {\n-        // Ugh. This is a painful case: the hidden region is not one\n-        // that we can easily summarize or explain. This can happen\n-        // in a case like\n-        // `src/test/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n-        //\n-        // ```\n-        // fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> {\n-        //   if condition() { a } else { b }\n-        // }\n-        // ```\n-        //\n-        // Here the captured lifetime is the intersection of `'a` and\n-        // `'b`, which we can't quite express.\n-\n-        if let Some(region_scope_tree) = region_scope_tree {\n-            // If the `region_scope_tree` is available, this is being\n-            // invoked from the \"region inferencer error\". We can at\n-            // least report a really cryptic error for now.\n+            // Ugh. This is a painful case: the hidden region is not one\n+            // that we can easily summarize or explain. This can happen\n+            // in a case like\n+            // `src/test/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n+            //\n+            // ```\n+            // fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> {\n+            //   if condition() { a } else { b }\n+            // }\n+            // ```\n+            //\n+            // Here the captured lifetime is the intersection of `'a` and\n+            // `'b`, which we can't quite express.\n+\n+            // We can at least report a really cryptic error for now.\n             note_and_explain_region(\n                 tcx,\n-                region_scope_tree,\n                 &mut err,\n                 &format!(\"hidden type `{}` captures \", hidden_ty),\n                 hidden_region,\n                 \"\",\n             );\n-        } else {\n-            // If the `region_scope_tree` is *unavailable*, this is\n-            // being invoked by the code that comes *after* region\n-            // inferencing. This is a bug, as the region inferencer\n-            // ought to have noticed the failed constraint and invoked\n-            // error reporting, which in turn should have prevented us\n-            // from getting trying to infer the hidden type\n-            // completely.\n-            tcx.sess.delay_span_bug(\n-                span,\n-                &format!(\n-                    \"hidden type captures unexpected lifetime `{:?}` \\\n-                     but no region inference failure\",\n-                    hidden_region,\n-                ),\n-            );\n         }\n     }\n-    }\n \n     err\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn report_region_errors(\n-        &self,\n-        region_scope_tree: &region::ScopeTree,\n-        errors: &Vec<RegionResolutionError<'tcx>>,\n-    ) {\n+    pub fn report_region_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n@@ -358,17 +330,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     // general bit of code that displays the error information\n                     RegionResolutionError::ConcreteFailure(origin, sub, sup) => {\n                         if sub.is_placeholder() || sup.is_placeholder() {\n-                            self.report_placeholder_failure(region_scope_tree, origin, sub, sup)\n-                                .emit();\n+                            self.report_placeholder_failure(origin, sub, sup).emit();\n                         } else {\n-                            self.report_concrete_failure(region_scope_tree, origin, sub, sup)\n-                                .emit();\n+                            self.report_concrete_failure(origin, sub, sup).emit();\n                         }\n                     }\n \n                     RegionResolutionError::GenericBoundFailure(origin, param_ty, sub) => {\n                         self.report_generic_bound_failure(\n-                            region_scope_tree,\n                             origin.span(),\n                             Some(origin),\n                             param_ty,\n@@ -385,29 +354,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         sup_r,\n                     ) => {\n                         if sub_r.is_placeholder() {\n-                            self.report_placeholder_failure(\n-                                region_scope_tree,\n-                                sub_origin,\n-                                sub_r,\n-                                sup_r,\n-                            )\n-                            .emit();\n+                            self.report_placeholder_failure(sub_origin, sub_r, sup_r).emit();\n                         } else if sup_r.is_placeholder() {\n-                            self.report_placeholder_failure(\n-                                region_scope_tree,\n-                                sup_origin,\n-                                sub_r,\n-                                sup_r,\n-                            )\n-                            .emit();\n+                            self.report_placeholder_failure(sup_origin, sub_r, sup_r).emit();\n                         } else {\n                             self.report_sub_sup_conflict(\n-                                region_scope_tree,\n-                                var_origin,\n-                                sub_origin,\n-                                sub_r,\n-                                sup_origin,\n-                                sup_r,\n+                                var_origin, sub_origin, sub_r, sup_origin, sup_r,\n                             );\n                         }\n                     }\n@@ -428,13 +380,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // value.\n                         let sub_r = self.tcx.mk_region(ty::ReEmpty(var_universe));\n \n-                        self.report_placeholder_failure(\n-                            region_scope_tree,\n-                            sup_origin,\n-                            sub_r,\n-                            sup_r,\n-                        )\n-                        .emit();\n+                        self.report_placeholder_failure(sup_origin, sub_r, sup_r).emit();\n                     }\n \n                     RegionResolutionError::MemberConstraintFailure {\n@@ -445,7 +391,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         let hidden_ty = self.resolve_vars_if_possible(&hidden_ty);\n                         unexpected_hidden_region_diagnostic(\n                             self.tcx,\n-                            Some(region_scope_tree),\n                             span,\n                             hidden_ty,\n                             member_region,\n@@ -1722,19 +1667,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn report_generic_bound_failure(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         span: Span,\n         origin: Option<SubregionOrigin<'tcx>>,\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n     ) {\n-        self.construct_generic_bound_failure(region_scope_tree, span, origin, bound_kind, sub)\n-            .emit();\n+        self.construct_generic_bound_failure(span, origin, bound_kind, sub).emit();\n     }\n \n     pub fn construct_generic_bound_failure(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         span: Span,\n         origin: Option<SubregionOrigin<'tcx>>,\n         bound_kind: GenericKind<'tcx>,\n@@ -1886,7 +1828,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 ));\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n@@ -1904,7 +1845,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     fn report_sub_sup_conflict(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         var_origin: RegionVariableOrigin,\n         sub_origin: SubregionOrigin<'tcx>,\n         sub_region: Region<'tcx>,\n@@ -1915,7 +1855,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         note_and_explain_region(\n             self.tcx,\n-            region_scope_tree,\n             &mut err,\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n@@ -1941,7 +1880,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 if sub_expected == sup_expected && sub_found == sup_found {\n                     note_and_explain_region(\n                         self.tcx,\n-                        region_scope_tree,\n                         &mut err,\n                         \"...but the lifetime must also be valid for \",\n                         sub_region,\n@@ -1963,7 +1901,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         note_and_explain_region(\n             self.tcx,\n-            region_scope_tree,\n             &mut err,\n             \"but, the lifetime must be valid for \",\n             sub_region,"}, {"sha": "8fbb89da5af416d5da50dd35ac2186393031794f", "filename": "src/librustc_infer/infer/error_reporting/note.rs", "status": "modified", "additions": 10, "deletions": 63, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs?ref=3d8a0733ae58749db958e929aa14108b869f7540", "patch": "@@ -1,7 +1,6 @@\n use crate::infer::error_reporting::{note_and_explain_region, ObligationCauseExt};\n use crate::infer::{self, InferCtxt, SubregionOrigin};\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n-use rustc_middle::middle::region;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::{self, Region};\n \n@@ -91,7 +90,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub(super) fn report_concrete_failure(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         origin: SubregionOrigin<'tcx>,\n         sub: Region<'tcx>,\n         sup: Region<'tcx>,\n@@ -100,10 +98,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::Subtype(box trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 let mut err = self.report_and_explain_type_error(trace, &terr);\n-                note_and_explain_region(self.tcx, region_scope_tree, &mut err, \"\", sup, \"...\");\n+                note_and_explain_region(self.tcx, &mut err, \"\", sup, \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"...does not necessarily outlive \",\n                     sub,\n@@ -121,15 +118,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"...the reference is valid for \",\n                     sub,\n                     \"...\",\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"...but the borrowed content is only valid for \",\n                     sup,\n@@ -149,15 +144,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"...the borrowed pointer is valid for \",\n                     sub,\n                     \"...\",\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     &format!(\"...but `{}` is only valid for \", var_name),\n                     sup,\n@@ -173,17 +166,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"lifetime of the source pointer does not outlive \\\n                                                 lifetime bound of the object type\"\n                 );\n+                note_and_explain_region(self.tcx, &mut err, \"object type is valid for \", sub, \"\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"object type is valid for \",\n-                    sub,\n-                    \"\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"source pointer is only valid for \",\n                     sup,\n@@ -201,22 +186,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.ty_to_string(ty)\n                 );\n                 match *sub {\n-                    ty::ReStatic => note_and_explain_region(\n-                        self.tcx,\n-                        region_scope_tree,\n-                        &mut err,\n-                        \"type must satisfy \",\n-                        sub,\n-                        \"\",\n-                    ),\n-                    _ => note_and_explain_region(\n-                        self.tcx,\n-                        region_scope_tree,\n-                        &mut err,\n-                        \"type must outlive \",\n-                        sub,\n-                        \"\",\n-                    ),\n+                    ty::ReStatic => {\n+                        note_and_explain_region(self.tcx, &mut err, \"type must satisfy \", sub, \"\")\n+                    }\n+                    _ => note_and_explain_region(self.tcx, &mut err, \"type must outlive \", sub, \"\"),\n                 }\n                 err\n             }\n@@ -225,15 +198,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"lifetime parameter instantiated with \",\n                     sup,\n                     \"\",\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"but lifetime parameter must outlive \",\n                     sub,\n@@ -251,7 +222,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"the return value is only valid for \",\n                     sup,\n@@ -267,22 +237,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"a value of type `{}` is borrowed for too long\",\n                     self.ty_to_string(ty)\n                 );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the type is valid for \",\n-                    sub,\n-                    \"\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"but the borrow lasts for \",\n-                    sup,\n-                    \"\",\n-                );\n+                note_and_explain_region(self.tcx, &mut err, \"the type is valid for \", sub, \"\");\n+                note_and_explain_region(self.tcx, &mut err, \"but the borrow lasts for \", sup, \"\");\n                 err\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n@@ -293,17 +249,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"in type `{}`, reference has a longer lifetime than the data it references\",\n                     self.ty_to_string(ty)\n                 );\n+                note_and_explain_region(self.tcx, &mut err, \"the pointer is valid for \", sub, \"\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    region_scope_tree,\n-                    &mut err,\n-                    \"the pointer is valid for \",\n-                    sub,\n-                    \"\",\n-                );\n-                note_and_explain_region(\n-                    self.tcx,\n-                    region_scope_tree,\n                     &mut err,\n                     \"but the referenced data is only valid for \",\n                     sup,\n@@ -328,7 +276,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub(super) fn report_placeholder_failure(\n         &self,\n-        region_scope_tree: &region::ScopeTree,\n         placeholder_origin: SubregionOrigin<'tcx>,\n         sub: Region<'tcx>,\n         sup: Region<'tcx>,\n@@ -340,7 +287,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 self.report_and_explain_type_error(trace, &terr)\n             }\n \n-            _ => self.report_concrete_failure(region_scope_tree, placeholder_origin, sub, sup),\n+            _ => self.report_concrete_failure(placeholder_origin, sub, sup),\n         }\n     }\n }"}, {"sha": "d975038b010b9dabdd320349117a621a5fc8ad49", "filename": "src/librustc_infer/infer/free_regions.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs?ref=3d8a0733ae58749db958e929aa14108b869f7540", "patch": "@@ -5,7 +5,6 @@\n \n use rustc_data_structures::transitive_relation::TransitiveRelation;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::middle::region;\n use rustc_middle::ty::{self, Lift, Region, TyCtxt};\n \n /// Combines a `region::ScopeTree` (which governs relationships between\n@@ -21,21 +20,13 @@ pub struct RegionRelations<'a, 'tcx> {\n     /// The context used to fetch the region maps.\n     pub context: DefId,\n \n-    /// The region maps for the given context.\n-    pub region_scope_tree: &'a region::ScopeTree,\n-\n     /// Free-region relationships.\n     pub free_regions: &'a FreeRegionMap<'tcx>,\n }\n \n impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        context: DefId,\n-        region_scope_tree: &'a region::ScopeTree,\n-        free_regions: &'a FreeRegionMap<'tcx>,\n-    ) -> Self {\n-        Self { tcx, context, region_scope_tree, free_regions }\n+    pub fn new(tcx: TyCtxt<'tcx>, context: DefId, free_regions: &'a FreeRegionMap<'tcx>) -> Self {\n+        Self { tcx, context, free_regions }\n     }\n \n     pub fn lub_free_regions(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> Region<'tcx> {"}, {"sha": "30af7d06744d78f3a20181ed72e29f643c3e613e", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=3d8a0733ae58749db958e929aa14108b869f7540", "patch": "@@ -20,7 +20,6 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n-use rustc_middle::middle::region;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::ConstEvalResult;\n use rustc_middle::traits::select;\n@@ -1213,7 +1212,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn resolve_regions_and_report_errors(\n         &self,\n         region_context: DefId,\n-        region_map: &region::ScopeTree,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n         mode: RegionckMode,\n     ) {\n@@ -1233,12 +1231,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 .into_infos_and_data()\n         };\n \n-        let region_rels = &RegionRelations::new(\n-            self.tcx,\n-            region_context,\n-            region_map,\n-            outlives_env.free_region_map(),\n-        );\n+        let region_rels =\n+            &RegionRelations::new(self.tcx, region_context, outlives_env.free_region_map());\n \n         let (lexical_region_resolutions, errors) =\n             lexical_region_resolve::resolve(region_rels, var_infos, data, mode);\n@@ -1252,7 +1246,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(region_map, &errors);\n+            self.report_region_errors(&errors);\n         }\n     }\n "}, {"sha": "943a065a8b5e8ef0fed990a8e4bd799bb8fd2eee", "filename": "src/librustc_middle/middle/region.rs", "status": "modified", "additions": 2, "deletions": 158, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs?ref=3d8a0733ae58749db958e929aa14108b869f7540", "patch": "@@ -7,7 +7,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/borrow_check.html\n \n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n-use crate::ty::{self, DefIdTree, TyCtxt};\n+use crate::ty::TyCtxt;\n use rustc_hir as hir;\n use rustc_hir::Node;\n \n@@ -333,7 +333,7 @@ pub struct YieldData {\n     pub source: hir::YieldSource,\n }\n \n-impl<'tcx> ScopeTree {\n+impl ScopeTree {\n     pub fn record_scope_parent(&mut self, child: Scope, parent: Option<(Scope, ScopeDepth)>) {\n         debug!(\"{:?}.parent = {:?}\", child, parent);\n \n@@ -348,24 +348,6 @@ impl<'tcx> ScopeTree {\n         }\n     }\n \n-    pub fn each_encl_scope<E>(&self, mut e: E)\n-    where\n-        E: FnMut(Scope, Scope),\n-    {\n-        for (&child, &parent) in &self.parent_map {\n-            e(child, parent.0)\n-        }\n-    }\n-\n-    pub fn each_var_scope<E>(&self, mut e: E)\n-    where\n-        E: FnMut(&hir::ItemLocalId, Scope),\n-    {\n-        for (child, &parent) in self.var_map.iter() {\n-            e(child, parent)\n-        }\n-    }\n-\n     pub fn opt_destruction_scope(&self, n: hir::ItemLocalId) -> Option<Scope> {\n         self.destruction_scopes.get(&n).cloned()\n     }\n@@ -406,12 +388,6 @@ impl<'tcx> ScopeTree {\n         self.parent_map.get(&id).cloned().map(|(p, _)| p)\n     }\n \n-    /// Returns the narrowest scope that encloses `id`, if any.\n-    #[allow(dead_code)] // used in cfg\n-    pub fn encl_scope(&self, id: Scope) -> Scope {\n-        self.opt_encl_scope(id).unwrap()\n-    }\n-\n     /// Returns the lifetime of the local variable `var_id`\n     pub fn var_scope(&self, var_id: hir::ItemLocalId) -> Scope {\n         self.var_map\n@@ -448,17 +424,6 @@ impl<'tcx> ScopeTree {\n         None\n     }\n \n-    /// Returns the lifetime of the variable `id`.\n-    pub fn var_region(&self, id: hir::ItemLocalId) -> ty::RegionKind {\n-        let scope = ty::ReScope(self.var_scope(id));\n-        debug!(\"var_region({:?}) = {:?}\", id, scope);\n-        scope\n-    }\n-\n-    pub fn scopes_intersect(&self, scope1: Scope, scope2: Scope) -> bool {\n-        self.is_subscope_of(scope1, scope2) || self.is_subscope_of(scope2, scope1)\n-    }\n-\n     /// Returns `true` if `subscope` is equal to or is lexically nested inside `superscope`, and\n     /// `false` otherwise.\n     pub fn is_subscope_of(&self, subscope: Scope, superscope: Scope) -> bool {\n@@ -479,127 +444,6 @@ impl<'tcx> ScopeTree {\n         true\n     }\n \n-    /// Returns the ID of the innermost containing body.\n-    pub fn containing_body(&self, mut scope: Scope) -> Option<hir::ItemLocalId> {\n-        loop {\n-            if let ScopeData::CallSite = scope.data {\n-                return Some(scope.item_local_id());\n-            }\n-\n-            scope = self.opt_encl_scope(scope)?;\n-        }\n-    }\n-\n-    /// Finds the nearest common ancestor of two scopes. That is, finds the\n-    /// smallest scope which is greater than or equal to both `scope_a` and\n-    /// `scope_b`.\n-    pub fn nearest_common_ancestor(&self, scope_a: Scope, scope_b: Scope) -> Scope {\n-        if scope_a == scope_b {\n-            return scope_a;\n-        }\n-\n-        let mut a = scope_a;\n-        let mut b = scope_b;\n-\n-        // Get the depth of each scope's parent. If either scope has no parent,\n-        // it must be the root, which means we can stop immediately because the\n-        // root must be the nearest common ancestor. (In practice, this is\n-        // moderately common.)\n-        let (parent_a, parent_a_depth) = match self.parent_map.get(&a) {\n-            Some(pd) => *pd,\n-            None => return a,\n-        };\n-        let (parent_b, parent_b_depth) = match self.parent_map.get(&b) {\n-            Some(pd) => *pd,\n-            None => return b,\n-        };\n-\n-        if parent_a_depth > parent_b_depth {\n-            // `a` is lower than `b`. Move `a` up until it's at the same depth\n-            // as `b`. The first move up is trivial because we already found\n-            // `parent_a` above; the loop does the remaining N-1 moves.\n-            a = parent_a;\n-            for _ in 0..(parent_a_depth - parent_b_depth - 1) {\n-                a = self.parent_map.get(&a).unwrap().0;\n-            }\n-        } else if parent_b_depth > parent_a_depth {\n-            // `b` is lower than `a`.\n-            b = parent_b;\n-            for _ in 0..(parent_b_depth - parent_a_depth - 1) {\n-                b = self.parent_map.get(&b).unwrap().0;\n-            }\n-        } else {\n-            // Both scopes are at the same depth, and we know they're not equal\n-            // because that case was tested for at the top of this function. So\n-            // we can trivially move them both up one level now.\n-            assert!(parent_a_depth != 0);\n-            a = parent_a;\n-            b = parent_b;\n-        }\n-\n-        // Now both scopes are at the same level. We move upwards in lockstep\n-        // until they match. In practice, this loop is almost always executed\n-        // zero times because `a` is almost always a direct ancestor of `b` or\n-        // vice versa.\n-        while a != b {\n-            a = self.parent_map.get(&a).unwrap().0;\n-            b = self.parent_map.get(&b).unwrap().0;\n-        }\n-\n-        a\n-    }\n-\n-    /// Assuming that the provided region was defined within this `ScopeTree`,\n-    /// returns the outermost `Scope` that the region outlives.\n-    pub fn early_free_scope(&self, tcx: TyCtxt<'tcx>, br: &ty::EarlyBoundRegion) -> Scope {\n-        let param_owner = tcx.parent(br.def_id).unwrap();\n-\n-        let param_owner_id = tcx.hir().as_local_hir_id(param_owner.expect_local());\n-        let scope = tcx\n-            .hir()\n-            .maybe_body_owned_by(param_owner_id)\n-            .map(|body_id| tcx.hir().body(body_id).value.hir_id.local_id)\n-            .unwrap_or_else(|| {\n-                // The lifetime was defined on node that doesn't own a body,\n-                // which in practice can only mean a trait or an impl, that\n-                // is the parent of a method, and that is enforced below.\n-                if Some(param_owner_id) != self.root_parent {\n-                    tcx.sess.delay_span_bug(\n-                        DUMMY_SP,\n-                        &format!(\n-                            \"free_scope: {:?} not recognized by the \\\n-                              region scope tree for {:?} / {:?}\",\n-                            param_owner,\n-                            self.root_parent.map(|id| tcx.hir().local_def_id(id)),\n-                            self.root_body.map(|hir_id| hir_id.owner)\n-                        ),\n-                    );\n-                }\n-\n-                // The trait/impl lifetime is in scope for the method's body.\n-                self.root_body.unwrap().local_id\n-            });\n-\n-        Scope { id: scope, data: ScopeData::CallSite }\n-    }\n-\n-    /// Assuming that the provided region was defined within this `ScopeTree`,\n-    /// returns the outermost `Scope` that the region outlives.\n-    pub fn free_scope(&self, tcx: TyCtxt<'tcx>, fr: &ty::FreeRegion) -> Scope {\n-        let param_owner = match fr.bound_region {\n-            ty::BoundRegion::BrNamed(def_id, _) => tcx.parent(def_id).unwrap(),\n-            _ => fr.scope,\n-        };\n-\n-        // Ensure that the named late-bound lifetimes were defined\n-        // on the same function that they ended up being freed in.\n-        assert_eq!(param_owner, fr.scope);\n-\n-        let param_owner_id = tcx.hir().as_local_hir_id(param_owner.expect_local());\n-        let body_id = tcx.hir().body_owned_by(param_owner_id);\n-        Scope { id: tcx.hir().body(body_id).value.hir_id.local_id, data: ScopeData::CallSite }\n-    }\n-\n     /// Checks whether the given scope contains a `yield`. If so,\n     /// returns `Some((span, expr_count))` with the span of a yield we found and\n     /// the number of expressions and patterns appearing before the `yield` in the body + 1."}, {"sha": "e19fab89eabfee105ac0b47c59a5c91e95e52f89", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=3d8a0733ae58749db958e929aa14108b869f7540", "patch": "@@ -162,10 +162,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     let type_test_span = type_test.locations.span(&self.body);\n \n                     if let Some(lower_bound_region) = lower_bound_region {\n-                        let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n                         self.infcx\n                             .construct_generic_bound_failure(\n-                                region_scope_tree,\n                                 type_test_span,\n                                 None,\n                                 type_test.generic_kind,\n@@ -194,12 +192,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n \n                 RegionErrorKind::UnexpectedHiddenRegion { span, hidden_ty, member_region } => {\n-                    let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n                     let named_ty = self.regioncx.name_regions(self.infcx.tcx, hidden_ty);\n                     let named_region = self.regioncx.name_regions(self.infcx.tcx, member_region);\n                     unexpected_hidden_region_diagnostic(\n                         self.infcx.tcx,\n-                        Some(region_scope_tree),\n                         span,\n                         named_ty,\n                         named_region,"}, {"sha": "484677ded249f9b079fff5ee4e3e329786dad050", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=3d8a0733ae58749db958e929aa14108b869f7540", "patch": "@@ -835,7 +835,6 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                 if let Some(hidden_ty) = self.hidden_ty.take() {\n                     unexpected_hidden_region_diagnostic(\n                         self.tcx,\n-                        None,\n                         self.tcx.def_span(self.opaque_type_def_id),\n                         hidden_ty,\n                         r,"}, {"sha": "d8e99dc10af2a25140172a39ee65ddc72ee319c8", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=3d8a0733ae58749db958e929aa14108b869f7540", "patch": "@@ -28,7 +28,6 @@ use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::middle::region;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::{\n@@ -237,15 +236,12 @@ fn do_normalize_predicates<'tcx>(\n \n         debug!(\"do_normalize_predictes: normalized predicates = {:?}\", predicates);\n \n-        let region_scope_tree = region::ScopeTree::default();\n-\n         // We can use the `elaborated_env` here; the region code only\n         // cares about declarations like `'a: 'b`.\n         let outlives_env = OutlivesEnvironment::new(elaborated_env);\n \n         infcx.resolve_regions_and_report_errors(\n             region_context,\n-            &region_scope_tree,\n             &outlives_env,\n             RegionckMode::default(),\n         );"}, {"sha": "8fa901d8a984a6969cd368c09a195bf029a95ba2", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=3d8a0733ae58749db958e929aa14108b869f7540", "patch": "@@ -3,7 +3,6 @@\n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use crate::astconv::AstConv;\n-use crate::middle::region;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::{FutureTraitLangItem, GeneratorTraitLangItem};\n@@ -17,7 +16,6 @@ use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n-use rustc_trait_selection::traits::Obligation;\n use std::cmp;\n use std::iter;\n "}, {"sha": "24c319f26e71f25fb666a9ae43b5630c6de6b87a", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=3d8a0733ae58749db958e929aa14108b869f7540", "patch": "@@ -5,7 +5,6 @@ use rustc_errors::{struct_span_err, ErrorReported};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{InferOk, RegionckMode, TyCtxtInferExt};\n use rustc_infer::traits::TraitEngineExt as _;\n-use rustc_middle::middle::region;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n@@ -120,8 +119,6 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n             return Err(ErrorReported);\n         }\n \n-        let region_scope_tree = region::ScopeTree::default();\n-\n         // NB. It seems a bit... suspicious to use an empty param-env\n         // here. The correct thing, I imagine, would be\n         // `OutlivesEnvironment::new(impl_param_env)`, which would\n@@ -134,7 +131,6 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n \n         infcx.resolve_regions_and_report_errors(\n             drop_impl_did.to_def_id(),\n-            &region_scope_tree,\n             &outlives_env,\n             RegionckMode::default(),\n         );"}, {"sha": "c5dd314dc655881fa8f6ee2c82b98b9fb96cfe1e", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=3d8a0733ae58749db958e929aa14108b869f7540", "patch": "@@ -11,7 +11,6 @@ use rustc_hir::ItemKind;\n use rustc_infer::infer;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{RegionckMode, TyCtxtInferExt};\n-use rustc_middle::middle::region;\n use rustc_middle::ty::adjustment::CoerceUnsizedInfo;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -293,11 +292,9 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n                     }\n \n                     // Finally, resolve all regions.\n-                    let region_scope_tree = region::ScopeTree::default();\n                     let outlives_env = OutlivesEnvironment::new(param_env);\n                     infcx.resolve_regions_and_report_errors(\n                         impl_did.to_def_id(),\n-                        &region_scope_tree,\n                         &outlives_env,\n                         RegionckMode::default(),\n                     );\n@@ -552,14 +549,8 @@ pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedI\n         }\n \n         // Finally, resolve all regions.\n-        let region_scope_tree = region::ScopeTree::default();\n         let outlives_env = OutlivesEnvironment::new(param_env);\n-        infcx.resolve_regions_and_report_errors(\n-            impl_did,\n-            &region_scope_tree,\n-            &outlives_env,\n-            RegionckMode::default(),\n-        );\n+        infcx.resolve_regions_and_report_errors(impl_did, &outlives_env, RegionckMode::default());\n \n         CoerceUnsizedInfo { custom_kind: kind }\n     })"}, {"sha": "08404bea56138638aecf4131aa3b94de2f2fded6", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0733ae58749db958e929aa14108b869f7540/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=3d8a0733ae58749db958e929aa14108b869f7540", "patch": "@@ -73,7 +73,6 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{InferCtxt, RegionckMode, TyCtxtInferExt};\n use rustc_infer::traits::specialization_graph::Node;\n-use rustc_middle::middle::region::ScopeTree;\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n use rustc_middle::ty::{self, InstantiatedPredicates, TyCtxt, TypeFoldable};\n@@ -165,12 +164,7 @@ fn get_impl_substs<'tcx>(\n \n     // Conservatively use an empty `ParamEnv`.\n     let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty());\n-    infcx.resolve_regions_and_report_errors(\n-        impl1_def_id,\n-        &ScopeTree::default(),\n-        &outlives_env,\n-        RegionckMode::default(),\n-    );\n+    infcx.resolve_regions_and_report_errors(impl1_def_id, &outlives_env, RegionckMode::default());\n     let impl2_substs = match infcx.fully_resolve(&impl2_substs) {\n         Ok(s) => s,\n         Err(_) => {"}]}