{"sha": "689fca01c5a1eac2d240bf08aa728171a28f2285", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4OWZjYTAxYzVhMWVhYzJkMjQwYmYwOGFhNzI4MTcxYTI4ZjIyODU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-17T15:58:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-17T15:58:24Z"}, "message": "Auto merge of #68311 - Dylan-DPC:rollup-wzgqw9t, r=Dylan-DPC\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #66564 (Document unsafe blocks in core::{cell, str, sync})\n - #67791 (Implement Lift using interners instead of in_arena)\n - #68278 ([self-profiler] Add example to `-Z help` to turn on query key recording)\n - #68300 (Allow added string.insert benchmarks to compile)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "20c3e430ee7eac5254a495608ff233e9f4c7d74e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20c3e430ee7eac5254a495608ff233e9f4c7d74e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/689fca01c5a1eac2d240bf08aa728171a28f2285", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/689fca01c5a1eac2d240bf08aa728171a28f2285", "html_url": "https://github.com/rust-lang/rust/commit/689fca01c5a1eac2d240bf08aa728171a28f2285", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/689fca01c5a1eac2d240bf08aa728171a28f2285/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71c6346aa1afa5a0d246649d4919e11311e635f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/71c6346aa1afa5a0d246649d4919e11311e635f2", "html_url": "https://github.com/rust-lang/rust/commit/71c6346aa1afa5a0d246649d4919e11311e635f2"}, {"sha": "87a2896b0aa32343af271d430c1e9ce548e1ff1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/87a2896b0aa32343af271d430c1e9ce548e1ff1f", "html_url": "https://github.com/rust-lang/rust/commit/87a2896b0aa32343af271d430c1e9ce548e1ff1f"}], "stats": {"total": 356, "additions": 187, "deletions": 169}, "files": [{"sha": "5c95160ba2d14dba82ea7a57b4fef7b64ef45f88", "filename": "src/liballoc/benches/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Fliballoc%2Fbenches%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Fliballoc%2Fbenches%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fstring.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -1,5 +1,5 @@\n use std::iter::repeat;\n-use test::Bencher;\n+use test::{black_box, Bencher};\n \n #[bench]\n fn bench_with_capacity(b: &mut Bencher) {"}, {"sha": "2a3d92edc4956dafc26936d82c8a506ff0e5029a", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -21,7 +21,6 @@\n extern crate alloc;\n \n use rustc_data_structures::cold_path;\n-use rustc_data_structures::sync::MTLock;\n use smallvec::SmallVec;\n \n use std::cell::{Cell, RefCell};\n@@ -116,11 +115,6 @@ impl<T> Default for TypedArena<T> {\n }\n \n impl<T> TypedArena<T> {\n-    pub fn in_arena(&self, ptr: *const T) -> bool {\n-        let ptr = ptr as *const T as *mut T;\n-\n-        self.chunks.borrow().iter().any(|chunk| chunk.start() <= ptr && ptr < chunk.end())\n-    }\n     /// Allocates an object in the `TypedArena`, returning a reference to it.\n     #[inline]\n     pub fn alloc(&self, object: T) -> &mut T {\n@@ -334,12 +328,6 @@ impl Default for DroplessArena {\n }\n \n impl DroplessArena {\n-    pub fn in_arena<T: ?Sized>(&self, ptr: *const T) -> bool {\n-        let ptr = ptr as *const u8 as *mut u8;\n-\n-        self.chunks.borrow().iter().any(|chunk| chunk.start() <= ptr && ptr < chunk.end())\n-    }\n-\n     #[inline]\n     fn align(&self, align: usize) {\n         let final_address = ((self.ptr.get() as usize) + align - 1) & !(align - 1);\n@@ -500,66 +488,5 @@ impl DroplessArena {\n     }\n }\n \n-#[derive(Default)]\n-// FIXME(@Zoxc): this type is entirely unused in rustc\n-pub struct SyncTypedArena<T> {\n-    lock: MTLock<TypedArena<T>>,\n-}\n-\n-impl<T> SyncTypedArena<T> {\n-    #[inline(always)]\n-    pub fn alloc(&self, object: T) -> &mut T {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc(object) as *mut T) }\n-    }\n-\n-    #[inline(always)]\n-    pub fn alloc_slice(&self, slice: &[T]) -> &mut [T]\n-    where\n-        T: Copy,\n-    {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc_slice(slice) as *mut [T]) }\n-    }\n-\n-    #[inline(always)]\n-    pub fn clear(&mut self) {\n-        self.lock.get_mut().clear();\n-    }\n-}\n-\n-#[derive(Default)]\n-pub struct SyncDroplessArena {\n-    lock: MTLock<DroplessArena>,\n-}\n-\n-impl SyncDroplessArena {\n-    #[inline(always)]\n-    pub fn in_arena<T: ?Sized>(&self, ptr: *const T) -> bool {\n-        self.lock.lock().in_arena(ptr)\n-    }\n-\n-    #[inline(always)]\n-    pub fn alloc_raw(&self, bytes: usize, align: usize) -> &mut [u8] {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc_raw(bytes, align) as *mut [u8]) }\n-    }\n-\n-    #[inline(always)]\n-    pub fn alloc<T>(&self, object: T) -> &mut T {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc(object) as *mut T) }\n-    }\n-\n-    #[inline(always)]\n-    pub fn alloc_slice<T>(&self, slice: &[T]) -> &mut [T]\n-    where\n-        T: Copy,\n-    {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc_slice(slice) as *mut [T]) }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests;"}, {"sha": "e7eecf7540ad74121d4a0c840536afff154a98e5", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -187,8 +187,6 @@\n //! ```\n //!\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cmp::Ordering;\n@@ -368,6 +366,10 @@ impl<T> Cell<T> {\n         if ptr::eq(self, other) {\n             return;\n         }\n+        // SAFETY: This can be risky if called from separate threads, but `Cell`\n+        // is `!Sync` so this won't happen. This also won't invalidate any\n+        // pointers since `Cell` makes sure nothing else will be pointing into\n+        // either of these `Cell`s.\n         unsafe {\n             ptr::swap(self.value.get(), other.value.get());\n         }\n@@ -387,6 +389,8 @@ impl<T> Cell<T> {\n     /// ```\n     #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n     pub fn replace(&self, val: T) -> T {\n+        // SAFETY: This can cause data races if called from a separate thread,\n+        // but `Cell` is `!Sync` so this won't happen.\n         mem::replace(unsafe { &mut *self.value.get() }, val)\n     }\n \n@@ -423,6 +427,8 @@ impl<T: Copy> Cell<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> T {\n+        // SAFETY: This can cause data races if called from a separate thread,\n+        // but `Cell` is `!Sync` so this won't happen.\n         unsafe { *self.value.get() }\n     }\n \n@@ -491,6 +497,9 @@ impl<T: ?Sized> Cell<T> {\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n+        // SAFETY: This can cause data races if called from a separate thread,\n+        // but `Cell` is `!Sync` so this won't happen, and `&mut` guarantees\n+        // unique access.\n         unsafe { &mut *self.value.get() }\n     }\n \n@@ -510,6 +519,7 @@ impl<T: ?Sized> Cell<T> {\n     #[inline]\n     #[stable(feature = \"as_cell\", since = \"1.37.0\")]\n     pub fn from_mut(t: &mut T) -> &Cell<T> {\n+        // SAFETY: `&mut` ensures unique access.\n         unsafe { &*(t as *mut T as *const Cell<T>) }\n     }\n }\n@@ -553,6 +563,7 @@ impl<T> Cell<[T]> {\n     /// ```\n     #[stable(feature = \"as_cell\", since = \"1.37.0\")]\n     pub fn as_slice_of_cells(&self) -> &[Cell<T>] {\n+        // SAFETY: `Cell<T>` has the same memory layout as `T`.\n         unsafe { &*(self as *const Cell<[T]> as *const [Cell<T>]) }\n     }\n }\n@@ -816,6 +827,8 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     pub fn try_borrow(&self) -> Result<Ref<'_, T>, BorrowError> {\n         match BorrowRef::new(&self.borrow) {\n+            // SAFETY: `BorrowRef` ensures that there is only immutable access\n+            // to the value while borrowed.\n             Some(b) => Ok(Ref { value: unsafe { &*self.value.get() }, borrow: b }),\n             None => Err(BorrowError { _private: () }),\n         }\n@@ -891,6 +904,7 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     pub fn try_borrow_mut(&self) -> Result<RefMut<'_, T>, BorrowMutError> {\n         match BorrowRefMut::new(&self.borrow) {\n+            // SAFETY: `BorrowRef` guarantees unique access.\n             Some(b) => Ok(RefMut { value: unsafe { &mut *self.value.get() }, borrow: b }),\n             None => Err(BorrowMutError { _private: () }),\n         }\n@@ -940,6 +954,7 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n+        // SAFETY: `&mut` guarantees unique access.\n         unsafe { &mut *self.value.get() }\n     }\n "}, {"sha": "88b2bc551b7d1138e136ff4cf49d95ea63d3e804", "filename": "src/libcore/str/lossy.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibcore%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibcore%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Flossy.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -3,8 +3,6 @@ use crate::fmt::{self, Write};\n use crate::mem;\n use crate::str as core_str;\n \n-// ignore-tidy-undocumented-unsafe\n-\n /// Lossy UTF-8 string.\n #[unstable(feature = \"str_internals\", issue = \"none\")]\n pub struct Utf8Lossy {\n@@ -17,6 +15,7 @@ impl Utf8Lossy {\n     }\n \n     pub fn from_bytes(bytes: &[u8]) -> &Utf8Lossy {\n+        // SAFETY: Both use the same memory layout, and UTF-8 correctness isn't required.\n         unsafe { mem::transmute(bytes) }\n     }\n \n@@ -60,6 +59,8 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n         while i < self.source.len() {\n             let i_ = i;\n \n+            // SAFETY: `i` starts at `0`, is less than `self.source.len()`, and\n+            // only increases, so `0 <= i < self.source.len()`.\n             let byte = unsafe { *self.source.get_unchecked(i) };\n             i += 1;\n \n@@ -69,6 +70,7 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n \n                 macro_rules! error {\n                     () => {{\n+                        // SAFETY: We have checked up to `i` that source is valid UTF-8.\n                         unsafe {\n                             let r = Utf8LossyChunk {\n                                 valid: core_str::from_utf8_unchecked(&self.source[0..i_]),\n@@ -130,6 +132,7 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n         }\n \n         let r = Utf8LossyChunk {\n+            // SAFETY: We have checked that the entire source is valid UTF-8.\n             valid: unsafe { core_str::from_utf8_unchecked(self.source) },\n             broken: &[],\n         };"}, {"sha": "5a7cddd4041d500200ec22071f1b176ab46bce30", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -1,5 +1,4 @@\n // ignore-tidy-filelength\n-// ignore-tidy-undocumented-unsafe\n \n //! String manipulation.\n //!\n@@ -341,6 +340,7 @@ impl Utf8Error {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n     run_utf8_validation(v)?;\n+    // SAFETY: Just ran validation.\n     Ok(unsafe { from_utf8_unchecked(v) })\n }\n \n@@ -379,6 +379,7 @@ pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n     run_utf8_validation(v)?;\n+    // SAFETY: Just ran validation.\n     Ok(unsafe { from_utf8_unchecked_mut(v) })\n }\n \n@@ -581,7 +582,7 @@ impl<'a> Iterator for Chars<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         next_code_point(&mut self.iter).map(|ch| {\n-            // str invariant says `ch` is a valid Unicode Scalar Value\n+            // SAFETY: `str` invariant says `ch` is a valid Unicode Scalar Value.\n             unsafe { char::from_u32_unchecked(ch) }\n         })\n     }\n@@ -628,7 +629,7 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n         next_code_point_reverse(&mut self.iter).map(|ch| {\n-            // str invariant says `ch` is a valid Unicode Scalar Value\n+            // SAFETY: `str` invariant says `ch` is a valid Unicode Scalar Value.\n             unsafe { char::from_u32_unchecked(ch) }\n         })\n     }\n@@ -658,6 +659,7 @@ impl<'a> Chars<'a> {\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     #[inline]\n     pub fn as_str(&self) -> &'a str {\n+        // SAFETY: `Chars` is only made from a str, which guarantees the iter is valid UTF-8.\n         unsafe { from_utf8_unchecked(self.iter.as_slice()) }\n     }\n }\n@@ -1102,6 +1104,7 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n     fn get_end(&mut self) -> Option<&'a str> {\n         if !self.finished && (self.allow_trailing_empty || self.end - self.start > 0) {\n             self.finished = true;\n+            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n             unsafe {\n                 let string = self.matcher.haystack().get_unchecked(self.start..self.end);\n                 Some(string)\n@@ -1119,6 +1122,7 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n \n         let haystack = self.matcher.haystack();\n         match self.matcher.next_match() {\n+            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n             Some((a, b)) => unsafe {\n                 let elt = haystack.get_unchecked(self.start..a);\n                 self.start = b;\n@@ -1151,11 +1155,13 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n \n         let haystack = self.matcher.haystack();\n         match self.matcher.next_match_back() {\n+            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n             Some((a, b)) => unsafe {\n                 let elt = haystack.get_unchecked(b..self.end);\n                 self.end = a;\n                 Some(elt)\n             },\n+            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n             None => unsafe {\n                 self.finished = true;\n                 Some(haystack.get_unchecked(self.start..self.end))\n@@ -1297,6 +1303,7 @@ impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n     fn next(&mut self) -> Option<(usize, &'a str)> {\n         self.0\n             .next_match()\n+            // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n             .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n     }\n \n@@ -1307,6 +1314,7 @@ impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n     {\n         self.0\n             .next_match_back()\n+            // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n             .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n     }\n }\n@@ -1348,6 +1356,7 @@ where\n impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n+        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n         self.0.next_match().map(|(a, b)| unsafe {\n             // Indices are known to be on utf8 boundaries\n             self.0.haystack().get_unchecked(a..b)\n@@ -1359,6 +1368,7 @@ impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n     where\n         P::Searcher: ReverseSearcher<'a>,\n     {\n+        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n         self.0.next_match_back().map(|(a, b)| unsafe {\n             // Indices are known to be on utf8 boundaries\n             self.0.haystack().get_unchecked(a..b)\n@@ -1579,6 +1589,10 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n             if align != usize::max_value() && align.wrapping_sub(index) % usize_bytes == 0 {\n                 let ptr = v.as_ptr();\n                 while index < blocks_end {\n+                    // SAFETY: since `align - index` and `ascii_block_size` are\n+                    // multiples of `usize_bytes`, `block = ptr.add(index)` is\n+                    // always aligned with a `usize` so it's safe to dereference\n+                    // both `block` and `block.offset(1)`.\n                     unsafe {\n                         let block = ptr.add(index) as *const usize;\n                         // break if there is a nonascii byte\n@@ -1804,6 +1818,7 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n+                // SAFETY: just checked that `start` and `end` are on a char boundary.\n                 Some(unsafe { self.get_unchecked(slice) })\n             } else {\n                 None\n@@ -1815,6 +1830,7 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n+                // SAFETY: just checked that `start` and `end` are on a char boundary.\n                 Some(unsafe { self.get_unchecked_mut(slice) })\n             } else {\n                 None\n@@ -1845,6 +1861,7 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n+                // SAFETY: just checked that `start` and `end` are on a char boundary.\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, self.start, self.end)\n@@ -1873,6 +1890,7 @@ mod traits {\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if slice.is_char_boundary(self.end) {\n+                // SAFETY: just checked that `end` is on a char boundary.\n                 Some(unsafe { self.get_unchecked(slice) })\n             } else {\n                 None\n@@ -1881,6 +1899,7 @@ mod traits {\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n             if slice.is_char_boundary(self.end) {\n+                // SAFETY: just checked that `end` is on a char boundary.\n                 Some(unsafe { self.get_unchecked_mut(slice) })\n             } else {\n                 None\n@@ -1903,8 +1922,8 @@ mod traits {\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            // is_char_boundary checks that the index is in [0, .len()]\n             if slice.is_char_boundary(self.end) {\n+                // SAFETY: just checked that `end` is on a char boundary.\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, 0, self.end)\n@@ -1934,6 +1953,7 @@ mod traits {\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if slice.is_char_boundary(self.start) {\n+                // SAFETY: just checked that `start` is on a char boundary.\n                 Some(unsafe { self.get_unchecked(slice) })\n             } else {\n                 None\n@@ -1942,6 +1962,7 @@ mod traits {\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n             if slice.is_char_boundary(self.start) {\n+                // SAFETY: just checked that `start` is on a char boundary.\n                 Some(unsafe { self.get_unchecked_mut(slice) })\n             } else {\n                 None\n@@ -1966,8 +1987,8 @@ mod traits {\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            // is_char_boundary checks that the index is in [0, .len()]\n             if slice.is_char_boundary(self.start) {\n+                // SAFETY: just checked that `start` is on a char boundary.\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, self.start, slice.len())\n@@ -2238,7 +2259,6 @@ impl str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"str_as_bytes\", since = \"1.32.0\")]\n     #[inline(always)]\n-    // SAFETY: const sound because we transmute two types with the same layout\n     #[allow(unused_attributes)]\n     #[allow_internal_unstable(const_fn_union)]\n     pub const fn as_bytes(&self) -> &[u8] {\n@@ -2247,6 +2267,7 @@ impl str {\n             str: &'a str,\n             slice: &'a [u8],\n         }\n+        // SAFETY: const sound because we transmute two types with the same layout\n         unsafe { Slices { str: self }.slice }\n     }\n \n@@ -2573,6 +2594,7 @@ impl str {\n     pub fn split_at(&self, mid: usize) -> (&str, &str) {\n         // is_char_boundary checks that the index is in [0, .len()]\n         if self.is_char_boundary(mid) {\n+            // SAFETY: just checked that `mid` is on a char boundary.\n             unsafe { (self.get_unchecked(0..mid), self.get_unchecked(mid..self.len())) }\n         } else {\n             slice_error_fail(self, 0, mid)\n@@ -2617,6 +2639,7 @@ impl str {\n         if self.is_char_boundary(mid) {\n             let len = self.len();\n             let ptr = self.as_mut_ptr();\n+            // SAFETY: just checked that `mid` is on a char boundary.\n             unsafe {\n                 (\n                     from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, mid)),\n@@ -3805,10 +3828,8 @@ impl str {\n         if let Some((_, b)) = matcher.next_reject_back() {\n             j = b;\n         }\n-        unsafe {\n-            // Searcher is known to return valid indices\n-            self.get_unchecked(i..j)\n-        }\n+        // SAFETY: `Searcher` is known to return valid indices.\n+        unsafe { self.get_unchecked(i..j) }\n     }\n \n     /// Returns a string slice with all prefixes that match a pattern\n@@ -3844,10 +3865,8 @@ impl str {\n         if let Some((a, _)) = matcher.next_reject() {\n             i = a;\n         }\n-        unsafe {\n-            // Searcher is known to return valid indices\n-            self.get_unchecked(i..self.len())\n-        }\n+        // SAFETY: `Searcher` is known to return valid indices.\n+        unsafe { self.get_unchecked(i..self.len()) }\n     }\n \n     /// Returns a string slice with the prefix removed.\n@@ -3878,10 +3897,8 @@ impl str {\n                 \"The first search step from Searcher \\\n                 must include the first character\"\n             );\n-            unsafe {\n-                // Searcher is known to return valid indices.\n-                Some(self.get_unchecked(len..))\n-            }\n+            // SAFETY: `Searcher` is known to return valid indices.\n+            unsafe { Some(self.get_unchecked(len..)) }\n         } else {\n             None\n         }\n@@ -3919,10 +3936,8 @@ impl str {\n                 \"The first search step from ReverseSearcher \\\n                 must include the last character\"\n             );\n-            unsafe {\n-                // Searcher is known to return valid indices.\n-                Some(self.get_unchecked(..start))\n-            }\n+            // SAFETY: `Searcher` is known to return valid indices.\n+            unsafe { Some(self.get_unchecked(..start)) }\n         } else {\n             None\n         }\n@@ -3970,10 +3985,8 @@ impl str {\n         if let Some((_, b)) = matcher.next_reject_back() {\n             j = b;\n         }\n-        unsafe {\n-            // Searcher is known to return valid indices\n-            self.get_unchecked(0..j)\n-        }\n+        // SAFETY: `Searcher` is known to return valid indices.\n+        unsafe { self.get_unchecked(0..j) }\n     }\n \n     /// Returns a string slice with all prefixes that match a pattern\n@@ -4166,6 +4179,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     pub fn make_ascii_uppercase(&mut self) {\n+        // SAFETY: safe because we transmute two types with the same layout.\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_uppercase()\n     }\n@@ -4191,6 +4205,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     pub fn make_ascii_lowercase(&mut self) {\n+        // SAFETY: safe because we transmute two types with the same layout.\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_lowercase()\n     }\n@@ -4357,6 +4372,7 @@ impl Default for &str {\n impl Default for &mut str {\n     /// Creates an empty mutable str\n     fn default() -> Self {\n+        // SAFETY: The empty string is valid UTF-8.\n         unsafe { from_utf8_unchecked_mut(&mut []) }\n     }\n }\n@@ -4412,6 +4428,7 @@ impl_fn_for_zst! {\n \n     #[derive(Clone)]\n     struct UnsafeBytesToStr impl<'a> Fn = |bytes: &'a [u8]| -> &'a str {\n+        // SAFETY: not safe\n         unsafe { from_utf8_unchecked(bytes) }\n     };\n }"}, {"sha": "ef64d8b0fdf8880883ee168c22a5e0164c72fea7", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -3,8 +3,6 @@\n //! For more details, see the traits [`Pattern`], [`Searcher`],\n //! [`ReverseSearcher`], and [`DoubleEndedSearcher`].\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![unstable(\n     feature = \"pattern\",\n     reason = \"API not fully fleshed out and ready to be stabilized\",\n@@ -271,6 +269,14 @@ unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n     #[inline]\n     fn next(&mut self) -> SearchStep {\n         let old_finger = self.finger;\n+        // SAFETY: 1-4 guarantee safety of `get_unchecked`\n+        // 1. `self.finger` and `self.finger_back` are kept on unicode boundaries\n+        //    (this is invariant)\n+        // 2. `self.finger >= 0` since it starts at 0 and only increases\n+        // 3. `self.finger < self.finger_back` because otherwise the char `iter`\n+        //    would return `SearchStep::Done`\n+        // 4. `self.finger` comes before the end of the haystack because `self.finger_back`\n+        //    starts at the end and only decreases\n         let slice = unsafe { self.haystack.get_unchecked(old_finger..self.finger_back) };\n         let mut iter = slice.chars();\n         let old_len = iter.iter.len();\n@@ -293,6 +299,7 @@ unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n             // get the haystack after the last character found\n             let bytes = self.haystack.as_bytes().get(self.finger..self.finger_back)?;\n             // the last byte of the utf8 encoded needle\n+            // SAFETY: we have an invariant that `utf8_size < 5`\n             let last_byte = unsafe { *self.utf8_encoded.get_unchecked(self.utf8_size - 1) };\n             if let Some(index) = memchr::memchr(last_byte, bytes) {\n                 // The new finger is the index of the byte we found,\n@@ -336,6 +343,7 @@ unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n     #[inline]\n     fn next_back(&mut self) -> SearchStep {\n         let old_finger = self.finger_back;\n+        // SAFETY: see the comment for next() above\n         let slice = unsafe { self.haystack.get_unchecked(self.finger..old_finger) };\n         let mut iter = slice.chars();\n         let old_len = iter.iter.len();\n@@ -363,6 +371,7 @@ unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n                 return None;\n             };\n             // the last byte of the utf8 encoded needle\n+            // SAFETY: we have an invariant that `utf8_size < 5`\n             let last_byte = unsafe { *self.utf8_encoded.get_unchecked(self.utf8_size - 1) };\n             if let Some(index) = memchr::memrchr(last_byte, bytes) {\n                 // we searched a slice that was offset by self.finger,"}, {"sha": "9d449bb9915071e3453af165045684d205cbacc9", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -112,8 +112,6 @@\n //! println!(\"live threads: {}\", old_thread_count + 1);\n //! ```\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(dead_code))]\n #![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(unused_imports))]\n@@ -350,6 +348,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n     pub fn get_mut(&mut self) -> &mut bool {\n+        // SAFETY: the mutable reference guarantees unique ownership.\n         unsafe { &mut *(self.v.get() as *mut bool) }\n     }\n \n@@ -400,6 +399,8 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> bool {\n+        // SAFETY: any data races are prevented by atomic intrinsics and the raw\n+        // pointer passed in is valid because we got it from a reference.\n         unsafe { atomic_load(self.v.get(), order) != 0 }\n     }\n \n@@ -432,6 +433,8 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n+        // SAFETY: any data races are prevented by atomic intrinsics and the raw\n+        // pointer passed in is valid because we got it from a reference.\n         unsafe {\n             atomic_store(self.v.get(), val as u8, order);\n         }\n@@ -463,6 +466,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -558,6 +562,7 @@ impl AtomicBool {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<bool, bool> {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         match unsafe {\n             atomic_compare_exchange(self.v.get(), current as u8, new as u8, success, failure)\n         } {\n@@ -615,6 +620,7 @@ impl AtomicBool {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<bool, bool> {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         match unsafe {\n             atomic_compare_exchange_weak(self.v.get(), current as u8, new as u8, success, failure)\n         } {\n@@ -661,6 +667,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -756,6 +763,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -797,6 +805,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -872,6 +881,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n     pub fn get_mut(&mut self) -> &mut *mut T {\n+        // SAFETY: the mutable reference guarantees unique ownership.\n         unsafe { &mut *self.p.get() }\n     }\n \n@@ -923,6 +933,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> *mut T {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_load(self.p.get() as *mut usize, order) as *mut T }\n     }\n \n@@ -957,6 +968,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe {\n             atomic_store(self.p.get() as *mut usize, ptr as usize, order);\n         }\n@@ -990,6 +1002,7 @@ impl<T> AtomicPtr<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"ptr\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n \n@@ -1074,6 +1087,7 @@ impl<T> AtomicPtr<T> {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<*mut T, *mut T> {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe {\n             let res = atomic_compare_exchange(\n                 self.p.get() as *mut usize,\n@@ -1137,6 +1151,7 @@ impl<T> AtomicPtr<T> {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<*mut T, *mut T> {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe {\n             let res = atomic_compare_exchange_weak(\n                 self.p.get() as *mut usize,\n@@ -1290,6 +1305,7 @@ assert_eq!(some_var.load(Ordering::SeqCst), 5);\n                 #[inline]\n                 #[$stable_access]\n                 pub fn get_mut(&mut self) -> &mut $int_type {\n+                    // SAFETY: the mutable reference guarantees unique ownership.\n                     unsafe { &mut *self.v.get() }\n                 }\n             }\n@@ -1344,6 +1360,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 5);\n                 #[inline]\n                 #[$stable]\n                 pub fn load(&self, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_load(self.v.get(), order) }\n                 }\n             }\n@@ -1378,6 +1395,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n                 #[inline]\n                 #[$stable]\n                 pub fn store(&self, val: $int_type, order: Ordering) {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_store(self.v.get(), val, order); }\n                 }\n             }\n@@ -1408,6 +1426,7 @@ assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_swap(self.v.get(), val, order) }\n                 }\n             }\n@@ -1510,6 +1529,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n                                         new: $int_type,\n                                         success: Ordering,\n                                         failure: Ordering) -> Result<$int_type, $int_type> {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n                 }\n             }\n@@ -1562,6 +1582,7 @@ loop {\n                                              new: $int_type,\n                                              success: Ordering,\n                                              failure: Ordering) -> Result<$int_type, $int_type> {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe {\n                         atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n                     }\n@@ -1596,6 +1617,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_add(self.v.get(), val, order) }\n                 }\n             }\n@@ -1628,6 +1650,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_sub(self.v.get(), val, order) }\n                 }\n             }\n@@ -1663,6 +1686,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_and(self.v.get(), val, order) }\n                 }\n             }\n@@ -1699,6 +1723,7 @@ assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n                 #[$stable_nand]\n                 #[$cfg_cas]\n                 pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_nand(self.v.get(), val, order) }\n                 }\n             }\n@@ -1734,6 +1759,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_or(self.v.get(), val, order) }\n                 }\n             }\n@@ -1769,6 +1795,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n             }\n@@ -1880,6 +1907,7 @@ assert!(max_foo == 42);\n                        issue = \"48655\")]\n                 #[$cfg_cas]\n                 pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { $max_fn(self.v.get(), val, order) }\n                 }\n             }\n@@ -1932,6 +1960,7 @@ assert_eq!(min_foo, 12);\n                        issue = \"48655\")]\n                 #[$cfg_cas]\n                 pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { $min_fn(self.v.get(), val, order) }\n                 }\n             }\n@@ -1960,7 +1989,9 @@ extern {\n }\n \n let mut atomic = \", stringify!($atomic_type), \"::new(1);\n-unsafe {\n+\",\n+// SAFETY: Safe as long as `my_atomic_op` is atomic.\n+\"unsafe {\n     my_atomic_op(atomic.as_mut_ptr());\n }\n # }\n@@ -2526,6 +2557,7 @@ pub fn fence(order: Ordering) {\n     // https://github.com/WebAssembly/tool-conventions/issues/59. We should\n     // follow that discussion and implement a solution when one comes about!\n     #[cfg(not(target_arch = \"wasm32\"))]\n+    // SAFETY: using an atomic fence is safe.\n     unsafe {\n         match order {\n             Acquire => intrinsics::atomic_fence_acq(),\n@@ -2613,6 +2645,7 @@ pub fn fence(order: Ordering) {\n #[inline]\n #[stable(feature = \"compiler_fences\", since = \"1.21.0\")]\n pub fn compiler_fence(order: Ordering) {\n+    // SAFETY: using an atomic fence is safe.\n     unsafe {\n         match order {\n             Acquire => intrinsics::atomic_singlethreadfence_acq(),"}, {"sha": "15e92d8d8421930d60c32929051b805f72c4d7b2", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -123,6 +123,9 @@ macro_rules! arena_types {\n             [few] inferred_outlives_crate: rustc::ty::CratePredicatesMap<'tcx>,\n             [] upvars: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,\n \n+            // Interned types\n+            [] tys: rustc::ty::TyS<$tcx>,\n+\n             // HIR types\n             [few] hir_forest: rustc::hir::map::Forest<$tcx>,\n             [] arm: rustc_hir::Arm<$tcx>,\n@@ -176,7 +179,7 @@ macro_rules! declare_arena {\n     ([], [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n         #[derive(Default)]\n         pub struct Arena<$tcx> {\n-            dropless: DroplessArena,\n+            pub dropless: DroplessArena,\n             drop: DropArena,\n             $($name: arena_for_type!($a[$ty]),)*\n         }"}, {"sha": "a51f0f7f24c368e6f8aebcc45fb6a023c745c0c0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -51,10 +51,9 @@ use rustc_session::config::CrateType;\n use rustc_session::config::{BorrowckMode, OutputFilenames};\n use rustc_session::Session;\n \n-use arena::SyncDroplessArena;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::SelfProfilerRef;\n-use rustc_data_structures::sharded::ShardedHashMap;\n+use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{\n     hash_stable_hashmap, HashStable, StableHasher, StableVec,\n };\n@@ -83,21 +82,11 @@ use syntax::ast;\n use syntax::attr;\n use syntax::expand::allocator::AllocatorKind;\n \n-pub struct AllArenas {\n-    pub interner: SyncDroplessArena,\n-}\n-\n-impl AllArenas {\n-    pub fn new() -> Self {\n-        AllArenas { interner: SyncDroplessArena::default() }\n-    }\n-}\n-\n type InternedSet<'tcx, T> = ShardedHashMap<Interned<'tcx, T>, ()>;\n \n pub struct CtxtInterners<'tcx> {\n     /// The arena that types, regions, etc. are allocated from.\n-    arena: &'tcx SyncDroplessArena,\n+    arena: &'tcx WorkerLocal<Arena<'tcx>>,\n \n     /// Specifically use a speedy hash algorithm for these hash sets, since\n     /// they're accessed quite often.\n@@ -117,7 +106,7 @@ pub struct CtxtInterners<'tcx> {\n }\n \n impl<'tcx> CtxtInterners<'tcx> {\n-    fn new(arena: &'tcx SyncDroplessArena) -> CtxtInterners<'tcx> {\n+    fn new(arena: &'tcx WorkerLocal<Arena<'tcx>>) -> CtxtInterners<'tcx> {\n         CtxtInterners {\n             arena,\n             type_: Default::default(),\n@@ -1125,7 +1114,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n         local_providers: ty::query::Providers<'tcx>,\n         extern_providers: ty::query::Providers<'tcx>,\n-        arenas: &'tcx AllArenas,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         resolutions: ty::ResolverOutputs,\n         hir: hir_map::Map<'tcx>,\n@@ -1136,7 +1124,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let data_layout = TargetDataLayout::parse(&s.target.target).unwrap_or_else(|err| {\n             s.fatal(&err);\n         });\n-        let interners = CtxtInterners::new(&arenas.interner);\n+        let interners = CtxtInterners::new(arena);\n         let common_types = CommonTypes::new(&interners);\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n@@ -1567,11 +1555,11 @@ pub trait Lift<'tcx>: fmt::Debug {\n }\n \n macro_rules! nop_lift {\n-    ($ty:ty => $lifted:ty) => {\n+    ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n             type Lifted = $lifted;\n             fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-                if tcx.interners.arena.in_arena(*self as *const _) {\n+                if tcx.interners.$set.contains_pointer_to(&Interned(*self)) {\n                     Some(unsafe { mem::transmute(*self) })\n                 } else {\n                     None\n@@ -1582,14 +1570,14 @@ macro_rules! nop_lift {\n }\n \n macro_rules! nop_list_lift {\n-    ($ty:ty => $lifted:ty) => {\n+    ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {\n             type Lifted = &'tcx List<$lifted>;\n             fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n                 if self.is_empty() {\n                     return Some(List::empty());\n                 }\n-                if tcx.interners.arena.in_arena(*self as *const _) {\n+                if tcx.interners.$set.contains_pointer_to(&Interned(*self)) {\n                     Some(unsafe { mem::transmute(*self) })\n                 } else {\n                     None\n@@ -1599,21 +1587,21 @@ macro_rules! nop_list_lift {\n     };\n }\n \n-nop_lift! {Ty<'a> => Ty<'tcx>}\n-nop_lift! {Region<'a> => Region<'tcx>}\n-nop_lift! {Goal<'a> => Goal<'tcx>}\n-nop_lift! {&'a Const<'a> => &'tcx Const<'tcx>}\n+nop_lift! {type_; Ty<'a> => Ty<'tcx>}\n+nop_lift! {region; Region<'a> => Region<'tcx>}\n+nop_lift! {goal; Goal<'a> => Goal<'tcx>}\n+nop_lift! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n \n-nop_list_lift! {Goal<'a> => Goal<'tcx>}\n-nop_list_lift! {Clause<'a> => Clause<'tcx>}\n-nop_list_lift! {Ty<'a> => Ty<'tcx>}\n-nop_list_lift! {ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n-nop_list_lift! {Predicate<'a> => Predicate<'tcx>}\n-nop_list_lift! {CanonicalVarInfo => CanonicalVarInfo}\n-nop_list_lift! {ProjectionKind => ProjectionKind}\n+nop_list_lift! {goal_list; Goal<'a> => Goal<'tcx>}\n+nop_list_lift! {clauses; Clause<'a> => Clause<'tcx>}\n+nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n+nop_list_lift! {existential_predicates; ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n+nop_list_lift! {predicates; Predicate<'a> => Predicate<'tcx>}\n+nop_list_lift! {canonical_var_infos; CanonicalVarInfo => CanonicalVarInfo}\n+nop_list_lift! {projs; ProjectionKind => ProjectionKind}\n \n // This is the impl for `&'a InternalSubsts<'a>`.\n-nop_list_lift! {GenericArg<'a> => GenericArg<'tcx>}\n+nop_list_lift! {substs; GenericArg<'a> => GenericArg<'tcx>}\n \n pub mod tls {\n     use super::{ptr_eq, GlobalCtxt, TyCtxt};\n@@ -1937,6 +1925,11 @@ impl<'tcx, T: 'tcx + ?Sized> Clone for Interned<'tcx, T> {\n }\n impl<'tcx, T: 'tcx + ?Sized> Copy for Interned<'tcx, T> {}\n \n+impl<'tcx, T: 'tcx + ?Sized> IntoPointer for Interned<'tcx, T> {\n+    fn into_pointer(&self) -> *const () {\n+        self.0 as *const _ as *const ()\n+    }\n+}\n // N.B., an `Interned<Ty>` compares and hashes as a `TyKind`.\n impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n     fn eq(&self, other: &Interned<'tcx, TyS<'tcx>>) -> bool {\n@@ -2089,7 +2082,7 @@ macro_rules! slice_interners {\n         $(impl<'tcx> TyCtxt<'tcx> {\n             pub fn $method(self, v: &[$ty]) -> &'tcx List<$ty> {\n                 self.interners.$field.intern_ref(v, || {\n-                    Interned(List::from_arena(&self.interners.arena, v))\n+                    Interned(List::from_arena(&*self.arena, v))\n                 }).0\n             }\n         })+"}, {"sha": "282136fa3546bec71efc57113912be3ad8b6bc64", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -6,6 +6,7 @@ pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::Variance::*;\n \n+use crate::arena::Arena;\n use crate::hir::exports::ExportMap;\n use crate::hir::map as hir_map;\n \n@@ -25,7 +26,6 @@ use crate::ty::layout::VariantIdx;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use crate::ty::util::{Discr, IntTypeExt};\n use crate::ty::walk::TypeWalker;\n-use arena::SyncDroplessArena;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::FxIndexMap;\n@@ -74,7 +74,7 @@ pub use crate::ty::diagnostics::*;\n pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n \n-pub use self::context::{keep_local, tls, AllArenas, FreeRegionInfo, TyCtxt};\n+pub use self::context::{keep_local, tls, FreeRegionInfo, TyCtxt};\n pub use self::context::{\n     CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, ResolvedOpaqueTy,\n     UserType, UserTypeAnnotationIndex,\n@@ -604,7 +604,7 @@ unsafe impl<T: Sync> Sync for List<T> {}\n \n impl<T: Copy> List<T> {\n     #[inline]\n-    fn from_arena<'tcx>(arena: &'tcx SyncDroplessArena, slice: &[T]) -> &'tcx List<T> {\n+    fn from_arena<'tcx>(arena: &'tcx Arena<'tcx>, slice: &[T]) -> &'tcx List<T> {\n         assert!(!mem::needs_drop::<T>());\n         assert!(mem::size_of::<T>() != 0);\n         assert!(slice.len() != 0);\n@@ -617,7 +617,9 @@ impl<T: Copy> List<T> {\n \n         let size = offset + slice.len() * mem::size_of::<T>();\n \n-        let mem = arena.alloc_raw(size, cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n+        let mem = arena\n+            .dropless\n+            .alloc_raw(size, cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n         unsafe {\n             let result = &mut *(mem.as_mut_ptr() as *mut List<T>);\n             // Write the length"}, {"sha": "44cef727f034be23d7884972cbda659bd5a8bcec", "filename": "src/librustc_data_structures/profiling.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc_data_structures%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc_data_structures%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fprofiling.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -136,9 +136,11 @@ bitflags::bitflags! {\n     }\n }\n \n+// keep this in sync with the `-Z self-profile-events` help message in librustc_session/options.rs\n const EVENT_FILTERS_BY_NAME: &[(&str, EventFilter)] = &[\n     (\"none\", EventFilter::NONE),\n     (\"all\", EventFilter::ALL),\n+    (\"default\", EventFilter::DEFAULT),\n     (\"generic-activity\", EventFilter::GENERIC_ACTIVITIES),\n     (\"query-provider\", EventFilter::QUERY_PROVIDERS),\n     (\"query-cache-hit\", EventFilter::QUERY_CACHE_HITS),"}, {"sha": "ee3f88ff1675fa6039077b6ad8c5e258a38ec10a", "filename": "src/librustc_data_structures/sharded.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc_data_structures%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc_data_structures%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsharded.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -137,6 +137,20 @@ impl<K: Eq + Hash + Copy> ShardedHashMap<K, ()> {\n     }\n }\n \n+pub trait IntoPointer {\n+    /// Returns a pointer which outlives `self`.\n+    fn into_pointer(&self) -> *const ();\n+}\n+\n+impl<K: Eq + Hash + Copy + IntoPointer> ShardedHashMap<K, ()> {\n+    pub fn contains_pointer_to<T: Hash + IntoPointer>(&self, value: &T) -> bool {\n+        let hash = make_hash(&value);\n+        let shard = self.get_shard_by_hash(hash).lock();\n+        let value = value.into_pointer();\n+        shard.raw_entry().from_hash(hash, |entry| entry.into_pointer() == value).is_some()\n+    }\n+}\n+\n #[inline]\n fn make_hash<K: Hash + ?Sized>(val: &K) -> u64 {\n     let mut state = FxHasher::default();"}, {"sha": "d62c7539d5f2189ac7c0663c7dc4e4231219bc29", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -15,7 +15,7 @@ use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n use rustc::traits;\n use rustc::ty::steal::Steal;\n-use rustc::ty::{self, AllArenas, GlobalCtxt, ResolverOutputs, TyCtxt};\n+use rustc::ty::{self, GlobalCtxt, ResolverOutputs, TyCtxt};\n use rustc::util::common::ErrorReported;\n use rustc_builtin_macros;\n use rustc_codegen_ssa::back::link::emit_metadata;\n@@ -715,7 +715,6 @@ pub fn create_global_ctxt<'tcx>(\n     outputs: OutputFilenames,\n     crate_name: &str,\n     global_ctxt: &'tcx Once<GlobalCtxt<'tcx>>,\n-    all_arenas: &'tcx AllArenas,\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n ) -> QueryContext<'tcx> {\n     let sess = &compiler.session();\n@@ -746,7 +745,6 @@ pub fn create_global_ctxt<'tcx>(\n                 lint_store,\n                 local_providers,\n                 extern_providers,\n-                &all_arenas,\n                 arena,\n                 resolver_outputs,\n                 hir_map,"}, {"sha": "0af9b17a2995b2f5026b2d1cefc2759ddb93d316", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -7,7 +7,7 @@ use rustc::hir::map;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::session::Session;\n use rustc::ty::steal::Steal;\n-use rustc::ty::{AllArenas, GlobalCtxt, ResolverOutputs};\n+use rustc::ty::{GlobalCtxt, ResolverOutputs};\n use rustc::util::common::ErrorReported;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::sync::{Lrc, Once, WorkerLocal};\n@@ -66,7 +66,6 @@ pub struct Queries<'tcx> {\n     compiler: &'tcx Compiler,\n     gcx: Once<GlobalCtxt<'tcx>>,\n \n-    all_arenas: AllArenas,\n     arena: WorkerLocal<Arena<'tcx>>,\n \n     dep_graph_future: Query<Option<DepGraphFuture>>,\n@@ -86,7 +85,6 @@ impl<'tcx> Queries<'tcx> {\n         Queries {\n             compiler,\n             gcx: Once::new(),\n-            all_arenas: AllArenas::new(),\n             arena: WorkerLocal::new(|_| Arena::default()),\n             dep_graph_future: Default::default(),\n             parse: Default::default(),\n@@ -265,7 +263,6 @@ impl<'tcx> Queries<'tcx> {\n                 outputs,\n                 &crate_name,\n                 &self.gcx,\n-                &self.all_arenas,\n                 &self.arena,\n             ))\n         })"}, {"sha": "2a0ed27b63b08f7c23f56ab2069a2265b0652fb7", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -923,8 +923,12 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     self_profile: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n         parse_switch_with_opt_path, [UNTRACKED],\n         \"run the self profiler and output the raw event data\"),\n+    // keep this in sync with the event filter names in librustc_data_structures/profiling.rs\n     self_profile_events: Option<Vec<String>> = (None, parse_opt_comma_list, [UNTRACKED],\n-        \"specifies which kinds of events get recorded by the self profiler\"),\n+        \"specifies which kinds of events get recorded by the self profiler;\n+        for example: `-Z self-profile-events=default,query-keys`\n+        all options: none, all, default, generic-activity, query-provider, query-cache-hit\n+                     query-blocked, incr-cache-load, query-keys\"),\n     emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],\n         \"emits a section containing stack size metadata\"),\n     plt: Option<bool> = (None, parse_opt_bool, [TRACKED],"}, {"sha": "173bb29e964d160c278b01ac66fecaff9f5785ce", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/689fca01c5a1eac2d240bf08aa728171a28f2285/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=689fca01c5a1eac2d240bf08aa728171a28f2285", "patch": "@@ -1320,10 +1320,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // those that do.\n                 self.one_bound_for_assoc_type(\n                     || traits::supertraits(tcx, trait_ref),\n-                    &trait_ref.print_only_trait_path().to_string(),\n+                    || trait_ref.print_only_trait_path().to_string(),\n                     binding.item_name,\n                     path_span,\n-                    match binding.kind {\n+                    || match binding.kind {\n                         ConvertedBindingKind::Equality(ty) => Some(ty.to_string()),\n                         _ => None,\n                     },\n@@ -1880,10 +1880,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     predicates.iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref()),\n                 )\n             },\n-            &param_name.as_str(),\n+            || param_name.to_string(),\n             assoc_name,\n             span,\n-            None,\n+            || None,\n         )\n     }\n \n@@ -1892,10 +1892,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn one_bound_for_assoc_type<I>(\n         &self,\n         all_candidates: impl Fn() -> I,\n-        ty_param_name: &str,\n+        ty_param_name: impl Fn() -> String,\n         assoc_name: ast::Ident,\n         span: Span,\n-        is_equality: Option<String>,\n+        is_equality: impl Fn() -> Option<String>,\n     ) -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n     where\n         I: Iterator<Item = ty::PolyTraitRef<'tcx>>,\n@@ -1908,7 +1908,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             None => {\n                 self.complain_about_assoc_type_not_found(\n                     all_candidates,\n-                    ty_param_name,\n+                    &ty_param_name(),\n                     assoc_name,\n                     span,\n                 );\n@@ -1921,6 +1921,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if let Some(bound2) = matching_candidates.next() {\n             debug!(\"one_bound_for_assoc_type: bound2 = {:?}\", bound2);\n \n+            let is_equality = is_equality();\n             let bounds = iter::once(bound).chain(iter::once(bound2)).chain(matching_candidates);\n             let mut err = if is_equality.is_some() {\n                 // More specific Error Index entry.\n@@ -1930,7 +1931,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     E0222,\n                     \"ambiguous associated type `{}` in bounds of `{}`\",\n                     assoc_name,\n-                    ty_param_name\n+                    ty_param_name()\n                 )\n             } else {\n                 struct_span_err!(\n@@ -1939,7 +1940,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     E0221,\n                     \"ambiguous associated type `{}` in bounds of `{}`\",\n                     assoc_name,\n-                    ty_param_name\n+                    ty_param_name()\n                 )\n             };\n             err.span_label(span, format!(\"ambiguous associated type `{}`\", assoc_name));\n@@ -1977,7 +1978,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             \"use fully qualified syntax to disambiguate\",\n                             format!(\n                                 \"<{} as {}>::{}\",\n-                                ty_param_name,\n+                                ty_param_name(),\n                                 bound.print_only_trait_path(),\n                                 assoc_name,\n                             ),\n@@ -1987,7 +1988,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 } else {\n                     err.note(&format!(\n                         \"associated type `{}` could derive from `{}`\",\n-                        ty_param_name,\n+                        ty_param_name(),\n                         bound.print_only_trait_path(),\n                     ));\n                 }\n@@ -1996,7 +1997,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 err.help(&format!(\n                     \"consider introducing a new type parameter `T` and adding `where` constraints:\\\n                      \\n    where\\n        T: {},\\n{}\",\n-                    ty_param_name,\n+                    ty_param_name(),\n                     where_bounds.join(\",\\n\"),\n                 ));\n             }\n@@ -2110,10 +2111,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                 self.one_bound_for_assoc_type(\n                     || traits::supertraits(tcx, ty::Binder::bind(trait_ref)),\n-                    \"Self\",\n+                    || \"Self\".to_string(),\n                     assoc_ident,\n                     span,\n-                    None,\n+                    || None,\n                 )?\n             }\n             (&ty::Param(_), Res::SelfTy(Some(param_did), None))"}]}