{"sha": "ff18038d750d5b692b4896c338e33ed134fe4ba2", "node_id": "C_kwDOAAsO6NoAKGZmMTgwMzhkNzUwZDViNjkyYjQ4OTZjMzM4ZTMzZWQxMzRmZTRiYTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-27T13:27:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-27T13:27:22Z"}, "message": "Auto merge of #95170 - jyn514:ci-llvm, r=Mark-Simulacrum\n\nMove `download-ci-llvm` out of bootstrap.py\n\nThis is ready for review. It has been tested on Windows, Linux, and NixOS.\n\nThe second commit ports the changes from https://github.com/rust-lang/rust/pull/95234 to Rust; I can remove it if desired.\n\nHelps with https://github.com/rust-lang/rust/issues/94829.\n\nAs a follow-up, this makes it possible to avoid downloading llvm until it's needed for building `rustc_llvm`; it would be nice to do that, but it shouldn't go in the first draft. It might also be possible to avoid requiring python until tests run (currently there's a check in `sanity.rs`), but I haven't looked too much into that.\n\n`@rustbot` label +A-rustbuild", "tree": {"sha": "8352f26e13019e5a63f3d2e34ce88713fe033af6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8352f26e13019e5a63f3d2e34ce88713fe033af6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff18038d750d5b692b4896c338e33ed134fe4ba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff18038d750d5b692b4896c338e33ed134fe4ba2", "html_url": "https://github.com/rust-lang/rust/commit/ff18038d750d5b692b4896c338e33ed134fe4ba2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff18038d750d5b692b4896c338e33ed134fe4ba2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2799141fdec79f2eb1ce75f27bf9982a495f72d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2799141fdec79f2eb1ce75f27bf9982a495f72d8", "html_url": "https://github.com/rust-lang/rust/commit/2799141fdec79f2eb1ce75f27bf9982a495f72d8"}, {"sha": "7885ade98434c765dc218ba7d396c8c4b7827fe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7885ade98434c765dc218ba7d396c8c4b7827fe8", "html_url": "https://github.com/rust-lang/rust/commit/7885ade98434c765dc218ba7d396c8c4b7827fe8"}], "stats": {"total": 553, "additions": 369, "deletions": 184}, "files": [{"sha": "cb92e50cdd39905ee9098f7361fc5b78576ef46c", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff18038d750d5b692b4896c338e33ed134fe4ba2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ff18038d750d5b692b4896c338e33ed134fe4ba2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ff18038d750d5b692b4896c338e33ed134fe4ba2", "patch": "@@ -225,8 +225,10 @@ dependencies = [\n  \"pretty_assertions\",\n  \"serde\",\n  \"serde_json\",\n+ \"tar\",\n  \"toml\",\n  \"winapi\",\n+ \"xz2\",\n ]\n \n [[package]]"}, {"sha": "dea8d998bdeda21ce50766a7e740a0c35868c35c", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=ff18038d750d5b692b4896c338e33ed134fe4ba2", "patch": "@@ -42,10 +42,12 @@ cc = \"1.0.69\"\n libc = \"0.2\"\n serde = { version = \"1.0.8\", features = [\"derive\"] }\n serde_json = \"1.0.2\"\n+tar = \"0.4\"\n toml = \"0.5\"\n ignore = \"0.4.10\"\n opener = \"0.5\"\n once_cell = \"1.7.2\"\n+xz2 = \"0.1\"\n \n [target.'cfg(windows)'.dependencies.winapi]\n version = \"0.3\""}, {"sha": "e38a574ca2310de1b230e2c0009a9e9d4f31d414", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=ff18038d750d5b692b4896c338e33ed134fe4ba2", "patch": "@@ -500,81 +500,6 @@ def download_toolchain(self, stage0=True, rustc_channel=None):\n                 with output(self.rustfmt_stamp()) as rustfmt_stamp:\n                     rustfmt_stamp.write(self.stage0_rustfmt.channel())\n \n-        # Avoid downloading LLVM twice (once for stage0 and once for the master rustc)\n-        if self.downloading_llvm() and stage0:\n-            # We want the most recent LLVM submodule update to avoid downloading\n-            # LLVM more often than necessary.\n-            #\n-            # This git command finds that commit SHA, looking for bors-authored\n-            # commits that modified src/llvm-project or other relevant version\n-            # stamp files.\n-            #\n-            # This works even in a repository that has not yet initialized\n-            # submodules.\n-            top_level = subprocess.check_output([\n-                \"git\", \"rev-parse\", \"--show-toplevel\",\n-            ]).decode(sys.getdefaultencoding()).strip()\n-            llvm_sha = subprocess.check_output([\n-                \"git\", \"rev-list\", \"--author=bors@rust-lang.org\", \"-n1\",\n-                \"--first-parent\", \"HEAD\",\n-                \"--\",\n-                \"{}/src/llvm-project\".format(top_level),\n-                \"{}/src/bootstrap/download-ci-llvm-stamp\".format(top_level),\n-                # the LLVM shared object file is named `LLVM-12-rust-{version}-nightly`\n-                \"{}/src/version\".format(top_level)\n-            ]).decode(sys.getdefaultencoding()).strip()\n-            llvm_assertions = self.get_toml('assertions', 'llvm') == 'true'\n-            llvm_root = self.llvm_root()\n-            llvm_lib = os.path.join(llvm_root, \"lib\")\n-            if self.program_out_of_date(self.llvm_stamp(), llvm_sha + str(llvm_assertions)):\n-                self._download_ci_llvm(llvm_sha, llvm_assertions)\n-                for binary in [\"llvm-config\", \"FileCheck\"]:\n-                    self.fix_bin_or_dylib(os.path.join(llvm_root, \"bin\", binary))\n-                for lib in os.listdir(llvm_lib):\n-                    if lib.endswith(\".so\"):\n-                        self.fix_bin_or_dylib(os.path.join(llvm_lib, lib))\n-                with output(self.llvm_stamp()) as llvm_stamp:\n-                    llvm_stamp.write(llvm_sha + str(llvm_assertions))\n-\n-    def downloading_llvm(self):\n-        opt = self.get_toml('download-ci-llvm', 'llvm')\n-        # This is currently all tier 1 targets and tier 2 targets with host tools\n-        # (since others may not have CI artifacts)\n-        # https://doc.rust-lang.org/rustc/platform-support.html#tier-1\n-        supported_platforms = [\n-            # tier 1\n-            \"aarch64-unknown-linux-gnu\",\n-            \"i686-pc-windows-gnu\",\n-            \"i686-pc-windows-msvc\",\n-            \"i686-unknown-linux-gnu\",\n-            \"x86_64-unknown-linux-gnu\",\n-            \"x86_64-apple-darwin\",\n-            \"x86_64-pc-windows-gnu\",\n-            \"x86_64-pc-windows-msvc\",\n-            # tier 2 with host tools\n-            \"aarch64-apple-darwin\",\n-            \"aarch64-pc-windows-msvc\",\n-            \"aarch64-unknown-linux-musl\",\n-            \"arm-unknown-linux-gnueabi\",\n-            \"arm-unknown-linux-gnueabihf\",\n-            \"armv7-unknown-linux-gnueabihf\",\n-            \"mips-unknown-linux-gnu\",\n-            \"mips64-unknown-linux-gnuabi64\",\n-            \"mips64el-unknown-linux-gnuabi64\",\n-            \"mipsel-unknown-linux-gnu\",\n-            \"powerpc-unknown-linux-gnu\",\n-            \"powerpc64-unknown-linux-gnu\",\n-            \"powerpc64le-unknown-linux-gnu\",\n-            \"riscv64gc-unknown-linux-gnu\",\n-            \"s390x-unknown-linux-gnu\",\n-            \"x86_64-unknown-freebsd\",\n-            \"x86_64-unknown-illumos\",\n-            \"x86_64-unknown-linux-musl\",\n-            \"x86_64-unknown-netbsd\",\n-        ]\n-        return opt == \"true\" \\\n-            or (opt == \"if-available\" and self.build in supported_platforms)\n-\n     def _download_component_helper(\n         self, filename, pattern, tarball_suffix, stage0=True, key=None\n     ):\n@@ -606,53 +531,6 @@ def _download_component_helper(\n             )\n         unpack(tarball, tarball_suffix, self.bin_root(stage0), match=pattern, verbose=self.verbose)\n \n-    def _download_ci_llvm(self, llvm_sha, llvm_assertions):\n-        if not llvm_sha:\n-            print(\"error: could not find commit hash for downloading LLVM\")\n-            print(\"help: maybe your repository history is too shallow?\")\n-            print(\"help: consider disabling `download-ci-llvm`\")\n-            print(\"help: or fetch enough history to include one upstream commit\")\n-            exit(1)\n-        cache_prefix = \"llvm-{}-{}\".format(llvm_sha, llvm_assertions)\n-        cache_dst = os.path.join(self.build_dir, \"cache\")\n-        rustc_cache = os.path.join(cache_dst, cache_prefix)\n-        if not os.path.exists(rustc_cache):\n-            os.makedirs(rustc_cache)\n-\n-        base = \"https://ci-artifacts.rust-lang.org\"\n-        url = \"rustc-builds/{}\".format(llvm_sha)\n-        if llvm_assertions:\n-            url = url.replace('rustc-builds', 'rustc-builds-alt')\n-        # ci-artifacts are only stored as .xz, not .gz\n-        if not support_xz():\n-            print(\"error: XZ support is required to download LLVM\")\n-            print(\"help: consider disabling `download-ci-llvm` or using python3\")\n-            exit(1)\n-        tarball_suffix = '.tar.xz'\n-        filename = \"rust-dev-nightly-\" + self.build + tarball_suffix\n-        tarball = os.path.join(rustc_cache, filename)\n-        if not os.path.exists(tarball):\n-            help_on_error = \"error: failed to download llvm from ci\"\n-            help_on_error += \"\\nhelp: old builds get deleted after a certain time\"\n-            help_on_error += \"\\nhelp: if trying to compile an old commit of rustc,\"\n-            help_on_error += \" disable `download-ci-llvm` in config.toml:\"\n-            help_on_error += \"\\n\"\n-            help_on_error += \"\\n[llvm]\"\n-            help_on_error += \"\\ndownload-ci-llvm = false\"\n-            help_on_error += \"\\n\"\n-            get(\n-                base,\n-                \"{}/{}\".format(url, filename),\n-                tarball,\n-                self.checksums_sha256,\n-                verbose=self.verbose,\n-                do_verify=False,\n-                help_on_error=help_on_error,\n-            )\n-        unpack(tarball, tarball_suffix, self.llvm_root(),\n-                match=\"rust-dev\",\n-                verbose=self.verbose)\n-\n     def fix_bin_or_dylib(self, fname):\n         \"\"\"Modifies the interpreter section of 'fname' to fix the dynamic linker,\n         or the RPATH section, to fix the dynamic library search path\n@@ -816,17 +694,6 @@ def rustfmt_stamp(self):\n         \"\"\"\n         return os.path.join(self.bin_root(True), '.rustfmt-stamp')\n \n-    def llvm_stamp(self):\n-        \"\"\"Return the path for .llvm-stamp\n-\n-        >>> rb = RustBuild()\n-        >>> rb.build_dir = \"build\"\n-        >>> rb.llvm_stamp() == os.path.join(\"build\", \"ci-llvm\", \".llvm-stamp\")\n-        True\n-        \"\"\"\n-        return os.path.join(self.llvm_root(), '.llvm-stamp')\n-\n-\n     def program_out_of_date(self, stamp_path, key):\n         \"\"\"Check if the given program stamp is out of date\"\"\"\n         if not os.path.exists(stamp_path) or self.clean:\n@@ -856,22 +723,6 @@ def bin_root(self, stage0):\n             subdir = \"ci-rustc\"\n         return os.path.join(self.build_dir, self.build, subdir)\n \n-    def llvm_root(self):\n-        \"\"\"Return the CI LLVM root directory\n-\n-        >>> rb = RustBuild()\n-        >>> rb.build_dir = \"build\"\n-        >>> rb.llvm_root() == os.path.join(\"build\", \"ci-llvm\")\n-        True\n-\n-        When the 'build' property is given should be a nested directory:\n-\n-        >>> rb.build = \"devel\"\n-        >>> rb.llvm_root() == os.path.join(\"build\", \"devel\", \"ci-llvm\")\n-        True\n-        \"\"\"\n-        return os.path.join(self.build_dir, self.build, \"ci-llvm\")\n-\n     def get_toml(self, key, section=None):\n         \"\"\"Returns the value of the given key in config.toml, otherwise returns None\n "}, {"sha": "dd45bd3a213b1f77e26de142207e57435772618d", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=ff18038d750d5b692b4896c338e33ed134fe4ba2", "patch": "@@ -12,7 +12,6 @@ use std::process::Command;\n use std::time::{Duration, Instant};\n \n use crate::cache::{Cache, Interned, INTERNER};\n-use crate::check;\n use crate::compile;\n use crate::config::{SplitDebuginfo, TargetSelection};\n use crate::dist;\n@@ -25,6 +24,7 @@ use crate::test;\n use crate::tool::{self, SourceType};\n use crate::util::{self, add_dylib_path, add_link_lib_path, exe, libdir, output, t};\n use crate::EXTRA_CHECK_CFGS;\n+use crate::{check, Config};\n use crate::{Build, CLang, DocTests, GitRepo, Mode};\n \n pub use crate::Compiler;\n@@ -960,6 +960,11 @@ impl<'a> Builder<'a> {\n         None\n     }\n \n+    /// Convenience wrapper to allow `builder.llvm_link_shared()` instead of `builder.config.llvm_link_shared(&builder)`.\n+    pub(crate) fn llvm_link_shared(&self) -> bool {\n+        Config::llvm_link_shared(self)\n+    }\n+\n     /// Prepares an invocation of `cargo` to be run.\n     ///\n     /// This will create a `Command` that represents a pending execution of"}, {"sha": "53933e4cd7d200299444a550d6fc2e0d6951fda4", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=ff18038d750d5b692b4896c338e33ed134fe4ba2", "patch": "@@ -737,7 +737,7 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetS\n             );\n             cargo.env(\"LLVM_STATIC_STDCPP\", file);\n         }\n-        if builder.config.llvm_link_shared {\n+        if builder.llvm_link_shared() {\n             cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n         }\n         if builder.config.llvm_use_libcxx {"}, {"sha": "e39c9fa1c5a6d6b30e4d325bc17870da43ce84dd", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 52, "deletions": 18, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=ff18038d750d5b692b4896c338e33ed134fe4ba2", "patch": "@@ -3,6 +3,7 @@\n //! This module implements parsing `config.toml` configuration files to tweak\n //! how the build runs.\n \n+use std::cell::Cell;\n use std::cmp;\n use std::collections::{HashMap, HashSet};\n use std::env;\n@@ -11,7 +12,7 @@ use std::fs;\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n \n-use crate::builder::TaskPath;\n+use crate::builder::{Builder, TaskPath};\n use crate::cache::{Interned, INTERNER};\n use crate::channel::GitInfo;\n pub use crate::flags::Subcommand;\n@@ -69,13 +70,14 @@ pub struct Config {\n     pub test_compare_mode: bool,\n     pub llvm_libunwind: LlvmLibunwind,\n     pub color: Color,\n+    pub patch_binaries_for_nix: bool,\n \n     pub on_fail: Option<String>,\n     pub stage: u32,\n     pub keep_stage: Vec<u32>,\n     pub keep_stage_std: Vec<u32>,\n     pub src: PathBuf,\n-    // defaults to `config.toml`\n+    /// defaults to `config.toml`\n     pub config: PathBuf,\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n@@ -96,7 +98,11 @@ pub struct Config {\n     pub llvm_release_debuginfo: bool,\n     pub llvm_version_check: bool,\n     pub llvm_static_stdcpp: bool,\n-    pub llvm_link_shared: bool,\n+    /// `None` if `llvm_from_ci` is true and we haven't yet downloaded llvm.\n+    #[cfg(not(test))]\n+    llvm_link_shared: Cell<Option<bool>>,\n+    #[cfg(test)]\n+    pub llvm_link_shared: Cell<Option<bool>>,\n     pub llvm_clang_cl: Option<String>,\n     pub llvm_targets: Option<String>,\n     pub llvm_experimental_targets: Option<String>,\n@@ -858,6 +864,7 @@ impl Config {\n         set(&mut config.local_rebuild, build.local_rebuild);\n         set(&mut config.print_step_timings, build.print_step_timings);\n         set(&mut config.print_step_rusage, build.print_step_rusage);\n+        set(&mut config.patch_binaries_for_nix, build.patch_binaries_for_nix);\n \n         config.verbose = cmp::max(config.verbose, flags.verbose);\n \n@@ -913,7 +920,9 @@ impl Config {\n             set(&mut config.llvm_release_debuginfo, llvm.release_debuginfo);\n             set(&mut config.llvm_version_check, llvm.version_check);\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n-            set(&mut config.llvm_link_shared, llvm.link_shared);\n+            if let Some(v) = llvm.link_shared {\n+                config.llvm_link_shared.set(Some(v));\n+            }\n             config.llvm_targets = llvm.targets.clone();\n             config.llvm_experimental_targets = llvm.experimental_targets.clone();\n             config.llvm_link_jobs = llvm.link_jobs;\n@@ -983,6 +992,7 @@ impl Config {\n                 check_ci_llvm!(llvm.optimize);\n                 check_ci_llvm!(llvm.thin_lto);\n                 check_ci_llvm!(llvm.release_debuginfo);\n+                // CI-built LLVM can be either dynamic or static. We won't know until we download it.\n                 check_ci_llvm!(llvm.link_shared);\n                 check_ci_llvm!(llvm.static_libstdcpp);\n                 check_ci_llvm!(llvm.targets);\n@@ -1000,26 +1010,14 @@ impl Config {\n                 check_ci_llvm!(llvm.clang);\n                 check_ci_llvm!(llvm.build_config);\n                 check_ci_llvm!(llvm.plugins);\n-\n-                // CI-built LLVM can be either dynamic or static.\n-                let ci_llvm = config.out.join(&*config.build.triple).join(\"ci-llvm\");\n-                config.llvm_link_shared = if config.dry_run {\n-                    // just assume dynamic for now\n-                    true\n-                } else {\n-                    let link_type = t!(\n-                        std::fs::read_to_string(ci_llvm.join(\"link-type.txt\")),\n-                        format!(\"CI llvm missing: {}\", ci_llvm.display())\n-                    );\n-                    link_type == \"dynamic\"\n-                };\n             }\n \n+            // NOTE: can never be hit when downloading from CI, since we call `check_ci_llvm!(thin_lto)` above.\n             if config.llvm_thin_lto && llvm.link_shared.is_none() {\n                 // If we're building with ThinLTO on, by default we want to link\n                 // to LLVM shared, to avoid re-doing ThinLTO (which happens in\n                 // the link step) with each stage.\n-                config.llvm_link_shared = true;\n+                config.llvm_link_shared.set(Some(true));\n             }\n         }\n \n@@ -1274,6 +1272,42 @@ impl Config {\n         }\n     }\n \n+    /// The absolute path to the downloaded LLVM artifacts.\n+    pub(crate) fn ci_llvm_root(&self) -> PathBuf {\n+        assert!(self.llvm_from_ci);\n+        self.out.join(&*self.build.triple).join(\"ci-llvm\")\n+    }\n+\n+    /// Determine whether llvm should be linked dynamically.\n+    ///\n+    /// If `false`, llvm should be linked statically.\n+    /// This is computed on demand since LLVM might have to first be downloaded from CI.\n+    pub(crate) fn llvm_link_shared(builder: &Builder<'_>) -> bool {\n+        let mut opt = builder.config.llvm_link_shared.get();\n+        if opt.is_none() && builder.config.dry_run {\n+            // just assume static for now - dynamic linking isn't supported on all platforms\n+            return false;\n+        }\n+\n+        let llvm_link_shared = *opt.get_or_insert_with(|| {\n+            if builder.config.llvm_from_ci {\n+                crate::native::maybe_download_ci_llvm(builder);\n+                let ci_llvm = builder.config.ci_llvm_root();\n+                let link_type = t!(\n+                    std::fs::read_to_string(ci_llvm.join(\"link-type.txt\")),\n+                    format!(\"CI llvm missing: {}\", ci_llvm.display())\n+                );\n+                link_type == \"dynamic\"\n+            } else {\n+                // unclear how thought-through this default is, but it maintains compatibility with\n+                // previous behavior\n+                false\n+            }\n+        });\n+        builder.config.llvm_link_shared.set(opt);\n+        llvm_link_shared\n+    }\n+\n     pub fn verbose(&self) -> bool {\n         self.verbose > 0\n     }"}, {"sha": "5d812e8b332e80bf69cf9f42d06d8abc01e1dfec", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=ff18038d750d5b692b4896c338e33ed134fe4ba2", "patch": "@@ -1904,7 +1904,7 @@ fn maybe_install_llvm(builder: &Builder<'_>, target: TargetSelection, dst_libdir\n     // clear why this is the case, though. llvm-config will emit the versioned\n     // paths and we don't want those in the sysroot (as we're expecting\n     // unversioned paths).\n-    if target.contains(\"apple-darwin\") && builder.config.llvm_link_shared {\n+    if target.contains(\"apple-darwin\") && builder.llvm_link_shared() {\n         let src_libdir = builder.llvm_out(target).join(\"lib\");\n         let llvm_dylib_path = src_libdir.join(\"libLLVM.dylib\");\n         if llvm_dylib_path.exists() {\n@@ -1939,7 +1939,7 @@ pub fn maybe_install_llvm_target(builder: &Builder<'_>, target: TargetSelection,\n     // We do not need to copy LLVM files into the sysroot if it is not\n     // dynamically linked; it is already included into librustc_llvm\n     // statically.\n-    if builder.config.llvm_link_shared {\n+    if builder.llvm_link_shared() {\n         maybe_install_llvm(builder, target, &dst_libdir);\n     }\n }\n@@ -1951,7 +1951,7 @@ pub fn maybe_install_llvm_runtime(builder: &Builder<'_>, target: TargetSelection\n     // We do not need to copy LLVM files into the sysroot if it is not\n     // dynamically linked; it is already included into librustc_llvm\n     // statically.\n-    if builder.config.llvm_link_shared {\n+    if builder.llvm_link_shared() {\n         maybe_install_llvm(builder, target, &dst_libdir);\n     }\n }\n@@ -2077,7 +2077,7 @@ impl Step for RustDev {\n         // compiler libraries.\n         let dst_libdir = tarball.image_dir().join(\"lib\");\n         maybe_install_llvm(builder, target, &dst_libdir);\n-        let link_type = if builder.config.llvm_link_shared { \"dynamic\" } else { \"static\" };\n+        let link_type = if builder.llvm_link_shared() { \"dynamic\" } else { \"static\" };\n         t!(std::fs::write(tarball.image_dir().join(\"link-type.txt\"), link_type), dst_libdir);\n \n         Some(tarball.generate())"}, {"sha": "b4b973b42479e942099f69a109786506371b737f", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=ff18038d750d5b692b4896c338e33ed134fe4ba2", "patch": "@@ -1391,6 +1391,16 @@ impl Build {\n         paths\n     }\n \n+    /// Create a temporary directory in `out` and return its path.\n+    ///\n+    /// NOTE: this temporary directory is shared between all steps;\n+    /// if you need an empty directory, create a new subdirectory inside it.\n+    fn tempdir(&self) -> PathBuf {\n+        let tmp = self.out.join(\"tmp\");\n+        t!(fs::create_dir_all(&tmp));\n+        tmp\n+    }\n+\n     /// Copies a file from `src` to `dst`\n     pub fn copy(&self, src: &Path, dst: &Path) {\n         if self.config.dry_run {"}, {"sha": "64e25f803b27f68141cda943297c4de7a7a67c49", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 288, "deletions": 4, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=ff18038d750d5b692b4896c338e33ed134fe4ba2", "patch": "@@ -12,9 +12,12 @@ use std::env;\n use std::env::consts::EXE_EXTENSION;\n use std::ffi::{OsStr, OsString};\n use std::fs::{self, File};\n-use std::io;\n+use std::io::{self, BufRead, BufReader, ErrorKind};\n use std::path::{Path, PathBuf};\n-use std::process::Command;\n+use std::process::{Command, Stdio};\n+\n+use once_cell::sync::OnceCell;\n+use xz2::bufread::XzDecoder;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::config::TargetSelection;\n@@ -62,6 +65,8 @@ pub fn prebuilt_llvm_config(\n     builder: &Builder<'_>,\n     target: TargetSelection,\n ) -> Result<PathBuf, Meta> {\n+    maybe_download_ci_llvm(builder);\n+\n     // If we're using a custom LLVM bail out here, but we can only use a\n     // custom LLVM for the build triple.\n     if let Some(config) = builder.config.target_config.get(&target) {\n@@ -111,6 +116,285 @@ pub fn prebuilt_llvm_config(\n     Err(Meta { stamp, build_llvm_config, out_dir, root: root.into() })\n }\n \n+pub(crate) fn maybe_download_ci_llvm(builder: &Builder<'_>) {\n+    let config = &builder.config;\n+    if !config.llvm_from_ci {\n+        return;\n+    }\n+    let mut rev_list = Command::new(\"git\");\n+    rev_list.args(&[\n+        PathBuf::from(\"rev-list\"),\n+        \"--author=bors@rust-lang.org\".into(),\n+        \"-n1\".into(),\n+        \"--first-parent\".into(),\n+        \"HEAD\".into(),\n+        \"--\".into(),\n+        builder.src.join(\"src/llvm-project\"),\n+        builder.src.join(\"src/bootstrap/download-ci-llvm-stamp\"),\n+        // the LLVM shared object file is named `LLVM-12-rust-{version}-nightly`\n+        builder.src.join(\"src/version\"),\n+    ]);\n+    let llvm_sha = output(&mut rev_list);\n+    let llvm_sha = llvm_sha.trim();\n+\n+    if llvm_sha == \"\" {\n+        println!(\"error: could not find commit hash for downloading LLVM\");\n+        println!(\"help: maybe your repository history is too shallow?\");\n+        println!(\"help: consider disabling `download-ci-llvm`\");\n+        println!(\"help: or fetch enough history to include one upstream commit\");\n+        panic!();\n+    }\n+\n+    let llvm_root = config.ci_llvm_root();\n+    let llvm_stamp = llvm_root.join(\".llvm-stamp\");\n+    let key = format!(\"{}{}\", llvm_sha, config.llvm_assertions);\n+    if program_out_of_date(&llvm_stamp, &key) && !config.dry_run {\n+        download_ci_llvm(builder, &llvm_sha);\n+        for binary in [\"llvm-config\", \"FileCheck\"] {\n+            fix_bin_or_dylib(builder, &llvm_root.join(\"bin\").join(binary));\n+        }\n+        let llvm_lib = llvm_root.join(\"lib\");\n+        for entry in t!(fs::read_dir(&llvm_lib)) {\n+            let lib = t!(entry).path();\n+            if lib.ends_with(\".so\") {\n+                fix_bin_or_dylib(builder, &lib);\n+            }\n+        }\n+        t!(fs::write(llvm_stamp, key));\n+    }\n+}\n+\n+fn download_ci_llvm(builder: &Builder<'_>, llvm_sha: &str) {\n+    let llvm_assertions = builder.config.llvm_assertions;\n+\n+    let cache_prefix = format!(\"llvm-{}-{}\", llvm_sha, llvm_assertions);\n+    let cache_dst = builder.out.join(\"cache\");\n+    let rustc_cache = cache_dst.join(cache_prefix);\n+    if !rustc_cache.exists() {\n+        t!(fs::create_dir_all(&rustc_cache));\n+    }\n+    let base = \"https://ci-artifacts.rust-lang.org\";\n+    let url = if llvm_assertions {\n+        format!(\"rustc-builds-alt/{}\", llvm_sha)\n+    } else {\n+        format!(\"rustc-builds/{}\", llvm_sha)\n+    };\n+    let filename = format!(\"rust-dev-nightly-{}.tar.xz\", builder.build.build.triple);\n+    let tarball = rustc_cache.join(&filename);\n+    if !tarball.exists() {\n+        download_component(builder, base, &format!(\"{}/{}\", url, filename), &tarball);\n+    }\n+    let llvm_root = builder.config.ci_llvm_root();\n+    unpack(builder, &tarball, &llvm_root);\n+}\n+\n+/// Modifies the interpreter section of 'fname' to fix the dynamic linker,\n+/// or the RPATH section, to fix the dynamic library search path\n+///\n+/// This is only required on NixOS and uses the PatchELF utility to\n+/// change the interpreter/RPATH of ELF executables.\n+///\n+/// Please see https://nixos.org/patchelf.html for more information\n+fn fix_bin_or_dylib(builder: &Builder<'_>, fname: &Path) {\n+    // FIXME: cache NixOS detection?\n+    match Command::new(\"uname\").arg(\"-s\").stderr(Stdio::inherit()).output() {\n+        Err(_) => return,\n+        Ok(output) if !output.status.success() => return,\n+        Ok(output) => {\n+            let mut s = output.stdout;\n+            if s.last() == Some(&b'\\n') {\n+                s.pop();\n+            }\n+            if s != b\"Linux\" {\n+                return;\n+            }\n+        }\n+    }\n+\n+    // If the user has asked binaries to be patched for Nix, then\n+    // don't check for NixOS or `/lib`, just continue to the patching.\n+    // FIXME: shouldn't this take precedence over the `uname` check above?\n+    if !builder.config.patch_binaries_for_nix {\n+        // Use `/etc/os-release` instead of `/etc/NIXOS`.\n+        // The latter one does not exist on NixOS when using tmpfs as root.\n+        const NIX_IDS: &[&str] = &[\"ID=nixos\", \"ID='nixos'\", \"ID=\\\"nixos\\\"\"];\n+        let os_release = match File::open(\"/etc/os-release\") {\n+            Err(e) if e.kind() == ErrorKind::NotFound => return,\n+            Err(e) => panic!(\"failed to access /etc/os-release: {}\", e),\n+            Ok(f) => f,\n+        };\n+        if !BufReader::new(os_release).lines().any(|l| NIX_IDS.contains(&t!(l).trim())) {\n+            return;\n+        }\n+        if Path::new(\"/lib\").exists() {\n+            return;\n+        }\n+    }\n+\n+    // At this point we're pretty sure the user is running NixOS or using Nix\n+    println!(\"info: you seem to be using Nix. Attempting to patch {}\", fname.display());\n+\n+    // Only build `.nix-deps` once.\n+    static NIX_DEPS_DIR: OnceCell<PathBuf> = OnceCell::new();\n+    let mut nix_build_succeeded = true;\n+    let nix_deps_dir = NIX_DEPS_DIR.get_or_init(|| {\n+        // Run `nix-build` to \"build\" each dependency (which will likely reuse\n+        // the existing `/nix/store` copy, or at most download a pre-built copy).\n+        //\n+        // Importantly, we create a gc-root called `.nix-deps` in the `build/`\n+        // directory, but still reference the actual `/nix/store` path in the rpath\n+        // as it makes it significantly more robust against changes to the location of\n+        // the `.nix-deps` location.\n+        //\n+        // bintools: Needed for the path of `ld-linux.so` (via `nix-support/dynamic-linker`).\n+        // zlib: Needed as a system dependency of `libLLVM-*.so`.\n+        // patchelf: Needed for patching ELF binaries (see doc comment above).\n+        let nix_deps_dir = builder.out.join(\".nix-deps\");\n+        const NIX_EXPR: &str = \"\n+        with (import <nixpkgs> {});\n+        symlinkJoin {\n+            name = \\\"rust-stage0-dependencies\\\";\n+            paths = [\n+                zlib\n+                patchelf\n+                stdenv.cc.bintools\n+            ];\n+        }\n+        \";\n+        nix_build_succeeded = builder.try_run(Command::new(\"nix-build\").args(&[\n+            Path::new(\"-E\"),\n+            Path::new(NIX_EXPR),\n+            Path::new(\"-o\"),\n+            &nix_deps_dir,\n+        ]));\n+        nix_deps_dir\n+    });\n+    if !nix_build_succeeded {\n+        return;\n+    }\n+\n+    let mut patchelf = Command::new(nix_deps_dir.join(\"bin/patchelf\"));\n+    let rpath_entries = {\n+        // ORIGIN is a relative default, all binary and dynamic libraries we ship\n+        // appear to have this (even when `../lib` is redundant).\n+        // NOTE: there are only two paths here, delimited by a `:`\n+        let mut entries = OsString::from(\"$ORIGIN/../lib:\");\n+        entries.push(t!(fs::canonicalize(nix_deps_dir)));\n+        entries.push(\"/lib\");\n+        entries\n+    };\n+    patchelf.args(&[OsString::from(\"--set-rpath\"), rpath_entries]);\n+    if !fname.ends_with(\".so\") {\n+        // Finally, set the corret .interp for binaries\n+        let dynamic_linker_path = nix_deps_dir.join(\"nix-support/dynamic-linker\");\n+        // FIXME: can we support utf8 here? `args` doesn't accept Vec<u8>, only OsString ...\n+        let dynamic_linker = t!(String::from_utf8(t!(fs::read(dynamic_linker_path))));\n+        patchelf.args(&[\"--set-interpreter\", dynamic_linker.trim_end()]);\n+    }\n+\n+    builder.try_run(patchelf.arg(fname));\n+}\n+\n+fn download_component(builder: &Builder<'_>, base: &str, url: &str, dest_path: &Path) {\n+    // Use a temporary file in case we crash while downloading, to avoid a corrupt download in cache/.\n+    let tempfile = builder.tempdir().join(dest_path.file_name().unwrap());\n+    // FIXME: support `do_verify` (only really needed for nightly rustfmt)\n+    // FIXME: support non-utf8 paths?\n+    download_with_retries(builder, tempfile.to_str().unwrap(), &format!(\"{}/{}\", base, url));\n+    t!(std::fs::rename(&tempfile, dest_path));\n+}\n+\n+fn download_with_retries(builder: &Builder<'_>, tempfile: &str, url: &str) {\n+    println!(\"downloading {}\", url);\n+\n+    // FIXME: check if curl is installed instead of skipping straight to powershell\n+    if builder.build.build.contains(\"windows-msvc\") {\n+        for _ in 0..3 {\n+            if builder.try_run(Command::new(\"PowerShell.exe\").args(&[\n+                \"/nologo\",\n+                \"-Command\",\n+                \"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\",\n+                &format!(\n+                    \"(New-Object System.Net.WebClient).DownloadFile('{}', '{}')\",\n+                    url, tempfile\n+                ),\n+            ])) {\n+                return;\n+            }\n+            println!(\"\\nspurious failure, trying again\");\n+        }\n+    } else {\n+        builder.run(Command::new(\"curl\").args(&[\n+            \"-#\",\n+            \"-y\",\n+            \"30\",\n+            \"-Y\",\n+            \"10\", // timeout if speed is < 10 bytes/sec for > 30 seconds\n+            \"--connect-timeout\",\n+            \"30\", // timeout if cannot connect within 30 seconds\n+            \"--retry\",\n+            \"3\",\n+            \"-Sf\",\n+            \"-o\",\n+            tempfile,\n+            url,\n+        ]));\n+    }\n+}\n+\n+fn unpack(builder: &Builder<'_>, tarball: &Path, dst: &Path) {\n+    println!(\"extracting {} to {}\", tarball.display(), dst.display());\n+    if !dst.exists() {\n+        t!(fs::create_dir_all(dst));\n+    }\n+\n+    // FIXME: will need to be a parameter once `download-rustc` is moved to rustbuild\n+    const MATCH: &str = \"rust-dev\";\n+\n+    // `tarball` ends with `.tar.xz`; strip that suffix\n+    // example: `rust-dev-nightly-x86_64-unknown-linux-gnu`\n+    let uncompressed_filename =\n+        Path::new(tarball.file_name().expect(\"missing tarball filename\")).file_stem().unwrap();\n+    let directory_prefix = Path::new(Path::new(uncompressed_filename).file_stem().unwrap());\n+\n+    // decompress the file\n+    let data = t!(File::open(tarball));\n+    let decompressor = XzDecoder::new(BufReader::new(data));\n+\n+    let mut tar = tar::Archive::new(decompressor);\n+    for member in t!(tar.entries()) {\n+        let mut member = t!(member);\n+        let original_path = t!(member.path()).into_owned();\n+        // skip the top-level directory\n+        if original_path == directory_prefix {\n+            continue;\n+        }\n+        let mut short_path = t!(original_path.strip_prefix(directory_prefix));\n+        if !short_path.starts_with(MATCH) {\n+            continue;\n+        }\n+        short_path = t!(short_path.strip_prefix(MATCH));\n+        let dst_path = dst.join(short_path);\n+        builder.verbose(&format!(\"extracting {} to {}\", original_path.display(), dst.display()));\n+        if !t!(member.unpack_in(dst)) {\n+            panic!(\"path traversal attack ??\");\n+        }\n+        let src_path = dst.join(original_path);\n+        if src_path.is_dir() && dst_path.exists() {\n+            continue;\n+        }\n+        t!(fs::rename(src_path, dst_path));\n+    }\n+    t!(fs::remove_dir_all(dst.join(directory_prefix)));\n+}\n+\n+fn program_out_of_date(stamp: &Path, key: &str) -> bool {\n+    if !stamp.exists() {\n+        return true;\n+    }\n+    t!(fs::read_to_string(stamp)) != key\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Llvm {\n     pub target: TargetSelection,\n@@ -153,7 +437,7 @@ impl Step for Llvm {\n             };\n \n         builder.update_submodule(&Path::new(\"src\").join(\"llvm-project\"));\n-        if builder.config.llvm_link_shared\n+        if builder.llvm_link_shared()\n             && (target.contains(\"windows\") || target.contains(\"apple-darwin\"))\n         {\n             panic!(\"shared linking to LLVM is not currently supported on {}\", target.triple);\n@@ -255,7 +539,7 @@ impl Step for Llvm {\n         //\n         // If we're not linking rustc to a dynamic LLVM, though, then don't link\n         // tools to it.\n-        if builder.llvm_link_tools_dynamically(target) && builder.config.llvm_link_shared {\n+        if builder.llvm_link_tools_dynamically(target) && builder.llvm_link_shared() {\n             cfg.define(\"LLVM_LINK_LLVM_DYLIB\", \"ON\");\n         }\n "}, {"sha": "1193546992cd57c7ad3cfee9c52662ed5dfd1b01", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff18038d750d5b692b4896c338e33ed134fe4ba2/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=ff18038d750d5b692b4896c338e33ed134fe4ba2", "patch": "@@ -1575,9 +1575,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             cmd.env(\"RUSTC_PROFILER_SUPPORT\", \"1\");\n         }\n \n-        let tmp = builder.out.join(\"tmp\");\n-        std::fs::create_dir_all(&tmp).unwrap();\n-        cmd.env(\"RUST_TEST_TMPDIR\", tmp);\n+        cmd.env(\"RUST_TEST_TMPDIR\", builder.tempdir());\n \n         cmd.arg(\"--adb-path\").arg(\"adb\");\n         cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n@@ -2257,14 +2255,13 @@ impl Step for RemoteCopyLibs {\n         builder.ensure(compile::Std { compiler, target });\n \n         builder.info(&format!(\"REMOTE copy libs to emulator ({})\", target));\n-        t!(fs::create_dir_all(builder.out.join(\"tmp\")));\n \n         let server = builder.ensure(tool::RemoteTestServer { compiler, target });\n \n         // Spawn the emulator and wait for it to come online\n         let tool = builder.tool_exe(Tool::RemoteTestClient);\n         let mut cmd = Command::new(&tool);\n-        cmd.arg(\"spawn-emulator\").arg(target.triple).arg(&server).arg(builder.out.join(\"tmp\"));\n+        cmd.arg(\"spawn-emulator\").arg(target.triple).arg(&server).arg(builder.tempdir());\n         if let Some(rootfs) = builder.qemu_rootfs(target) {\n             cmd.arg(rootfs);\n         }\n@@ -2298,7 +2295,7 @@ impl Step for Distcheck {\n     /// Runs \"distcheck\", a 'make check' from a tarball\n     fn run(self, builder: &Builder<'_>) {\n         builder.info(\"Distcheck\");\n-        let dir = builder.out.join(\"tmp\").join(\"distcheck\");\n+        let dir = builder.tempdir().join(\"distcheck\");\n         let _ = fs::remove_dir_all(&dir);\n         t!(fs::create_dir_all(&dir));\n \n@@ -2324,7 +2321,7 @@ impl Step for Distcheck {\n \n         // Now make sure that rust-src has all of libstd's dependencies\n         builder.info(\"Distcheck rust-src\");\n-        let dir = builder.out.join(\"tmp\").join(\"distcheck-src\");\n+        let dir = builder.tempdir().join(\"distcheck-src\");\n         let _ = fs::remove_dir_all(&dir);\n         t!(fs::create_dir_all(&dir));\n "}]}