{"sha": "9bcf557589a385d163c6d543ede82953b09e072f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliY2Y1NTc1ODlhMzg1ZDE2M2M2ZDU0M2VkZTgyOTUzYjA5ZTA3MmY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-12T22:38:28Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-14T02:34:59Z"}, "message": "Implement native::IoFactory\n\nThis commit re-organizes the io::native module slightly in order to have a\nworking implementation of rtio::IoFactory which uses native implementations. The\ngoal is to seamlessly multiplex among libuv/native implementations wherever\nnecessary.\n\nRight now most of the native I/O is unimplemented, but we have existing bindings\nfor file descriptors and processes which have been hooked up. What this means is\nthat you can now invoke println!() from libstd with no local task, no local\nscheduler, and even without libuv.\n\nThere's still plenty of work to do on the native I/O factory, but this is the\nfirst steps into making it an official portion of the standard library. I don't\nexpect anyone to reach into io::native directly, but rather only std::io\nprimitives will be used. Each std::io interface seamlessly falls back onto the\nnative I/O implementation if the local scheduler doesn't have a libuv one\n(hurray trait ojects!)", "tree": {"sha": "fa03002e7054bde23c9712637f78914806e16454", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa03002e7054bde23c9712637f78914806e16454"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bcf557589a385d163c6d543ede82953b09e072f", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bcf557589a385d163c6d543ede82953b09e072f", "html_url": "https://github.com/rust-lang/rust/commit/9bcf557589a385d163c6d543ede82953b09e072f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bcf557589a385d163c6d543ede82953b09e072f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bfa45cfd9d7c8b2dcc0ea7a42396624e8b5a31b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bfa45cfd9d7c8b2dcc0ea7a42396624e8b5a31b", "html_url": "https://github.com/rust-lang/rust/commit/1bfa45cfd9d7c8b2dcc0ea7a42396624e8b5a31b"}], "stats": {"total": 832, "additions": 476, "deletions": 356}, "files": [{"sha": "71744c717d4bddd5a3897f6ebeba298070c2830b", "filename": "src/librustuv/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibrustuv%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibrustuv%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fmacros.rs?ref=9bcf557589a385d163c6d543ede82953b09e072f", "patch": "@@ -33,9 +33,9 @@ macro_rules! get_handle_to_current_scheduler(\n )\n \n pub fn dumb_println(args: &fmt::Arguments) {\n-    use std::io::native::stdio::stderr;\n-    use std::io::Writer;\n-\n-    let mut out = stderr();\n-    fmt::writeln(&mut out as &mut Writer, args);\n+    use std::io::native::file::FileDesc;\n+    use std::io;\n+    use std::libc;\n+    let mut out = FileDesc::new(libc::STDERR_FILENO, false);\n+    fmt::writeln(&mut out as &mut io::Writer, args);\n }"}, {"sha": "2aed3bdb8496fddeefdeb79f786d1a442fe7146d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=9bcf557589a385d163c6d543ede82953b09e072f", "patch": "@@ -306,24 +306,7 @@ pub mod timer;\n /// Buffered I/O wrappers\n pub mod buffered;\n \n-/// Thread-blocking implementations\n-pub mod native {\n-    /// Posix file I/O\n-    pub mod file;\n-    /// Process spawning and child management\n-    pub mod process;\n-    /// Posix stdio\n-    pub mod stdio;\n-\n-    /// Sockets\n-    /// # XXX - implement this\n-    pub mod net {\n-        pub mod tcp { }\n-        pub mod udp { }\n-        #[cfg(unix)]\n-        pub mod unix { }\n-    }\n-}\n+pub mod native;\n \n /// Signal handling\n pub mod signal;"}, {"sha": "5e39460ba6a4dc9e2361be9a85b09759f3716fed", "filename": "src/libstd/io/native/file.rs", "status": "modified", "additions": 132, "deletions": 100, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Ffile.rs?ref=9bcf557589a385d163c6d543ede82953b09e072f", "patch": "@@ -12,42 +12,16 @@\n \n #[allow(non_camel_case_types)];\n \n+use io::IoError;\n+use io;\n use libc;\n+use ops::Drop;\n+use option::{Some, None, Option};\n use os;\n-use prelude::*;\n-use super::super::*;\n-\n-#[cfg(windows)]\n-fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n-    match errno {\n-        libc::EOF => (EndOfFile, \"end of file\"),\n-        _ => (OtherIoError, \"unknown error\"),\n-    }\n-}\n-\n-#[cfg(not(windows))]\n-fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n-    // XXX: this should probably be a bit more descriptive...\n-    match errno {\n-        libc::EOF => (EndOfFile, \"end of file\"),\n-\n-        // These two constants can have the same value on some systems, but\n-        // different values on others, so we can't use a match clause\n-        x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n-            (ResourceUnavailable, \"resource temporarily unavailable\"),\n-\n-        _ => (OtherIoError, \"unknown error\"),\n-    }\n-}\n-\n-fn raise_error() {\n-    let (kind, desc) = get_err(os::errno() as i32);\n-    io_error::cond.raise(IoError {\n-        kind: kind,\n-        desc: desc,\n-        detail: Some(os::last_os_error())\n-    });\n-}\n+use ptr::RawPtr;\n+use result::{Result, Ok, Err};\n+use rt::rtio;\n+use vec::ImmutableVector;\n \n fn keep_going(data: &[u8], f: &fn(*u8, uint) -> i64) -> i64 {\n     #[cfg(windows)] static eintr: int = 0; // doesn't matter\n@@ -95,10 +69,8 @@ impl FileDesc {\n     pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n         FileDesc { fd: fd, close_on_drop: close_on_drop }\n     }\n-}\n \n-impl Reader for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         #[cfg(windows)] type rlen = libc::c_uint;\n         #[cfg(not(windows))] type rlen = libc::size_t;\n         let ret = do keep_going(buf) |buf, len| {\n@@ -107,20 +79,14 @@ impl Reader for FileDesc {\n             }\n         };\n         if ret == 0 {\n-            None\n+            Err(io::standard_error(io::EndOfFile))\n         } else if ret < 0 {\n-            raise_error();\n-            None\n+            Err(super::last_error())\n         } else {\n-            Some(ret as uint)\n+            Ok(ret as uint)\n         }\n     }\n-\n-    fn eof(&mut self) -> bool { false }\n-}\n-\n-impl Writer for FileDesc {\n-    fn write(&mut self, buf: &[u8]) {\n+    fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         #[cfg(windows)] type wlen = libc::c_uint;\n         #[cfg(not(windows))] type wlen = libc::size_t;\n         let ret = do keep_going(buf) |buf, len| {\n@@ -129,14 +95,84 @@ impl Writer for FileDesc {\n             }\n         };\n         if ret < 0 {\n-            raise_error();\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n         }\n     }\n }\n \n+impl io::Reader for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        match self.inner_read(buf) { Ok(n) => Some(n), Err(*) => None }\n+    }\n+    fn eof(&mut self) -> bool { false }\n+}\n+\n+impl io::Writer for FileDesc {\n+    fn write(&mut self, buf: &[u8]) {\n+        self.inner_write(buf);\n+    }\n+}\n+\n+impl rtio::RtioFileStream for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+        self.inner_read(buf).map(|i| i as int)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+    fn pread(&mut self, _buf: &mut [u8], _offset: u64) -> Result<int, IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn pwrite(&mut self, _buf: &[u8], _offset: u64) -> Result<(), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn seek(&mut self, _pos: i64, _whence: io::SeekStyle) -> Result<u64, IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn tell(&self) -> Result<u64, IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn fsync(&mut self) -> Result<(), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn datasync(&mut self) -> Result<(), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn truncate(&mut self, _offset: i64) -> Result<(), IoError> {\n+        Err(super::unimpl())\n+    }\n+}\n+\n+impl rtio::RtioPipe for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        self.inner_read(buf)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+}\n+\n+impl rtio::RtioTTY for FileDesc {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        self.inner_read(buf)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.inner_write(buf)\n+    }\n+    fn set_raw(&mut self, _raw: bool) -> Result<(), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+        Err(super::unimpl())\n+    }\n+}\n+\n impl Drop for FileDesc {\n     fn drop(&mut self) {\n-        if self.close_on_drop {\n+        // closing stdio file handles makes no sense, so never do it\n+        if self.close_on_drop && self.fd > libc::STDERR_FILENO {\n             unsafe { libc::close(self.fd); }\n         }\n     }\n@@ -154,67 +190,72 @@ impl CFile {\n     pub fn new(file: *libc::FILE) -> CFile { CFile { file: file } }\n }\n \n-impl Reader for CFile {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+impl rtio::RtioFileStream for CFile {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n         let ret = do keep_going(buf) |buf, len| {\n             unsafe {\n                 libc::fread(buf as *mut libc::c_void, 1, len as libc::size_t,\n                             self.file) as i64\n             }\n         };\n         if ret == 0 {\n-            None\n+            Err(io::standard_error(io::EndOfFile))\n         } else if ret < 0 {\n-            raise_error();\n-            None\n+            Err(super::last_error())\n         } else {\n-            Some(ret as uint)\n+            Ok(ret as int)\n         }\n     }\n \n-    fn eof(&mut self) -> bool {\n-        unsafe { libc::feof(self.file) != 0 }\n-    }\n-}\n-\n-impl Writer for CFile {\n-    fn write(&mut self, buf: &[u8]) {\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         let ret = do keep_going(buf) |buf, len| {\n             unsafe {\n                 libc::fwrite(buf as *libc::c_void, 1, len as libc::size_t,\n                             self.file) as i64\n             }\n         };\n         if ret < 0 {\n-            raise_error();\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n         }\n     }\n \n-    fn flush(&mut self) {\n-        if unsafe { libc::fflush(self.file) } < 0 {\n-            raise_error();\n+    fn pread(&mut self, _buf: &mut [u8], _offset: u64) -> Result<int, IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn pwrite(&mut self, _buf: &[u8], _offset: u64) -> Result<(), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n+        let whence = match style {\n+            io::SeekSet => libc::SEEK_SET,\n+            io::SeekEnd => libc::SEEK_END,\n+            io::SeekCur => libc::SEEK_CUR,\n+        };\n+        let n = unsafe { libc::fseek(self.file, pos as libc::c_long, whence) };\n+        if n < 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(n as u64)\n         }\n     }\n-}\n-\n-impl Seek for CFile {\n-    fn tell(&self) -> u64 {\n+    fn tell(&self) -> Result<u64, IoError> {\n         let ret = unsafe { libc::ftell(self.file) };\n         if ret < 0 {\n-            raise_error();\n+            Err(super::last_error())\n+        } else {\n+            Ok(ret as u64)\n         }\n-        return ret as u64;\n     }\n-\n-    fn seek(&mut self, pos: i64, style: SeekStyle) {\n-        let whence = match style {\n-            SeekSet => libc::SEEK_SET,\n-            SeekEnd => libc::SEEK_END,\n-            SeekCur => libc::SEEK_CUR,\n-        };\n-        if unsafe { libc::fseek(self.file, pos as libc::c_long, whence) } < 0 {\n-            raise_error();\n-        }\n+    fn fsync(&mut self) -> Result<(), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn datasync(&mut self) -> Result<(), IoError> {\n+        Err(super::unimpl())\n+    }\n+    fn truncate(&mut self, _offset: i64) -> Result<(), IoError> {\n+        Err(super::unimpl())\n     }\n }\n \n@@ -228,9 +269,9 @@ impl Drop for CFile {\n mod tests {\n     use libc;\n     use os;\n-    use prelude::*;\n-    use io::{io_error, SeekSet};\n-    use super::*;\n+    use io::{io_error, SeekSet, Writer, Reader};\n+    use result::Ok;\n+    use super::{CFile, FileDesc};\n \n     #[ignore(cfg(target_os = \"freebsd\"))] // hmm, maybe pipes have a tiny buffer\n     fn test_file_desc() {\n@@ -241,10 +282,10 @@ mod tests {\n             let mut reader = FileDesc::new(input, true);\n             let mut writer = FileDesc::new(out, true);\n \n-            writer.write(bytes!(\"test\"));\n+            writer.inner_write(bytes!(\"test\"));\n             let mut buf = [0u8, ..4];\n-            match reader.read(buf) {\n-                Some(4) => {\n+            match reader.inner_read(buf) {\n+                Ok(4) => {\n                     assert_eq!(buf[0], 't' as u8);\n                     assert_eq!(buf[1], 'e' as u8);\n                     assert_eq!(buf[2], 's' as u8);\n@@ -253,17 +294,8 @@ mod tests {\n                 r => fail!(\"invalid read: {:?}\", r)\n             }\n \n-            let mut raised = false;\n-            do io_error::cond.trap(|_| { raised = true; }).inside {\n-                writer.read(buf);\n-            }\n-            assert!(raised);\n-\n-            raised = false;\n-            do io_error::cond.trap(|_| { raised = true; }).inside {\n-                reader.write(buf);\n-            }\n-            assert!(raised);\n+            assert!(writer.inner_read(buf).is_err());\n+            assert!(reader.inner_write(buf).is_err());\n         }\n     }\n \n@@ -278,7 +310,7 @@ mod tests {\n             let mut buf = [0u8, ..4];\n             file.seek(0, SeekSet);\n             match file.read(buf) {\n-                Some(4) => {\n+                Ok(4) => {\n                     assert_eq!(buf[0], 't' as u8);\n                     assert_eq!(buf[1], 'e' as u8);\n                     assert_eq!(buf[2], 's' as u8);"}, {"sha": "d7aa6c14fcd9f86f6b4577781359407aeae37875", "filename": "src/libstd/io/native/mod.rs", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Fio%2Fnative%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Fio%2Fnative%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Fmod.rs?ref=9bcf557589a385d163c6d543ede82953b09e072f", "patch": "@@ -0,0 +1,200 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Native thread-blocking I/O implementation\n+//!\n+//! This module contains the implementation of native thread-blocking\n+//! implementations of I/O on all platforms. This module is not intended to be\n+//! used directly, but rather the rust runtime will fall back to using it if\n+//! necessary.\n+//!\n+//! Rust code normally runs inside of green tasks with a local scheduler using\n+//! asynchronous I/O to cooperate among tasks. This model is not always\n+//! available, however, and that's where these native implementations come into\n+//! play. The only dependencies of these modules are the normal system libraries\n+//! that you would find on the respective platform.\n+\n+use c_str::CString;\n+use comm::SharedChan;\n+use libc::c_int;\n+use libc;\n+use option::{Option, None, Some};\n+use os;\n+use path::Path;\n+use result::{Result, Ok, Err};\n+use rt::rtio;\n+use rt::rtio::{RtioTcpStream, RtioTcpListener, RtioUdpSocket, RtioUnixListener,\n+               RtioPipe, RtioFileStream, RtioProcess, RtioSignal, RtioTTY,\n+               CloseBehavior, RtioTimer};\n+use io;\n+use io::IoError;\n+use io::net::ip::SocketAddr;\n+use io::process::ProcessConfig;\n+use io::signal::Signum;\n+use ai = io::net::addrinfo;\n+\n+// Local re-exports\n+pub use self::file::FileDesc;\n+pub use self::process::Process;\n+\n+// Native I/O implementations\n+pub mod file;\n+pub mod process;\n+\n+type IoResult<T> = Result<T, IoError>;\n+\n+fn unimpl() -> IoError {\n+    IoError {\n+        kind: io::IoUnavailable,\n+        desc: \"unimplemented I/O interface\",\n+        detail: None,\n+    }\n+}\n+\n+fn last_error() -> IoError {\n+    #[cfg(windows)]\n+    fn get_err(errno: i32) -> (io::IoErrorKind, &'static str) {\n+        match errno {\n+            libc::EOF => (io::EndOfFile, \"end of file\"),\n+            _ => (io::OtherIoError, \"unknown error\"),\n+        }\n+    }\n+\n+    #[cfg(not(windows))]\n+    fn get_err(errno: i32) -> (io::IoErrorKind, &'static str) {\n+        // XXX: this should probably be a bit more descriptive...\n+        match errno {\n+            libc::EOF => (io::EndOfFile, \"end of file\"),\n+\n+            // These two constants can have the same value on some systems, but\n+            // different values on others, so we can't use a match clause\n+            x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n+                (io::ResourceUnavailable, \"resource temporarily unavailable\"),\n+\n+            _ => (io::OtherIoError, \"unknown error\"),\n+        }\n+    }\n+\n+    let (kind, desc) = get_err(os::errno() as i32);\n+    IoError {\n+        kind: kind,\n+        desc: desc,\n+        detail: Some(os::last_os_error())\n+    }\n+}\n+\n+/// Implementation of rt::rtio's IoFactory trait to generate handles to the\n+/// native I/O functionality.\n+pub struct IoFactory;\n+\n+impl rtio::IoFactory for IoFactory {\n+    // networking\n+    fn tcp_connect(&mut self, _addr: SocketAddr) -> IoResult<~RtioTcpStream> {\n+        Err(unimpl())\n+    }\n+    fn tcp_bind(&mut self, _addr: SocketAddr) -> IoResult<~RtioTcpListener> {\n+        Err(unimpl())\n+    }\n+    fn udp_bind(&mut self, _addr: SocketAddr) -> IoResult<~RtioUdpSocket> {\n+        Err(unimpl())\n+    }\n+    fn unix_bind(&mut self, _path: &CString) -> IoResult<~RtioUnixListener> {\n+        Err(unimpl())\n+    }\n+    fn unix_connect(&mut self, _path: &CString) -> IoResult<~RtioPipe> {\n+        Err(unimpl())\n+    }\n+    fn get_host_addresses(&mut self, _host: Option<&str>, _servname: Option<&str>,\n+                          _hint: Option<ai::Hint>) -> IoResult<~[ai::Info]> {\n+        Err(unimpl())\n+    }\n+\n+    // filesystem operations\n+    fn fs_from_raw_fd(&mut self, fd: c_int,\n+                      close: CloseBehavior) -> ~RtioFileStream {\n+        let close = match close {\n+            rtio::CloseSynchronously | rtio::CloseAsynchronously => true,\n+            rtio::DontClose => false\n+        };\n+        ~file::FileDesc::new(fd, close) as ~RtioFileStream\n+    }\n+    fn fs_open(&mut self, _path: &CString, _fm: io::FileMode, _fa: io::FileAccess)\n+        -> IoResult<~RtioFileStream> {\n+        Err(unimpl())\n+    }\n+    fn fs_unlink(&mut self, _path: &CString) -> IoResult<()> {\n+        Err(unimpl())\n+    }\n+    fn fs_stat(&mut self, _path: &CString) -> IoResult<io::FileStat> {\n+        Err(unimpl())\n+    }\n+    fn fs_mkdir(&mut self, _path: &CString,\n+                _mode: io::FilePermission) -> IoResult<()> {\n+        Err(unimpl())\n+    }\n+    fn fs_chmod(&mut self, _path: &CString,\n+                _mode: io::FilePermission) -> IoResult<()> {\n+        Err(unimpl())\n+    }\n+    fn fs_rmdir(&mut self, _path: &CString) -> IoResult<()> {\n+        Err(unimpl())\n+    }\n+    fn fs_rename(&mut self, _path: &CString, _to: &CString) -> IoResult<()> {\n+        Err(unimpl())\n+    }\n+    fn fs_readdir(&mut self, _path: &CString, _flags: c_int) -> IoResult<~[Path]> {\n+        Err(unimpl())\n+    }\n+    fn fs_lstat(&mut self, _path: &CString) -> IoResult<io::FileStat> {\n+        Err(unimpl())\n+    }\n+    fn fs_chown(&mut self, _path: &CString, _uid: int, _gid: int) -> IoResult<()> {\n+        Err(unimpl())\n+    }\n+    fn fs_readlink(&mut self, _path: &CString) -> IoResult<Path> {\n+        Err(unimpl())\n+    }\n+    fn fs_symlink(&mut self, _src: &CString, _dst: &CString) -> IoResult<()> {\n+        Err(unimpl())\n+    }\n+    fn fs_link(&mut self, _src: &CString, _dst: &CString) -> IoResult<()> {\n+        Err(unimpl())\n+    }\n+    fn fs_utime(&mut self, _src: &CString, _atime: u64,\n+                _mtime: u64) -> IoResult<()> {\n+        Err(unimpl())\n+    }\n+\n+    // misc\n+    fn timer_init(&mut self) -> IoResult<~RtioTimer> {\n+        Err(unimpl())\n+    }\n+    fn spawn(&mut self, config: ProcessConfig)\n+            -> IoResult<(~RtioProcess, ~[Option<~RtioPipe>])> {\n+        process::Process::spawn(config).map(|(p, io)| {\n+            (~p as ~RtioProcess,\n+             io.move_iter().map(|p| p.map(|p| ~p as ~RtioPipe)).collect())\n+        })\n+    }\n+    fn pipe_open(&mut self, _fd: c_int) -> IoResult<~RtioPipe> {\n+        Err(unimpl())\n+    }\n+    fn tty_open(&mut self, fd: c_int, _readable: bool) -> IoResult<~RtioTTY> {\n+        if unsafe { libc::isatty(fd) } != 0 {\n+            Ok(~file::FileDesc::new(fd, true) as ~RtioTTY)\n+        } else {\n+            Err(unimpl())\n+        }\n+    }\n+    fn signal(&mut self, _signal: Signum, _channel: SharedChan<Signum>)\n+        -> IoResult<~RtioSignal> {\n+        Err(unimpl())\n+    }\n+}"}, {"sha": "71c6ce78a1ed1ded2c3764bf79c742cb06dd615c", "filename": "src/libstd/io/native/process.rs", "status": "modified", "additions": 57, "deletions": 129, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs?ref=9bcf557589a385d163c6d543ede82953b09e072f", "patch": "@@ -9,14 +9,17 @@\n // except according to those terms.\n \n use cast;\n+use io;\n use libc::{pid_t, c_void, c_int};\n use libc;\n use os;\n use prelude::*;\n use ptr;\n-use io;\n+use rt::rtio;\n use super::file;\n \n+use p = io::process;\n+\n /**\n  * A value representing a child process.\n  *\n@@ -33,13 +36,6 @@ pub struct Process {\n     /// pid being re-used until the handle is closed.\n     priv handle: *(),\n \n-    /// Currently known stdin of the child, if any\n-    priv input: Option<file::FileDesc>,\n-    /// Currently known stdout of the child, if any\n-    priv output: Option<file::FileDesc>,\n-    /// Currently known stderr of the child, if any\n-    priv error: Option<file::FileDesc>,\n-\n     /// None until finish() is called.\n     priv exit_code: Option<int>,\n }\n@@ -64,133 +60,71 @@ impl Process {\n     ///     these are `None`, then this module will bind the input/output to an\n     ///     os pipe instead. This process takes ownership of these file\n     ///     descriptors, closing them upon destruction of the process.\n-    pub fn new(prog: &str, args: &[~str], env: Option<~[(~str, ~str)]>,\n-               cwd: Option<&Path>,\n-               stdin: Option<file::fd_t>,\n-               stdout: Option<file::fd_t>,\n-               stderr: Option<file::fd_t>) -> Process {\n-        let (in_pipe, in_fd) = match stdin {\n-            None => {\n-                let pipe = os::pipe();\n-                (Some(pipe), pipe.input)\n-            },\n-            Some(fd) => (None, fd)\n-        };\n-        let (out_pipe, out_fd) = match stdout {\n-            None => {\n-                let pipe = os::pipe();\n-                (Some(pipe), pipe.out)\n-            },\n-            Some(fd) => (None, fd)\n-        };\n-        let (err_pipe, err_fd) = match stderr {\n-            None => {\n-                let pipe = os::pipe();\n-                (Some(pipe), pipe.out)\n-            },\n-            Some(fd) => (None, fd)\n-        };\n+    pub fn spawn(config: p::ProcessConfig)\n+        -> Result<(Process, ~[Option<file::FileDesc>]), io::IoError>\n+    {\n+        // right now we only handle stdin/stdout/stderr.\n+        if config.io.len() > 3 {\n+            return Err(super::unimpl());\n+        }\n+\n+        fn get_io(io: &[p::StdioContainer],\n+                  ret: &mut ~[Option<file::FileDesc>],\n+                  idx: uint) -> (Option<os::Pipe>, c_int) {\n+            if idx >= io.len() { return (None, -1); }\n+            ret.push(None);\n+            match io[idx] {\n+                p::Ignored => (None, -1),\n+                p::InheritFd(fd) => (None, fd),\n+                p::CreatePipe(readable, _writable) => {\n+                    let pipe = os::pipe();\n+                    let (theirs, ours) = if readable {\n+                        (pipe.input, pipe.out)\n+                    } else {\n+                        (pipe.out, pipe.input)\n+                    };\n+                    ret[idx] = Some(file::FileDesc::new(ours, true));\n+                    (Some(pipe), theirs)\n+                }\n+            }\n+        }\n+\n+        let mut ret_io = ~[];\n+        let (in_pipe, in_fd) = get_io(config.io, &mut ret_io, 0);\n+        let (out_pipe, out_fd) = get_io(config.io, &mut ret_io, 1);\n+        let (err_pipe, err_fd) = get_io(config.io, &mut ret_io, 2);\n \n-        let res = spawn_process_os(prog, args, env, cwd,\n-                                   in_fd, out_fd, err_fd);\n+        let env = config.env.map(|a| a.to_owned());\n+        let cwd = config.cwd.map(|a| Path::new(a));\n+        let res = spawn_process_os(config.program, config.args, env,\n+                                   cwd.as_ref(), in_fd, out_fd, err_fd);\n \n         unsafe {\n             for pipe in in_pipe.iter() { libc::close(pipe.input); }\n             for pipe in out_pipe.iter() { libc::close(pipe.out); }\n             for pipe in err_pipe.iter() { libc::close(pipe.out); }\n         }\n \n-        Process {\n-            pid: res.pid,\n-            handle: res.handle,\n-            input: in_pipe.map(|pipe| file::FileDesc::new(pipe.out, true)),\n-            output: out_pipe.map(|pipe| file::FileDesc::new(pipe.input, true)),\n-            error: err_pipe.map(|pipe| file::FileDesc::new(pipe.input, true)),\n-            exit_code: None,\n-        }\n-    }\n-\n-    /// Returns the unique id of the process\n-    pub fn id(&self) -> pid_t { self.pid }\n-\n-    /**\n-     * Returns an io::Writer that can be used to write to this Process's stdin.\n-     *\n-     * Fails if there is no stdinavailable (it's already been removed by\n-     * take_input)\n-     */\n-    pub fn input<'a>(&'a mut self) -> &'a mut io::Writer {\n-        match self.input {\n-            Some(ref mut fd) => fd as &mut io::Writer,\n-            None => fail!(\"This process has no stdin\")\n-        }\n-    }\n-\n-    /**\n-     * Returns an io::Reader that can be used to read from this Process's\n-     * stdout.\n-     *\n-     * Fails if there is no stdin available (it's already been removed by\n-     * take_output)\n-     */\n-    pub fn output<'a>(&'a mut self) -> &'a mut io::Reader {\n-        match self.input {\n-            Some(ref mut fd) => fd as &mut io::Reader,\n-            None => fail!(\"This process has no stdout\")\n-        }\n-    }\n-\n-    /**\n-     * Returns an io::Reader that can be used to read from this Process's\n-     * stderr.\n-     *\n-     * Fails if there is no stdin available (it's already been removed by\n-     * take_error)\n-     */\n-    pub fn error<'a>(&'a mut self) -> &'a mut io::Reader {\n-        match self.error {\n-            Some(ref mut fd) => fd as &mut io::Reader,\n-            None => fail!(\"This process has no stderr\")\n-        }\n-    }\n-\n-    /**\n-     * Takes the stdin of this process, transferring ownership to the caller.\n-     * Note that when the return value is destroyed, the handle will be closed\n-     * for the child process.\n-     */\n-    pub fn take_input(&mut self) -> Option<~io::Writer> {\n-        self.input.take().map(|fd| ~fd as ~io::Writer)\n-    }\n-\n-    /**\n-     * Takes the stdout of this process, transferring ownership to the caller.\n-     * Note that when the return value is destroyed, the handle will be closed\n-     * for the child process.\n-     */\n-    pub fn take_output(&mut self) -> Option<~io::Reader> {\n-        self.output.take().map(|fd| ~fd as ~io::Reader)\n+        Ok((Process { pid: res.pid, handle: res.handle, exit_code: None }, ret_io))\n     }\n+}\n \n-    /**\n-     * Takes the stderr of this process, transferring ownership to the caller.\n-     * Note that when the return value is destroyed, the handle will be closed\n-     * for the child process.\n-     */\n-    pub fn take_error(&mut self) -> Option<~io::Reader> {\n-        self.error.take().map(|fd| ~fd as ~io::Reader)\n-    }\n+impl rtio::RtioProcess for Process {\n+    fn id(&self) -> pid_t { self.pid }\n \n-    pub fn wait(&mut self) -> int {\n-        for &code in self.exit_code.iter() {\n-            return code;\n-        }\n-        let code = waitpid(self.pid);\n-        self.exit_code = Some(code);\n-        return code;\n+    fn wait(&mut self) -> p::ProcessExit {\n+        let code = match self.exit_code {\n+            Some(code) => code,\n+            None => {\n+                let code = waitpid(self.pid);\n+                self.exit_code = Some(code);\n+                code\n+            }\n+        };\n+        return p::ExitStatus(code); // XXX: this is wrong\n     }\n \n-    pub fn signal(&mut self, signum: int) -> Result<(), io::IoError> {\n+    fn kill(&mut self, signum: int) -> Result<(), io::IoError> {\n         // if the process has finished, and therefore had waitpid called,\n         // and we kill it, then on unix we might ending up killing a\n         // newer process that happens to have the same (re-used) id\n@@ -207,8 +141,7 @@ impl Process {\n         #[cfg(windows)]\n         unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n             match signal {\n-                io::process::PleaseExitSignal |\n-                io::process::MustDieSignal => {\n+                io::process::PleaseExitSignal | io::process::MustDieSignal => {\n                     libc::funcs::extra::kernel32::TerminateProcess(\n                         cast::transmute(pid), 1);\n                     Ok(())\n@@ -231,11 +164,6 @@ impl Process {\n \n impl Drop for Process {\n     fn drop(&mut self) {\n-        // close all these handles\n-        self.take_input();\n-        self.take_output();\n-        self.take_error();\n-        self.wait();\n         free_handle(self.handle);\n     }\n }"}, {"sha": "68748ab49a3ea61e7a8bfa625fb77a000352d629", "filename": "src/libstd/io/native/stdio.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1bfa45cfd9d7c8b2dcc0ea7a42396624e8b5a31b/src%2Flibstd%2Fio%2Fnative%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bfa45cfd9d7c8b2dcc0ea7a42396624e8b5a31b/src%2Flibstd%2Fio%2Fnative%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Fstdio.rs?ref=1bfa45cfd9d7c8b2dcc0ea7a42396624e8b5a31b", "patch": "@@ -1,63 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc;\n-use option::Option;\n-use io::{Reader, Writer};\n-use super::file;\n-\n-/// Creates a new handle to the stdin of this process\n-pub fn stdin() -> StdIn { StdIn::new() }\n-/// Creates a new handle to the stdout of this process\n-pub fn stdout() -> StdOut { StdOut::new(libc::STDOUT_FILENO) }\n-/// Creates a new handle to the stderr of this process\n-pub fn stderr() -> StdOut { StdOut::new(libc::STDERR_FILENO) }\n-\n-pub fn print(s: &str) {\n-    stdout().write(s.as_bytes())\n-}\n-\n-pub fn println(s: &str) {\n-    let mut out = stdout();\n-    out.write(s.as_bytes());\n-    out.write(['\\n' as u8]);\n-}\n-\n-pub struct StdIn {\n-    priv fd: file::FileDesc\n-}\n-\n-impl StdIn {\n-    /// Duplicates the stdin file descriptor, returning an io::Reader\n-    pub fn new() -> StdIn {\n-        StdIn { fd: file::FileDesc::new(libc::STDIN_FILENO, false) }\n-    }\n-}\n-\n-impl Reader for StdIn {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.fd.read(buf) }\n-    fn eof(&mut self) -> bool { self.fd.eof() }\n-}\n-\n-pub struct StdOut {\n-    priv fd: file::FileDesc\n-}\n-\n-impl StdOut {\n-    /// Duplicates the specified file descriptor, returning an io::Writer\n-    pub fn new(fd: file::fd_t) -> StdOut {\n-        StdOut { fd: file::FileDesc::new(fd, false) }\n-    }\n-}\n-\n-impl Writer for StdOut {\n-    fn write(&mut self, buf: &[u8]) { self.fd.write(buf) }\n-    fn flush(&mut self) { self.fd.flush() }\n-}"}, {"sha": "6df9ea6c60a6d6f1ca04e8dd93af3fd6379a7204", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=9bcf557589a385d163c6d543ede82953b09e072f", "patch": "@@ -126,17 +126,23 @@ fn with_task_stdout(f: &fn(&mut Writer)) {\n     use rt::task::Task;\n \n     unsafe {\n-        // Logging may require scheduling operations, so we can't remove the\n-        // task from TLS right now, hence the unsafe borrow. Sad.\n-        let task: *mut Task = Local::unsafe_borrow();\n+        let task: Option<*mut Task> = Local::try_unsafe_borrow();\n+        match task {\n+            Some(task) => {\n+                match (*task).stdout_handle {\n+                    Some(ref mut handle) => f(*handle),\n+                    None => {\n+                        let handle = ~LineBufferedWriter::new(stdout());\n+                        let mut handle = handle as ~Writer;\n+                        f(handle);\n+                        (*task).stdout_handle = Some(handle);\n+                    }\n+                }\n+            }\n \n-        match (*task).stdout_handle {\n-            Some(ref mut handle) => f(*handle),\n             None => {\n-                let handle = stdout();\n-                let mut handle = ~LineBufferedWriter::new(handle) as ~Writer;\n-                f(handle);\n-                (*task).stdout_handle = Some(handle);\n+                let mut io = stdout();\n+                f(&mut io as &mut Writer);\n             }\n         }\n     }"}, {"sha": "42ecbf5dc785640421ee64e94757ae0214206d99", "filename": "src/libstd/rt/basic.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Frt%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Frt%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbasic.rs?ref=9bcf557589a385d163c6d543ede82953b09e072f", "patch": "@@ -18,6 +18,7 @@ use cast;\n use rt::rtio::{EventLoop, IoFactory, RemoteCallback, PausibleIdleCallback,\n                Callback};\n use unstable::sync::Exclusive;\n+use io::native;\n use util;\n \n /// This is the only exported function from this module.\n@@ -30,7 +31,8 @@ struct BasicLoop {\n     idle: Option<*mut BasicPausible>, // only one is allowed\n     remotes: ~[(uint, ~Callback)],\n     next_remote: uint,\n-    messages: Exclusive<~[Message]>\n+    messages: Exclusive<~[Message]>,\n+    io: ~IoFactory,\n }\n \n enum Message { RunRemote(uint), RemoveRemote(uint) }\n@@ -54,6 +56,7 @@ impl BasicLoop {\n             next_remote: 0,\n             remotes: ~[],\n             messages: Exclusive::new(~[]),\n+            io: ~native::IoFactory as ~IoFactory,\n         }\n     }\n \n@@ -167,8 +170,9 @@ impl EventLoop for BasicLoop {\n         ~BasicRemote::new(self.messages.clone(), id) as ~RemoteCallback\n     }\n \n-    /// This has no bindings for local I/O\n-    fn io<'a>(&'a mut self, _: &fn(&'a mut IoFactory)) {}\n+    fn io<'a>(&'a mut self, f: &fn(&'a mut IoFactory)) {\n+        f(self.io)\n+    }\n }\n \n struct BasicRemote {"}, {"sha": "35fb8baa6ce688db8dc9b65ee56c2f9059352ce0", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=9bcf557589a385d163c6d543ede82953b09e072f", "patch": "@@ -78,20 +78,28 @@ pub enum CloseBehavior {\n pub fn with_local_io<T>(f: &fn(&mut IoFactory) -> Option<T>) -> Option<T> {\n     use rt::sched::Scheduler;\n     use rt::local::Local;\n-    use io::{io_error, standard_error, IoUnavailable};\n+    use io::native;\n \n     unsafe {\n-        let sched: *mut Scheduler = Local::unsafe_borrow();\n-        let mut io = None;\n-        (*sched).event_loop.io(|i| io = Some(i));\n-        match io {\n-            Some(io) => f(io),\n-            None => {\n-                io_error::cond.raise(standard_error(IoUnavailable));\n-                None\n+        // First, attempt to use the local scheduler's I/O services\n+        let sched: Option<*mut Scheduler> = Local::try_unsafe_borrow();\n+        match sched {\n+            Some(sched) => {\n+                let mut io = None;\n+                (*sched).event_loop.io(|i| io = Some(i));\n+                match io {\n+                    Some(io) => return f(io),\n+                    None => {}\n+                }\n             }\n+            None => {}\n         }\n     }\n+\n+    // If we don't have a scheduler or the scheduler doesn't have I/O services,\n+    // then fall back to the native I/O services.\n+    let mut io = native::IoFactory;\n+    f(&mut io as &mut IoFactory)\n }\n \n pub trait IoFactory {"}, {"sha": "b5b76f6af66061d616076cab6b4f5bb8a93beda2", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcf557589a385d163c6d543ede82953b09e072f/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=9bcf557589a385d163c6d543ede82953b09e072f", "patch": "@@ -68,25 +68,11 @@ pub fn default_sched_threads() -> uint {\n }\n \n pub fn dumb_println(args: &fmt::Arguments) {\n-    use io::native::stdio::stderr;\n-    use io::{Writer, io_error, ResourceUnavailable};\n-    use rt::task::Task;\n-    use rt::local::Local;\n-\n-    let mut out = stderr();\n-    if Local::exists(None::<Task>) {\n-        let mut again = true;\n-        do io_error::cond.trap(|e| {\n-            again = e.kind == ResourceUnavailable;\n-        }).inside {\n-            while again {\n-                again = false;\n-                fmt::writeln(&mut out as &mut Writer, args);\n-            }\n-        }\n-    } else {\n-        fmt::writeln(&mut out as &mut Writer, args);\n-    }\n+    use io::native::file::FileDesc;\n+    use io;\n+    use libc;\n+    let mut out = FileDesc::new(libc::STDERR_FILENO, false);\n+    fmt::writeln(&mut out as &mut io::Writer, args);\n }\n \n pub fn abort(msg: &str) -> ! {"}, {"sha": "5cc8e161f5ffde0236c80f6973a38e9af7391838", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9bcf557589a385d163c6d543ede82953b09e072f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcf557589a385d163c6d543ede82953b09e072f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=9bcf557589a385d163c6d543ede82953b09e072f", "patch": "@@ -154,7 +154,7 @@ fn make_sequence_processor(sz: uint,\n // given a FASTA file on stdin, process sequence THREE\n fn main() {\n     use std::io::Reader;\n-    use std::io::native::stdio;\n+    use std::io::stdio;\n     use std::io::mem::MemReader;\n     use std::io::buffered::BufferedReader;\n "}, {"sha": "b468b53d2f75e2216091ca504862bb43ff0398bd", "filename": "src/test/run-pass/native-print-no-runtime.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9bcf557589a385d163c6d543ede82953b09e072f/src%2Ftest%2Frun-pass%2Fnative-print-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcf557589a385d163c6d543ede82953b09e072f/src%2Ftest%2Frun-pass%2Fnative-print-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-print-no-runtime.rs?ref=9bcf557589a385d163c6d543ede82953b09e072f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast\n+\n+#[no_uv];\n+\n+#[start]\n+fn main(_: int, _: **u8) -> int {\n+    println!(\"hello\");\n+    0\n+}"}, {"sha": "d3b6d6059849df97227c93cf64188d4ff82ee3ad", "filename": "src/test/run-pass/native-print-no-uv.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9bcf557589a385d163c6d543ede82953b09e072f/src%2Ftest%2Frun-pass%2Fnative-print-no-uv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bcf557589a385d163c6d543ede82953b09e072f/src%2Ftest%2Frun-pass%2Fnative-print-no-uv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-print-no-uv.rs?ref=9bcf557589a385d163c6d543ede82953b09e072f", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast\n+\n+#[no_uv];\n+\n+fn main() {\n+    println!(\"hello\");\n+}"}]}