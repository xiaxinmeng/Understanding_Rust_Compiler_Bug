{"sha": "0e35603069b4f3cee97641204b09d91fd723d01d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMzU2MDMwNjliNGYzY2VlOTc2NDEyMDRiMDlkOTFmZDcyM2QwMWQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-17T05:10:29Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-17T05:10:29Z"}, "message": "Merge #1157\n\n1157: Add mbe stmt matcher r=matklad a=edwin0cheng\n\nAdd `stmt` matcher in `ra_mbe` , and added corresponding `stmt()` parser in `ra_syntax`. \r\nThis PR also help PR #1148 for `MarcoKind::Items` parsing.\r\n\r\nNote: \r\n* According [the book](https://doc.rust-lang.org/reference/macros-by-example.html), mbe `stmt` matcher will only match statement without the trailing semicolon \r\n* `item` is a valid statement.\r\n\r\n\r\n\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "5ce7ba4ec6fbf9ce8a25bfe2877abc78dd4e9f45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ce7ba4ec6fbf9ce8a25bfe2877abc78dd4e9f45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e35603069b4f3cee97641204b09d91fd723d01d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e35603069b4f3cee97641204b09d91fd723d01d", "html_url": "https://github.com/rust-lang/rust/commit/0e35603069b4f3cee97641204b09d91fd723d01d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e35603069b4f3cee97641204b09d91fd723d01d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "546d9be2a7bf7b3942c125f922a01321aea6ad26", "url": "https://api.github.com/repos/rust-lang/rust/commits/546d9be2a7bf7b3942c125f922a01321aea6ad26", "html_url": "https://github.com/rust-lang/rust/commit/546d9be2a7bf7b3942c125f922a01321aea6ad26"}, {"sha": "57e4122b890d56c11f9d74c1bdfed40f186331a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/57e4122b890d56c11f9d74c1bdfed40f186331a4", "html_url": "https://github.com/rust-lang/rust/commit/57e4122b890d56c11f9d74c1bdfed40f186331a4"}], "stats": {"total": 191, "additions": 119, "deletions": 72}, "files": [{"sha": "a1f4389069db659b6cbe0ed36be7e43ad7b1b28c", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0e35603069b4f3cee97641204b09d91fd723d01d/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e35603069b4f3cee97641204b09d91fd723d01d/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=0e35603069b4f3cee97641204b09d91fd723d01d", "patch": "@@ -582,4 +582,19 @@ SOURCE_FILE@[0; 40)\n         );\n         assert_expansion(&rules, \"foo! { (a, b) }\", \"fn foo () {let (a , b) ;}\");\n     }\n+\n+    #[test]\n+    fn test_stmt() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+            ($ i:stmt) => (\n+                fn bar() { $ i; }\n+            )\n+        }\n+\"#,\n+        );\n+        assert_expansion(&rules, \"foo! { 2 }\", \"fn bar () {2 ;}\");\n+        assert_expansion(&rules, \"foo! { let a = 0 }\", \"fn bar () {let a = 0 ;}\");\n+    }\n }"}, {"sha": "7587b575d91bd2da2a8c13801d673d470ad5a795", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e35603069b4f3cee97641204b09d91fd723d01d/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e35603069b4f3cee97641204b09d91fd723d01d/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=0e35603069b4f3cee97641204b09d91fd723d01d", "patch": "@@ -157,6 +157,10 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                             let pat = input.eat_pat().ok_or(ExpandError::UnexpectedToken)?.clone();\n                             res.inner.insert(text.clone(), Binding::Simple(pat.into()));\n                         }\n+                        \"stmt\" => {\n+                            let pat = input.eat_stmt().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                            res.inner.insert(text.clone(), Binding::Simple(pat.into()));\n+                        }\n                         _ => return Err(ExpandError::UnexpectedToken),\n                     }\n                 }"}, {"sha": "f075ce24565587358a8a603a28bec86f4f222aba", "filename": "crates/ra_mbe/src/subtree_parser.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e35603069b4f3cee97641204b09d91fd723d01d/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e35603069b4f3cee97641204b09d91fd723d01d/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs?ref=0e35603069b4f3cee97641204b09d91fd723d01d", "patch": "@@ -42,6 +42,10 @@ impl<'a> Parser<'a> {\n         self.parse(ra_parser::parse_pat)\n     }\n \n+    pub fn parse_stmt(self) -> Option<tt::TokenTree> {\n+        self.parse(|src, sink| ra_parser::parse_stmt(src, sink, false))\n+    }\n+\n     fn parse<F>(self, f: F) -> Option<tt::TokenTree>\n     where\n         F: FnOnce(&dyn TokenSource, &mut dyn TreeSink),"}, {"sha": "adfe5520d11275b3126879bff89ca67e86843773", "filename": "crates/ra_mbe/src/tt_cursor.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e35603069b4f3cee97641204b09d91fd723d01d/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e35603069b4f3cee97641204b09d91fd723d01d/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs?ref=0e35603069b4f3cee97641204b09d91fd723d01d", "patch": "@@ -99,6 +99,11 @@ impl<'a> TtCursor<'a> {\n         parser.parse_pat()\n     }\n \n+    pub(crate) fn eat_stmt(&mut self) -> Option<tt::TokenTree> {\n+        let parser = Parser::new(&mut self.pos, self.subtree);\n+        parser.parse_stmt()\n+    }\n+\n     pub(crate) fn expect_char(&mut self, char: char) -> Result<(), ParseError> {\n         if self.at_char(char) {\n             self.bump();"}, {"sha": "2c2f785d0f42777d5cfca673a5ebaa9a10a1a615", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e35603069b4f3cee97641204b09d91fd723d01d/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e35603069b4f3cee97641204b09d91fd723d01d/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=0e35603069b4f3cee97641204b09d91fd723d01d", "patch": "@@ -65,6 +65,10 @@ pub(crate) fn pattern(p: &mut Parser) {\n     patterns::pattern(p)\n }\n \n+pub(crate) fn stmt(p: &mut Parser, with_semi: bool) {\n+    expressions::stmt(p, with_semi)\n+}\n+\n pub(crate) fn reparser(\n     node: SyntaxKind,\n     first_child: Option<SyntaxKind>,"}, {"sha": "06f2b45b151f643b813b5fc712aeeefa1980505c", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 82, "deletions": 72, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/0e35603069b4f3cee97641204b09d91fd723d01d/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e35603069b4f3cee97641204b09d91fd723d01d/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=0e35603069b4f3cee97641204b09d91fd723d01d", "patch": "@@ -48,88 +48,77 @@ fn is_expr_stmt_attr_allowed(kind: SyntaxKind) -> bool {\n     }\n }\n \n-pub(crate) fn expr_block_contents(p: &mut Parser) {\n-    // This is checked by a validator\n-    attributes::inner_attributes(p);\n-\n-    while !p.at(EOF) && !p.at(R_CURLY) {\n-        // test nocontentexpr\n-        // fn foo(){\n-        //     ;;;some_expr();;;;{;;;};;;;Ok(())\n-        // }\n-        if p.current() == SEMI {\n-            p.bump();\n-            continue;\n-        }\n+pub(super) fn stmt(p: &mut Parser, with_semi: bool) {\n+    // test block_items\n+    // fn a() { fn b() {} }\n+    let m = p.start();\n+    // test attr_on_expr_stmt\n+    // fn foo() {\n+    //     #[A] foo();\n+    //     #[B] bar!{}\n+    //     #[C] #[D] {}\n+    //     #[D] return ();\n+    // }\n+    let has_attrs = p.at(POUND);\n+    attributes::outer_attributes(p);\n \n-        // test block_items\n-        // fn a() { fn b() {} }\n-        let m = p.start();\n-        // test attr_on_expr_stmt\n-        // fn foo() {\n-        //     #[A] foo();\n-        //     #[B] bar!{}\n-        //     #[C] #[D] {}\n-        //     #[D] return ();\n-        // }\n-        let has_attrs = p.at(POUND);\n-        attributes::outer_attributes(p);\n-        if p.at(LET_KW) {\n-            let_stmt(p, m);\n-            continue;\n-        }\n+    if p.at(LET_KW) {\n+        let_stmt(p, m, with_semi);\n+        return;\n+    }\n \n-        let m = match items::maybe_item(p, m, items::ItemFlavor::Mod) {\n-            Ok(()) => continue,\n-            Err(m) => m,\n-        };\n+    let m = match items::maybe_item(p, m, items::ItemFlavor::Mod) {\n+        Ok(()) => return,\n+        Err(m) => m,\n+    };\n \n-        let (cm, blocklike) = expr_stmt(p);\n-        let kind = cm.as_ref().map(|cm| cm.kind()).unwrap_or(ERROR);\n+    let (cm, blocklike) = expr_stmt(p);\n+    let kind = cm.as_ref().map(|cm| cm.kind()).unwrap_or(ERROR);\n \n-        if has_attrs && !is_expr_stmt_attr_allowed(kind) {\n-            // test_err attr_on_expr_not_allowed\n-            // fn foo() {\n-            //    #[A] 1 + 2;\n-            //    #[B] if true {};\n-            // }\n-            p.error(format!(\"attributes are not allowed on {:?}\", kind));\n-        }\n+    if has_attrs && !is_expr_stmt_attr_allowed(kind) {\n+        // test_err attr_on_expr_not_allowed\n+        // fn foo() {\n+        //    #[A] 1 + 2;\n+        //    #[B] if true {};\n+        // }\n+        p.error(format!(\"attributes are not allowed on {:?}\", kind));\n+    }\n \n-        if p.at(R_CURLY) {\n-            // test attr_on_last_expr_in_block\n-            // fn foo() {\n-            //     { #[A] bar!()? }\n-            //     #[B] &()\n-            // }\n-            if let Some(cm) = cm {\n-                cm.undo_completion(p).abandon(p);\n-                m.complete(p, kind);\n-            } else {\n-                m.abandon(p);\n-            }\n+    if p.at(R_CURLY) {\n+        // test attr_on_last_expr_in_block\n+        // fn foo() {\n+        //     { #[A] bar!()? }\n+        //     #[B] &()\n+        // }\n+        if let Some(cm) = cm {\n+            cm.undo_completion(p).abandon(p);\n+            m.complete(p, kind);\n         } else {\n-            // test no_semi_after_block\n-            // fn foo() {\n-            //     if true {}\n-            //     loop {}\n-            //     match () {}\n-            //     while true {}\n-            //     for _ in () {}\n-            //     {}\n-            //     {}\n-            //     macro_rules! test {\n-            //          () => {}\n-            //     }\n-            //     test!{}\n-            // }\n+            m.abandon(p);\n+        }\n+    } else {\n+        // test no_semi_after_block\n+        // fn foo() {\n+        //     if true {}\n+        //     loop {}\n+        //     match () {}\n+        //     while true {}\n+        //     for _ in () {}\n+        //     {}\n+        //     {}\n+        //     macro_rules! test {\n+        //          () => {}\n+        //     }\n+        //     test!{}\n+        // }\n+        if with_semi {\n             if blocklike.is_block() {\n                 p.eat(SEMI);\n             } else {\n                 p.expect(SEMI);\n             }\n-            m.complete(p, EXPR_STMT);\n         }\n+        m.complete(p, EXPR_STMT);\n     }\n \n     // test let_stmt;\n@@ -139,7 +128,7 @@ pub(crate) fn expr_block_contents(p: &mut Parser) {\n     //     let c = 92;\n     //     let d: i32 = 92;\n     // }\n-    fn let_stmt(p: &mut Parser, m: Marker) {\n+    fn let_stmt(p: &mut Parser, m: Marker, with_semi: bool) {\n         assert!(p.at(LET_KW));\n         p.bump();\n         patterns::pattern(p);\n@@ -149,11 +138,32 @@ pub(crate) fn expr_block_contents(p: &mut Parser) {\n         if p.eat(EQ) {\n             expressions::expr(p);\n         }\n-        p.expect(SEMI);\n+\n+        if with_semi {\n+            p.expect(SEMI);\n+        }\n         m.complete(p, LET_STMT);\n     }\n }\n \n+pub(crate) fn expr_block_contents(p: &mut Parser) {\n+    // This is checked by a validator\n+    attributes::inner_attributes(p);\n+\n+    while !p.at(EOF) && !p.at(R_CURLY) {\n+        // test nocontentexpr\n+        // fn foo(){\n+        //     ;;;some_expr();;;;{;;;};;;;Ok(())\n+        // }\n+        if p.current() == SEMI {\n+            p.bump();\n+            continue;\n+        }\n+\n+        stmt(p, true)\n+    }\n+}\n+\n #[derive(Clone, Copy)]\n struct Restrictions {\n     forbid_structs: bool,"}, {"sha": "9133c1b8ae08878d9255703f066dbcee1a91bdb3", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e35603069b4f3cee97641204b09d91fd723d01d/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e35603069b4f3cee97641204b09d91fd723d01d/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=0e35603069b4f3cee97641204b09d91fd723d01d", "patch": "@@ -88,6 +88,11 @@ pub fn parse_pat(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n     parse_from_tokens(token_source, tree_sink, grammar::pattern);\n }\n \n+/// Parse given tokens into the given sink as a statement\n+pub fn parse_stmt(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink, with_semi: bool) {\n+    parse_from_tokens(token_source, tree_sink, |p| grammar::stmt(p, with_semi));\n+}\n+\n /// A parsing function for a specific braced-block.\n pub struct Reparser(fn(&mut parser::Parser));\n "}]}