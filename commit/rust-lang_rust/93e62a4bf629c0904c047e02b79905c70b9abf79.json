{"sha": "93e62a4bf629c0904c047e02b79905c70b9abf79", "node_id": "C_kwDOAAsO6NoAKDkzZTYyYTRiZjYyOWMwOTA0YzA0N2UwMmI3OTkwNWM3MGI5YWJmNzk", "commit": {"author": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2022-12-27T11:11:13Z"}, "committer": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2023-01-02T01:14:18Z"}, "message": "resolve merge conflict", "tree": {"sha": "765c43fd76c5682871388de286689b7fbf09ccf6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/765c43fd76c5682871388de286689b7fbf09ccf6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93e62a4bf629c0904c047e02b79905c70b9abf79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93e62a4bf629c0904c047e02b79905c70b9abf79", "html_url": "https://github.com/rust-lang/rust/commit/93e62a4bf629c0904c047e02b79905c70b9abf79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93e62a4bf629c0904c047e02b79905c70b9abf79/comments", "author": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74cdf933078d9a936ab5103b6c29148d61fe4b16", "url": "https://api.github.com/repos/rust-lang/rust/commits/74cdf933078d9a936ab5103b6c29148d61fe4b16", "html_url": "https://github.com/rust-lang/rust/commit/74cdf933078d9a936ab5103b6c29148d61fe4b16"}], "stats": {"total": 104, "additions": 60, "deletions": 44}, "files": [{"sha": "71c3803e64fa24772785e7fac4e036e186ca20f0", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 60, "deletions": 44, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/93e62a4bf629c0904c047e02b79905c70b9abf79/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93e62a4bf629c0904c047e02b79905c70b9abf79/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=93e62a4bf629c0904c047e02b79905c70b9abf79", "patch": "@@ -221,7 +221,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mode = no_match_data.mode;\n         let tcx = self.tcx;\n         let rcvr_ty = self.resolve_vars_if_possible(rcvr_ty);\n-        let ty_str = self.ty_to_string(rcvr_ty);\n+        let ty_str = with_forced_trimmed_paths!(self.ty_to_string(rcvr_ty));\n         let is_method = mode == Mode::MethodCall;\n         let unsatisfied_predicates = &no_match_data.unsatisfied_predicates;\n         let lev_candidate = no_match_data.lev_candidate;\n@@ -523,7 +523,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let term = pred.skip_binder().term;\n \n                         let obligation = format!(\"{} = {}\", projection_ty, term);\n-                        let quiet = format!(\"{} = {}\", quiet_projection_ty, term);\n+                        let quiet = with_forced_trimmed_paths!(format!(\n+                            \"{} = {}\",\n+                            quiet_projection_ty, term\n+                        ));\n \n                         bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n                         Some((obligation, projection_ty.self_ty()))\n@@ -533,7 +536,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let self_ty = p.self_ty();\n                         let path = p.print_only_trait_path();\n                         let obligation = format!(\"{}: {}\", self_ty, path);\n-                        let quiet = format!(\"_: {}\", path);\n+                        let quiet = with_forced_trimmed_paths!(format!(\"_: {}\", path));\n                         bound_span_label(self_ty, &obligation, &quiet);\n                         Some((obligation, self_ty))\n                     }\n@@ -636,6 +639,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let entry = spanned_predicates.entry(spans);\n                         entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n                     }\n+                    Some(Node::Item(hir::Item {\n+                        kind: hir::ItemKind::Trait(rustc_ast::ast::IsAuto::Yes, ..),\n+                        span: item_span,\n+                        ..\n+                    })) => {\n+                        tcx.sess.delay_span_bug(\n+                            *item_span,\n+                            \"auto trait is invoked with no method error, but no error reported?\",\n+                        );\n+                    }\n                     Some(_) => unreachable!(),\n                     None => (),\n                 }\n@@ -731,9 +744,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 } else {\n                     (None, None)\n                 };\n-                let primary_message = primary_message.unwrap_or_else(|| format!(\n-                    \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, but its trait bounds were not satisfied\"\n-                ));\n+                let primary_message = primary_message.unwrap_or_else(|| {\n+                    format!(\n+                        \"the {item_kind} `{item_name}` exists for {actual_prefix} `{ty_str}`, \\\n+                    but its trait bounds were not satisfied\"\n+                    )\n+                });\n                 err.set_primary_message(&primary_message);\n                 if let Some(label) = label {\n                     custom_span_label = true;\n@@ -826,11 +842,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             } else {\n+                let ty_str =\n+                    if ty_str.len() > 50 { String::new() } else { format!(\"on `{ty_str}` \") };\n                 err.span_label(\n                     span,\n-                    format!(\n-                        \"{item_kind} cannot be called on `{ty_str}` due to unsatisfied trait bounds\"\n-                    ),\n+                    format!(\"{item_kind} cannot be called {ty_str}due to unsatisfied trait bounds\"),\n                 );\n             }\n         };\n@@ -922,7 +938,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if def_kind == DefKind::AssocFn && lev_candidate.fn_has_self_parameter {\n                     err.span_suggestion(\n                         span,\n-                        &format!(\"there is a method with a similar name\",),\n+                        \"there is a method with a similar name\",\n                         lev_candidate.name,\n                         Applicability::MaybeIncorrect,\n                     );\n@@ -966,11 +982,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // Provide the best span we can. Use the item, if local to crate, else\n                     // the impl, if local to crate (item may be defaulted), else nothing.\n                     let Some(item) = self.associated_value(impl_did, item_name).or_else(|| {\n-                            let impl_trait_ref = self.tcx.impl_trait_ref(impl_did)?;\n-                            self.associated_value(impl_trait_ref.def_id, item_name)\n-                        }) else {\n-                            continue;\n-                        };\n+                        let impl_trait_ref = self.tcx.impl_trait_ref(impl_did)?;\n+                        self.associated_value(impl_trait_ref.def_id, item_name)\n+                    }) else {\n+                        continue;\n+                    };\n \n                     let note_span = if item.def_id.is_local() {\n                         Some(self.tcx.def_span(item.def_id))\n@@ -1015,35 +1031,35 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         err.note(&note_str);\n                     }\n                     if let Some(sugg_span) = sugg_span\n-                            && let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n-                            let path = self.tcx.def_path_str(trait_ref.def_id);\n-\n-                            let ty = match item.kind {\n-                                ty::AssocKind::Const | ty::AssocKind::Type => rcvr_ty,\n-                                ty::AssocKind::Fn => self\n-                                    .tcx\n-                                    .fn_sig(item.def_id)\n-                                    .inputs()\n-                                    .skip_binder()\n-                                    .get(0)\n-                                    .filter(|ty| ty.is_region_ptr() && !rcvr_ty.is_region_ptr())\n-                                    .copied()\n-                                    .unwrap_or(rcvr_ty),\n-                            };\n-                            print_disambiguation_help(\n-                                item_name,\n-                                args,\n-                                err,\n-                                path,\n-                                ty,\n-                                item.kind,\n-                                item.def_id,\n-                                sugg_span,\n-                                idx,\n-                                self.tcx.sess.source_map(),\n-                                item.fn_has_self_parameter,\n-                            );\n-                        }\n+                        && let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n+                        let path = self.tcx.def_path_str(trait_ref.def_id);\n+\n+                        let ty = match item.kind {\n+                            ty::AssocKind::Const | ty::AssocKind::Type => rcvr_ty,\n+                            ty::AssocKind::Fn => self\n+                                .tcx\n+                                .fn_sig(item.def_id)\n+                                .inputs()\n+                                .skip_binder()\n+                                .get(0)\n+                                .filter(|ty| ty.is_region_ptr() && !rcvr_ty.is_region_ptr())\n+                                .copied()\n+                                .unwrap_or(rcvr_ty),\n+                        };\n+                        print_disambiguation_help(\n+                            item_name,\n+                            args,\n+                            err,\n+                            path,\n+                            ty,\n+                            item.kind,\n+                            item.def_id,\n+                            sugg_span,\n+                            idx,\n+                            self.tcx.sess.source_map(),\n+                            item.fn_has_self_parameter,\n+                        );\n+                    }\n                 }\n                 CandidateSource::Trait(trait_did) => {\n                     let Some(item) = self.associated_value(trait_did, item_name) else { continue };"}]}