{"sha": "0e82dc969f714e19278178d199d67b54fb9c0e8e", "node_id": "C_kwDOAAsO6NoAKDBlODJkYzk2OWY3MTRlMTkyNzgxNzhkMTk5ZDY3YjU0ZmI5YzBlOGU", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-09-02T09:34:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-02T09:34:46Z"}, "message": "Rollup merge of #99583 - shepmaster:provider-plus-plus, r=yaahc\n\nAdd additional methods to the Demand type\n\nThis adds on to the original tracking issue #96024\n\nr? `````@yaahc`````", "tree": {"sha": "545c37fda79cb3f5675fd0c1911bb0f93cafd471", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/545c37fda79cb3f5675fd0c1911bb0f93cafd471"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e82dc969f714e19278178d199d67b54fb9c0e8e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjEc42CRBK7hj4Ov3rIwAAwhoIADDLgA0nxVL9kCKsDZ8KkiF9\nyRN1Tiw3KblQQ67J8xnVCf0Wa/hEjeC/uUL2Jp2nBZDtXXd3luQxt5XguTiRr/qu\nmmhAmOPHHjIDOH+XjQLMWhbm37+TQsuRZzdf2tLoiNHkaFBrCG/O2HZcRkeCygx8\nNEfln8FrXh9+UfYD0o8SGfZCOjE6wJ1SGmARIIVWlz2LFjh4maYFDrLMSjgsYDwc\nhkJS/uRWDOhlObcLFaPLMNNvHtUdaaQ//e2ucBMZP7d9mQ+s4h80bYK2I+f/kx/T\nsODvFfIRd6aH7uYJAqrYnCmvIezro9PTLW+o7g2MzkqUwTCspYmfx3ywRiD4RSg=\n=poEz\n-----END PGP SIGNATURE-----\n", "payload": "tree 545c37fda79cb3f5675fd0c1911bb0f93cafd471\nparent 07f43a1ca179c624996b1095a314566733d2e017\nparent 260ec9347838714ad9fa4f7e083bdc0448f4f9be\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1662111286 +0200\ncommitter GitHub <noreply@github.com> 1662111286 +0200\n\nRollup merge of #99583 - shepmaster:provider-plus-plus, r=yaahc\n\nAdd additional methods to the Demand type\n\nThis adds on to the original tracking issue #96024\n\nr? `````@yaahc`````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e82dc969f714e19278178d199d67b54fb9c0e8e", "html_url": "https://github.com/rust-lang/rust/commit/0e82dc969f714e19278178d199d67b54fb9c0e8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e82dc969f714e19278178d199d67b54fb9c0e8e/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07f43a1ca179c624996b1095a314566733d2e017", "url": "https://api.github.com/repos/rust-lang/rust/commits/07f43a1ca179c624996b1095a314566733d2e017", "html_url": "https://github.com/rust-lang/rust/commit/07f43a1ca179c624996b1095a314566733d2e017"}, {"sha": "260ec9347838714ad9fa4f7e083bdc0448f4f9be", "url": "https://api.github.com/repos/rust-lang/rust/commits/260ec9347838714ad9fa4f7e083bdc0448f4f9be", "html_url": "https://github.com/rust-lang/rust/commit/260ec9347838714ad9fa4f7e083bdc0448f4f9be"}], "stats": {"total": 241, "additions": 234, "deletions": 7}, "files": [{"sha": "1a379ecc11c01d7ae8cdfde75d8a591425eaa2ca", "filename": "library/core/src/any.rs", "status": "modified", "additions": 233, "deletions": 6, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/0e82dc969f714e19278178d199d67b54fb9c0e8e/library%2Fcore%2Fsrc%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e82dc969f714e19278178d199d67b54fb9c0e8e/library%2Fcore%2Fsrc%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fany.rs?ref=0e82dc969f714e19278178d199d67b54fb9c0e8e", "patch": "@@ -796,7 +796,7 @@ pub trait Provider {\n     /// impl Provider for SomeConcreteType {\n     ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n     ///         demand.provide_ref::<str>(&self.field)\n-    ///             .provide_value::<i32>(|| self.num_field);\n+    ///             .provide_value::<i32>(self.num_field);\n     ///     }\n     /// }\n     /// ```\n@@ -881,36 +881,64 @@ impl<'a> Demand<'a> {\n     ///\n     /// # Examples\n     ///\n+    /// Provides an `u8`.\n+    ///\n+    /// ```rust\n+    /// #![feature(provide_any)]\n+    ///\n+    /// use std::any::{Provider, Demand};\n+    /// # struct SomeConcreteType { field: u8 }\n+    ///\n+    /// impl Provider for SomeConcreteType {\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         demand.provide_value::<u8>(self.field);\n+    ///     }\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"provide_any\", issue = \"96024\")]\n+    pub fn provide_value<T>(&mut self, value: T) -> &mut Self\n+    where\n+        T: 'static,\n+    {\n+        self.provide::<tags::Value<T>>(value)\n+    }\n+\n+    /// Provide a value or other type with only static lifetimes computed using a closure.\n+    ///\n+    /// # Examples\n+    ///\n     /// Provides a `String` by cloning.\n     ///\n     /// ```rust\n-    /// # #![feature(provide_any)]\n+    /// #![feature(provide_any)]\n+    ///\n     /// use std::any::{Provider, Demand};\n     /// # struct SomeConcreteType { field: String }\n     ///\n     /// impl Provider for SomeConcreteType {\n     ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n-    ///         demand.provide_value::<String>(|| self.field.clone());\n+    ///         demand.provide_value_with::<String>(|| self.field.clone());\n     ///     }\n     /// }\n     /// ```\n     #[unstable(feature = \"provide_any\", issue = \"96024\")]\n-    pub fn provide_value<T>(&mut self, fulfil: impl FnOnce() -> T) -> &mut Self\n+    pub fn provide_value_with<T>(&mut self, fulfil: impl FnOnce() -> T) -> &mut Self\n     where\n         T: 'static,\n     {\n         self.provide_with::<tags::Value<T>>(fulfil)\n     }\n \n-    /// Provide a reference, note that the referee type must be bounded by `'static`,\n+    /// Provide a reference. The referee type must be bounded by `'static`,\n     /// but may be unsized.\n     ///\n     /// # Examples\n     ///\n     /// Provides a reference to a field as a `&str`.\n     ///\n     /// ```rust\n-    /// # #![feature(provide_any)]\n+    /// #![feature(provide_any)]\n+    ///\n     /// use std::any::{Provider, Demand};\n     /// # struct SomeConcreteType { field: String }\n     ///\n@@ -925,6 +953,40 @@ impl<'a> Demand<'a> {\n         self.provide::<tags::Ref<tags::MaybeSizedValue<T>>>(value)\n     }\n \n+    /// Provide a reference computed using a closure. The referee type\n+    /// must be bounded by `'static`, but may be unsized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Provides a reference to a field as a `&str`.\n+    ///\n+    /// ```rust\n+    /// #![feature(provide_any)]\n+    ///\n+    /// use std::any::{Provider, Demand};\n+    /// # struct SomeConcreteType { business: String, party: String }\n+    /// # fn today_is_a_weekday() -> bool { true }\n+    ///\n+    /// impl Provider for SomeConcreteType {\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         demand.provide_ref_with::<str>(|| {\n+    ///             if today_is_a_weekday() {\n+    ///                 &self.business\n+    ///             } else {\n+    ///                 &self.party\n+    ///             }\n+    ///         });\n+    ///     }\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"provide_any\", issue = \"96024\")]\n+    pub fn provide_ref_with<T: ?Sized + 'static>(\n+        &mut self,\n+        fulfil: impl FnOnce() -> &'a T,\n+    ) -> &mut Self {\n+        self.provide_with::<tags::Ref<tags::MaybeSizedValue<T>>>(fulfil)\n+    }\n+\n     /// Provide a value with the given `Type` tag.\n     fn provide<I>(&mut self, value: I::Reified) -> &mut Self\n     where\n@@ -946,6 +1008,156 @@ impl<'a> Demand<'a> {\n         }\n         self\n     }\n+\n+    /// Check if the `Demand` would be satisfied if provided with a\n+    /// value of the specified type. If the type does not match or has\n+    /// already been provided, returns false.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Check if an `u8` still needs to be provided and then provides\n+    /// it.\n+    ///\n+    /// ```rust\n+    /// #![feature(provide_any)]\n+    ///\n+    /// use std::any::{Provider, Demand};\n+    ///\n+    /// struct Parent(Option<u8>);\n+    ///\n+    /// impl Provider for Parent {\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         if let Some(v) = self.0 {\n+    ///             demand.provide_value::<u8>(v);\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// struct Child {\n+    ///     parent: Parent,\n+    /// }\n+    ///\n+    /// impl Child {\n+    ///     // Pretend that this takes a lot of resources to evaluate.\n+    ///     fn an_expensive_computation(&self) -> Option<u8> {\n+    ///         Some(99)\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Provider for Child {\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         // In general, we don't know if this call will provide\n+    ///         // an `u8` value or not...\n+    ///         self.parent.provide(demand);\n+    ///\n+    ///         // ...so we check to see if the `u8` is needed before\n+    ///         // we run our expensive computation.\n+    ///         if demand.would_be_satisfied_by_value_of::<u8>() {\n+    ///             if let Some(v) = self.an_expensive_computation() {\n+    ///                 demand.provide_value::<u8>(v);\n+    ///             }\n+    ///         }\n+    ///\n+    ///         // The demand will be satisfied now, regardless of if\n+    ///         // the parent provided the value or we did.\n+    ///         assert!(!demand.would_be_satisfied_by_value_of::<u8>());\n+    ///     }\n+    /// }\n+    ///\n+    /// let parent = Parent(Some(42));\n+    /// let child = Child { parent };\n+    /// assert_eq!(Some(42), std::any::request_value::<u8>(&child));\n+    ///\n+    /// let parent = Parent(None);\n+    /// let child = Child { parent };\n+    /// assert_eq!(Some(99), std::any::request_value::<u8>(&child));\n+    /// ```\n+    #[unstable(feature = \"provide_any\", issue = \"96024\")]\n+    pub fn would_be_satisfied_by_value_of<T>(&self) -> bool\n+    where\n+        T: 'static,\n+    {\n+        self.would_be_satisfied_by::<tags::Value<T>>()\n+    }\n+\n+    /// Check if the `Demand` would be satisfied if provided with a\n+    /// reference to a value of the specified type. If the type does\n+    /// not match or has already been provided, returns false.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Check if a `&str` still needs to be provided and then provides\n+    /// it.\n+    ///\n+    /// ```rust\n+    /// #![feature(provide_any)]\n+    ///\n+    /// use std::any::{Provider, Demand};\n+    ///\n+    /// struct Parent(Option<String>);\n+    ///\n+    /// impl Provider for Parent {\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         if let Some(v) = &self.0 {\n+    ///             demand.provide_ref::<str>(v);\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// struct Child {\n+    ///     parent: Parent,\n+    ///     name: String,\n+    /// }\n+    ///\n+    /// impl Child {\n+    ///     // Pretend that this takes a lot of resources to evaluate.\n+    ///     fn an_expensive_computation(&self) -> Option<&str> {\n+    ///         Some(&self.name)\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Provider for Child {\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         // In general, we don't know if this call will provide\n+    ///         // a `str` reference or not...\n+    ///         self.parent.provide(demand);\n+    ///\n+    ///         // ...so we check to see if the `&str` is needed before\n+    ///         // we run our expensive computation.\n+    ///         if demand.would_be_satisfied_by_ref_of::<str>() {\n+    ///             if let Some(v) = self.an_expensive_computation() {\n+    ///                 demand.provide_ref::<str>(v);\n+    ///             }\n+    ///         }\n+    ///\n+    ///         // The demand will be satisfied now, regardless of if\n+    ///         // the parent provided the reference or we did.\n+    ///         assert!(!demand.would_be_satisfied_by_ref_of::<str>());\n+    ///     }\n+    /// }\n+    ///\n+    /// let parent = Parent(Some(\"parent\".into()));\n+    /// let child = Child { parent, name: \"child\".into() };\n+    /// assert_eq!(Some(\"parent\"), std::any::request_ref::<str>(&child));\n+    ///\n+    /// let parent = Parent(None);\n+    /// let child = Child { parent, name: \"child\".into() };\n+    /// assert_eq!(Some(\"child\"), std::any::request_ref::<str>(&child));\n+    /// ```\n+    #[unstable(feature = \"provide_any\", issue = \"96024\")]\n+    pub fn would_be_satisfied_by_ref_of<T>(&self) -> bool\n+    where\n+        T: ?Sized + 'static,\n+    {\n+        self.would_be_satisfied_by::<tags::Ref<tags::MaybeSizedValue<T>>>()\n+    }\n+\n+    fn would_be_satisfied_by<I>(&self) -> bool\n+    where\n+        I: tags::Type<'a>,\n+    {\n+        matches!(self.0.downcast::<I>(), Some(TaggedOption(None)))\n+    }\n }\n \n #[unstable(feature = \"provide_any\", issue = \"96024\")]\n@@ -1050,6 +1262,21 @@ impl<'a> dyn Erased<'a> + 'a {\n     /// Returns some reference to the dynamic value if it is tagged with `I`,\n     /// or `None` otherwise.\n     #[inline]\n+    fn downcast<I>(&self) -> Option<&TaggedOption<'a, I>>\n+    where\n+        I: tags::Type<'a>,\n+    {\n+        if self.tag_id() == TypeId::of::<I>() {\n+            // SAFETY: Just checked whether we're pointing to an I.\n+            Some(unsafe { &*(self as *const Self).cast::<TaggedOption<'a, I>>() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns some mutable reference to the dynamic value if it is tagged with `I`,\n+    /// or `None` otherwise.\n+    #[inline]\n     fn downcast_mut<I>(&mut self) -> Option<&mut TaggedOption<'a, I>>\n     where\n         I: tags::Type<'a>,"}, {"sha": "9538b81394957be74e188531cb1d9e9b9f4fa9ad", "filename": "library/core/tests/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e82dc969f714e19278178d199d67b54fb9c0e8e/library%2Fcore%2Ftests%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e82dc969f714e19278178d199d67b54fb9c0e8e/library%2Fcore%2Ftests%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fany.rs?ref=0e82dc969f714e19278178d199d67b54fb9c0e8e", "patch": "@@ -142,7 +142,7 @@ impl Provider for SomeConcreteType {\n         demand\n             .provide_ref::<String>(&self.some_string)\n             .provide_ref::<str>(&self.some_string)\n-            .provide_value::<String>(|| \"bye\".to_owned());\n+            .provide_value_with::<String>(|| \"bye\".to_owned());\n     }\n }\n "}]}