{"sha": "9583fd1bdd0127328e25e5b8c24dff575ec2c86b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ODNmZDFiZGQwMTI3MzI4ZTI1ZTViOGMyNGRmZjU3NWVjMmM4NmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-23T17:27:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-23T17:27:23Z"}, "message": "Auto merge of #87676 - sexxi-goose:truncate_unique, r=nikomatsakis\n\n2229: Handle MutBorrow/UniqueImmBorrow better\n\nWe only want to use UniqueImmBorrow when the capture place is truncated and we\ndrop Deref of a MutRef.\n\nr? `@nikomatsakis`\n\nFixes: https://github.com/rust-lang/project-rfc-2229/issues/56", "tree": {"sha": "c72f8264ce319cfd16e5f0ea82a463b3d5eb004d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c72f8264ce319cfd16e5f0ea82a463b3d5eb004d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9583fd1bdd0127328e25e5b8c24dff575ec2c86b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9583fd1bdd0127328e25e5b8c24dff575ec2c86b", "html_url": "https://github.com/rust-lang/rust/commit/9583fd1bdd0127328e25e5b8c24dff575ec2c86b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9583fd1bdd0127328e25e5b8c24dff575ec2c86b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52c881ff5240bf0f09557a3c100f40704b5db836", "url": "https://api.github.com/repos/rust-lang/rust/commits/52c881ff5240bf0f09557a3c100f40704b5db836", "html_url": "https://github.com/rust-lang/rust/commit/52c881ff5240bf0f09557a3c100f40704b5db836"}, {"sha": "8e899717813c891d3644102865c6bcfa99291f3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e899717813c891d3644102865c6bcfa99291f3f", "html_url": "https://github.com/rust-lang/rust/commit/8e899717813c891d3644102865c6bcfa99291f3f"}], "stats": {"total": 242, "additions": 166, "deletions": 76}, "files": [{"sha": "34176623ebc452364de1e9fdf82db9587f130d6c", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 150, "deletions": 60, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/9583fd1bdd0127328e25e5b8c24dff575ec2c86b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9583fd1bdd0127328e25e5b8c24dff575ec2c86b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=9583fd1bdd0127328e25e5b8c24dff575ec2c86b", "patch": "@@ -350,9 +350,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         for (place, mut capture_info) in capture_information {\n             // Apply rules for safety before inferring closure kind\n-            let place = restrict_capture_precision(place);\n+            let (place, capture_kind) =\n+                restrict_capture_precision(place, capture_info.capture_kind);\n+            capture_info.capture_kind = capture_kind;\n \n-            let place = truncate_capture_for_optimization(&place);\n+            let (place, capture_kind) =\n+                truncate_capture_for_optimization(place, capture_info.capture_kind);\n+            capture_info.capture_kind = capture_kind;\n \n             let usage_span = if let Some(usage_expr) = capture_info.path_expr_id {\n                 self.tcx.hir().span(usage_expr)\n@@ -520,8 +524,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // current place is ancestor of possible_descendant\n                     PlaceAncestryRelation::Ancestor => {\n                         descendant_found = true;\n+\n+                        let mut possible_descendant = possible_descendant.clone();\n                         let backup_path_expr_id = updated_capture_info.path_expr_id;\n \n+                        // Truncate the descendant (already in min_captures) to be same as the ancestor to handle any\n+                        // possible change in capture mode.\n+                        let (_, descendant_capture_kind) = truncate_place_to_len(\n+                            possible_descendant.place,\n+                            possible_descendant.info.capture_kind,\n+                            place.projections.len(),\n+                        );\n+\n+                        possible_descendant.info.capture_kind = descendant_capture_kind;\n+\n                         updated_capture_info =\n                             determine_capture_info(updated_capture_info, possible_descendant.info);\n \n@@ -542,8 +558,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         PlaceAncestryRelation::Descendant => {\n                             ancestor_found = true;\n                             let backup_path_expr_id = possible_ancestor.info.path_expr_id;\n-                            possible_ancestor.info =\n-                                determine_capture_info(possible_ancestor.info, capture_info);\n+\n+                            // Truncate the descendant (current place) to be same as the ancestor to handle any\n+                            // possible change in capture mode.\n+                            let (_, descendant_capture_kind) = truncate_place_to_len(\n+                                place.clone(),\n+                                updated_capture_info.capture_kind,\n+                                possible_ancestor.place.projections.len(),\n+                            );\n+\n+                            updated_capture_info.capture_kind = descendant_capture_kind;\n+\n+                            possible_ancestor.info = determine_capture_info(\n+                                possible_ancestor.info,\n+                                updated_capture_info,\n+                            );\n \n                             // we need to keep the ancestor's `path_expr_id`\n                             possible_ancestor.info.path_expr_id = backup_path_expr_id;\n@@ -1447,7 +1476,8 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     place: &Place<'tcx>,\n-) -> Place<'tcx> {\n+    curr_borrow_kind: ty::UpvarCapture<'tcx>,\n+) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n     let pos = place.projections.iter().enumerate().position(|(i, p)| {\n         let ty = place.ty_before_projection(i);\n \n@@ -1478,13 +1508,13 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n         }\n     });\n \n-    let mut place = place.clone();\n+    let place = place.clone();\n \n     if let Some(pos) = pos {\n-        place.projections.truncate(pos);\n+        truncate_place_to_len(place, curr_borrow_kind, pos)\n+    } else {\n+        (place, curr_borrow_kind)\n     }\n-\n-    place\n }\n \n /// Returns a Ty that applies the specified capture kind on the provided capture Ty\n@@ -1605,20 +1635,11 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         );\n \n         if let PlaceBase::Upvar(_) = place_with_id.place.base {\n-            let mut borrow_kind = ty::MutBorrow;\n-            for pointer_ty in place_with_id.place.deref_tys() {\n-                match pointer_ty.kind() {\n-                    // Raw pointers don't inherit mutability.\n-                    ty::RawPtr(_) => return,\n-                    // assignment to deref of an `&mut`\n-                    // borrowed pointer implies that the\n-                    // pointer itself must be unique, but not\n-                    // necessarily *mutable*\n-                    ty::Ref(.., hir::Mutability::Mut) => borrow_kind = ty::UniqueImmBorrow,\n-                    _ => (),\n-                }\n+            // Raw pointers don't inherit mutability\n+            if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n+                return;\n             }\n-            self.adjust_upvar_deref(place_with_id, diag_expr_id, borrow_kind);\n+            self.adjust_upvar_deref(place_with_id, diag_expr_id, ty::MutBorrow);\n         }\n     }\n \n@@ -1735,9 +1756,19 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         if let PlaceBase::Upvar(_) = place.base {\n             // We need to restrict Fake Read precision to avoid fake reading unsafe code,\n             // such as deref of a raw pointer.\n-            let place = restrict_capture_precision(place);\n-            let place =\n-                restrict_repr_packed_field_ref_capture(self.fcx.tcx, self.fcx.param_env, &place);\n+            let dummy_capture_kind = ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n+                kind: ty::BorrowKind::ImmBorrow,\n+                region: &ty::ReErased,\n+            });\n+\n+            let (place, _) = restrict_capture_precision(place, dummy_capture_kind);\n+\n+            let (place, _) = restrict_repr_packed_field_ref_capture(\n+                self.fcx.tcx,\n+                self.fcx.param_env,\n+                &place,\n+                dummy_capture_kind,\n+            );\n             self.fake_reads.push((place, cause, diag_expr_id));\n         }\n     }\n@@ -1763,13 +1794,18 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id, bk\n         );\n \n+        // The region here will get discarded/ignored\n+        let dummy_capture_kind =\n+            ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind: bk, region: &ty::ReErased });\n+\n         // We only want repr packed restriction to be applied to reading references into a packed\n         // struct, and not when the data is being moved. Therefore we call this method here instead\n         // of in `restrict_capture_precision`.\n-        let place = restrict_repr_packed_field_ref_capture(\n+        let (place, updated_kind) = restrict_repr_packed_field_ref_capture(\n             self.fcx.tcx,\n             self.fcx.param_env,\n             &place_with_id.place,\n+            dummy_capture_kind,\n         );\n \n         let place_with_id = PlaceWithHirId { place, ..*place_with_id };\n@@ -1778,14 +1814,19 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n             self.init_capture_info_for_place(&place_with_id, diag_expr_id);\n         }\n \n-        match bk {\n-            ty::ImmBorrow => {}\n-            ty::UniqueImmBorrow => {\n-                self.adjust_upvar_borrow_kind_for_unique(&place_with_id, diag_expr_id);\n-            }\n-            ty::MutBorrow => {\n-                self.adjust_upvar_borrow_kind_for_mut(&place_with_id, diag_expr_id);\n-            }\n+        match updated_kind {\n+            ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind, .. }) => match kind {\n+                ty::ImmBorrow => {}\n+                ty::UniqueImmBorrow => {\n+                    self.adjust_upvar_borrow_kind_for_unique(&place_with_id, diag_expr_id);\n+                }\n+                ty::MutBorrow => {\n+                    self.adjust_upvar_borrow_kind_for_mut(&place_with_id, diag_expr_id);\n+                }\n+            },\n+\n+            // Just truncating the place will never cause capture kind to be updated to ByValue\n+            ty::UpvarCapture::ByValue(..) => unreachable!(),\n         }\n     }\n \n@@ -1799,72 +1840,73 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n /// - No projections are applied to raw pointers, since these require unsafe blocks. We capture\n ///   them completely.\n /// - No projections are applied on top of Union ADTs, since these require unsafe blocks.\n-fn restrict_precision_for_unsafe(mut place: Place<'tcx>) -> Place<'tcx> {\n+fn restrict_precision_for_unsafe(\n+    place: Place<'tcx>,\n+    curr_mode: ty::UpvarCapture<'tcx>,\n+) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n     if place.projections.is_empty() {\n         // Nothing to do here\n-        return place;\n+        return (place, curr_mode);\n     }\n \n     if place.base_ty.is_unsafe_ptr() {\n-        place.projections.truncate(0);\n-        return place;\n+        return truncate_place_to_len(place, curr_mode, 0);\n     }\n \n     if place.base_ty.is_union() {\n-        place.projections.truncate(0);\n-        return place;\n+        return truncate_place_to_len(place, curr_mode, 0);\n     }\n \n     for (i, proj) in place.projections.iter().enumerate() {\n         if proj.ty.is_unsafe_ptr() {\n             // Don't apply any projections on top of an unsafe ptr.\n-            place.projections.truncate(i + 1);\n-            break;\n+            return truncate_place_to_len(place, curr_mode, i + 1);\n         }\n \n         if proj.ty.is_union() {\n             // Don't capture preicse fields of a union.\n-            place.projections.truncate(i + 1);\n-            break;\n+            return truncate_place_to_len(place, curr_mode, i + 1);\n         }\n     }\n \n-    place\n+    (place, curr_mode)\n }\n \n /// Truncate projections so that following rules are obeyed by the captured `place`:\n /// - No Index projections are captured, since arrays are captured completely.\n /// - No unsafe block is required to capture `place`\n-/// Truncate projections so that following rules are obeyed by the captured `place`:\n-fn restrict_capture_precision<'tcx>(mut place: Place<'tcx>) -> Place<'tcx> {\n-    place = restrict_precision_for_unsafe(place);\n+/// Returns the truncated place and updated cature mode.\n+fn restrict_capture_precision<'tcx>(\n+    place: Place<'tcx>,\n+    curr_mode: ty::UpvarCapture<'tcx>,\n+) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    let (place, curr_mode) = restrict_precision_for_unsafe(place, curr_mode);\n \n     if place.projections.is_empty() {\n         // Nothing to do here\n-        return place;\n+        return (place, curr_mode);\n     }\n \n     for (i, proj) in place.projections.iter().enumerate() {\n         match proj.kind {\n             ProjectionKind::Index => {\n                 // Arrays are completely captured, so we drop Index projections\n-                place.projections.truncate(i);\n-                break;\n+                return truncate_place_to_len(place, curr_mode, i);\n             }\n             ProjectionKind::Deref => {}\n             ProjectionKind::Field(..) => {} // ignore\n             ProjectionKind::Subslice => {}  // We never capture this\n         }\n     }\n \n-    place\n+    return (place, curr_mode);\n }\n \n /// Take ownership if data being accessed is owned by the variable used to access it\n /// (or if closure attempts to move data that it doesn\u2019t own).\n /// Note: When taking ownership, only capture data found on the stack.\n fn adjust_for_move_closure<'tcx>(\n-    mut place: Place<'tcx>,\n+    place: Place<'tcx>,\n     kind: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n     let contains_deref_of_ref = place.deref_tys().any(|ty| ty.is_ref());\n@@ -1878,7 +1920,7 @@ fn adjust_for_move_closure<'tcx>(\n         _ if first_deref.is_some() => {\n             let place = match first_deref {\n                 Some(idx) => {\n-                    place.projections.truncate(idx);\n+                    let (place, _) = truncate_place_to_len(place, kind, idx);\n                     place\n                 }\n                 None => place,\n@@ -1896,8 +1938,8 @@ fn adjust_for_move_closure<'tcx>(\n /// Adjust closure capture just that if taking ownership of data, only move data\n /// from enclosing stack frame.\n fn adjust_for_non_move_closure<'tcx>(\n-    mut place: Place<'tcx>,\n-    kind: ty::UpvarCapture<'tcx>,\n+    place: Place<'tcx>,\n+    mut kind: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n     let contains_deref =\n         place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n@@ -1906,7 +1948,9 @@ fn adjust_for_non_move_closure<'tcx>(\n         ty::UpvarCapture::ByValue(..) if contains_deref.is_some() => {\n             let place = match contains_deref {\n                 Some(idx) => {\n-                    place.projections.truncate(idx);\n+                    let (place, new_kind) = truncate_place_to_len(place, kind, idx);\n+\n+                    kind = new_kind;\n                     place\n                 }\n                 // Because of the if guard on the match on `kind`, we should never get here.\n@@ -2107,6 +2151,49 @@ fn determine_capture_info(\n     }\n }\n \n+/// Truncates `place` to have up to `len` projections.\n+/// `curr_mode` is the current required capture kind for the place.\n+/// Returns the truncated `place` and the updated required capture kind.\n+///\n+/// Note: Capture kind changes from `MutBorrow` to `UniqueImmBorrow` if the truncated part of the `place`\n+/// contained `Deref` of `&mut`.\n+fn truncate_place_to_len(\n+    mut place: Place<'tcx>,\n+    curr_mode: ty::UpvarCapture<'tcx>,\n+    len: usize,\n+) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    let is_mut_ref = |ty: Ty<'_>| matches!(ty.kind(), ty::Ref(.., hir::Mutability::Mut));\n+\n+    let mut capture_kind = curr_mode;\n+\n+    // If the truncated part of the place contains `Deref` of a `&mut` then convert MutBorrow ->\n+    // UniqueImmBorrow\n+    // Note that if the place contained Deref of a raw pointer it would've not been MutBorrow, so\n+    // we don't need to worry about that case here.\n+    match curr_mode {\n+        ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind: ty::BorrowKind::MutBorrow, region }) => {\n+            for i in len..place.projections.len() {\n+                if place.projections[i].kind == ProjectionKind::Deref\n+                    && is_mut_ref(place.ty_before_projection(i))\n+                {\n+                    capture_kind = ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n+                        kind: ty::BorrowKind::UniqueImmBorrow,\n+                        region,\n+                    });\n+                    break;\n+                }\n+            }\n+        }\n+\n+        ty::UpvarCapture::ByRef(..) => {}\n+        ty::UpvarCapture::ByValue(..) => {}\n+    }\n+\n+    place.projections.truncate(len);\n+\n+    (place, capture_kind)\n+}\n+\n /// Determines the Ancestry relationship of Place A relative to Place B\n ///\n /// `PlaceAncestryRelation::Ancestor` implies Place A is ancestor of Place B\n@@ -2168,7 +2255,10 @@ fn determine_place_ancestry_relation(\n ///     // it is constrained to `'a`\n /// }\n /// ```\n-fn truncate_capture_for_optimization<'tcx>(place: &Place<'tcx>) -> Place<'tcx> {\n+fn truncate_capture_for_optimization<'tcx>(\n+    place: Place<'tcx>,\n+    curr_mode: ty::UpvarCapture<'tcx>,\n+) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n     let is_shared_ref = |ty: Ty<'_>| matches!(ty.kind(), ty::Ref(.., hir::Mutability::Not));\n \n     // Find the right-most deref (if any). All the projections that come after this\n@@ -2179,9 +2269,9 @@ fn truncate_capture_for_optimization<'tcx>(place: &Place<'tcx>) -> Place<'tcx> {\n     match idx {\n         // If that pointer is a shared reference, then we don't need those fields.\n         Some(idx) if is_shared_ref(place.ty_before_projection(idx)) => {\n-            Place { projections: place.projections[0..=idx].to_vec(), ..place.clone() }\n+            truncate_place_to_len(place, curr_mode, idx + 1)\n         }\n-        None | Some(_) => place.clone(),\n+        None | Some(_) => (place, curr_mode),\n     }\n }\n "}, {"sha": "6b49293e6d3fb735e70cfafb12000352754fe43c", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9583fd1bdd0127328e25e5b8c24dff575ec2c86b/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9583fd1bdd0127328e25e5b8c24dff575ec2c86b/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs?ref=9583fd1bdd0127328e25e5b8c24dff575ec2c86b", "patch": "@@ -34,8 +34,8 @@ fn simple_ref() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         *ref_s += 10;\n-        //~^ NOTE: Capturing ref_s[Deref] -> UniqueImmBorrow\n-        //~| NOTE: Min Capture ref_s[Deref] -> UniqueImmBorrow\n+        //~^ NOTE: Capturing ref_s[Deref] -> MutBorrow\n+        //~| NOTE: Min Capture ref_s[Deref] -> MutBorrow\n     };\n     c();\n }\n@@ -55,8 +55,8 @@ fn struct_contains_ref_to_another_struct_1() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         t.0.0 = \"new s\".into();\n-        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n-        //~| NOTE: Min Capture t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> MutBorrow\n+        //~| NOTE: Min Capture t[(0, 0),Deref,(0, 0)] -> MutBorrow\n     };\n \n     c();\n@@ -173,9 +173,9 @@ fn box_mut_1() {\n     //~^ ERROR: attributes on expressions are experimental\n     //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n     //~| First Pass analysis includes:\n-    //~| NOTE: Capturing box_p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+    //~| NOTE: Capturing box_p_foo[Deref,Deref,(0, 0)] -> MutBorrow\n     //~| Min Capture analysis includes:\n-    //~| NOTE: Min Capture box_p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+    //~| NOTE: Min Capture box_p_foo[Deref,Deref,(0, 0)] -> MutBorrow\n }\n \n // Ensure that even in move closures, if the data is not owned by the root variable\n@@ -190,9 +190,9 @@ fn box_mut_2() {\n     //~^ ERROR: attributes on expressions are experimental\n     //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n     //~| First Pass analysis includes:\n-    //~| NOTE: Capturing p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+    //~| NOTE: Capturing p_foo[Deref,Deref,(0, 0)] -> MutBorrow\n     //~| Min Capture analysis includes:\n-    //~| NOTE: Min Capture p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+    //~| NOTE: Min Capture p_foo[Deref,Deref,(0, 0)] -> MutBorrow\n }\n \n // Test that move closures can take ownership of Copy type"}, {"sha": "b99b451a1711b3981c4ba23c3e3ee4351b86d734", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9583fd1bdd0127328e25e5b8c24dff575ec2c86b/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9583fd1bdd0127328e25e5b8c24dff575ec2c86b/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr?ref=9583fd1bdd0127328e25e5b8c24dff575ec2c86b", "patch": "@@ -169,7 +169,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing ref_s[Deref] -> UniqueImmBorrow\n+note: Capturing ref_s[Deref] -> MutBorrow\n   --> $DIR/move_closure.rs:36:9\n    |\n LL |         *ref_s += 10;\n@@ -187,7 +187,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Min Capture ref_s[Deref] -> UniqueImmBorrow\n+note: Min Capture ref_s[Deref] -> MutBorrow\n   --> $DIR/move_closure.rs:36:9\n    |\n LL |         *ref_s += 10;\n@@ -205,7 +205,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> MutBorrow\n   --> $DIR/move_closure.rs:57:9\n    |\n LL |         t.0.0 = \"new s\".into();\n@@ -223,7 +223,7 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Min Capture t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n+note: Min Capture t[(0, 0),Deref,(0, 0)] -> MutBorrow\n   --> $DIR/move_closure.rs:57:9\n    |\n LL |         t.0.0 = \"new s\".into();\n@@ -415,7 +415,7 @@ error: First Pass analysis includes:\n LL |     let c = #[rustc_capture_analysis] move || box_p_foo.x += 10;\n    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: Capturing box_p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+note: Capturing box_p_foo[Deref,Deref,(0, 0)] -> MutBorrow\n   --> $DIR/move_closure.rs:172:47\n    |\n LL |     let c = #[rustc_capture_analysis] move || box_p_foo.x += 10;\n@@ -427,7 +427,7 @@ error: Min Capture analysis includes:\n LL |     let c = #[rustc_capture_analysis] move || box_p_foo.x += 10;\n    |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: Min Capture box_p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+note: Min Capture box_p_foo[Deref,Deref,(0, 0)] -> MutBorrow\n   --> $DIR/move_closure.rs:172:47\n    |\n LL |     let c = #[rustc_capture_analysis] move || box_p_foo.x += 10;\n@@ -439,7 +439,7 @@ error: First Pass analysis includes:\n LL |     let c = #[rustc_capture_analysis] move || p_foo.x += 10;\n    |                                       ^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: Capturing p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+note: Capturing p_foo[Deref,Deref,(0, 0)] -> MutBorrow\n   --> $DIR/move_closure.rs:189:47\n    |\n LL |     let c = #[rustc_capture_analysis] move || p_foo.x += 10;\n@@ -451,7 +451,7 @@ error: Min Capture analysis includes:\n LL |     let c = #[rustc_capture_analysis] move || p_foo.x += 10;\n    |                                       ^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: Min Capture p_foo[Deref,Deref,(0, 0)] -> UniqueImmBorrow\n+note: Min Capture p_foo[Deref,Deref,(0, 0)] -> MutBorrow\n   --> $DIR/move_closure.rs:189:47\n    |\n LL |     let c = #[rustc_capture_analysis] move || p_foo.x += 10;"}]}