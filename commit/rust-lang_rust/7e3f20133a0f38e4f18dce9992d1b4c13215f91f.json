{"sha": "7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlM2YyMDEzM2EwZjM4ZTRmMThkY2U5OTkyZDFiNGMxMzIxNWY5MWY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-19T21:22:03Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-19T21:22:03Z"}, "message": "librustc: Change most uses of `&fn()` to `||`.", "tree": {"sha": "5663e1c00b8b8a4aad67b706807900f43a2ea600", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5663e1c00b8b8a4aad67b706807900f43a2ea600"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "html_url": "https://github.com/rust-lang/rust/commit/7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "492677ec1e4e66a57a2fce78962db2f89932dd74", "url": "https://api.github.com/repos/rust-lang/rust/commits/492677ec1e4e66a57a2fce78962db2f89932dd74", "html_url": "https://github.com/rust-lang/rust/commit/492677ec1e4e66a57a2fce78962db2f89932dd74"}], "stats": {"total": 591, "additions": 298, "deletions": 293}, "files": [{"sha": "f752b68fea5fe53386b7aa3a04a98c7faf51da2f", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -386,8 +386,7 @@ pub fn basic_options() -> @options {\n }\n \n // Seems out of place, but it uses session, so I'm putting it here\n-pub fn expect<T:Clone>(sess: Session, opt: Option<T>, msg: &fn() -> ~str)\n-                       -> T {\n+pub fn expect<T:Clone>(sess: Session, opt: Option<T>, msg: || -> ~str) -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n "}, {"sha": "296e8578cbe7c9bd215b7790b1a02a1f94c6ab78", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -42,7 +42,7 @@ impl<'self> fold::ast_fold for Context<'self> {\n }\n \n pub fn strip_items(crate: ast::Crate,\n-                   in_cfg: &fn(attrs: &[ast::Attribute]) -> bool)\n+                   in_cfg: |attrs: &[ast::Attribute]| -> bool)\n                    -> ast::Crate {\n     let ctxt = Context {\n         in_cfg: in_cfg,"}, {"sha": "9c9dba524534bb64a26c4d37ba8fdb28298dd2d7", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -44,16 +44,18 @@ pub fn get_type_param_count(cstore: @mut cstore::CStore, def: ast::DefId)\n /// Iterates over all the language items in the given crate.\n pub fn each_lang_item(cstore: @mut cstore::CStore,\n                       cnum: ast::CrateNum,\n-                      f: &fn(ast::NodeId, uint) -> bool) -> bool {\n+                      f: |ast::NodeId, uint| -> bool)\n+                      -> bool {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     decoder::each_lang_item(crate_data, f)\n }\n \n /// Iterates over each child of the given item.\n pub fn each_child_of_item(cstore: @mut cstore::CStore,\n                           def_id: ast::DefId,\n-                          callback: &fn(decoder::DefLike, ast::Ident,\n-                                        ast::visibility)) {\n+                          callback: |decoder::DefLike,\n+                                     ast::Ident,\n+                                     ast::visibility|) {\n     let crate_data = cstore::get_crate_data(cstore, def_id.crate);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n@@ -68,9 +70,9 @@ pub fn each_child_of_item(cstore: @mut cstore::CStore,\n /// Iterates over each top-level crate item.\n pub fn each_top_level_item_of_crate(cstore: @mut cstore::CStore,\n                                     cnum: ast::CrateNum,\n-                                    callback: &fn(decoder::DefLike,\n-                                                  ast::Ident,\n-                                                  ast::visibility)) {\n+                                    callback: |decoder::DefLike,\n+                                               ast::Ident,\n+                                               ast::visibility|) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n@@ -178,7 +180,7 @@ pub fn get_static_methods_if_impl(cstore: @mut cstore::CStore,\n \n pub fn get_item_attrs(cstore: @mut cstore::CStore,\n                       def_id: ast::DefId,\n-                      f: &fn(~[@ast::MetaItem])) {\n+                      f: |~[@ast::MetaItem]|) {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }\n@@ -262,21 +264,21 @@ pub fn get_item_visibility(cstore: @mut cstore::CStore,\n \n pub fn each_impl(cstore: @mut cstore::CStore,\n                  crate_num: ast::CrateNum,\n-                 callback: &fn(ast::DefId)) {\n+                 callback: |ast::DefId|) {\n     let cdata = cstore::get_crate_data(cstore, crate_num);\n     decoder::each_impl(cdata, callback)\n }\n \n pub fn each_implementation_for_type(cstore: @mut cstore::CStore,\n                                     def_id: ast::DefId,\n-                                    callback: &fn(ast::DefId)) {\n+                                    callback: |ast::DefId|) {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::each_implementation_for_type(cdata, def_id.node, callback)\n }\n \n pub fn each_implementation_for_trait(cstore: @mut cstore::CStore,\n                                      def_id: ast::DefId,\n-                                     callback: &fn(ast::DefId)) {\n+                                     callback: |ast::DefId|) {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n     decoder::each_implementation_for_trait(cdata, def_id.node, callback)\n }"}, {"sha": "135d1ac8ac047d5b517f123763864d840cbd0b46", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -82,8 +82,7 @@ pub fn have_crate_data(cstore: &CStore, cnum: ast::CrateNum) -> bool {\n     cstore.metas.contains_key(&cnum)\n }\n \n-pub fn iter_crate_data(cstore: &CStore,\n-                       i: &fn(ast::CrateNum, @crate_metadata)) {\n+pub fn iter_crate_data(cstore: &CStore, i: |ast::CrateNum, @crate_metadata|) {\n     for (&k, &v) in cstore.metas.iter() {\n         i(k, v);\n     }"}, {"sha": "fbe3d7bbe9eea5c2f39940a4f1fa9bd47321007c", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -51,7 +51,7 @@ type Cmd = @crate_metadata;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: u64) ->\n+fn lookup_hash(d: ebml::Doc, eq_fn: |&[u8]| -> bool, hash: u64) ->\n    Option<ebml::Doc> {\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n@@ -205,7 +205,7 @@ fn get_provided_source(d: ebml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n     }\n }\n \n-fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) -> bool {\n+fn each_reexport(d: ebml::Doc, f: |ebml::Doc| -> bool) -> bool {\n     reader::tagged_docs(d, tag_items_data_item_reexport, f)\n }\n \n@@ -509,7 +509,7 @@ pub fn def_like_to_def(def_like: DefLike) -> ast::Def {\n }\n \n /// Iterates over the language items in the given crate.\n-pub fn each_lang_item(cdata: Cmd, f: &fn(ast::NodeId, uint) -> bool) -> bool {\n+pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n     let root = reader::Doc(cdata.data);\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     do reader::tagged_docs(lang_items, tag_lang_items_item) |item_doc| {\n@@ -733,8 +733,9 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                                cdata: Cmd,\n                                item_doc: ebml::Doc,\n                                get_crate_data: GetCrateDataCb,\n-                               callback: &fn(DefLike, ast::Ident,\n-                                             ast::visibility)) {\n+                               callback: |DefLike,\n+                                          ast::Ident,\n+                                          ast::visibility|) {\n     // Iterate over all children.\n     let _ = do reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n         let child_def_id = reader::with_doc_data(child_info_doc,\n@@ -861,7 +862,7 @@ pub fn each_child_of_item(intr: @ident_interner,\n                           cdata: Cmd,\n                           id: ast::NodeId,\n                           get_crate_data: GetCrateDataCb,\n-                          callback: &fn(DefLike, ast::Ident, ast::visibility)) {\n+                          callback: |DefLike, ast::Ident, ast::visibility|) {\n     // Find the item.\n     let root_doc = reader::Doc(cdata.data);\n     let items = reader::get_doc(root_doc, tag_items);\n@@ -881,8 +882,9 @@ pub fn each_child_of_item(intr: @ident_interner,\n pub fn each_top_level_item_of_crate(intr: @ident_interner,\n                                     cdata: Cmd,\n                                     get_crate_data: GetCrateDataCb,\n-                                    callback: &fn(DefLike, ast::Ident,\n-                                                  ast::visibility)) {\n+                                    callback: |DefLike,\n+                                               ast::Ident,\n+                                               ast::visibility|) {\n     let root_doc = reader::Doc(cdata.data);\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n@@ -1201,8 +1203,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n \n pub fn get_item_attrs(cdata: Cmd,\n                       node_id: ast::NodeId,\n-                      f: &fn(~[@ast::MetaItem])) {\n-\n+                      f: |~[@ast::MetaItem]|) {\n     let item = lookup_item(node_id, cdata.data);\n     do reader::tagged_docs(item, tag_attributes) |attributes| {\n         do reader::tagged_docs(attributes, tag_attribute) |attribute| {\n@@ -1474,7 +1475,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n     }\n }\n \n-pub fn each_impl(cdata: Cmd, callback: &fn(ast::DefId)) {\n+pub fn each_impl(cdata: Cmd, callback: |ast::DefId|) {\n     let impls_doc = reader::get_doc(reader::Doc(cdata.data), tag_impls);\n     let _ = do reader::tagged_docs(impls_doc, tag_impls_impl) |impl_doc| {\n         callback(item_def_id(impl_doc, cdata));\n@@ -1484,7 +1485,7 @@ pub fn each_impl(cdata: Cmd, callback: &fn(ast::DefId)) {\n \n pub fn each_implementation_for_type(cdata: Cmd,\n                                     id: ast::NodeId,\n-                                    callback: &fn(ast::DefId)) {\n+                                    callback: |ast::DefId|) {\n     let item_doc = lookup_item(id, cdata.data);\n     do reader::tagged_docs(item_doc, tag_items_data_item_inherent_impl)\n             |impl_doc| {\n@@ -1496,7 +1497,7 @@ pub fn each_implementation_for_type(cdata: Cmd,\n \n pub fn each_implementation_for_trait(cdata: Cmd,\n                                      id: ast::NodeId,\n-                                     callback: &fn(ast::DefId)) {\n+                                     callback: |ast::DefId|) {\n     let item_doc = lookup_item(id, cdata.data);\n \n     let _ = do reader::tagged_docs(item_doc,"}, {"sha": "340a4241da23bded7c4047468892d5bcb235a4b1", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -535,8 +535,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n /// * For enums, iterates through the node IDs of the variants.\n ///\n /// * For newtype structs, iterates through the node ID of the constructor.\n-fn each_auxiliary_node_id(item: @item, callback: &fn(NodeId) -> bool)\n-                          -> bool {\n+fn each_auxiliary_node_id(item: @item, callback: |NodeId| -> bool) -> bool {\n     let mut continue_ = true;\n     match item.node {\n         item_enum(ref enum_def, _) => {\n@@ -912,7 +911,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                      index: @mut ~[entry<i64>]) {\n         index.push(entry { val: item.id as i64, pos: ebml_w.writer.tell() });\n     }\n-    let add_to_index: &fn() = || add_to_index(item, ebml_w, index);\n+    let add_to_index: || = || add_to_index(item, ebml_w, index);\n \n     debug!(\"encoding info for item at {}\",\n            ecx.tcx.sess.codemap.span_to_str(item.span));\n@@ -1412,7 +1411,7 @@ fn create_index<T:Clone + Hash + IterBytes + 'static>(\n fn encode_index<T:'static>(\n                 ebml_w: &mut writer::Encoder,\n                 buckets: ~[@~[entry<T>]],\n-                write_fn: &fn(@mut MemWriter, &T)) {\n+                write_fn: |@mut MemWriter, &T|) {\n     ebml_w.start_tag(tag_index);\n     let mut bucket_locs = ~[];\n     ebml_w.start_tag(tag_index_buckets);"}, {"sha": "32beb4bbaf375aa2be7b1a634b4e4d98e88e6abe", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -35,7 +35,7 @@ pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n \n pub trait FileSearch {\n     fn sysroot(&self) -> @Path;\n-    fn for_each_lib_search_path(&self, f: &fn(&Path) -> FileMatch);\n+    fn for_each_lib_search_path(&self, f: |&Path| -> FileMatch);\n     fn get_target_lib_path(&self) -> Path;\n     fn get_target_lib_file_path(&self, file: &Path) -> Path;\n }\n@@ -51,7 +51,8 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n     }\n     impl FileSearch for FileSearchImpl {\n         fn sysroot(&self) -> @Path { self.sysroot }\n-        fn for_each_lib_search_path(&self, f: &fn(&Path) -> FileMatch) {\n+\n+        fn for_each_lib_search_path(&self, f: |&Path| -> FileMatch) {\n             let mut visited_dirs = HashSet::new();\n             let mut found = false;\n "}, {"sha": "281998b08114674ef8cdd18bec24b6f17f366984", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -79,9 +79,7 @@ fn next_byte(st: &mut PState) -> u8 {\n     return b;\n }\n \n-fn scan<R>(st: &mut PState, is_last: &fn(char) -> bool,\n-           op: &fn(&[u8]) -> R) -> R\n-{\n+fn scan<R>(st: &mut PState, is_last: |char| -> bool, op: |&[u8]| -> R) -> R {\n     let start_pos = st.pos;\n     debug!(\"scan: '{}' (start)\", st.data[st.pos] as char);\n     while !is_last(st.data[st.pos] as char) {\n@@ -98,7 +96,7 @@ pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n     return parse_ident_(st, |a| is_last(last, a) );\n }\n \n-fn parse_ident_(st: &mut PState, is_last: &fn(char) -> bool) -> ast::Ident {\n+fn parse_ident_(st: &mut PState, is_last: |char| -> bool) -> ast::Ident {\n     let rslt = scan(st, is_last, str::from_utf8);\n     return st.tcx.sess.ident_of(rslt);\n }\n@@ -292,7 +290,7 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n     }\n }\n \n-fn parse_opt<T>(st: &mut PState, f: &fn(&mut PState) -> T) -> Option<T> {\n+fn parse_opt<T>(st: &mut PState, f: |&mut PState| -> T) -> Option<T> {\n     match next(st) {\n       'n' => None,\n       's' => Some(f(st)),"}, {"sha": "f1207b07ada8992350f505efefca92e9d36c5d47", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -120,7 +120,7 @@ fn enc_mt(w: @mut MemWriter, cx: @ctxt, mt: ty::mt) {\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T>(w: @mut MemWriter, t: Option<T>, enc_f: &fn(T)) {\n+fn enc_opt<T>(w: @mut MemWriter, t: Option<T>, enc_f: |T|) {\n     match t {\n         None => mywrite!(w, \"n\"),\n         Some(v) => {"}, {"sha": "7f8816bd6137dd6e4dcb810d831b85cfa709f94a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -845,14 +845,12 @@ impl ebml_writer_helpers for writer::Encoder {\n }\n \n trait write_tag_and_id {\n-    fn tag(&mut self, tag_id: c::astencode_tag, f: &fn(&mut Self));\n+    fn tag(&mut self, tag_id: c::astencode_tag, f: |&mut Self|);\n     fn id(&mut self, id: ast::NodeId);\n }\n \n impl write_tag_and_id for writer::Encoder {\n-    fn tag(&mut self,\n-           tag_id: c::astencode_tag,\n-           f: &fn(&mut writer::Encoder)) {\n+    fn tag(&mut self, tag_id: c::astencode_tag, f: |&mut writer::Encoder|) {\n         self.start_tag(tag_id as uint);\n         f(self);\n         self.end_tag();"}, {"sha": "d6aec7738a16160f48e521acc417851b1b71d9ac", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -124,9 +124,7 @@ impl<'self> CheckLoanCtxt<'self> {\n \n     pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    pub fn each_issued_loan(&self,\n-                            scope_id: ast::NodeId,\n-                            op: &fn(&Loan) -> bool)\n+    pub fn each_issued_loan(&self, scope_id: ast::NodeId, op: |&Loan| -> bool)\n                             -> bool {\n         //! Iterates over each loan that has been issued\n         //! on entrance to `scope_id`, regardless of whether it is\n@@ -142,7 +140,7 @@ impl<'self> CheckLoanCtxt<'self> {\n \n     pub fn each_in_scope_loan(&self,\n                               scope_id: ast::NodeId,\n-                              op: &fn(&Loan) -> bool)\n+                              op: |&Loan| -> bool)\n                               -> bool {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n@@ -160,7 +158,7 @@ impl<'self> CheckLoanCtxt<'self> {\n     pub fn each_in_scope_restriction(&self,\n                                      scope_id: ast::NodeId,\n                                      loan_path: @LoanPath,\n-                                     op: &fn(&Loan, &Restriction) -> bool)\n+                                     op: |&Loan, &Restriction| -> bool)\n                                      -> bool {\n         //! Iterates through all the in-scope restrictions for the\n         //! given `loan_path`"}, {"sha": "ef2c172acdf225ee1c780430e464cbfeefa53812", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -533,7 +533,7 @@ impl BorrowckCtxt {\n     pub fn cat_pattern(&self,\n                        cmt: mc::cmt,\n                        pat: @ast::Pat,\n-                       op: &fn(mc::cmt, @ast::Pat)) {\n+                       op: |mc::cmt, @ast::Pat|) {\n         let mc = self.mc_ctxt();\n         mc.cat_pattern(cmt, pat, op);\n     }"}, {"sha": "a0a9ba11db2f0ca303401a4184f49b8576a4fa4b", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -412,9 +412,7 @@ impl MoveData {\n         }\n     }\n \n-    fn each_base_path(&self,\n-                      index: MovePathIndex,\n-                      f: &fn(MovePathIndex) -> bool)\n+    fn each_base_path(&self, index: MovePathIndex, f: |MovePathIndex| -> bool)\n                       -> bool {\n         let mut p = index;\n         while p != InvalidMovePathIndex {\n@@ -428,7 +426,8 @@ impl MoveData {\n \n     fn each_extending_path(&self,\n                            index: MovePathIndex,\n-                           f: &fn(MovePathIndex) -> bool) -> bool {\n+                           f: |MovePathIndex| -> bool)\n+                           -> bool {\n         if !f(index) {\n             return false;\n         }\n@@ -446,7 +445,8 @@ impl MoveData {\n \n     fn each_applicable_move(&self,\n                             index0: MovePathIndex,\n-                            f: &fn(MoveIndex) -> bool) -> bool {\n+                            f: |MoveIndex| -> bool)\n+                            -> bool {\n         let mut ret = true;\n         do self.each_extending_path(index0) |index| {\n             let mut p = self.path(index).first_move;\n@@ -505,7 +505,7 @@ impl FlowedMoveData {\n \n     pub fn each_path_moved_by(&self,\n                               id: ast::NodeId,\n-                              f: &fn(&Move, @LoanPath) -> bool)\n+                              f: |&Move, @LoanPath| -> bool)\n                               -> bool {\n         /*!\n          * Iterates through each path moved by `id`\n@@ -521,7 +521,7 @@ impl FlowedMoveData {\n     pub fn each_move_of(&self,\n                         id: ast::NodeId,\n                         loan_path: @LoanPath,\n-                        f: &fn(&Move, @LoanPath) -> bool)\n+                        f: |&Move, @LoanPath| -> bool)\n                         -> bool {\n         /*!\n          * Iterates through each move of `loan_path` (or some base path\n@@ -587,7 +587,7 @@ impl FlowedMoveData {\n     pub fn each_assignment_of(&self,\n                               id: ast::NodeId,\n                               loan_path: @LoanPath,\n-                              f: &fn(&Assignment) -> bool)\n+                              f: |&Assignment| -> bool)\n                               -> bool {\n         /*!\n          * Iterates through every assignment to `loan_path` that"}, {"sha": "04d6266d405f072bdb246a1708a3c30df0f855b4", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -121,7 +121,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n         for pat in arm.pats.iter() {\n \n             // Check that we do not match against a static NaN (#6804)\n-            let pat_matches_nan: &fn(&Pat) -> bool = |p| {\n+            let pat_matches_nan: |&Pat| -> bool = |p| {\n                 match cx.tcx.def_map.find(&p.id) {\n                     Some(&DefStatic(did, false)) => {\n                         let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n@@ -900,7 +900,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         }\n     }\n \n-    let check_move: &fn(&Pat, Option<@Pat>) = |p, sub| {\n+    let check_move: |&Pat, Option<@Pat>| = |p, sub| {\n         // check legality of moving out of the enum\n \n         // x @ Foo(*) is legal, but x @ Foo(y) isn't."}, {"sha": "96970e13fcbc34bc2fe323f512f5f9b42bf9fbb3", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -234,7 +234,8 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n \n     pub fn each_bit_on_entry_frozen(&self,\n                                     id: ast::NodeId,\n-                                    f: &fn(uint) -> bool) -> bool {\n+                                    f: |uint| -> bool)\n+                                    -> bool {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n         if !self.nodeid_to_bitset.contains_key(&id) {\n@@ -249,7 +250,8 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n \n     pub fn each_bit_on_entry(&mut self,\n                              id: ast::NodeId,\n-                             f: &fn(uint) -> bool) -> bool {\n+                             f: |uint| -> bool)\n+                             -> bool {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n \n@@ -260,9 +262,8 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         self.each_bit(on_entry, f)\n     }\n \n-    pub fn each_gen_bit(&mut self,\n-                        id: ast::NodeId,\n-                        f: &fn(uint) -> bool) -> bool {\n+    pub fn each_gen_bit(&mut self, id: ast::NodeId, f: |uint| -> bool)\n+                        -> bool {\n         //! Iterates through each bit in the gen set for `id`.\n \n         let (start, end) = self.compute_id_range(id);\n@@ -272,9 +273,8 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         self.each_bit(gens, f)\n     }\n \n-    pub fn each_gen_bit_frozen(&self,\n-                               id: ast::NodeId,\n-                               f: &fn(uint) -> bool) -> bool {\n+    pub fn each_gen_bit_frozen(&self, id: ast::NodeId, f: |uint| -> bool)\n+                               -> bool {\n         //! Iterates through each bit in the gen set for `id`.\n         if !self.nodeid_to_bitset.contains_key(&id) {\n             return true;\n@@ -286,9 +286,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n         self.each_bit(gens, f)\n     }\n \n-    fn each_bit(&self,\n-                words: &[uint],\n-                f: &fn(uint) -> bool) -> bool {\n+    fn each_bit(&self, words: &[uint], f: |uint| -> bool) -> bool {\n         //! Helper for iterating over the bits in a bit set.\n \n         for (word_index, &word) in words.iter().enumerate() {\n@@ -978,9 +976,8 @@ fn join_bits<O:DataFlowOperator>(oper: &O,\n }\n \n #[inline]\n-fn bitwise(out_vec: &mut [uint],\n-           in_vec: &[uint],\n-           op: &fn(uint, uint) -> uint) -> bool {\n+fn bitwise(out_vec: &mut [uint], in_vec: &[uint], op: |uint, uint| -> uint)\n+           -> bool {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n     for (out_elt, in_elt) in out_vec.mut_iter().zip(in_vec.iter()) {"}, {"sha": "7a842364d1e3386f7d7e3173875093cf35a52a47", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -185,27 +185,29 @@ impl<N,E> Graph<N,E> {\n     ///////////////////////////////////////////////////////////////////////////\n     // Iterating over nodes, edges\n \n-    pub fn each_node(&self, f: &fn(NodeIndex, &Node<N>) -> bool) -> bool {\n+    pub fn each_node(&self, f: |NodeIndex, &Node<N>| -> bool) -> bool {\n         //! Iterates over all edges defined in the graph.\n         self.nodes.iter().enumerate().advance(|(i, node)| f(NodeIndex(i), node))\n     }\n \n-    pub fn each_edge(&self, f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+    pub fn each_edge(&self, f: |EdgeIndex, &Edge<E>| -> bool) -> bool {\n         //! Iterates over all edges defined in the graph\n         self.edges.iter().enumerate().advance(|(i, edge)| f(EdgeIndex(i), edge))\n     }\n \n     pub fn each_outgoing_edge(&self,\n                               source: NodeIndex,\n-                              f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+                              f: |EdgeIndex, &Edge<E>| -> bool)\n+                              -> bool {\n         //! Iterates over all outgoing edges from the node `from`\n \n         self.each_adjacent_edge(source, Outgoing, f)\n     }\n \n     pub fn each_incoming_edge(&self,\n                               target: NodeIndex,\n-                              f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+                              f: |EdgeIndex, &Edge<E>| -> bool)\n+                              -> bool {\n         //! Iterates over all incoming edges to the node `target`\n \n         self.each_adjacent_edge(target, Incoming, f)\n@@ -214,7 +216,8 @@ impl<N,E> Graph<N,E> {\n     pub fn each_adjacent_edge(&self,\n                               node: NodeIndex,\n                               dir: Direction,\n-                              f: &fn(EdgeIndex, &Edge<E>) -> bool) -> bool {\n+                              f: |EdgeIndex, &Edge<E>| -> bool)\n+                              -> bool {\n         //! Iterates over all edges adjacent to the node `node`\n         //! in the direction `dir` (either `Outgoing` or `Incoming)\n \n@@ -239,9 +242,10 @@ impl<N,E> Graph<N,E> {\n     // computation.\n \n     pub fn iterate_until_fixed_point(&self,\n-                                     op: &fn(iter_index: uint,\n-                                             edge_index: EdgeIndex,\n-                                             edge: &Edge<E>) -> bool) {\n+                                     op: |iter_index: uint,\n+                                          edge_index: EdgeIndex,\n+                                          edge: &Edge<E>|\n+                                          -> bool) {\n         let mut iteration = 0;\n         let mut changed = true;\n         while changed {\n@@ -254,7 +258,7 @@ impl<N,E> Graph<N,E> {\n     }\n }\n \n-pub fn each_edge_index(max_edge_index: EdgeIndex, f: &fn(EdgeIndex) -> bool) {\n+pub fn each_edge_index(max_edge_index: EdgeIndex, f: |EdgeIndex| -> bool) {\n     let mut i = 0;\n     let n = *max_edge_index;\n     while i < n {"}, {"sha": "b6b1516d05a02d10285221340d5b6acf4568779a", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -167,8 +167,9 @@ fn check_item(cx: &mut Context, item: @item) {\n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the NodeId for some expression that creates the\n // closure.\n-fn with_appropriate_checker(cx: &Context, id: NodeId,\n-                            b: &fn(checker: &fn(&Context, @freevar_entry))) {\n+fn with_appropriate_checker(cx: &Context,\n+                            id: NodeId,\n+                            b: |checker: |&Context, @freevar_entry||) {\n     fn check_for_uniq(cx: &Context, fv: &freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n@@ -351,9 +352,10 @@ fn check_ty(cx: &mut Context, aty: &Ty) {\n }\n \n // Calls \"any_missing\" if any bounds were missing.\n-pub fn check_builtin_bounds(cx: &Context, ty: ty::t, bounds: ty::BuiltinBounds,\n-                            any_missing: &fn(ty::BuiltinBounds))\n-{\n+pub fn check_builtin_bounds(cx: &Context,\n+                            ty: ty::t,\n+                            bounds: ty::BuiltinBounds,\n+                            any_missing: |ty::BuiltinBounds|) {\n     let kind = ty::type_contents(cx.tcx, ty);\n     let mut missing = ty::EmptyBuiltinBounds();\n     for bound in bounds.iter() {"}, {"sha": "24e76709ff50dc58ccc939c8e1948a2766229566", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -417,8 +417,9 @@ impl<'self> Context<'self> {\n      * current lint context, call the provided function, then reset the\n      * lints in effect to their previous state.\n      */\n-    fn with_lint_attrs(&mut self, attrs: &[ast::Attribute],\n-                       f: &fn(&mut Context)) {\n+    fn with_lint_attrs(&mut self,\n+                       attrs: &[ast::Attribute],\n+                       f: |&mut Context|) {\n         // Parse all of the lint attributes, and then add them all to the\n         // current dictionary of lint information. Along the way, keep a history\n         // of what we changed so we can roll everything back after invoking the\n@@ -468,7 +469,7 @@ impl<'self> Context<'self> {\n         }\n     }\n \n-    fn visit_ids(&self, f: &fn(&mut ast_util::IdVisitor<Context>)) {\n+    fn visit_ids(&self, f: |&mut ast_util::IdVisitor<Context>|) {\n         let mut v = ast_util::IdVisitor {\n             operation: self,\n             pass_through_items: false,\n@@ -480,7 +481,8 @@ impl<'self> Context<'self> {\n \n pub fn each_lint(sess: session::Session,\n                  attrs: &[ast::Attribute],\n-                 f: &fn(@ast::MetaItem, level, @str) -> bool) -> bool {\n+                 f: |@ast::MetaItem, level, @str| -> bool)\n+                 -> bool {\n     let xs = [allow, warn, deny, forbid];\n     for &level in xs.iter() {\n         let level_name = level_to_str(level);"}, {"sha": "3220ab08ede44720f183ac3a9eff14fc86f7f35d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -657,7 +657,7 @@ impl Liveness {\n \n     pub fn pat_bindings(&self,\n                         pat: @Pat,\n-                        f: &fn(LiveNode, Variable, Span, NodeId)) {\n+                        f: |LiveNode, Variable, Span, NodeId|) {\n         let def_map = self.tcx.def_map;\n         do pat_util::pat_bindings(def_map, pat) |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n@@ -668,7 +668,7 @@ impl Liveness {\n \n     pub fn arm_pats_bindings(&self,\n                              pats: &[@Pat],\n-                             f: &fn(LiveNode, Variable, Span, NodeId)) {\n+                             f: |LiveNode, Variable, Span, NodeId|) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n         // the \"authoratative\" set of ids\n@@ -729,7 +729,7 @@ impl Liveness {\n         self.assigned_on_entry(self.successors[*ln], var)\n     }\n \n-    pub fn indices(&self, ln: LiveNode, op: &fn(uint)) {\n+    pub fn indices(&self, ln: LiveNode, op: |uint|) {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for var_idx in range(0u, self.ir.num_vars) {\n             op(node_base_idx + var_idx)\n@@ -739,7 +739,7 @@ impl Liveness {\n     pub fn indices2(&self,\n                     ln: LiveNode,\n                     succ_ln: LiveNode,\n-                    op: &fn(uint, uint)) {\n+                    op: |uint, uint|) {\n         let node_base_idx = self.idx(ln, Variable(0u));\n         let succ_base_idx = self.idx(succ_ln, Variable(0u));\n         for var_idx in range(0u, self.ir.num_vars) {\n@@ -750,7 +750,7 @@ impl Liveness {\n     pub fn write_vars(&self,\n                       wr: &mut io::Writer,\n                       ln: LiveNode,\n-                      test: &fn(uint) -> LiveNode) {\n+                      test: |uint| -> LiveNode) {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for var_idx in range(0u, self.ir.num_vars) {\n             let idx = node_base_idx + var_idx;\n@@ -1406,12 +1406,13 @@ impl Liveness {\n         cond_ln\n     }\n \n-    pub fn with_loop_nodes<R>(&self,\n-                              loop_node_id: NodeId,\n-                              break_ln: LiveNode,\n-                              cont_ln: LiveNode,\n-                              f: &fn() -> R)\n-                              -> R {\n+    pub fn with_loop_nodes<R>(\n+                           &self,\n+                           loop_node_id: NodeId,\n+                           break_ln: LiveNode,\n+                           cont_ln: LiveNode,\n+                           f: || -> R)\n+                           -> R {\n       debug!(\"with_loop_nodes: {} {}\", loop_node_id, *break_ln);\n         self.loop_scope.push(loop_node_id);\n         self.break_ln.insert(loop_node_id, break_ln);"}, {"sha": "89e19631dae8a5c514e3658b85d4aa130c06d30c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -63,7 +63,7 @@ pub enum categorization {\n     cat_rvalue(ast::NodeId),           // temporary val, argument is its scope\n     cat_static_item,\n     cat_copied_upvar(CopiedUpvar),     // upvar copied into @fn or ~fn env\n-    cat_stack_upvar(cmt),              // by ref upvar from &fn\n+    cat_stack_upvar(cmt),              // by ref upvar from ||\n     cat_local(ast::NodeId),            // local variable\n     cat_arg(ast::NodeId),              // formal argument\n     cat_deref(cmt, uint, PointerKind), // deref of a ptr\n@@ -822,7 +822,7 @@ impl mem_categorization_ctxt {\n     pub fn cat_pattern(&self,\n                        cmt: cmt,\n                        pat: @ast::Pat,\n-                       op: &fn(cmt, @ast::Pat)) {\n+                       op: |cmt, @ast::Pat|) {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n         //"}, {"sha": "8493a7e00ddbeb916ea5528004cc528458f86a20", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -148,7 +148,7 @@ use syntax::codemap::Span;\n pub enum CaptureMode {\n     CapCopy, // Copy the value into the closure.\n     CapMove, // Move the value into the closure.\n-    CapRef,  // Reference directly from parent stack frame (used by `&fn()`).\n+    CapRef,  // Reference directly from parent stack frame (used by `||`).\n }\n \n #[deriving(Encodable, Decodable)]\n@@ -686,7 +686,7 @@ impl VisitContext {\n         let sigil = ty::ty_closure_sigil(fn_ty);\n         let freevars = freevars::get_freevars(self.tcx, fn_expr_id);\n         if sigil == BorrowedSigil {\n-            // &fn() captures everything by ref\n+            // || captures everything by ref\n             at_vec::from_fn(freevars.len(), |i| {\n                 let fvar = &freevars[i];\n                 CaptureVar {def: fvar.def, span: fvar.span, mode: CapRef}"}, {"sha": "6e5cd2e0bf2d8ea9afb9c97345f60cc585344792", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -70,8 +70,9 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @Pat) -> bool {\n     }\n }\n \n-pub fn pat_bindings(dm: resolve::DefMap, pat: @Pat,\n-                    it: &fn(BindingMode, NodeId, Span, &Path)) {\n+pub fn pat_bindings(dm: resolve::DefMap,\n+                    pat: @Pat,\n+                    it: |BindingMode, NodeId, Span, &Path|) {\n     do walk_pat(pat) |p| {\n         match p.node {\n           PatIdent(binding_mode, ref pth, _) if pat_is_binding(dm, p) => {"}, {"sha": "fdf2e170e32562c19f34d0d808d6a8444cc3658c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -1538,10 +1538,10 @@ impl Resolver {\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self,\n-                                                foreign_item: @foreign_item,\n-                                                parent: ReducedGraphParent,\n-                                                f: &fn(&mut Resolver,\n-                                                       ReducedGraphParent)) {\n+                                            foreign_item: @foreign_item,\n+                                            parent: ReducedGraphParent,\n+                                            f: |&mut Resolver,\n+                                                ReducedGraphParent|) {\n         let name = foreign_item.ident;\n         let is_public = foreign_item.vis == ast::public;\n         let (name_bindings, new_parent) =\n@@ -3331,7 +3331,7 @@ impl Resolver {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope(&mut self, name: Option<Ident>, f: &fn(&mut Resolver)) {\n+    fn with_scope(&mut self, name: Option<Ident>, f: |&mut Resolver|) {\n         let orig_module = self.current_module;\n \n         // Move down in the graph.\n@@ -3692,8 +3692,8 @@ impl Resolver {\n     }\n \n     fn with_type_parameter_rib(&mut self,\n-                                   type_parameters: TypeParameters,\n-                                   f: &fn(&mut Resolver)) {\n+                               type_parameters: TypeParameters,\n+                               f: |&mut Resolver|) {\n         match type_parameters {\n             HasTypeParameters(generics, node_id, initial_index,\n                               rib_kind) => {\n@@ -3735,13 +3735,13 @@ impl Resolver {\n         }\n     }\n \n-    fn with_label_rib(&mut self, f: &fn(&mut Resolver)) {\n+    fn with_label_rib(&mut self, f: |&mut Resolver|) {\n         self.label_ribs.push(@Rib::new(NormalRibKind));\n         f(self);\n         self.label_ribs.pop();\n     }\n \n-    fn with_constant_rib(&mut self, f: &fn(&mut Resolver)) {\n+    fn with_constant_rib(&mut self, f: |&mut Resolver|) {\n         self.value_ribs.push(@Rib::new(ConstantItemRibKind));\n         self.type_ribs.push(@Rib::new(ConstantItemRibKind));\n         f(self);\n@@ -4888,7 +4888,7 @@ impl Resolver {\n         }\n     }\n \n-    fn with_no_errors<T>(&mut self, f: &fn(&mut Resolver) -> T) -> T {\n+    fn with_no_errors<T>(&mut self, f: |&mut Resolver| -> T) -> T {\n         self.emit_errors = false;\n         let rs = f(self);\n         self.emit_errors = true;\n@@ -4901,10 +4901,8 @@ impl Resolver {\n         }\n     }\n \n-    fn find_best_match_for_name(&mut self,\n-                                    name: &str,\n-                                    max_distance: uint)\n-                                    -> Option<@str> {\n+    fn find_best_match_for_name(&mut self, name: &str, max_distance: uint)\n+                                -> Option<@str> {\n         let this = &mut *self;\n \n         let mut maybes: ~[@str] = ~[];"}, {"sha": "92913983d865977c0bf1741835d5e19e5ead147a", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -2066,7 +2066,8 @@ fn mk_binding_alloca(mut bcx: @mut Block,\n                      p_id: ast::NodeId,\n                      path: &ast::Path,\n                      binding_mode: IrrefutablePatternBindingMode,\n-                     populate: &fn(@mut Block, ty::t, ValueRef) -> @mut Block) -> @mut Block {\n+                     populate: |@mut Block, ty::t, ValueRef| -> @mut Block)\n+                     -> @mut Block {\n     let var_ty = node_id_type(bcx, p_id);\n     let ident = ast_util::path_to_ident(path);\n     let llval = alloc_ty(bcx, var_ty, bcx.ident(ident));"}, {"sha": "80b3455e9fa76ada8b04b312f8576900b39da55c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -93,7 +93,7 @@ pub use middle::trans::context::task_llcx;\n \n local_data_key!(task_local_insn_key: ~[&'static str])\n \n-pub fn with_insn_ctxt(blk: &fn(&[&'static str])) {\n+pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n     do local_data::get(task_local_insn_key) |c| {\n         match c {\n             Some(ctx) => blk(*ctx),\n@@ -787,10 +787,11 @@ pub fn cast_shift_const_rhs(op: ast::BinOp,\n }\n \n pub fn cast_shift_rhs(op: ast::BinOp,\n-                      lhs: ValueRef, rhs: ValueRef,\n-                      trunc: &fn(ValueRef, Type) -> ValueRef,\n-                      zext: &fn(ValueRef, Type) -> ValueRef)\n-                   -> ValueRef {\n+                      lhs: ValueRef,\n+                      rhs: ValueRef,\n+                      trunc: |ValueRef, Type| -> ValueRef,\n+                      zext: |ValueRef, Type| -> ValueRef)\n+                      -> ValueRef {\n     // Shifts may have any size int on the rhs\n     unsafe {\n         if ast_util::is_shift_binop(op) {\n@@ -966,7 +967,7 @@ pub fn have_cached_lpad(bcx: @mut Block) -> bool {\n     return res;\n }\n \n-pub fn in_lpad_scope_cx(bcx: @mut Block, f: &fn(si: &mut ScopeInfo)) {\n+pub fn in_lpad_scope_cx(bcx: @mut Block, f: |si: &mut ScopeInfo|) {\n     let mut bcx = bcx;\n     let mut cur_scope = bcx.scope;\n     loop {\n@@ -1430,7 +1431,8 @@ pub fn leave_block(bcx: @mut Block, out_of: @mut Block) -> @mut Block {\n pub fn with_scope(bcx: @mut Block,\n                   opt_node_info: Option<NodeInfo>,\n                   name: &str,\n-                  f: &fn(@mut Block) -> @mut Block) -> @mut Block {\n+                  f: |@mut Block| -> @mut Block)\n+                  -> @mut Block {\n     let _icx = push_ctxt(\"with_scope\");\n \n     debug!(\"with_scope(bcx={}, opt_node_info={:?}, name={})\",\n@@ -1448,7 +1450,8 @@ pub fn with_scope(bcx: @mut Block,\n pub fn with_scope_result(bcx: @mut Block,\n                          opt_node_info: Option<NodeInfo>,\n                          _name: &str,\n-                         f: &fn(@mut Block) -> Result) -> Result {\n+                         f: |@mut Block| -> Result)\n+                         -> Result {\n     let _icx = push_ctxt(\"with_scope_result\");\n \n     let scope = simple_block_scope(bcx.scope, opt_node_info);\n@@ -1462,9 +1465,11 @@ pub fn with_scope_result(bcx: @mut Block,\n     rslt(out_bcx, val)\n }\n \n-pub fn with_scope_datumblock(bcx: @mut Block, opt_node_info: Option<NodeInfo>,\n-                             name: &str, f: &fn(@mut Block) -> datum::DatumBlock)\n-                          -> datum::DatumBlock {\n+pub fn with_scope_datumblock(bcx: @mut Block,\n+                             opt_node_info: Option<NodeInfo>,\n+                             name: &str,\n+                             f: |@mut Block| -> datum::DatumBlock)\n+                             -> datum::DatumBlock {\n     use middle::trans::datum::DatumBlock;\n \n     let _icx = push_ctxt(\"with_scope_result\");\n@@ -1474,7 +1479,7 @@ pub fn with_scope_datumblock(bcx: @mut Block, opt_node_info: Option<NodeInfo>,\n     DatumBlock {bcx: leave_block(bcx, scope_cx), datum: datum}\n }\n \n-pub fn block_locals(b: &ast::Block, it: &fn(@ast::Local)) {\n+pub fn block_locals(b: &ast::Block, it: |@ast::Local|) {\n     for s in b.stmts.iter() {\n         match s.node {\n           ast::StmtDecl(d, _) => {\n@@ -1488,7 +1493,10 @@ pub fn block_locals(b: &ast::Block, it: &fn(@ast::Local)) {\n     }\n }\n \n-pub fn with_cond(bcx: @mut Block, val: ValueRef, f: &fn(@mut Block) -> @mut Block) -> @mut Block {\n+pub fn with_cond(bcx: @mut Block,\n+                 val: ValueRef,\n+                 f: |@mut Block| -> @mut Block)\n+                 -> @mut Block {\n     let _icx = push_ctxt(\"with_cond\");\n     let next_cx = base::sub_block(bcx, \"next\");\n     let cond_cx = base::sub_block(bcx, \"cond\");\n@@ -1885,7 +1893,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                      id: ast::NodeId,\n                      _attributes: &[ast::Attribute],\n                      output_type: ty::t,\n-                     maybe_load_env: &fn(@mut FunctionContext)) {\n+                     maybe_load_env: |@mut FunctionContext|) {\n     ccx.stats.n_closures += 1;\n     let _icx = push_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);"}, {"sha": "ebd7bb6937ef41284b84422d0adfdd3af5f4b125", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -337,9 +337,9 @@ pub fn compute_abi_info(_ccx: &mut CrateContext,\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n     fn x86_64_ty(ty: Type,\n-                 is_mem_cls: &fn(cls: &[RegClass]) -> bool,\n-                 attr: Attribute) -> ArgType {\n-\n+                 is_mem_cls: |cls: &[RegClass]| -> bool,\n+                 attr: Attribute)\n+                 -> ArgType {\n         if !ty.is_reg_ty() {\n             let cls = classify_ty(ty);\n             if is_mem_cls(cls) {"}, {"sha": "d78311c8a398a2dd1a9c5ec3c0cb77b013bcb941", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -600,7 +600,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n                         call_info: Option<NodeInfo>,\n                         callee_ty: ty::t,\n                         ret_ty: ty::t,\n-                        get_callee: &fn(@mut Block) -> Callee,\n+                        get_callee: |@mut Block| -> Callee,\n                         args: CallArgs,\n                         dest: Option<expr::Dest>,\n                         autoref_arg: AutorefArg)"}, {"sha": "baccd9c7028e33b185be6dc366fe94219110931d", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -51,7 +51,7 @@ use syntax::parse::token::special_idents;\n // };\n //\n // Note that the closure is itself a rust_opaque_box.  This is true\n-// even for ~fn and &fn, because we wish to keep binary compatibility\n+// even for ~fn and ||, because we wish to keep binary compatibility\n // between all kinds of closures.  The allocation strategy for this\n // closure depends on the closure type.  For a sendfn, the closure\n // (and the referenced type descriptors) will be allocated in the\n@@ -422,11 +422,12 @@ pub fn trans_expr_fn(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn make_closure_glue(\n-        cx: @mut Block,\n-        v: ValueRef,\n-        t: ty::t,\n-        glue_fn: &fn(@mut Block, v: ValueRef, t: ty::t) -> @mut Block) -> @mut Block {\n+pub fn make_closure_glue(cx: @mut Block,\n+                         v: ValueRef,\n+                         t: ty::t,\n+                         glue_fn: |@mut Block, v: ValueRef, t: ty::t|\n+                                   -> @mut Block)\n+                         -> @mut Block {\n     let _icx = push_ctxt(\"closure::make_closure_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();"}, {"sha": "48602534a3d89e35c0736f3c2730f376e5aadc5b", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -769,7 +769,9 @@ pub fn val_ty(v: ValueRef) -> Type {\n     }\n }\n \n-pub fn in_scope_cx(cx: @mut Block, scope_id: Option<ast::NodeId>, f: &fn(si: &mut ScopeInfo)) {\n+pub fn in_scope_cx(cx: @mut Block,\n+                   scope_id: Option<ast::NodeId>,\n+                   f: |si: &mut ScopeInfo|) {\n     let mut cur = cx;\n     let mut cur_scope = cur.scope;\n     loop {"}, {"sha": "1806dee6c8f2097eb6cbcb278af15dae53097aa9", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -524,7 +524,7 @@ impl Datum {\n                        bcx: @mut Block,\n                        ty: ty::t,\n                        source: DatumCleanup,\n-                       gep: &fn(ValueRef) -> ValueRef)\n+                       gep: |ValueRef| -> ValueRef)\n                        -> Datum {\n         let base_val = self.to_ref_llval(bcx);\n         Datum {"}, {"sha": "676af30b2eeba6b764974edd74c4ebf5c8dbca13", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -2274,9 +2274,9 @@ fn populate_scope_map(cx: &mut CrateContext,\n                       scope_span: Span,\n                       scope_stack: &mut ~[ScopeStackEntry],\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>,\n-                      inner_walk: &fn(&mut CrateContext,\n-                                      &mut ~[ScopeStackEntry],\n-                                      &mut HashMap<ast::NodeId, DIScope>)) {\n+                      inner_walk: |&mut CrateContext,\n+                                   &mut ~[ScopeStackEntry],\n+                                   &mut HashMap<ast::NodeId, DIScope>|) {\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess.codemap.lookup_char_pos(scope_span.lo);\n         let file_metadata = file_metadata(cx, loc.file.name);"}, {"sha": "9d8b539bac83bb453ddbb2c9f727f8ae04b5d5fb", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -1151,10 +1151,12 @@ pub fn trans_local_var(bcx: @mut Block, def: ast::Def) -> Datum {\n // The optional node ID here is the node ID of the path identifying the enum\n // variant in use. If none, this cannot possibly an enum variant (so, if it\n // is and `node_id_opt` is none, this function fails).\n-pub fn with_field_tys<R>(tcx: ty::ctxt,\n-                         ty: ty::t,\n-                         node_id_opt: Option<ast::NodeId>,\n-                         op: &fn(ty::Disr, (&[ty::field])) -> R) -> R {\n+pub fn with_field_tys<R>(\n+                      tcx: ty::ctxt,\n+                      ty: ty::t,\n+                      node_id_opt: Option<ast::NodeId>,\n+                      op: |ty::Disr, (&[ty::field])| -> R)\n+                      -> R {\n     match ty::get(ty).sty {\n         ty::ty_struct(did, ref substs) => {\n             op(0, struct_fields(tcx, did, substs))"}, {"sha": "33036aab65be10153669c9f058781581c2b83b87", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -510,11 +510,13 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n         // Array for the arguments we will pass to the rust function.\n         let mut llrust_args = ~[];\n         let mut next_foreign_arg_counter: c_uint = 0;\n-        let next_foreign_arg: &fn(pad: bool) -> c_uint = {\n-            |pad: bool| {\n-                next_foreign_arg_counter += if pad { 2 } else { 1 };\n-                next_foreign_arg_counter - 1\n-            }\n+        let next_foreign_arg: |pad: bool| -> c_uint = |pad: bool| {\n+            next_foreign_arg_counter += if pad {\n+                2\n+            } else {\n+                1\n+            };\n+            next_foreign_arg_counter - 1\n         };\n \n         // If there is an out pointer on the foreign function"}, {"sha": "b1dc17a12399851b1fcc4c9a6390d8077cdbcca6", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -121,7 +121,7 @@ impl Reflector {\n     pub fn bracketed(&mut self,\n                      bracket_name: &str,\n                      extra: &[ValueRef],\n-                     inner: &fn(&mut Reflector)) {\n+                     inner: |&mut Reflector|) {\n         self.visit(\"enter_\" + bracket_name, extra);\n         inner(self);\n         self.visit(\"leave_\" + bracket_name, extra);"}, {"sha": "2a8db56eec6498d9666586903d4d302d6c99958e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -247,7 +247,7 @@ pub enum AutoRef {\n     /// Convert from @[]/~[]/&[] to &&[] (or str)\n     AutoBorrowVecRef(Region, ast::Mutability),\n \n-    /// Convert from @fn()/~fn()/&fn() to &fn()\n+    /// Convert from @fn()/~fn()/|| to ||\n     AutoBorrowFn(Region),\n \n     /// Convert from T to *T\n@@ -651,7 +651,7 @@ pub enum sty {\n     // \"Fake\" types, used for trans purposes\n     ty_type, // type_desc*\n     ty_opaque_box, // used by monomorphizer to represent any @ box\n-    ty_opaque_closure_ptr(Sigil), // ptr to env for &fn, @fn, ~fn\n+    ty_opaque_closure_ptr(Sigil), // ptr to env for ||, @fn, ~fn\n     ty_unboxed_vec(mt),\n }\n \n@@ -1348,11 +1348,11 @@ pub fn mk_opaque_closure_ptr(cx: ctxt, sigil: ast::Sigil) -> t {\n \n pub fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n \n-pub fn walk_ty(ty: t, f: &fn(t)) {\n+pub fn walk_ty(ty: t, f: |t|) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n \n-pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n+pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n     if !f(ty) {\n         return;\n     }\n@@ -1382,25 +1382,19 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n }\n \n // Folds types from the bottom up.\n-pub fn fold_ty(cx: ctxt, t0: t, fldop: &fn(t) -> t) -> t {\n+pub fn fold_ty(cx: ctxt, t0: t, fldop: |t| -> t) -> t {\n     let mut f = ty_fold::BottomUpFolder {tcx: cx, fldop: fldop};\n     f.fold_ty(t0)\n }\n \n-pub fn walk_regions_and_ty(cx: ctxt,\n-                           ty: t,\n-                           fldr: &fn(r: Region),\n-                           fldt: &fn(t: t))\n+pub fn walk_regions_and_ty(cx: ctxt, ty: t, fldr: |r: Region|, fldt: |t: t|)\n                            -> t {\n     ty_fold::RegionFolder::general(cx,\n                                    |r| { fldr(r); r },\n                                    |t| { fldt(t); t }).fold_ty(ty)\n }\n \n-pub fn fold_regions(cx: ctxt,\n-                    ty: t,\n-                    fldr: &fn(r: Region) -> Region)\n-                    -> t {\n+pub fn fold_regions(cx: ctxt, ty: t, fldr: |r: Region| -> Region) -> t {\n     ty_fold::RegionFolder::regions(cx, fldr).fold_ty(ty)\n }\n \n@@ -1886,7 +1880,7 @@ impl TypeContents {\n             *self & TC::ReachesAll)\n     }\n \n-    pub fn union<T>(v: &[T], f: &fn(&T) -> TypeContents) -> TypeContents {\n+    pub fn union<T>(v: &[T], f: |&T| -> TypeContents) -> TypeContents {\n         v.iter().fold(TC::None, |tc, t| tc | f(t))\n     }\n \n@@ -2223,7 +2217,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         fn each_inherited_builtin_bound(cx: ctxt,\n                                         bounds: BuiltinBounds,\n                                         traits: &[@TraitRef],\n-                                        f: &fn(BuiltinBound)) {\n+                                        f: |BuiltinBound|) {\n             for bound in bounds.iter() {\n                 f(bound);\n             }\n@@ -2351,10 +2345,8 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n     !subtypes_require(cx, &mut seen, r_ty, r_ty)\n }\n \n-pub fn type_structurally_contains(cx: ctxt,\n-                                  ty: t,\n-                                  test: &fn(x: &sty) -> bool)\n-                               -> bool {\n+pub fn type_structurally_contains(cx: ctxt, ty: t, test: |x: &sty| -> bool)\n+                                  -> bool {\n     let sty = &get(ty).sty;\n     debug!(\"type_structurally_contains: {}\",\n            ::util::ppaux::ty_to_str(cx, ty));\n@@ -2969,7 +2961,7 @@ pub fn adjust_ty(cx: ctxt,\n }\n \n impl AutoRef {\n-    pub fn map_region(&self, f: &fn(Region) -> Region) -> AutoRef {\n+    pub fn map_region(&self, f: |Region| -> Region) -> AutoRef {\n         match *self {\n             ty::AutoPtr(r, m) => ty::AutoPtr(f(r), m),\n             ty::AutoBorrowVec(r, m) => ty::AutoBorrowVec(f(r), m),\n@@ -3525,11 +3517,10 @@ pub fn trait_ref_supertraits(cx: ctxt, trait_ref: &ty::TraitRef) -> ~[@TraitRef]\n }\n \n fn lookup_locally_or_in_crate_store<V:Clone>(\n-    descr: &str,\n-    def_id: ast::DefId,\n-    map: &mut HashMap<ast::DefId, V>,\n-    load_external: &fn() -> V) -> V\n-{\n+                                    descr: &str,\n+                                    def_id: ast::DefId,\n+                                    map: &mut HashMap<ast::DefId, V>,\n+                                    load_external: || -> V) -> V {\n     /*!\n      * Helper for looking things up in the various maps\n      * that are populated during typeck::collect (e.g.,\n@@ -3961,7 +3952,7 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n /// Iterate over meta_items of a definition.\n // (This should really be an iterator, but that would require csearch and\n // decoder to use iterators instead of higher-order functions.)\n-pub fn each_attr(tcx: ctxt, did: DefId, f: &fn(@MetaItem) -> bool) -> bool {\n+pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n     if is_local(did) {\n         match tcx.items.find(&did.node) {\n             Some(&ast_map::node_item(@ast::item {attrs: ref attrs, _}, _)) =>\n@@ -4341,7 +4332,8 @@ pub fn determine_inherited_purity(parent: (ast::purity, ast::NodeId),\n // list.\n pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n                                         bounds: &[@TraitRef],\n-                                        f: &fn(@TraitRef) -> bool) -> bool {\n+                                        f: |@TraitRef| -> bool)\n+                                        -> bool {\n     for &bound_trait_ref in bounds.iter() {\n         let mut supertrait_set = HashMap::new();\n         let mut trait_refs = ~[];"}, {"sha": "7feb82788fc449e41699430e3e23da9d33f5c772", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -33,7 +33,7 @@\n  * scopes and (b) the default region may change.  To understand case (a),\n  * consider something like:\n  *\n- *   type foo = { x: &a.int, y: &fn(&a.int) }\n+ *   type foo = { x: &a.int, y: |&a.int| }\n  *\n  * The type of `x` is an error because there is no region `a` in scope.\n  * In the type of `y`, however, region `a` is considered a bound region\n@@ -290,13 +290,14 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n     // Handle @, ~, and & being able to mean estrs and evecs.\n     // If a_seq_ty is a str or a vec, make it an estr/evec.\n     // Also handle first-class trait types.\n-    fn mk_pointer<AC:AstConv,RS:RegionScope>(\n-        this: &AC,\n-        rscope: &RS,\n-        a_seq_ty: &ast::mt,\n-        vst: ty::vstore,\n-        constr: &fn(ty::mt) -> ty::t) -> ty::t\n-    {\n+    fn mk_pointer<AC:AstConv,\n+                  RS:RegionScope>(\n+                  this: &AC,\n+                  rscope: &RS,\n+                  a_seq_ty: &ast::mt,\n+                  vst: ty::vstore,\n+                  constr: |ty::mt| -> ty::t)\n+                  -> ty::t {\n         let tcx = this.tcx();\n         debug!(\"mk_pointer(vst={:?})\", vst);\n \n@@ -715,7 +716,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n                     ty::ReStatic\n                 }\n                 ast::BorrowedSigil => {\n-                    // &fn() defaults as normal for an omitted lifetime:\n+                    // || defaults as normal for an omitted lifetime:\n                     opt_ast_region_to_region(this, rscope, span, opt_lifetime)\n                 }\n             }"}, {"sha": "0785ba002aacbc59d021f966bb9ce48b84919136", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -655,7 +655,7 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n                          span: Span,\n                          expected: ty::t) {\n     let fcx = pcx.fcx;\n-    let check_inner: &fn(ty::mt) = |e_inner| {\n+    let check_inner: |ty::mt| = |e_inner| {\n         check_pat(pcx, inner, e_inner.ty);\n         fcx.write_ty(pat_id, expected);\n     };"}, {"sha": "5973d791f525cb4131319d27ac9c0606be0a982a", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -31,9 +31,11 @@ pub fn subtype(fcx: @mut FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n }\n \n pub fn suptype_with_fn(fcx: @mut FnCtxt,\n-                       sp: Span, b_is_expected: bool,\n-                       ty_a: ty::t, ty_b: ty::t,\n-                       handle_err: &fn(Span, ty::t, ty::t, &ty::type_err)) {\n+                       sp: Span,\n+                       b_is_expected: bool,\n+                       ty_a: ty::t,\n+                       ty_b: ty::t,\n+                       handle_err: |Span, ty::t, ty::t, &ty::type_err|) {\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), b_is_expected, infer::Misc(sp),\n                           ty_b, ty_a) {"}, {"sha": "8eaf3824ff40804c4c86c8d33f31c9ef5152a39a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -483,12 +483,13 @@ impl<'self> LookupContext<'self> {\n \n     // Do a search through a list of bounds, using a callback to actually\n     // create the candidates.\n-    fn push_inherent_candidates_from_bounds_inner(\n-        &self,\n-        bounds: &[@TraitRef],\n-        mk_cand: &fn(trait_ref: @TraitRef, m: @ty::Method, method_num: uint,\n-                     bound_num: uint) -> Candidate) {\n-\n+    fn push_inherent_candidates_from_bounds_inner(&self,\n+                                                  bounds: &[@TraitRef],\n+                                                  mk_cand: |tr: @TraitRef,\n+                                                            m: @ty::Method,\n+                                                            method_num: uint,\n+                                                            bound_num: uint|\n+                                                            -> Candidate) {\n         let tcx = self.tcx();\n         let mut next_bound_idx = 0; // count only trait bounds\n \n@@ -783,12 +784,12 @@ impl<'self> LookupContext<'self> {\n     }\n \n     fn search_for_some_kind_of_autorefd_method(\n-        &self,\n-        kind: &fn(Region, ast::Mutability) -> ty::AutoRef,\n-        autoderefs: uint,\n-        mutbls: &[ast::Mutability],\n-        mk_autoref_ty: &fn(ast::Mutability, ty::Region) -> ty::t)\n-        -> Option<method_map_entry> {\n+            &self,\n+            kind: |Region, ast::Mutability| -> ty::AutoRef,\n+            autoderefs: uint,\n+            mutbls: &[ast::Mutability],\n+            mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n+            -> Option<method_map_entry> {\n         // This is hokey. We should have mutability inference as a\n         // variable.  But for now, try &const, then &, then &mut:\n         let region ="}, {"sha": "8d643ef220042866f839223f7127d0bc67ea64e5", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -1194,7 +1194,7 @@ impl FnCtxt {\n \n     pub fn opt_node_ty_substs(&self,\n                               id: ast::NodeId,\n-                              f: &fn(&ty::substs) -> bool)\n+                              f: |&ty::substs| -> bool)\n                               -> bool {\n         match self.inh.node_type_substs.find(&id) {\n             Some(s) => f(s),\n@@ -1257,8 +1257,7 @@ impl FnCtxt {\n         infer::mk_subr(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n-    pub fn with_region_lb<R>(@mut self, lb: ast::NodeId, f: &fn() -> R)\n-                             -> R {\n+    pub fn with_region_lb<R>(@mut self, lb: ast::NodeId, f: || -> R) -> R {\n         let old_region_lb = self.region_lb;\n         self.region_lb = lb;\n         let v = f();\n@@ -1268,7 +1267,7 @@ impl FnCtxt {\n \n     pub fn type_error_message(&self,\n                               sp: Span,\n-                              mk_msg: &fn(~str) -> ~str,\n+                              mk_msg: |~str| -> ~str,\n                               actual_ty: ty::t,\n                               err: Option<&ty::type_err>) {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n@@ -1629,7 +1628,7 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                expr: @ast::Expr,\n                                expected: Option<ty::t>,\n-                               unifier: &fn()) {\n+                               unifier: ||) {\n     debug!(\">> typechecking\");\n \n     fn check_method_argument_types(\n@@ -2014,7 +2013,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         args: ~[@ast::Expr],\n                         deref_args: DerefArgs,\n                         autoderef_receiver: AutoderefReceiverFlag,\n-                        unbound_method: &fn(),\n+                        unbound_method: ||,\n                         _expected_result: Option<ty::t>\n                        )\n                      -> ty::t {\n@@ -2198,10 +2197,11 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     // through the `unpack` function.  It there is no expected type or\n     // resolution is not possible (e.g., no constraints yet present), just\n     // returns `none`.\n-    fn unpack_expected<O>(fcx: @mut FnCtxt,\n-                          expected: Option<ty::t>,\n-                          unpack: &fn(&ty::sty) -> Option<O>)\n-                          -> Option<O> {\n+    fn unpack_expected<O>(\n+                       fcx: @mut FnCtxt,\n+                       expected: Option<ty::t>,\n+                       unpack: |&ty::sty| -> Option<O>)\n+                       -> Option<O> {\n         match expected {\n             Some(t) => {\n                 match resolve_type(fcx.infcx(), t, force_tvar) {"}, {"sha": "ebdd4b5f48c2fef426b1d5d33eeb76c8eb77a109", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -20,12 +20,11 @@ use util::ppaux;\n // Helper functions related to manipulating region types.\n \n pub fn replace_bound_regions_in_fn_sig(\n-    tcx: ty::ctxt,\n-    opt_self_ty: Option<ty::t>,\n-    fn_sig: &ty::FnSig,\n-    mapf: &fn(ty::BoundRegion) -> ty::Region)\n-    -> (HashMap<ty::BoundRegion,ty::Region>, Option<ty::t>, ty::FnSig)\n-{\n+        tcx: ty::ctxt,\n+        opt_self_ty: Option<ty::t>,\n+        fn_sig: &ty::FnSig,\n+        mapf: |ty::BoundRegion| -> ty::Region)\n+        -> (HashMap<ty::BoundRegion,ty::Region>, Option<ty::t>, ty::FnSig) {\n     debug!(\"replace_bound_regions_in_fn_sig(self_ty={}, fn_sig={})\",\n             opt_self_ty.repr(tcx),\n             fn_sig.repr(tcx));\n@@ -47,12 +46,10 @@ pub fn replace_bound_regions_in_fn_sig(\n     (map, opt_self_ty, fn_sig)\n }\n \n-pub fn relate_nested_regions(\n-    tcx: ty::ctxt,\n-    opt_region: Option<ty::Region>,\n-    ty: ty::t,\n-    relate_op: &fn(ty::Region, ty::Region))\n-{\n+pub fn relate_nested_regions(tcx: ty::ctxt,\n+                             opt_region: Option<ty::Region>,\n+                             ty: ty::t,\n+                             relate_op: |ty::Region, ty::Region|) {\n     /*!\n      * This rather specialized function walks each region `r` that appear\n      * in `ty` and invokes `relate_op(r_encl, r)` for each one.  `r_encl`"}, {"sha": "78aa3f8fe40777a2a4ca50b1d5fb0eb055a9c5bf", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -451,7 +451,7 @@ impl CoherenceChecker {\n         }\n     }\n \n-    pub fn iter_impls_of_trait(&self, trait_def_id: DefId, f: &fn(@Impl)) {\n+    pub fn iter_impls_of_trait(&self, trait_def_id: DefId, f: |@Impl|) {\n         match self.crate_context.tcx.trait_impls.find(&trait_def_id) {\n             Some(impls) => {\n                 for &im in impls.iter() {"}, {"sha": "e2ea08244006dbe9fc4c8a0a72d01f181737ff97", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -161,9 +161,7 @@ impl Coerce {\n         }\n     }\n \n-    pub fn unpack_actual_value(&self,\n-                               a: ty::t,\n-                               f: &fn(&ty::sty) -> CoerceResult)\n+    pub fn unpack_actual_value(&self, a: ty::t, f: |&ty::sty| -> CoerceResult)\n                                -> CoerceResult {\n         match resolve_type(self.infcx, a, try_resolve_tvar_shallow) {\n             Ok(t) => {"}, {"sha": "af7a23a4dfcdcac94d6e33eed6b60a40b639b21d", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -196,7 +196,7 @@ impl Combine for Glb {\n             // NB---I do not believe this algorithm computes\n             // (necessarily) the GLB.  As written it can\n             // spuriously fail.  In particular, if there is a case\n-            // like: &fn(fn(&a)) and fn(fn(&b)), where a and b are\n+            // like: |fn(&a)| and fn(fn(&b)), where a and b are\n             // free, it will return fn(&c) where c = GLB(a,b).  If\n             // however this GLB is not defined, then the result is\n             // an error, even though something like"}, {"sha": "cde9dd135b3116db09958baecfb41929a5ef1e03", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -442,12 +442,12 @@ pub fn resolve_region(cx: @mut InferCtxt, r: ty::Region, modes: uint)\n }\n \n trait then {\n-    fn then<T:Clone>(&self, f: &fn() -> Result<T,ty::type_err>)\n+    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err>;\n }\n \n impl then for ures {\n-    fn then<T:Clone>(&self, f: &fn() -> Result<T,ty::type_err>)\n+    fn then<T:Clone>(&self, f: || -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err> {\n         self.and_then(|_i| f())\n     }\n@@ -467,11 +467,11 @@ impl<T> ToUres for cres<T> {\n }\n \n trait CresCompare<T> {\n-    fn compare(&self, t: T, f: &fn() -> ty::type_err) -> cres<T>;\n+    fn compare(&self, t: T, f: || -> ty::type_err) -> cres<T>;\n }\n \n impl<T:Clone + Eq> CresCompare<T> for cres<T> {\n-    fn compare(&self, t: T, f: &fn() -> ty::type_err) -> cres<T> {\n+    fn compare(&self, t: T, f: || -> ty::type_err) -> cres<T> {\n         do (*self).clone().and_then |s| {\n             if s == t {\n                 (*self).clone()\n@@ -549,7 +549,7 @@ impl InferCtxt {\n     }\n \n     /// Execute `f` and commit the bindings if successful\n-    pub fn commit<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    pub fn commit<T,E>(@mut self, f: || -> Result<T,E>) -> Result<T,E> {\n         assert!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n@@ -564,7 +564,7 @@ impl InferCtxt {\n     }\n \n     /// Execute `f`, unroll bindings on failure\n-    pub fn try<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    pub fn try<T,E>(@mut self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n         let snapshot = self.start_snapshot();\n         let r = f();\n@@ -579,7 +579,7 @@ impl InferCtxt {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    pub fn probe<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n+    pub fn probe<T,E>(@mut self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"probe()\");\n         do indent {\n             let snapshot = self.start_snapshot();\n@@ -721,17 +721,17 @@ impl InferCtxt {\n     // errors.\n     pub fn type_error_message_str(@mut self,\n                                   sp: Span,\n-                                  mk_msg: &fn(Option<~str>, ~str) -> ~str,\n+                                  mk_msg: |Option<~str>, ~str| -> ~str,\n                                   actual_ty: ~str,\n                                   err: Option<&ty::type_err>) {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n     }\n \n     pub fn type_error_message_str_with_expected(@mut self,\n                                                 sp: Span,\n-                                                mk_msg:\n-                                                &fn(Option<~str>, ~str) ->\n-                                                ~str,\n+                                                mk_msg: |Option<~str>,\n+                                                         ~str|\n+                                                         -> ~str,\n                                                 expected_ty: Option<ty::t>,\n                                                 actual_ty: ~str,\n                                                 err: Option<&ty::type_err>) {\n@@ -760,7 +760,7 @@ impl InferCtxt {\n \n     pub fn type_error_message(@mut self,\n                               sp: Span,\n-                              mk_msg: &fn(~str) -> ~str,\n+                              mk_msg: |~str| -> ~str,\n                               actual_ty: ty::t,\n                               err: Option<&ty::type_err>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n@@ -813,11 +813,10 @@ impl InferCtxt {\n     }\n }\n \n-pub fn fold_regions_in_sig(\n-    tcx: ty::ctxt,\n-    fn_sig: &ty::FnSig,\n-    fldr: &fn(r: ty::Region) -> ty::Region) -> ty::FnSig\n-{\n+pub fn fold_regions_in_sig(tcx: ty::ctxt,\n+                           fn_sig: &ty::FnSig,\n+                           fldr: |r: ty::Region| -> ty::Region)\n+                           -> ty::FnSig {\n     ty_fold::RegionFolder::regions(tcx, fldr).fold_sig(fn_sig)\n }\n "}, {"sha": "2b99a0a4f0ef45e8d18b9bf99a70a06599b113e2", "filename": "src/librustc/middle/typeck/infer/region_inference/doc.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -389,7 +389,7 @@ The problem we are addressing is that there is a kind of subtyping\n between functions with bound region parameters.  Consider, for\n example, whether the following relation holds:\n \n-    fn(&'a int) <: &fn(&'b int)? (Yes, a => b)\n+    fn(&'a int) <: |&'b int|? (Yes, a => b)\n \n The answer is that of course it does.  These two types are basically\n the same, except that in one we used the name `a` and one we used\n@@ -406,7 +406,7 @@ Now let's consider two more function types.  Here, we assume that the\n `self` lifetime is defined somewhere outside and hence is not a\n lifetime parameter bound by the function type (it \"appears free\"):\n \n-    fn<a>(&'a int) <: &fn(&'self int)? (Yes, a => self)\n+    fn<a>(&'a int) <: |&'self int|? (Yes, a => self)\n \n This subtyping relation does in fact hold.  To see why, you have to\n consider what subtyping means.  One way to look at `T1 <: T2` is to\n@@ -423,7 +423,7 @@ to the same thing: a function that accepts pointers with any lifetime\n \n So, what if we reverse the order of the two function types, like this:\n \n-    fn(&'self int) <: &fn<a>(&'a int)? (No)\n+    fn(&'self int) <: <a>|&'a int|? (No)\n \n Does the subtyping relationship still hold?  The answer of course is\n no.  In this case, the function accepts *only the lifetime `&self`*,\n@@ -432,8 +432,8 @@ accepted any lifetime.\n \n What about these two examples:\n \n-    fn<a,b>(&'a int, &'b int) <: &fn<a>(&'a int, &'a int)? (Yes)\n-    fn<a>(&'a int, &'a int) <: &fn<a,b>(&'a int, &'b int)? (No)\n+    fn<a,b>(&'a int, &'b int) <: <a>|&'a int, &'a int|? (Yes)\n+    fn<a>(&'a int, &'a int) <: <a,b>|&'a int, &'b int|? (No)\n \n Here, it is true that functions which take two pointers with any two\n lifetimes can be treated as if they only accepted two pointers with\n@@ -457,12 +457,12 @@ Let's walk through some examples and see how this algorithm plays out.\n \n We'll start with the first example, which was:\n \n-    1. fn<a>(&'a T) <: &fn<b>(&'b T)?        Yes: a -> b\n+    1. fn<a>(&'a T) <: <b>|&'b T|?        Yes: a -> b\n \n After steps 1 and 2 of the algorithm we will have replaced the types\n like so:\n \n-    1. fn(&'A T) <: &fn(&'x T)?\n+    1. fn(&'A T) <: |&'x T|?\n \n Here the upper case `&A` indicates a *region variable*, that is, a\n region whose value is being inferred by the system.  I also replaced\n@@ -491,12 +491,12 @@ So far we have encountered no error, so the subtype check succeeds.\n \n Now let's look first at the third example, which was:\n \n-    3. fn(&'self T)    <: &fn<b>(&'b T)?        No!\n+    3. fn(&'self T)    <: <b>|&'b T|?        No!\n \n After steps 1 and 2 of the algorithm we will have replaced the types\n like so:\n \n-    3. fn(&'self T) <: &fn(&'x T)?\n+    3. fn(&'self T) <: |&'x T|?\n \n This looks pretty much the same as before, except that on the LHS\n `&self` was not bound, and hence was left as-is and not replaced with\n@@ -511,7 +511,7 @@ You may be wondering about that mysterious last step in the algorithm.\n So far it has not been relevant.  The purpose of that last step is to\n catch something like *this*:\n \n-    fn<a>() -> fn(&'a T) <: &fn() -> fn<b>(&'b T)?   No.\n+    fn<a>() -> fn(&'a T) <: || -> fn<b>(&'b T)?   No.\n \n Here the function types are the same but for where the binding occurs.\n The subtype returns a function that expects a value in precisely one\n@@ -525,15 +525,15 @@ So let's step through what happens when we perform this subtype check.\n We first replace the bound regions in the subtype (the supertype has\n no bound regions).  This gives us:\n \n-    fn() -> fn(&'A T) <: &fn() -> fn<b>(&'b T)?\n+    fn() -> fn(&'A T) <: || -> fn<b>(&'b T)?\n \n Now we compare the return types, which are covariant, and hence we have:\n \n-    fn(&'A T) <: &fn<b>(&'b T)?\n+    fn(&'A T) <: <b>|&'b T|?\n \n Here we skolemize the bound region in the supertype to yield:\n \n-    fn(&'A T) <: &fn(&'x T)?\n+    fn(&'A T) <: |&'x T|?\n \n And then proceed to compare the argument types:\n \n@@ -550,7 +550,7 @@ The difference between this example and the first one is that the variable\n `A` already existed at the point where the skolemization occurred.  In\n the first example, you had two functions:\n \n-    fn<a>(&'a T) <: &fn<b>(&'b T)\n+    fn<a>(&'a T) <: <b>|&'b T|\n \n and hence `&A` and `&x` were created \"together\".  In general, the\n intention of the skolemized names is that they are supposed to be"}, {"sha": "ff4b20d369b6f5bea46cfb44bcd96ec45f568ded", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -359,9 +359,9 @@ impl RegionVarBindings {\n                         a: Region,\n                         b: Region,\n                         origin: SubregionOrigin,\n-                        relate: &fn(this: &mut RegionVarBindings,\n-                                    old_r: Region,\n-                                    new_r: Region))\n+                        relate: |this: &mut RegionVarBindings,\n+                                 old_r: Region,\n+                                 new_r: Region|)\n                         -> Region {\n         let vars = TwoRegions { a: a, b: b };\n         match self.combine_map(t).find(&vars) {\n@@ -1254,7 +1254,7 @@ impl RegionVarBindings {\n \n     fn iterate_until_fixed_point(&self,\n                                  tag: &str,\n-                                 body: &fn(constraint: &Constraint) -> bool) {\n+                                 body: |constraint: &Constraint| -> bool) {\n         let mut iteration = 0;\n         let mut changed = true;\n         while changed {"}, {"sha": "ed2b1d1db4b5a69f33547e6f4acec69c9032b650", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -282,15 +282,14 @@ pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n     }\n }\n \n-pub fn require_same_types(\n-    tcx: ty::ctxt,\n-    maybe_infcx: Option<@mut infer::InferCtxt>,\n-    t1_is_expected: bool,\n-    span: Span,\n-    t1: ty::t,\n-    t2: ty::t,\n-    msg: &fn() -> ~str) -> bool {\n-\n+pub fn require_same_types(tcx: ty::ctxt,\n+                          maybe_infcx: Option<@mut infer::InferCtxt>,\n+                          t1_is_expected: bool,\n+                          span: Span,\n+                          t1: ty::t,\n+                          t2: ty::t,\n+                          msg: || -> ~str)\n+                          -> bool {\n     let l_tcx;\n     let l_infcx;\n     match maybe_infcx {"}, {"sha": "985bcaf96d17e93f5448c161240a39d806beed48", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -150,8 +150,8 @@ constraints will be satisfied.\n As a simple example, consider:\n \n     enum Option<A> { Some(A), None }\n-    enum OptionalFn<B> { Some(&fn(B)), None }\n-    enum OptionalMap<C> { Some(&fn(C) -> C), None }\n+    enum OptionalFn<B> { Some(|B|), None }\n+    enum OptionalMap<C> { Some(|C| -> C), None }\n \n Here, we will generate the constraints:\n "}, {"sha": "ffbea94c4774bfa5381d6d4b47ee13aee56b2c75", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -17,7 +17,7 @@ use syntax::visit::Visitor;\n use std::hashmap::HashSet;\n use extra;\n \n-pub fn time<T, U>(do_it: bool, what: &str, u: U, f: &fn(U) -> T) -> T {\n+pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n     if !do_it { return f(u); }\n     let start = extra::time::precise_time_s();\n     let rv = f(u);\n@@ -26,7 +26,7 @@ pub fn time<T, U>(do_it: bool, what: &str, u: U, f: &fn(U) -> T) -> T {\n     rv\n }\n \n-pub fn indent<R>(op: &fn() -> R) -> R {\n+pub fn indent<R>(op: || -> R) -> R {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`\n     // to make debug output more readable.\n     debug!(\">>\");\n@@ -79,7 +79,7 @@ impl<'self> Visitor<()> for LoopQueryVisitor<'self> {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn loop_query(b: &ast::Block, p: &fn(&ast::Expr_) -> bool) -> bool {\n+pub fn loop_query(b: &ast::Block, p: |&ast::Expr_| -> bool) -> bool {\n     let mut v = LoopQueryVisitor {\n         p: p,\n         flag: false,\n@@ -102,7 +102,7 @@ impl<'self> Visitor<()> for BlockQueryVisitor<'self> {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query(b: &ast::Block, p: &fn(@ast::Expr) -> bool) -> bool {\n+pub fn block_query(b: &ast::Block, p: |@ast::Expr| -> bool) -> bool {\n     let mut v = BlockQueryVisitor {\n         p: p,\n         flag: false,"}, {"sha": "0364eb890fbb9876a129f686cbfadec1e1c31ede", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e3f20133a0f38e4f18dce9992d1b4c13215f91f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=7e3f20133a0f38e4f18dce9992d1b4c13215f91f", "patch": "@@ -286,7 +286,7 @@ pub fn vstore_ty_to_str(cx: ctxt, mt: &mt, vs: ty::vstore) -> ~str {\n     }\n }\n \n-pub fn vec_map_to_str<T>(ts: &[T], f: &fn(t: &T) -> ~str) -> ~str {\n+pub fn vec_map_to_str<T>(ts: &[T], f: |t: &T| -> ~str) -> ~str {\n     let tstrs = ts.map(f);\n     format!(\"[{}]\", tstrs.connect(\", \"))\n }"}]}