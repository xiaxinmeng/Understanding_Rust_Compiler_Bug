{"sha": "f8d1c3589e51061a3999e8de3bf59aeccfc06f5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ZDFjMzU4OWU1MTA2MWEzOTk5ZThkZTNiZjU5YWVjY2ZjMDZmNWM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-20T23:39:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-20T23:39:13Z"}, "message": "Rollup merge of #65592 - RalfJung:const-prop-comment, r=wesleywiser\n\nclarify const_prop ICE protection comment\n\nThis is based on discussion at https://github.com/rust-lang/rust/pull/64890/files#r334555787.\n\nThat said, why are function arguments the only unsized locals that could remain uninitialized? Couldn't we also fail to initialize some local but still go on with const_prop, and then hit a line that takes a reference to that? Cc @wesleywiser @oli-obk ; I don't know enough about const-prop to understand why this can happen only for function arguments.\n\n~~The PR includes https://github.com/rust-lang/rust/pull/64890; the only new commit is 05e4e6ba0d5.~~", "tree": {"sha": "21c587fabf04ab05cfb14d86fea744502ba11e79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21c587fabf04ab05cfb14d86fea744502ba11e79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8d1c3589e51061a3999e8de3bf59aeccfc06f5c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdrPAhCRBK7hj4Ov3rIwAAdHIIAFSQ4Qq6mYW9NZPjTfbMVD4M\nyHA+/vGjkf07Ku9CCBPW7bpCECDYDqBxZ6OYwXU8M8pUTHALWEX3bbjNHWADN5iv\nP0smhrjBIHPK8jORLHb3gCkmQVEHT49kqR9laUIBFQdnfVh04fhN2+W3UnQSI0bO\nkqJIYE8CM6fypv5OYBSYm9tuqtCZHYxucWDtjOX9XqJytoVFvTCsrMspQIz05ciu\nBYyKD2EaUM3q3l9V4vjkyE1vxbbRov0bgwxovXnKgeIES/S/YNCXS8d1/H5l/PrM\npHlVo/vhmnlpORodfv4sfG777NQ/CJxAIW+b2AhtYf37FcokcfdD/2M9XG24Wdk=\n=os59\n-----END PGP SIGNATURE-----\n", "payload": "tree 21c587fabf04ab05cfb14d86fea744502ba11e79\nparent 194d1935d393c635b620cf82bd299868e7bddce1\nparent f907fbe1a6676a26cfc893b78f0fffb4285f1e6c\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1571614753 +0200\ncommitter GitHub <noreply@github.com> 1571614753 +0200\n\nRollup merge of #65592 - RalfJung:const-prop-comment, r=wesleywiser\n\nclarify const_prop ICE protection comment\n\nThis is based on discussion at https://github.com/rust-lang/rust/pull/64890/files#r334555787.\n\nThat said, why are function arguments the only unsized locals that could remain uninitialized? Couldn't we also fail to initialize some local but still go on with const_prop, and then hit a line that takes a reference to that? Cc @wesleywiser @oli-obk ; I don't know enough about const-prop to understand why this can happen only for function arguments.\n\n~~The PR includes https://github.com/rust-lang/rust/pull/64890; the only new commit is 05e4e6ba0d5.~~\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8d1c3589e51061a3999e8de3bf59aeccfc06f5c", "html_url": "https://github.com/rust-lang/rust/commit/f8d1c3589e51061a3999e8de3bf59aeccfc06f5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8d1c3589e51061a3999e8de3bf59aeccfc06f5c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "194d1935d393c635b620cf82bd299868e7bddce1", "url": "https://api.github.com/repos/rust-lang/rust/commits/194d1935d393c635b620cf82bd299868e7bddce1", "html_url": "https://github.com/rust-lang/rust/commit/194d1935d393c635b620cf82bd299868e7bddce1"}, {"sha": "f907fbe1a6676a26cfc893b78f0fffb4285f1e6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f907fbe1a6676a26cfc893b78f0fffb4285f1e6c", "html_url": "https://github.com/rust-lang/rust/commit/f907fbe1a6676a26cfc893b78f0fffb4285f1e6c"}], "stats": {"total": 25, "additions": 14, "deletions": 11}, "files": [{"sha": "780b49cd9db0d100751e6738733a54cc08d79feb", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f8d1c3589e51061a3999e8de3bf59aeccfc06f5c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d1c3589e51061a3999e8de3bf59aeccfc06f5c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=f8d1c3589e51061a3999e8de3bf59aeccfc06f5c", "patch": "@@ -518,27 +518,30 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 }\n             }\n \n-            // Work around: avoid ICE in miri.\n-            // FIXME(wesleywiser) we don't currently handle the case where we try to make a ref\n-            // from a function argument that hasn't been assigned to in this function. The main\n-            // issue is if an arg is a fat-pointer, miri `expects()` to be able to read the value\n-            // of that pointer to get size info. However, since this is `ConstProp`, that argument\n-            // doesn't actually have a backing value and so this causes an ICE.\n+            // Work around: avoid ICE in miri. FIXME(wesleywiser)\n+            // The Miri engine ICEs when taking a reference to an uninitialized unsized\n+            // local. There's nothing it can do here: taking a reference needs an allocation\n+            // which needs to know the size. Normally that's okay as during execution\n+            // (e.g. for CTFE) it can never happen. But here in const_prop\n+            // unknown data is uninitialized, so if e.g. a function argument is unsized\n+            // and has a reference taken, we get an ICE.\n             Rvalue::Ref(_, _, Place { base: PlaceBase::Local(local), projection: box [] }) => {\n                 trace!(\"checking Ref({:?})\", place);\n                 let alive =\n                     if let LocalValue::Live(_) = self.ecx.frame().locals[*local].value {\n                         true\n-                    } else { false };\n+                    } else {\n+                        false\n+                    };\n \n-                if local.as_usize() <= self.ecx.frame().body.arg_count && !alive {\n-                    trace!(\"skipping Ref({:?})\", place);\n+                if !alive {\n+                    trace!(\"skipping Ref({:?}) to uninitialized local\", place);\n                     return None;\n                 }\n             }\n \n-            // Work around: avoid extra unnecessary locals.\n-            // FIXME(wesleywiser): const eval will turn this into a `const Scalar(<ZST>)` that\n+            // Work around: avoid extra unnecessary locals. FIXME(wesleywiser)\n+            // Const eval will turn this into a `const Scalar(<ZST>)` that\n             // `SimplifyLocals` doesn't know it can remove.\n             Rvalue::Aggregate(_, operands) if operands.len() == 0 => {\n                 return None;"}]}