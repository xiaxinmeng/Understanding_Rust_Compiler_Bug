{"sha": "2b27d12ce1b3babf4adea41d669140019cb80b8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiMjdkMTJjZTFiM2JhYmY0YWRlYTQxZDY2OTE0MDAxOWNiODBiOGE=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-03-26T04:53:57Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-29T04:13:53Z"}, "message": "Add expr_spawn, spawn parsing, folding, typechecking, ty_task", "tree": {"sha": "c8e113ccede4de3475be1639de445a761b755ae4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8e113ccede4de3475be1639de445a761b755ae4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b27d12ce1b3babf4adea41d669140019cb80b8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b27d12ce1b3babf4adea41d669140019cb80b8a", "html_url": "https://github.com/rust-lang/rust/commit/2b27d12ce1b3babf4adea41d669140019cb80b8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b27d12ce1b3babf4adea41d669140019cb80b8a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db5c809c83815701bb4e629ee52a6de0d480cdd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/db5c809c83815701bb4e629ee52a6de0d480cdd2", "html_url": "https://github.com/rust-lang/rust/commit/db5c809c83815701bb4e629ee52a6de0d480cdd2"}], "stats": {"total": 123, "additions": 107, "deletions": 16}, "files": [{"sha": "8458a749d2062e3a8385dd4fe26f2fdc9b0ba570", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b27d12ce1b3babf4adea41d669140019cb80b8a/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b27d12ce1b3babf4adea41d669140019cb80b8a/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=2b27d12ce1b3babf4adea41d669140019cb80b8a", "patch": "@@ -219,13 +219,19 @@ type arm = rec(@pat pat, block block, hashmap[ident,def_id] index);\n type elt = rec(mutability mut, @expr expr);\n type field = rec(mutability mut, ident ident, @expr expr);\n \n+tag spawn_dom {\n+    dom_implicit;\n+    dom_thread;\n+}\n+\n type expr = spanned[expr_];\n tag expr_ {\n     expr_vec(vec[@expr], mutability, ann);\n     expr_tup(vec[elt], ann);\n     expr_rec(vec[field], option.t[@expr], ann);\n     expr_call(@expr, vec[@expr], ann);\n     expr_bind(@expr, vec[option.t[@expr]], ann);\n+    expr_spawn(spawn_dom, option.t[str], @expr, vec[@expr], ann);\n     expr_binary(binop, @expr, @expr, ann);\n     expr_unary(unop, @expr, ann);\n     expr_lit(@lit, ann);"}, {"sha": "06e22ea88187393fa6875df63fd895dca50eee9e", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2b27d12ce1b3babf4adea41d669140019cb80b8a/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b27d12ce1b3babf4adea41d669140019cb80b8a/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=2b27d12ce1b3babf4adea41d669140019cb80b8a", "patch": "@@ -1333,6 +1333,27 @@ impure fn parse_alt_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, expr);\n }\n \n+impure fn parse_spawn_expr(parser p) -> @ast.expr {\n+    auto lo = p.get_span();\n+    expect(p, token.SPAWN);\n+\n+    // FIXME: Parse domain and name\n+\n+    auto fn_expr = parse_bottom_expr(p);\n+    auto pf = parse_expr;\n+    auto es = parse_seq[@ast.expr](token.LPAREN,\n+                                   token.RPAREN,\n+                                   some(token.COMMA),\n+                                   pf, p);\n+    auto hi = es.span;\n+    auto spawn_expr = ast.expr_spawn(ast.dom_implicit,\n+                                     option.none[str],\n+                                     fn_expr,\n+                                     es.node,\n+                                     ast.ann_none);\n+    ret @spanned(lo, hi, spawn_expr);\n+}\n+\n impure fn parse_expr(parser p) -> @ast.expr {\n     ret parse_expr_res(p, UNRESTRICTED);\n }\n@@ -1367,6 +1388,9 @@ impure fn parse_expr_inner(parser p) -> @ast.expr {\n         case (token.ALT) {\n             ret parse_alt_expr(p);\n         }\n+        case (token.SPAWN) {\n+            ret parse_spawn_expr(p);\n+        }\n         case (_) {\n             ret parse_assign_expr(p);\n         }"}, {"sha": "3756f9876e804ff2cc43cc14bc3eb53a0194570b", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2b27d12ce1b3babf4adea41d669140019cb80b8a/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b27d12ce1b3babf4adea41d669140019cb80b8a/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=2b27d12ce1b3babf4adea41d669140019cb80b8a", "patch": "@@ -90,6 +90,11 @@ type ast_fold[ENV] =\n          @expr f, vec[option.t[@expr]] args,\n          ann a) -> @expr)                         fold_expr_bind,\n \n+     (fn(&ENV e, &span sp,\n+         ast.spawn_dom dom, option.t[str] name,\n+         @expr f, vec[@expr] args,\n+         ann a) -> @expr)                         fold_expr_spawn,\n+\n      (fn(&ENV e, &span sp,\n          ast.binop,\n          @expr lhs, @expr rhs,\n@@ -573,6 +578,12 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_bind(env_, e.span, ff, aargs_opt, t);\n         }\n \n+        case (ast.expr_spawn(?dom, ?name, ?f, ?args, ?t)) {\n+            auto ff = fold_expr(env_, fld, f);\n+            auto aargs = fold_exprs(env_, fld, args);\n+            ret fld.fold_expr_spawn(env_, e.span, dom, name, ff, aargs, t);\n+        }\n+\n         case (ast.expr_binary(?op, ?a, ?b, ?t)) {\n             auto aa = fold_expr(env_, fld, a);\n             auto bb = fold_expr(env_, fld, b);\n@@ -1168,6 +1179,12 @@ fn identity_fold_expr_bind[ENV](&ENV env, &span sp, @expr f,\n     ret @respan(sp, ast.expr_bind(f, args_opt, a));\n }\n \n+fn identity_fold_expr_spawn[ENV](&ENV env, &span sp,\n+                                 ast.spawn_dom dom, option.t[str] name,\n+                                 @expr f, vec[@expr] args, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_spawn(dom, name, f, args, a));\n+}\n+\n fn identity_fold_expr_binary[ENV](&ENV env, &span sp, ast.binop b,\n                                   @expr lhs, @expr rhs,\n                                   ann a) -> @expr {\n@@ -1562,6 +1579,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_expr_rec    = bind identity_fold_expr_rec[ENV](_,_,_,_,_),\n          fold_expr_call   = bind identity_fold_expr_call[ENV](_,_,_,_,_),\n          fold_expr_bind   = bind identity_fold_expr_bind[ENV](_,_,_,_,_),\n+         fold_expr_spawn  = bind identity_fold_expr_spawn[ENV](_,_,_,_,_,_,_),\n          fold_expr_binary = bind identity_fold_expr_binary[ENV](_,_,_,_,_,_),\n          fold_expr_unary  = bind identity_fold_expr_unary[ENV](_,_,_,_,_),\n          fold_expr_lit    = bind identity_fold_expr_lit[ENV](_,_,_,_),"}, {"sha": "f9822d97e55b3aab4c64d6a492b73be7c863b92d", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b27d12ce1b3babf4adea41d669140019cb80b8a/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b27d12ce1b3babf4adea41d669140019cb80b8a/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=2b27d12ce1b3babf4adea41d669140019cb80b8a", "patch": "@@ -42,6 +42,7 @@ tag sty {\n     ty_vec(mt);\n     ty_port(@t);\n     ty_chan(@t);\n+    ty_task;\n     ty_tup(vec[mt]);\n     ty_rec(vec[field]);\n     ty_fn(ast.proto, vec[arg], @t);                 // TODO: effect\n@@ -756,6 +757,8 @@ fn expr_ty(@ast.expr expr) -> @t {\n         case (ast.expr_rec(_, _, ?ann))       { ret ann_to_type(ann); }\n         case (ast.expr_bind(_, _, ?ann))      { ret ann_to_type(ann); }\n         case (ast.expr_call(_, _, ?ann))      { ret ann_to_type(ann); }\n+        case (ast.expr_spawn(_, _, _, _, ?ann))\n+                                              { ret ann_to_type(ann); }\n         case (ast.expr_binary(_, _, _, ?ann)) { ret ann_to_type(ann); }\n         case (ast.expr_unary(_, _, ?ann))     { ret ann_to_type(ann); }\n         case (ast.expr_lit(_, ?ann))          { ret ann_to_type(ann); }"}, {"sha": "cdb61cbd3856a24a606b5abaacc339b696617983", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 56, "deletions": 16, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2b27d12ce1b3babf4adea41d669140019cb80b8a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b27d12ce1b3babf4adea41d669140019cb80b8a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=2b27d12ce1b3babf4adea41d669140019cb80b8a", "patch": "@@ -1750,6 +1750,27 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         ret tup(lhs_1, rhs_1, ann);\n     }\n \n+    // A generic function for checking call expressions\n+    fn check_call(&@fn_ctxt fcx, @ast.expr f, vec[@ast.expr] args)\n+        -> tup(@ast.expr, vec[@ast.expr]) {\n+\n+        let vec[option.t[@ast.expr]] args_opt_0 = vec();\n+        for (@ast.expr arg in args) {\n+            args_opt_0 += vec(some[@ast.expr](arg));\n+        }\n+\n+        // Call the generic checker.\n+        auto result = check_call_or_bind(fcx, f, args_opt_0);\n+\n+        // Pull out the arguments.\n+        let vec[@ast.expr] args_1 = vec();\n+        for (option.t[@ast.expr] arg in result._1) {\n+            args_1 += vec(option.get[@ast.expr](arg));\n+        }\n+\n+        ret tup(result._0, args_1);\n+    }\n+\n     alt (expr.node) {\n         case (ast.expr_lit(?lit, _)) {\n             auto typ = check_lit(lit);\n@@ -2154,23 +2175,13 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         }\n \n         case (ast.expr_call(?f, ?args, _)) {\n-            let vec[option.t[@ast.expr]] args_opt_0 = vec();\n-            for (@ast.expr arg in args) {\n-                args_opt_0 += vec(some[@ast.expr](arg));\n-            }\n-\n-            // Call the generic checker.\n-            auto result = check_call_or_bind(fcx, f, args_opt_0);\n-\n-            // Pull out the arguments.\n-            let vec[@ast.expr] args_1 = vec();\n-            for (option.t[@ast.expr] arg in result._1) {\n-                args_1 += vec(option.get[@ast.expr](arg));\n-            }\n+            auto result = check_call(fcx, f, args);\n+            auto f_1 = result._0;\n+            auto args_1 = result._1;\n \n             // Pull the return type out of the type of the function.\n             auto rt_1 = plain_ty(ty.ty_nil);    // FIXME: typestate botch\n-            alt (expr_ty(result._0).struct) {\n+            alt (expr_ty(f_1).struct) {\n                 case (ty.ty_fn(_,_,?rt))    { rt_1 = rt; }\n                 case (ty.ty_native_fn(_, _, ?rt))    { rt_1 = rt; }\n                 case (_) {\n@@ -2181,8 +2192,37 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n             auto ann = ast.ann_type(rt_1, none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_call(result._0, args_1,\n-                                                      ann));\n+                                        ast.expr_call(f_1, args_1, ann));\n+        }\n+\n+        case (ast.expr_spawn(?dom, ?name, ?f, ?args, _)) {\n+            auto result = check_call(fcx, f, args);\n+            auto f_1 = result._0;\n+            auto args_1 = result._1;\n+\n+            // Check the return type\n+            alt (expr_ty(f_1).struct) {\n+                case (ty.ty_fn(_,_,?rt)) {\n+                    alt (rt.struct) {\n+                        case (ty.ty_nil) {\n+                            // This is acceptable\n+                        }\n+                        case (_) {\n+                            auto err = \"non-nil return type in \"\n+                                + \"spawned function\";\n+                            fcx.ccx.sess.span_err(expr.span, err);\n+                            fail;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // FIXME: Other typechecks needed\n+\n+            auto ann = ast.ann_type(plain_ty(ty.ty_task), none[vec[@ty.t]]);\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_spawn(dom, name,\n+                                                       f_1, args_1, ann));\n         }\n \n         case (ast.expr_cast(?e, ?t, _)) {"}]}