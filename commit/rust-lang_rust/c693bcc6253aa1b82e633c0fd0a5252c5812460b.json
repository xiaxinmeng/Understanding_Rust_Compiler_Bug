{"sha": "c693bcc6253aa1b82e633c0fd0a5252c5812460b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2OTNiY2M2MjUzYWExYjgyZTYzM2MwZmQwYTUyNTJjNTgxMjQ2MGI=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-17T22:52:29Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:03:30Z"}, "message": "Inline memfill and merge with memset_intrinsic.", "tree": {"sha": "247b878ba98fca4f6437ccd0c3b769dfdbcc4e77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/247b878ba98fca4f6437ccd0c3b769dfdbcc4e77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c693bcc6253aa1b82e633c0fd0a5252c5812460b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c693bcc6253aa1b82e633c0fd0a5252c5812460b", "html_url": "https://github.com/rust-lang/rust/commit/c693bcc6253aa1b82e633c0fd0a5252c5812460b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c693bcc6253aa1b82e633c0fd0a5252c5812460b/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f051c60d925d37f535e61637d8bda700d6d3be74", "url": "https://api.github.com/repos/rust-lang/rust/commits/f051c60d925d37f535e61637d8bda700d6d3be74", "html_url": "https://github.com/rust-lang/rust/commit/f051c60d925d37f535e61637d8bda700d6d3be74"}], "stats": {"total": 94, "additions": 27, "deletions": 67}, "files": [{"sha": "21fd3e02047fc8d83bfa746bd11c2105a2962dab", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c693bcc6253aa1b82e633c0fd0a5252c5812460b/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c693bcc6253aa1b82e633c0fd0a5252c5812460b/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c693bcc6253aa1b82e633c0fd0a5252c5812460b", "patch": "@@ -53,7 +53,7 @@ use builder::Builder;\n use callee::{Callee};\n use common::{BlockAndBuilder, C_bool, C_bytes_in_context, C_i32, C_uint};\n use collector::{self, TransItemCollectionMode};\n-use common::{C_struct_in_context, C_u64, C_u8, C_undef};\n+use common::{C_struct_in_context, C_u64, C_undef};\n use common::{CrateContext, FunctionContext};\n use common::{fulfill_obligation};\n use common::{type_is_zero_size, val_ty};\n@@ -550,38 +550,17 @@ pub fn memcpy_ty<'blk, 'tcx>(\n     }\n }\n \n-pub fn init_zero_mem<'blk, 'tcx>(cx: &BlockAndBuilder<'blk, 'tcx>, llptr: ValueRef, t: Ty<'tcx>) {\n-    let bcx = cx;\n-    memfill(bcx, llptr, t, 0);\n-}\n-\n-// Always use this function instead of storing a constant byte to the memory\n-// in question. e.g. if you store a zero constant, LLVM will drown in vreg\n-// allocation for large data structures, and the generated code will be\n-// awful. (A telltale sign of this is large quantities of\n-// `mov [byte ptr foo],0` in the generated code.)\n-fn memfill<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>, byte: u8) {\n-    let ccx = b.ccx;\n-    let llty = type_of::type_of(ccx, ty);\n-    let llptr = b.pointercast(llptr, Type::i8(ccx).ptr_to());\n-    let llzeroval = C_u8(ccx, byte);\n-    let size = machine::llsize_of(ccx, llty);\n-    let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n-    call_memset(b, llptr, llzeroval, size, align, false);\n-}\n-\n pub fn call_memset<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n                                ptr: ValueRef,\n                                fill_byte: ValueRef,\n                                size: ValueRef,\n                                align: ValueRef,\n-                               volatile: bool) {\n-    let ccx = b.ccx;\n-    let ptr_width = &ccx.sess().target.target.target_pointer_width[..];\n+                               volatile: bool) -> ValueRef {\n+    let ptr_width = &b.ccx.sess().target.target.target_pointer_width[..];\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n-    let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n-    let volatile = C_bool(ccx, volatile);\n-    b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None);\n+    let llintrinsicfn = b.ccx.get_intrinsic(&intrinsic_key);\n+    let volatile = C_bool(b.ccx, volatile);\n+    b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n }\n \n pub fn alloc_ty<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,"}, {"sha": "3de7d10c8d428e5ad78b768dbc8443ab86dfa1d4", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 21, "deletions": 40, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c693bcc6253aa1b82e633c0fd0a5252c5812460b/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c693bcc6253aa1b82e633c0fd0a5252c5812460b/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=c693bcc6253aa1b82e633c0fd0a5252c5812460b", "patch": "@@ -180,10 +180,13 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n             C_u64(ccx, ccx.tcx().type_id_hash(substs.type_at(0)))\n         }\n         (_, \"init\") => {\n-            let tp_ty = substs.type_at(0);\n-            if !type_is_zero_size(ccx, tp_ty) {\n-                // Just zero out the stack slot. (See comment on base::memzero for explanation)\n-                init_zero_mem(bcx, llresult, tp_ty);\n+            let ty = substs.type_at(0);\n+            if !type_is_zero_size(ccx, ty) {\n+                // Just zero out the stack slot.\n+                // If we store a zero constant, LLVM will drown in vreg allocation for large data\n+                // structures, and the generated code will be awful. (A telltale sign of this is\n+                // large quantities of `mov [byte ptr foo],0` in the generated code.)\n+                memset_intrinsic(bcx, false, ty, llresult, C_u8(ccx, 0), C_uint(ccx, 1usize));\n             }\n             C_nil(ccx)\n         }\n@@ -226,12 +229,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                            llargs[2])\n         }\n         (_, \"write_bytes\") => {\n-            memset_intrinsic(bcx,\n-                             false,\n-                             substs.type_at(0),\n-                             llargs[0],\n-                             llargs[1],\n-                             llargs[2])\n+            memset_intrinsic(bcx, false, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n         }\n \n         (_, \"volatile_copy_nonoverlapping_memory\") => {\n@@ -253,12 +251,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                            llargs[2])\n         }\n         (_, \"volatile_set_memory\") => {\n-            memset_intrinsic(bcx,\n-                             true,\n-                             substs.type_at(0),\n-                             llargs[0],\n-                             llargs[1],\n-                             llargs[2])\n+            memset_intrinsic(bcx, true, substs.type_at(0), llargs[0], llargs[1], llargs[2])\n         }\n         (_, \"volatile_load\") => {\n             let tp_ty = substs.type_at(0);\n@@ -710,32 +703,20 @@ fn copy_intrinsic<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         None)\n }\n \n-fn memset_intrinsic<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                volatile: bool,\n-                                tp_ty: Ty<'tcx>,\n-                                dst: ValueRef,\n-                                val: ValueRef,\n-                                count: ValueRef)\n-                                -> ValueRef {\n+fn memset_intrinsic<'blk, 'tcx>(\n+    bcx: &BlockAndBuilder<'blk, 'tcx>,\n+    volatile: bool,\n+    ty: Ty<'tcx>,\n+    dst: ValueRef,\n+    val: ValueRef,\n+    count: ValueRef\n+) -> ValueRef {\n     let ccx = bcx.ccx();\n-    let lltp_ty = type_of::type_of(ccx, tp_ty);\n-    let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n+    let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n+    let lltp_ty = type_of::type_of(ccx, ty);\n     let size = machine::llsize_of(ccx, lltp_ty);\n-    let int_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n-\n-    let name = format!(\"llvm.memset.p0i8.i{}\", int_size);\n-\n-    let dst_ptr = bcx.pointercast(dst, Type::i8p(ccx));\n-    let llfn = ccx.get_intrinsic(&name);\n-\n-    bcx.call(\n-        llfn,\n-        &[dst_ptr,\n-        val,\n-        bcx.mul(size, count),\n-        align,\n-        C_bool(ccx, volatile)],\n-        None)\n+    let dst = bcx.pointercast(dst, Type::i8p(ccx));\n+    call_memset(bcx, dst, val, bcx.mul(size, count), align, volatile)\n }\n \n fn count_zeros_intrinsic(bcx: &BlockAndBuilder,"}]}