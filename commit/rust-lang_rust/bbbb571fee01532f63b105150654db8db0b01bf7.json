{"sha": "bbbb571fee01532f63b105150654db8db0b01bf7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYmI1NzFmZWUwMTUzMmY2M2IxMDUxNTA2NTRkYjhkYjBiMDFiZjc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-10T00:33:19Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-11T20:14:59Z"}, "message": "rustc: Fix a number of stability lint holes\n\nThere are a number of holes that the stability lint did not previously cover,\nincluding:\n\n* Types\n* Bounds on type parameters on functions and impls\n* Where clauses\n* Imports\n* Patterns (structs and enums)\n\nThese holes have all been fixed by overriding the `visit_path` function on the\nAST visitor instead of a few specialized cases. This change also necessitated a\nfew stability changes:\n\n* The `collections::fmt` module is now stable (it was already supposed to be).\n* The `thread_local::imp::Key` type is now stable (it was already supposed to\n  be).\n* The `std::rt::{begin_unwind, begin_unwind_fmt}` functions are now stable.\n  These are required via the `panic!` macro.\n* The `std::old_io::stdio::{println, println_args}` functions are now stable.\n  These are required by the `print!` and `println!` macros.\n* The `ops::{FnOnce, FnMut, Fn}` traits are now `#[stable]`. This is required to\n  make bounds with these traits stable. Note that manual implementations of\n  these traits are still gated by default, this stability only allows bounds\n  such as `F: FnOnce()`.\n\nAdditionally, the compiler now has special logic to ignore its own generated\n`__test` module for the `--test` harness in terms of stability.\n\nCloses #8962\nCloses #16360\nCloses #20327\n\n[breaking-change]", "tree": {"sha": "e3d8b2c3105e2c0dfb861ccc43b5f02d876c8518", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3d8b2c3105e2c0dfb861ccc43b5f02d876c8518"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbbb571fee01532f63b105150654db8db0b01bf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbbb571fee01532f63b105150654db8db0b01bf7", "html_url": "https://github.com/rust-lang/rust/commit/bbbb571fee01532f63b105150654db8db0b01bf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbbb571fee01532f63b105150654db8db0b01bf7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "446bc899b28e988f4252beca0d1858e7f7d866b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/446bc899b28e988f4252beca0d1858e7f7d866b1", "html_url": "https://github.com/rust-lang/rust/commit/446bc899b28e988f4252beca0d1858e7f7d866b1"}], "stats": {"total": 314, "additions": 187, "deletions": 127}, "files": [{"sha": "8f02f9fd580fafb2b7874a1fbb5f84e6361f7793", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -401,7 +401,7 @@\n //! them with the same character. For example, the `{` character is escaped with\n //! `{{` and the `}` character is escaped with `}}`.\n \n-#![unstable(feature = \"std_misc\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n pub use core::fmt::{Formatter, Result, Writer, rt};\n pub use core::fmt::{Show, String, Octal, Binary};"}, {"sha": "f940300a26945cf84ed29536f217ec28a4f5fb9e", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -268,6 +268,7 @@ pub trait Debug {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n+#[allow(deprecated)]\n impl<T: Show + ?Sized> Debug for T {\n     #[allow(deprecated)]\n     fn fmt(&self, f: &mut Formatter) -> Result { Show::fmt(self, f) }\n@@ -295,6 +296,7 @@ pub trait Display {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n+#[allow(deprecated)]\n impl<T: String + ?Sized> Display for T {\n     #[allow(deprecated)]\n     fn fmt(&self, f: &mut Formatter) -> Result { String::fmt(self, f) }"}, {"sha": "a46536e341edd1e1e3d98382de724deea96ff28b", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -1119,8 +1119,7 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n \n /// A version of the call operator that takes an immutable receiver.\n #[lang=\"fn\"]\n-#[unstable(feature = \"core\",\n-           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n pub trait Fn<Args> {\n     type Output;\n@@ -1131,8 +1130,7 @@ pub trait Fn<Args> {\n \n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n-#[unstable(feature = \"core\",\n-           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n pub trait FnMut<Args> {\n     type Output;\n@@ -1143,8 +1141,7 @@ pub trait FnMut<Args> {\n \n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n-#[unstable(feature = \"core\",\n-           reason = \"uncertain about variadic generics, input versus associated types\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n pub trait FnOnce<Args> {\n     type Output;"}, {"sha": "747152a82449640483e0dd94ff53d703bf9b41a5", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -34,7 +34,7 @@ use ptr::PtrExt;\n use raw::{Repr, Slice};\n use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};\n-use uint;\n+use usize;\n \n macro_rules! delegate_iter {\n     (exact $te:ty : $ti:ty) => {\n@@ -783,7 +783,7 @@ impl TwoWaySearcher {\n                 byteset: byteset,\n \n                 position: 0,\n-                memory: uint::MAX // Dummy value to signify that the period is long\n+                memory: usize::MAX // Dummy value to signify that the period is long\n             }\n         }\n     }\n@@ -911,7 +911,7 @@ impl Searcher {\n             Naive(NaiveSearcher::new())\n         } else {\n             let searcher = TwoWaySearcher::new(needle);\n-            if searcher.memory == uint::MAX { // If the period is long\n+            if searcher.memory == usize::MAX { // If the period is long\n                 TwoWayLong(searcher)\n             } else {\n                 TwoWay(searcher)"}, {"sha": "1c332509fb36326a53e4b2f9ba3fd5992092e96b", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -130,7 +130,7 @@ impl fmt::Display for Error {\n pub mod reader {\n     use std::char;\n \n-    use std::int;\n+    use std::isize;\n     use std::old_io::extensions::u64_from_be_bytes;\n     use std::mem::transmute;\n     use std::num::Int;\n@@ -440,7 +440,7 @@ pub mod reader {\n         fn read_u8 (&mut self) -> DecodeResult<u8 > { Ok(doc_as_u8 (try!(self.next_doc(EsU8 )))) }\n         fn read_uint(&mut self) -> DecodeResult<uint> {\n             let v = doc_as_u64(try!(self.next_doc(EsUint)));\n-            if v > (::std::uint::MAX as u64) {\n+            if v > (::std::usize::MAX as u64) {\n                 Err(IntTooBig(v as uint))\n             } else {\n                 Ok(v as uint)\n@@ -461,7 +461,7 @@ pub mod reader {\n         }\n         fn read_int(&mut self) -> DecodeResult<int> {\n             let v = doc_as_u64(try!(self.next_doc(EsInt))) as i64;\n-            if v > (int::MAX as i64) || v < (int::MIN as i64) {\n+            if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n                 debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n                 Err(IntTooBig(v as uint))\n             } else {"}, {"sha": "4f26d286414efcfe0887946ceb9c30e404bcc245", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -1768,6 +1768,11 @@ impl LintPass for Stability {\n         stability::check_expr(cx.tcx, e,\n                               &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n     }\n+\n+    fn check_path(&mut self, cx: &Context, path: &ast::Path, id: ast::NodeId) {\n+        stability::check_path(cx.tcx, path, id,\n+                              &mut |id, sp, stab| self.lint(cx, id, sp, stab));\n+    }\n }\n \n declare_lint! {"}, {"sha": "b792a44d4d89aad86e57da055cdd5ea1c81fe3d8", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -20,7 +20,7 @@ use middle::cfg;\n use middle::cfg::CFGIndex;\n use middle::ty;\n use std::old_io;\n-use std::uint;\n+use std::usize;\n use std::iter::repeat;\n use syntax::ast;\n use syntax::ast_util::IdRange;\n@@ -48,7 +48,7 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n     bits_per_id: uint,\n \n     /// number of words we will use to store bits_per_id.\n-    /// equal to bits_per_id/uint::BITS rounded up.\n+    /// equal to bits_per_id/usize::BITS rounded up.\n     words_per_id: uint,\n \n     // mapping from node to cfg node index\n@@ -193,7 +193,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                oper: O,\n                id_range: IdRange,\n                bits_per_id: uint) -> DataFlowContext<'a, 'tcx, O> {\n-        let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n+        let words_per_id = (bits_per_id + usize::BITS - 1) / usize::BITS;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n         debug!(\"DataFlowContext::new(analysis_name: {}, id_range={:?}, \\\n@@ -202,7 +202,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                analysis_name, id_range, bits_per_id, words_per_id,\n                num_nodes);\n \n-        let entry = if oper.initial_value() { uint::MAX } else {0};\n+        let entry = if oper.initial_value() { usize::MAX } else {0};\n \n         let gens: Vec<_> = repeat(0).take(num_nodes * words_per_id).collect();\n         let kills: Vec<_> = repeat(0).take(num_nodes * words_per_id).collect();\n@@ -351,13 +351,13 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         for (word_index, &word) in words.iter().enumerate() {\n             if word != 0 {\n-                let base_index = word_index * uint::BITS;\n-                for offset in 0..uint::BITS {\n+                let base_index = word_index * usize::BITS;\n+                for offset in 0..usize::BITS {\n                     let bit = 1 << offset;\n                     if (word & bit) != 0 {\n                         // NB: we round up the total number of bits\n                         // that we store in any given bit set so that\n-                        // it is an even multiple of uint::BITS.  This\n+                        // it is an even multiple of usize::BITS.  This\n                         // means that there may be some stray bits at\n                         // the end that do not correspond to any\n                         // actual value.  So before we callback, check\n@@ -500,7 +500,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     }\n \n     fn reset(&mut self, bits: &mut [uint]) {\n-        let e = if self.dfcx.oper.initial_value() {uint::MAX} else {0};\n+        let e = if self.dfcx.oper.initial_value() {usize::MAX} else {0};\n         for b in bits {\n             *b = e;\n         }\n@@ -552,7 +552,7 @@ fn bits_to_string(words: &[uint]) -> String {\n \n     for &word in words {\n         let mut v = word;\n-        for _ in 0..uint::BYTES {\n+        for _ in 0..usize::BYTES {\n             result.push(sep);\n             result.push_str(&format!(\"{:02x}\", v & 0xFF)[]);\n             v >>= 8;\n@@ -581,8 +581,8 @@ fn bitwise<Op:BitwiseOperator>(out_vec: &mut [uint],\n fn set_bit(words: &mut [uint], bit: uint) -> bool {\n     debug!(\"set_bit: words={} bit={}\",\n            mut_bits_to_string(words), bit_str(bit));\n-    let word = bit / uint::BITS;\n-    let bit_in_word = bit % uint::BITS;\n+    let word = bit / usize::BITS;\n+    let bit_in_word = bit % usize::BITS;\n     let bit_mask = 1 << bit_in_word;\n     debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, word);\n     let oldv = words[word];"}, {"sha": "4dd7a4a226629bf4b338bcfdb1abc6ce6e613ff1", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -33,7 +33,7 @@\n #![allow(dead_code)] // still WIP\n \n use std::fmt::{Formatter, Error, Debug};\n-use std::uint;\n+use std::usize;\n use std::collections::BitvSet;\n \n pub struct Graph<N,E> {\n@@ -64,12 +64,12 @@ impl<E: Debug> Debug for Edge<E> {\n #[derive(Clone, Copy, PartialEq, Debug)]\n pub struct NodeIndex(pub uint);\n #[allow(non_upper_case_globals)]\n-pub const InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n+pub const InvalidNodeIndex: NodeIndex = NodeIndex(usize::MAX);\n \n #[derive(Copy, PartialEq, Debug)]\n pub struct EdgeIndex(pub uint);\n #[allow(non_upper_case_globals)]\n-pub const InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::MAX);\n+pub const InvalidEdgeIndex: EdgeIndex = EdgeIndex(usize::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n #[derive(Copy, Debug)]"}, {"sha": "a086e91f4d9f26e40cf8dfe9f29a3aceeb52c1a5", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -13,6 +13,7 @@\n \n use session::Session;\n use lint;\n+use middle::def;\n use middle::ty;\n use middle::privacy::PublicItems;\n use metadata::csearch;\n@@ -277,6 +278,11 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n+        // When compiling with --test we don't enforce stability on the\n+        // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n+        // name `__test`\n+        if item.span == DUMMY_SP && item.ident.as_str() == \"__test\" { return }\n+\n         check_item(self.tcx, item,\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n         visit::walk_item(self, item);\n@@ -287,6 +293,12 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n                    &mut |id, sp, stab| self.check(id, sp, stab));\n         visit::walk_expr(self, ex);\n     }\n+\n+    fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId) {\n+        check_path(self.tcx, path, id,\n+                   &mut |id, sp, stab| self.check(id, sp, stab));\n+        visit::walk_path(self, path)\n+    }\n }\n \n /// Helper for discovering nodes to check for stability\n@@ -304,18 +316,6 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item,\n             let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n             maybe_do_stability_check(tcx, id, item.span, cb);\n         }\n-        ast::ItemTrait(_, _, ref supertraits, _) => {\n-            for t in &**supertraits {\n-                if let ast::TraitTyParamBound(ref t, _) = *t {\n-                    let id = ty::trait_ref_to_def_id(tcx, &t.trait_ref);\n-                    maybe_do_stability_check(tcx, id, t.trait_ref.path.span, cb);\n-                }\n-            }\n-        }\n-        ast::ItemImpl(_, _, _, Some(ref t), _, _) => {\n-            let id = ty::trait_ref_to_def_id(tcx, t);\n-            maybe_do_stability_check(tcx, id, t.path.span, cb);\n-        }\n         _ => (/* pass */)\n     }\n }\n@@ -325,15 +325,8 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n                   cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n     if is_internal(tcx, e.span) { return; }\n \n-    let mut span = e.span;\n-\n+    let span;\n     let id = match e.node {\n-        ast::ExprPath(..) | ast::ExprQPath(..) | ast::ExprStruct(..) => {\n-            match tcx.def_map.borrow().get(&e.id) {\n-                Some(&def) => def.def_id(),\n-                None => return\n-            }\n-        }\n         ast::ExprMethodCall(i, _, _) => {\n             span = i.span;\n             let method_call = ty::MethodCall::expr(e.id);\n@@ -369,6 +362,16 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n     maybe_do_stability_check(tcx, id, span, cb);\n }\n \n+pub fn check_path(tcx: &ty::ctxt, path: &ast::Path, id: ast::NodeId,\n+                  cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+    let did = match tcx.def_map.borrow().get(&id) {\n+        Some(&def::DefPrimTy(..)) => return,\n+        Some(def) => def.def_id(),\n+        None => return\n+    };\n+    maybe_do_stability_check(tcx, did, path.span, cb)\n+}\n+\n fn maybe_do_stability_check(tcx: &ty::ctxt, id: ast::DefId, span: Span,\n                             cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n     if !is_staged_api(tcx, id) { return  }"}, {"sha": "9c5ddc06519b97208e523379170d84609ef430b4", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -24,7 +24,7 @@ use rustc::util::nodemap::{FnvHashMap, NodeSet};\n use rustc::util::ppaux::Repr;\n use std::cell::RefCell;\n use std::rc::Rc;\n-use std::uint;\n+use std::usize;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n@@ -92,7 +92,7 @@ impl Clone for MovePathIndex {\n \n #[allow(non_upper_case_globals)]\n static InvalidMovePathIndex: MovePathIndex =\n-    MovePathIndex(uint::MAX);\n+    MovePathIndex(usize::MAX);\n \n /// Index into `MoveData.moves`, used like a pointer\n #[derive(Copy, PartialEq)]\n@@ -106,7 +106,7 @@ impl MoveIndex {\n \n #[allow(non_upper_case_globals)]\n static InvalidMoveIndex: MoveIndex =\n-    MoveIndex(uint::MAX);\n+    MoveIndex(usize::MAX);\n \n pub struct MovePath<'tcx> {\n     /// Loan path corresponding to this move path"}, {"sha": "6bb83d4790c3edf13971ba2c45297d743e93e875", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -101,7 +101,7 @@ use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem::replace;\n use std::rc::{Rc, Weak};\n-use std::uint;\n+use std::usize;\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -4366,7 +4366,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         for rib in this.value_ribs.iter().rev() {\n             for (&k, _) in &rib.bindings {\n                 maybes.push(token::get_name(k));\n-                values.push(uint::MAX);\n+                values.push(usize::MAX);\n             }\n         }\n \n@@ -4380,7 +4380,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         if values.len() > 0 &&\n-            values[smallest] != uint::MAX &&\n+            values[smallest] != usize::MAX &&\n             values[smallest] < name.len() + 2 &&\n             values[smallest] <= max_distance &&\n             name != &maybes[smallest][] {"}, {"sha": "5ad2dc2871c52b60ee3f4c611f6ae9d252cb75f1", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -79,6 +79,7 @@ This API is completely unstable and subject to change.\n #![feature(collections)]\n #![feature(core)]\n #![feature(int_uint)]\n+#![feature(std_misc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "abd73fcfb70289981213f7ef579fc4f657ab7268", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -12,7 +12,7 @@ use std::collections::HashSet;\n use rustc::util::nodemap::NodeSet;\n use std::cmp;\n use std::string::String;\n-use std::uint;\n+use std::usize;\n use syntax::ast;\n use syntax::ast_util;\n \n@@ -310,7 +310,7 @@ pub fn unindent(s: &str) -> String {\n     let lines = s.lines_any().collect::<Vec<&str> >();\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n-    let min_indent = lines.iter().fold(uint::MAX, |min_indent, line| {\n+    let min_indent = lines.iter().fold(usize::MAX, |min_indent, line| {\n \n         // After we see the first non-whitespace line, look at\n         // the line we have. If it is not whitespace, and therefore\n@@ -322,7 +322,7 @@ pub fn unindent(s: &str) -> String {\n             !line.chars().all(|c| c.is_whitespace());\n \n         let min_indent = if ignore_previous_indents {\n-            uint::MAX\n+            usize::MAX\n         } else {\n             min_indent\n         };"}, {"sha": "f81edca837198ade2545b56f86a1d8d1115d6b1d", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -10,7 +10,7 @@\n \n //! Implementations of serialization for structures found in libcollections\n \n-use std::uint;\n+use std::usize;\n use std::default::Default;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_state::HashState;\n@@ -148,7 +148,7 @@ impl<\n     fn decode<D: Decoder>(d: &mut D) -> Result<EnumSet<T>, D::Error> {\n         let bits = try!(d.read_uint());\n         let mut set = EnumSet::new();\n-        for bit in 0..uint::BITS {\n+        for bit in 0..usize::BITS {\n             if bits & (1 << bit) != 0 {\n                 set.insert(CLike::from_usize(1 << bit));\n             }"}, {"sha": "4579d1f19d3f0b3c1848aec9218023181d9d7e93", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -31,6 +31,7 @@ Core encoding and decoding interfaces.\n #![feature(int_uint)]\n #![feature(io)]\n #![feature(path)]\n+#![feature(hash)]\n #![feature(rustc_private)]\n #![feature(slicing_syntax)]\n #![feature(staged_api)]"}, {"sha": "77423cdcd313922982a4ddb04975da807095fcef", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -164,6 +164,7 @@ pub use core::cell;\n pub use core::clone;\n #[cfg(not(test))] pub use core::cmp;\n pub use core::default;\n+#[allow(deprecated)]\n pub use core::finally;\n pub use core::hash;\n pub use core::intrinsics;\n@@ -306,8 +307,8 @@ mod std {\n     pub use marker;  // used for tls!\n     pub use ops; // used for bitflags!\n \n-    // The test runner calls ::std::os::args() but really wants realstd\n-    #[cfg(test)] pub use realstd::os as os;\n+    // The test runner calls ::std::env::args() but really wants realstd\n+    #[cfg(test)] pub use realstd::env as env;\n     // The test runner requires std::slice::Vector, so re-export std::slice just for it.\n     //\n     // It is also used in vec![]"}, {"sha": "0f4d9c8b4ea457836af8a72666d6b2117c49a5f1", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -66,6 +66,7 @@ impl Writer for Vec<u8> {\n #[deprecated(since = \"1.0.0\",\n              reason = \"use the Vec<u8> Writer implementation directly\")]\n #[derive(Clone)]\n+#[allow(deprecated)]\n pub struct MemWriter {\n     buf: Vec<u8>,\n }"}, {"sha": "14661a483e3ccfe557e27fb40e97ce9083042e89", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -249,7 +249,7 @@ use char::CharExt;\n use default::Default;\n use error::Error;\n use fmt;\n-use int;\n+use isize;\n use iter::{Iterator, IteratorExt};\n use marker::Sized;\n use mem::transmute;\n@@ -265,7 +265,7 @@ use slice::SliceExt;\n use str::StrExt;\n use str;\n use string::String;\n-use uint;\n+use usize;\n use unicode;\n use vec::Vec;\n \n@@ -711,28 +711,28 @@ pub trait Reader {\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_le_uint(&mut self) -> IoResult<uint> {\n-        self.read_le_uint_n(uint::BYTES).map(|i| i as uint)\n+        self.read_le_uint_n(usize::BYTES).map(|i| i as uint)\n     }\n \n     /// Reads a little-endian integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_le_int(&mut self) -> IoResult<int> {\n-        self.read_le_int_n(int::BYTES).map(|i| i as int)\n+        self.read_le_int_n(isize::BYTES).map(|i| i as int)\n     }\n \n     /// Reads a big-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_be_uint(&mut self) -> IoResult<uint> {\n-        self.read_be_uint_n(uint::BYTES).map(|i| i as uint)\n+        self.read_be_uint_n(usize::BYTES).map(|i| i as uint)\n     }\n \n     /// Reads a big-endian integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n     fn read_be_int(&mut self) -> IoResult<int> {\n-        self.read_be_int_n(int::BYTES).map(|i| i as int)\n+        self.read_be_int_n(isize::BYTES).map(|i| i as int)\n     }\n \n     /// Reads a big-endian `u64`.\n@@ -1095,25 +1095,25 @@ pub trait Writer {\n     /// Write a little-endian uint (number of bytes depends on system).\n     #[inline]\n     fn write_le_uint(&mut self, n: uint) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, uint::BYTES, |v| self.write_all(v))\n+        extensions::u64_to_le_bytes(n as u64, usize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian int (number of bytes depends on system).\n     #[inline]\n     fn write_le_int(&mut self, n: int) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, int::BYTES, |v| self.write_all(v))\n+        extensions::u64_to_le_bytes(n as u64, isize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian uint (number of bytes depends on system).\n     #[inline]\n     fn write_be_uint(&mut self, n: uint) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, uint::BYTES, |v| self.write_all(v))\n+        extensions::u64_to_be_bytes(n as u64, usize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian int (number of bytes depends on system).\n     #[inline]\n     fn write_be_int(&mut self, n: int) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, int::BYTES, |v| self.write_all(v))\n+        extensions::u64_to_be_bytes(n as u64, isize::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian u64 (8 bytes).\n@@ -1843,7 +1843,7 @@ mod tests {\n     use self::BadReaderBehavior::*;\n     use super::{IoResult, Reader, MemReader, NoProgress, InvalidInput, Writer};\n     use prelude::v1::{Ok, Vec, Buffer, SliceExt};\n-    use uint;\n+    use usize;\n \n     #[derive(Clone, PartialEq, Debug)]\n     enum BadReaderBehavior {\n@@ -1890,24 +1890,24 @@ mod tests {\n     #[test]\n     fn test_read_at_least() {\n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![GoodBehavior(uint::MAX)]);\n+                                   vec![GoodBehavior(usize::MAX)]);\n         let buf = &mut [0u8; 5];\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n         assert!(r.read_exact(5).unwrap().len() == 5); // read_exact uses read_at_least\n         assert!(r.read_at_least(0, buf).is_ok());\n \n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(50), GoodBehavior(uint::MAX)]);\n+                                   vec![BadBehavior(50), GoodBehavior(usize::MAX)]);\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n \n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n                                    vec![BadBehavior(1), GoodBehavior(1),\n-                                        BadBehavior(50), GoodBehavior(uint::MAX)]);\n+                                        BadBehavior(50), GoodBehavior(usize::MAX)]);\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n \n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(uint::MAX)]);\n+                                   vec![BadBehavior(usize::MAX)]);\n         assert_eq!(r.read_at_least(1, buf).unwrap_err().kind, NoProgress);\n \n         let mut r = MemReader::new(b\"hello, world!\".to_vec());\n@@ -1918,23 +1918,23 @@ mod tests {\n     #[test]\n     fn test_push_at_least() {\n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![GoodBehavior(uint::MAX)]);\n+                                   vec![GoodBehavior(usize::MAX)]);\n         let mut buf = Vec::new();\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n         assert!(r.push_at_least(0, 5, &mut buf).is_ok());\n \n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(50), GoodBehavior(uint::MAX)]);\n+                                   vec![BadBehavior(50), GoodBehavior(usize::MAX)]);\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n \n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n                                    vec![BadBehavior(1), GoodBehavior(1),\n-                                        BadBehavior(50), GoodBehavior(uint::MAX)]);\n+                                        BadBehavior(50), GoodBehavior(usize::MAX)]);\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n \n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(uint::MAX)]);\n+                                   vec![BadBehavior(usize::MAX)]);\n         assert_eq!(r.push_at_least(1, 5, &mut buf).unwrap_err().kind, NoProgress);\n \n         let mut r = MemReader::new(b\"hello, world!\".to_vec());"}, {"sha": "0669af9cf9a910dc54e19f9b27c1bf5a0df7ff34", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -48,7 +48,7 @@ use str::StrExt;\n use string::String;\n use sys::{fs, tty};\n use sync::{Arc, Mutex, MutexGuard, Once, ONCE_INIT};\n-use uint;\n+use usize;\n use vec::Vec;\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n@@ -383,12 +383,14 @@ pub fn println(s: &str) {\n \n /// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n /// with the `format_args!` macro.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn print_args(fmt: fmt::Arguments) {\n     with_task_stdout(|io| write!(io, \"{}\", fmt))\n }\n \n /// Similar to `println`, but takes a `fmt::Arguments` structure to be\n /// compatible with the `format_args!` macro.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn println_args(fmt: fmt::Arguments) {\n     with_task_stdout(|io| writeln!(io, \"{}\", fmt))\n }\n@@ -510,7 +512,7 @@ impl Writer for StdWriter {\n         //\n         // [1]: https://tahoe-lafs.org/trac/tahoe-lafs/ticket/1232\n         // [2]: http://www.mail-archive.com/log4net-dev@logging.apache.org/msg00661.html\n-        let max_size = if cfg!(windows) {8192} else {uint::MAX};\n+        let max_size = if cfg!(windows) {8192} else {usize::MAX};\n         for chunk in buf.chunks(max_size) {\n             try!(match self.inner {\n                 TTY(ref mut tty) => tty.write(chunk),"}, {"sha": "b37f5f7a9741df8196011d13d291ad47704e7ccb", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -317,6 +317,7 @@ pub unsafe fn pipe() -> IoResult<Pipe> {\n #[cfg(not(target_os=\"ios\"))]\n #[deprecated(since = \"1.0.0\", reason = \"this function will be removed, use the constants directly\")]\n #[unstable(feature = \"os\")]\n+#[allow(deprecated)]\n pub fn dll_filename(base: &str) -> String {\n     format!(\"{}{}{}\", consts::DLL_PREFIX, base, consts::DLL_SUFFIX)\n }"}, {"sha": "659e787a9ff8f00e9a4e1731bc3668388316ca6e", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -494,6 +494,7 @@ pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n /// on (e.g.) the inlining of other functions as possible), by moving\n /// the actual formatting into this shared place.\n #[inline(never)] #[cold]\n+#[stable(since = \"1.0.0\", feature = \"rust1\")]\n pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n     use fmt::Writer;\n \n@@ -509,6 +510,7 @@ pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -\n \n /// This is the entry point of unwinding for panic!() and assert!().\n #[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n+#[stable(since = \"1.0.0\", feature = \"rust1\")]\n pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) -> ! {\n     // Note that this should be the only allocation performed in this code path.\n     // Currently this means that panic!() on OOM will invoke this code path,"}, {"sha": "babae93b2d44031387873d5a73ce31f4985c9946", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -61,7 +61,7 @@ use core::cell::Cell;\n use core::marker;\n use core::mem;\n use core::ptr;\n-use core::uint;\n+use core::usize;\n \n use sync::mpsc::{Receiver, RecvError};\n use sync::mpsc::blocking::{self, SignalToken};\n@@ -228,15 +228,15 @@ impl Select {\n             // A rewrite should focus on avoiding a yield loop, and for now this\n             // implementation is tying us over to a more efficient \"don't\n             // iterate over everything every time\" implementation.\n-            let mut ready_id = uint::MAX;\n+            let mut ready_id = usize::MAX;\n             for handle in self.iter() {\n                 if (*handle).packet.abort_selection() {\n                     ready_id = (*handle).id;\n                 }\n             }\n \n             // We must have found a ready receiver\n-            assert!(ready_id != uint::MAX);\n+            assert!(ready_id != usize::MAX);\n             return ready_id;\n         }\n     }"}, {"sha": "6c31fb925911edbbea453cdbcb57af7ab9b3ab26", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -23,7 +23,7 @@ pub use self::Failure::*;\n use core::prelude::*;\n \n use core::cmp;\n-use core::int;\n+use core::isize;\n \n use sync::atomic::{AtomicUsize, AtomicIsize, AtomicBool, Ordering};\n use sync::mpsc::blocking::{self, SignalToken};\n@@ -33,17 +33,17 @@ use sync::mpsc::select::StartResult;\n use sync::{Mutex, MutexGuard};\n use thread::Thread;\n \n-const DISCONNECTED: int = int::MIN;\n-const FUDGE: int = 1024;\n+const DISCONNECTED: isize = isize::MIN;\n+const FUDGE: isize = 1024;\n #[cfg(test)]\n-const MAX_STEALS: int = 5;\n+const MAX_STEALS: isize = 5;\n #[cfg(not(test))]\n-const MAX_STEALS: int = 1 << 20;\n+const MAX_STEALS: isize = 1 << 20;\n \n pub struct Packet<T> {\n     queue: mpsc::Queue<T>,\n     cnt: AtomicIsize, // How many items are on this channel\n-    steals: int, // How many times has a port received without blocking?\n+    steals: isize, // How many times has a port received without blocking?\n     to_wake: AtomicUsize, // SignalToken for wake up\n \n     // The number of channels which are currently using this packet."}, {"sha": "ab9bd6b2ed7f6982a5c48273ea4548adb54a3d97", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -25,19 +25,19 @@ use self::Message::*;\n use core::prelude::*;\n \n use core::cmp;\n-use core::int;\n+use core::isize;\n use thread::Thread;\n \n use sync::atomic::{AtomicIsize, AtomicUsize, Ordering, AtomicBool};\n use sync::mpsc::Receiver;\n use sync::mpsc::blocking::{self, SignalToken};\n use sync::mpsc::spsc_queue as spsc;\n \n-const DISCONNECTED: int = int::MIN;\n+const DISCONNECTED: isize = isize::MIN;\n #[cfg(test)]\n-const MAX_STEALS: int = 5;\n+const MAX_STEALS: isize = 5;\n #[cfg(not(test))]\n-const MAX_STEALS: int = 1 << 20;\n+const MAX_STEALS: isize = 1 << 20;\n \n pub struct Packet<T> {\n     queue: spsc::Queue<Message<T>>, // internal queue for all message"}, {"sha": "29c2051e5adc46f8b42cac7570f1c469dc03ca4d", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -13,7 +13,7 @@\n //! This primitive is meant to be used to run one-time initialization. An\n //! example use case would be for initializing an FFI library.\n \n-use int;\n+use isize;\n use marker::Sync;\n use mem::drop;\n use ops::FnOnce;\n@@ -99,9 +99,9 @@ impl Once {\n \n         let prev = self.cnt.fetch_add(1, Ordering::SeqCst);\n         if prev < 0 {\n-            // Make sure we never overflow, we'll never have int::MIN\n+            // Make sure we never overflow, we'll never have isize::MIN\n             // simultaneous calls to `call_once` to make this value go back to 0\n-            self.cnt.store(int::MIN, Ordering::SeqCst);\n+            self.cnt.store(isize::MIN, Ordering::SeqCst);\n             return\n         }\n \n@@ -111,7 +111,7 @@ impl Once {\n         let guard = self.mutex.lock();\n         if self.cnt.load(Ordering::SeqCst) > 0 {\n             f();\n-            let prev = self.cnt.swap(int::MIN, Ordering::SeqCst);\n+            let prev = self.cnt.swap(isize::MIN, Ordering::SeqCst);\n             self.lock_cnt.store(prev, Ordering::SeqCst);\n         }\n         drop(guard);"}, {"sha": "b725b6c7e6e93f3dbb8960dbaf9b1464f0eafaba", "filename": "src/libstd/sys/common/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -12,7 +12,7 @@ use core::prelude::*;\n \n use boxed::Box;\n use mem;\n-use uint;\n+use usize;\n use libc;\n use thunk::Thunk;\n use sys_common::stack;\n@@ -25,7 +25,7 @@ use sys::{thread, stack_overflow};\n #[no_stack_check]\n pub fn start_thread(main: *mut libc::c_void) -> thread::rust_thread_return {\n     unsafe {\n-        stack::record_os_managed_stack_bounds(0, uint::MAX);\n+        stack::record_os_managed_stack_bounds(0, usize::MAX);\n         let handler = stack_overflow::Handler::new();\n         let f: Box<Thunk> = mem::transmute(main);\n         f.invoke(());"}, {"sha": "cd246e8add5f0009961b245fdbd06f3390fdfc64", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -179,20 +179,20 @@ mod select {\n           target_os = \"openbsd\",\n           target_os = \"linux\"))]\n mod select {\n-    use uint;\n+    use usize;\n     use libc;\n \n-    pub const FD_SETSIZE: uint = 1024;\n+    pub const FD_SETSIZE: usize = 1024;\n \n     #[repr(C)]\n     pub struct fd_set {\n         // FIXME: shouldn't this be a c_ulong?\n-        fds_bits: [libc::uintptr_t; (FD_SETSIZE / uint::BITS)]\n+        fds_bits: [libc::uintptr_t; (FD_SETSIZE / usize::BITS)]\n     }\n \n     pub fn fd_set(set: &mut fd_set, fd: i32) {\n         let fd = fd as uint;\n-        set.fds_bits[fd / uint::BITS] |= 1 << (fd % uint::BITS);\n+        set.fds_bits[fd / usize::BITS] |= 1 << (fd % usize::BITS);\n     }\n }\n "}, {"sha": "0ec241a65e26e7618aa4ae6d2e131e5a694acd52", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -335,18 +335,22 @@ mod imp {\n     use ptr;\n \n     #[doc(hidden)]\n+    #[stable(since = \"1.0.0\", feature = \"rust1\")]\n     pub struct Key<T> {\n         // Place the inner bits in an `UnsafeCell` to currently get around the\n         // \"only Sync statics\" restriction. This allows any type to be placed in\n         // the cell.\n         //\n         // Note that all access requires `T: 'static` so it can't be a type with\n         // any borrowed pointers still.\n+        #[stable(since = \"1.0.0\", feature = \"rust1\")]\n         pub inner: UnsafeCell<T>,\n \n         // Metadata to keep track of the state of the destructor. Remember that\n         // these variables are thread-local, not global.\n+        #[stable(since = \"1.0.0\", feature = \"rust1\")]\n         pub dtor_registered: UnsafeCell<bool>, // should be Cell\n+        #[stable(since = \"1.0.0\", feature = \"rust1\")]\n         pub dtor_running: UnsafeCell<bool>, // should be Cell\n     }\n \n@@ -468,12 +472,15 @@ mod imp {\n     use sys_common::thread_local::StaticKey as OsStaticKey;\n \n     #[doc(hidden)]\n+    #[stable(since = \"1.0.0\", feature = \"rust1\")]\n     pub struct Key<T> {\n         // Statically allocated initialization expression, using an `UnsafeCell`\n         // for the same reasons as above.\n+        #[stable(since = \"1.0.0\", feature = \"rust1\")]\n         pub inner: UnsafeCell<T>,\n \n         // OS-TLS key that we'll use to key off.\n+        #[stable(since = \"1.0.0\", feature = \"rust1\")]\n         pub os: OsStaticKey,\n     }\n "}, {"sha": "6511dffa6bf8bbc1d944785a5f54151205eba7c1", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -436,40 +436,28 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     let sp = ignored_span(cx, DUMMY_SP);\n     let ecx = &cx.ext_cx;\n \n-    // std::slice::AsSlice\n-    let as_slice_path = ecx.path(sp, vec![token::str_to_ident(\"std\"),\n-                                          token::str_to_ident(\"slice\"),\n-                                          token::str_to_ident(\"AsSlice\")]);\n     // test::test_main_static\n     let test_main_path = ecx.path(sp, vec![token::str_to_ident(\"test\"),\n                                            token::str_to_ident(\"test_main_static\")]);\n-    // ::std::os::args\n+    // ::std::env::args\n     let os_args_path = ecx.path_global(sp, vec![token::str_to_ident(\"std\"),\n-                                                token::str_to_ident(\"os\"),\n+                                                token::str_to_ident(\"env\"),\n                                                 token::str_to_ident(\"args\")]);\n-    // use std::slice::AsSlice\n-    let as_slice_path = P(nospan(ast::ViewPathSimple(token::str_to_ident(\"AsSlice\"),\n-                                                     as_slice_path)));\n-    let use_as_slice = ecx.item_use(sp, ast::Inherited, as_slice_path);\n-    let use_as_slice = ecx.stmt_item(sp, use_as_slice);\n-    // ::std::os::args()\n+    // ::std::env::args()\n     let os_args_path_expr = ecx.expr_path(os_args_path);\n     let call_os_args = ecx.expr_call(sp, os_args_path_expr, vec![]);\n-    // ::std::os::args().as_slice()\n-    let call_as_slice = ecx.expr_method_call(sp, call_os_args,\n-                                             token::str_to_ident(\"as_slice\"), vec![]);\n     // test::test_main_static(...)\n     let test_main_path_expr = ecx.expr_path(test_main_path);\n     let tests_ident_expr = ecx.expr_ident(sp, token::str_to_ident(\"TESTS\"));\n     let call_test_main = ecx.expr_call(sp, test_main_path_expr,\n-                                       vec![call_as_slice, tests_ident_expr]);\n+                                       vec![call_os_args, tests_ident_expr]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n     // #![main]\n     let main_meta = ecx.meta_word(sp, token::intern_and_get_ident(\"main\"));\n     let main_attr = ecx.attribute(sp, main_meta);\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyTup(vec![]));\n-    let main_body = ecx.block_all(sp, vec![use_as_slice, call_test_main], None);\n+    let main_body = ecx.block_all(sp, vec![call_test_main], None);\n     let main = ast::ItemFn(ecx.fn_decl(vec![], main_ret_ty),\n                            ast::Unsafety::Normal, ::abi::Rust, empty_generics(), main_body);\n     let main = P(ast::Item {"}, {"sha": "1bb038603c39cc3fa592d38ed2bffe50af5d15a4", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -50,6 +50,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![deny(missing_docs)]\n \n+#![feature(core)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(int_uint)]"}, {"sha": "fb22067ee94f2202c41ffb9a1cfca305d8567412", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -40,6 +40,7 @@\n #![feature(hash)]\n #![feature(int_uint)]\n #![feature(io)]\n+#![feature(os)]\n #![feature(path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -265,15 +266,16 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn> ) {\n // a ~[TestDescAndFn] is used in order to effect ownership-transfer\n // semantics into parallel test runners, which in turn requires a ~[]\n // rather than a &[].\n-pub fn test_main_static(args: &[String], tests: &[TestDescAndFn]) {\n+pub fn test_main_static(args: env::Args, tests: &[TestDescAndFn]) {\n+    let args = args.map(|s| s.into_string().unwrap()).collect::<Vec<_>>();\n     let owned_tests = tests.iter().map(|t| {\n         match t.testfn {\n             StaticTestFn(f) => TestDescAndFn { testfn: StaticTestFn(f), desc: t.desc.clone() },\n             StaticBenchFn(f) => TestDescAndFn { testfn: StaticBenchFn(f), desc: t.desc.clone() },\n             _ => panic!(\"non-static tests passed to test::test_main_static\")\n         }\n     }).collect();\n-    test_main(args, owned_tests)\n+    test_main(&args, owned_tests)\n }\n \n #[derive(Copy)]"}, {"sha": "9ee3fcee0235557da422bec01305fb010d843112", "filename": "src/test/compile-fail/feature-gate-simd-ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-simd-ffi.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(simd)]\n+#![feature(simd, core)]\n #![allow(dead_code)]\n \n use std::simd::f32x4;"}, {"sha": "5c187176fb2ae9c1654724b13432eedf6639ee89", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -98,12 +98,10 @@ mod cross_crate {\n         // Eventually, we will want to lint the contents of the\n         // macro in the module *defining* it. Also, stability levels\n         // on macros themselves are not yet linted.\n-        macro_test!();\n         macro_test_arg!(deprecated_text()); //~ ERROR use of deprecated item: text\n         macro_test_arg!(deprecated_unstable_text()); //~ ERROR use of deprecated item: text\n         //~^ WARNING use of unstable library feature\n         macro_test_arg!(macro_test_arg!(deprecated_text())); //~ ERROR use of deprecated item: text\n-        macro_test_arg_nested!(deprecated_text);\n     }\n \n     fn test_method_param<F: Trait>(foo: F) {\n@@ -139,7 +137,7 @@ mod cross_crate {\n \n mod inheritance {\n     extern crate inherited_stability; //~ WARNING: use of unstable library feature\n-    use self::inherited_stability::*;\n+    use self::inherited_stability::*; //~ WARNING: use of unstable library feature\n \n     fn test_inheritance() {\n         unstable(); //~ WARNING use of unstable library feature"}, {"sha": "d2ec00d649506605ba54d4f3995f6fccae39d2db", "filename": "src/test/compile-fail/lint-stability2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Ftest%2Fcompile-fail%2Flint-stability2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Ftest%2Fcompile-fail%2Flint-stability2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability2.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_stability.rs\n+// error-pattern: use of deprecated item\n+\n+#![deny(deprecated)]\n+\n+#[macro_use]\n+extern crate lint_stability;\n+\n+use lint_stability::*;\n+\n+fn main() {\n+    macro_test!();\n+}"}, {"sha": "88a93134b47c0f427b63e0bd39c5f2675c849521", "filename": "src/test/compile-fail/lint-stability3.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Ftest%2Fcompile-fail%2Flint-stability3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbbb571fee01532f63b105150654db8db0b01bf7/src%2Ftest%2Fcompile-fail%2Flint-stability3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability3.rs?ref=bbbb571fee01532f63b105150654db8db0b01bf7", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:lint_stability.rs\n+// error-pattern: use of deprecated item\n+\n+#![deny(deprecated)]\n+#![allow(warnings)]\n+\n+#[macro_use]\n+extern crate lint_stability;\n+\n+use lint_stability::*;\n+\n+fn main() {\n+    macro_test_arg_nested!(deprecated_text);\n+}\n+"}]}