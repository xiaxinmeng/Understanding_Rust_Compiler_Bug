{"sha": "0f06824013761ed6829887019033f1001e68f623", "node_id": "C_kwDOAAsO6NoAKDBmMDY4MjQwMTM3NjFlZDY4Mjk4ODcwMTkwMzNmMTAwMWU2OGY2MjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-29T08:20:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-29T08:20:13Z"}, "message": "Auto merge of #97287 - compiler-errors:type-interner, r=jackh726,oli-obk\n\nMove things to `rustc_type_ir`\n\nFinishes some work proposed in https://github.com/rust-lang/compiler-team/issues/341.\n\nr? `@ghost`", "tree": {"sha": "f509b63cc8fe6c83d8157c1040810a481199ccb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f509b63cc8fe6c83d8157c1040810a481199ccb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f06824013761ed6829887019033f1001e68f623", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f06824013761ed6829887019033f1001e68f623", "html_url": "https://github.com/rust-lang/rust/commit/0f06824013761ed6829887019033f1001e68f623", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f06824013761ed6829887019033f1001e68f623/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "303d916867040e269b54adf3cfc7f5c903dc26ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/303d916867040e269b54adf3cfc7f5c903dc26ff", "html_url": "https://github.com/rust-lang/rust/commit/303d916867040e269b54adf3cfc7f5c903dc26ff"}, {"sha": "46389159403ca0973bf88a4c153a2707cdb257d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/46389159403ca0973bf88a4c153a2707cdb257d2", "html_url": "https://github.com/rust-lang/rust/commit/46389159403ca0973bf88a4c153a2707cdb257d2"}], "stats": {"total": 2362, "additions": 1732, "deletions": 630}, "files": [{"sha": "402e734dc76a436e9b0c20ca4540dd1448778cbe", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -3676,6 +3676,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n+ \"rustc_type_ir\",\n  \"tracing\",\n ]\n \n@@ -3969,6 +3970,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n+ \"rustc_type_ir\",\n  \"tracing\",\n  \"unicode-security\",\n ]\n@@ -4041,6 +4043,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_type_ir\",\n  \"smallvec\",\n  \"snap\",\n  \"tracing\",\n@@ -4262,6 +4265,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n+ \"rustc_type_ir\",\n  \"tracing\",\n ]\n \n@@ -4283,6 +4287,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_type_ir\",\n  \"smallvec\",\n  \"tracing\",\n ]\n@@ -4472,6 +4477,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n+ \"rustc_type_ir\",\n  \"tracing\",\n ]\n \n@@ -4484,6 +4490,7 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n+ \"smallvec\",\n ]\n \n [[package]]\n@@ -4509,6 +4516,7 @@ dependencies = [\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n  \"rustc_ty_utils\",\n+ \"rustc_type_ir\",\n  \"smallvec\",\n  \"tracing\",\n ]"}, {"sha": "bf38ca19484c939e11ff050abd74c691a3a4da76", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -98,7 +98,11 @@ struct Upvar<'tcx> {\n     by_ref: bool,\n }\n \n-const DEREF_PROJECTION: &[PlaceElem<'_>; 1] = &[ProjectionElem::Deref];\n+/// Associate some local constants with the `'tcx` lifetime\n+struct TyCtxtConsts<'tcx>(TyCtxt<'tcx>);\n+impl<'tcx> TyCtxtConsts<'tcx> {\n+    const DEREF_PROJECTION: &'tcx [PlaceElem<'tcx>; 1] = &[ProjectionElem::Deref];\n+}\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n@@ -1443,7 +1447,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // Thread-locals might be dropped after the function exits\n                 // We have to dereference the outer reference because\n                 // borrows don't conflict behind shared references.\n-                root_place.projection = DEREF_PROJECTION;\n+                root_place.projection = TyCtxtConsts::DEREF_PROJECTION;\n                 (true, true)\n             } else {\n                 (false, self.locals_are_invalidated_at_exit)"}, {"sha": "dd3adbf70a62fc5ed2f739d4a92bd5faac7f6aca", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -33,7 +33,7 @@ use rustc_middle::mir::{self, GeneratorLayout};\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, AdtKind, Instance, ParamEnv, Ty, TyCtxt, COMMON_VTABLE_ENTRIES};\n+use rustc_middle::ty::{self, AdtKind, Instance, ParamEnv, Ty, TyCtxt};\n use rustc_session::config::{self, DebugInfo};\n use rustc_span::symbol::Symbol;\n use rustc_span::FileName;\n@@ -1392,7 +1392,7 @@ fn build_vtable_type_di_node<'ll, 'tcx>(\n \n         tcx.vtable_entries(trait_ref)\n     } else {\n-        COMMON_VTABLE_ENTRIES\n+        TyCtxt::COMMON_VTABLE_ENTRIES\n     };\n \n     // All function pointers are described as opaque pointers. This could be improved in the future"}, {"sha": "32e8233a0415ff868a840e525a974102766f09f4", "filename": "compiler/rustc_const_eval/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2FCargo.toml?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -24,3 +24,4 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_span = { path = \"../rustc_span\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }"}, {"sha": "be34a77bdba966e265ccec946bec6b464ef9ef64", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -8,6 +8,7 @@ use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::{self, FloatTy, Ty, TypeAndMut};\n use rustc_target::abi::{Integer, Variants};\n+use rustc_type_ir::sty::TyKind::*;\n \n use super::{\n     util::ensure_monomorphic_enough, FnVal, ImmTy, Immediate, InterpCx, Machine, OpTy, PlaceTy,\n@@ -102,7 +103,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         src: &ImmTy<'tcx, M::PointerTag>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n-        use rustc_middle::ty::TyKind::*;\n+        use rustc_type_ir::sty::TyKind::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, cast_ty);\n \n         match src.layout.ty.kind() {\n@@ -205,7 +206,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let v = scalar.to_bits(src_layout.size)?;\n         let v = if signed { self.sign_extend(v, src_layout) } else { v };\n         trace!(\"cast_from_scalar: {}, {} -> {}\", v, src_layout.ty, cast_ty);\n-        use rustc_middle::ty::TyKind::*;\n \n         Ok(match *cast_ty.kind() {\n             Int(_) | Uint(_) => {\n@@ -247,7 +247,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     where\n         F: Float + Into<Scalar<M::PointerTag>> + FloatConvert<Single> + FloatConvert<Double>,\n     {\n-        use rustc_middle::ty::TyKind::*;\n+        use rustc_type_ir::sty::TyKind::*;\n         match *dest_ty.kind() {\n             // float -> uint\n             Uint(t) => {"}, {"sha": "c4d1074e4379c01d8ec023eb699a911eab5d250f", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -2,8 +2,8 @@ use std::convert::TryFrom;\n \n use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic};\n use rustc_middle::ty::{\n-    self, Ty, COMMON_VTABLE_ENTRIES, COMMON_VTABLE_ENTRIES_ALIGN,\n-    COMMON_VTABLE_ENTRIES_DROPINPLACE, COMMON_VTABLE_ENTRIES_SIZE,\n+    self, Ty, TyCtxt, COMMON_VTABLE_ENTRIES_ALIGN, COMMON_VTABLE_ENTRIES_DROPINPLACE,\n+    COMMON_VTABLE_ENTRIES_SIZE,\n };\n use rustc_target::abi::{Align, Size};\n \n@@ -38,7 +38,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     /// Resolves the function at the specified slot in the provided\n-    /// vtable. Currently an index of '3' (`COMMON_VTABLE_ENTRIES.len()`)\n+    /// vtable. Currently an index of '3' (`TyCtxt::COMMON_VTABLE_ENTRIES.len()`)\n     /// corresponds to the first method declared in the trait of the provided vtable.\n     pub fn get_vtable_slot(\n         &self,\n@@ -64,7 +64,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let vtable = self\n             .get_ptr_alloc(\n                 vtable,\n-                pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES.len()).unwrap(),\n+                pointer_size * u64::try_from(TyCtxt::COMMON_VTABLE_ENTRIES.len()).unwrap(),\n                 self.tcx.data_layout.pointer_align.abi,\n             )?\n             .expect(\"cannot be a ZST\");\n@@ -99,7 +99,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let vtable = self\n             .get_ptr_alloc(\n                 vtable,\n-                pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES.len()).unwrap(),\n+                pointer_size * u64::try_from(TyCtxt::COMMON_VTABLE_ENTRIES.len()).unwrap(),\n                 self.tcx.data_layout.pointer_align.abi,\n             )?\n             .expect(\"cannot be a ZST\");"}, {"sha": "fab60b6f6096c0c424b6c69203ef57552c6d6501", "filename": "compiler/rustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2FCargo.toml?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -21,3 +21,4 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_parse_format = { path = \"../rustc_parse_format\" }\n rustc_infer = { path = \"../rustc_infer\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }"}, {"sha": "6be78c52f99e3d77932696f6d8199c0532e77662", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -2489,7 +2489,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             ty: Ty<'tcx>,\n             init: InitKind,\n         ) -> Option<InitError> {\n-            use rustc_middle::ty::TyKind::*;\n+            use rustc_type_ir::sty::TyKind::*;\n             match ty.kind() {\n                 // Primitive types that don't like 0 as a value.\n                 Ref(..) => Some((\"references must be non-null\".to_string(), None)),\n@@ -2801,7 +2801,7 @@ impl ClashingExternDeclarations {\n                 true\n             } else {\n                 // Do a full, depth-first comparison between the two.\n-                use rustc_middle::ty::TyKind::*;\n+                use rustc_type_ir::sty::TyKind::*;\n                 let a_kind = a.kind();\n                 let b_kind = b.kind();\n "}, {"sha": "b83d63e0da086008b00cb320ddb60174866e458e", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 123, "deletions": 68, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -5,8 +5,8 @@ use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext}\n use rustc_ast as ast;\n use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n-use rustc_hir::{Expr, ExprKind, GenericArg, Path, PathSegment, QPath};\n-use rustc_hir::{HirId, Item, ItemKind, Node, Ty, TyKind};\n+use rustc_hir::{Expr, ExprKind, GenericArg, PatKind, Path, PathSegment, QPath};\n+use rustc_hir::{HirId, Item, ItemKind, Node, Pat, Ty, TyKind};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n@@ -123,55 +123,115 @@ declare_lint_pass!(TyTyKind => [\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n-    fn check_path(&mut self, cx: &LateContext<'_>, path: &'tcx Path<'tcx>, _: HirId) {\n-        let segments = path.segments.iter().rev().skip(1).rev();\n-\n-        if let Some(last) = segments.last() {\n-            let span = path.span.with_hi(last.ident.span.hi());\n-            if lint_ty_kind_usage(cx, last) {\n-                cx.struct_span_lint(USAGE_OF_TY_TYKIND, span, |lint| {\n-                    lint.build(\"usage of `ty::TyKind::<kind>`\")\n-                        .span_suggestion(\n-                            span,\n-                            \"try using ty::<kind> directly\",\n-                            \"ty\".to_string(),\n-                            Applicability::MaybeIncorrect, // ty maybe needs an import\n-                        )\n-                        .emit();\n-                })\n-            }\n+    fn check_path(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        path: &'tcx rustc_hir::Path<'tcx>,\n+        _: rustc_hir::HirId,\n+    ) {\n+        if let Some(segment) = path.segments.iter().nth_back(1)\n+        && let Some(res) = &segment.res\n+        && lint_ty_kind_usage(cx, res)\n+        {\n+            let span = path.span.with_hi(\n+                segment.args.map_or(segment.ident.span, |a| a.span_ext).hi()\n+            );\n+            cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, |lint| {\n+                lint.build(\"usage of `ty::TyKind::<kind>`\")\n+                    .span_suggestion(\n+                        span,\n+                        \"try using `ty::<kind>` directly\",\n+                        \"ty\".to_string(),\n+                        Applicability::MaybeIncorrect, // ty maybe needs an import\n+                    )\n+                    .emit();\n+            });\n         }\n     }\n \n     fn check_ty(&mut self, cx: &LateContext<'_>, ty: &'tcx Ty<'tcx>) {\n         match &ty.kind {\n             TyKind::Path(QPath::Resolved(_, path)) => {\n-                if let Some(last) = path.segments.iter().last() {\n-                    if lint_ty_kind_usage(cx, last) {\n-                        cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, |lint| {\n-                            lint.build(\"usage of `ty::TyKind`\")\n-                                .help(\"try using `Ty` instead\")\n-                                .emit();\n-                        })\n-                    } else {\n-                        if ty.span.from_expansion() {\n-                            return;\n-                        }\n-                        if let Some(t) = is_ty_or_ty_ctxt(cx, ty) {\n-                            if path.segments.len() > 1 {\n-                                cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, |lint| {\n-                                    lint.build(&format!(\"usage of qualified `ty::{}`\", t))\n+                if lint_ty_kind_usage(cx, &path.res) {\n+                    cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, |lint| {\n+                        let hir = cx.tcx.hir();\n+                        match hir.find(hir.get_parent_node(ty.hir_id)) {\n+                            Some(Node::Pat(Pat {\n+                                kind:\n+                                    PatKind::Path(qpath)\n+                                    | PatKind::TupleStruct(qpath, ..)\n+                                    | PatKind::Struct(qpath, ..),\n+                                ..\n+                            })) => {\n+                                if let QPath::TypeRelative(qpath_ty, ..) = qpath\n+                                    && qpath_ty.hir_id == ty.hir_id\n+                                {\n+                                    lint.build(\"usage of `ty::TyKind::<kind>`\")\n+                                        .span_suggestion(\n+                                            path.span,\n+                                            \"try using `ty::<kind>` directly\",\n+                                            \"ty\".to_string(),\n+                                            Applicability::MaybeIncorrect, // ty maybe needs an import\n+                                        )\n+                                        .emit();\n+                                    return;\n+                                }\n+                            }\n+                            Some(Node::Expr(Expr {\n+                                kind: ExprKind::Path(qpath),\n+                                ..\n+                            })) => {\n+                                if let QPath::TypeRelative(qpath_ty, ..) = qpath\n+                                    && qpath_ty.hir_id == ty.hir_id\n+                                {\n+                                    lint.build(\"usage of `ty::TyKind::<kind>`\")\n                                         .span_suggestion(\n                                             path.span,\n-                                            \"try importing it and using it unqualified\",\n-                                            t,\n-                                            // The import probably needs to be changed\n-                                            Applicability::MaybeIncorrect,\n+                                            \"try using `ty::<kind>` directly\",\n+                                            \"ty\".to_string(),\n+                                            Applicability::MaybeIncorrect, // ty maybe needs an import\n                                         )\n                                         .emit();\n-                                })\n+                                    return;\n+                                }\n                             }\n+                            // Can't unify these two branches because qpath below is `&&` and above is `&`\n+                            // and `A | B` paths don't play well together with adjustments, apparently.\n+                            Some(Node::Expr(Expr {\n+                                kind: ExprKind::Struct(qpath, ..),\n+                                ..\n+                            })) => {\n+                                if let QPath::TypeRelative(qpath_ty, ..) = qpath\n+                                    && qpath_ty.hir_id == ty.hir_id\n+                                {\n+                                    lint.build(\"usage of `ty::TyKind::<kind>`\")\n+                                        .span_suggestion(\n+                                            path.span,\n+                                            \"try using `ty::<kind>` directly\",\n+                                            \"ty\".to_string(),\n+                                            Applicability::MaybeIncorrect, // ty maybe needs an import\n+                                        )\n+                                        .emit();\n+                                    return;\n+                                }\n+                            }\n+                            _ => {}\n                         }\n+                        lint.build(\"usage of `ty::TyKind`\").help(\"try using `Ty` instead\").emit();\n+                    })\n+                } else if !ty.span.from_expansion() && let Some(t) = is_ty_or_ty_ctxt(cx, &path) {\n+                    if path.segments.len() > 1 {\n+                        cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, |lint| {\n+                            lint.build(&format!(\"usage of qualified `ty::{}`\", t))\n+                                .span_suggestion(\n+                                    path.span,\n+                                    \"try importing it and using it unqualified\",\n+                                    t,\n+                                    // The import probably needs to be changed\n+                                    Applicability::MaybeIncorrect,\n+                                )\n+                                .emit();\n+                        })\n                     }\n                 }\n             }\n@@ -180,42 +240,37 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n     }\n }\n \n-fn lint_ty_kind_usage(cx: &LateContext<'_>, segment: &PathSegment<'_>) -> bool {\n-    if let Some(res) = segment.res {\n-        if let Some(did) = res.opt_def_id() {\n-            return cx.tcx.is_diagnostic_item(sym::TyKind, did);\n-        }\n+fn lint_ty_kind_usage(cx: &LateContext<'_>, res: &Res) -> bool {\n+    if let Some(did) = res.opt_def_id() {\n+        cx.tcx.is_diagnostic_item(sym::TyKind, did) || cx.tcx.is_diagnostic_item(sym::IrTyKind, did)\n+    } else {\n+        false\n     }\n-\n-    false\n }\n \n-fn is_ty_or_ty_ctxt(cx: &LateContext<'_>, ty: &Ty<'_>) -> Option<String> {\n-    if let TyKind::Path(QPath::Resolved(_, path)) = &ty.kind {\n-        match path.res {\n-            Res::Def(_, def_id) => {\n-                if let Some(name @ (sym::Ty | sym::TyCtxt)) = cx.tcx.get_diagnostic_name(def_id) {\n-                    return Some(format!(\"{}{}\", name, gen_args(path.segments.last().unwrap())));\n-                }\n+fn is_ty_or_ty_ctxt(cx: &LateContext<'_>, path: &Path<'_>) -> Option<String> {\n+    match &path.res {\n+        Res::Def(_, def_id) => {\n+            if let Some(name @ (sym::Ty | sym::TyCtxt)) = cx.tcx.get_diagnostic_name(*def_id) {\n+                return Some(format!(\"{}{}\", name, gen_args(path.segments.last().unwrap())));\n             }\n-            // Only lint on `&Ty` and `&TyCtxt` if it is used outside of a trait.\n-            Res::SelfTy { trait_: None, alias_to: Some((did, _)) } => {\n-                if let ty::Adt(adt, substs) = cx.tcx.type_of(did).kind() {\n-                    if let Some(name @ (sym::Ty | sym::TyCtxt)) =\n-                        cx.tcx.get_diagnostic_name(adt.did())\n-                    {\n-                        // NOTE: This path is currently unreachable as `Ty<'tcx>` is\n-                        // defined as a type alias meaning that `impl<'tcx> Ty<'tcx>`\n-                        // is not actually allowed.\n-                        //\n-                        // I(@lcnr) still kept this branch in so we don't miss this\n-                        // if we ever change it in the future.\n-                        return Some(format!(\"{}<{}>\", name, substs[0]));\n-                    }\n+        }\n+        // Only lint on `&Ty` and `&TyCtxt` if it is used outside of a trait.\n+        Res::SelfTy { trait_: None, alias_to: Some((did, _)) } => {\n+            if let ty::Adt(adt, substs) = cx.tcx.type_of(did).kind() {\n+                if let Some(name @ (sym::Ty | sym::TyCtxt)) = cx.tcx.get_diagnostic_name(adt.did())\n+                {\n+                    // NOTE: This path is currently unreachable as `Ty<'tcx>` is\n+                    // defined as a type alias meaning that `impl<'tcx> Ty<'tcx>`\n+                    // is not actually allowed.\n+                    //\n+                    // I(@lcnr) still kept this branch in so we don't miss this\n+                    // if we ever change it in the future.\n+                    return Some(format!(\"{}<{}>\", name, substs[0]));\n                 }\n             }\n-            _ => (),\n         }\n+        _ => (),\n     }\n \n     None"}, {"sha": "a39b44139811ebc8fee1445ea7ddb572897ad2c4", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -8,7 +8,7 @@ pub fn type_decodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2:\n     if !s.ast().generics.lifetimes().any(|lt| lt.lifetime.ident == \"tcx\") {\n         s.add_impl_generic(parse_quote! { 'tcx });\n     }\n-    s.add_impl_generic(parse_quote! {#decoder_ty: ::rustc_middle::ty::codec::TyDecoder<'tcx>});\n+    s.add_impl_generic(parse_quote! {#decoder_ty: ::rustc_type_ir::codec::TyDecoder<I = ::rustc_middle::ty::TyCtxt<'tcx>>});\n     s.add_bounds(synstructure::AddBounds::Generics);\n \n     decodable_body(s, decoder_ty)\n@@ -95,7 +95,7 @@ pub fn type_encodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2:\n         s.add_impl_generic(parse_quote! {'tcx});\n     }\n     let encoder_ty = quote! { __E };\n-    s.add_impl_generic(parse_quote! {#encoder_ty: ::rustc_middle::ty::codec::TyEncoder<'tcx>});\n+    s.add_impl_generic(parse_quote! {#encoder_ty: ::rustc_type_ir::codec::TyEncoder<I = ::rustc_middle::ty::TyCtxt<'tcx>>});\n     s.add_bounds(synstructure::AddBounds::Generics);\n \n     encodable_body(s, encoder_ty, false)"}, {"sha": "41224e33461776b212e3d92a20bcc63b08adc7ed", "filename": "compiler/rustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2FCargo.toml?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -27,3 +27,4 @@ rustc_ast = { path = \"../rustc_ast\" }\n rustc_expand = { path = \"../rustc_expand\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_session = { path = \"../rustc_session\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }"}, {"sha": "775ebb48402aabef8b08384c3dd1743baf51f132", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -377,12 +377,14 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n+impl<'a, 'tcx> TyDecoder for DecodeContext<'a, 'tcx> {\n     const CLEAR_CROSS_CRATE: bool = true;\n \n+    type I = TyCtxt<'tcx>;\n+\n     #[inline]\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n+    fn interner(&self) -> Self::I {\n+        self.tcx()\n     }\n \n     #[inline]"}, {"sha": "5a40986307c7fe6d5b9b0c9d989ebfb141b90deb", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -313,9 +313,11 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n     }\n }\n \n-impl<'a, 'tcx> TyEncoder<'tcx> for EncodeContext<'a, 'tcx> {\n+impl<'a, 'tcx> TyEncoder for EncodeContext<'a, 'tcx> {\n     const CLEAR_CROSS_CRATE: bool = true;\n \n+    type I = TyCtxt<'tcx>;\n+\n     fn position(&self) -> usize {\n         self.opaque.position()\n     }"}, {"sha": "06cd6a66e39f580762e11645834fdac4379e1d9e", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -203,7 +203,7 @@ enum AllocDiscriminant {\n     Static,\n }\n \n-pub fn specialized_encode_alloc_id<'tcx, E: TyEncoder<'tcx>>(\n+pub fn specialized_encode_alloc_id<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>>(\n     encoder: &mut E,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n@@ -277,7 +277,7 @@ impl<'s> AllocDecodingSession<'s> {\n     /// Decodes an `AllocId` in a thread-safe way.\n     pub fn decode_alloc_id<'tcx, D>(&self, decoder: &mut D) -> AllocId\n     where\n-        D: TyDecoder<'tcx>,\n+        D: TyDecoder<I = TyCtxt<'tcx>>,\n     {\n         // Read the index of the allocation.\n         let idx = usize::try_from(decoder.read_u32()).unwrap();\n@@ -305,7 +305,7 @@ impl<'s> AllocDecodingSession<'s> {\n                         AllocDiscriminant::Alloc => {\n                             // If this is an allocation, we need to reserve an\n                             // `AllocId` so we can decode cyclic graphs.\n-                            let alloc_id = decoder.tcx().reserve_alloc_id();\n+                            let alloc_id = decoder.interner().reserve_alloc_id();\n                             *entry =\n                                 State::InProgress(TinyList::new_single(self.session_id), alloc_id);\n                             Some(alloc_id)\n@@ -349,23 +349,23 @@ impl<'s> AllocDecodingSession<'s> {\n                     // We already have a reserved `AllocId`.\n                     let alloc_id = alloc_id.unwrap();\n                     trace!(\"decoded alloc {:?}: {:#?}\", alloc_id, alloc);\n-                    decoder.tcx().set_alloc_id_same_memory(alloc_id, alloc);\n+                    decoder.interner().set_alloc_id_same_memory(alloc_id, alloc);\n                     alloc_id\n                 }\n                 AllocDiscriminant::Fn => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating fn alloc ID\");\n                     let instance = ty::Instance::decode(decoder);\n                     trace!(\"decoded fn alloc instance: {:?}\", instance);\n-                    let alloc_id = decoder.tcx().create_fn_alloc(instance);\n+                    let alloc_id = decoder.interner().create_fn_alloc(instance);\n                     alloc_id\n                 }\n                 AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc ID\");\n                     let did = <DefId as Decodable<D>>::decode(decoder);\n                     trace!(\"decoded static def-ID: {:?}\", did);\n-                    let alloc_id = decoder.tcx().create_static_alloc(did);\n+                    let alloc_id = decoder.interner().create_static_alloc(did);\n                     alloc_id\n                 }\n             }"}, {"sha": "71cea005cf8583e8b7293602b40ea9fcf13c31d6", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -668,7 +668,7 @@ impl<T> ClearCrossCrate<T> {\n const TAG_CLEAR_CROSS_CRATE_CLEAR: u8 = 0;\n const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n \n-impl<'tcx, E: TyEncoder<'tcx>, T: Encodable<E>> Encodable<E> for ClearCrossCrate<T> {\n+impl<E: TyEncoder, T: Encodable<E>> Encodable<E> for ClearCrossCrate<T> {\n     #[inline]\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         if E::CLEAR_CROSS_CRATE {\n@@ -684,7 +684,7 @@ impl<'tcx, E: TyEncoder<'tcx>, T: Encodable<E>> Encodable<E> for ClearCrossCrate\n         }\n     }\n }\n-impl<'tcx, D: TyDecoder<'tcx>, T: Decodable<D>> Decodable<D> for ClearCrossCrate<T> {\n+impl<D: TyDecoder, T: Decodable<D>> Decodable<D> for ClearCrossCrate<T> {\n     #[inline]\n     fn decode(d: &mut D) -> ClearCrossCrate<T> {\n         if D::CLEAR_CROSS_CRATE {"}, {"sha": "1e2d1fbeb4bf635ba7c34333d82c568ac43b2b1b", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 90, "deletions": 101, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -15,10 +15,12 @@ use crate::mir::{\n use crate::thir;\n use crate::traits;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, AdtDef, Ty, TyCtxt};\n+use crate::ty::{self, AdtDef, Ty};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_serialize::{Decodable, Encodable};\n use rustc_span::Span;\n+pub use rustc_type_ir::{TyDecoder, TyEncoder};\n use std::hash::Hash;\n use std::intrinsics;\n use std::marker::DiscriminantKind;\n@@ -28,13 +30,13 @@ use std::marker::DiscriminantKind;\n /// This offset is also chosen so that the first byte is never < 0x80.\n pub const SHORTHAND_OFFSET: usize = 0x80;\n \n-pub trait EncodableWithShorthand<'tcx, E: TyEncoder<'tcx>>: Copy + Eq + Hash {\n+pub trait EncodableWithShorthand<E: TyEncoder>: Copy + Eq + Hash {\n     type Variant: Encodable<E>;\n     fn variant(&self) -> &Self::Variant;\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n-impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for Ty<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> EncodableWithShorthand<E> for Ty<'tcx> {\n     type Variant = ty::TyKind<'tcx>;\n \n     #[inline]\n@@ -43,7 +45,7 @@ impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for ty::PredicateKind<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> EncodableWithShorthand<E> for ty::PredicateKind<'tcx> {\n     type Variant = ty::PredicateKind<'tcx>;\n \n     #[inline]\n@@ -52,15 +54,6 @@ impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for ty::Predicate\n     }\n }\n \n-pub trait TyEncoder<'tcx>: Encoder {\n-    const CLEAR_CROSS_CRATE: bool;\n-\n-    fn position(&self) -> usize;\n-    fn type_shorthands(&mut self) -> &mut FxHashMap<Ty<'tcx>, usize>;\n-    fn predicate_shorthands(&mut self) -> &mut FxHashMap<ty::PredicateKind<'tcx>, usize>;\n-    fn encode_alloc_id(&mut self, alloc_id: &AllocId) -> Result<(), Self::Error>;\n-}\n-\n /// Trait for decoding to a reference.\n ///\n /// This is a separate trait from `Decodable` so that we can implement it for\n@@ -71,7 +64,7 @@ pub trait TyEncoder<'tcx>: Encoder {\n ///\n /// `Decodable` can still be implemented in cases where `Decodable` is required\n /// by a trait bound.\n-pub trait RefDecodable<'tcx, D: TyDecoder<'tcx>> {\n+pub trait RefDecodable<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> {\n     fn decode(d: &mut D) -> &'tcx Self;\n }\n \n@@ -82,9 +75,9 @@ pub fn encode_with_shorthand<'tcx, E, T, M>(\n     cache: M,\n ) -> Result<(), E::Error>\n where\n-    E: TyEncoder<'tcx>,\n+    E: TyEncoder<I = TyCtxt<'tcx>>,\n     M: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<T, usize>,\n-    T: EncodableWithShorthand<'tcx, E>,\n+    T: EncodableWithShorthand<E>,\n     // The discriminant and shorthand must have the same size.\n     T::Variant: DiscriminantKind<Discriminant = isize>,\n {\n@@ -119,100 +112,86 @@ where\n     Ok(())\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for Ty<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for Ty<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         encode_with_shorthand(e, self, TyEncoder::type_shorthands)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E>\n+    for ty::Binder<'tcx, ty::PredicateKind<'tcx>>\n+{\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.bound_vars().encode(e)?;\n         encode_with_shorthand(e, &self.skip_binder(), TyEncoder::predicate_shorthands)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Predicate<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ty::Predicate<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.kind().encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Region<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ty::Region<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.kind().encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Const<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ty::Const<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.0.0.encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ConstAllocation<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ConstAllocation<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.inner().encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for AdtDef<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for AdtDef<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.0.0.encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for AllocId {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for AllocId {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         e.encode_alloc_id(self)\n     }\n }\n \n-pub trait TyDecoder<'tcx>: Decoder {\n-    const CLEAR_CROSS_CRATE: bool;\n-\n-    fn tcx(&self) -> TyCtxt<'tcx>;\n-\n-    fn peek_byte(&self) -> u8;\n-\n-    fn position(&self) -> usize;\n-\n-    fn cached_ty_for_shorthand<F>(&mut self, shorthand: usize, or_insert_with: F) -> Ty<'tcx>\n-    where\n-        F: FnOnce(&mut Self) -> Ty<'tcx>;\n-\n-    fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n-    where\n-        F: FnOnce(&mut Self) -> R;\n-\n-    fn positioned_at_shorthand(&self) -> bool {\n-        (self.peek_byte() & (SHORTHAND_OFFSET as u8)) != 0\n-    }\n-\n-    fn decode_alloc_id(&mut self) -> AllocId;\n-}\n-\n #[inline]\n-fn decode_arena_allocable<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n+fn decode_arena_allocable<\n+    'tcx,\n+    D: TyDecoder<I = TyCtxt<'tcx>>,\n+    T: ArenaAllocatable<'tcx> + Decodable<D>,\n+>(\n     decoder: &mut D,\n ) -> &'tcx T\n where\n-    D: TyDecoder<'tcx>,\n+    D: TyDecoder,\n {\n-    decoder.tcx().arena.alloc(Decodable::decode(decoder))\n+    decoder.interner().arena.alloc(Decodable::decode(decoder))\n }\n \n #[inline]\n-fn decode_arena_allocable_slice<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n+fn decode_arena_allocable_slice<\n+    'tcx,\n+    D: TyDecoder<I = TyCtxt<'tcx>>,\n+    T: ArenaAllocatable<'tcx> + Decodable<D>,\n+>(\n     decoder: &mut D,\n ) -> &'tcx [T]\n where\n-    D: TyDecoder<'tcx>,\n+    D: TyDecoder,\n {\n-    decoder.tcx().arena.alloc_from_iter(<Vec<T> as Decodable<D>>::decode(decoder))\n+    decoder.interner().arena.alloc_from_iter(<Vec<T> as Decodable<D>>::decode(decoder))\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for Ty<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for Ty<'tcx> {\n     #[allow(rustc::usage_of_ty_tykind)]\n     fn decode(decoder: &mut D) -> Ty<'tcx> {\n         // Handle shorthands first, if we have a usize > 0x80.\n@@ -225,13 +204,15 @@ impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for Ty<'tcx> {\n                 decoder.with_position(shorthand, Ty::decode)\n             })\n         } else {\n-            let tcx = decoder.tcx();\n-            tcx.mk_ty(ty::TyKind::decode(decoder))\n+            let tcx = decoder.interner();\n+            tcx.mk_ty(rustc_type_ir::TyKind::decode(decoder))\n         }\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D>\n+    for ty::Binder<'tcx, ty::PredicateKind<'tcx>>\n+{\n     fn decode(decoder: &mut D) -> ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n         let bound_vars = Decodable::decode(decoder);\n         // Handle shorthands first, if we have a usize > 0x80.\n@@ -250,143 +231,151 @@ impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, ty::PredicateKi\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Predicate<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::Predicate<'tcx> {\n     fn decode(decoder: &mut D) -> ty::Predicate<'tcx> {\n         let predicate_kind = Decodable::decode(decoder);\n-        decoder.tcx().mk_predicate(predicate_kind)\n+        decoder.interner().mk_predicate(predicate_kind)\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for SubstsRef<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for SubstsRef<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n         let len = decoder.read_usize();\n-        let tcx = decoder.tcx();\n+        let tcx = decoder.interner();\n         tcx.mk_substs(\n             (0..len).map::<ty::subst::GenericArg<'tcx>, _>(|_| Decodable::decode(decoder)),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for mir::Place<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for mir::Place<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n         let local: mir::Local = Decodable::decode(decoder);\n         let len = decoder.read_usize();\n-        let projection = decoder.tcx().mk_place_elems(\n+        let projection = decoder.interner().mk_place_elems(\n             (0..len).map::<mir::PlaceElem<'tcx>, _>(|_| Decodable::decode(decoder)),\n         );\n         mir::Place { local, projection }\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Region<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::Region<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        decoder.tcx().mk_region(Decodable::decode(decoder))\n+        decoder.interner().mk_region(Decodable::decode(decoder))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for CanonicalVarInfos<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for CanonicalVarInfos<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n         let len = decoder.read_usize();\n         let interned: Vec<CanonicalVarInfo<'tcx>> =\n             (0..len).map(|_| Decodable::decode(decoder)).collect();\n-        decoder.tcx().intern_canonical_var_infos(interned.as_slice())\n+        decoder.interner().intern_canonical_var_infos(interned.as_slice())\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for AllocId {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for AllocId {\n     fn decode(decoder: &mut D) -> Self {\n         decoder.decode_alloc_id()\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::SymbolName<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::SymbolName<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        ty::SymbolName::new(decoder.tcx(), &decoder.read_str())\n+        ty::SymbolName::new(decoder.interner(), &decoder.read_str())\n     }\n }\n \n macro_rules! impl_decodable_via_ref {\n     ($($t:ty),+) => {\n-        $(impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for $t {\n+        $(impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for $t {\n             fn decode(decoder: &mut D) -> Self {\n                 RefDecodable::decode(decoder)\n             }\n         })*\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<Ty<'tcx>> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for ty::List<Ty<'tcx>> {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         let len = decoder.read_usize();\n-        decoder.tcx().mk_type_list((0..len).map::<Ty<'tcx>, _>(|_| Decodable::decode(decoder)))\n+        decoder.interner().mk_type_list((0..len).map::<Ty<'tcx>, _>(|_| Decodable::decode(decoder)))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D>\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n     for ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         let len = decoder.read_usize();\n-        decoder.tcx().mk_poly_existential_predicates(\n+        decoder.interner().mk_poly_existential_predicates(\n             (0..len).map::<ty::Binder<'tcx, _>, _>(|_| Decodable::decode(decoder)),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Const<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::Const<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        decoder.tcx().mk_const(Decodable::decode(decoder))\n+        decoder.interner().mk_const(Decodable::decode(decoder))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [ty::ValTree<'tcx>] {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for [ty::ValTree<'tcx>] {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.tcx().arena.alloc_from_iter(\n+        decoder.interner().arena.alloc_from_iter(\n             (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ConstAllocation<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ConstAllocation<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        decoder.tcx().intern_const_alloc(Decodable::decode(decoder))\n+        decoder.interner().intern_const_alloc(Decodable::decode(decoder))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for AdtDef<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for AdtDef<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        decoder.tcx().intern_adt_def(Decodable::decode(decoder))\n+        decoder.interner().intern_adt_def(Decodable::decode(decoder))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [(ty::Predicate<'tcx>, Span)] {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n+    for [(ty::Predicate<'tcx>, Span)]\n+{\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.tcx().arena.alloc_from_iter(\n+        decoder.interner().arena.alloc_from_iter(\n             (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [thir::abstract_const::Node<'tcx>] {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n+    for [thir::abstract_const::Node<'tcx>]\n+{\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.tcx().arena.alloc_from_iter(\n+        decoder.interner().arena.alloc_from_iter(\n             (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [thir::abstract_const::NodeId] {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n+    for [thir::abstract_const::NodeId]\n+{\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.tcx().arena.alloc_from_iter(\n+        decoder.interner().arena.alloc_from_iter(\n             (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<ty::BoundVariableKind> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n+    for ty::List<ty::BoundVariableKind>\n+{\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         let len = decoder.read_usize();\n-        decoder.tcx().mk_bound_variable_kinds(\n+        decoder.interner().mk_bound_variable_kinds(\n             (0..len).map::<ty::BoundVariableKind, _>(|_| Decodable::decode(decoder)),\n         )\n     }\n@@ -420,14 +409,14 @@ macro_rules! impl_arena_allocatable_decoder {\n     ([]$args:tt) => {};\n     ([decode $(, $attrs:ident)*]\n      [$name:ident: $ty:ty]) => {\n-        impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for $ty {\n+        impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for $ty {\n             #[inline]\n             fn decode(decoder: &mut D) -> &'tcx Self {\n                 decode_arena_allocable(decoder)\n             }\n         }\n \n-        impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [$ty] {\n+        impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for [$ty] {\n             #[inline]\n             fn decode(decoder: &mut D) -> &'tcx Self {\n                 decode_arena_allocable_slice(decoder)\n@@ -449,17 +438,17 @@ arena_types!(impl_arena_allocatable_decoders);\n \n macro_rules! impl_arena_copy_decoder {\n     (<$tcx:tt> $($ty:ty,)*) => {\n-        $(impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for $ty {\n+        $(impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for $ty {\n             #[inline]\n             fn decode(decoder: &mut D) -> &'tcx Self {\n-                decoder.tcx().arena.alloc(Decodable::decode(decoder))\n+                decoder.interner().arena.alloc(Decodable::decode(decoder))\n             }\n         }\n \n-        impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [$ty] {\n+        impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for [$ty] {\n             #[inline]\n             fn decode(decoder: &mut D) -> &'tcx Self {\n-                decoder.tcx().arena.alloc_from_iter(<Vec<_> as Decodable<D>>::decode(decoder))\n+                decoder.interner().arena.alloc_from_iter(<Vec<_> as Decodable<D>>::decode(decoder))\n             }\n         })*\n     };\n@@ -518,13 +507,13 @@ macro_rules! implement_ty_decoder {\n macro_rules! impl_binder_encode_decode {\n     ($($t:ty),+ $(,)?) => {\n         $(\n-            impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<'tcx, $t> {\n+            impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for ty::Binder<'tcx, $t> {\n                 fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n                     self.bound_vars().encode(e)?;\n                     self.as_ref().skip_binder().encode(e)\n                 }\n             }\n-            impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, $t> {\n+            impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for ty::Binder<'tcx, $t> {\n                 fn decode(decoder: &mut D) -> Self {\n                     let bound_vars = Decodable::decode(decoder);\n                     ty::Binder::bind_with_vars(Decodable::decode(decoder), bound_vars)"}, {"sha": "a0d92e2a5dd94fc89102ac8bff7cf5e11b858560", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 28, "deletions": 106, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -16,7 +16,6 @@ use crate::thir::Thir;\n use crate::traits;\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSubsts};\n-use crate::ty::TyKind::*;\n use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n     ClosureSizeProfileData, Const, ConstS, ConstVid, DefIdTree, ExistentialPredicate, FloatTy,\n@@ -60,9 +59,9 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Layout, LayoutS, TargetDataLayout, VariantIdx};\n use rustc_target::spec::abi;\n+use rustc_type_ir::sty::TyKind::*;\n+use rustc_type_ir::{InternAs, InternIteratorElement, Interner, TypeFlags};\n \n-use rustc_type_ir::TypeFlags;\n-use smallvec::SmallVec;\n use std::any::Any;\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n@@ -91,6 +90,31 @@ pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     fn serialize(&self, tcx: TyCtxt<'tcx>, encoder: &mut FileEncoder) -> FileEncodeResult;\n }\n \n+#[allow(rustc::usage_of_ty_tykind)]\n+impl<'tcx> Interner for TyCtxt<'tcx> {\n+    type AdtDef = ty::AdtDef<'tcx>;\n+    type SubstsRef = ty::SubstsRef<'tcx>;\n+    type DefId = DefId;\n+    type Ty = Ty<'tcx>;\n+    type Const = ty::Const<'tcx>;\n+    type Region = Region<'tcx>;\n+    type TypeAndMut = TypeAndMut<'tcx>;\n+    type Mutability = hir::Mutability;\n+    type Movability = hir::Movability;\n+    type PolyFnSig = PolyFnSig<'tcx>;\n+    type ListBinderExistentialPredicate = &'tcx List<Binder<'tcx, ExistentialPredicate<'tcx>>>;\n+    type BinderListTy = Binder<'tcx, &'tcx List<Ty<'tcx>>>;\n+    type ListTy = &'tcx List<Ty<'tcx>>;\n+    type ProjectionTy = ty::ProjectionTy<'tcx>;\n+    type ParamTy = ParamTy;\n+    type BoundTy = ty::BoundTy;\n+    type PlaceholderType = ty::PlaceholderType;\n+    type InferTy = InferTy;\n+    type DelaySpanBugEmitted = DelaySpanBugEmitted;\n+    type PredicateKind = ty::PredicateKind<'tcx>;\n+    type AllocId = crate::mir::interpret::AllocId;\n+}\n+\n /// A type that is not publicly constructable. This prevents people from making [`TyKind::Error`]s\n /// except through the error-reporting functions on a [`tcx`][TyCtxt].\n #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n@@ -1677,7 +1701,7 @@ macro_rules! nop_lift {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n             type Lifted = $lifted;\n             fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-                if tcx.interners.$set.contains_pointer_to(&InternedInSet(self.0.0)) {\n+                if tcx.interners.$set.contains_pointer_to(&InternedInSet(&*self.0.0)) {\n                     // SAFETY: `self` is interned and therefore valid\n                     // for the entire lifetime of the `TyCtxt`.\n                     Some(unsafe { mem::transmute(self) })\n@@ -2848,108 +2872,6 @@ impl<'tcx> TyCtxtAt<'tcx> {\n     }\n }\n \n-pub trait InternAs<T: ?Sized, R> {\n-    type Output;\n-    fn intern_with<F>(self, f: F) -> Self::Output\n-    where\n-        F: FnOnce(&T) -> R;\n-}\n-\n-impl<I, T, R, E> InternAs<[T], R> for I\n-where\n-    E: InternIteratorElement<T, R>,\n-    I: Iterator<Item = E>,\n-{\n-    type Output = E::Output;\n-    fn intern_with<F>(self, f: F) -> Self::Output\n-    where\n-        F: FnOnce(&[T]) -> R,\n-    {\n-        E::intern_with(self, f)\n-    }\n-}\n-\n-pub trait InternIteratorElement<T, R>: Sized {\n-    type Output;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output;\n-}\n-\n-impl<T, R> InternIteratorElement<T, R> for T {\n-    type Output = R;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(\n-        mut iter: I,\n-        f: F,\n-    ) -> Self::Output {\n-        // This code is hot enough that it's worth specializing for the most\n-        // common length lists, to avoid the overhead of `SmallVec` creation.\n-        // Lengths 0, 1, and 2 typically account for ~95% of cases. If\n-        // `size_hint` is incorrect a panic will occur via an `unwrap` or an\n-        // `assert`.\n-        match iter.size_hint() {\n-            (0, Some(0)) => {\n-                assert!(iter.next().is_none());\n-                f(&[])\n-            }\n-            (1, Some(1)) => {\n-                let t0 = iter.next().unwrap();\n-                assert!(iter.next().is_none());\n-                f(&[t0])\n-            }\n-            (2, Some(2)) => {\n-                let t0 = iter.next().unwrap();\n-                let t1 = iter.next().unwrap();\n-                assert!(iter.next().is_none());\n-                f(&[t0, t1])\n-            }\n-            _ => f(&iter.collect::<SmallVec<[_; 8]>>()),\n-        }\n-    }\n-}\n-\n-impl<'a, T, R> InternIteratorElement<T, R> for &'a T\n-where\n-    T: Clone + 'a,\n-{\n-    type Output = R;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n-        // This code isn't hot.\n-        f(&iter.cloned().collect::<SmallVec<[_; 8]>>())\n-    }\n-}\n-\n-impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n-    type Output = Result<R, E>;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(\n-        mut iter: I,\n-        f: F,\n-    ) -> Self::Output {\n-        // This code is hot enough that it's worth specializing for the most\n-        // common length lists, to avoid the overhead of `SmallVec` creation.\n-        // Lengths 0, 1, and 2 typically account for ~95% of cases. If\n-        // `size_hint` is incorrect a panic will occur via an `unwrap` or an\n-        // `assert`, unless a failure happens first, in which case the result\n-        // will be an error anyway.\n-        Ok(match iter.size_hint() {\n-            (0, Some(0)) => {\n-                assert!(iter.next().is_none());\n-                f(&[])\n-            }\n-            (1, Some(1)) => {\n-                let t0 = iter.next().unwrap()?;\n-                assert!(iter.next().is_none());\n-                f(&[t0])\n-            }\n-            (2, Some(2)) => {\n-                let t0 = iter.next().unwrap()?;\n-                let t1 = iter.next().unwrap()?;\n-                assert!(iter.next().is_none());\n-                f(&[t0, t1])\n-            }\n-            _ => f(&iter.collect::<Result<SmallVec<[_; 8]>, _>>()?),\n-        })\n-    }\n-}\n-\n // We are comparing types with different invariant lifetimes, so `ptr::eq`\n // won't work for us.\n fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {"}, {"sha": "462fc27009de9ce1b9c462519ab6308c1d0c8b33", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -1,7 +1,6 @@\n //! Diagnostics related methods for `Ty`.\n \n use crate::ty::subst::{GenericArg, GenericArgKind};\n-use crate::ty::TyKind::*;\n use crate::ty::{\n     ConstKind, DefIdTree, ExistentialPredicate, ExistentialProjection, ExistentialTraitRef,\n     InferTy, ProjectionTy, Term, Ty, TyCtxt, TypeAndMut,\n@@ -13,6 +12,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::WherePredicate;\n use rustc_span::Span;\n+use rustc_type_ir::sty::TyKind::*;\n \n impl<'tcx> IntoDiagnosticArg for Ty<'tcx> {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {"}, {"sha": "208cd9ba16a0844bde36b859f7f5fb24b3ba6944", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -207,10 +207,10 @@ pub struct DeepRejectCtxt {\n }\n \n impl DeepRejectCtxt {\n-    pub fn generic_args_may_unify(\n+    pub fn generic_args_may_unify<'tcx>(\n         self,\n-        obligation_arg: ty::GenericArg<'_>,\n-        impl_arg: ty::GenericArg<'_>,\n+        obligation_arg: ty::GenericArg<'tcx>,\n+        impl_arg: ty::GenericArg<'tcx>,\n     ) -> bool {\n         match (obligation_arg.unpack(), impl_arg.unpack()) {\n             // We don't fast reject based on regions for now.\n@@ -225,7 +225,7 @@ impl DeepRejectCtxt {\n         }\n     }\n \n-    pub fn types_may_unify(self, obligation_ty: Ty<'_>, impl_ty: Ty<'_>) -> bool {\n+    pub fn types_may_unify<'tcx>(self, obligation_ty: Ty<'tcx>, impl_ty: Ty<'tcx>) -> bool {\n         match impl_ty.kind() {\n             // Start by checking whether the type in the impl may unify with\n             // pretty much everything. Just return `true` in that case."}, {"sha": "3d22f5a04a2bf1879c22dbd232c8904d95663f93", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -2,11 +2,12 @@ pub use self::def_id_forest::DefIdForest;\n \n use crate::ty;\n use crate::ty::context::TyCtxt;\n-use crate::ty::TyKind::*;\n use crate::ty::{AdtDef, FieldDef, Ty, VariantDef};\n use crate::ty::{AdtKind, Visibility};\n use crate::ty::{DefId, SubstsRef};\n \n+use rustc_type_ir::sty::TyKind::*;\n+\n mod def_id_forest;\n \n // The methods in this module calculate `DefIdForest`s of modules in which an"}, {"sha": "14e5dc0dd772250ed73d858597338a668c7a2eb7", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -51,6 +51,7 @@ use std::{fmt, str};\n \n pub use crate::ty::diagnostics::*;\n pub use rustc_type_ir::InferTy::*;\n+pub use rustc_type_ir::TyKind::*;\n pub use rustc_type_ir::*;\n \n pub use self::binding::BindingMode;\n@@ -76,15 +77,14 @@ pub use self::parameterized::ParameterizedOverTcx;\n pub use self::rvalue_scopes::RvalueScopes;\n pub use self::sty::BoundRegionKind::*;\n pub use self::sty::RegionKind::*;\n-pub use self::sty::TyKind::*;\n pub use self::sty::{\n-    Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar, BoundVariableKind,\n-    CanonicalPolyFnSig, ClosureSubsts, ClosureSubstsParts, ConstVid, EarlyBinder, EarlyBoundRegion,\n-    ExistentialPredicate, ExistentialProjection, ExistentialTraitRef, FnSig, FreeRegion, GenSig,\n-    GeneratorSubsts, GeneratorSubstsParts, InlineConstSubsts, InlineConstSubstsParts, ParamConst,\n-    ParamTy, PolyExistentialProjection, PolyExistentialTraitRef, PolyFnSig, PolyGenSig,\n-    PolyTraitRef, ProjectionTy, Region, RegionKind, RegionVid, TraitRef, TyKind, TypeAndMut,\n-    UpvarSubsts, VarianceDiagInfo,\n+    Article, Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar,\n+    BoundVariableKind, CanonicalPolyFnSig, ClosureSubsts, ClosureSubstsParts, ConstVid,\n+    EarlyBinder, EarlyBoundRegion, ExistentialPredicate, ExistentialProjection,\n+    ExistentialTraitRef, FnSig, FreeRegion, GenSig, GeneratorSubsts, GeneratorSubstsParts,\n+    InlineConstSubsts, InlineConstSubstsParts, ParamConst, ParamTy, PolyExistentialProjection,\n+    PolyExistentialTraitRef, PolyFnSig, PolyGenSig, PolyTraitRef, ProjectionTy, Region, RegionKind,\n+    RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts, VarianceDiagInfo,\n };\n pub use self::trait_def::TraitDef;\n \n@@ -463,16 +463,18 @@ static_assert_size!(WithStableHash<TyS<'_>>, 56);\n #[rustc_pass_by_value]\n pub struct Ty<'tcx>(Interned<'tcx, WithStableHash<TyS<'tcx>>>);\n \n-// Statics only used for internal testing.\n-pub static BOOL_TY: Ty<'static> = Ty(Interned::new_unchecked(&WithStableHash {\n-    internee: BOOL_TYS,\n-    stable_hash: Fingerprint::ZERO,\n-}));\n-const BOOL_TYS: TyS<'static> = TyS {\n-    kind: ty::Bool,\n-    flags: TypeFlags::empty(),\n-    outer_exclusive_binder: DebruijnIndex::from_usize(0),\n-};\n+impl<'tcx> TyCtxt<'tcx> {\n+    /// A \"bool\" type used in rustc_mir_transform unit tests when we\n+    /// have not spun up a TyCtxt.\n+    pub const BOOL_TY_FOR_UNIT_TESTING: Ty<'tcx> = Ty(Interned::new_unchecked(&WithStableHash {\n+        internee: TyS {\n+            kind: ty::Bool,\n+            flags: TypeFlags::empty(),\n+            outer_exclusive_binder: DebruijnIndex::from_usize(0),\n+        },\n+        stable_hash: Fingerprint::ZERO,\n+    }));\n+}\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n     #[inline]"}, {"sha": "faeb729c88483463a49d33c5c27d4ca305893d86", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 14, "deletions": 186, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -2,16 +2,14 @@\n \n #![allow(rustc::usage_of_ty_tykind)]\n \n-use self::TyKind::*;\n-\n use crate::infer::canonical::Canonical;\n use crate::ty::fold::ValidateBoundVars;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n-use crate::ty::InferTy::{self, *};\n+use crate::ty::InferTy::*;\n use crate::ty::{\n     self, AdtDef, DefIdTree, Discr, Term, Ty, TyCtxt, TypeFlags, TypeFoldable, TypeVisitor,\n };\n-use crate::ty::{DelaySpanBugEmitted, List, ParamEnv};\n+use crate::ty::{List, ParamEnv};\n use polonius_engine::Atom;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::intern::Interned;\n@@ -29,6 +27,13 @@ use std::marker::PhantomData;\n use std::ops::{ControlFlow, Deref, Range};\n use ty::util::IntTypeExt;\n \n+use rustc_type_ir::sty::TyKind::*;\n+use rustc_type_ir::TyKind as IrTyKind;\n+\n+// Re-export the `TyKind` from `rustc_type_ir` here for convenience\n+#[rustc_diagnostic_item = \"TyKind\"]\n+pub type TyKind<'tcx> = IrTyKind<TyCtxt<'tcx>>;\n+\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n pub struct TypeAndMut<'tcx> {\n@@ -78,190 +83,13 @@ impl BoundRegionKind {\n     }\n }\n \n-/// Defines the kinds of types used by the type system.\n-///\n-/// Types written by the user start out as [hir::TyKind](rustc_hir::TyKind) and get\n-/// converted to this representation using `AstConv::ast_ty_to_ty`.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable, Debug)]\n-#[derive(HashStable)]\n-#[rustc_diagnostic_item = \"TyKind\"]\n-pub enum TyKind<'tcx> {\n-    /// The primitive boolean type. Written as `bool`.\n-    Bool,\n-\n-    /// The primitive character type; holds a Unicode scalar value\n-    /// (a non-surrogate code point). Written as `char`.\n-    Char,\n-\n-    /// A primitive signed integer type. For example, `i32`.\n-    Int(ty::IntTy),\n-\n-    /// A primitive unsigned integer type. For example, `u32`.\n-    Uint(ty::UintTy),\n-\n-    /// A primitive floating-point type. For example, `f64`.\n-    Float(ty::FloatTy),\n-\n-    /// Algebraic data types (ADT). For example: structures, enumerations and unions.\n-    ///\n-    /// For example, the type `List<i32>` would be represented using the `AdtDef`\n-    /// for `struct List<T>` and the substs `[i32]`.\n-    ///\n-    /// Note that generic parameters in fields only get lazily substituted\n-    /// by using something like `adt_def.all_fields().map(|field| field.ty(tcx, substs))`.\n-    Adt(AdtDef<'tcx>, SubstsRef<'tcx>),\n-\n-    /// An unsized FFI type that is opaque to Rust. Written as `extern type T`.\n-    Foreign(DefId),\n-\n-    /// The pointee of a string slice. Written as `str`.\n-    Str,\n-\n-    /// An array with the given length. Written as `[T; N]`.\n-    Array(Ty<'tcx>, ty::Const<'tcx>),\n-\n-    /// The pointee of an array slice. Written as `[T]`.\n-    Slice(Ty<'tcx>),\n-\n-    /// A raw pointer. Written as `*mut T` or `*const T`\n-    RawPtr(TypeAndMut<'tcx>),\n-\n-    /// A reference; a pointer with an associated lifetime. Written as\n-    /// `&'a mut T` or `&'a T`.\n-    Ref(Region<'tcx>, Ty<'tcx>, hir::Mutability),\n-\n-    /// The anonymous type of a function declaration/definition. Each\n-    /// function has a unique type.\n-    ///\n-    /// For the function `fn foo() -> i32 { 3 }` this type would be\n-    /// shown to the user as `fn() -> i32 {foo}`.\n-    ///\n-    /// For example the type of `bar` here:\n-    /// ```rust\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar = foo; // bar: fn() -> i32 {foo}\n-    /// ```\n-    FnDef(DefId, SubstsRef<'tcx>),\n-\n-    /// A pointer to a function. Written as `fn() -> i32`.\n-    ///\n-    /// Note that both functions and closures start out as either\n-    /// [FnDef] or [Closure] which can be then be coerced to this variant.\n-    ///\n-    /// For example the type of `bar` here:\n-    ///\n-    /// ```rust\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar: fn() -> i32 = foo;\n-    /// ```\n-    FnPtr(PolyFnSig<'tcx>),\n-\n-    /// A trait object. Written as `dyn for<'b> Trait<'b, Assoc = u32> + Send + 'a`.\n-    Dynamic(&'tcx List<Binder<'tcx, ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n-\n-    /// The anonymous type of a closure. Used to represent the type of `|a| a`.\n-    ///\n-    /// Closure substs contain both the - potentially substituted - generic parameters\n-    /// of its parent and some synthetic parameters. See the documentation for\n-    /// [ClosureSubsts] for more details.\n-    Closure(DefId, SubstsRef<'tcx>),\n-\n-    /// The anonymous type of a generator. Used to represent the type of\n-    /// `|a| yield a`.\n-    ///\n-    /// For more info about generator substs, visit the documentation for\n-    /// [GeneratorSubsts].\n-    Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n-\n-    /// A type representing the types stored inside a generator.\n-    /// This should only appear as part of the [GeneratorSubsts].\n-    ///\n-    /// Note that the captured variables for generators are stored separately\n-    /// using a tuple in the same way as for closures.\n-    ///\n-    /// Unlike upvars, the witness can reference lifetimes from\n-    /// inside of the generator itself. To deal with them in\n-    /// the type of the generator, we convert them to higher ranked\n-    /// lifetimes bound by the witness itself.\n-    ///\n-    /// Looking at the following example, the witness for this generator\n-    /// may end up as something like `for<'a> [Vec<i32>, &'a Vec<i32>]`:\n-    ///\n-    /// ```ignore UNSOLVED (ask @compiler-errors, should this error? can we just swap the yields?)\n-    /// #![feature(generators)]\n-    /// |a| {\n-    ///     let x = &vec![3];\n-    ///     yield a;\n-    ///     yield x[0];\n-    /// }\n-    /// # ;\n-    /// ```\n-    GeneratorWitness(Binder<'tcx, &'tcx List<Ty<'tcx>>>),\n-\n-    /// The never type `!`.\n-    Never,\n-\n-    /// A tuple type. For example, `(i32, bool)`.\n-    Tuple(&'tcx List<Ty<'tcx>>),\n-\n-    /// The projection of an associated type. For example,\n-    /// `<T as Trait<..>>::N`.\n-    Projection(ProjectionTy<'tcx>),\n-\n-    /// Opaque (`impl Trait`) type found in a return type.\n-    ///\n-    /// The `DefId` comes either from\n-    /// * the `impl Trait` ast::Ty node,\n-    /// * or the `type Foo = impl Trait` declaration\n-    ///\n-    /// For RPIT the substitutions are for the generics of the function,\n-    /// while for TAIT it is used for the generic parameters of the alias.\n-    ///\n-    /// During codegen, `tcx.type_of(def_id)` can be used to get the underlying type.\n-    Opaque(DefId, SubstsRef<'tcx>),\n-\n-    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}`.\n-    Param(ParamTy),\n-\n-    /// Bound type variable, used to represent the `'a` in `for<'a> fn(&'a ())`.\n-    ///\n-    /// For canonical queries, we replace inference variables with bound variables,\n-    /// so e.g. when checking whether `&'_ (): Trait<_>` holds, we canonicalize that to\n-    /// `for<'a, T> &'a (): Trait<T>` and then convert the introduced bound variables\n-    /// back to inference variables in a new inference context when inside of the query.\n-    ///\n-    /// See the `rustc-dev-guide` for more details about\n-    /// [higher-ranked trait bounds][1] and [canonical queries][2].\n-    ///\n-    /// [1]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n-    /// [2]: https://rustc-dev-guide.rust-lang.org/traits/canonical-queries.html\n-    Bound(ty::DebruijnIndex, BoundTy),\n-\n-    /// A placeholder type, used during higher ranked subtyping to instantiate\n-    /// bound variables.\n-    Placeholder(ty::PlaceholderType),\n-\n-    /// A type variable used during type checking.\n-    ///\n-    /// Similar to placeholders, inference variables also live in a universe to\n-    /// correctly deal with higher ranked types. Though unlike placeholders,\n-    /// that universe is stored in the `InferCtxt` instead of directly\n-    /// inside of the type.\n-    Infer(InferTy),\n-\n-    /// A placeholder for a type which could not be computed; this is\n-    /// propagated to avoid useless error messages.\n-    Error(DelaySpanBugEmitted),\n+pub trait Article {\n+    fn article(&self) -> &'static str;\n }\n \n-impl<'tcx> TyKind<'tcx> {\n-    #[inline]\n-    pub fn is_primitive(&self) -> bool {\n-        matches!(self, Bool | Char | Int(_) | Uint(_) | Float(_))\n-    }\n-\n+impl<'tcx> Article for TyKind<'tcx> {\n     /// Get the article (\"a\" or \"an\") to use with this type.\n-    pub fn article(&self) -> &'static str {\n+    fn article(&self) -> &'static str {\n         match self {\n             Int(_) | Float(_) | Array(_, _) => \"an\",\n             Adt(def, _) if def.is_enum() => \"an\",\n@@ -930,7 +758,7 @@ impl<'tcx> List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>> {\n     }\n \n     #[inline]\n-    pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item = DefId> + 'a {\n+    pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item = DefId> + Captures<'tcx> + 'a {\n         self.iter().filter_map(|predicate| match predicate.skip_binder() {\n             ExistentialPredicate::AutoTrait(did) => Some(did),\n             _ => None,"}, {"sha": "290485ab5fe0f83d51cecb317c8973f4310dbf62", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -4,7 +4,7 @@ use crate::mir;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts, InlineConstSubsts};\n-use crate::ty::{self, EarlyBinder, Lift, List, ParamConst, Ty, TyCtxt};\n+use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt};\n \n use rustc_data_structures::intern::{Interned, WithStableHash};\n use rustc_hir::def_id::DefId;\n@@ -79,17 +79,17 @@ impl<'tcx> GenericArgKind<'tcx> {\n         let (tag, ptr) = match self {\n             GenericArgKind::Lifetime(lt) => {\n                 // Ensure we can use the tag bits.\n-                assert_eq!(mem::align_of_val(lt.0.0) & TAG_MASK, 0);\n+                assert_eq!(mem::align_of_val(&*lt.0.0) & TAG_MASK, 0);\n                 (REGION_TAG, lt.0.0 as *const ty::RegionKind as usize)\n             }\n             GenericArgKind::Type(ty) => {\n                 // Ensure we can use the tag bits.\n-                assert_eq!(mem::align_of_val(ty.0.0) & TAG_MASK, 0);\n+                assert_eq!(mem::align_of_val(&*ty.0.0) & TAG_MASK, 0);\n                 (TYPE_TAG, ty.0.0 as *const WithStableHash<ty::TyS<'tcx>> as usize)\n             }\n             GenericArgKind::Const(ct) => {\n                 // Ensure we can use the tag bits.\n-                assert_eq!(mem::align_of_val(ct.0.0) & TAG_MASK, 0);\n+                assert_eq!(mem::align_of_val(&*ct.0.0) & TAG_MASK, 0);\n                 (CONST_TAG, ct.0.0 as *const ty::ConstS<'tcx> as usize)\n             }\n         };\n@@ -216,13 +216,13 @@ impl<'tcx> TypeFoldable<'tcx> for GenericArg<'tcx> {\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for GenericArg<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyCtxt<'tcx>>> Encodable<E> for GenericArg<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.unpack().encode(e)\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for GenericArg<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> Decodable<D> for GenericArg<'tcx> {\n     fn decode(d: &mut D) -> GenericArg<'tcx> {\n         GenericArgKind::decode(d).pack()\n     }\n@@ -506,7 +506,7 @@ pub trait Subst<'tcx>: Sized {\n     fn subst(self, tcx: TyCtxt<'tcx>, substs: &[GenericArg<'tcx>]) -> Self::Inner;\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for EarlyBinder<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for ty::EarlyBinder<T> {\n     type Inner = T;\n \n     fn subst(self, tcx: TyCtxt<'tcx>, substs: &[GenericArg<'tcx>]) -> Self::Inner {"}, {"sha": "04a9fd1f71308d2e67c015e6e6b805e093587ba4", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -36,8 +36,11 @@ impl<'tcx> fmt::Debug for VtblEntry<'tcx> {\n     }\n }\n \n-pub const COMMON_VTABLE_ENTRIES: &[VtblEntry<'_>] =\n-    &[VtblEntry::MetadataDropInPlace, VtblEntry::MetadataSize, VtblEntry::MetadataAlign];\n+// Needs to be associated with the `'tcx` lifetime\n+impl<'tcx> TyCtxt<'tcx> {\n+    pub const COMMON_VTABLE_ENTRIES: &'tcx [VtblEntry<'tcx>] =\n+        &[VtblEntry::MetadataDropInPlace, VtblEntry::MetadataSize, VtblEntry::MetadataAlign];\n+}\n \n pub const COMMON_VTABLE_ENTRIES_DROPINPLACE: usize = 0;\n pub const COMMON_VTABLE_ENTRIES_SIZE: usize = 1;\n@@ -57,7 +60,7 @@ pub(super) fn vtable_allocation_provider<'tcx>(\n \n         tcx.vtable_entries(trait_ref)\n     } else {\n-        COMMON_VTABLE_ENTRIES\n+        TyCtxt::COMMON_VTABLE_ENTRIES\n     };\n \n     let layout = tcx"}, {"sha": "213bb6608e1396fc51a199c9a4123ff356e86afa", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -37,7 +37,7 @@ use rustc_data_structures::graph::WithSuccessors;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::coverage::CoverageKind;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, BOOL_TY};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::{self, BytePos, Pos, Span, DUMMY_SP};\n \n // All `TEMP_BLOCK` targets should be replaced before calling `to_body() -> mir::Body`.\n@@ -47,6 +47,7 @@ struct MockBlocks<'tcx> {\n     blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n     dummy_place: Place<'tcx>,\n     next_local: usize,\n+    bool_ty: Ty<'tcx>,\n }\n \n impl<'tcx> MockBlocks<'tcx> {\n@@ -55,6 +56,7 @@ impl<'tcx> MockBlocks<'tcx> {\n             blocks: IndexVec::new(),\n             dummy_place: Place { local: RETURN_PLACE, projection: ty::List::empty() },\n             next_local: 0,\n+            bool_ty: TyCtxt::BOOL_TY_FOR_UNIT_TESTING,\n         }\n     }\n \n@@ -155,7 +157,7 @@ impl<'tcx> MockBlocks<'tcx> {\n     fn switchint(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n         let switchint_kind = TerminatorKind::SwitchInt {\n             discr: Operand::Move(Place::from(self.new_temp())),\n-            switch_ty: BOOL_TY, // just a dummy value\n+            switch_ty: self.bool_ty, // just a dummy value\n             targets: SwitchTargets::static_if(0, TEMP_BLOCK, TEMP_BLOCK),\n         };\n         self.add_block_from(some_from_block, switchint_kind)"}, {"sha": "856f09b6fcc32e23d612ffca802f5bedbbcf5815", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -20,6 +20,7 @@ rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }\n tracing = \"0.1\"\n \n [features]"}, {"sha": "8e4b3269402e9b6a84dc40d144ab0825acba1792", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -547,11 +547,12 @@ where\n     value\n }\n \n-impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n+impl<'a, 'tcx> TyDecoder for CacheDecoder<'a, 'tcx> {\n+    type I = TyCtxt<'tcx>;\n     const CLEAR_CROSS_CRATE: bool = false;\n \n     #[inline]\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n+    fn interner(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n \n@@ -569,7 +570,7 @@ impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n     where\n         F: FnOnce(&mut Self) -> Ty<'tcx>,\n     {\n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n \n         let cache_key = ty::CReaderCacheKey { cnum: None, pos: shorthand };\n \n@@ -750,7 +751,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n         // If we get to this point, then all of the query inputs were green,\n         // which means that the definition with this hash is guaranteed to\n         // still exist in the current compilation session.\n-        d.tcx().def_path_hash_to_def_id(def_path_hash, &mut || {\n+        d.tcx.def_path_hash_to_def_id(def_path_hash, &mut || {\n             panic!(\"Failed to convert DefPathHash {:?}\", def_path_hash)\n         })\n     }\n@@ -927,10 +928,11 @@ where\n     }\n }\n \n-impl<'a, 'tcx, E> TyEncoder<'tcx> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> TyEncoder for CacheEncoder<'a, 'tcx, E>\n where\n     E: 'a + OpaqueEncoder,\n {\n+    type I = TyCtxt<'tcx>;\n     const CLEAR_CROSS_CRATE: bool = false;\n \n     fn position(&self) -> usize {"}, {"sha": "85fbb08eeeb53f141a2ccb70b7a46ce175ccfea7", "filename": "compiler/rustc_query_system/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2FCargo.toml?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -21,6 +21,7 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }\n parking_lot = \"0.11\"\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n "}, {"sha": "e4c52f8d25aea202b7313e230d002e7e9b7a98dd", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -205,6 +205,7 @@ symbols! {\n         IntoIterator,\n         IoRead,\n         IoWrite,\n+        IrTyKind,\n         Is,\n         ItemContext,\n         Iterator,"}, {"sha": "03757b5447eead25d56b0677274a9674e8d7764c", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -32,9 +32,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{\n-    self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, VtblEntry, COMMON_VTABLE_ENTRIES,\n-};\n+use rustc_middle::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, VtblEntry};\n use rustc_span::{sym, Span};\n use smallvec::SmallVec;\n \n@@ -695,7 +693,7 @@ fn vtable_entries<'tcx>(\n     let vtable_segment_callback = |segment| -> ControlFlow<()> {\n         match segment {\n             VtblSegment::MetadataDSA => {\n-                entries.extend(COMMON_VTABLE_ENTRIES);\n+                entries.extend(TyCtxt::COMMON_VTABLE_ENTRIES);\n             }\n             VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n                 let existential_trait_ref = trait_ref\n@@ -785,7 +783,7 @@ fn vtable_trait_first_method_offset<'tcx>(\n         move |segment| {\n             match segment {\n                 VtblSegment::MetadataDSA => {\n-                    vtable_base += COMMON_VTABLE_ENTRIES.len();\n+                    vtable_base += TyCtxt::COMMON_VTABLE_ENTRIES.len();\n                 }\n                 VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n                     if tcx.erase_regions(trait_ref) == trait_to_be_found_erased {"}, {"sha": "34dc81b14d29e80810186ddeb50ea1395ca5c45a", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -12,7 +12,7 @@ use rustc_index::bit_set::GrowableBitSet;\n use rustc_infer::infer::InferOk;\n use rustc_infer::infer::LateBoundRegionConversionTime::HigherRankedType;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{self, EarlyBinder, GenericParamDefKind, Ty};\n+use rustc_middle::ty::{self, EarlyBinder, GenericParamDefKind, Ty, TyCtxt};\n use rustc_middle::ty::{ToPolyTraitRef, ToPredicate};\n use rustc_span::def_id::DefId;\n \n@@ -834,7 +834,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             move |segment| {\n                 match segment {\n                     VtblSegment::MetadataDSA => {\n-                        vptr_offset += ty::COMMON_VTABLE_ENTRIES.len();\n+                        vptr_offset += TyCtxt::COMMON_VTABLE_ENTRIES.len();\n                     }\n                     VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n                         vptr_offset += util::count_own_vtable_entries(tcx, trait_ref);"}, {"sha": "d03d675bfd231d546e097d7164cd1114a5ee7d29", "filename": "compiler/rustc_ty_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_ty_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_ty_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2FCargo.toml?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -14,3 +14,4 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }"}, {"sha": "8d04b8816ffbe59dce69ab985fe1bea9872cd744", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -13,7 +13,7 @@ fn sized_constraint_for_ty<'tcx>(\n     adtdef: ty::AdtDef<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Vec<Ty<'tcx>> {\n-    use ty::TyKind::*;\n+    use rustc_type_ir::sty::TyKind::*;\n \n     let result = match ty.kind() {\n         Bool | Char | Int(..) | Uint(..) | Float(..) | RawPtr(..) | Ref(..) | FnDef(..)"}, {"sha": "b8066f2e5d89186f73191fb623400c1ec3593065", "filename": "compiler/rustc_type_ir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_type_ir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_type_ir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2FCargo.toml?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -12,3 +12,4 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_macros = { path = \"../rustc_macros\" }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "09f781fae75bde0dea38eef2dcd44ba7cc6778f5", "filename": "compiler/rustc_type_ir/src/codec.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_type_ir%2Fsrc%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_type_ir%2Fsrc%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fcodec.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -0,0 +1,67 @@\n+use crate::Interner;\n+\n+use rustc_data_structures::stable_map::FxHashMap;\n+use rustc_serialize::{Decoder, Encoder};\n+\n+/// The shorthand encoding uses an enum's variant index `usize`\n+/// and is offset by this value so it never matches a real variant.\n+/// This offset is also chosen so that the first byte is never < 0x80.\n+pub const SHORTHAND_OFFSET: usize = 0x80;\n+\n+/// Trait for decoding to a reference.\n+///\n+/// This is a separate trait from `Decodable` so that we can implement it for\n+/// upstream types, such as `FxHashSet`.\n+///\n+/// The `TyDecodable` derive macro will use this trait for fields that are\n+/// references (and don't use a type alias to hide that).\n+///\n+/// `Decodable` can still be implemented in cases where `Decodable` is required\n+/// by a trait bound.\n+pub trait RefDecodable<'tcx, D: TyDecoder> {\n+    fn decode(d: &mut D) -> &'tcx Self;\n+}\n+\n+pub trait TyEncoder: Encoder {\n+    type I: Interner;\n+    const CLEAR_CROSS_CRATE: bool;\n+\n+    fn position(&self) -> usize;\n+    fn type_shorthands(&mut self) -> &mut FxHashMap<<Self::I as Interner>::Ty, usize>;\n+    fn predicate_shorthands(\n+        &mut self,\n+    ) -> &mut FxHashMap<<Self::I as Interner>::PredicateKind, usize>;\n+    fn encode_alloc_id(\n+        &mut self,\n+        alloc_id: &<Self::I as Interner>::AllocId,\n+    ) -> Result<(), Self::Error>;\n+}\n+\n+pub trait TyDecoder: Decoder {\n+    type I: Interner;\n+    const CLEAR_CROSS_CRATE: bool;\n+\n+    fn interner(&self) -> Self::I;\n+\n+    fn peek_byte(&self) -> u8;\n+\n+    fn position(&self) -> usize;\n+\n+    fn cached_ty_for_shorthand<F>(\n+        &mut self,\n+        shorthand: usize,\n+        or_insert_with: F,\n+    ) -> <Self::I as Interner>::Ty\n+    where\n+        F: FnOnce(&mut Self) -> <Self::I as Interner>::Ty;\n+\n+    fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n+    where\n+        F: FnOnce(&mut Self) -> R;\n+\n+    fn positioned_at_shorthand(&self) -> bool {\n+        (self.peek_byte() & (SHORTHAND_OFFSET as u8)) != 0\n+    }\n+\n+    fn decode_alloc_id(&mut self) -> <Self::I as Interner>::AllocId;\n+}"}, {"sha": "6380001b57c08b1ab11e2968535e38573e70ca46", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -1,4 +1,5 @@\n #![feature(min_specialization)]\n+#![feature(rustc_attrs)]\n \n #[macro_use]\n extern crate bitflags;\n@@ -7,9 +8,144 @@ extern crate rustc_macros;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::unify::{EqUnifyValue, UnifyKey};\n+use smallvec::SmallVec;\n use std::fmt;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n use std::mem::discriminant;\n \n+pub mod codec;\n+pub mod sty;\n+\n+pub use codec::*;\n+pub use sty::*;\n+\n+pub trait Interner {\n+    type AdtDef: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type SubstsRef: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type DefId: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type Ty: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type Const: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type Region: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type TypeAndMut: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type Mutability: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type Movability: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type PolyFnSig: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type ListBinderExistentialPredicate: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type BinderListTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type ListTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type ProjectionTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type ParamTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type BoundTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type PlaceholderType: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type InferTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type DelaySpanBugEmitted: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type PredicateKind: Clone + Debug + Hash + PartialEq + Eq;\n+    type AllocId: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+}\n+\n+pub trait InternAs<T: ?Sized, R> {\n+    type Output;\n+    fn intern_with<F>(self, f: F) -> Self::Output\n+    where\n+        F: FnOnce(&T) -> R;\n+}\n+\n+impl<I, T, R, E> InternAs<[T], R> for I\n+where\n+    E: InternIteratorElement<T, R>,\n+    I: Iterator<Item = E>,\n+{\n+    type Output = E::Output;\n+    fn intern_with<F>(self, f: F) -> Self::Output\n+    where\n+        F: FnOnce(&[T]) -> R,\n+    {\n+        E::intern_with(self, f)\n+    }\n+}\n+\n+pub trait InternIteratorElement<T, R>: Sized {\n+    type Output;\n+    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output;\n+}\n+\n+impl<T, R> InternIteratorElement<T, R> for T {\n+    type Output = R;\n+    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(\n+        mut iter: I,\n+        f: F,\n+    ) -> Self::Output {\n+        // This code is hot enough that it's worth specializing for the most\n+        // common length lists, to avoid the overhead of `SmallVec` creation.\n+        // Lengths 0, 1, and 2 typically account for ~95% of cases. If\n+        // `size_hint` is incorrect a panic will occur via an `unwrap` or an\n+        // `assert`.\n+        match iter.size_hint() {\n+            (0, Some(0)) => {\n+                assert!(iter.next().is_none());\n+                f(&[])\n+            }\n+            (1, Some(1)) => {\n+                let t0 = iter.next().unwrap();\n+                assert!(iter.next().is_none());\n+                f(&[t0])\n+            }\n+            (2, Some(2)) => {\n+                let t0 = iter.next().unwrap();\n+                let t1 = iter.next().unwrap();\n+                assert!(iter.next().is_none());\n+                f(&[t0, t1])\n+            }\n+            _ => f(&iter.collect::<SmallVec<[_; 8]>>()),\n+        }\n+    }\n+}\n+\n+impl<'a, T, R> InternIteratorElement<T, R> for &'a T\n+where\n+    T: Clone + 'a,\n+{\n+    type Output = R;\n+    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n+        // This code isn't hot.\n+        f(&iter.cloned().collect::<SmallVec<[_; 8]>>())\n+    }\n+}\n+\n+impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n+    type Output = Result<R, E>;\n+    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(\n+        mut iter: I,\n+        f: F,\n+    ) -> Self::Output {\n+        // This code is hot enough that it's worth specializing for the most\n+        // common length lists, to avoid the overhead of `SmallVec` creation.\n+        // Lengths 0, 1, and 2 typically account for ~95% of cases. If\n+        // `size_hint` is incorrect a panic will occur via an `unwrap` or an\n+        // `assert`, unless a failure happens first, in which case the result\n+        // will be an error anyway.\n+        Ok(match iter.size_hint() {\n+            (0, Some(0)) => {\n+                assert!(iter.next().is_none());\n+                f(&[])\n+            }\n+            (1, Some(1)) => {\n+                let t0 = iter.next().unwrap()?;\n+                assert!(iter.next().is_none());\n+                f(&[t0])\n+            }\n+            (2, Some(2)) => {\n+                let t0 = iter.next().unwrap()?;\n+                let t1 = iter.next().unwrap()?;\n+                assert!(iter.next().is_none());\n+                f(&[t0, t1])\n+            }\n+            _ => f(&iter.collect::<Result<SmallVec<[_; 8]>, _>>()?),\n+        })\n+    }\n+}\n+\n bitflags! {\n     /// Flags that we track on types. These flags are propagated upwards\n     /// through the type during type construction, so that we can quickly check"}, {"sha": "650c3519b562e8cf4bc1045bd0925481019e082d", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "added", "additions": 1040, "deletions": 0, "changes": 1040, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -0,0 +1,1040 @@\n+#![allow(rustc::usage_of_ty_tykind)]\n+\n+use std::cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n+use std::{fmt, hash};\n+\n+use crate::DebruijnIndex;\n+use crate::FloatTy;\n+use crate::IntTy;\n+use crate::Interner;\n+use crate::TyDecoder;\n+use crate::TyEncoder;\n+use crate::UintTy;\n+\n+use self::TyKind::*;\n+\n+use rustc_data_structures::stable_hasher::HashStable;\n+use rustc_serialize::{Decodable, Encodable};\n+\n+/// Defines the kinds of types used by the type system.\n+///\n+/// Types written by the user start out as `hir::TyKind` and get\n+/// converted to this representation using `AstConv::ast_ty_to_ty`.\n+///\n+/// The `HashStable` implementation for this type is defined in `rustc_query_system::ich`.\n+#[rustc_diagnostic_item = \"IrTyKind\"]\n+pub enum TyKind<I: Interner> {\n+    /// The primitive boolean type. Written as `bool`.\n+    Bool,\n+\n+    /// The primitive character type; holds a Unicode scalar value\n+    /// (a non-surrogate code point). Written as `char`.\n+    Char,\n+\n+    /// A primitive signed integer type. For example, `i32`.\n+    Int(IntTy),\n+\n+    /// A primitive unsigned integer type. For example, `u32`.\n+    Uint(UintTy),\n+\n+    /// A primitive floating-point type. For example, `f64`.\n+    Float(FloatTy),\n+\n+    /// Algebraic data types (ADT). For example: structures, enumerations and unions.\n+    ///\n+    /// For example, the type `List<i32>` would be represented using the `AdtDef`\n+    /// for `struct List<T>` and the substs `[i32]`.\n+    ///\n+    /// Note that generic parameters in fields only get lazily substituted\n+    /// by using something like `adt_def.all_fields().map(|field| field.ty(tcx, substs))`.\n+    Adt(I::AdtDef, I::SubstsRef),\n+\n+    /// An unsized FFI type that is opaque to Rust. Written as `extern type T`.\n+    Foreign(I::DefId),\n+\n+    /// The pointee of a string slice. Written as `str`.\n+    Str,\n+\n+    /// An array with the given length. Written as `[T; N]`.\n+    Array(I::Ty, I::Const),\n+\n+    /// The pointee of an array slice. Written as `[T]`.\n+    Slice(I::Ty),\n+\n+    /// A raw pointer. Written as `*mut T` or `*const T`\n+    RawPtr(I::TypeAndMut),\n+\n+    /// A reference; a pointer with an associated lifetime. Written as\n+    /// `&'a mut T` or `&'a T`.\n+    Ref(I::Region, I::Ty, I::Mutability),\n+\n+    /// The anonymous type of a function declaration/definition. Each\n+    /// function has a unique type.\n+    ///\n+    /// For the function `fn foo() -> i32 { 3 }` this type would be\n+    /// shown to the user as `fn() -> i32 {foo}`.\n+    ///\n+    /// For example the type of `bar` here:\n+    /// ```rust\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar = foo; // bar: fn() -> i32 {foo}\n+    /// ```\n+    FnDef(I::DefId, I::SubstsRef),\n+\n+    /// A pointer to a function. Written as `fn() -> i32`.\n+    ///\n+    /// Note that both functions and closures start out as either\n+    /// [FnDef] or [Closure] which can be then be coerced to this variant.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```rust\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar: fn() -> i32 = foo;\n+    /// ```\n+    FnPtr(I::PolyFnSig),\n+\n+    /// A trait object. Written as `dyn for<'b> Trait<'b, Assoc = u32> + Send + 'a`.\n+    Dynamic(I::ListBinderExistentialPredicate, I::Region),\n+\n+    /// The anonymous type of a closure. Used to represent the type of `|a| a`.\n+    ///\n+    /// Closure substs contain both the - potentially substituted - generic parameters\n+    /// of its parent and some synthetic parameters. See the documentation for\n+    /// `ClosureSubsts` for more details.\n+    Closure(I::DefId, I::SubstsRef),\n+\n+    /// The anonymous type of a generator. Used to represent the type of\n+    /// `|a| yield a`.\n+    ///\n+    /// For more info about generator substs, visit the documentation for\n+    /// `GeneratorSubsts`.\n+    Generator(I::DefId, I::SubstsRef, I::Movability),\n+\n+    /// A type representing the types stored inside a generator.\n+    /// This should only appear as part of the `GeneratorSubsts`.\n+    ///\n+    /// Note that the captured variables for generators are stored separately\n+    /// using a tuple in the same way as for closures.\n+    ///\n+    /// Unlike upvars, the witness can reference lifetimes from\n+    /// inside of the generator itself. To deal with them in\n+    /// the type of the generator, we convert them to higher ranked\n+    /// lifetimes bound by the witness itself.\n+    ///\n+    /// Looking at the following example, the witness for this generator\n+    /// may end up as something like `for<'a> [Vec<i32>, &'a Vec<i32>]`:\n+    ///\n+    /// ```ignore UNSOLVED (ask @compiler-errors, should this error? can we just swap the yields?)\n+    /// #![feature(generators)]\n+    /// |a| {\n+    ///     let x = &vec![3];\n+    ///     yield a;\n+    ///     yield x[0];\n+    /// }\n+    /// # ;\n+    /// ```\n+    GeneratorWitness(I::BinderListTy),\n+\n+    /// The never type `!`.\n+    Never,\n+\n+    /// A tuple type. For example, `(i32, bool)`.\n+    Tuple(I::ListTy),\n+\n+    /// The projection of an associated type. For example,\n+    /// `<T as Trait<..>>::N`.\n+    Projection(I::ProjectionTy),\n+\n+    /// Opaque (`impl Trait`) type found in a return type.\n+    ///\n+    /// The `DefId` comes either from\n+    /// * the `impl Trait` ast::Ty node,\n+    /// * or the `type Foo = impl Trait` declaration\n+    ///\n+    /// For RPIT the substitutions are for the generics of the function,\n+    /// while for TAIT it is used for the generic parameters of the alias.\n+    ///\n+    /// During codegen, `tcx.type_of(def_id)` can be used to get the underlying type.\n+    Opaque(I::DefId, I::SubstsRef),\n+\n+    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}`.\n+    Param(I::ParamTy),\n+\n+    /// Bound type variable, used to represent the `'a` in `for<'a> fn(&'a ())`.\n+    ///\n+    /// For canonical queries, we replace inference variables with bound variables,\n+    /// so e.g. when checking whether `&'_ (): Trait<_>` holds, we canonicalize that to\n+    /// `for<'a, T> &'a (): Trait<T>` and then convert the introduced bound variables\n+    /// back to inference variables in a new inference context when inside of the query.\n+    ///\n+    /// See the `rustc-dev-guide` for more details about\n+    /// [higher-ranked trait bounds][1] and [canonical queries][2].\n+    ///\n+    /// [1]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n+    /// [2]: https://rustc-dev-guide.rust-lang.org/traits/canonical-queries.html\n+    Bound(DebruijnIndex, I::BoundTy),\n+\n+    /// A placeholder type, used during higher ranked subtyping to instantiate\n+    /// bound variables.\n+    Placeholder(I::PlaceholderType),\n+\n+    /// A type variable used during type checking.\n+    ///\n+    /// Similar to placeholders, inference variables also live in a universe to\n+    /// correctly deal with higher ranked types. Though unlike placeholders,\n+    /// that universe is stored in the `InferCtxt` instead of directly\n+    /// inside of the type.\n+    Infer(I::InferTy),\n+\n+    /// A placeholder for a type which could not be computed; this is\n+    /// propagated to avoid useless error messages.\n+    Error(I::DelaySpanBugEmitted),\n+}\n+\n+impl<I: Interner> TyKind<I> {\n+    #[inline]\n+    pub fn is_primitive(&self) -> bool {\n+        matches!(self, Bool | Char | Int(_) | Uint(_) | Float(_))\n+    }\n+}\n+\n+// This is manually implemented for `TyKind` because `std::mem::discriminant`\n+// returns an opaque value that is `PartialEq` but not `PartialOrd`\n+#[inline]\n+const fn discriminant<I: Interner>(value: &TyKind<I>) -> usize {\n+    match value {\n+        Bool => 0,\n+        Char => 1,\n+        Int(_) => 2,\n+        Uint(_) => 3,\n+        Float(_) => 4,\n+        Adt(_, _) => 5,\n+        Foreign(_) => 6,\n+        Str => 7,\n+        Array(_, _) => 8,\n+        Slice(_) => 9,\n+        RawPtr(_) => 10,\n+        Ref(_, _, _) => 11,\n+        FnDef(_, _) => 12,\n+        FnPtr(_) => 13,\n+        Dynamic(_, _) => 14,\n+        Closure(_, _) => 15,\n+        Generator(_, _, _) => 16,\n+        GeneratorWitness(_) => 17,\n+        Never => 18,\n+        Tuple(_) => 19,\n+        Projection(_) => 20,\n+        Opaque(_, _) => 21,\n+        Param(_) => 22,\n+        Bound(_, _) => 23,\n+        Placeholder(_) => 24,\n+        Infer(_) => 25,\n+        Error(_) => 26,\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: Clone`\n+impl<I: Interner> Clone for TyKind<I> {\n+    fn clone(&self) -> Self {\n+        match self {\n+            Bool => Bool,\n+            Char => Char,\n+            Int(i) => Int(i.clone()),\n+            Uint(u) => Uint(u.clone()),\n+            Float(f) => Float(f.clone()),\n+            Adt(d, s) => Adt(d.clone(), s.clone()),\n+            Foreign(d) => Foreign(d.clone()),\n+            Str => Str,\n+            Array(t, c) => Array(t.clone(), c.clone()),\n+            Slice(t) => Slice(t.clone()),\n+            RawPtr(t) => RawPtr(t.clone()),\n+            Ref(r, t, m) => Ref(r.clone(), t.clone(), m.clone()),\n+            FnDef(d, s) => FnDef(d.clone(), s.clone()),\n+            FnPtr(s) => FnPtr(s.clone()),\n+            Dynamic(p, r) => Dynamic(p.clone(), r.clone()),\n+            Closure(d, s) => Closure(d.clone(), s.clone()),\n+            Generator(d, s, m) => Generator(d.clone(), s.clone(), m.clone()),\n+            GeneratorWitness(g) => GeneratorWitness(g.clone()),\n+            Never => Never,\n+            Tuple(t) => Tuple(t.clone()),\n+            Projection(p) => Projection(p.clone()),\n+            Opaque(d, s) => Opaque(d.clone(), s.clone()),\n+            Param(p) => Param(p.clone()),\n+            Bound(d, b) => Bound(d.clone(), b.clone()),\n+            Placeholder(p) => Placeholder(p.clone()),\n+            Infer(t) => Infer(t.clone()),\n+            Error(e) => Error(e.clone()),\n+        }\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: PartialEq`\n+impl<I: Interner> PartialEq for TyKind<I> {\n+    #[inline]\n+    fn eq(&self, other: &TyKind<I>) -> bool {\n+        let __self_vi = discriminant(self);\n+        let __arg_1_vi = discriminant(other);\n+        if __self_vi == __arg_1_vi {\n+            match (&*self, &*other) {\n+                (&Int(ref __self_0), &Int(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Uint(ref __self_0), &Uint(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Float(ref __self_0), &Float(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Adt(ref __self_0, ref __self_1), &Adt(ref __arg_1_0, ref __arg_1_1)) => {\n+                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                }\n+                (&Foreign(ref __self_0), &Foreign(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Array(ref __self_0, ref __self_1), &Array(ref __arg_1_0, ref __arg_1_1)) => {\n+                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                }\n+                (&Slice(ref __self_0), &Slice(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&RawPtr(ref __self_0), &RawPtr(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (\n+                    &Ref(ref __self_0, ref __self_1, ref __self_2),\n+                    &Ref(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n+                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1 && __self_2 == __arg_1_2,\n+                (&FnDef(ref __self_0, ref __self_1), &FnDef(ref __arg_1_0, ref __arg_1_1)) => {\n+                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                }\n+                (&FnPtr(ref __self_0), &FnPtr(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Dynamic(ref __self_0, ref __self_1), &Dynamic(ref __arg_1_0, ref __arg_1_1)) => {\n+                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                }\n+                (&Closure(ref __self_0, ref __self_1), &Closure(ref __arg_1_0, ref __arg_1_1)) => {\n+                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                }\n+                (\n+                    &Generator(ref __self_0, ref __self_1, ref __self_2),\n+                    &Generator(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n+                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1 && __self_2 == __arg_1_2,\n+                (&GeneratorWitness(ref __self_0), &GeneratorWitness(ref __arg_1_0)) => {\n+                    __self_0 == __arg_1_0\n+                }\n+                (&Tuple(ref __self_0), &Tuple(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Projection(ref __self_0), &Projection(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Opaque(ref __self_0, ref __self_1), &Opaque(ref __arg_1_0, ref __arg_1_1)) => {\n+                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                }\n+                (&Param(ref __self_0), &Param(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Bound(ref __self_0, ref __self_1), &Bound(ref __arg_1_0, ref __arg_1_1)) => {\n+                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                }\n+                (&Placeholder(ref __self_0), &Placeholder(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Infer(ref __self_0), &Infer(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Error(ref __self_0), &Error(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                _ => true,\n+            }\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: Eq`\n+impl<I: Interner> Eq for TyKind<I> {}\n+\n+// This is manually implemented because a derive would require `I: PartialOrd`\n+impl<I: Interner> PartialOrd for TyKind<I> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &TyKind<I>) -> Option<Ordering> {\n+        Some(Ord::cmp(self, other))\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: Ord`\n+impl<I: Interner> Ord for TyKind<I> {\n+    #[inline]\n+    fn cmp(&self, other: &TyKind<I>) -> Ordering {\n+        let __self_vi = discriminant(self);\n+        let __arg_1_vi = discriminant(other);\n+        if __self_vi == __arg_1_vi {\n+            match (&*self, &*other) {\n+                (&Int(ref __self_0), &Int(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Uint(ref __self_0), &Uint(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Float(ref __self_0), &Float(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Adt(ref __self_0, ref __self_1), &Adt(ref __arg_1_0, ref __arg_1_1)) => {\n+                    match Ord::cmp(__self_0, __arg_1_0) {\n+                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                        cmp => cmp,\n+                    }\n+                }\n+                (&Foreign(ref __self_0), &Foreign(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Array(ref __self_0, ref __self_1), &Array(ref __arg_1_0, ref __arg_1_1)) => {\n+                    match Ord::cmp(__self_0, __arg_1_0) {\n+                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                        cmp => cmp,\n+                    }\n+                }\n+                (&Slice(ref __self_0), &Slice(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&RawPtr(ref __self_0), &RawPtr(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (\n+                    &Ref(ref __self_0, ref __self_1, ref __self_2),\n+                    &Ref(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n+                ) => match Ord::cmp(__self_0, __arg_1_0) {\n+                    Ordering::Equal => match Ord::cmp(__self_1, __arg_1_1) {\n+                        Ordering::Equal => Ord::cmp(__self_2, __arg_1_2),\n+                        cmp => cmp,\n+                    },\n+                    cmp => cmp,\n+                },\n+                (&FnDef(ref __self_0, ref __self_1), &FnDef(ref __arg_1_0, ref __arg_1_1)) => {\n+                    match Ord::cmp(__self_0, __arg_1_0) {\n+                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                        cmp => cmp,\n+                    }\n+                }\n+                (&FnPtr(ref __self_0), &FnPtr(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Dynamic(ref __self_0, ref __self_1), &Dynamic(ref __arg_1_0, ref __arg_1_1)) => {\n+                    match Ord::cmp(__self_0, __arg_1_0) {\n+                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                        cmp => cmp,\n+                    }\n+                }\n+                (&Closure(ref __self_0, ref __self_1), &Closure(ref __arg_1_0, ref __arg_1_1)) => {\n+                    match Ord::cmp(__self_0, __arg_1_0) {\n+                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                        cmp => cmp,\n+                    }\n+                }\n+                (\n+                    &Generator(ref __self_0, ref __self_1, ref __self_2),\n+                    &Generator(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n+                ) => match Ord::cmp(__self_0, __arg_1_0) {\n+                    Ordering::Equal => match Ord::cmp(__self_1, __arg_1_1) {\n+                        Ordering::Equal => Ord::cmp(__self_2, __arg_1_2),\n+                        cmp => cmp,\n+                    },\n+                    cmp => cmp,\n+                },\n+                (&GeneratorWitness(ref __self_0), &GeneratorWitness(ref __arg_1_0)) => {\n+                    Ord::cmp(__self_0, __arg_1_0)\n+                }\n+                (&Tuple(ref __self_0), &Tuple(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Projection(ref __self_0), &Projection(ref __arg_1_0)) => {\n+                    Ord::cmp(__self_0, __arg_1_0)\n+                }\n+                (&Opaque(ref __self_0, ref __self_1), &Opaque(ref __arg_1_0, ref __arg_1_1)) => {\n+                    match Ord::cmp(__self_0, __arg_1_0) {\n+                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                        cmp => cmp,\n+                    }\n+                }\n+                (&Param(ref __self_0), &Param(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Bound(ref __self_0, ref __self_1), &Bound(ref __arg_1_0, ref __arg_1_1)) => {\n+                    match Ord::cmp(__self_0, __arg_1_0) {\n+                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                        cmp => cmp,\n+                    }\n+                }\n+                (&Placeholder(ref __self_0), &Placeholder(ref __arg_1_0)) => {\n+                    Ord::cmp(__self_0, __arg_1_0)\n+                }\n+                (&Infer(ref __self_0), &Infer(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Error(ref __self_0), &Error(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                _ => Ordering::Equal,\n+            }\n+        } else {\n+            Ord::cmp(&__self_vi, &__arg_1_vi)\n+        }\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: Hash`\n+impl<I: Interner> hash::Hash for TyKind<I> {\n+    fn hash<__H: hash::Hasher>(&self, state: &mut __H) -> () {\n+        match (&*self,) {\n+            (&Int(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Uint(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Float(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Adt(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&Foreign(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Array(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&Slice(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&RawPtr(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Ref(ref __self_0, ref __self_1, ref __self_2),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state);\n+                hash::Hash::hash(__self_2, state)\n+            }\n+            (&FnDef(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&FnPtr(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Dynamic(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&Closure(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&Generator(ref __self_0, ref __self_1, ref __self_2),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state);\n+                hash::Hash::hash(__self_2, state)\n+            }\n+            (&GeneratorWitness(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Tuple(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Projection(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Opaque(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&Param(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Bound(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&Placeholder(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Infer(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Error(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            _ => hash::Hash::hash(&discriminant(self), state),\n+        }\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: Debug`\n+impl<I: Interner> fmt::Debug for TyKind<I> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match (&*self,) {\n+            (&Bool,) => fmt::Formatter::write_str(f, \"Bool\"),\n+            (&Char,) => fmt::Formatter::write_str(f, \"Char\"),\n+            (&Int(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Int\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Uint(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Uint\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Float(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Float\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Adt(ref __self_0, ref __self_1),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Adt\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Foreign(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Foreign\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Str,) => fmt::Formatter::write_str(f, \"Str\"),\n+            (&Array(ref __self_0, ref __self_1),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Array\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Slice(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Slice\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&RawPtr(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"RawPtr\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Ref(ref __self_0, ref __self_1, ref __self_2),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Ref\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_2);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&FnDef(ref __self_0, ref __self_1),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"FnDef\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&FnPtr(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"FnPtr\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Dynamic(ref __self_0, ref __self_1),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Dynamic\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Closure(ref __self_0, ref __self_1),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Closure\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Generator(ref __self_0, ref __self_1, ref __self_2),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Generator\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_2);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&GeneratorWitness(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"GeneratorWitness\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Never,) => fmt::Formatter::write_str(f, \"Never\"),\n+            (&Tuple(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Tuple\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Projection(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Projection\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Opaque(ref __self_0, ref __self_1),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Opaque\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Param(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Param\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Bound(ref __self_0, ref __self_1),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Bound\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Placeholder(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Placeholder\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Infer(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Infer\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Error(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Error\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+        }\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: Encodable`\n+impl<I: Interner, E: TyEncoder> Encodable<E> for TyKind<I>\n+where\n+    I::DelaySpanBugEmitted: Encodable<E>,\n+    I::AdtDef: Encodable<E>,\n+    I::SubstsRef: Encodable<E>,\n+    I::DefId: Encodable<E>,\n+    I::Ty: Encodable<E>,\n+    I::Const: Encodable<E>,\n+    I::Region: Encodable<E>,\n+    I::TypeAndMut: Encodable<E>,\n+    I::Mutability: Encodable<E>,\n+    I::Movability: Encodable<E>,\n+    I::PolyFnSig: Encodable<E>,\n+    I::ListBinderExistentialPredicate: Encodable<E>,\n+    I::BinderListTy: Encodable<E>,\n+    I::ListTy: Encodable<E>,\n+    I::ProjectionTy: Encodable<E>,\n+    I::ParamTy: Encodable<E>,\n+    I::BoundTy: Encodable<E>,\n+    I::PlaceholderType: Encodable<E>,\n+    I::InferTy: Encodable<E>,\n+    I::DelaySpanBugEmitted: Encodable<E>,\n+    I::PredicateKind: Encodable<E>,\n+    I::AllocId: Encodable<E>,\n+{\n+    fn encode(&self, e: &mut E) -> Result<(), <E as rustc_serialize::Encoder>::Error> {\n+        rustc_serialize::Encoder::emit_enum(e, |e| {\n+            let disc = discriminant(self);\n+            match self {\n+                Bool => e.emit_enum_variant(\"Bool\", disc, 0, |_| Ok(())),\n+                Char => e.emit_enum_variant(\"Char\", disc, 0, |_| Ok(())),\n+                Int(i) => e.emit_enum_variant(\"Int\", disc, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| i.encode(e))?;\n+                    Ok(())\n+                }),\n+                Uint(u) => e.emit_enum_variant(\"Uint\", disc, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| u.encode(e))?;\n+                    Ok(())\n+                }),\n+                Float(f) => e.emit_enum_variant(\"Float\", disc, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| f.encode(e))?;\n+                    Ok(())\n+                }),\n+                Adt(adt, substs) => e.emit_enum_variant(\"Adt\", disc, 2, |e| {\n+                    e.emit_enum_variant_arg(true, |e| adt.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n+                    Ok(())\n+                }),\n+                Foreign(def_id) => e.emit_enum_variant(\"Foreign\", disc, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n+                    Ok(())\n+                }),\n+                Str => e.emit_enum_variant(\"Str\", disc, 0, |_| Ok(())),\n+                Array(t, c) => e.emit_enum_variant(\"Array\", disc, 2, |e| {\n+                    e.emit_enum_variant_arg(true, |e| t.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| c.encode(e))?;\n+                    Ok(())\n+                }),\n+                Slice(t) => e.emit_enum_variant(\"Slice\", disc, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| t.encode(e))?;\n+                    Ok(())\n+                }),\n+                RawPtr(tam) => e.emit_enum_variant(\"RawPtr\", disc, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| tam.encode(e))?;\n+                    Ok(())\n+                }),\n+                Ref(r, t, m) => e.emit_enum_variant(\"Ref\", disc, 3, |e| {\n+                    e.emit_enum_variant_arg(true, |e| r.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| t.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| m.encode(e))?;\n+                    Ok(())\n+                }),\n+                FnDef(def_id, substs) => e.emit_enum_variant(\"FnDef\", disc, 2, |e| {\n+                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n+                    Ok(())\n+                }),\n+                FnPtr(polyfnsig) => e.emit_enum_variant(\"FnPtr\", disc, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| polyfnsig.encode(e))?;\n+                    Ok(())\n+                }),\n+                Dynamic(l, r) => e.emit_enum_variant(\"Dynamic\", disc, 2, |e| {\n+                    e.emit_enum_variant_arg(true, |e| l.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| r.encode(e))?;\n+                    Ok(())\n+                }),\n+                Closure(def_id, substs) => e.emit_enum_variant(\"Closure\", disc, 2, |e| {\n+                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n+                    Ok(())\n+                }),\n+                Generator(def_id, substs, m) => e.emit_enum_variant(\"Generator\", disc, 3, |e| {\n+                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| m.encode(e))?;\n+                    Ok(())\n+                }),\n+                GeneratorWitness(b) => e.emit_enum_variant(\"GeneratorWitness\", disc, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| b.encode(e))?;\n+                    Ok(())\n+                }),\n+                Never => e.emit_enum_variant(\"Never\", disc, 0, |_| Ok(())),\n+                Tuple(substs) => e.emit_enum_variant(\"Tuple\", disc, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| substs.encode(e))?;\n+                    Ok(())\n+                }),\n+                Projection(p) => e.emit_enum_variant(\"Projection\", disc, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n+                    Ok(())\n+                }),\n+                Opaque(def_id, substs) => e.emit_enum_variant(\"Opaque\", disc, 2, |e| {\n+                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n+                    Ok(())\n+                }),\n+                Param(p) => e.emit_enum_variant(\"Param\", disc, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n+                    Ok(())\n+                }),\n+                Bound(d, b) => e.emit_enum_variant(\"Bound\", disc, 2, |e| {\n+                    e.emit_enum_variant_arg(true, |e| d.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| b.encode(e))?;\n+                    Ok(())\n+                }),\n+                Placeholder(p) => e.emit_enum_variant(\"Placeholder\", disc, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n+                    Ok(())\n+                }),\n+                Infer(i) => e.emit_enum_variant(\"Infer\", disc, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| i.encode(e))?;\n+                    Ok(())\n+                }),\n+                Error(d) => e.emit_enum_variant(\"Error\", disc, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| d.encode(e))?;\n+                    Ok(())\n+                }),\n+            }\n+        })\n+    }\n+}\n+\n+// This is manually implemented because a derive would require `I: Decodable`\n+impl<I: Interner, D: TyDecoder<I = I>> Decodable<D> for TyKind<I>\n+where\n+    I::DelaySpanBugEmitted: Decodable<D>,\n+    I::AdtDef: Decodable<D>,\n+    I::SubstsRef: Decodable<D>,\n+    I::DefId: Decodable<D>,\n+    I::Ty: Decodable<D>,\n+    I::Const: Decodable<D>,\n+    I::Region: Decodable<D>,\n+    I::TypeAndMut: Decodable<D>,\n+    I::Mutability: Decodable<D>,\n+    I::Movability: Decodable<D>,\n+    I::PolyFnSig: Decodable<D>,\n+    I::ListBinderExistentialPredicate: Decodable<D>,\n+    I::BinderListTy: Decodable<D>,\n+    I::ListTy: Decodable<D>,\n+    I::ProjectionTy: Decodable<D>,\n+    I::ParamTy: Decodable<D>,\n+    I::BoundTy: Decodable<D>,\n+    I::PlaceholderType: Decodable<D>,\n+    I::InferTy: Decodable<D>,\n+    I::DelaySpanBugEmitted: Decodable<D>,\n+    I::PredicateKind: Decodable<D>,\n+    I::AllocId: Decodable<D>,\n+{\n+    fn decode(d: &mut D) -> Self {\n+        match rustc_serialize::Decoder::read_usize(d) {\n+            0 => Bool,\n+            1 => Char,\n+            2 => Int(rustc_serialize::Decodable::decode(d)),\n+            3 => Uint(rustc_serialize::Decodable::decode(d)),\n+            4 => Float(rustc_serialize::Decodable::decode(d)),\n+            5 => Adt(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d)),\n+            6 => Foreign(rustc_serialize::Decodable::decode(d)),\n+            7 => Str,\n+            8 => {\n+                Array(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d))\n+            }\n+            9 => Slice(rustc_serialize::Decodable::decode(d)),\n+            10 => RawPtr(rustc_serialize::Decodable::decode(d)),\n+            11 => Ref(\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n+            ),\n+            12 => {\n+                FnDef(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d))\n+            }\n+            13 => FnPtr(rustc_serialize::Decodable::decode(d)),\n+            14 => Dynamic(\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n+            ),\n+            15 => Closure(\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n+            ),\n+            16 => Generator(\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n+            ),\n+            17 => GeneratorWitness(rustc_serialize::Decodable::decode(d)),\n+            18 => Never,\n+            19 => Tuple(rustc_serialize::Decodable::decode(d)),\n+            20 => Projection(rustc_serialize::Decodable::decode(d)),\n+            21 => {\n+                Opaque(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d))\n+            }\n+            22 => Param(rustc_serialize::Decodable::decode(d)),\n+            23 => {\n+                Bound(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d))\n+            }\n+            24 => Placeholder(rustc_serialize::Decodable::decode(d)),\n+            25 => Infer(rustc_serialize::Decodable::decode(d)),\n+            26 => Error(rustc_serialize::Decodable::decode(d)),\n+            _ => panic!(\n+                \"{}\",\n+                format!(\n+                    \"invalid enum variant tag while decoding `{}`, expected 0..{}\",\n+                    \"TyKind\", 27,\n+                )\n+            ),\n+        }\n+    }\n+}\n+\n+// This is not a derived impl because a derive would require `I: HashStable`\n+#[allow(rustc::usage_of_ty_tykind)]\n+impl<CTX, I: Interner> HashStable<CTX> for TyKind<I>\n+where\n+    I::AdtDef: HashStable<CTX>,\n+    I::DefId: HashStable<CTX>,\n+    I::SubstsRef: HashStable<CTX>,\n+    I::Ty: HashStable<CTX>,\n+    I::Const: HashStable<CTX>,\n+    I::TypeAndMut: HashStable<CTX>,\n+    I::PolyFnSig: HashStable<CTX>,\n+    I::ListBinderExistentialPredicate: HashStable<CTX>,\n+    I::Region: HashStable<CTX>,\n+    I::Movability: HashStable<CTX>,\n+    I::Mutability: HashStable<CTX>,\n+    I::BinderListTy: HashStable<CTX>,\n+    I::ListTy: HashStable<CTX>,\n+    I::ProjectionTy: HashStable<CTX>,\n+    I::BoundTy: HashStable<CTX>,\n+    I::ParamTy: HashStable<CTX>,\n+    I::PlaceholderType: HashStable<CTX>,\n+    I::InferTy: HashStable<CTX>,\n+    I::DelaySpanBugEmitted: HashStable<CTX>,\n+{\n+    #[inline]\n+    fn hash_stable(\n+        &self,\n+        __hcx: &mut CTX,\n+        __hasher: &mut rustc_data_structures::stable_hasher::StableHasher,\n+    ) {\n+        std::mem::discriminant(self).hash_stable(__hcx, __hasher);\n+        match self {\n+            Bool => {}\n+            Char => {}\n+            Int(i) => {\n+                i.hash_stable(__hcx, __hasher);\n+            }\n+            Uint(u) => {\n+                u.hash_stable(__hcx, __hasher);\n+            }\n+            Float(f) => {\n+                f.hash_stable(__hcx, __hasher);\n+            }\n+            Adt(adt, substs) => {\n+                adt.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            Foreign(def_id) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+            }\n+            Str => {}\n+            Array(t, c) => {\n+                t.hash_stable(__hcx, __hasher);\n+                c.hash_stable(__hcx, __hasher);\n+            }\n+            Slice(t) => {\n+                t.hash_stable(__hcx, __hasher);\n+            }\n+            RawPtr(tam) => {\n+                tam.hash_stable(__hcx, __hasher);\n+            }\n+            Ref(r, t, m) => {\n+                r.hash_stable(__hcx, __hasher);\n+                t.hash_stable(__hcx, __hasher);\n+                m.hash_stable(__hcx, __hasher);\n+            }\n+            FnDef(def_id, substs) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            FnPtr(polyfnsig) => {\n+                polyfnsig.hash_stable(__hcx, __hasher);\n+            }\n+            Dynamic(l, r) => {\n+                l.hash_stable(__hcx, __hasher);\n+                r.hash_stable(__hcx, __hasher);\n+            }\n+            Closure(def_id, substs) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            Generator(def_id, substs, m) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+                m.hash_stable(__hcx, __hasher);\n+            }\n+            GeneratorWitness(b) => {\n+                b.hash_stable(__hcx, __hasher);\n+            }\n+            Never => {}\n+            Tuple(substs) => {\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            Projection(p) => {\n+                p.hash_stable(__hcx, __hasher);\n+            }\n+            Opaque(def_id, substs) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            Param(p) => {\n+                p.hash_stable(__hcx, __hasher);\n+            }\n+            Bound(d, b) => {\n+                d.hash_stable(__hcx, __hasher);\n+                b.hash_stable(__hcx, __hasher);\n+            }\n+            Placeholder(p) => {\n+                p.hash_stable(__hcx, __hasher);\n+            }\n+            Infer(i) => {\n+                i.hash_stable(__hcx, __hasher);\n+            }\n+            Error(d) => {\n+                d.hash_stable(__hcx, __hasher);\n+            }\n+        }\n+    }\n+}"}, {"sha": "c08023ee6a70a50187c9c8bbf4b19f17c5d96c8b", "filename": "compiler/rustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2FCargo.toml?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -29,3 +29,4 @@ rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n rustc_lint = { path = \"../rustc_lint\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }"}, {"sha": "419ccb5a73aac39959d262ddc6a67b2acf913b9f", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, AssocItem, Ty, TypeAndMut};\n+use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span};\n "}, {"sha": "9cb57759b86c14a56765399ec05504a61284296e", "filename": "compiler/rustc_typeck/src/check/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -4,7 +4,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n-use rustc_middle::ty::{self, FloatTy, InferTy, IntTy, Ty, TyCtxt, TypeFoldable, UintTy};\n+use rustc_middle::ty::{self, Article, FloatTy, InferTy, IntTy, Ty, TyCtxt, TypeFoldable, UintTy};\n use rustc_session::lint;\n use rustc_span::{Span, Symbol, DUMMY_SP};\n use rustc_target::abi::{Pointer, VariantIdx};"}, {"sha": "3ae04706e4bc33d8acf8914f14d2771b792985f4", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -10,14 +10,14 @@ use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n use rustc_middle::ty::fold::TypeFolder;\n-use rustc_middle::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple, Uint};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt as _;\n use rustc_trait_selection::traits::{FulfillmentError, TraitEngine, TraitEngineExt};\n+use rustc_type_ir::sty::TyKind::*;\n \n use std::ops::ControlFlow;\n "}, {"sha": "d08d9938708c914cfab09270c0519c4ef99f970a", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -177,7 +177,7 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n     tcx.infer_ctxt().enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_hir_id);\n \n-        use ty::TyKind::*;\n+        use rustc_type_ir::sty::TyKind::*;\n         match (source.kind(), target.kind()) {\n             (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n                 if infcx.at(&cause, param_env).eq(r_a, *r_b).is_ok() && mutbl_a == *mutbl_b => {}"}, {"sha": "8f78bda033ec18726123ae23da4afe8e0af6b73a", "filename": "src/test/run-make-fulldeps/obtain-borrowck/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -154,7 +154,7 @@ fn get_bodies<'tcx>(tcx: TyCtxt<'tcx>) -> Vec<(String, BodyWithBorrowckFacts<'tc\n                 // SAFETY: For soundness we need to ensure that the bodies have\n                 // the same lifetime (`'tcx`), which they had before they were\n                 // stored in the thread local.\n-                (def_path.to_string_no_crate_verbose(), body)\n+                (def_path.to_string_no_crate_verbose(), unsafe { std::mem::transmute(body) })\n             })\n             .collect()\n     })"}, {"sha": "2cb1ed6fcb76b349133493d7a627d91ba157e16a", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -3,46 +3,54 @@\n #![feature(rustc_private)]\n \n extern crate rustc_middle;\n+extern crate rustc_type_ir;\n \n use rustc_middle::ty::{self, Ty, TyKind};\n+use rustc_type_ir::{Interner, TyKind as IrTyKind};\n \n #[deny(rustc::usage_of_ty_tykind)]\n fn main() {\n     let kind = TyKind::Bool; //~ ERROR usage of `ty::TyKind::<kind>`\n \n     match kind {\n-        TyKind::Bool => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Char => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Int(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Uint(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Float(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Adt(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Foreign(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Str => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Array(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Slice(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::RawPtr(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Ref(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::FnDef(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::FnPtr(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Dynamic(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Closure(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Generator(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Bool => (),                 //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Char => (),                 //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Int(..) => (),              //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Uint(..) => (),             //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Float(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Adt(..) => (),              //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Foreign(..) => (),          //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Str => (),                  //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Array(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Slice(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::RawPtr(..) => (),           //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Ref(..) => (),              //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::FnDef(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::FnPtr(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Dynamic(..) => (),          //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Closure(..) => (),          //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Generator(..) => (),        //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::GeneratorWitness(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Never => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Tuple(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Projection(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Opaque(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Param(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Bound(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Placeholder(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Infer(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Error(_) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Never => (),                //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Tuple(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Projection(..) => (),       //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Opaque(..) => (),           //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Param(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Bound(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Placeholder(..) => (),      //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Infer(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Error(_) => (),             //~ ERROR usage of `ty::TyKind::<kind>`\n     }\n \n     if let ty::Int(int_ty) = kind {}\n \n     if let TyKind::Int(int_ty) = kind {} //~ ERROR usage of `ty::TyKind::<kind>`\n \n     fn ty_kind(ty_bad: TyKind<'_>, ty_good: Ty<'_>) {} //~ ERROR usage of `ty::TyKind`\n+\n+    fn ir_ty_kind<I: Interner>(bad: IrTyKind<I>) -> IrTyKind<I> {\n+        //~^ ERROR usage of `ty::TyKind`\n+        //~| ERROR usage of `ty::TyKind`\n+        IrTyKind::Bool //~ ERROR usage of `ty::TyKind::<kind>`\n+    }\n }"}, {"sha": "171f49087d6953fc4818eafa7c00b7794fa7a038", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.stderr", "status": "modified", "additions": 85, "deletions": 61, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/0f06824013761ed6829887019033f1001e68f623/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f06824013761ed6829887019033f1001e68f623/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr?ref=0f06824013761ed6829887019033f1001e68f623", "patch": "@@ -1,190 +1,214 @@\n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:11:16\n+  --> $DIR/ty_tykind_usage.rs:13:16\n    |\n LL |     let kind = TyKind::Bool;\n-   |                ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |                ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n    |\n note: the lint level is defined here\n-  --> $DIR/ty_tykind_usage.rs:9:8\n+  --> $DIR/ty_tykind_usage.rs:11:8\n    |\n LL | #[deny(rustc::usage_of_ty_tykind)]\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:14:9\n+  --> $DIR/ty_tykind_usage.rs:16:9\n    |\n LL |         TyKind::Bool => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:15:9\n+  --> $DIR/ty_tykind_usage.rs:17:9\n    |\n LL |         TyKind::Char => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:16:9\n+  --> $DIR/ty_tykind_usage.rs:18:9\n    |\n LL |         TyKind::Int(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:17:9\n+  --> $DIR/ty_tykind_usage.rs:19:9\n    |\n LL |         TyKind::Uint(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:18:9\n+  --> $DIR/ty_tykind_usage.rs:20:9\n    |\n LL |         TyKind::Float(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:19:9\n+  --> $DIR/ty_tykind_usage.rs:21:9\n    |\n LL |         TyKind::Adt(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:20:9\n+  --> $DIR/ty_tykind_usage.rs:22:9\n    |\n LL |         TyKind::Foreign(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:21:9\n+  --> $DIR/ty_tykind_usage.rs:23:9\n    |\n LL |         TyKind::Str => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:22:9\n+  --> $DIR/ty_tykind_usage.rs:24:9\n    |\n LL |         TyKind::Array(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:23:9\n+  --> $DIR/ty_tykind_usage.rs:25:9\n    |\n LL |         TyKind::Slice(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:24:9\n+  --> $DIR/ty_tykind_usage.rs:26:9\n    |\n LL |         TyKind::RawPtr(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:25:9\n+  --> $DIR/ty_tykind_usage.rs:27:9\n    |\n LL |         TyKind::Ref(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:26:9\n+  --> $DIR/ty_tykind_usage.rs:28:9\n    |\n LL |         TyKind::FnDef(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:27:9\n+  --> $DIR/ty_tykind_usage.rs:29:9\n    |\n LL |         TyKind::FnPtr(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:28:9\n+  --> $DIR/ty_tykind_usage.rs:30:9\n    |\n LL |         TyKind::Dynamic(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:29:9\n+  --> $DIR/ty_tykind_usage.rs:31:9\n    |\n LL |         TyKind::Closure(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:30:9\n+  --> $DIR/ty_tykind_usage.rs:32:9\n    |\n LL |         TyKind::Generator(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:31:9\n+  --> $DIR/ty_tykind_usage.rs:33:9\n    |\n LL |         TyKind::GeneratorWitness(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:32:9\n+  --> $DIR/ty_tykind_usage.rs:34:9\n    |\n LL |         TyKind::Never => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:33:9\n+  --> $DIR/ty_tykind_usage.rs:35:9\n    |\n LL |         TyKind::Tuple(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:34:9\n+  --> $DIR/ty_tykind_usage.rs:36:9\n    |\n LL |         TyKind::Projection(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:35:9\n+  --> $DIR/ty_tykind_usage.rs:37:9\n    |\n LL |         TyKind::Opaque(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:36:9\n+  --> $DIR/ty_tykind_usage.rs:38:9\n    |\n LL |         TyKind::Param(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:37:9\n+  --> $DIR/ty_tykind_usage.rs:39:9\n    |\n LL |         TyKind::Bound(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:38:9\n+  --> $DIR/ty_tykind_usage.rs:40:9\n    |\n LL |         TyKind::Placeholder(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:39:9\n+  --> $DIR/ty_tykind_usage.rs:41:9\n    |\n LL |         TyKind::Infer(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:40:9\n+  --> $DIR/ty_tykind_usage.rs:42:9\n    |\n LL |         TyKind::Error(_) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:45:12\n+  --> $DIR/ty_tykind_usage.rs:47:12\n    |\n LL |     if let TyKind::Int(int_ty) = kind {}\n-   |            ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |            ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind`\n-  --> $DIR/ty_tykind_usage.rs:47:24\n+  --> $DIR/ty_tykind_usage.rs:49:24\n    |\n LL |     fn ty_kind(ty_bad: TyKind<'_>, ty_good: Ty<'_>) {}\n    |                        ^^^^^^^^^^\n    |\n    = help: try using `Ty` instead\n \n-error: aborting due to 30 previous errors\n+error: usage of `ty::TyKind`\n+  --> $DIR/ty_tykind_usage.rs:51:37\n+   |\n+LL |     fn ir_ty_kind<I: Interner>(bad: IrTyKind<I>) -> IrTyKind<I> {\n+   |                                     ^^^^^^^^^^^\n+   |\n+   = help: try using `Ty` instead\n+\n+error: usage of `ty::TyKind`\n+  --> $DIR/ty_tykind_usage.rs:51:53\n+   |\n+LL |     fn ir_ty_kind<I: Interner>(bad: IrTyKind<I>) -> IrTyKind<I> {\n+   |                                                     ^^^^^^^^^^^\n+   |\n+   = help: try using `Ty` instead\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:54:9\n+   |\n+LL |         IrTyKind::Bool\n+   |         --------^^^^^^\n+   |         |\n+   |         help: try using `ty::<kind>` directly: `ty`\n+\n+error: aborting due to 33 previous errors\n "}]}