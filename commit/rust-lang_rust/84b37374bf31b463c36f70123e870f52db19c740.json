{"sha": "84b37374bf31b463c36f70123e870f52db19c740", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0YjM3Mzc0YmYzMWI0NjNjMzZmNzAxMjNlODcwZjUyZGIxOWM3NDA=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-09-15T19:37:01Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-09-15T20:48:20Z"}, "message": "heap: optimize EMPTY to avoid relocations\n\nSized deallocation makes it pointless to provide an address that never\noverlaps with pointers returned by an allocator. Code can branch on the\ncapacity of the allocation instead of a comparison with this sentinel.\n\nThis improves the situation in #8859, and the remaining issues are only\nfrom the logging API, which should be disabled by default in optimized\nrelease builds anyway along with debug assertions. The remaining issues\nare part of #17081.\n\nCloses #8859", "tree": {"sha": "73d698cc2a76498a748c5e186f3005ce19517009", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73d698cc2a76498a748c5e186f3005ce19517009"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84b37374bf31b463c36f70123e870f52db19c740", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84b37374bf31b463c36f70123e870f52db19c740", "html_url": "https://github.com/rust-lang/rust/commit/84b37374bf31b463c36f70123e870f52db19c740", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84b37374bf31b463c36f70123e870f52db19c740/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "396f9106173b941e880a0f311bc2d1429a68c983", "url": "https://api.github.com/repos/rust-lang/rust/commits/396f9106173b941e880a0f311bc2d1429a68c983", "html_url": "https://github.com/rust-lang/rust/commit/396f9106173b941e880a0f311bc2d1429a68c983"}], "stats": {"total": 25, "additions": 11, "deletions": 14}, "files": [{"sha": "b6c255e79306644b667b1bdedc518ec291c000f9", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/84b37374bf31b463c36f70123e870f52db19c740/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b37374bf31b463c36f70123e870f52db19c740/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=84b37374bf31b463c36f70123e870f52db19c740", "patch": "@@ -86,18 +86,19 @@ pub fn stats_print() {\n     imp::stats_print();\n }\n \n-// The compiler never calls `exchange_free` on Box<ZeroSizeType>, so zero-size\n-// allocations can point to this `static`. It would be incorrect to use a null\n-// pointer, due to enums assuming types like unique pointers are never null.\n-pub static mut EMPTY: uint = 12345;\n+/// An arbitrary non-null address to represent zero-size allocations.\n+///\n+/// This preserves the non-null invariant for types like `Box<T>`. The address may overlap with\n+/// non-zero-size memory allocations.\n+pub static EMPTY: *mut () = 0x1 as *mut ();\n \n /// The allocator for unique pointers.\n #[cfg(not(test))]\n #[lang=\"exchange_malloc\"]\n #[inline]\n unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n     if size == 0 {\n-        &EMPTY as *const uint as *mut u8\n+        EMPTY as *mut u8\n     } else {\n         allocate(size, align)\n     }"}, {"sha": "3597ab285baf0a6224d33c5098cfe1bf320dcb79", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/84b37374bf31b463c36f70123e870f52db19c740/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b37374bf31b463c36f70123e870f52db19c740/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=84b37374bf31b463c36f70123e870f52db19c740", "patch": "@@ -12,7 +12,7 @@\n \n use core::prelude::*;\n \n-use alloc::heap::{allocate, reallocate, deallocate};\n+use alloc::heap::{EMPTY, allocate, reallocate, deallocate};\n use core::cmp::max;\n use core::default::Default;\n use core::fmt;\n@@ -26,10 +26,6 @@ use {Mutable, MutableSeq};\n use slice::{MutableOrdSlice, MutableSliceAllocating, CloneableVector};\n use slice::{Items, MutItems};\n \n-\n-#[doc(hidden)]\n-pub static PTR_MARKER: u8 = 0;\n-\n /// An owned, growable vector.\n ///\n /// # Examples\n@@ -122,7 +118,7 @@ impl<T> Vec<T> {\n         // non-null value which is fine since we never call deallocate on the ptr\n         // if cap is 0. The reason for this is because the pointer of a slice\n         // being NULL would break the null pointer optimization for enums.\n-        Vec { len: 0, cap: 0, ptr: &PTR_MARKER as *const _ as *mut T }\n+        Vec { len: 0, cap: 0, ptr: EMPTY as *mut T }\n     }\n \n     /// Constructs a new, empty `Vec` with the specified capacity.\n@@ -155,7 +151,7 @@ impl<T> Vec<T> {\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n-            Vec { len: 0, cap: uint::MAX, ptr: &PTR_MARKER as *const _ as *mut T }\n+            Vec { len: 0, cap: uint::MAX, ptr: EMPTY as *mut T }\n         } else if capacity == 0 {\n             Vec::new()\n         } else {"}, {"sha": "33482ec0eb35952e58be0c4669963b689e3aabb3", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/84b37374bf31b463c36f70123e870f52db19c740/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84b37374bf31b463c36f70123e870f52db19c740/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=84b37374bf31b463c36f70123e870f52db19c740", "patch": "@@ -12,6 +12,7 @@ use std::fmt;\n use std::default::Default;\n use std::hash;\n use std::{mem, raw, ptr, slice, vec};\n+use std::rt::heap::EMPTY;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// A non-growable owned slice. This would preferably become `~[T]`\n@@ -81,10 +82,9 @@ impl<T> OwnedSlice<T> {\n     }\n \n     pub fn as_slice<'a>(&'a self) -> &'a [T] {\n-        static PTR_MARKER: u8 = 0;\n         let ptr = if self.data.is_null() {\n             // length zero, i.e. this will never be read as a T.\n-            &PTR_MARKER as *const u8 as *const T\n+            EMPTY as *const T\n         } else {\n             self.data as *const T\n         };"}]}