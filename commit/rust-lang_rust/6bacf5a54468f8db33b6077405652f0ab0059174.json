{"sha": "6bacf5a54468f8db33b6077405652f0ab0059174", "node_id": "C_kwDOAAsO6NoAKDZiYWNmNWE1NDQ2OGY4ZGIzM2I2MDc3NDA1NjUyZjBhYjAwNTkxNzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-20T16:07:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-20T16:07:54Z"}, "message": "Auto merge of #111798 - GuillaumeGomez:rollup-t3bus8o, r=GuillaumeGomez\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #111450 (Use `OpaqueTypeKey` in query response)\n - #111726 (Migrate GUI colors test to original CSS color format)\n - #111746 (Merge some query impl modules into one)\n - #111765 (Migrate GUI colors test to original CSS color format)\n - #111771 (add `--remote-time` flag to curl for bootstrap)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "1ad36fdd9c2cbaef1441d84b908453e4d0f2b957", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ad36fdd9c2cbaef1441d84b908453e4d0f2b957"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bacf5a54468f8db33b6077405652f0ab0059174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bacf5a54468f8db33b6077405652f0ab0059174", "html_url": "https://github.com/rust-lang/rust/commit/6bacf5a54468f8db33b6077405652f0ab0059174", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bacf5a54468f8db33b6077405652f0ab0059174/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4eb5225cdf0b6e5a3cefccf4172eb0b2a496b6a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eb5225cdf0b6e5a3cefccf4172eb0b2a496b6a2", "html_url": "https://github.com/rust-lang/rust/commit/4eb5225cdf0b6e5a3cefccf4172eb0b2a496b6a2"}, {"sha": "a6ebaf8425b3da2c72226386c2e620e20a5b282c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6ebaf8425b3da2c72226386c2e620e20a5b282c", "html_url": "https://github.com/rust-lang/rust/commit/a6ebaf8425b3da2c72226386c2e620e20a5b282c"}], "stats": {"total": 362, "additions": 180, "deletions": 182}, "files": [{"sha": "de9afbbcaabbd3f433c6eb8dd47a6b8dd851af3d", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6bacf5a54468f8db33b6077405652f0ab0059174/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bacf5a54468f8db33b6077405652f0ab0059174/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=6bacf5a54468f8db33b6077405652f0ab0059174", "patch": "@@ -153,20 +153,22 @@ impl<'tcx> InferCtxt<'tcx> {\n \n     /// Used by the new solver as that one takes the opaque types at the end of a probe\n     /// to deal with multiple candidates without having to recompute them.\n-    pub fn clone_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+    pub fn clone_opaque_types_for_query_response(\n+        &self,\n+    ) -> Vec<(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)> {\n         self.inner\n             .borrow()\n             .opaque_type_storage\n             .opaque_types\n             .iter()\n-            .map(|(k, v)| (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty))\n+            .map(|(k, v)| (*k, v.hidden_type.ty))\n             .collect()\n     }\n \n-    fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+    fn take_opaque_types_for_query_response(&self) -> Vec<(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)> {\n         std::mem::take(&mut self.inner.borrow_mut().opaque_type_storage.opaque_types)\n             .into_iter()\n-            .map(|(k, v)| (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty))\n+            .map(|(k, v)| (k, v.hidden_type.ty))\n             .collect()\n     }\n \n@@ -507,8 +509,22 @@ impl<'tcx> InferCtxt<'tcx> {\n             let a = substitute_value(self.tcx, &result_subst, a);\n             let b = substitute_value(self.tcx, &result_subst, b);\n             debug!(?a, ?b, \"constrain opaque type\");\n-            obligations\n-                .extend(self.at(cause, param_env).eq(DefineOpaqueTypes::Yes, a, b)?.obligations);\n+            // We use equate here instead of, for example, just registering the\n+            // opaque type's hidden value directly, because we may be instantiating\n+            // a query response that was canonicalized in an InferCtxt that had\n+            // a different defining anchor. In that case, we may have inferred\n+            // `NonLocalOpaque := LocalOpaque` but can only instantiate it in\n+            // the other direction as `LocalOpaque := NonLocalOpaque`. Using eq\n+            // here allows us to try both directions (in `InferCtxt::handle_opaque_type`).\n+            obligations.extend(\n+                self.at(cause, param_env)\n+                    .eq(\n+                        DefineOpaqueTypes::Yes,\n+                        self.tcx.mk_opaque(a.def_id.to_def_id(), a.substs),\n+                        b,\n+                    )?\n+                    .obligations,\n+            );\n         }\n \n         Ok(InferOk { value: result_subst, obligations })"}, {"sha": "56171314944cc6ba243fc2798e3101947352c074", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bacf5a54468f8db33b6077405652f0ab0059174/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bacf5a54468f8db33b6077405652f0ab0059174/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=6bacf5a54468f8db33b6077405652f0ab0059174", "patch": "@@ -280,7 +280,7 @@ pub struct QueryResponse<'tcx, R> {\n     /// should get its hidden type inferred. So we bubble the opaque type\n     /// and the type it was compared against upwards and let the query caller\n     /// handle it.\n-    pub opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n+    pub opaque_types: Vec<(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)>,\n     pub value: R,\n }\n "}, {"sha": "1511c906d1e86854e4bb8178731dbda5d6f4b202", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bacf5a54468f8db33b6077405652f0ab0059174/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bacf5a54468f8db33b6077405652f0ab0059174/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=6bacf5a54468f8db33b6077405652f0ab0059174", "patch": "@@ -124,7 +124,7 @@ impl<'tcx> std::ops::Deref for ExternalConstraints<'tcx> {\n pub struct ExternalConstraintsData<'tcx> {\n     // FIXME: implement this.\n     pub region_constraints: QueryRegionConstraints<'tcx>,\n-    pub opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n+    pub opaque_types: Vec<(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)>,\n }\n \n // FIXME: Having to clone `region_constraints` for folding feels bad and"}, {"sha": "a9056edc4cf0eea0e7b902b861882fdddf681280", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 125, "deletions": 143, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/6bacf5a54468f8db33b6077405652f0ab0059174/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bacf5a54468f8db33b6077405652f0ab0059174/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=6bacf5a54468f8db33b6077405652f0ab0059174", "patch": "@@ -506,169 +506,151 @@ macro_rules! define_queries {\n     (\n      $($(#[$attr:meta])*\n         [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n-        mod get_query_incr {\n-            use super::*;\n \n-            $(\n+        pub(crate) mod query_impl { $(pub mod $name {\n+            use super::super::*;\n+            use std::marker::PhantomData;\n+\n+            pub mod get_query_incr {\n+                use super::*;\n+\n                 // Adding `__rust_end_short_backtrace` marker to backtraces so that we emit the frames\n                 // when `RUST_BACKTRACE=1`, add a new mod with `$name` here is to allow duplicate naming\n-                pub mod $name {\n-                    use super::*;\n-                    #[inline(never)]\n-                    pub fn __rust_end_short_backtrace<'tcx>(\n-                        tcx: TyCtxt<'tcx>,\n-                        span: Span,\n-                        key: queries::$name::Key<'tcx>,\n-                        mode: QueryMode,\n-                    ) -> Option<Erase<queries::$name::Value<'tcx>>> {\n-                        get_query_incr(\n-                            query_config::$name::config(tcx),\n-                            QueryCtxt::new(tcx),\n-                            span,\n-                            key,\n-                            mode\n+                #[inline(never)]\n+                pub fn __rust_end_short_backtrace<'tcx>(\n+                    tcx: TyCtxt<'tcx>,\n+                    span: Span,\n+                    key: queries::$name::Key<'tcx>,\n+                    mode: QueryMode,\n+                ) -> Option<Erase<queries::$name::Value<'tcx>>> {\n+                    get_query_incr(\n+                        QueryType::config(tcx),\n+                        QueryCtxt::new(tcx),\n+                        span,\n+                        key,\n+                        mode\n+                    )\n+                }\n+            }\n+\n+            pub mod get_query_non_incr {\n+                use super::*;\n+\n+                #[inline(never)]\n+                pub fn __rust_end_short_backtrace<'tcx>(\n+                    tcx: TyCtxt<'tcx>,\n+                    span: Span,\n+                    key: queries::$name::Key<'tcx>,\n+                    __mode: QueryMode,\n+                ) -> Option<Erase<queries::$name::Value<'tcx>>> {\n+                    Some(get_query_non_incr(\n+                        QueryType::config(tcx),\n+                        QueryCtxt::new(tcx),\n+                        span,\n+                        key,\n+                    ))\n+                }\n+            }\n+\n+            pub fn dynamic_query<'tcx>() -> DynamicQuery<'tcx, queries::$name::Storage<'tcx>> {\n+                DynamicQuery {\n+                    name: stringify!($name),\n+                    eval_always: is_eval_always!([$($modifiers)*]),\n+                    dep_kind: dep_graph::DepKind::$name,\n+                    handle_cycle_error: handle_cycle_error!([$($modifiers)*]),\n+                    query_state: offset_of!(QueryStates<'tcx> => $name),\n+                    query_cache: offset_of!(QueryCaches<'tcx> => $name),\n+                    cache_on_disk: |tcx, key| ::rustc_middle::query::cached::$name(tcx, key),\n+                    execute_query: |tcx, key| erase(tcx.$name(key)),\n+                    compute: |tcx, key| {\n+                        __rust_begin_short_backtrace(||\n+                            queries::$name::provided_to_erased(\n+                                tcx,\n+                                call_provider!([$($modifiers)*][tcx, $name, key])\n+                            )\n                         )\n-                    }\n+                    },\n+                    can_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] true false),\n+                    try_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] {\n+                        |tcx, key, prev_index, index| {\n+                            if ::rustc_middle::query::cached::$name(tcx, key) {\n+                                let value = $crate::plumbing::try_load_from_disk::<\n+                                    queries::$name::ProvidedValue<'tcx>\n+                                >(\n+                                    tcx,\n+                                    prev_index,\n+                                    index,\n+                                );\n+                                value.map(|value| queries::$name::provided_to_erased(tcx, value))\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                    } {\n+                        |_tcx, _key, _prev_index, _index| None\n+                    }),\n+                    value_from_cycle_error: |tcx, cycle| {\n+                        let result: queries::$name::Value<'tcx> = Value::from_cycle_error(tcx, cycle);\n+                        erase(result)\n+                    },\n+                    loadable_from_disk: |_tcx, _key, _index| {\n+                        should_ever_cache_on_disk!([$($modifiers)*] {\n+                            ::rustc_middle::query::cached::$name(_tcx, _key) &&\n+                                $crate::plumbing::loadable_from_disk(_tcx, _index)\n+                        } {\n+                            false\n+                        })\n+                    },\n+                    hash_result: hash_result!([$($modifiers)*][queries::$name::Value<'tcx>]),\n+                    format_value: |value| format!(\"{:?}\", restore::<queries::$name::Value<'tcx>>(*value)),\n                 }\n-            )*\n-        }\n+            }\n \n-        mod get_query_non_incr {\n-            use super::*;\n+            #[derive(Copy, Clone, Default)]\n+            pub struct QueryType<'tcx> {\n+                data: PhantomData<&'tcx ()>\n+            }\n \n-            $(\n-                pub mod $name {\n-                    use super::*;\n-                    #[inline(never)]\n-                    pub fn __rust_end_short_backtrace<'tcx>(\n-                        tcx: TyCtxt<'tcx>,\n-                        span: Span,\n-                        key: queries::$name::Key<'tcx>,\n-                        __mode: QueryMode,\n-                    ) -> Option<Erase<queries::$name::Value<'tcx>>> {\n-                        Some(get_query_non_incr(\n-                            query_config::$name::config(tcx),\n-                            QueryCtxt::new(tcx),\n-                            span,\n-                            key,\n-                        ))\n+            impl<'tcx> QueryConfigRestored<'tcx> for QueryType<'tcx> {\n+                type RestoredValue = queries::$name::Value<'tcx>;\n+                type Config = DynamicConfig<\n+                    'tcx,\n+                    queries::$name::Storage<'tcx>,\n+                    { is_anon!([$($modifiers)*]) },\n+                    { depth_limit!([$($modifiers)*]) },\n+                    { feedable!([$($modifiers)*]) },\n+                >;\n+\n+                #[inline(always)]\n+                fn config(tcx: TyCtxt<'tcx>) -> Self::Config {\n+                    DynamicConfig {\n+                        dynamic: &tcx.query_system.dynamic_queries.$name,\n                     }\n                 }\n-            )*\n-        }\n+\n+                #[inline(always)]\n+                fn restore(value: <Self::Config as QueryConfig<QueryCtxt<'tcx>>>::Value) -> Self::RestoredValue {\n+                    restore::<queries::$name::Value<'tcx>>(value)\n+                }\n+            }\n+        })*}\n \n         pub(crate) fn engine(incremental: bool) -> QueryEngine {\n             if incremental {\n                 QueryEngine {\n-                    $($name: get_query_incr::$name::__rust_end_short_backtrace,)*\n+                    $($name: query_impl::$name::get_query_incr::__rust_end_short_backtrace,)*\n                 }\n             } else {\n                 QueryEngine {\n-                    $($name: get_query_non_incr::$name::__rust_end_short_backtrace,)*\n+                    $($name: query_impl::$name::get_query_non_incr::__rust_end_short_backtrace,)*\n                 }\n             }\n         }\n \n-        #[allow(nonstandard_style)]\n-        mod query_config {\n-            use std::marker::PhantomData;\n-\n-            $(\n-                #[derive(Copy, Clone, Default)]\n-                pub struct $name<'tcx> {\n-                    data: PhantomData<&'tcx ()>\n-                }\n-            )*\n-        }\n-\n-        #[allow(nonstandard_style)]\n-        mod dynamic_query {\n-            use super::*;\n-\n-            $(\n-                pub(super) fn $name<'tcx>() -> DynamicQuery<'tcx, queries::$name::Storage<'tcx>> {\n-                    DynamicQuery {\n-                        name: stringify!($name),\n-                        eval_always: is_eval_always!([$($modifiers)*]),\n-                        dep_kind: dep_graph::DepKind::$name,\n-                        handle_cycle_error: handle_cycle_error!([$($modifiers)*]),\n-                        query_state: offset_of!(QueryStates<'tcx> => $name),\n-                        query_cache: offset_of!(QueryCaches<'tcx> => $name),\n-                        cache_on_disk: |tcx, key| ::rustc_middle::query::cached::$name(tcx, key),\n-                        execute_query: |tcx, key| erase(tcx.$name(key)),\n-                        compute: |tcx, key| {\n-                            __rust_begin_short_backtrace(||\n-                                queries::$name::provided_to_erased(\n-                                    tcx,\n-                                    call_provider!([$($modifiers)*][tcx, $name, key])\n-                                )\n-                            )\n-                        },\n-                        can_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] true false),\n-                        try_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] {\n-                            |tcx, key, prev_index, index| {\n-                                if ::rustc_middle::query::cached::$name(tcx, key) {\n-                                    let value = $crate::plumbing::try_load_from_disk::<\n-                                        queries::$name::ProvidedValue<'tcx>\n-                                    >(\n-                                        tcx,\n-                                        prev_index,\n-                                        index,\n-                                    );\n-                                    value.map(|value| queries::$name::provided_to_erased(tcx, value))\n-                                } else {\n-                                    None\n-                                }\n-                            }\n-                        } {\n-                            |_tcx, _key, _prev_index, _index| None\n-                        }),\n-                        value_from_cycle_error: |tcx, cycle| {\n-                            let result: queries::$name::Value<'tcx> = Value::from_cycle_error(tcx, cycle);\n-                            erase(result)\n-                        },\n-                        loadable_from_disk: |_tcx, _key, _index| {\n-                            should_ever_cache_on_disk!([$($modifiers)*] {\n-                                ::rustc_middle::query::cached::$name(_tcx, _key) &&\n-                                    $crate::plumbing::loadable_from_disk(_tcx, _index)\n-                            } {\n-                                false\n-                            })\n-                        },\n-                        hash_result: hash_result!([$($modifiers)*][queries::$name::Value<'tcx>]),\n-                        format_value: |value| format!(\"{:?}\", restore::<queries::$name::Value<'tcx>>(*value)),\n-                    }\n-                }\n-            )*\n-        }\n-\n-        $(impl<'tcx> QueryConfigRestored<'tcx> for query_config::$name<'tcx> {\n-            type RestoredValue = queries::$name::Value<'tcx>;\n-            type Config = DynamicConfig<\n-                'tcx,\n-                queries::$name::Storage<'tcx>,\n-                { is_anon!([$($modifiers)*]) },\n-                { depth_limit!([$($modifiers)*]) },\n-                { feedable!([$($modifiers)*]) },\n-            >;\n-\n-            #[inline(always)]\n-            fn config(tcx: TyCtxt<'tcx>) -> Self::Config {\n-                DynamicConfig {\n-                    dynamic: &tcx.query_system.dynamic_queries.$name,\n-                }\n-            }\n-\n-            #[inline(always)]\n-            fn restore(value: <Self::Config as QueryConfig<QueryCtxt<'tcx>>>::Value) -> Self::RestoredValue {\n-                restore::<queries::$name::Value<'tcx>>(value)\n-            }\n-        })*\n-\n         pub fn dynamic_queries<'tcx>() -> DynamicQueries<'tcx> {\n             DynamicQueries {\n                 $(\n-                    $name: dynamic_query::$name(),\n+                    $name: query_impl::$name::dynamic_query(),\n                 )*\n             }\n         }\n@@ -731,7 +713,7 @@ macro_rules! define_queries {\n             }\n \n             $(pub(crate) fn $name<'tcx>()-> DepKindStruct<'tcx> {\n-                $crate::plumbing::query_callback::<query_config::$name<'tcx>>(\n+                $crate::plumbing::query_callback::<query_impl::$name::QueryType<'tcx>>(\n                     is_anon!([$($modifiers)*]),\n                     is_eval_always!([$($modifiers)*]),\n                 )\n@@ -786,8 +768,8 @@ macro_rules! define_queries {\n                     )\n                 },\n                 encode_query_results: expand_if_cached!([$($modifiers)*], |tcx, encoder, query_result_index|\n-                    $crate::plumbing::encode_query_results::<super::query_config::$name<'tcx>>(\n-                        super::query_config::$name::config(tcx),\n+                    $crate::plumbing::encode_query_results::<query_impl::$name::QueryType<'tcx>>(\n+                        query_impl::$name::QueryType::config(tcx),\n                         QueryCtxt::new(tcx),\n                         encoder,\n                         query_result_index,"}, {"sha": "50ace987193a2289e04c6b75d04d6c7f3676a865", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bacf5a54468f8db33b6077405652f0ab0059174/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/6bacf5a54468f8db33b6077405652f0ab0059174/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=6bacf5a54468f8db33b6077405652f0ab0059174", "patch": "@@ -109,7 +109,7 @@ def _download(path, url, probably_big, verbose, exception):\n                 \"-L\", # Follow redirect.\n                 \"-y\", \"30\", \"-Y\", \"10\",    # timeout if speed is < 10 bytes/sec for > 30 seconds\n                 \"--connect-timeout\", \"30\",  # timeout if cannot connect within 30 seconds\n-                \"--retry\", \"3\", \"-Sf\", url],\n+                \"--retry\", \"3\", \"-SRf\", url],\n                 stdout=outfile,    #Implements cli redirect operator '>'\n                 verbose=verbose,\n                 exception=True, # Will raise RuntimeError on failure"}, {"sha": "25df5b2573b96bf1b9a4b6e9c0baf21ab3026873", "filename": "src/bootstrap/download.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bacf5a54468f8db33b6077405652f0ab0059174/src%2Fbootstrap%2Fdownload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bacf5a54468f8db33b6077405652f0ab0059174/src%2Fbootstrap%2Fdownload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload.rs?ref=6bacf5a54468f8db33b6077405652f0ab0059174", "patch": "@@ -219,7 +219,7 @@ impl Config {\n             \"30\", // timeout if cannot connect within 30 seconds\n             \"--retry\",\n             \"3\",\n-            \"-Sf\",\n+            \"-SRf\",\n         ]);\n         curl.arg(url);\n         let f = File::create(tempfile).unwrap();"}, {"sha": "81cf6fee9d4b3877bc53a3d2f466d555fc37f011", "filename": "tests/rustdoc-gui/scrape-examples-color.goml", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6bacf5a54468f8db33b6077405652f0ab0059174/tests%2Frustdoc-gui%2Fscrape-examples-color.goml", "raw_url": "https://github.com/rust-lang/rust/raw/6bacf5a54468f8db33b6077405652f0ab0059174/tests%2Frustdoc-gui%2Fscrape-examples-color.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fscrape-examples-color.goml?ref=6bacf5a54468f8db33b6077405652f0ab0059174", "patch": "@@ -33,30 +33,30 @@ define-function: (\n \n call-function: (\"check-colors\", {\n     \"theme\": \"ayu\",\n-    \"highlight\": \"rgb(91, 59, 1)\",\n-    \"highlight_focus\": \"rgb(124, 75, 15)\",\n-    \"help_border\": \"rgb(170, 170, 170)\",\n-    \"help_color\": \"rgb(238, 238, 238)\",\n-    \"help_hover_border\": \"rgb(255, 255, 255)\",\n-    \"help_hover_color\": \"rgb(255, 255, 255)\",\n+    \"highlight\": \"#5b3b01\",\n+    \"highlight_focus\": \"#7c4b0f\",\n+    \"help_border\": \"#aaa\",\n+    \"help_color\": \"#eee\",\n+    \"help_hover_border\": \"#fff\",\n+    \"help_hover_color\": \"#fff\",\n })\n call-function: (\"check-colors\", {\n     \"theme\": \"dark\",\n-    \"highlight\": \"rgb(91, 59, 1)\",\n-    \"highlight_focus\": \"rgb(124, 75, 15)\",\n-    \"help_border\": \"rgb(170, 170, 170)\",\n-    \"help_color\": \"rgb(238, 238, 238)\",\n-    \"help_hover_border\": \"rgb(255, 255, 255)\",\n-    \"help_hover_color\": \"rgb(255, 255, 255)\",\n+    \"highlight\": \"#5b3b01\",\n+    \"highlight_focus\": \"#7c4b0f\",\n+    \"help_border\": \"#aaa\",\n+    \"help_color\": \"#eee\",\n+    \"help_hover_border\": \"#fff\",\n+    \"help_hover_color\": \"#fff\",\n })\n call-function: (\"check-colors\", {\n     \"theme\": \"light\",\n-    \"highlight\": \"rgb(252, 255, 214)\",\n-    \"highlight_focus\": \"rgb(246, 253, 176)\",\n-    \"help_border\": \"rgb(85, 85, 85)\",\n-    \"help_color\": \"rgb(51, 51, 51)\",\n-    \"help_hover_border\": \"rgb(0, 0, 0)\",\n-    \"help_hover_color\": \"rgb(0, 0, 0)\",\n+    \"highlight\": \"#fcffd6\",\n+    \"highlight_focus\": \"#f6fdb0\",\n+    \"help_border\": \"#555\",\n+    \"help_color\": \"#333\",\n+    \"help_hover_border\": \"#000\",\n+    \"help_hover_color\": \"#000\",\n })\n \n // Now testing the top and bottom background in case there is only one scraped examples."}, {"sha": "d5dd511b1d31fdec3afde16cf7d76ef811f823ba", "filename": "tests/rustdoc-gui/source-code-page.goml", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6bacf5a54468f8db33b6077405652f0ab0059174/tests%2Frustdoc-gui%2Fsource-code-page.goml", "raw_url": "https://github.com/rust-lang/rust/raw/6bacf5a54468f8db33b6077405652f0ab0059174/tests%2Frustdoc-gui%2Fsource-code-page.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsource-code-page.goml?ref=6bacf5a54468f8db33b6077405652f0ab0059174", "patch": "@@ -40,24 +40,24 @@ define-function: (\n \n call-function: (\"check-colors\", {\n     \"theme\": \"ayu\",\n-    \"color\": \"rgb(92, 103, 115)\",\n-    \"background_color\": \"rgba(0, 0, 0, 0)\",\n-    \"highlight_color\": \"rgb(112, 128, 144)\",\n+    \"color\": \"#5c6773\",\n+    \"background_color\": \"transparent\",\n+    \"highlight_color\": \"#708090\",\n     \"highlight_background_color\": \"rgba(255, 236, 164, 0.06)\",\n })\n call-function: (\"check-colors\", {\n     \"theme\": \"dark\",\n-    \"color\": \"rgb(59, 145, 226)\",\n-    \"background_color\": \"rgba(0, 0, 0, 0)\",\n-    \"highlight_color\": \"rgb(59, 145, 226)\",\n-    \"highlight_background_color\": \"rgb(10, 4, 47)\",\n+    \"color\": \"#3b91e2\",\n+    \"background_color\": \"transparent\",\n+    \"highlight_color\": \"#3b91e2\",\n+    \"highlight_background_color\": \"#0a042f\",\n })\n call-function: (\"check-colors\", {\n     \"theme\": \"light\",\n-    \"color\": \"rgb(198, 126, 45)\",\n-    \"background_color\": \"rgba(0, 0, 0, 0)\",\n-    \"highlight_color\": \"rgb(198, 126, 45)\",\n-    \"highlight_background_color\": \"rgb(253, 255, 211)\",\n+    \"color\": \"#c67e2d\",\n+    \"background_color\": \"transparent\",\n+    \"highlight_color\": \"#c67e2d\",\n+    \"highlight_background_color\": \"#fdffd3\",\n })\n \n // This is to ensure that the content is correctly align with the line numbers."}]}