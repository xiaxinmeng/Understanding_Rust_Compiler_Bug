{"sha": "a474535e44f9d4d46a74466f92cf5d8c48f5617c", "node_id": "C_kwDOAAsO6NoAKGE0NzQ1MzVlNDRmOWQ0ZDQ2YTc0NDY2ZjkyY2Y1ZDhjNDhmNTYxN2M", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-04T19:47:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-04T19:47:39Z"}, "message": "Merge #11620\n\n11620: feat: Support locals with multiple declaration sites r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/8860\r\n\r\nThis implements the first approach of https://github.com/rust-analyzer/rust-analyzer/issues/8860#issuecomment-845461773:\r\n> treat every Local as having potentially many sources?\r\n\r\nThe way this is written does allow changing to a MultiLocal approach instead though, I'll investigate whether that turns out to be better or not.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "3f7ac6187a85fb306e0070f1f78aefa16c818742", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f7ac6187a85fb306e0070f1f78aefa16c818742"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a474535e44f9d4d46a74466f92cf5d8c48f5617c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiImzbCRBK7hj4Ov3rIwAAi2EIAFpkGkrA5bpSK8AGWDMD4m7T\n2MmGAw8AKBUIXvJANWOUPLqLXJfTex94GbC+vr9S3fCSeQj+VNJ1lPJ/9YY7ietG\nAgfkAxJFq6rpRJl8JIq2h8dm0UMnsFxJdIjh0cIBANUNEJ53J1Nhz9xKA6Knc+v7\nly7bp5DqmF2dXq5y1Ojnju3iKOyO17OM81gsxOamcRpeTTA9UvE+xfc+6w9OIA+S\nV3w5sKlBcSEnwGaXpYt6FAn2NMvTjJ3gTvWPsjaS81OXdqgDr4esO0FKp+uLpach\ncdNkUZ3jT7oQd69ZrtfhzgyzVXC2DVpXpfwKPn3bXTZNWVsiTxs+P5QRF7r4sEA=\n=cL2h\n-----END PGP SIGNATURE-----\n", "payload": "tree 3f7ac6187a85fb306e0070f1f78aefa16c818742\nparent f8329ba98731a939fe2c6eb878778a6399274ff0\nparent 4a866fc672927b9d3dd5a7211bfe45e9eebebdc2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1646423259 +0000\ncommitter GitHub <noreply@github.com> 1646423259 +0000\n\nMerge #11620\n\n11620: feat: Support locals with multiple declaration sites r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/8860\r\n\r\nThis implements the first approach of https://github.com/rust-analyzer/rust-analyzer/issues/8860#issuecomment-845461773:\r\n> treat every Local as having potentially many sources?\r\n\r\nThe way this is written does allow changing to a MultiLocal approach instead though, I'll investigate whether that turns out to be better or not.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a474535e44f9d4d46a74466f92cf5d8c48f5617c", "html_url": "https://github.com/rust-lang/rust/commit/a474535e44f9d4d46a74466f92cf5d8c48f5617c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a474535e44f9d4d46a74466f92cf5d8c48f5617c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8329ba98731a939fe2c6eb878778a6399274ff0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8329ba98731a939fe2c6eb878778a6399274ff0", "html_url": "https://github.com/rust-lang/rust/commit/f8329ba98731a939fe2c6eb878778a6399274ff0"}, {"sha": "4a866fc672927b9d3dd5a7211bfe45e9eebebdc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a866fc672927b9d3dd5a7211bfe45e9eebebdc2", "html_url": "https://github.com/rust-lang/rust/commit/4a866fc672927b9d3dd5a7211bfe45e9eebebdc2"}], "stats": {"total": 383, "additions": 315, "deletions": 68}, "files": [{"sha": "60e3548d495db5de0ba605771cf5776740a5c288", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=a474535e44f9d4d46a74466f92cf5d8c48f5617c", "patch": "@@ -2036,6 +2036,11 @@ impl GenericDef {\n     }\n }\n \n+/// A single local definition.\n+///\n+/// If the definition of this is part of a \"MultiLocal\", that is a local that has multiple declarations due to or-patterns\n+/// then this only references a single one of those.\n+/// To retrieve the other locals you should use [`Local::associated_locals`]\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct Local {\n     pub(crate) parent: DefWithBodyId,\n@@ -2107,12 +2112,28 @@ impl Local {\n         Type::new(db, krate, def, ty)\n     }\n \n+    pub fn associated_locals(self, db: &dyn HirDatabase) -> Box<[Local]> {\n+        let body = db.body(self.parent);\n+        body.ident_patterns_for(&self.pat_id)\n+            .iter()\n+            .map(|&pat_id| Local { parent: self.parent, pat_id })\n+            .collect()\n+    }\n+\n+    /// If this local is part of a multi-local, retrieve the representative local.\n+    /// That is the local that references are being resolved to.\n+    pub fn representative(self, db: &dyn HirDatabase) -> Local {\n+        let body = db.body(self.parent);\n+        Local { pat_id: body.pattern_representative(self.pat_id), ..self }\n+    }\n+\n     pub fn source(self, db: &dyn HirDatabase) -> InFile<Either<ast::IdentPat, ast::SelfParam>> {\n         let (_body, source_map) = db.body_with_source_map(self.parent);\n         let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n         let root = src.file_syntax(db.upcast());\n-        src.map(|ast| {\n-            ast.map_left(|it| it.cast().unwrap().to_node(&root)).map_right(|it| it.to_node(&root))\n+        src.map(|ast| match ast {\n+            Either::Left(it) => Either::Left(it.cast().unwrap().to_node(&root)),\n+            Either::Right(it) => Either::Right(it.to_node(&root)),\n         })\n     }\n }"}, {"sha": "6d3c2c2c4670c41f9ab6b701c063a87c0d8ffd87", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=a474535e44f9d4d46a74466f92cf5d8c48f5617c", "patch": "@@ -241,6 +241,7 @@ pub struct Mark {\n pub struct Body {\n     pub exprs: Arena<Expr>,\n     pub pats: Arena<Pat>,\n+    pub or_pats: FxHashMap<PatId, Arc<[PatId]>>,\n     pub labels: Arena<Label>,\n     /// The patterns for the function's parameters. While the parameter types are\n     /// part of the function signature, the patterns are not (they don't change\n@@ -352,7 +353,19 @@ impl Body {\n     ) -> impl Iterator<Item = (BlockId, Arc<DefMap>)> + '_ {\n         self.block_scopes\n             .iter()\n-            .map(move |block| (*block, db.block_def_map(*block).expect(\"block ID without DefMap\")))\n+            .map(move |&block| (block, db.block_def_map(block).expect(\"block ID without DefMap\")))\n+    }\n+\n+    pub fn pattern_representative(&self, pat: PatId) -> PatId {\n+        self.or_pats.get(&pat).and_then(|pats| pats.first().copied()).unwrap_or(pat)\n+    }\n+\n+    /// Retrieves all ident patterns this pattern shares the ident with.\n+    pub fn ident_patterns_for<'slf>(&'slf self, pat: &'slf PatId) -> &'slf [PatId] {\n+        match self.or_pats.get(pat) {\n+            Some(pats) => &**pats,\n+            None => std::slice::from_ref(pat),\n+        }\n     }\n \n     fn new(\n@@ -365,8 +378,9 @@ impl Body {\n     }\n \n     fn shrink_to_fit(&mut self) {\n-        let Self { _c: _, body_expr: _, block_scopes, exprs, labels, params, pats } = self;\n+        let Self { _c: _, body_expr: _, block_scopes, or_pats, exprs, labels, params, pats } = self;\n         block_scopes.shrink_to_fit();\n+        or_pats.shrink_to_fit();\n         exprs.shrink_to_fit();\n         labels.shrink_to_fit();\n         params.shrink_to_fit();"}, {"sha": "46b2ba8a254e2e8506792712f41af1956500885e", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 47, "deletions": 13, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=a474535e44f9d4d46a74466f92cf5d8c48f5617c", "patch": "@@ -12,6 +12,7 @@ use hir_expand::{\n };\n use la_arena::Arena;\n use profile::Count;\n+use rustc_hash::FxHashMap;\n use syntax::{\n     ast::{\n         self, ArrayExprKind, AstChildren, HasArgList, HasLoopBody, HasName, LiteralKind,\n@@ -92,9 +93,12 @@ pub(super) fn lower(\n             body_expr: dummy_expr_id(),\n             block_scopes: Vec::new(),\n             _c: Count::new(),\n+            or_pats: Default::default(),\n         },\n         expander,\n         statements_in_scope: Vec::new(),\n+        name_to_pat_grouping: Default::default(),\n+        is_lowering_inside_or_pat: false,\n     }\n     .collect(params, body)\n }\n@@ -105,6 +109,9 @@ struct ExprCollector<'a> {\n     body: Body,\n     source_map: BodySourceMap,\n     statements_in_scope: Vec<Statement>,\n+    // a poor-mans union-find?\n+    name_to_pat_grouping: FxHashMap<Name, Vec<PatId>>,\n+    is_lowering_inside_or_pat: bool,\n }\n \n impl ExprCollector<'_> {\n@@ -704,13 +711,32 @@ impl ExprCollector<'_> {\n     }\n \n     fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n+        let pat_id = self.collect_pat_(pat);\n+        for (_, pats) in self.name_to_pat_grouping.drain() {\n+            let pats = Arc::<[_]>::from(pats);\n+            self.body.or_pats.extend(pats.iter().map(|&pat| (pat, pats.clone())));\n+        }\n+        self.is_lowering_inside_or_pat = false;\n+        pat_id\n+    }\n+\n+    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n+        match pat {\n+            Some(pat) => self.collect_pat(pat),\n+            None => self.missing_pat(),\n+        }\n+    }\n+\n+    fn collect_pat_(&mut self, pat: ast::Pat) -> PatId {\n         let pattern = match &pat {\n             ast::Pat::IdentPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n+\n+                let key = self.is_lowering_inside_or_pat.then(|| name.clone());\n                 let annotation =\n                     BindingAnnotation::new(bp.mut_token().is_some(), bp.ref_token().is_some());\n-                let subpat = bp.pat().map(|subpat| self.collect_pat(subpat));\n-                if annotation == BindingAnnotation::Unannotated && subpat.is_none() {\n+                let subpat = bp.pat().map(|subpat| self.collect_pat_(subpat));\n+                let pattern = if annotation == BindingAnnotation::Unannotated && subpat.is_none() {\n                     // This could also be a single-segment path pattern. To\n                     // decide that, we need to try resolving the name.\n                     let (resolved, _) = self.expander.def_map.resolve_path(\n@@ -740,7 +766,14 @@ impl ExprCollector<'_> {\n                     }\n                 } else {\n                     Pat::Bind { name, mode: annotation, subpat }\n+                };\n+\n+                let ptr = AstPtr::new(&pat);\n+                let pat = self.alloc_pat(pattern, Either::Left(ptr));\n+                if let Some(key) = key {\n+                    self.name_to_pat_grouping.entry(key).or_default().push(pat);\n                 }\n+                return pat;\n             }\n             ast::Pat::TupleStructPat(p) => {\n                 let path =\n@@ -759,10 +792,11 @@ impl ExprCollector<'_> {\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n             ast::Pat::OrPat(p) => {\n-                let pats = p.pats().map(|p| self.collect_pat(p)).collect();\n+                self.is_lowering_inside_or_pat = true;\n+                let pats = p.pats().map(|p| self.collect_pat_(p)).collect();\n                 Pat::Or(pats)\n             }\n-            ast::Pat::ParenPat(p) => return self.collect_pat_opt(p.pat()),\n+            ast::Pat::ParenPat(p) => return self.collect_pat_opt_(p.pat()),\n             ast::Pat::TuplePat(p) => {\n                 let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n                 Pat::Tuple { args, ellipsis }\n@@ -777,7 +811,7 @@ impl ExprCollector<'_> {\n                     .fields()\n                     .filter_map(|f| {\n                         let ast_pat = f.pat()?;\n-                        let pat = self.collect_pat(ast_pat);\n+                        let pat = self.collect_pat_(ast_pat);\n                         let name = f.field_name()?.as_name();\n                         Some(RecordFieldPat { name, pat })\n                     })\n@@ -796,9 +830,9 @@ impl ExprCollector<'_> {\n \n                 // FIXME properly handle `RestPat`\n                 Pat::Slice {\n-                    prefix: prefix.into_iter().map(|p| self.collect_pat(p)).collect(),\n-                    slice: slice.map(|p| self.collect_pat(p)),\n-                    suffix: suffix.into_iter().map(|p| self.collect_pat(p)).collect(),\n+                    prefix: prefix.into_iter().map(|p| self.collect_pat_(p)).collect(),\n+                    slice: slice.map(|p| self.collect_pat_(p)),\n+                    suffix: suffix.into_iter().map(|p| self.collect_pat_(p)).collect(),\n                 }\n             }\n             ast::Pat::LiteralPat(lit) => {\n@@ -821,7 +855,7 @@ impl ExprCollector<'_> {\n                 Pat::Missing\n             }\n             ast::Pat::BoxPat(boxpat) => {\n-                let inner = self.collect_pat_opt(boxpat.pat());\n+                let inner = self.collect_pat_opt_(boxpat.pat());\n                 Pat::Box { inner }\n             }\n             ast::Pat::ConstBlockPat(const_block_pat) => {\n@@ -837,7 +871,7 @@ impl ExprCollector<'_> {\n                     let macro_ptr = AstPtr::new(&call);\n                     let mut pat = None;\n                     self.collect_macro_call(call, macro_ptr, true, |this, expanded_pat| {\n-                        pat = Some(this.collect_pat_opt(expanded_pat));\n+                        pat = Some(this.collect_pat_opt_(expanded_pat));\n                     });\n \n                     match pat {\n@@ -854,9 +888,9 @@ impl ExprCollector<'_> {\n         self.alloc_pat(pattern, Either::Left(ptr))\n     }\n \n-    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n+    fn collect_pat_opt_(&mut self, pat: Option<ast::Pat>) -> PatId {\n         match pat {\n-            Some(pat) => self.collect_pat(pat),\n+            Some(pat) => self.collect_pat_(pat),\n             None => self.missing_pat(),\n         }\n     }\n@@ -868,7 +902,7 @@ impl ExprCollector<'_> {\n         // We want to skip the `..` pattern here, since we account for it above.\n         let args = args\n             .filter(|p| !matches!(p, ast::Pat::RestPat(_)))\n-            .map(|p| self.collect_pat(p))\n+            .map(|p| self.collect_pat_(p))\n             .collect();\n \n         (args, ellipsis)"}, {"sha": "5724090e636811f8fd3b4380cc1255ad2e0e5b0d", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 133, "deletions": 48, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=a474535e44f9d4d46a74466f92cf5d8c48f5617c", "patch": "@@ -98,24 +98,37 @@ fn highlight_references(\n             range,\n             category: access,\n         });\n+    let mut res = FxHashSet::default();\n \n-    let declarations = defs.iter().flat_map(|def| {\n-        match def {\n-            &Definition::Module(module) => {\n+    let mut def_to_hl_range = |def| {\n+        let hl_range = match def {\n+            Definition::Module(module) => {\n                 Some(NavigationTarget::from_module_to_decl(sema.db, module))\n             }\n             def => def.try_to_nav(sema.db),\n         }\n         .filter(|decl| decl.file_id == file_id)\n-        .and_then(|decl| {\n-            let range = decl.focus_range?;\n+        .and_then(|decl| decl.focus_range)\n+        .map(|range| {\n             let category =\n                 references::decl_mutability(&def, node, range).then(|| ReferenceCategory::Write);\n-            Some(HighlightedRange { range, category })\n-        })\n-    });\n+            HighlightedRange { range, category }\n+        });\n+        if let Some(hl_range) = hl_range {\n+            res.insert(hl_range);\n+        }\n+    };\n+    for &def in &defs {\n+        match def {\n+            Definition::Local(local) => local\n+                .associated_locals(sema.db)\n+                .iter()\n+                .for_each(|&local| def_to_hl_range(Definition::Local(local))),\n+            def => def_to_hl_range(def),\n+        }\n+    }\n \n-    let res: FxHashSet<_> = declarations.chain(usages).collect();\n+    res.extend(usages);\n     if res.is_empty() {\n         None\n     } else {\n@@ -332,6 +345,7 @@ mod tests {\n \n     use super::*;\n \n+    #[track_caller]\n     fn check(ra_fixture: &str) {\n         let config = HighlightRelatedConfig {\n             break_points: true,\n@@ -343,6 +357,7 @@ mod tests {\n         check_with_config(ra_fixture, config);\n     }\n \n+    #[track_caller]\n     fn check_with_config(ra_fixture: &str, config: HighlightRelatedConfig) {\n         let (analysis, pos, annotations) = fixture::annotations(ra_fixture);\n \n@@ -1053,13 +1068,15 @@ fn function(field: u32) {\n             yield_points: true,\n         };\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n fn foo() {\n     let x$0 = 5;\n     let y = x * 2;\n-}\"#;\n-\n-        check_with_config(ra_fixture, config);\n+}\n+\"#,\n+            config,\n+        );\n     }\n \n     #[test]\n@@ -1071,19 +1088,22 @@ fn foo() {\n             yield_points: true,\n         };\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n fn foo() {\n     let x$0 = 5;\n     let y = x * 2;\n \n     loop {\n         break;\n     }\n-}\"#;\n-\n-        check_with_config(ra_fixture, config.clone());\n+}\n+\"#,\n+            config.clone(),\n+        );\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n fn foo() {\n     let x = 5;\n     let y = x * 2;\n@@ -1093,9 +1113,10 @@ fn foo() {\n         break;\n //      ^^^^^\n     }\n-}\"#;\n-\n-        check_with_config(ra_fixture, config);\n+}\n+\"#,\n+            config,\n+        );\n     }\n \n     #[test]\n@@ -1107,27 +1128,31 @@ fn foo() {\n             yield_points: true,\n         };\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n async fn foo() {\n     let x$0 = 5;\n     let y = x * 2;\n \n     0.await;\n-}\"#;\n-\n-        check_with_config(ra_fixture, config.clone());\n+}\n+\"#,\n+            config.clone(),\n+        );\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n     async fn foo() {\n //  ^^^^^\n         let x = 5;\n         let y = x * 2;\n \n         0.await$0;\n //        ^^^^^\n-}\"#;\n-\n-        check_with_config(ra_fixture, config);\n+}\n+\"#,\n+            config,\n+        );\n     }\n \n     #[test]\n@@ -1139,7 +1164,8 @@ async fn foo() {\n             yield_points: true,\n         };\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n fn foo() -> i32 {\n     let x$0 = 5;\n     let y = x * 2;\n@@ -1149,11 +1175,13 @@ fn foo() -> i32 {\n     }\n \n     0?\n-}\"#;\n-\n-        check_with_config(ra_fixture, config.clone());\n+}\n+\"#,\n+            config.clone(),\n+        );\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n fn foo() ->$0 i32 {\n     let x = 5;\n     let y = x * 2;\n@@ -1165,9 +1193,9 @@ fn foo() ->$0 i32 {\n \n     0?\n //   ^\n-\"#;\n-\n-        check_with_config(ra_fixture, config);\n+\"#,\n+            config,\n+        );\n     }\n \n     #[test]\n@@ -1179,14 +1207,16 @@ fn foo() ->$0 i32 {\n             yield_points: true,\n         };\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n fn foo() {\n     loop {\n         break$0;\n     }\n-}\"#;\n-\n-        check_with_config(ra_fixture, config);\n+}\n+\"#,\n+            config,\n+        );\n     }\n \n     #[test]\n@@ -1198,12 +1228,14 @@ fn foo() {\n             yield_points: false,\n         };\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n async$0 fn foo() {\n     0.await;\n-}\"#;\n-\n-        check_with_config(ra_fixture, config);\n+}\n+\"#,\n+            config,\n+        );\n     }\n \n     #[test]\n@@ -1215,15 +1247,68 @@ async$0 fn foo() {\n             yield_points: true,\n         };\n \n-        let ra_fixture = r#\"\n+        check_with_config(\n+            r#\"\n fn foo() ->$0 i32 {\n     if true {\n         return -1;\n     }\n \n     42\n-}\"#;\n+}\"#,\n+            config,\n+        );\n+    }\n \n-        check_with_config(ra_fixture, config);\n+    #[test]\n+    fn test_hl_multi_local() {\n+        check(\n+            r#\"\n+fn foo((\n+    foo$0\n+  //^^^\n+    | foo\n+    //^^^\n+    | foo\n+    //^^^\n+): ()) {\n+    foo;\n+  //^^^read\n+    let foo;\n+}\n+\"#,\n+        );\n+        check(\n+            r#\"\n+fn foo((\n+    foo\n+  //^^^\n+    | foo$0\n+    //^^^\n+    | foo\n+    //^^^\n+): ()) {\n+    foo;\n+  //^^^read\n+    let foo;\n+}\n+\"#,\n+        );\n+        check(\n+            r#\"\n+fn foo((\n+    foo\n+  //^^^\n+    | foo\n+    //^^^\n+    | foo\n+    //^^^\n+): ()) {\n+    foo$0;\n+  //^^^read\n+    let foo;\n+}\n+\"#,\n+        );\n     }\n }"}, {"sha": "83bc299adcce7a0b79bfad99eb9f8e9b61117837", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=a474535e44f9d4d46a74466f92cf5d8c48f5617c", "patch": "@@ -2084,4 +2084,53 @@ fn foo() {\n \"#,\n         )\n     }\n+\n+    #[test]\n+    fn rename_multi_local() {\n+        check(\n+            \"bar\",\n+            r#\"\n+fn foo((foo$0 | foo | foo): ()) {\n+    foo;\n+    let foo;\n+}\n+\"#,\n+            r#\"\n+fn foo((bar | bar | bar): ()) {\n+    bar;\n+    let foo;\n+}\n+\"#,\n+        );\n+        check(\n+            \"bar\",\n+            r#\"\n+fn foo((foo | foo$0 | foo): ()) {\n+    foo;\n+    let foo;\n+}\n+\"#,\n+            r#\"\n+fn foo((bar | bar | bar): ()) {\n+    bar;\n+    let foo;\n+}\n+\"#,\n+        );\n+        check(\n+            \"bar\",\n+            r#\"\n+fn foo((foo | foo | foo): ()) {\n+    foo$0;\n+    let foo;\n+}\n+\"#,\n+            r#\"\n+fn foo((bar | bar | bar): ()) {\n+    bar;\n+    let foo;\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "0b4f46caf41f484ea42faf748f474dbc1b4656e4", "filename": "crates/ide_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=a474535e44f9d4d46a74466f92cf5d8c48f5617c", "patch": "@@ -206,6 +206,7 @@ fn inline_usage(\n         return None;\n     }\n \n+    // FIXME: Handle multiple local definitions\n     let bind_pat = match local.source(sema.db).value {\n         Either::Left(ident) => ident,\n         _ => return None,"}, {"sha": "a44fe04e748ee359644a97ce38f943df23299ae9", "filename": "crates/ide_db/src/rename.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fide_db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fide_db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Frename.rs?ref=a474535e44f9d4d46a74466f92cf5d8c48f5617c", "patch": "@@ -293,8 +293,18 @@ fn rename_reference(\n         (file_id, source_edit_from_references(references, def, new_name))\n     }));\n \n-    let (file_id, edit) = source_edit_from_def(sema, def, new_name)?;\n-    source_change.insert_source_edit(file_id, edit);\n+    let mut insert_def_edit = |def| {\n+        let (file_id, edit) = source_edit_from_def(sema, def, new_name)?;\n+        source_change.insert_source_edit(file_id, edit);\n+        Ok(())\n+    };\n+    match def {\n+        Definition::Local(l) => l\n+            .associated_locals(sema.db)\n+            .iter()\n+            .try_for_each(|&local| insert_def_edit(Definition::Local(local))),\n+        def => insert_def_edit(def),\n+    }?;\n     Ok(source_change)\n }\n "}, {"sha": "3ff48520f497bdc397d55920bfc7b2e06482be5f", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a474535e44f9d4d46a74466f92cf5d8c48f5617c/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=a474535e44f9d4d46a74466f92cf5d8c48f5617c", "patch": "@@ -310,6 +310,10 @@ impl Definition {\n \n     pub fn usages<'a>(self, sema: &'a Semantics<RootDatabase>) -> FindUsages<'a> {\n         FindUsages {\n+            local_repr: match self {\n+                Definition::Local(local) => Some(local.representative(sema.db)),\n+                _ => None,\n+            },\n             def: self,\n             sema,\n             scope: None,\n@@ -325,6 +329,7 @@ pub struct FindUsages<'a> {\n     sema: &'a Semantics<'a, RootDatabase>,\n     scope: Option<SearchScope>,\n     include_self_kw_refs: Option<hir::Type>,\n+    local_repr: Option<hir::Local>,\n     search_self_mod: bool,\n }\n \n@@ -593,6 +598,19 @@ impl<'a> FindUsages<'a> {\n         sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n     ) -> bool {\n         match NameRefClass::classify(self.sema, name_ref) {\n+            Some(NameRefClass::Definition(def @ Definition::Local(local)))\n+                if matches!(\n+                    self.local_repr, Some(repr) if repr == local.representative(self.sema.db)\n+                ) =>\n+            {\n+                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n+                let reference = FileReference {\n+                    range,\n+                    name: ast::NameLike::NameRef(name_ref.clone()),\n+                    category: ReferenceCategory::new(&def, name_ref),\n+                };\n+                sink(file_id, reference)\n+            }\n             Some(NameRefClass::Definition(def)) if def == self.def => {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let reference = FileReference {\n@@ -622,7 +640,7 @@ impl<'a> FindUsages<'a> {\n                     Definition::Field(_) if field == self.def => {\n                         ReferenceCategory::new(&field, name_ref)\n                     }\n-                    Definition::Local(l) if local == l => {\n+                    Definition::Local(_) if matches!(self.local_repr, Some(repr) if repr == local.representative(self.sema.db)) => {\n                         ReferenceCategory::new(&Definition::Local(local), name_ref)\n                     }\n                     _ => return false,\n@@ -667,6 +685,21 @@ impl<'a> FindUsages<'a> {\n                 };\n                 sink(file_id, reference)\n             }\n+            Some(NameClass::Definition(def @ Definition::Local(local))) if def != self.def => {\n+                if matches!(\n+                    self.local_repr,\n+                    Some(repr) if local.representative(self.sema.db) == repr\n+                ) {\n+                    let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n+                    let reference = FileReference {\n+                        range,\n+                        name: ast::NameLike::Name(name.clone()),\n+                        category: None,\n+                    };\n+                    return sink(file_id, reference);\n+                }\n+                false\n+            }\n             // Resolve trait impl function definitions to the trait definition's version if self.def is the trait definition's\n             Some(NameClass::Definition(def)) if def != self.def => {\n                 /* poor man's try block */"}]}