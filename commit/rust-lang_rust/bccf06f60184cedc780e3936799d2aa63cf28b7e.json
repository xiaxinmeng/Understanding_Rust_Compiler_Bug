{"sha": "bccf06f60184cedc780e3936799d2aa63cf28b7e", "node_id": "C_kwDOAAsO6NoAKGJjY2YwNmY2MDE4NGNlZGM3ODBlMzkzNjc5OWQyYWE2M2NmMjhiN2U", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-06T21:24:14Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-07T17:22:26Z"}, "message": "Split out `match_as_ref`", "tree": {"sha": "e1b8dcb03a2e8676f6f6512b21a0de6d547dd6ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1b8dcb03a2e8676f6f6512b21a0de6d547dd6ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bccf06f60184cedc780e3936799d2aa63cf28b7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bccf06f60184cedc780e3936799d2aa63cf28b7e", "html_url": "https://github.com/rust-lang/rust/commit/bccf06f60184cedc780e3936799d2aa63cf28b7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bccf06f60184cedc780e3936799d2aa63cf28b7e/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75923dff5baa8de3acdec3026aac487033fe68fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/75923dff5baa8de3acdec3026aac487033fe68fe", "html_url": "https://github.com/rust-lang/rust/commit/75923dff5baa8de3acdec3026aac487033fe68fe"}], "stats": {"total": 172, "additions": 89, "deletions": 83}, "files": [{"sha": "d914eba01716b69e6fb182bcede18001c2e6f94b", "filename": "clippy_lints/src/matches/match_as_ref.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/bccf06f60184cedc780e3936799d2aa63cf28b7e/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bccf06f60184cedc780e3936799d2aa63cf28b7e/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs?ref=bccf06f60184cedc780e3936799d2aa63cf28b7e", "patch": "@@ -0,0 +1,85 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{is_lang_ctor, peel_blocks};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, LangItem, PatKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::MATCH_AS_REF;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n+        let arm_ref: Option<BindingAnnotation> = if is_none_arm(cx, &arms[0]) {\n+            is_ref_some_arm(cx, &arms[1])\n+        } else if is_none_arm(cx, &arms[1]) {\n+            is_ref_some_arm(cx, &arms[0])\n+        } else {\n+            None\n+        };\n+        if let Some(rb) = arm_ref {\n+            let suggestion = if rb == BindingAnnotation::Ref {\n+                \"as_ref\"\n+            } else {\n+                \"as_mut\"\n+            };\n+\n+            let output_ty = cx.typeck_results().expr_ty(expr);\n+            let input_ty = cx.typeck_results().expr_ty(ex);\n+\n+            let cast = if_chain! {\n+                if let ty::Adt(_, substs) = input_ty.kind();\n+                let input_ty = substs.type_at(0);\n+                if let ty::Adt(_, substs) = output_ty.kind();\n+                let output_ty = substs.type_at(0);\n+                if let ty::Ref(_, output_ty, _) = *output_ty.kind();\n+                if input_ty != output_ty;\n+                then {\n+                    \".map(|x| x as _)\"\n+                } else {\n+                    \"\"\n+                }\n+            };\n+\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_AS_REF,\n+                expr.span,\n+                &format!(\"use `{}()` instead\", suggestion),\n+                \"try this\",\n+                format!(\n+                    \"{}.{}(){}\",\n+                    snippet_with_applicability(cx, ex.span, \"_\", &mut applicability),\n+                    suggestion,\n+                    cast,\n+                ),\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+// Checks if arm has the form `None => None`\n+fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n+    matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, LangItem::OptionNone))\n+}\n+\n+// Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n+fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotation> {\n+    if_chain! {\n+        if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n+        if is_lang_ctor(cx, qpath, LangItem::OptionSome);\n+        if let PatKind::Binding(rb, .., ident, _) = first_pat.kind;\n+        if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n+        if let ExprKind::Call(e, args) = peel_blocks(arm.body).kind;\n+        if let ExprKind::Path(ref some_path) = e.kind;\n+        if is_lang_ctor(cx, some_path, LangItem::OptionSome) && args.len() == 1;\n+        if let ExprKind::Path(QPath::Resolved(_, path2)) = args[0].kind;\n+        if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n+        then {\n+            return Some(rb)\n+        }\n+    }\n+    None\n+}"}, {"sha": "b48cdcb7d7169a39268f62bd4c64910fee401df8", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 4, "deletions": 83, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/bccf06f60184cedc780e3936799d2aa63cf28b7e/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bccf06f60184cedc780e3936799d2aa63cf28b7e/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=bccf06f60184cedc780e3936799d2aa63cf28b7e", "patch": "@@ -2,21 +2,18 @@ use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_help, span_lint_an\n use clippy_utils::source::{indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{\n-    get_parent_expr, is_lang_ctor, is_refutable, is_wild, meets_msrv, msrvs, path_to_local_id, peel_blocks,\n-    strip_pat_refs,\n+    get_parent_expr, is_refutable, is_wild, meets_msrv, msrvs, path_to_local_id, peel_blocks, strip_pat_refs,\n };\n use core::iter::once;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{\n-    Arm, BindingAnnotation, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Node, Pat, PatKind, QPath,\n-};\n+use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Node, Pat, PatKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n+mod match_as_ref;\n mod match_bool;\n mod match_like_matches;\n mod match_same_arms;\n@@ -627,7 +624,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n             overlapping_arms::check(cx, ex, arms);\n             match_wild_err_arm::check(cx, ex, arms);\n             match_wild_enum::check(cx, ex, arms);\n-            check_match_as_ref(cx, ex, arms, expr);\n+            match_as_ref::check(cx, ex, arms, expr);\n             check_wild_in_or_pats(cx, arms);\n \n             if self.infallible_destructuring_match_linted {\n@@ -738,58 +735,6 @@ where\n     });\n }\n \n-fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n-        let arm_ref: Option<BindingAnnotation> = if is_none_arm(cx, &arms[0]) {\n-            is_ref_some_arm(cx, &arms[1])\n-        } else if is_none_arm(cx, &arms[1]) {\n-            is_ref_some_arm(cx, &arms[0])\n-        } else {\n-            None\n-        };\n-        if let Some(rb) = arm_ref {\n-            let suggestion = if rb == BindingAnnotation::Ref {\n-                \"as_ref\"\n-            } else {\n-                \"as_mut\"\n-            };\n-\n-            let output_ty = cx.typeck_results().expr_ty(expr);\n-            let input_ty = cx.typeck_results().expr_ty(ex);\n-\n-            let cast = if_chain! {\n-                if let ty::Adt(_, substs) = input_ty.kind();\n-                let input_ty = substs.type_at(0);\n-                if let ty::Adt(_, substs) = output_ty.kind();\n-                let output_ty = substs.type_at(0);\n-                if let ty::Ref(_, output_ty, _) = *output_ty.kind();\n-                if input_ty != output_ty;\n-                then {\n-                    \".map(|x| x as _)\"\n-                } else {\n-                    \"\"\n-                }\n-            };\n-\n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                MATCH_AS_REF,\n-                expr.span,\n-                &format!(\"use `{}()` instead\", suggestion),\n-                \"try this\",\n-                format!(\n-                    \"{}.{}(){}\",\n-                    snippet_with_applicability(cx, ex.span, \"_\", &mut applicability),\n-                    suggestion,\n-                    cast,\n-                ),\n-                applicability,\n-            );\n-        }\n-    }\n-}\n-\n fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n     for arm in arms {\n         if let PatKind::Or(fields) = arm.pat.kind {\n@@ -965,30 +910,6 @@ fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'\n     None\n }\n \n-// Checks if arm has the form `None => None`\n-fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n-    matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n-}\n-\n-// Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n-fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotation> {\n-    if_chain! {\n-        if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n-        if is_lang_ctor(cx, qpath, OptionSome);\n-        if let PatKind::Binding(rb, .., ident, _) = first_pat.kind;\n-        if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n-        if let ExprKind::Call(e, args) = peel_blocks(arm.body).kind;\n-        if let ExprKind::Path(ref some_path) = e.kind;\n-        if is_lang_ctor(cx, some_path, OptionSome) && args.len() == 1;\n-        if let ExprKind::Path(QPath::Resolved(_, path2)) = args[0].kind;\n-        if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n-        then {\n-            return Some(rb)\n-        }\n-    }\n-    None\n-}\n-\n fn has_multiple_ref_pats<'a, 'b, I>(pats: I) -> bool\n where\n     'b: 'a,"}]}