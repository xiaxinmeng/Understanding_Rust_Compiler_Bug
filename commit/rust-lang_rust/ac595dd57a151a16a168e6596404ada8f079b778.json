{"sha": "ac595dd57a151a16a168e6596404ada8f079b778", "node_id": "C_kwDOAAsO6NoAKGFjNTk1ZGQ1N2ExNTFhMTZhMTY4ZTY1OTY0MDRhZGE4ZjA3OWI3Nzg", "commit": {"author": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2022-06-23T03:14:32Z"}, "committer": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2022-06-23T03:14:32Z"}, "message": "Merge commit 'c4416f20dcaec5d93077f72470e83e150fb923b1' into sync-rustfmt", "tree": {"sha": "4bc7319f885acb7aeaf958d4fb0534cf9c148569", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bc7319f885acb7aeaf958d4fb0534cf9c148569"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac595dd57a151a16a168e6596404ada8f079b778", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac595dd57a151a16a168e6596404ada8f079b778", "html_url": "https://github.com/rust-lang/rust/commit/ac595dd57a151a16a168e6596404ada8f079b778", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac595dd57a151a16a168e6596404ada8f079b778/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac2b7a261c94d2d7d718bede54fc93c7f2fdd641", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac2b7a261c94d2d7d718bede54fc93c7f2fdd641", "html_url": "https://github.com/rust-lang/rust/commit/ac2b7a261c94d2d7d718bede54fc93c7f2fdd641"}], "stats": {"total": 12166, "additions": 533, "deletions": 11633}, "files": [{"sha": "bce9b0c8d5a95ed1659c4906be6647d20369babe", "filename": ".github/workflows/linux.yml", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/.github%2Fworkflows%2Flinux.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/.github%2Fworkflows%2Flinux.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Flinux.yml?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -35,15 +35,5 @@ jobs:\n         sh rustup-init.sh -y --default-toolchain none\n         rustup target add ${{ matrix.target }}\n \n-    - name: build\n-      run: |\n-        rustc -Vv\n-        cargo -V\n-        cargo build\n-      env:\n-        RUSTFLAGS: '-D warnings'\n-\n-    - name: test\n-      run: cargo test\n-      env:\n-        RUSTFLAGS: '-D warnings'\n+    - name: Build and Test\n+      run: ./ci/build_and_test.sh"}, {"sha": "89a980c42c5a09cbc17d600ad31099726832e4c4", "filename": ".github/workflows/mac.yml", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/.github%2Fworkflows%2Fmac.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/.github%2Fworkflows%2Fmac.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fmac.yml?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -32,11 +32,5 @@ jobs:\n         sh rustup-init.sh -y --default-toolchain none\n         rustup target add ${{ matrix.target }}\n \n-    - name: build\n-      run: |\n-        rustc -Vv\n-        cargo -V\n-        cargo build\n-\n-    - name: test\n-      run: cargo test\n+    - name: Build and Test\n+      run: ./ci/build_and_test.sh"}, {"sha": "ec37c714b085106d0fbbbe9d65ff9c5ed2f44159", "filename": ".github/workflows/windows.yml", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/.github%2Fworkflows%2Fwindows.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/.github%2Fworkflows%2Fwindows.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fwindows.yml?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -57,13 +57,6 @@ jobs:\n       if: matrix.target == 'x86_64-pc-windows-gnu' && matrix.channel == 'nightly'\n       shell: bash\n \n-    - name: build\n-      run: |\n-        rustc -Vv\n-        cargo -V\n-        cargo build\n-      shell: cmd\n-\n-    - name: test\n-      run: cargo test\n+    - name: Build and Test\n       shell: cmd\n+      run: ci\\build_and_test.bat"}, {"sha": "0c1893bf8c387f1ddd72f8958cc0885589159dcc", "filename": "CHANGELOG.md", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -2,7 +2,29 @@\n \n ## [Unreleased]\n \n-## [1.5.0] 2022-06-13\n+## [1.5.1] 2022-06-24\n+\n+**N.B** A bug was introduced in v1.5.0/nightly-2022-06-15 which modified formatting. If you happened to run rustfmt over your code with one of those ~10 nightlies it's possible you may have seen formatting changes, and you may see additional changes after this fix since that bug has now been reverted.\n+\n+### Fixed\n+\n+- Correct an issue introduced in v1.5.0 where formatting changes were unintentionally introduced in a few cases with a large/long construct in a right hand side position (e.g. a large chain on the RHS of a local/assignment statement)\n+- `cargo fmt --version` properly displays the version value again [#5395](https://github.com/rust-lang/rustfmt/issues/5395)\n+\n+### Changed\n+\n+- Properly sort imports containing raw identifiers [#3791](https://github.com/rust-lang/rustfmt/issues/3791) (note this is change version gated, and not applied by default)\n+\n+### Added\n+\n+- Add new configuration option, `doc_comment_code_block_width`, which allows for setting a shorter width limit to use for formatting code snippets in doc comments [#5384](https://github.com/rust-lang/rustfmt/issues/5384)\n+\n+### Install/Download Options\n+- **rustup (nightly)** - nightly-2022-06-24\n+- **GitHub Release Binaries** - [Release v1.5.1](https://github.com/rust-lang/rustfmt/releases/tag/v1.5.0)\n+- **Build from source** - [Tag v1.5.1](https://github.com/rust-lang/rustfmt/tree/v1.5.1), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.5.0] 2022-06-14\n \n ### Changed\n \n@@ -75,7 +97,7 @@\n - Improved performance when formatting large and deeply nested expression trees, often found in generated code, which have many expressions that exceed `max_width` [#5128](https://github.com/rust-lang/rustfmt/issues/5128), [#4867](https://github.com/rust-lang/rustfmt/issues/4867), [#4476](https://github.com/rust-lang/rustfmt/issues/4476), [#5139](https://github.com/rust-lang/rustfmt/pull/5139)\n \n ### Install/Download Options\n-- **rustup (nightly)** - *pending*\n+- **rustup (nightly)** - nightly-2022-06-15\n - **GitHub Release Binaries** - [Release v1.5.0](https://github.com/rust-lang/rustfmt/releases/tag/v1.5.0)\n - **Build from source** - [Tag v1.5.0](https://github.com/rust-lang/rustfmt/tree/v1.5.0), see instructions for how to [install rustfmt from source][install-from-source]\n "}, {"sha": "311df226da19dea273bd3b6680ea919f38b1eb33", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -485,7 +485,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.5.0\"\n+version = \"1.5.1\"\n dependencies = [\n  \"annotate-snippets\",\n  \"anyhow\","}, {"sha": "7a4e02d69eddc05f7db59d35654d812b89031669", "filename": "Cargo.toml", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -1,7 +1,7 @@\n [package]\n \n name = \"rustfmt-nightly\"\n-version = \"1.5.0\"\n+version = \"1.5.1\"\n description = \"Tool to find and fix Rust formatting issues\"\n repository = \"https://github.com/rust-lang/rustfmt\"\n readme = \"README.md\"\n@@ -65,3 +65,7 @@ rustfmt-config_proc_macro = { version = \"0.2\", path = \"config_proc_macro\" }\n rustc-workspace-hack = \"1.0.0\"\n \n # Rustc dependencies are loaded from the sysroot, Cargo doesn't know about them.\n+\n+[package.metadata.rust-analyzer]\n+# This package uses #[feature(rustc_private)]\n+rustc_private = true"}, {"sha": "8b96b9d36892ae0494b72aeef42f409f34597e88", "filename": "Configurations.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -926,6 +926,14 @@ fn add_one(x: i32) -> i32 {\n }\n ```\n \n+## `doc_comment_code_block_width`\n+\n+Max width for code snippets included in doc comments. Only used if [`format_code_in_doc_comments`](#format_code_in_doc_comments) is true.\n+\n+- **Default value**: `100`\n+- **Possible values**: any positive integer that is less than or equal to the value specified for [`max_width`](#max_width)\n+- **Stable**: No (tracking issue: [#5359](https://github.com/rust-lang/rustfmt/issues/5359))\n+\n ## `format_generated_files`\n \n Format generated files. A file is considered generated"}, {"sha": "ef41017783feb6e44f576f3bc3e58b8a8bdfa1c3", "filename": "ci/build_and_test.bat", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/ci%2Fbuild_and_test.bat", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/ci%2Fbuild_and_test.bat", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci%2Fbuild_and_test.bat?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -0,0 +1,14 @@\n+set \"RUSTFLAGS=-D warnings\"\n+\n+:: Print version information\n+rustc -Vv || exit /b 1\n+cargo -V || exit /b 1\n+\n+:: Build and test main crate\n+cargo build --locked || exit /b 1\n+cargo test || exit /b 1\n+\n+:: Build and test other crates\n+cd config_proc_macro || exit /b 1\n+cargo build --locked || exit /b 1\n+cargo test || exit /b 1"}, {"sha": "8fa0f67b0d02184e63d299bfcf0befb7ee82ce9a", "filename": "ci/build_and_test.sh", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/ci%2Fbuild_and_test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/ci%2Fbuild_and_test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci%2Fbuild_and_test.sh?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -0,0 +1,18 @@\n+#!/bin/bash\n+\n+set -euo pipefail\n+\n+export RUSTFLAGS=\"-D warnings\"\n+\n+# Print version information\n+rustc -Vv\n+cargo -V\n+\n+# Build and test main crate\n+cargo build --locked\n+cargo test\n+\n+# Build and test other crates\n+cd config_proc_macro\n+cargo build --locked\n+cargo test"}, {"sha": "562d5d70c70ba63a5dbfcfc3d4709897efed615a", "filename": "ci/integration.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/ci%2Fintegration.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/ci%2Fintegration.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ci%2Fintegration.sh?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -15,7 +15,7 @@ set -ex\n # it again.\n #\n #which cargo-fmt || cargo install --force\n-CFG_RELEASE=nightly CFG_RELEASE_CHANNEL=nightly cargo install --path . --force\n+CFG_RELEASE=nightly CFG_RELEASE_CHANNEL=nightly cargo install --path . --force --locked\n \n echo \"Integration tests for: ${INTEGRATION}\"\n cargo fmt -- --version"}, {"sha": "ecf561f28fb6aa5e64cffedfdefd2a146e61b1d5", "filename": "config_proc_macro/Cargo.lock", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/config_proc_macro%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/config_proc_macro%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2FCargo.lock?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -1,68 +1,68 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n+version = 3\n+\n [[package]]\n name = \"proc-macro2\"\n version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e98a83a9f9b331f54b924e68a66acb1bb35cb01fb0a23645139967abefb697e8\"\n dependencies = [\n- \"unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n name = \"quote\"\n version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"053a8c8bcc71fcce321828dc897a98ab9760bef03a4fc36693c231e5b3216cfe\"\n dependencies = [\n- \"proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2\",\n ]\n \n [[package]]\n name = \"rustfmt-config_proc_macro\"\n-version = \"0.1.2\"\n+version = \"0.2.0\"\n dependencies = [\n- \"proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"serde\",\n+ \"syn\",\n ]\n \n [[package]]\n name = \"serde\"\n version = \"1.0.99\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fec2851eb56d010dc9a21b89ca53ee75e6528bab60c11e89d38390904982da9f\"\n dependencies = [\n- \"serde_derive 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n version = \"1.0.99\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cb4dc18c61206b08dc98216c98faa0232f4337e1e1b8574551d5bad29ea1b425\"\n dependencies = [\n- \"proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n name = \"syn\"\n version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"66850e97125af79138385e9b88339cbcd037e3f28ceab8c5ad98e64f0f1f80bf\"\n dependencies = [\n- \"proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n name = \"unicode-xid\"\n version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[metadata]\n-\"checksum proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e98a83a9f9b331f54b924e68a66acb1bb35cb01fb0a23645139967abefb697e8\"\n-\"checksum quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"053a8c8bcc71fcce321828dc897a98ab9760bef03a4fc36693c231e5b3216cfe\"\n-\"checksum serde 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fec2851eb56d010dc9a21b89ca53ee75e6528bab60c11e89d38390904982da9f\"\n-\"checksum serde_derive 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cb4dc18c61206b08dc98216c98faa0232f4337e1e1b8574551d5bad29ea1b425\"\n-\"checksum syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"66850e97125af79138385e9b88339cbcd037e3f28ceab8c5ad98e64f0f1f80bf\"\n-\"checksum unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c\"\n+checksum = \"826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c\""}, {"sha": "e772c53f42361f94131e0e67294b107ae532a0cd", "filename": "config_proc_macro/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/config_proc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/config_proc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config_proc_macro%2Fsrc%2Flib.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -29,6 +29,8 @@ pub fn config_type(_args: TokenStream, input: TokenStream) -> TokenStream {\n /// Used to conditionally output the TokenStream for tests that need to be run on nightly only.\n ///\n /// ```rust\n+/// # use rustfmt_config_proc_macro::nightly_only_test;\n+///\n /// #[nightly_only_test]\n /// #[test]\n /// fn test_needs_nightly_rustfmt() {\n@@ -49,6 +51,8 @@ pub fn nightly_only_test(_args: TokenStream, input: TokenStream) -> TokenStream\n /// Used to conditionally output the TokenStream for tests that need to be run on stable only.\n ///\n /// ```rust\n+/// # use rustfmt_config_proc_macro::stable_only_test;\n+///\n /// #[stable_only_test]\n /// #[test]\n /// fn test_needs_stable_rustfmt() {"}, {"sha": "2640a9e0ecc286cd9c0e6e020e1207ffe17bf8e1", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-06-06\"\n+channel = \"nightly-2022-06-21\"\n components = [\"rustc-dev\"]"}, {"sha": "9031d29b45f7ff3e7b3f3a4c0b58a8a465ae9ebf", "filename": "src/cargo-fmt/main.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fcargo-fmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fcargo-fmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo-fmt%2Fmain.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -14,14 +14,15 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::str;\n \n-use clap::{CommandFactory, Parser};\n+use clap::{AppSettings, CommandFactory, Parser};\n \n #[path = \"test/mod.rs\"]\n #[cfg(test)]\n mod cargo_fmt_tests;\n \n #[derive(Parser)]\n #[clap(\n+    global_setting(AppSettings::NoAutoVersion),\n     bin_name = \"cargo fmt\",\n     about = \"This utility formats all bin and lib files of \\\n              the current crate using rustfmt.\""}, {"sha": "4d565afc1e0266c7544f2a5be85912856c26cd98", "filename": "src/comment.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -730,6 +730,10 @@ impl<'a> CommentRewrite<'a> {\n                     {\n                         let mut config = self.fmt.config.clone();\n                         config.set().wrap_comments(false);\n+                        let comment_max_width = config\n+                            .doc_comment_code_block_width()\n+                            .min(config.max_width());\n+                        config.set().max_width(comment_max_width);\n                         if let Some(s) =\n                             crate::format_code_block(&self.code_block_buffer, &config, false)\n                         {"}, {"sha": "f49c18d3a4603a9804168664629c314181d7838f", "filename": "src/config/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -57,6 +57,8 @@ create_config! {\n     // Comments. macros, and strings\n     wrap_comments: bool, false, false, \"Break comments to fit on the line\";\n     format_code_in_doc_comments: bool, false, false, \"Format the code snippet in doc comments.\";\n+    doc_comment_code_block_width: usize, 100, false, \"Maximum width for code snippets in doc \\\n+        comments. No effect unless format_code_in_doc_comments = true\";\n     comment_width: usize, 80, false,\n         \"Maximum length of comments. No effect unless wrap_comments = true\";\n     normalize_comments: bool, false, false, \"Convert /* */ comments to // comments where possible\";\n@@ -532,6 +534,7 @@ chain_width = 60\n single_line_if_else_max_width = 50\n wrap_comments = false\n format_code_in_doc_comments = false\n+doc_comment_code_block_width = 100\n comment_width = 80\n normalize_comments = false\n normalize_doc_attributes = false"}, {"sha": "e4cc93026f10bb552b89514ce87d5098d87352ed", "filename": "src/expr.rs", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -1,6 +1,5 @@\n use std::borrow::Cow;\n use std::cmp::min;\n-use std::collections::HashMap;\n \n use itertools::Itertools;\n use rustc_ast::token::{Delimiter, LitKind};\n@@ -23,7 +22,7 @@ use crate::macros::{rewrite_macro, MacroPosition};\n use crate::matches::rewrite_match;\n use crate::overflow::{self, IntoOverflowableItem, OverflowableItem};\n use crate::pairs::{rewrite_all_pairs, rewrite_pair, PairParts};\n-use crate::rewrite::{QueryId, Rewrite, RewriteContext};\n+use crate::rewrite::{Rewrite, RewriteContext};\n use crate::shape::{Indent, Shape};\n use crate::source_map::{LineRangeUtils, SpanUtils};\n use crate::spanned::Spanned;\n@@ -54,54 +53,6 @@ pub(crate) fn format_expr(\n     expr_type: ExprType,\n     context: &RewriteContext<'_>,\n     shape: Shape,\n-) -> Option<String> {\n-    // when max_width is tight, we should check all possible formattings, in order to find\n-    // if we can fit expression in the limit. Doing it recursively takes exponential time\n-    // relative to input size, and people hit it with rustfmt takes minutes in #4476 #4867 #5128\n-    // By memoization of format_expr function, we format each pair of expression and shape\n-    // only once, so worst case execution time becomes O(n*max_width^3).\n-    if context.inside_macro() || context.is_macro_def {\n-        // span ids are not unique in macros, so we don't memoize result of them.\n-        return format_expr_inner(expr, expr_type, context, shape);\n-    }\n-    let clean;\n-    let query_id = QueryId {\n-        shape,\n-        span: expr.span,\n-    };\n-    if let Some(map) = context.memoize.take() {\n-        if let Some(r) = map.get(&query_id) {\n-            let r = r.clone();\n-            context.memoize.set(Some(map)); // restore map in the memoize cell for other users\n-            return r;\n-        }\n-        context.memoize.set(Some(map));\n-        clean = false;\n-    } else {\n-        context.memoize.set(Some(HashMap::default()));\n-        clean = true; // We got None, so we are the top level called function. When\n-        // this function finishes, no one is interested in what is in the map, because\n-        // all of them are sub expressions of this top level expression, and this is\n-        // done. So we should clean up memoize map to save some memory.\n-    }\n-\n-    let r = format_expr_inner(expr, expr_type, context, shape);\n-    if clean {\n-        context.memoize.set(None);\n-    } else {\n-        if let Some(mut map) = context.memoize.take() {\n-            map.insert(query_id, r.clone()); // insert the result in the memoize map\n-            context.memoize.set(Some(map)); // so it won't be computed again\n-        }\n-    }\n-    r\n-}\n-\n-fn format_expr_inner(\n-    expr: &ast::Expr,\n-    expr_type: ExprType,\n-    context: &RewriteContext<'_>,\n-    shape: Shape,\n ) -> Option<String> {\n     skip_out_of_file_lines_range!(context, expr.span);\n "}, {"sha": "1dfd8a514f0bcc0994cc590cbf45a0c1f9064019", "filename": "src/formatting.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -2,7 +2,6 @@\n \n use std::collections::HashMap;\n use std::io::{self, Write};\n-use std::rc::Rc;\n use std::time::{Duration, Instant};\n \n use rustc_ast::ast;\n@@ -203,7 +202,6 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n             self.config,\n             &snippet_provider,\n             self.report.clone(),\n-            Rc::default(),\n         );\n         visitor.skip_context.update_with_attrs(&self.krate.attrs);\n         visitor.is_macro_def = is_macro_def;"}, {"sha": "8d41c881589e5564c97fd3220a4c72b1ff0b63d0", "filename": "src/imports.rs", "status": "modified", "additions": 227, "deletions": 116, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -15,7 +15,7 @@ use rustc_span::{\n use crate::comment::combine_strs_with_missing_comments;\n use crate::config::lists::*;\n use crate::config::ImportGranularity;\n-use crate::config::{Edition, IndentStyle};\n+use crate::config::{Edition, IndentStyle, Version};\n use crate::lists::{\n     definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator,\n };\n@@ -92,7 +92,7 @@ impl<'a> FmtVisitor<'a> {\n \n // FIXME we do a lot of allocation to make our own representation.\n #[derive(Clone, Eq, Hash, PartialEq)]\n-pub(crate) enum UseSegment {\n+pub(crate) enum UseSegmentKind {\n     Ident(String, Option<String>),\n     Slf(Option<String>),\n     Super(Option<String>),\n@@ -101,6 +101,12 @@ pub(crate) enum UseSegment {\n     List(Vec<UseTree>),\n }\n \n+#[derive(Clone, Eq, PartialEq)]\n+pub(crate) struct UseSegment {\n+    pub(crate) kind: UseSegmentKind,\n+    pub(crate) version: Version,\n+}\n+\n #[derive(Clone)]\n pub(crate) struct UseTree {\n     pub(crate) path: Vec<UseSegment>,\n@@ -134,34 +140,38 @@ impl Spanned for UseTree {\n impl UseSegment {\n     // Clone a version of self with any top-level alias removed.\n     fn remove_alias(&self) -> UseSegment {\n-        match *self {\n-            UseSegment::Ident(ref s, _) => UseSegment::Ident(s.clone(), None),\n-            UseSegment::Slf(_) => UseSegment::Slf(None),\n-            UseSegment::Super(_) => UseSegment::Super(None),\n-            UseSegment::Crate(_) => UseSegment::Crate(None),\n-            _ => self.clone(),\n+        let kind = match self.kind {\n+            UseSegmentKind::Ident(ref s, _) => UseSegmentKind::Ident(s.clone(), None),\n+            UseSegmentKind::Slf(_) => UseSegmentKind::Slf(None),\n+            UseSegmentKind::Super(_) => UseSegmentKind::Super(None),\n+            UseSegmentKind::Crate(_) => UseSegmentKind::Crate(None),\n+            _ => return self.clone(),\n+        };\n+        UseSegment {\n+            kind,\n+            version: self.version,\n         }\n     }\n \n     // Check if self == other with their aliases removed.\n     fn equal_except_alias(&self, other: &Self) -> bool {\n-        match (self, other) {\n-            (UseSegment::Ident(ref s1, _), UseSegment::Ident(ref s2, _)) => s1 == s2,\n-            (UseSegment::Slf(_), UseSegment::Slf(_))\n-            | (UseSegment::Super(_), UseSegment::Super(_))\n-            | (UseSegment::Crate(_), UseSegment::Crate(_))\n-            | (UseSegment::Glob, UseSegment::Glob) => true,\n-            (UseSegment::List(ref list1), UseSegment::List(ref list2)) => list1 == list2,\n+        match (&self.kind, &other.kind) {\n+            (UseSegmentKind::Ident(ref s1, _), UseSegmentKind::Ident(ref s2, _)) => s1 == s2,\n+            (UseSegmentKind::Slf(_), UseSegmentKind::Slf(_))\n+            | (UseSegmentKind::Super(_), UseSegmentKind::Super(_))\n+            | (UseSegmentKind::Crate(_), UseSegmentKind::Crate(_))\n+            | (UseSegmentKind::Glob, UseSegmentKind::Glob) => true,\n+            (UseSegmentKind::List(ref list1), UseSegmentKind::List(ref list2)) => list1 == list2,\n             _ => false,\n         }\n     }\n \n     fn get_alias(&self) -> Option<&str> {\n-        match self {\n-            UseSegment::Ident(_, a)\n-            | UseSegment::Slf(a)\n-            | UseSegment::Super(a)\n-            | UseSegment::Crate(a) => a.as_deref(),\n+        match &self.kind {\n+            UseSegmentKind::Ident(_, a)\n+            | UseSegmentKind::Slf(a)\n+            | UseSegmentKind::Super(a)\n+            | UseSegmentKind::Crate(a) => a.as_deref(),\n             _ => None,\n         }\n     }\n@@ -175,19 +185,24 @@ impl UseSegment {\n         if name.is_empty() || name == \"{{root}}\" {\n             return None;\n         }\n-        Some(match name {\n-            \"self\" => UseSegment::Slf(None),\n-            \"super\" => UseSegment::Super(None),\n-            \"crate\" => UseSegment::Crate(None),\n+        let kind = match name {\n+            \"self\" => UseSegmentKind::Slf(None),\n+            \"super\" => UseSegmentKind::Super(None),\n+            \"crate\" => UseSegmentKind::Crate(None),\n             _ => {\n                 let mod_sep = if modsep { \"::\" } else { \"\" };\n-                UseSegment::Ident(format!(\"{}{}\", mod_sep, name), None)\n+                UseSegmentKind::Ident(format!(\"{}{}\", mod_sep, name), None)\n             }\n+        };\n+\n+        Some(UseSegment {\n+            kind,\n+            version: context.config.version(),\n         })\n     }\n \n     fn contains_comment(&self) -> bool {\n-        if let UseSegment::List(list) = self {\n+        if let UseSegmentKind::List(list) = &self.kind {\n             list.iter().any(|subtree| subtree.contains_comment())\n         } else {\n             false\n@@ -254,20 +269,38 @@ impl fmt::Debug for UseTree {\n \n impl fmt::Debug for UseSegment {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n+        fmt::Display::fmt(&self.kind, f)\n     }\n }\n \n impl fmt::Display for UseSegment {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.kind, f)\n+    }\n+}\n+\n+impl Hash for UseSegment {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.kind.hash(state);\n+    }\n+}\n+\n+impl fmt::Debug for UseSegmentKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for UseSegmentKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            UseSegment::Glob => write!(f, \"*\"),\n-            UseSegment::Ident(ref s, Some(ref alias)) => write!(f, \"{} as {}\", s, alias),\n-            UseSegment::Ident(ref s, None) => write!(f, \"{}\", s),\n-            UseSegment::Slf(..) => write!(f, \"self\"),\n-            UseSegment::Super(..) => write!(f, \"super\"),\n-            UseSegment::Crate(..) => write!(f, \"crate\"),\n-            UseSegment::List(ref list) => {\n+            UseSegmentKind::Glob => write!(f, \"*\"),\n+            UseSegmentKind::Ident(ref s, Some(ref alias)) => write!(f, \"{} as {}\", s, alias),\n+            UseSegmentKind::Ident(ref s, None) => write!(f, \"{}\", s),\n+            UseSegmentKind::Slf(..) => write!(f, \"self\"),\n+            UseSegmentKind::Super(..) => write!(f, \"super\"),\n+            UseSegmentKind::Crate(..) => write!(f, \"crate\"),\n+            UseSegmentKind::List(ref list) => {\n                 write!(f, \"{{\")?;\n                 for (i, item) in list.iter().enumerate() {\n                     if i != 0 {\n@@ -411,13 +444,19 @@ impl UseTree {\n             }\n         }\n \n+        let version = context.config.version();\n+\n         match a.kind {\n             UseTreeKind::Glob => {\n                 // in case of a global path and the glob starts at the root, e.g., \"::*\"\n                 if a.prefix.segments.len() == 1 && leading_modsep {\n-                    result.path.push(UseSegment::Ident(\"\".to_owned(), None));\n+                    let kind = UseSegmentKind::Ident(\"\".to_owned(), None);\n+                    result.path.push(UseSegment { kind, version });\n                 }\n-                result.path.push(UseSegment::Glob);\n+                result.path.push(UseSegment {\n+                    kind: UseSegmentKind::Glob,\n+                    version,\n+                });\n             }\n             UseTreeKind::Nested(ref list) => {\n                 // Extract comments between nested use items.\n@@ -438,16 +477,18 @@ impl UseTree {\n                 // in case of a global path and the nested list starts at the root,\n                 // e.g., \"::{foo, bar}\"\n                 if a.prefix.segments.len() == 1 && leading_modsep {\n-                    result.path.push(UseSegment::Ident(\"\".to_owned(), None));\n+                    let kind = UseSegmentKind::Ident(\"\".to_owned(), None);\n+                    result.path.push(UseSegment { kind, version });\n                 }\n-                result.path.push(UseSegment::List(\n+                let kind = UseSegmentKind::List(\n                     list.iter()\n                         .zip(items)\n                         .map(|(t, list_item)| {\n                             Self::from_ast(context, &t.0, Some(list_item), None, None, None)\n                         })\n                         .collect(),\n-                ));\n+                );\n+                result.path.push(UseSegment { kind, version });\n             }\n             UseTreeKind::Simple(ref rename, ..) => {\n                 // If the path has leading double colons and is composed of only 2 segments, then we\n@@ -469,13 +510,15 @@ impl UseTree {\n                         Some(rewrite_ident(context, ident).to_owned())\n                     }\n                 });\n-                let segment = match name.as_ref() {\n-                    \"self\" => UseSegment::Slf(alias),\n-                    \"super\" => UseSegment::Super(alias),\n-                    \"crate\" => UseSegment::Crate(alias),\n-                    _ => UseSegment::Ident(name, alias),\n+                let kind = match name.as_ref() {\n+                    \"self\" => UseSegmentKind::Slf(alias),\n+                    \"super\" => UseSegmentKind::Super(alias),\n+                    \"crate\" => UseSegmentKind::Crate(alias),\n+                    _ => UseSegmentKind::Ident(name, alias),\n                 };\n \n+                let segment = UseSegment { kind, version };\n+\n                 // `name` is already in result.\n                 result.path.pop();\n                 result.path.push(segment);\n@@ -492,39 +535,46 @@ impl UseTree {\n         let mut aliased_self = false;\n \n         // Remove foo::{} or self without attributes.\n-        match last {\n+        match last.kind {\n             _ if self.attrs.is_some() => (),\n-            UseSegment::List(ref list) if list.is_empty() => {\n+            UseSegmentKind::List(ref list) if list.is_empty() => {\n                 self.path = vec![];\n                 return self;\n             }\n-            UseSegment::Slf(None) if self.path.is_empty() && self.visibility.is_some() => {\n+            UseSegmentKind::Slf(None) if self.path.is_empty() && self.visibility.is_some() => {\n                 self.path = vec![];\n                 return self;\n             }\n             _ => (),\n         }\n \n         // Normalise foo::self -> foo.\n-        if let UseSegment::Slf(None) = last {\n+        if let UseSegmentKind::Slf(None) = last.kind {\n             if !self.path.is_empty() {\n                 return self;\n             }\n         }\n \n         // Normalise foo::self as bar -> foo as bar.\n-        if let UseSegment::Slf(_) = last {\n-            if let Some(UseSegment::Ident(_, None)) = self.path.last() {\n+        if let UseSegmentKind::Slf(_) = last.kind {\n+            if let Some(UseSegment {\n+                kind: UseSegmentKind::Ident(_, None),\n+                ..\n+            }) = self.path.last()\n+            {\n                 aliased_self = true;\n             }\n         }\n \n         let mut done = false;\n         if aliased_self {\n             match self.path.last_mut() {\n-                Some(UseSegment::Ident(_, ref mut old_rename)) => {\n+                Some(UseSegment {\n+                    kind: UseSegmentKind::Ident(_, ref mut old_rename),\n+                    ..\n+                }) => {\n                     assert!(old_rename.is_none());\n-                    if let UseSegment::Slf(Some(rename)) = last.clone() {\n+                    if let UseSegmentKind::Slf(Some(rename)) = last.clone().kind {\n                         *old_rename = Some(rename);\n                         done = true;\n                     }\n@@ -538,15 +588,15 @@ impl UseTree {\n         }\n \n         // Normalise foo::{bar} -> foo::bar\n-        if let UseSegment::List(ref list) = last {\n+        if let UseSegmentKind::List(ref list) = last.kind {\n             if list.len() == 1 && list[0].to_string() != \"self\" {\n                 normalize_sole_list = true;\n             }\n         }\n \n         if normalize_sole_list {\n-            match last {\n-                UseSegment::List(list) => {\n+            match last.kind {\n+                UseSegmentKind::List(list) => {\n                     for seg in &list[0].path {\n                         self.path.push(seg.clone());\n                     }\n@@ -557,10 +607,13 @@ impl UseTree {\n         }\n \n         // Recursively normalize elements of a list use (including sorting the list).\n-        if let UseSegment::List(list) = last {\n+        if let UseSegmentKind::List(list) = last.kind {\n             let mut list = list.into_iter().map(UseTree::normalize).collect::<Vec<_>>();\n             list.sort();\n-            last = UseSegment::List(list);\n+            last = UseSegment {\n+                kind: UseSegmentKind::List(list),\n+                version: last.version,\n+            };\n         }\n \n         self.path.push(last);\n@@ -620,10 +673,10 @@ impl UseTree {\n         if self.path.is_empty() || self.contains_comment() {\n             return vec![self];\n         }\n-        match self.path.clone().last().unwrap() {\n-            UseSegment::List(list) => {\n+        match &self.path.clone().last().unwrap().kind {\n+            UseSegmentKind::List(list) => {\n                 if list.len() == 1 && list[0].path.len() == 1 {\n-                    if let UseSegment::Slf(..) = list[0].path[0] {\n+                    if let UseSegmentKind::Slf(..) = list[0].path[0].kind {\n                         return vec![self];\n                     };\n                 }\n@@ -671,12 +724,15 @@ impl UseTree {\n \n     /// If this tree ends in `::self`, rewrite it to `::{self}`.\n     fn nest_trailing_self(mut self) -> UseTree {\n-        if let Some(UseSegment::Slf(..)) = self.path.last() {\n+        if let Some(UseSegment {\n+            kind: UseSegmentKind::Slf(..),\n+            ..\n+        }) = self.path.last()\n+        {\n             let self_segment = self.path.pop().unwrap();\n-            self.path.push(UseSegment::List(vec![UseTree::from_path(\n-                vec![self_segment],\n-                DUMMY_SP,\n-            )]));\n+            let version = self_segment.version;\n+            let kind = UseSegmentKind::List(vec![UseTree::from_path(vec![self_segment], DUMMY_SP)]);\n+            self.path.push(UseSegment { kind, version });\n         }\n         self\n     }\n@@ -692,15 +748,17 @@ fn merge_rest(\n         return None;\n     }\n     if a.len() != len && b.len() != len {\n-        if let UseSegment::List(ref list) = a[len] {\n+        let version = a[len].version;\n+        if let UseSegmentKind::List(ref list) = a[len].kind {\n             let mut list = list.clone();\n             merge_use_trees_inner(\n                 &mut list,\n                 UseTree::from_path(b[len..].to_vec(), DUMMY_SP),\n                 merge_by,\n             );\n             let mut new_path = b[..len].to_vec();\n-            new_path.push(UseSegment::List(list));\n+            let kind = UseSegmentKind::List(list);\n+            new_path.push(UseSegment { kind, version });\n             return Some(new_path);\n         }\n     } else if len == 1 {\n@@ -709,15 +767,28 @@ fn merge_rest(\n         } else {\n             (&b[0], &a[1..])\n         };\n+        let kind = UseSegmentKind::Slf(common.get_alias().map(ToString::to_string));\n+        let version = a[0].version;\n         let mut list = vec![UseTree::from_path(\n-            vec![UseSegment::Slf(common.get_alias().map(ToString::to_string))],\n+            vec![UseSegment { kind, version }],\n             DUMMY_SP,\n         )];\n         match rest {\n-            [UseSegment::List(rest_list)] => list.extend(rest_list.clone()),\n+            [\n+                UseSegment {\n+                    kind: UseSegmentKind::List(rest_list),\n+                    ..\n+                },\n+            ] => list.extend(rest_list.clone()),\n             _ => list.push(UseTree::from_path(rest.to_vec(), DUMMY_SP)),\n         }\n-        return Some(vec![b[0].clone(), UseSegment::List(list)]);\n+        return Some(vec![\n+            b[0].clone(),\n+            UseSegment {\n+                kind: UseSegmentKind::List(list),\n+                version,\n+            },\n+        ]);\n     } else {\n         len -= 1;\n     }\n@@ -727,7 +798,9 @@ fn merge_rest(\n     ];\n     list.sort();\n     let mut new_path = b[..len].to_vec();\n-    new_path.push(UseSegment::List(list));\n+    let kind = UseSegmentKind::List(list);\n+    let version = a[0].version;\n+    new_path.push(UseSegment { kind, version });\n     Some(new_path)\n }\n \n@@ -805,19 +878,33 @@ impl PartialOrd for UseTree {\n }\n impl Ord for UseSegment {\n     fn cmp(&self, other: &UseSegment) -> Ordering {\n-        use self::UseSegment::*;\n+        use self::UseSegmentKind::*;\n \n         fn is_upper_snake_case(s: &str) -> bool {\n             s.chars()\n                 .all(|c| c.is_uppercase() || c == '_' || c.is_numeric())\n         }\n \n-        match (self, other) {\n-            (&Slf(ref a), &Slf(ref b))\n-            | (&Super(ref a), &Super(ref b))\n-            | (&Crate(ref a), &Crate(ref b)) => a.cmp(b),\n-            (&Glob, &Glob) => Ordering::Equal,\n-            (&Ident(ref ia, ref aa), &Ident(ref ib, ref ab)) => {\n+        match (&self.kind, &other.kind) {\n+            (Slf(ref a), Slf(ref b))\n+            | (Super(ref a), Super(ref b))\n+            | (Crate(ref a), Crate(ref b)) => match (a, b) {\n+                (Some(sa), Some(sb)) => {\n+                    if self.version == Version::Two {\n+                        sa.trim_start_matches(\"r#\").cmp(sb.trim_start_matches(\"r#\"))\n+                    } else {\n+                        a.cmp(b)\n+                    }\n+                }\n+                (_, _) => a.cmp(b),\n+            },\n+            (Glob, Glob) => Ordering::Equal,\n+            (Ident(ref pia, ref aa), Ident(ref pib, ref ab)) => {\n+                let (ia, ib) = if self.version == Version::Two {\n+                    (pia.trim_start_matches(\"r#\"), pib.trim_start_matches(\"r#\"))\n+                } else {\n+                    (pia.as_str(), pib.as_str())\n+                };\n                 // snake_case < CamelCase < UPPER_SNAKE_CASE\n                 if ia.starts_with(char::is_uppercase) && ib.starts_with(char::is_lowercase) {\n                     return Ordering::Greater;\n@@ -835,15 +922,21 @@ impl Ord for UseSegment {\n                 if ident_ord != Ordering::Equal {\n                     return ident_ord;\n                 }\n-                if aa.is_none() && ab.is_some() {\n-                    return Ordering::Less;\n-                }\n-                if aa.is_some() && ab.is_none() {\n-                    return Ordering::Greater;\n+                match (aa, ab) {\n+                    (None, Some(_)) => Ordering::Less,\n+                    (Some(_), None) => Ordering::Greater,\n+                    (Some(aas), Some(abs)) => {\n+                        if self.version == Version::Two {\n+                            aas.trim_start_matches(\"r#\")\n+                                .cmp(abs.trim_start_matches(\"r#\"))\n+                        } else {\n+                            aas.cmp(abs)\n+                        }\n+                    }\n+                    (None, None) => Ordering::Equal,\n                 }\n-                aa.cmp(ab)\n             }\n-            (&List(ref a), &List(ref b)) => {\n+            (List(ref a), List(ref b)) => {\n                 for (a, b) in a.iter().zip(b.iter()) {\n                     let ord = a.cmp(b);\n                     if ord != Ordering::Equal {\n@@ -853,16 +946,16 @@ impl Ord for UseSegment {\n \n                 a.len().cmp(&b.len())\n             }\n-            (&Slf(_), _) => Ordering::Less,\n-            (_, &Slf(_)) => Ordering::Greater,\n-            (&Super(_), _) => Ordering::Less,\n-            (_, &Super(_)) => Ordering::Greater,\n-            (&Crate(_), _) => Ordering::Less,\n-            (_, &Crate(_)) => Ordering::Greater,\n-            (&Ident(..), _) => Ordering::Less,\n-            (_, &Ident(..)) => Ordering::Greater,\n-            (&Glob, _) => Ordering::Less,\n-            (_, &Glob) => Ordering::Greater,\n+            (Slf(_), _) => Ordering::Less,\n+            (_, Slf(_)) => Ordering::Greater,\n+            (Super(_), _) => Ordering::Less,\n+            (_, Super(_)) => Ordering::Greater,\n+            (Crate(_), _) => Ordering::Less,\n+            (_, Crate(_)) => Ordering::Greater,\n+            (Ident(..), _) => Ordering::Less,\n+            (_, Ident(..)) => Ordering::Greater,\n+            (Glob, _) => Ordering::Less,\n+            (_, Glob) => Ordering::Greater,\n         }\n     }\n }\n@@ -906,7 +999,7 @@ fn rewrite_nested_use_tree(\n     }\n     let has_nested_list = use_tree_list.iter().any(|use_segment| {\n         use_segment.path.last().map_or(false, |last_segment| {\n-            matches!(last_segment, UseSegment::List(..))\n+            matches!(last_segment.kind, UseSegmentKind::List(..))\n         })\n     });\n \n@@ -957,17 +1050,19 @@ fn rewrite_nested_use_tree(\n \n impl Rewrite for UseSegment {\n     fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n-        Some(match self {\n-            UseSegment::Ident(ref ident, Some(ref rename)) => format!(\"{} as {}\", ident, rename),\n-            UseSegment::Ident(ref ident, None) => ident.clone(),\n-            UseSegment::Slf(Some(ref rename)) => format!(\"self as {}\", rename),\n-            UseSegment::Slf(None) => \"self\".to_owned(),\n-            UseSegment::Super(Some(ref rename)) => format!(\"super as {}\", rename),\n-            UseSegment::Super(None) => \"super\".to_owned(),\n-            UseSegment::Crate(Some(ref rename)) => format!(\"crate as {}\", rename),\n-            UseSegment::Crate(None) => \"crate\".to_owned(),\n-            UseSegment::Glob => \"*\".to_owned(),\n-            UseSegment::List(ref use_tree_list) => rewrite_nested_use_tree(\n+        Some(match self.kind {\n+            UseSegmentKind::Ident(ref ident, Some(ref rename)) => {\n+                format!(\"{} as {}\", ident, rename)\n+            }\n+            UseSegmentKind::Ident(ref ident, None) => ident.clone(),\n+            UseSegmentKind::Slf(Some(ref rename)) => format!(\"self as {}\", rename),\n+            UseSegmentKind::Slf(None) => \"self\".to_owned(),\n+            UseSegmentKind::Super(Some(ref rename)) => format!(\"super as {}\", rename),\n+            UseSegmentKind::Super(None) => \"super\".to_owned(),\n+            UseSegmentKind::Crate(Some(ref rename)) => format!(\"crate as {}\", rename),\n+            UseSegmentKind::Crate(None) => \"crate\".to_owned(),\n+            UseSegmentKind::Glob => \"*\".to_owned(),\n+            UseSegmentKind::List(ref use_tree_list) => rewrite_nested_use_tree(\n                 context,\n                 use_tree_list,\n                 // 1 = \"{\" and \"}\"\n@@ -1016,6 +1111,7 @@ mod test {\n \n         struct Parser<'a> {\n             input: Peekable<Chars<'a>>,\n+            version: Version,\n         }\n \n         impl<'a> Parser<'a> {\n@@ -1028,34 +1124,40 @@ mod test {\n             }\n \n             fn push_segment(\n+                &self,\n                 result: &mut Vec<UseSegment>,\n                 buf: &mut String,\n                 alias_buf: &mut Option<String>,\n             ) {\n+                let version = self.version;\n                 if !buf.is_empty() {\n                     let mut alias = None;\n                     swap(alias_buf, &mut alias);\n \n                     match buf.as_ref() {\n                         \"self\" => {\n-                            result.push(UseSegment::Slf(alias));\n+                            let kind = UseSegmentKind::Slf(alias);\n+                            result.push(UseSegment { kind, version });\n                             *buf = String::new();\n                             *alias_buf = None;\n                         }\n                         \"super\" => {\n-                            result.push(UseSegment::Super(alias));\n+                            let kind = UseSegmentKind::Super(alias);\n+                            result.push(UseSegment { kind, version });\n                             *buf = String::new();\n                             *alias_buf = None;\n                         }\n                         \"crate\" => {\n-                            result.push(UseSegment::Crate(alias));\n+                            let kind = UseSegmentKind::Crate(alias);\n+                            result.push(UseSegment { kind, version });\n                             *buf = String::new();\n                             *alias_buf = None;\n                         }\n                         _ => {\n                             let mut name = String::new();\n                             swap(buf, &mut name);\n-                            result.push(UseSegment::Ident(name, alias));\n+                            let kind = UseSegmentKind::Ident(name, alias);\n+                            result.push(UseSegment { kind, version });\n                         }\n                     }\n                 }\n@@ -1070,21 +1172,29 @@ mod test {\n                         '{' => {\n                             assert!(buf.is_empty());\n                             self.bump();\n-                            result.push(UseSegment::List(self.parse_list()));\n+                            let kind = UseSegmentKind::List(self.parse_list());\n+                            result.push(UseSegment {\n+                                kind,\n+                                version: self.version,\n+                            });\n                             self.eat('}');\n                         }\n                         '*' => {\n                             assert!(buf.is_empty());\n                             self.bump();\n-                            result.push(UseSegment::Glob);\n+                            let kind = UseSegmentKind::Glob;\n+                            result.push(UseSegment {\n+                                kind,\n+                                version: self.version,\n+                            });\n                         }\n                         ':' => {\n                             self.bump();\n                             self.eat(':');\n-                            Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                            self.push_segment(&mut result, &mut buf, &mut alias_buf);\n                         }\n                         '}' | ',' => {\n-                            Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                            self.push_segment(&mut result, &mut buf, &mut alias_buf);\n                             return UseTree {\n                                 path: result,\n                                 span: DUMMY_SP,\n@@ -1110,7 +1220,7 @@ mod test {\n                         }\n                     }\n                 }\n-                Self::push_segment(&mut result, &mut buf, &mut alias_buf);\n+                self.push_segment(&mut result, &mut buf, &mut alias_buf);\n                 UseTree {\n                     path: result,\n                     span: DUMMY_SP,\n@@ -1136,6 +1246,7 @@ mod test {\n \n         let mut parser = Parser {\n             input: s.chars().peekable(),\n+            version: Version::One,\n         };\n         parser.parse_in_list()\n     }"}, {"sha": "9e4a668aa49301319ace07e9bb21dad53d4b3393", "filename": "src/reorder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -12,7 +12,7 @@ use rustc_ast::ast;\n use rustc_span::{symbol::sym, Span};\n \n use crate::config::{Config, GroupImportsTactic};\n-use crate::imports::{normalize_use_trees_with_granularity, UseSegment, UseTree};\n+use crate::imports::{normalize_use_trees_with_granularity, UseSegmentKind, UseTree};\n use crate::items::{is_mod_decl, rewrite_extern_crate, rewrite_mod};\n use crate::lists::{itemize_list, write_list, ListFormatting, ListItem};\n use crate::rewrite::RewriteContext;\n@@ -182,16 +182,16 @@ fn group_imports(uts: Vec<UseTree>) -> Vec<Vec<UseTree>> {\n             external_imports.push(ut);\n             continue;\n         }\n-        match &ut.path[0] {\n-            UseSegment::Ident(id, _) => match id.as_ref() {\n+        match &ut.path[0].kind {\n+            UseSegmentKind::Ident(id, _) => match id.as_ref() {\n                 \"std\" | \"alloc\" | \"core\" => std_imports.push(ut),\n                 _ => external_imports.push(ut),\n             },\n-            UseSegment::Slf(_) | UseSegment::Super(_) | UseSegment::Crate(_) => {\n+            UseSegmentKind::Slf(_) | UseSegmentKind::Super(_) | UseSegmentKind::Crate(_) => {\n                 local_imports.push(ut)\n             }\n             // These are probably illegal here\n-            UseSegment::Glob | UseSegment::List(_) => external_imports.push(ut),\n+            UseSegmentKind::Glob | UseSegmentKind::List(_) => external_imports.push(ut),\n         }\n     }\n "}, {"sha": "4a3bd129d16f5ad62b017f0ba277c87c8a80968d", "filename": "src/rewrite.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -12,7 +12,6 @@ use crate::shape::Shape;\n use crate::skip::SkipContext;\n use crate::visitor::SnippetProvider;\n use crate::FormatReport;\n-use rustc_data_structures::stable_map::FxHashMap;\n \n pub(crate) trait Rewrite {\n     /// Rewrite self into shape.\n@@ -25,22 +24,10 @@ impl<T: Rewrite> Rewrite for ptr::P<T> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash)]\n-pub(crate) struct QueryId {\n-    pub(crate) shape: Shape,\n-    pub(crate) span: Span,\n-}\n-\n-// We use Option<HashMap> instead of HashMap, because in case of `None`\n-// the function clean the memoize map, but it doesn't clean when\n-// there is `Some(empty)`, so they are different.\n-pub(crate) type Memoize = Rc<Cell<Option<FxHashMap<QueryId, Option<String>>>>>;\n-\n #[derive(Clone)]\n pub(crate) struct RewriteContext<'a> {\n     pub(crate) parse_sess: &'a ParseSess,\n     pub(crate) config: &'a Config,\n-    pub(crate) memoize: Memoize,\n     pub(crate) inside_macro: Rc<Cell<bool>>,\n     // Force block indent style even if we are using visual indent style.\n     pub(crate) use_block: Cell<bool>,"}, {"sha": "4376fd12b526005706f526bcc3252446f8cf74c0", "filename": "src/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshape.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -4,7 +4,7 @@ use std::ops::{Add, Sub};\n \n use crate::Config;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug)]\n pub(crate) struct Indent {\n     // Width of the block indent, in characters. Must be a multiple of\n     // Config::tab_spaces.\n@@ -139,7 +139,7 @@ impl Sub<usize> for Indent {\n // 8096 is close enough to infinite for rustfmt.\n const INFINITE_SHAPE_WIDTH: usize = 8096;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug)]\n pub(crate) struct Shape {\n     pub(crate) width: usize,\n     // The current indentation of code."}, {"sha": "9a0e0752c12f5ed3ec755a389ac1cd696a647fd5", "filename": "src/visitor.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -17,7 +17,7 @@ use crate::items::{\n use crate::macros::{macro_style, rewrite_macro, rewrite_macro_def, MacroPosition};\n use crate::modules::Module;\n use crate::parse::session::ParseSess;\n-use crate::rewrite::{Memoize, Rewrite, RewriteContext};\n+use crate::rewrite::{Rewrite, RewriteContext};\n use crate::shape::{Indent, Shape};\n use crate::skip::{is_skip_attr, SkipContext};\n use crate::source_map::{LineRangeUtils, SpanUtils};\n@@ -71,7 +71,6 @@ impl SnippetProvider {\n \n pub(crate) struct FmtVisitor<'a> {\n     parent_context: Option<&'a RewriteContext<'a>>,\n-    pub(crate) memoize: Memoize,\n     pub(crate) parse_sess: &'a ParseSess,\n     pub(crate) buffer: String,\n     pub(crate) last_pos: BytePos,\n@@ -759,7 +758,6 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             ctx.config,\n             ctx.snippet_provider,\n             ctx.report.clone(),\n-            ctx.memoize.clone(),\n         );\n         visitor.skip_context.update(ctx.skip_context.clone());\n         visitor.set_parent_context(ctx);\n@@ -771,12 +769,10 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         config: &'a Config,\n         snippet_provider: &'a SnippetProvider,\n         report: FormatReport,\n-        memoize: Memoize,\n     ) -> FmtVisitor<'a> {\n         FmtVisitor {\n             parent_context: None,\n             parse_sess: parse_session,\n-            memoize,\n             buffer: String::with_capacity(snippet_provider.big_snippet.len() * 2),\n             last_pos: BytePos(0),\n             block_indent: Indent::empty(),\n@@ -999,7 +995,6 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         RewriteContext {\n             parse_sess: self.parse_sess,\n             config: self.config,\n-            memoize: self.memoize.clone(),\n             inside_macro: Rc::new(Cell::new(false)),\n             use_block: Cell::new(false),\n             is_if_else_block: Cell::new(false),"}, {"sha": "515780761670c1049a3f1249d4cf48fe2fce9786", "filename": "tests/source/configs/doc_comment_code_block_width/100.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F100.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -0,0 +1,16 @@\n+// rustfmt-format_code_in_doc_comments: true\n+// rustfmt-doc_comment_code_block_width: 100\n+\n+/// ```rust\n+/// impl Test {\n+///     pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+///         Self::from_bytes_manual_slice(v, 0, v.len()      )\n+///     }\n+/// }\n+/// ```\n+\n+impl Test {\n+    pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+        Self::from_bytes_manual_slice(v, 0, v.len()       )\n+    }\n+}"}, {"sha": "96505c69714e5ce570a1efae27e01ae7db5154ac", "filename": "tests/source/configs/doc_comment_code_block_width/100_greater_max_width.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F100_greater_max_width.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F100_greater_max_width.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F100_greater_max_width.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -0,0 +1,17 @@\n+// rustfmt-max_width: 50\n+// rustfmt-format_code_in_doc_comments: true\n+// rustfmt-doc_comment_code_block_width: 100\n+\n+/// ```rust\n+/// impl Test {\n+///     pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+///         Self::from_bytes_manual_slice(v, 0, v.len()      )\n+///     }\n+/// }\n+/// ```\n+\n+impl Test {\n+    pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+        Self::from_bytes_manual_slice(v, 0, v.len()       )\n+    }\n+}"}, {"sha": "2c6307951c84eee5bfacb23a6e2daf64d6a62a85", "filename": "tests/source/configs/doc_comment_code_block_width/50.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F50.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F50.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs%2Fdoc_comment_code_block_width%2F50.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -0,0 +1,16 @@\n+// rustfmt-format_code_in_doc_comments: true\n+// rustfmt-doc_comment_code_block_width: 50\n+\n+/// ```rust\n+/// impl Test {\n+///     pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+///         Self::from_bytes_manual_slice(v, 0, v.len()      )\n+///     }\n+/// }\n+/// ```\n+\n+impl Test {\n+    pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+        Self::from_bytes_manual_slice(v, 0, v.len()       )\n+    }\n+}"}, {"sha": "bc4b5b135696a9791f8e1cef8b4853496e55f008", "filename": "tests/source/imports_raw_identifiers/version_One.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Fsource%2Fimports_raw_identifiers%2Fversion_One.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Fsource%2Fimports_raw_identifiers%2Fversion_One.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fimports_raw_identifiers%2Fversion_One.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -0,0 +1,5 @@\n+// rustfmt-version:One\n+\n+use websocket::client::ClientBuilder;\n+use websocket::r#async::futures::Stream;\n+use websocket::result::WebSocketError;"}, {"sha": "88e7fbd01ca6e5b9b0c750bab1a47c1b0566a921", "filename": "tests/source/imports_raw_identifiers/version_Two.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Fsource%2Fimports_raw_identifiers%2Fversion_Two.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Fsource%2Fimports_raw_identifiers%2Fversion_Two.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fimports_raw_identifiers%2Fversion_Two.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -0,0 +1,5 @@\n+// rustfmt-version:Two\n+\n+use websocket::client::ClientBuilder;\n+use websocket::r#async::futures::Stream;\n+use websocket::result::WebSocketError;"}, {"sha": "8da3f19b62d6004b3faf6439f65dec1bc07a0b7d", "filename": "tests/source/performance/issue-4476.rs", "status": "removed", "additions": 0, "deletions": 638, "changes": 638, "blob_url": "https://github.com/rust-lang/rust/blob/ac2b7a261c94d2d7d718bede54fc93c7f2fdd641/tests%2Fsource%2Fperformance%2Fissue-4476.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2b7a261c94d2d7d718bede54fc93c7f2fdd641/tests%2Fsource%2Fperformance%2Fissue-4476.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fperformance%2Fissue-4476.rs?ref=ac2b7a261c94d2d7d718bede54fc93c7f2fdd641", "patch": "@@ -1,638 +0,0 @@\n-use super::SemverParser;\n-\n-#[allow(dead_code, non_camel_case_types)]\n-#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n-pub enum Rule {\n-  EOI,\n-  range_set,\n-  logical_or,\n-  range,\n-  empty,\n-  hyphen,\n-  simple,\n-  primitive,\n-  primitive_op,\n-  partial,\n-  xr,\n-  xr_op,\n-  nr,\n-  tilde,\n-  caret,\n-  qualifier,\n-  parts,\n-  part,\n-  space,\n-}\n-#[allow(clippy::all)]\n-impl ::pest::Parser<Rule> for SemverParser {\n-  fn parse<'i>(\n-    rule: Rule,\n-    input: &'i str,\n-  ) -> ::std::result::Result<::pest::iterators::Pairs<'i, Rule>, ::pest::error::Error<Rule>> {\n-    mod rules {\n-      pub mod hidden {\n-        use super::super::Rule;\n-        #[inline]\n-        #[allow(dead_code, non_snake_case, unused_variables)]\n-        pub fn skip(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          Ok(state)\n-        }\n-      }\n-      pub mod visible {\n-        use super::super::Rule;\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn range_set(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::range_set, |state| {\n-            state.sequence(|state| {\n-              self::SOI(state)\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      self::space(state).and_then(|state| {\n-                        state.repeat(|state| {\n-                          state.sequence(|state| {\n-                            super::hidden::skip(state).and_then(|state| self::space(state))\n-                          })\n-                        })\n-                      })\n-                    })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| self::range(state))\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      state\n-                        .sequence(|state| {\n-                          self::logical_or(state)\n-                            .and_then(|state| super::hidden::skip(state))\n-                            .and_then(|state| self::range(state))\n-                        })\n-                        .and_then(|state| {\n-                          state.repeat(|state| {\n-                            state.sequence(|state| {\n-                              super::hidden::skip(state).and_then(|state| {\n-                                state.sequence(|state| {\n-                                  self::logical_or(state)\n-                                    .and_then(|state| super::hidden::skip(state))\n-                                    .and_then(|state| self::range(state))\n-                                })\n-                              })\n-                            })\n-                          })\n-                        })\n-                    })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      self::space(state).and_then(|state| {\n-                        state.repeat(|state| {\n-                          state.sequence(|state| {\n-                            super::hidden::skip(state).and_then(|state| self::space(state))\n-                          })\n-                        })\n-                      })\n-                    })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| self::EOI(state))\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn logical_or(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::logical_or, |state| {\n-            state.sequence(|state| {\n-              state\n-                .sequence(|state| {\n-                  state.optional(|state| {\n-                    self::space(state).and_then(|state| {\n-                      state.repeat(|state| {\n-                        state.sequence(|state| {\n-                          super::hidden::skip(state).and_then(|state| self::space(state))\n-                        })\n-                      })\n-                    })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| state.match_string(\"||\"))\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      self::space(state).and_then(|state| {\n-                        state.repeat(|state| {\n-                          state.sequence(|state| {\n-                            super::hidden::skip(state).and_then(|state| self::space(state))\n-                          })\n-                        })\n-                      })\n-                    })\n-                  })\n-                })\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn range(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::range, |state| {\n-            self::hyphen(state)\n-              .or_else(|state| {\n-                state.sequence(|state| {\n-                  self::simple(state)\n-                    .and_then(|state| super::hidden::skip(state))\n-                    .and_then(|state| {\n-                      state.sequence(|state| {\n-                        state.optional(|state| {\n-                          state\n-                            .sequence(|state| {\n-                              state\n-                                .optional(|state| state.match_string(\",\"))\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                  state.sequence(|state| {\n-                                    self::space(state)\n-                                      .and_then(|state| super::hidden::skip(state))\n-                                      .and_then(|state| {\n-                                        state.sequence(|state| {\n-                                          state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                              state.repeat(|state| {\n-                                                state.sequence(|state| {\n-                                                  super::hidden::skip(state)\n-                                                    .and_then(|state| self::space(state))\n-                                                })\n-                                              })\n-                                            })\n-                                          })\n-                                        })\n-                                      })\n-                                  })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::simple(state))\n-                            })\n-                            .and_then(|state| {\n-                              state.repeat(|state| {\n-                                state.sequence(|state| {\n-                                  super::hidden::skip(state).and_then(|state| {\n-                                    state.sequence(|state| {\n-                                      state\n-                                        .optional(|state| state.match_string(\",\"))\n-                                        .and_then(|state| super::hidden::skip(state))\n-                                        .and_then(|state| {\n-                                          state.sequence(|state| {\n-                                            self::space(state)\n-                                              .and_then(|state| super::hidden::skip(state))\n-                                              .and_then(|state| {\n-                                                state.sequence(|state| {\n-                                                  state.optional(|state| {\n-                                                    self::space(state).and_then(|state| {\n-                                                      state.repeat(|state| {\n-                                                        state.sequence(|state| {\n-                                                          super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                        })\n-                                                      })\n-                                                    })\n-                                                  })\n-                                                })\n-                                              })\n-                                          })\n-                                        })\n-                                        .and_then(|state| super::hidden::skip(state))\n-                                        .and_then(|state| self::simple(state))\n-                                    })\n-                                  })\n-                                })\n-                              })\n-                            })\n-                        })\n-                      })\n-                    })\n-                })\n-              })\n-              .or_else(|state| self::empty(state))\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn empty(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::empty, |state| state.match_string(\"\"))\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn hyphen(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::hyphen, |state| {\n-            state.sequence(|state| {\n-              self::partial(state)\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    self::space(state)\n-                      .and_then(|state| super::hidden::skip(state))\n-                      .and_then(|state| {\n-                        state.sequence(|state| {\n-                          state.optional(|state| {\n-                            self::space(state).and_then(|state| {\n-                              state.repeat(|state| {\n-                                state.sequence(|state| {\n-                                  super::hidden::skip(state).and_then(|state| self::space(state))\n-                                })\n-                              })\n-                            })\n-                          })\n-                        })\n-                      })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| state.match_string(\"-\"))\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    self::space(state)\n-                      .and_then(|state| super::hidden::skip(state))\n-                      .and_then(|state| {\n-                        state.sequence(|state| {\n-                          state.optional(|state| {\n-                            self::space(state).and_then(|state| {\n-                              state.repeat(|state| {\n-                                state.sequence(|state| {\n-                                  super::hidden::skip(state).and_then(|state| self::space(state))\n-                                })\n-                              })\n-                            })\n-                          })\n-                        })\n-                      })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| self::partial(state))\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn simple(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::simple, |state| {\n-            self::primitive(state)\n-              .or_else(|state| self::partial(state))\n-              .or_else(|state| self::tilde(state))\n-              .or_else(|state| self::caret(state))\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn primitive(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::primitive, |state| {\n-            state.sequence(|state| {\n-              self::primitive_op(state)\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      self::space(state).and_then(|state| {\n-                        state.repeat(|state| {\n-                          state.sequence(|state| {\n-                            super::hidden::skip(state).and_then(|state| self::space(state))\n-                          })\n-                        })\n-                      })\n-                    })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| self::partial(state))\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn primitive_op(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::primitive_op, |state| {\n-            state\n-              .match_string(\"<=\")\n-              .or_else(|state| state.match_string(\">=\"))\n-              .or_else(|state| state.match_string(\">\"))\n-              .or_else(|state| state.match_string(\"<\"))\n-              .or_else(|state| state.match_string(\"=\"))\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn partial(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::partial, |state| {\n-            state.sequence(|state| {\n-              self::xr(state)\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.optional(|state| {\n-                    state.sequence(|state| {\n-                      state\n-                        .match_string(\".\")\n-                        .and_then(|state| super::hidden::skip(state))\n-                        .and_then(|state| self::xr(state))\n-                        .and_then(|state| super::hidden::skip(state))\n-                        .and_then(|state| {\n-                          state.optional(|state| {\n-                            state.sequence(|state| {\n-                              state\n-                                .match_string(\".\")\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::xr(state))\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| state.optional(|state| self::qualifier(state)))\n-                            })\n-                          })\n-                        })\n-                    })\n-                  })\n-                })\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn xr(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::xr, |state| {\n-            self::xr_op(state).or_else(|state| self::nr(state))\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn xr_op(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::xr_op, |state| {\n-            state\n-              .match_string(\"x\")\n-              .or_else(|state| state.match_string(\"X\"))\n-              .or_else(|state| state.match_string(\"*\"))\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn nr(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::nr, |state| {\n-            state.match_string(\"0\").or_else(|state| {\n-              state.sequence(|state| {\n-                state\n-                  .match_range('1'..'9')\n-                  .and_then(|state| super::hidden::skip(state))\n-                  .and_then(|state| {\n-                    state.sequence(|state| {\n-                      state.optional(|state| {\n-                        state.match_range('0'..'9').and_then(|state| {\n-                          state.repeat(|state| {\n-                            state.sequence(|state| {\n-                              super::hidden::skip(state)\n-                                .and_then(|state| state.match_range('0'..'9'))\n-                            })\n-                          })\n-                        })\n-                      })\n-                    })\n-                  })\n-              })\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn tilde(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::tilde, |state| {\n-            state.sequence(|state| {\n-              state\n-                .match_string(\"~>\")\n-                .or_else(|state| state.match_string(\"~\"))\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      self::space(state).and_then(|state| {\n-                        state.repeat(|state| {\n-                          state.sequence(|state| {\n-                            super::hidden::skip(state).and_then(|state| self::space(state))\n-                          })\n-                        })\n-                      })\n-                    })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| self::partial(state))\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn caret(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::caret, |state| {\n-            state.sequence(|state| {\n-              state\n-                .match_string(\"^\")\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      self::space(state).and_then(|state| {\n-                        state.repeat(|state| {\n-                          state.sequence(|state| {\n-                            super::hidden::skip(state).and_then(|state| self::space(state))\n-                          })\n-                        })\n-                      })\n-                    })\n-                  })\n-                })\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| self::partial(state))\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn qualifier(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::qualifier, |state| {\n-            state.sequence(|state| {\n-              state\n-                .match_string(\"-\")\n-                .or_else(|state| state.match_string(\"+\"))\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| self::parts(state))\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn parts(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::parts, |state| {\n-            state.sequence(|state| {\n-              self::part(state)\n-                .and_then(|state| super::hidden::skip(state))\n-                .and_then(|state| {\n-                  state.sequence(|state| {\n-                    state.optional(|state| {\n-                      state\n-                        .sequence(|state| {\n-                          state\n-                            .match_string(\".\")\n-                            .and_then(|state| super::hidden::skip(state))\n-                            .and_then(|state| self::part(state))\n-                        })\n-                        .and_then(|state| {\n-                          state.repeat(|state| {\n-                            state.sequence(|state| {\n-                              super::hidden::skip(state).and_then(|state| {\n-                                state.sequence(|state| {\n-                                  state\n-                                    .match_string(\".\")\n-                                    .and_then(|state| super::hidden::skip(state))\n-                                    .and_then(|state| self::part(state))\n-                                })\n-                              })\n-                            })\n-                          })\n-                        })\n-                    })\n-                  })\n-                })\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn part(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::part, |state| {\n-            self::nr(state).or_else(|state| {\n-              state.sequence(|state| {\n-                state\n-                  .match_string(\"-\")\n-                  .or_else(|state| state.match_range('0'..'9'))\n-                  .or_else(|state| state.match_range('A'..'Z'))\n-                  .or_else(|state| state.match_range('a'..'z'))\n-                  .and_then(|state| super::hidden::skip(state))\n-                  .and_then(|state| {\n-                    state.sequence(|state| {\n-                      state.optional(|state| {\n-                        state\n-                          .match_string(\"-\")\n-                          .or_else(|state| state.match_range('0'..'9'))\n-                          .or_else(|state| state.match_range('A'..'Z'))\n-                          .or_else(|state| state.match_range('a'..'z'))\n-                          .and_then(|state| {\n-                            state.repeat(|state| {\n-                              state.sequence(|state| {\n-                                super::hidden::skip(state).and_then(|state| {\n-                                  state\n-                                    .match_string(\"-\")\n-                                    .or_else(|state| state.match_range('0'..'9'))\n-                                    .or_else(|state| state.match_range('A'..'Z'))\n-                                    .or_else(|state| state.match_range('a'..'z'))\n-                                })\n-                              })\n-                            })\n-                          })\n-                      })\n-                    })\n-                  })\n-              })\n-            })\n-          })\n-        }\n-        #[inline]\n-        #[allow(non_snake_case, unused_variables)]\n-        pub fn space(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state\n-            .match_string(\" \")\n-            .or_else(|state| state.match_string(\"\\t\"))\n-        }\n-        #[inline]\n-        #[allow(dead_code, non_snake_case, unused_variables)]\n-        pub fn EOI(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.rule(Rule::EOI, |state| state.end_of_input())\n-        }\n-        #[inline]\n-        #[allow(dead_code, non_snake_case, unused_variables)]\n-        pub fn SOI(\n-          state: Box<::pest::ParserState<Rule>>,\n-        ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-          state.start_of_input()\n-        }\n-      }\n-      pub use self::visible::*;\n-    }\n-    ::pest::state(input, |state| match rule {\n-      Rule::range_set => rules::range_set(state),\n-      Rule::logical_or => rules::logical_or(state),\n-      Rule::range => rules::range(state),\n-      Rule::empty => rules::empty(state),\n-      Rule::hyphen => rules::hyphen(state),\n-      Rule::simple => rules::simple(state),\n-      Rule::primitive => rules::primitive(state),\n-      Rule::primitive_op => rules::primitive_op(state),\n-      Rule::partial => rules::partial(state),\n-      Rule::xr => rules::xr(state),\n-      Rule::xr_op => rules::xr_op(state),\n-      Rule::nr => rules::nr(state),\n-      Rule::tilde => rules::tilde(state),\n-      Rule::caret => rules::caret(state),\n-      Rule::qualifier => rules::qualifier(state),\n-      Rule::parts => rules::parts(state),\n-      Rule::part => rules::part(state),\n-      Rule::space => rules::space(state),\n-      Rule::EOI => rules::EOI(state),\n-    })\n-  }\n-}\n\\ No newline at end of file"}, {"sha": "3adce49601c0ca0805daed8cba5dc8e7edcf118e", "filename": "tests/source/performance/issue-5128.rs", "status": "removed", "additions": 0, "deletions": 5127, "changes": 5127, "blob_url": "https://github.com/rust-lang/rust/blob/ac2b7a261c94d2d7d718bede54fc93c7f2fdd641/tests%2Fsource%2Fperformance%2Fissue-5128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2b7a261c94d2d7d718bede54fc93c7f2fdd641/tests%2Fsource%2Fperformance%2Fissue-5128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fperformance%2Fissue-5128.rs?ref=ac2b7a261c94d2d7d718bede54fc93c7f2fdd641"}, {"sha": "c010a28aab61550bffcfc2637c1f199c3d1fc913", "filename": "tests/target/configs/doc_comment_code_block_width/100.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F100.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -0,0 +1,16 @@\n+// rustfmt-format_code_in_doc_comments: true\n+// rustfmt-doc_comment_code_block_width: 100\n+\n+/// ```rust\n+/// impl Test {\n+///     pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+///         Self::from_bytes_manual_slice(v, 0, v.len())\n+///     }\n+/// }\n+/// ```\n+\n+impl Test {\n+    pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+        Self::from_bytes_manual_slice(v, 0, v.len())\n+    }\n+}"}, {"sha": "6bcb99b915ff958c10477a38bfa3578eeca9bda7", "filename": "tests/target/configs/doc_comment_code_block_width/100_greater_max_width.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F100_greater_max_width.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F100_greater_max_width.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F100_greater_max_width.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -0,0 +1,29 @@\n+// rustfmt-max_width: 50\n+// rustfmt-format_code_in_doc_comments: true\n+// rustfmt-doc_comment_code_block_width: 100\n+\n+/// ```rust\n+/// impl Test {\n+///     pub const fn from_bytes(\n+///         v: &[u8],\n+///     ) -> Result<Self, ParserError> {\n+///         Self::from_bytes_manual_slice(\n+///             v,\n+///             0,\n+///             v.len(),\n+///         )\n+///     }\n+/// }\n+/// ```\n+\n+impl Test {\n+    pub const fn from_bytes(\n+        v: &[u8],\n+    ) -> Result<Self, ParserError> {\n+        Self::from_bytes_manual_slice(\n+            v,\n+            0,\n+            v.len(),\n+        )\n+    }\n+}"}, {"sha": "e8ab6f28bdc5ab4b88e5a617eced4492ffb4466a", "filename": "tests/target/configs/doc_comment_code_block_width/50.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F50.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F50.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs%2Fdoc_comment_code_block_width%2F50.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -0,0 +1,22 @@\n+// rustfmt-format_code_in_doc_comments: true\n+// rustfmt-doc_comment_code_block_width: 50\n+\n+/// ```rust\n+/// impl Test {\n+///     pub const fn from_bytes(\n+///         v: &[u8],\n+///     ) -> Result<Self, ParserError> {\n+///         Self::from_bytes_manual_slice(\n+///             v,\n+///             0,\n+///             v.len(),\n+///         )\n+///     }\n+/// }\n+/// ```\n+\n+impl Test {\n+    pub const fn from_bytes(v: &[u8]) -> Result<Self, ParserError> {\n+        Self::from_bytes_manual_slice(v, 0, v.len())\n+    }\n+}"}, {"sha": "bc4b5b135696a9791f8e1cef8b4853496e55f008", "filename": "tests/target/imports_raw_identifiers/version_One.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Ftarget%2Fimports_raw_identifiers%2Fversion_One.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Ftarget%2Fimports_raw_identifiers%2Fversion_One.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports_raw_identifiers%2Fversion_One.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -0,0 +1,5 @@\n+// rustfmt-version:One\n+\n+use websocket::client::ClientBuilder;\n+use websocket::r#async::futures::Stream;\n+use websocket::result::WebSocketError;"}, {"sha": "22bfe93122f95aa383c9fd6dab7d4ea1f9247bcb", "filename": "tests/target/imports_raw_identifiers/version_Two.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Ftarget%2Fimports_raw_identifiers%2Fversion_Two.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Ftarget%2Fimports_raw_identifiers%2Fversion_Two.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports_raw_identifiers%2Fversion_Two.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -0,0 +1,5 @@\n+// rustfmt-version:Two\n+\n+use websocket::r#async::futures::Stream;\n+use websocket::client::ClientBuilder;\n+use websocket::result::WebSocketError;"}, {"sha": "17364c38919a2696f426d97dd2d19e7b12cd8390", "filename": "tests/target/issue_5399.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Ftarget%2Fissue_5399.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac595dd57a151a16a168e6596404ada8f079b778/tests%2Ftarget%2Fissue_5399.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue_5399.rs?ref=ac595dd57a151a16a168e6596404ada8f079b778", "patch": "@@ -0,0 +1,48 @@\n+// rustfmt-max_width: 140\n+\n+impl NotificationRepository {\n+    fn set_status_changed(\n+        &self,\n+        repo_tx_conn: &RepoTxConn,\n+        rid: &RoutableId,\n+        changed_at: NaiveDateTime,\n+    ) -> NukeResult<Option<NotificationStatus>> {\n+        repo_tx_conn.run(move |conn| {\n+            let res = diesel::update(client_notification::table)\n+                .filter(\n+                    client_notification::routable_id.eq(DieselRoutableId(rid.clone())).and(\n+                        client_notification::changed_at\n+                            .lt(changed_at)\n+                            .or(client_notification::changed_at.is_null()),\n+                    ),\n+                )\n+                .set(client_notification::changed_at.eq(changed_at))\n+                .returning((\n+                    client_notification::id,\n+                    client_notification::changed_at,\n+                    client_notification::polled_at,\n+                    client_notification::notified_at,\n+                ))\n+                .get_result::<(Uuid, Option<NaiveDateTime>, Option<NaiveDateTime>, Option<NaiveDateTime>)>(conn)\n+                .optional()?;\n+\n+            match res {\n+                Some(row) => {\n+                    let client_id = client_contract::table\n+                        .inner_join(client_notification::table)\n+                        .filter(client_notification::id.eq(row.0))\n+                        .select(client_contract::client_id)\n+                        .get_result::<Uuid>(conn)?;\n+\n+                    Ok(Some(NotificationStatus {\n+                        client_id: client_id.into(),\n+                        changed_at: row.1,\n+                        polled_at: row.2,\n+                        notified_at: row.3,\n+                    }))\n+                }\n+                None => Ok(None),\n+            }\n+        })\n+    }\n+}"}, {"sha": "30567f2644b749bb019da54f7b36f938c8fcd78e", "filename": "tests/target/performance/issue-4476.rs", "status": "removed", "additions": 0, "deletions": 705, "changes": 705, "blob_url": "https://github.com/rust-lang/rust/blob/ac2b7a261c94d2d7d718bede54fc93c7f2fdd641/tests%2Ftarget%2Fperformance%2Fissue-4476.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2b7a261c94d2d7d718bede54fc93c7f2fdd641/tests%2Ftarget%2Fperformance%2Fissue-4476.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fperformance%2Fissue-4476.rs?ref=ac2b7a261c94d2d7d718bede54fc93c7f2fdd641", "patch": "@@ -1,705 +0,0 @@\n-use super::SemverParser;\n-\n-#[allow(dead_code, non_camel_case_types)]\n-#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n-pub enum Rule {\n-    EOI,\n-    range_set,\n-    logical_or,\n-    range,\n-    empty,\n-    hyphen,\n-    simple,\n-    primitive,\n-    primitive_op,\n-    partial,\n-    xr,\n-    xr_op,\n-    nr,\n-    tilde,\n-    caret,\n-    qualifier,\n-    parts,\n-    part,\n-    space,\n-}\n-#[allow(clippy::all)]\n-impl ::pest::Parser<Rule> for SemverParser {\n-    fn parse<'i>(\n-        rule: Rule,\n-        input: &'i str,\n-    ) -> ::std::result::Result<::pest::iterators::Pairs<'i, Rule>, ::pest::error::Error<Rule>> {\n-        mod rules {\n-            pub mod hidden {\n-                use super::super::Rule;\n-                #[inline]\n-                #[allow(dead_code, non_snake_case, unused_variables)]\n-                pub fn skip(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    Ok(state)\n-                }\n-            }\n-            pub mod visible {\n-                use super::super::Rule;\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn range_set(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::range_set, |state| {\n-                        state.sequence(|state| {\n-                            self::SOI(state)\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                                state.repeat(|state| {\n-                                                    state.sequence(|state| {\n-                                                        super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                    })\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::range(state))\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            state\n-                                                .sequence(|state| {\n-                                                    self::logical_or(state)\n-                                                        .and_then(|state| {\n-                                                            super::hidden::skip(state)\n-                                                        })\n-                                                        .and_then(|state| self::range(state))\n-                                                })\n-                                                .and_then(|state| {\n-                                                    state.repeat(|state| {\n-                                                        state.sequence(|state| {\n-                                                            super::hidden::skip(state).and_then(\n-                                                                |state| {\n-                                                                    state.sequence(|state| {\n-                                                                        self::logical_or(state)\n-                                                                            .and_then(|state| {\n-                                                                                super::hidden::skip(\n-                                                                                    state,\n-                                                                                )\n-                                                                            })\n-                                                                            .and_then(|state| {\n-                                                                                self::range(state)\n-                                                                            })\n-                                                                    })\n-                                                                },\n-                                                            )\n-                                                        })\n-                                                    })\n-                                                })\n-                                        })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                                state.repeat(|state| {\n-                                                    state.sequence(|state| {\n-                                                        super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                    })\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::EOI(state))\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn logical_or(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::logical_or, |state| {\n-                        state.sequence(|state| {\n-                            state\n-                                .sequence(|state| {\n-                                    state.optional(|state| {\n-                                        self::space(state).and_then(|state| {\n-                                            state.repeat(|state| {\n-                                                state.sequence(|state| {\n-                                                    super::hidden::skip(state)\n-                                                        .and_then(|state| self::space(state))\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| state.match_string(\"||\"))\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                                state.repeat(|state| {\n-                                                    state.sequence(|state| {\n-                                                        super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                    })\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                                })\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn range(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::range, |state| {\n-                        self::hyphen(state)\n-                            .or_else(|state| {\n-                                state.sequence(|state| {\n-                                    self::simple(state)\n-                                        .and_then(|state| super::hidden::skip(state))\n-                                        .and_then(|state| {\n-                                            state.sequence(|state| {\n-                                                state.optional(|state| {\n-                                                    state\n-                                                        .sequence(|state| {\n-                                                            state\n-                                                                .optional(|state| {\n-                                                                    state.match_string(\",\")\n-                                                                })\n-                                                                .and_then(|state| {\n-                                                                    super::hidden::skip(state)\n-                                                                })\n-                                                                .and_then(|state| {\n-                                                                    state.sequence(|state| {\n-                                                                        self::space(state)\n-                                      .and_then(|state| super::hidden::skip(state))\n-                                      .and_then(|state| {\n-                                        state.sequence(|state| {\n-                                          state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                              state.repeat(|state| {\n-                                                state.sequence(|state| {\n-                                                  super::hidden::skip(state)\n-                                                    .and_then(|state| self::space(state))\n-                                                })\n-                                              })\n-                                            })\n-                                          })\n-                                        })\n-                                      })\n-                                                                    })\n-                                                                })\n-                                                                .and_then(|state| {\n-                                                                    super::hidden::skip(state)\n-                                                                })\n-                                                                .and_then(|state| {\n-                                                                    self::simple(state)\n-                                                                })\n-                                                        })\n-                                                        .and_then(|state| {\n-                                                            state.repeat(|state| {\n-                                                                state.sequence(|state| {\n-                                                                    super::hidden::skip(state)\n-                                                                        .and_then(|state| {\n-                                                                            state.sequence(\n-                                                                                |state| {\n-                                                                                    state\n-                                        .optional(|state| state.match_string(\",\"))\n-                                        .and_then(|state| super::hidden::skip(state))\n-                                        .and_then(|state| {\n-                                          state.sequence(|state| {\n-                                            self::space(state)\n-                                              .and_then(|state| super::hidden::skip(state))\n-                                              .and_then(|state| {\n-                                                state.sequence(|state| {\n-                                                  state.optional(|state| {\n-                                                    self::space(state).and_then(|state| {\n-                                                      state.repeat(|state| {\n-                                                        state.sequence(|state| {\n-                                                          super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                        })\n-                                                      })\n-                                                    })\n-                                                  })\n-                                                })\n-                                              })\n-                                          })\n-                                        })\n-                                        .and_then(|state| super::hidden::skip(state))\n-                                        .and_then(|state| self::simple(state))\n-                                                                                },\n-                                                                            )\n-                                                                        })\n-                                                                })\n-                                                            })\n-                                                        })\n-                                                })\n-                                            })\n-                                        })\n-                                })\n-                            })\n-                            .or_else(|state| self::empty(state))\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn empty(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::empty, |state| state.match_string(\"\"))\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn hyphen(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::hyphen, |state| {\n-                        state.sequence(|state| {\n-                            self::partial(state)\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        self::space(state)\n-                                            .and_then(|state| super::hidden::skip(state))\n-                                            .and_then(|state| {\n-                                                state.sequence(|state| {\n-                                                    state.optional(|state| {\n-                                                        self::space(state).and_then(|state| {\n-                                                            state.repeat(|state| {\n-                                                                state.sequence(|state| {\n-                                                                    super::hidden::skip(state)\n-                                                                        .and_then(|state| {\n-                                                                            self::space(state)\n-                                                                        })\n-                                                                })\n-                                                            })\n-                                                        })\n-                                                    })\n-                                                })\n-                                            })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| state.match_string(\"-\"))\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        self::space(state)\n-                                            .and_then(|state| super::hidden::skip(state))\n-                                            .and_then(|state| {\n-                                                state.sequence(|state| {\n-                                                    state.optional(|state| {\n-                                                        self::space(state).and_then(|state| {\n-                                                            state.repeat(|state| {\n-                                                                state.sequence(|state| {\n-                                                                    super::hidden::skip(state)\n-                                                                        .and_then(|state| {\n-                                                                            self::space(state)\n-                                                                        })\n-                                                                })\n-                                                            })\n-                                                        })\n-                                                    })\n-                                                })\n-                                            })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::partial(state))\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn simple(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::simple, |state| {\n-                        self::primitive(state)\n-                            .or_else(|state| self::partial(state))\n-                            .or_else(|state| self::tilde(state))\n-                            .or_else(|state| self::caret(state))\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn primitive(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::primitive, |state| {\n-                        state.sequence(|state| {\n-                            self::primitive_op(state)\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                                state.repeat(|state| {\n-                                                    state.sequence(|state| {\n-                                                        super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                    })\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::partial(state))\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn primitive_op(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::primitive_op, |state| {\n-                        state\n-                            .match_string(\"<=\")\n-                            .or_else(|state| state.match_string(\">=\"))\n-                            .or_else(|state| state.match_string(\">\"))\n-                            .or_else(|state| state.match_string(\"<\"))\n-                            .or_else(|state| state.match_string(\"=\"))\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn partial(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::partial, |state| {\n-                        state.sequence(|state| {\n-                            self::xr(state)\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.optional(|state| {\n-                                        state.sequence(|state| {\n-                                            state\n-                                                .match_string(\".\")\n-                                                .and_then(|state| super::hidden::skip(state))\n-                                                .and_then(|state| self::xr(state))\n-                                                .and_then(|state| super::hidden::skip(state))\n-                                                .and_then(|state| {\n-                                                    state.optional(|state| {\n-                                                        state.sequence(|state| {\n-                                                            state\n-                                                                .match_string(\".\")\n-                                                                .and_then(|state| {\n-                                                                    super::hidden::skip(state)\n-                                                                })\n-                                                                .and_then(|state| self::xr(state))\n-                                                                .and_then(|state| {\n-                                                                    super::hidden::skip(state)\n-                                                                })\n-                                                                .and_then(|state| {\n-                                                                    state.optional(|state| {\n-                                                                        self::qualifier(state)\n-                                                                    })\n-                                                                })\n-                                                        })\n-                                                    })\n-                                                })\n-                                        })\n-                                    })\n-                                })\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn xr(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::xr, |state| {\n-                        self::xr_op(state).or_else(|state| self::nr(state))\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn xr_op(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::xr_op, |state| {\n-                        state\n-                            .match_string(\"x\")\n-                            .or_else(|state| state.match_string(\"X\"))\n-                            .or_else(|state| state.match_string(\"*\"))\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn nr(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::nr, |state| {\n-                        state.match_string(\"0\").or_else(|state| {\n-                            state.sequence(|state| {\n-                                state\n-                                    .match_range('1'..'9')\n-                                    .and_then(|state| super::hidden::skip(state))\n-                                    .and_then(|state| {\n-                                        state.sequence(|state| {\n-                                            state.optional(|state| {\n-                                                state.match_range('0'..'9').and_then(|state| {\n-                                                    state.repeat(|state| {\n-                                                        state.sequence(|state| {\n-                                                            super::hidden::skip(state).and_then(\n-                                                                |state| state.match_range('0'..'9'),\n-                                                            )\n-                                                        })\n-                                                    })\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                            })\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn tilde(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::tilde, |state| {\n-                        state.sequence(|state| {\n-                            state\n-                                .match_string(\"~>\")\n-                                .or_else(|state| state.match_string(\"~\"))\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                                state.repeat(|state| {\n-                                                    state.sequence(|state| {\n-                                                        super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                    })\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::partial(state))\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn caret(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::caret, |state| {\n-                        state.sequence(|state| {\n-                            state\n-                                .match_string(\"^\")\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            self::space(state).and_then(|state| {\n-                                                state.repeat(|state| {\n-                                                    state.sequence(|state| {\n-                                                        super::hidden::skip(state)\n-                                                            .and_then(|state| self::space(state))\n-                                                    })\n-                                                })\n-                                            })\n-                                        })\n-                                    })\n-                                })\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::partial(state))\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn qualifier(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::qualifier, |state| {\n-                        state.sequence(|state| {\n-                            state\n-                                .match_string(\"-\")\n-                                .or_else(|state| state.match_string(\"+\"))\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| self::parts(state))\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn parts(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::parts, |state| {\n-                        state.sequence(|state| {\n-                            self::part(state)\n-                                .and_then(|state| super::hidden::skip(state))\n-                                .and_then(|state| {\n-                                    state.sequence(|state| {\n-                                        state.optional(|state| {\n-                                            state\n-                                                .sequence(|state| {\n-                                                    state\n-                                                        .match_string(\".\")\n-                                                        .and_then(|state| {\n-                                                            super::hidden::skip(state)\n-                                                        })\n-                                                        .and_then(|state| self::part(state))\n-                                                })\n-                                                .and_then(|state| {\n-                                                    state.repeat(|state| {\n-                                                        state.sequence(|state| {\n-                                                            super::hidden::skip(state).and_then(\n-                                                                |state| {\n-                                                                    state.sequence(|state| {\n-                                                                        state\n-                                                                            .match_string(\".\")\n-                                                                            .and_then(|state| {\n-                                                                                super::hidden::skip(\n-                                                                                    state,\n-                                                                                )\n-                                                                            })\n-                                                                            .and_then(|state| {\n-                                                                                self::part(state)\n-                                                                            })\n-                                                                    })\n-                                                                },\n-                                                            )\n-                                                        })\n-                                                    })\n-                                                })\n-                                        })\n-                                    })\n-                                })\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn part(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::part, |state| {\n-                        self::nr(state).or_else(|state| {\n-                            state.sequence(|state| {\n-                                state\n-                                    .match_string(\"-\")\n-                                    .or_else(|state| state.match_range('0'..'9'))\n-                                    .or_else(|state| state.match_range('A'..'Z'))\n-                                    .or_else(|state| state.match_range('a'..'z'))\n-                                    .and_then(|state| super::hidden::skip(state))\n-                                    .and_then(|state| {\n-                                        state.sequence(|state| {\n-                                            state.optional(|state| {\n-                                                state\n-                                                    .match_string(\"-\")\n-                                                    .or_else(|state| state.match_range('0'..'9'))\n-                                                    .or_else(|state| state.match_range('A'..'Z'))\n-                                                    .or_else(|state| state.match_range('a'..'z'))\n-                                                    .and_then(|state| {\n-                                                        state.repeat(|state| {\n-                                                            state.sequence(|state| {\n-                                                                super::hidden::skip(state).and_then(\n-                                                                    |state| {\n-                                                                        state\n-                                                                            .match_string(\"-\")\n-                                                                            .or_else(|state| {\n-                                                                                state.match_range(\n-                                                                                    '0'..'9',\n-                                                                                )\n-                                                                            })\n-                                                                            .or_else(|state| {\n-                                                                                state.match_range(\n-                                                                                    'A'..'Z',\n-                                                                                )\n-                                                                            })\n-                                                                            .or_else(|state| {\n-                                                                                state.match_range(\n-                                                                                    'a'..'z',\n-                                                                                )\n-                                                                            })\n-                                                                    },\n-                                                                )\n-                                                            })\n-                                                        })\n-                                                    })\n-                                            })\n-                                        })\n-                                    })\n-                            })\n-                        })\n-                    })\n-                }\n-                #[inline]\n-                #[allow(non_snake_case, unused_variables)]\n-                pub fn space(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state\n-                        .match_string(\" \")\n-                        .or_else(|state| state.match_string(\"\\t\"))\n-                }\n-                #[inline]\n-                #[allow(dead_code, non_snake_case, unused_variables)]\n-                pub fn EOI(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.rule(Rule::EOI, |state| state.end_of_input())\n-                }\n-                #[inline]\n-                #[allow(dead_code, non_snake_case, unused_variables)]\n-                pub fn SOI(\n-                    state: Box<::pest::ParserState<Rule>>,\n-                ) -> ::pest::ParseResult<Box<::pest::ParserState<Rule>>> {\n-                    state.start_of_input()\n-                }\n-            }\n-            pub use self::visible::*;\n-        }\n-        ::pest::state(input, |state| match rule {\n-            Rule::range_set => rules::range_set(state),\n-            Rule::logical_or => rules::logical_or(state),\n-            Rule::range => rules::range(state),\n-            Rule::empty => rules::empty(state),\n-            Rule::hyphen => rules::hyphen(state),\n-            Rule::simple => rules::simple(state),\n-            Rule::primitive => rules::primitive(state),\n-            Rule::primitive_op => rules::primitive_op(state),\n-            Rule::partial => rules::partial(state),\n-            Rule::xr => rules::xr(state),\n-            Rule::xr_op => rules::xr_op(state),\n-            Rule::nr => rules::nr(state),\n-            Rule::tilde => rules::tilde(state),\n-            Rule::caret => rules::caret(state),\n-            Rule::qualifier => rules::qualifier(state),\n-            Rule::parts => rules::parts(state),\n-            Rule::part => rules::part(state),\n-            Rule::space => rules::space(state),\n-            Rule::EOI => rules::EOI(state),\n-        })\n-    }\n-}"}, {"sha": "336dae1b64ab804be11155e53d1da099877e277b", "filename": "tests/target/performance/issue-4867.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac2b7a261c94d2d7d718bede54fc93c7f2fdd641/tests%2Ftarget%2Fperformance%2Fissue-4867.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2b7a261c94d2d7d718bede54fc93c7f2fdd641/tests%2Ftarget%2Fperformance%2Fissue-4867.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fperformance%2Fissue-4867.rs?ref=ac2b7a261c94d2d7d718bede54fc93c7f2fdd641", "patch": "@@ -1,13 +0,0 @@\n-mod modA {\n-    mod modB {\n-        mod modC {\n-            mod modD {\n-                mod modE {\n-                    fn func() {\n-                        state . rule (Rule :: myrule , | state | { state . sequence (| state | { state . sequence (| state | { state . match_string (\"abc\") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (\"def\") }) }) . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . sequence (| state | { state . optional (| state | { state . sequence (| state | { state . match_string (\"abc\") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (\"def\") }) }) . and_then (| state | { state . repeat (| state | { state . sequence (| state | { super :: hidden :: skip (state) . and_then (| state | { state . sequence (| state | { state . match_string (\"abc\") . and_then (| state | { super :: hidden :: skip (state) }) . and_then (| state | { state . match_string (\"def\") }) }) }) }) }) }) }) }) }) }) });\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "ba9ebfc6243f21f225639c0b0b7c32e9a3566a4a", "filename": "tests/target/performance/issue-5128.rs", "status": "removed", "additions": 0, "deletions": 4898, "changes": 4898, "blob_url": "https://github.com/rust-lang/rust/blob/ac2b7a261c94d2d7d718bede54fc93c7f2fdd641/tests%2Ftarget%2Fperformance%2Fissue-5128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac2b7a261c94d2d7d718bede54fc93c7f2fdd641/tests%2Ftarget%2Fperformance%2Fissue-5128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fperformance%2Fissue-5128.rs?ref=ac2b7a261c94d2d7d718bede54fc93c7f2fdd641"}]}