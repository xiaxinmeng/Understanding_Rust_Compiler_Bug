{"sha": "73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZDNhMWMxNGFkMTcwMzY0NDY2N2Y4Y2IwZGY4ZTRkMzE2YWE0ZTE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-02-22T15:00:20Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-02-23T17:49:37Z"}, "message": "Use dynamic dispatch for the inner Module\n\nThis improves compilation time and shrinks the linked backend from\n13MB to 9.7MB on Linux.", "tree": {"sha": "d5683974c4cf47d1debe8e3b5b247e4ece43779a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5683974c4cf47d1debe8e3b5b247e4ece43779a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "html_url": "https://github.com/rust-lang/rust/commit/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef96a0f3f0235bb9a487fd5d8ee900bb4e9c4208", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef96a0f3f0235bb9a487fd5d8ee900bb4e9c4208", "html_url": "https://github.com/rust-lang/rust/commit/ef96a0f3f0235bb9a487fd5d8ee900bb4e9c4208"}], "stats": {"total": 381, "additions": 162, "deletions": 219}, "files": [{"sha": "8570805fcd27b9c907e3519b2c88bb525d7e054f", "filename": "src/abi/comments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -10,14 +10,14 @@ use cranelift_codegen::entity::EntityRef;\n \n use crate::prelude::*;\n \n-pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n     fx.add_global_comment(\n         \"kind  loc.idx   param    pass mode                            ty\".to_string(),\n     );\n }\n \n pub(super) fn add_arg_comment<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     kind: &str,\n     local: Option<mir::Local>,\n     local_field: Option<usize>,\n@@ -62,15 +62,15 @@ pub(super) fn add_arg_comment<'tcx>(\n     ));\n }\n \n-pub(super) fn add_locals_header_comment(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+pub(super) fn add_locals_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n     fx.add_global_comment(String::new());\n     fx.add_global_comment(\n         \"kind  local ty                              size align (abi,pref)\".to_string(),\n     );\n }\n \n pub(super) fn add_local_place_comments<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: CPlace<'tcx>,\n     local: Local,\n ) {"}, {"sha": "849f293c41993053fa174ee285b38a78a78e4cbf", "filename": "src/abi/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -73,7 +73,7 @@ pub(crate) fn get_function_sig<'tcx>(\n /// Instance must be monomorphized\n pub(crate) fn import_function<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    module: &mut impl Module,\n+    module: &mut dyn Module,\n     inst: Instance<'tcx>,\n ) -> FuncId {\n     let name = tcx.symbol_name(inst).name.to_string();\n@@ -83,10 +83,10 @@ pub(crate) fn import_function<'tcx>(\n         .unwrap()\n }\n \n-impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     /// Instance must be monomorphized\n     pub(crate) fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n-        let func_id = import_function(self.tcx, &mut self.cx.module, inst);\n+        let func_id = import_function(self.tcx, self.cx.module, inst);\n         let func_ref = self\n             .cx\n             .module\n@@ -167,7 +167,7 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n \n /// Make a [`CPlace`] capable of holding value of the specified type.\n fn make_local_place<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     local: Local,\n     layout: TyAndLayout<'tcx>,\n     is_ssa: bool,\n@@ -188,10 +188,7 @@ fn make_local_place<'tcx>(\n     place\n }\n \n-pub(crate) fn codegen_fn_prelude<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    start_block: Block,\n-) {\n+pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_block: Block) {\n     fx.bcx.append_block_params_for_function_params(start_block);\n \n     fx.bcx.switch_to_block(start_block);\n@@ -344,7 +341,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n }\n \n pub(crate) fn codegen_terminator_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     span: Span,\n     current_block: Block,\n     func: &Operand<'tcx>,\n@@ -572,7 +569,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n }\n \n pub(crate) fn codegen_drop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     span: Span,\n     drop_place: CPlace<'tcx>,\n ) {"}, {"sha": "57b5ff9d02b9d4d7b3483ccd21165f477b5cd3e8", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -199,7 +199,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n }\n \n pub(super) fn to_casted_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     cast: CastTarget,\n ) -> SmallVec<[Value; 2]> {\n@@ -219,7 +219,7 @@ pub(super) fn to_casted_value<'tcx>(\n }\n \n pub(super) fn from_casted_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     block_params: &[Value],\n     layout: TyAndLayout<'tcx>,\n     cast: CastTarget,\n@@ -258,7 +258,7 @@ pub(super) fn from_casted_value<'tcx>(\n \n /// Get a set of values to be passed as function arguments.\n pub(super) fn adjust_arg_for_abi<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n ) -> SmallVec<[Value; 2]> {\n@@ -281,7 +281,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n /// Create a [`CValue`] containing the value of a function parameter adding clif function parameters\n /// as necessary.\n pub(super) fn cvalue_for_param<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local: Option<mir::Local>,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local_field: Option<usize>,\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,"}, {"sha": "40a0320b579962eb2be7bfa810834bbd9b425e98", "filename": "src/abi/returning.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -8,7 +8,7 @@ use smallvec::{smallvec, SmallVec};\n \n /// Can the given type be returned into an ssa var or does it need to be returned on the stack.\n pub(crate) fn can_return_to_ssa_var<'tcx>(\n-    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &FunctionCx<'_, '_, 'tcx>,\n     func: &mir::Operand<'tcx>,\n     args: &[mir::Operand<'tcx>],\n ) -> bool {\n@@ -58,7 +58,7 @@ pub(crate) fn can_return_to_ssa_var<'tcx>(\n /// Return a place where the return value of the current function can be written to. If necessary\n /// this adds an extra parameter pointing to where the return value needs to be stored.\n pub(super) fn codegen_return_param<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     ssa_analyzed: &rustc_index::vec::IndexVec<Local, crate::analyze::SsaKind>,\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n@@ -120,11 +120,11 @@ pub(super) fn codegen_return_param<'tcx>(\n \n /// Invokes the closure with if necessary a value representing the return pointer. When the closure\n /// returns the call return value(s) if any are written to the correct place.\n-pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+pub(super) fn codegen_with_call_return_arg<'tcx, T>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     ret_arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     ret_place: Option<CPlace<'tcx>>,\n-    f: impl FnOnce(&mut FunctionCx<'_, 'tcx, M>, Option<Value>) -> (Inst, T),\n+    f: impl FnOnce(&mut FunctionCx<'_, '_, 'tcx>, Option<Value>) -> (Inst, T),\n ) -> (Inst, T) {\n     let return_ptr = match ret_arg_abi.mode {\n         PassMode::Ignore => None,\n@@ -193,7 +193,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n }\n \n /// Codegen a return instruction with the right return value(s) if any.\n-pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, '_>) {\n     match fx.fn_abi.as_ref().unwrap().ret.mode {\n         PassMode::Ignore\n         | PassMode::Indirect {"}, {"sha": "9aeea38c091561921e4be7bb017e5f68b973f631", "filename": "src/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -11,7 +11,7 @@ pub(crate) enum SsaKind {\n     Ssa,\n }\n \n-pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Module>) -> IndexVec<Local, SsaKind> {\n+pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n     let mut flag_map = fx\n         .mir\n         .local_decls"}, {"sha": "8a45e1bad42eb780a5d1a7d1a0167fda7231433e", "filename": "src/base.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -8,7 +8,7 @@ use rustc_target::abi::call::FnAbi;\n use crate::prelude::*;\n \n pub(crate) fn codegen_fn<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx, impl Module>,\n+    cx: &mut crate::CodegenCx<'_, 'tcx>,\n     instance: Instance<'tcx>,\n     linkage: Linkage,\n ) {\n@@ -209,7 +209,7 @@ pub(crate) fn verify_func(\n     });\n }\n \n-fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n+fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n     for (bb, bb_data) in fx.mir.basic_blocks().iter_enumerated() {\n         let block = fx.get_block(bb);\n         fx.bcx.switch_to_block(block);\n@@ -453,7 +453,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n }\n \n fn codegen_stmt<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     #[allow(unused_variables)] cur_block: Block,\n     stmt: &Statement<'tcx>,\n ) {\n@@ -595,10 +595,7 @@ fn codegen_stmt<'tcx>(\n                     let from_ty = operand.layout().ty;\n                     let to_ty = fx.monomorphize(to_ty);\n \n-                    fn is_fat_ptr<'tcx>(\n-                        fx: &FunctionCx<'_, 'tcx, impl Module>,\n-                        ty: Ty<'tcx>,\n-                    ) -> bool {\n+                    fn is_fat_ptr<'tcx>(fx: &FunctionCx<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n                         ty.builtin_deref(true)\n                             .map(\n                                 |ty::TypeAndMut {\n@@ -895,10 +892,7 @@ fn codegen_stmt<'tcx>(\n     }\n }\n \n-fn codegen_array_len<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    place: CPlace<'tcx>,\n-) -> Value {\n+fn codegen_array_len<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, place: CPlace<'tcx>) -> Value {\n     match *place.layout().ty.kind() {\n         ty::Array(_elem_ty, len) => {\n             let len = fx\n@@ -915,7 +909,7 @@ fn codegen_array_len<'tcx>(\n }\n \n pub(crate) fn codegen_place<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: Place<'tcx>,\n ) -> CPlace<'tcx> {\n     let mut cplace = fx.get_local_place(place.local);\n@@ -987,7 +981,7 @@ pub(crate) fn codegen_place<'tcx>(\n }\n \n pub(crate) fn codegen_operand<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     operand: &Operand<'tcx>,\n ) -> CValue<'tcx> {\n     match operand {\n@@ -999,11 +993,7 @@ pub(crate) fn codegen_operand<'tcx>(\n     }\n }\n \n-pub(crate) fn codegen_panic<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    msg_str: &str,\n-    span: Span,\n-) {\n+pub(crate) fn codegen_panic<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, msg_str: &str, span: Span) {\n     let location = fx.get_caller_location(span).load_scalar(fx);\n \n     let msg_ptr = fx.anonymous_str(\"assert\", msg_str);\n@@ -1017,7 +1007,7 @@ pub(crate) fn codegen_panic<'tcx>(\n }\n \n pub(crate) fn codegen_panic_inner<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     lang_item: rustc_hir::LangItem,\n     args: &[Value],\n     span: Span,"}, {"sha": "432533c7636bc42a2208c2f9063939371dc22ee5", "filename": "src/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -3,7 +3,7 @@\n use crate::prelude::*;\n \n pub(crate) fn clif_intcast(\n-    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, '_>,\n     val: Value,\n     to: Type,\n     signed: bool,\n@@ -51,7 +51,7 @@ pub(crate) fn clif_intcast(\n }\n \n pub(crate) fn clif_int_or_float_cast(\n-    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, '_>,\n     from: Value,\n     from_signed: bool,\n     to_ty: Type,"}, {"sha": "60fffa60484e3e3c0b44f103b8c52f22e8f3ddfc", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -5,7 +5,7 @@ use cranelift_codegen::ir::ArgumentPurpose;\n use crate::prelude::*;\n \n pub(crate) fn maybe_codegen<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     checked: bool,\n     lhs: CValue<'tcx>,"}, {"sha": "2c34c8ee5e832b9f493523e45ee9ad8ef1e3089e", "filename": "src/common.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -130,7 +130,7 @@ pub(crate) fn has_ptr_meta<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n pub(crate) fn codegen_icmp_imm(\n-    fx: &mut FunctionCx<'_, '_, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, '_>,\n     intcc: IntCC,\n     lhs: Value,\n     rhs: i128,\n@@ -241,8 +241,8 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n     }\n }\n \n-pub(crate) struct FunctionCx<'clif, 'tcx, M: Module> {\n-    pub(crate) cx: &'clif mut crate::CodegenCx<'tcx, M>,\n+pub(crate) struct FunctionCx<'m, 'clif, 'tcx> {\n+    pub(crate) cx: &'clif mut crate::CodegenCx<'m, 'tcx>,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) pointer_type: Type, // Cached from module\n \n@@ -269,7 +269,7 @@ pub(crate) struct FunctionCx<'clif, 'tcx, M: Module> {\n     pub(crate) inline_asm_index: u32,\n }\n \n-impl<'tcx, M: Module> LayoutOf for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> LayoutOf for FunctionCx<'_, '_, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type TyAndLayout = TyAndLayout<'tcx>;\n \n@@ -278,31 +278,31 @@ impl<'tcx, M: Module> LayoutOf for FunctionCx<'_, 'tcx, M> {\n     }\n }\n \n-impl<'tcx, M: Module> layout::HasTyCtxt<'tcx> for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> layout::HasTyCtxt<'tcx> for FunctionCx<'_, '_, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n }\n \n-impl<'tcx, M: Module> rustc_target::abi::HasDataLayout for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> rustc_target::abi::HasDataLayout for FunctionCx<'_, '_, 'tcx> {\n     fn data_layout(&self) -> &rustc_target::abi::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'tcx, M: Module> layout::HasParamEnv<'tcx> for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> layout::HasParamEnv<'tcx> for FunctionCx<'_, '_, 'tcx> {\n     fn param_env(&self) -> ParamEnv<'tcx> {\n         ParamEnv::reveal_all()\n     }\n }\n \n-impl<'tcx, M: Module> HasTargetSpec for FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> HasTargetSpec for FunctionCx<'_, '_, 'tcx> {\n     fn target_spec(&self) -> &Target {\n         &self.tcx.sess.target\n     }\n }\n \n-impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n+impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     pub(crate) fn monomorphize<T>(&self, value: T) -> T\n     where\n         T: TypeFoldable<'tcx> + Copy,"}, {"sha": "3712357746b74ae930a7547ee50322335b3b55cd", "filename": "src/constant.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -28,15 +28,15 @@ enum TodoItem {\n }\n \n impl ConstantCx {\n-    pub(crate) fn finalize(mut self, tcx: TyCtxt<'_>, module: &mut impl Module) {\n+    pub(crate) fn finalize(mut self, tcx: TyCtxt<'_>, module: &mut dyn Module) {\n         //println!(\"todo {:?}\", self.todo);\n         define_all_allocs(tcx, module, &mut self);\n         //println!(\"done {:?}\", self.done);\n         self.done.clear();\n     }\n }\n \n-pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, impl Module>) -> bool {\n+pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n     let mut all_constants_ok = true;\n     for constant in &fx.mir.required_consts {\n         let const_ = fx.monomorphize(constant.literal);\n@@ -79,11 +79,11 @@ pub(crate) fn codegen_static(constants_cx: &mut ConstantCx, def_id: DefId) {\n }\n \n pub(crate) fn codegen_tls_ref<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n@@ -92,11 +92,11 @@ pub(crate) fn codegen_tls_ref<'tcx>(\n }\n \n fn codegen_static_ref<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CPlace<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n@@ -113,7 +113,7 @@ fn codegen_static_ref<'tcx>(\n }\n \n pub(crate) fn codegen_constant<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     constant: &Constant<'tcx>,\n ) -> CValue<'tcx> {\n     let const_ = fx.monomorphize(constant.literal);\n@@ -155,7 +155,7 @@ pub(crate) fn codegen_constant<'tcx>(\n }\n \n pub(crate) fn codegen_const_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     const_val: ConstValue<'tcx>,\n     ty: Ty<'tcx>,\n ) -> CValue<'tcx> {\n@@ -189,11 +189,8 @@ pub(crate) fn codegen_const_value<'tcx>(\n                     let base_addr = match alloc_kind {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n                             fx.cx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n-                            let data_id = data_id_for_alloc_id(\n-                                &mut fx.cx.module,\n-                                ptr.alloc_id,\n-                                alloc.mutability,\n-                            );\n+                            let data_id =\n+                                data_id_for_alloc_id(fx.cx.module, ptr.alloc_id, alloc.mutability);\n                             let local_data_id =\n                                 fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             #[cfg(debug_assertions)]\n@@ -202,15 +199,14 @@ pub(crate) fn codegen_const_value<'tcx>(\n                         }\n                         Some(GlobalAlloc::Function(instance)) => {\n                             let func_id =\n-                                crate::abi::import_function(fx.tcx, &mut fx.cx.module, instance);\n+                                crate::abi::import_function(fx.tcx, fx.cx.module, instance);\n                             let local_func_id =\n                                 fx.cx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n                             fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n                         }\n                         Some(GlobalAlloc::Static(def_id)) => {\n                             assert!(fx.tcx.is_static(def_id));\n-                            let data_id =\n-                                data_id_for_static(fx.tcx, &mut fx.cx.module, def_id, false);\n+                            let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n                             let local_data_id =\n                                 fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             #[cfg(debug_assertions)]\n@@ -249,12 +245,12 @@ pub(crate) fn codegen_const_value<'tcx>(\n }\n \n fn pointer_for_allocation<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     alloc: &'tcx Allocation,\n ) -> crate::pointer::Pointer {\n     let alloc_id = fx.tcx.create_memory_alloc(alloc);\n     fx.cx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n-    let data_id = data_id_for_alloc_id(&mut fx.cx.module, alloc_id, alloc.mutability);\n+    let data_id = data_id_for_alloc_id(fx.cx.module, alloc_id, alloc.mutability);\n \n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n@@ -264,7 +260,7 @@ fn pointer_for_allocation<'tcx>(\n }\n \n fn data_id_for_alloc_id(\n-    module: &mut impl Module,\n+    module: &mut dyn Module,\n     alloc_id: AllocId,\n     mutability: rustc_hir::Mutability,\n ) -> DataId {\n@@ -280,7 +276,7 @@ fn data_id_for_alloc_id(\n \n fn data_id_for_static(\n     tcx: TyCtxt<'_>,\n-    module: &mut impl Module,\n+    module: &mut dyn Module,\n     def_id: DefId,\n     definition: bool,\n ) -> DataId {\n@@ -355,7 +351,7 @@ fn data_id_for_static(\n     }\n }\n \n-fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut ConstantCx) {\n+fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut ConstantCx) {\n     while let Some(todo_item) = cx.todo.pop() {\n         let (data_id, alloc, section_name) = match todo_item {\n             TodoItem::Alloc(alloc_id) => {\n@@ -456,7 +452,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n }\n \n pub(crate) fn mir_operand_get_const_val<'tcx>(\n-    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &FunctionCx<'_, '_, 'tcx>,\n     operand: &Operand<'tcx>,\n ) -> Option<&'tcx Const<'tcx>> {\n     match operand {"}, {"sha": "3815e149ffa1a4529608ee5129f6fee60005e4fa", "filename": "src/discriminant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiscriminant.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -7,7 +7,7 @@ use rustc_target::abi::{Int, TagEncoding, Variants};\n use crate::prelude::*;\n \n pub(crate) fn codegen_set_discriminant<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: CPlace<'tcx>,\n     variant_index: VariantIdx,\n ) {\n@@ -70,7 +70,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n }\n \n pub(crate) fn codegen_get_discriminant<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     value: CValue<'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {"}, {"sha": "07c6c27817c54a83172ab1a90ac22e53a0f72582", "filename": "src/driver/aot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -119,12 +119,12 @@ fn module_codegen(\n     let cgu = tcx.codegen_unit(cgu_name);\n     let mono_items = cgu.items_in_deterministic_order(tcx);\n \n-    let module = new_module(tcx, cgu_name.as_str().to_string());\n+    let mut module = new_module(tcx, cgu_name.as_str().to_string());\n \n     let mut cx = crate::CodegenCx::new(\n         tcx,\n         backend_config,\n-        module,\n+        &mut module,\n         tcx.sess.opts.debuginfo != DebugInfo::None,\n     );\n     super::predefine_mono_items(&mut cx, &mono_items);\n@@ -150,7 +150,7 @@ fn module_codegen(\n             }\n         }\n     }\n-    let (mut module, global_asm, debug, mut unwind_context) =\n+    let (global_asm, debug, mut unwind_context) =\n         tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n     crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context);\n "}, {"sha": "beb316c58c3d1261dca57cacbfc1188155f1a6ef", "filename": "src/driver/jit.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -57,7 +57,7 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         .into_iter()\n         .collect::<Vec<(_, (_, _))>>();\n \n-    let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module, false);\n+    let mut cx = crate::CodegenCx::new(tcx, backend_config, &mut jit_module, false);\n \n     super::time(tcx, \"codegen mono items\", || {\n         super::predefine_mono_items(&mut cx, &mono_items);\n@@ -85,7 +85,7 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         }\n     });\n \n-    let (mut jit_module, global_asm, _debug, mut unwind_context) =\n+    let (global_asm, _debug, mut unwind_context) =\n         tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n     jit_module.finalize_definitions();\n \n@@ -145,21 +145,20 @@ extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8\n             let jit_module = jit_module.as_mut().unwrap();\n             let backend_config =\n                 BACKEND_CONFIG.with(|backend_config| backend_config.borrow().clone().unwrap());\n-            let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module, false);\n \n             let name = tcx.symbol_name(instance).name.to_string();\n-            let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), instance);\n-            let func_id = cx\n-                .module\n+            let sig = crate::abi::get_function_sig(tcx, jit_module.isa().triple(), instance);\n+            let func_id = jit_module\n                 .declare_function(&name, Linkage::Export, &sig)\n                 .unwrap();\n-            cx.module.prepare_for_function_redefine(func_id).unwrap();\n+            jit_module.prepare_for_function_redefine(func_id).unwrap();\n \n+            let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module, false);\n             tcx.sess.time(\"codegen fn\", || {\n                 crate::base::codegen_fn(&mut cx, instance, Linkage::Export)\n             });\n \n-            let (jit_module, global_asm, _debug_context, unwind_context) = cx.finalize();\n+            let (global_asm, _debug_context, unwind_context) = cx.finalize();\n             assert!(global_asm.is_empty());\n             jit_module.finalize_definitions();\n             std::mem::forget(unsafe { unwind_context.register_jit(&jit_module) });\n@@ -233,7 +232,7 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n     imported_symbols\n }\n \n-pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx, impl Module>, inst: Instance<'tcx>) {\n+pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'tcx>) {\n     let tcx = cx.tcx;\n \n     let pointer_type = cx.module.target_config().pointer_type();"}, {"sha": "91cfde654f9386587db97e6666f96236b99b4e64", "filename": "src/driver/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -43,7 +43,7 @@ pub(crate) fn codegen_crate(\n }\n \n fn predefine_mono_items<'tcx>(\n-    cx: &mut crate::CodegenCx<'tcx, impl Module>,\n+    cx: &mut crate::CodegenCx<'_, 'tcx>,\n     mono_items: &[(MonoItem<'tcx>, (RLinkage, Visibility))],\n ) {\n     cx.tcx.sess.time(\"predefine functions\", || {"}, {"sha": "c8f027e7b1a5ba68619d06ea97356de38312375f", "filename": "src/inline_asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir::InlineAsmOperand;\n use rustc_target::asm::*;\n \n pub(crate) fn codegen_inline_asm<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     _span: Span,\n     template: &[InlineAsmTemplatePiece],\n     operands: &[InlineAsmOperand<'tcx>],\n@@ -203,7 +203,7 @@ fn generate_asm_wrapper(\n }\n \n fn call_inline_asm<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     asm_name: &str,\n     slot_size: Size,\n     inputs: Vec<(InlineAsmReg, Size, Value)>,"}, {"sha": "4c82e793ad26501d367fe2dd7967f32d58ebb2a9", "filename": "src/intrinsics/cpuid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fcpuid.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -6,7 +6,7 @@ use crate::prelude::*;\n ///\n /// This emulates an intel cpu with sse and sse2 support, but which doesn't support anything else.\n pub(crate) fn codegen_cpuid_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     leaf: Value,\n     _subleaf: Value,\n ) -> (Value, Value, Value, Value) {"}, {"sha": "0692da397eb9465c2e44c1f70173bfe7c28e82bf", "filename": "src/intrinsics/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fllvm.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -6,7 +6,7 @@ use crate::prelude::*;\n use rustc_middle::ty::subst::SubstsRef;\n \n pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     intrinsic: &str,\n     substs: SubstsRef<'tcx>,\n     args: &[mir::Operand<'tcx>],"}, {"sha": "f0ca7400d5031736dc13ed2d2c239c157a37a4ac", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -153,12 +153,12 @@ pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx\n     }\n }\n \n-fn simd_for_each_lane<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_for_each_lane<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n     f: impl Fn(\n-        &mut FunctionCx<'_, 'tcx, M>,\n+        &mut FunctionCx<'_, '_, 'tcx>,\n         TyAndLayout<'tcx>,\n         TyAndLayout<'tcx>,\n         Value,\n@@ -182,13 +182,13 @@ fn simd_for_each_lane<'tcx, M: Module>(\n     }\n }\n \n-fn simd_pair_for_each_lane<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_pair_for_each_lane<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     x: CValue<'tcx>,\n     y: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n     f: impl Fn(\n-        &mut FunctionCx<'_, 'tcx, M>,\n+        &mut FunctionCx<'_, '_, 'tcx>,\n         TyAndLayout<'tcx>,\n         TyAndLayout<'tcx>,\n         Value,\n@@ -215,11 +215,11 @@ fn simd_pair_for_each_lane<'tcx, M: Module>(\n     }\n }\n \n-fn simd_reduce<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_reduce<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n-    f: impl Fn(&mut FunctionCx<'_, 'tcx, M>, TyAndLayout<'tcx>, Value, Value) -> Value,\n+    f: impl Fn(&mut FunctionCx<'_, '_, 'tcx>, TyAndLayout<'tcx>, Value, Value) -> Value,\n ) {\n     let (lane_count, lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     let lane_layout = fx.layout_of(lane_ty);\n@@ -236,11 +236,11 @@ fn simd_reduce<'tcx, M: Module>(\n     ret.write_cvalue(fx, res);\n }\n \n-fn simd_reduce_bool<'tcx, M: Module>(\n-    fx: &mut FunctionCx<'_, 'tcx, M>,\n+fn simd_reduce_bool<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     val: CValue<'tcx>,\n     ret: CPlace<'tcx>,\n-    f: impl Fn(&mut FunctionCx<'_, 'tcx, M>, Value, Value) -> Value,\n+    f: impl Fn(&mut FunctionCx<'_, '_, 'tcx>, Value, Value) -> Value,\n ) {\n     let (lane_count, _lane_ty) = val.layout().ty.simd_size_and_type(fx.tcx);\n     assert!(ret.layout().ty.is_bool());\n@@ -259,7 +259,7 @@ fn simd_reduce_bool<'tcx, M: Module>(\n }\n \n fn bool_to_zero_or_max_uint<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     val: Value,\n ) -> CValue<'tcx> {\n@@ -393,7 +393,7 @@ macro simd_flt_binop($fx:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) {\n }\n \n pub(crate) fn codegen_intrinsic_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     instance: Instance<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     destination: Option<(CPlace<'tcx>, BasicBlock)>,"}, {"sha": "1f8eeb1e714913c072e2c303594501d33011bc4a", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -4,7 +4,7 @@ use super::*;\n use crate::prelude::*;\n \n pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     instance: Instance<'tcx>,\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,"}, {"sha": "122ad4e366dda6986cb487d592865e3dd8b76bf3", "filename": "src/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -127,9 +127,9 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n     }\n }\n \n-struct CodegenCx<'tcx, M: Module> {\n+struct CodegenCx<'m, 'tcx: 'm> {\n     tcx: TyCtxt<'tcx>,\n-    module: M,\n+    module: &'m mut dyn Module,\n     global_asm: String,\n     constants_cx: ConstantCx,\n     cached_context: Context,\n@@ -138,8 +138,13 @@ struct CodegenCx<'tcx, M: Module> {\n     unwind_context: UnwindContext<'tcx>,\n }\n \n-impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n-    fn new(tcx: TyCtxt<'tcx>, backend_config: BackendConfig, module: M, debug_info: bool) -> Self {\n+impl<'m, 'tcx> CodegenCx<'m, 'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        backend_config: BackendConfig,\n+        module: &'m mut dyn Module,\n+        debug_info: bool,\n+    ) -> Self {\n         let unwind_context = UnwindContext::new(\n             tcx,\n             module.isa(),\n@@ -162,14 +167,9 @@ impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n         }\n     }\n \n-    fn finalize(mut self) -> (M, String, Option<DebugContext<'tcx>>, UnwindContext<'tcx>) {\n-        self.constants_cx.finalize(self.tcx, &mut self.module);\n-        (\n-            self.module,\n-            self.global_asm,\n-            self.debug_context,\n-            self.unwind_context,\n-        )\n+    fn finalize(self) -> (String, Option<DebugContext<'tcx>>, UnwindContext<'tcx>) {\n+        self.constants_cx.finalize(self.tcx, self.module);\n+        (self.global_asm, self.debug_context, self.unwind_context)\n     }\n }\n "}, {"sha": "4fc0cdfe0e79d78bc213c33b1e29212ae390dd1d", "filename": "src/num.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -41,7 +41,7 @@ pub(crate) fn bin_op_to_intcc(bin_op: BinOp, signed: bool) -> Option<IntCC> {\n }\n \n fn codegen_compare_bin_op<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     signed: bool,\n     lhs: Value,\n@@ -54,7 +54,7 @@ fn codegen_compare_bin_op<'tcx>(\n }\n \n pub(crate) fn codegen_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -103,7 +103,7 @@ pub(crate) fn codegen_binop<'tcx>(\n }\n \n pub(crate) fn codegen_bool_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -124,7 +124,7 @@ pub(crate) fn codegen_bool_binop<'tcx>(\n }\n \n pub(crate) fn codegen_int_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -197,7 +197,7 @@ pub(crate) fn codegen_int_binop<'tcx>(\n }\n \n pub(crate) fn codegen_checked_int_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -350,7 +350,7 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n }\n \n pub(crate) fn codegen_float_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n@@ -395,7 +395,7 @@ pub(crate) fn codegen_float_binop<'tcx>(\n }\n \n pub(crate) fn codegen_ptr_binop<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,"}, {"sha": "03b1e6cc4acee87a159a5a4ede6f4c25633ceb2f", "filename": "src/pointer.rs", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpointer.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -36,10 +36,7 @@ impl Pointer {\n         }\n     }\n \n-    pub(crate) fn const_addr<'a, 'tcx>(\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        addr: i64,\n-    ) -> Self {\n+    pub(crate) fn const_addr(fx: &mut FunctionCx<'_, '_, '_>, addr: i64) -> Self {\n         let addr = fx.bcx.ins().iconst(fx.pointer_type, addr);\n         Pointer {\n             base: PointerBase::Addr(addr),\n@@ -59,7 +56,7 @@ impl Pointer {\n         (self.base, self.offset)\n     }\n \n-    pub(crate) fn get_addr<'a, 'tcx>(self, fx: &mut FunctionCx<'a, 'tcx, impl Module>) -> Value {\n+    pub(crate) fn get_addr(self, fx: &mut FunctionCx<'_, '_, '_>) -> Value {\n         match self.base {\n             PointerBase::Addr(base_addr) => {\n                 let offset: i64 = self.offset.into();\n@@ -81,19 +78,11 @@ impl Pointer {\n         }\n     }\n \n-    pub(crate) fn offset<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        extra_offset: Offset32,\n-    ) -> Self {\n+    pub(crate) fn offset(self, fx: &mut FunctionCx<'_, '_, '_>, extra_offset: Offset32) -> Self {\n         self.offset_i64(fx, extra_offset.into())\n     }\n \n-    pub(crate) fn offset_i64<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        extra_offset: i64,\n-    ) -> Self {\n+    pub(crate) fn offset_i64(self, fx: &mut FunctionCx<'_, '_, '_>, extra_offset: i64) -> Self {\n         if let Some(new_offset) = self.offset.try_add_i64(extra_offset) {\n             Pointer {\n                 base: self.base,\n@@ -126,11 +115,7 @@ impl Pointer {\n         }\n     }\n \n-    pub(crate) fn offset_value<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        extra_offset: Value,\n-    ) -> Self {\n+    pub(crate) fn offset_value(self, fx: &mut FunctionCx<'_, '_, '_>, extra_offset: Value) -> Self {\n         match self.base {\n             PointerBase::Addr(addr) => Pointer {\n                 base: PointerBase::Addr(fx.bcx.ins().iadd(addr, extra_offset)),\n@@ -159,25 +144,15 @@ impl Pointer {\n         }\n     }\n \n-    pub(crate) fn load<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        ty: Type,\n-        flags: MemFlags,\n-    ) -> Value {\n+    pub(crate) fn load(self, fx: &mut FunctionCx<'_, '_, '_>, ty: Type, flags: MemFlags) -> Value {\n         match self.base {\n             PointerBase::Addr(base_addr) => fx.bcx.ins().load(ty, flags, base_addr, self.offset),\n             PointerBase::Stack(stack_slot) => fx.bcx.ins().stack_load(ty, stack_slot, self.offset),\n             PointerBase::Dangling(_align) => unreachable!(),\n         }\n     }\n \n-    pub(crate) fn store<'a, 'tcx>(\n-        self,\n-        fx: &mut FunctionCx<'a, 'tcx, impl Module>,\n-        value: Value,\n-        flags: MemFlags,\n-    ) {\n+    pub(crate) fn store(self, fx: &mut FunctionCx<'_, '_, '_>, value: Value, flags: MemFlags) {\n         match self.base {\n             PointerBase::Addr(base_addr) => {\n                 fx.bcx.ins().store(flags, value, base_addr, self.offset);"}, {"sha": "a5ae7fa829d56e6ba23eda3d93a5e8f9c13e30c4", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -186,7 +186,7 @@ impl FuncWriter for &'_ CommentWriter {\n }\n \n #[cfg(debug_assertions)]\n-impl<M: Module> FunctionCx<'_, '_, M> {\n+impl FunctionCx<'_, '_, '_> {\n     pub(crate) fn add_global_comment<S: Into<String>>(&mut self, comment: S) {\n         self.clif_comments.add_global_comment(comment);\n     }\n@@ -276,7 +276,7 @@ pub(crate) fn write_clif_file<'tcx>(\n     );\n }\n \n-impl<M: Module> fmt::Debug for FunctionCx<'_, '_, M> {\n+impl fmt::Debug for FunctionCx<'_, '_, '_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         writeln!(f, \"{:?}\", self.instance.substs)?;\n         writeln!(f, \"{:?}\", self.local_map)?;"}, {"sha": "bb63d72addf9842f32c3cf1af965fb80824c7bc3", "filename": "src/trap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftrap.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -2,7 +2,7 @@\n \n use crate::prelude::*;\n \n-fn codegen_print(fx: &mut FunctionCx<'_, '_, impl Module>, msg: &str) {\n+fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n     let puts = fx\n         .cx\n         .module\n@@ -29,7 +29,7 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, impl Module>, msg: &str) {\n }\n \n /// Trap code: user1\n-pub(crate) fn trap_abort(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+pub(crate) fn trap_abort(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     fx.bcx.ins().trap(TrapCode::User(1));\n }\n@@ -38,7 +38,7 @@ pub(crate) fn trap_abort(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsR\n /// so you can **not** add instructions to it afterwards.\n ///\n /// Trap code: user65535\n-pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n@@ -47,7 +47,7 @@ pub(crate) fn trap_unreachable(fx: &mut FunctionCx<'_, '_, impl Module>, msg: im\n ///\n /// Trap code: user65535\n pub(crate) fn trap_unreachable_ret_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n     msg: impl AsRef<str>,\n ) -> CValue<'tcx> {\n@@ -62,7 +62,7 @@ pub(crate) fn trap_unreachable_ret_value<'tcx>(\n /// to it afterwards.\n ///\n /// Trap code: user65535\n-pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, impl Module>, msg: impl AsRef<str>) {\n+pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, '_>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     let true_ = fx.bcx.ins().iconst(types::I32, 1);\n     fx.bcx.ins().trapnz(true_, TrapCode::User(!0));\n@@ -72,7 +72,7 @@ pub(crate) fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, impl Module>, msg:\n ///\n /// Trap code: user65535\n pub(crate) fn trap_unimplemented_ret_value<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     dest_layout: TyAndLayout<'tcx>,\n     msg: impl AsRef<str>,\n ) -> CValue<'tcx> {"}, {"sha": "109aee5a044113a9d72cb6d5eebc31e9b971257f", "filename": "src/unsize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsize.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -13,7 +13,7 @@ use crate::prelude::*;\n /// in an upcast, where the new vtable for an object will be derived\n /// from the old one.\n pub(crate) fn unsized_info<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     source: Ty<'tcx>,\n     target: Ty<'tcx>,\n     old_info: Option<Value>,\n@@ -45,7 +45,7 @@ pub(crate) fn unsized_info<'tcx>(\n \n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n fn unsize_thin_ptr<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     src: Value,\n     src_layout: TyAndLayout<'tcx>,\n     dst_layout: TyAndLayout<'tcx>,\n@@ -89,7 +89,7 @@ fn unsize_thin_ptr<'tcx>(\n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n pub(crate) fn coerce_unsized_into<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     src: CValue<'tcx>,\n     dst: CPlace<'tcx>,\n ) {\n@@ -142,7 +142,7 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n // Adapted from https://github.com/rust-lang/rust/blob/2a663555ddf36f6b041445894a8c175cd1bc718c/src/librustc_codegen_ssa/glue.rs\n \n pub(crate) fn size_and_align_of_dst<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     info: Value,\n ) -> (Value, Value) {"}, {"sha": "0dad9b2edafdfe4f076f6ad0e024a87d71edee36", "filename": "src/value_and_place.rs", "status": "modified", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -6,7 +6,7 @@ use cranelift_codegen::entity::EntityRef;\n use cranelift_codegen::ir::immediates::Offset32;\n \n fn codegen_field<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     base: Pointer,\n     extra: Option<Value>,\n     layout: TyAndLayout<'tcx>,\n@@ -15,7 +15,7 @@ fn codegen_field<'tcx>(\n     let field_offset = layout.fields.offset(field.index());\n     let field_layout = layout.field(&*fx, field.index());\n \n-    let simple = |fx: &mut FunctionCx<'_, '_, _>| {\n+    let simple = |fx: &mut FunctionCx<'_, '_, '_>| {\n         (\n             base.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap()),\n             field_layout,\n@@ -106,10 +106,7 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     // FIXME remove\n-    pub(crate) fn force_stack(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    ) -> (Pointer, Option<Value>) {\n+    pub(crate) fn force_stack(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> (Pointer, Option<Value>) {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr, meta) => (ptr, meta),\n@@ -129,7 +126,7 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     /// Load a value with layout.abi of scalar\n-    pub(crate) fn load_scalar(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> Value {\n+    pub(crate) fn load_scalar(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> Value {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr, None) => {\n@@ -153,10 +150,7 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     /// Load a value pair with layout.abi of scalar pair\n-    pub(crate) fn load_scalar_pair(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    ) -> (Value, Value) {\n+    pub(crate) fn load_scalar_pair(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> (Value, Value) {\n         let layout = self.1;\n         match self.0 {\n             CValueInner::ByRef(ptr, None) => {\n@@ -183,7 +177,7 @@ impl<'tcx> CValue<'tcx> {\n \n     pub(crate) fn value_field(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         field: mir::Field,\n     ) -> CValue<'tcx> {\n         let layout = self.1;\n@@ -219,17 +213,13 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n-    pub(crate) fn unsize_value(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-        dest: CPlace<'tcx>,\n-    ) {\n+    pub(crate) fn unsize_value(self, fx: &mut FunctionCx<'_, '_, 'tcx>, dest: CPlace<'tcx>) {\n         crate::unsize::coerce_unsized_into(fx, self, dest);\n     }\n \n     /// If `ty` is signed, `const_val` must already be sign extended.\n     pub(crate) fn const_val(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n         const_val: ty::ScalarInt,\n     ) -> CValue<'tcx> {\n@@ -330,7 +320,7 @@ impl<'tcx> CPlace<'tcx> {\n     }\n \n     pub(crate) fn new_stack_slot(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n         assert!(!layout.is_unsized());\n@@ -352,7 +342,7 @@ impl<'tcx> CPlace<'tcx> {\n     }\n \n     pub(crate) fn new_var(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         local: Local,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n@@ -366,7 +356,7 @@ impl<'tcx> CPlace<'tcx> {\n     }\n \n     pub(crate) fn new_var_pair(\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         local: Local,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n@@ -402,7 +392,7 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n-    pub(crate) fn to_cvalue(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> CValue<'tcx> {\n+    pub(crate) fn to_cvalue(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> CValue<'tcx> {\n         let layout = self.layout();\n         match self.inner {\n             CPlaceInner::Var(_local, var) => {\n@@ -453,32 +443,28 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n-    pub(crate) fn write_cvalue(\n-        self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-        from: CValue<'tcx>,\n-    ) {\n+    pub(crate) fn write_cvalue(self, fx: &mut FunctionCx<'_, '_, 'tcx>, from: CValue<'tcx>) {\n         assert_assignable(fx, from.layout().ty, self.layout().ty);\n \n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue\");\n     }\n \n     pub(crate) fn write_cvalue_transmute(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         from: CValue<'tcx>,\n     ) {\n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue_transmute\");\n     }\n \n     fn write_cvalue_maybe_transmute(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         from: CValue<'tcx>,\n         #[cfg_attr(not(debug_assertions), allow(unused_variables))] method: &'static str,\n     ) {\n         fn transmute_value<'tcx>(\n-            fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+            fx: &mut FunctionCx<'_, '_, 'tcx>,\n             var: Variable,\n             data: Value,\n             dst_ty: Type,\n@@ -638,7 +624,7 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn place_field(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         field: mir::Field,\n     ) -> CPlace<'tcx> {\n         let layout = self.layout();\n@@ -686,7 +672,7 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn place_index(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         index: Value,\n     ) -> CPlace<'tcx> {\n         let (elem_layout, ptr) = match self.layout().ty.kind() {\n@@ -703,7 +689,7 @@ impl<'tcx> CPlace<'tcx> {\n         CPlace::for_ptr(ptr.offset_value(fx, offset), elem_layout)\n     }\n \n-    pub(crate) fn place_deref(self, fx: &mut FunctionCx<'_, 'tcx, impl Module>) -> CPlace<'tcx> {\n+    pub(crate) fn place_deref(self, fx: &mut FunctionCx<'_, '_, 'tcx>) -> CPlace<'tcx> {\n         let inner_layout = fx.layout_of(self.layout().ty.builtin_deref(true).unwrap().ty);\n         if has_ptr_meta(fx.tcx, inner_layout.ty) {\n             let (addr, extra) = self.to_cvalue(fx).load_scalar_pair(fx);\n@@ -718,7 +704,7 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn place_ref(\n         self,\n-        fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n     ) -> CValue<'tcx> {\n         if has_ptr_meta(fx.tcx, self.layout().ty) {\n@@ -735,7 +721,7 @@ impl<'tcx> CPlace<'tcx> {\n \n     pub(crate) fn downcast_variant(\n         self,\n-        fx: &FunctionCx<'_, 'tcx, impl Module>,\n+        fx: &FunctionCx<'_, '_, 'tcx>,\n         variant: VariantIdx,\n     ) -> Self {\n         assert!(!self.layout().is_unsized());\n@@ -749,7 +735,7 @@ impl<'tcx> CPlace<'tcx> {\n \n #[track_caller]\n pub(crate) fn assert_assignable<'tcx>(\n-    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &FunctionCx<'_, '_, 'tcx>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n ) {"}, {"sha": "a1f0aa40f0f16935d6e9b33bf12d18328c60f756", "filename": "src/vtable.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73d3a1c14ad1703644667f8cb0df8e4d316aa4e1/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=73d3a1c14ad1703644667f8cb0df8e4d316aa4e1", "patch": "@@ -15,7 +15,7 @@ fn vtable_memflags() -> MemFlags {\n     flags\n }\n \n-pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -25,7 +25,7 @@ pub(crate) fn drop_fn_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: V\n     )\n }\n \n-pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -35,7 +35,7 @@ pub(crate) fn size_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Valu\n     )\n }\n \n-pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable: Value) -> Value {\n+pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -> Value {\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -46,7 +46,7 @@ pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, impl Module>, vtable:\n }\n \n pub(crate) fn get_ptr_and_method_ref<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     idx: usize,\n ) -> (Value, Value) {\n@@ -68,7 +68,7 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n }\n \n pub(crate) fn get_vtable<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Value {\n@@ -85,7 +85,7 @@ pub(crate) fn get_vtable<'tcx>(\n }\n \n fn build_vtable<'tcx>(\n-    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n     layout: TyAndLayout<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> DataId {\n@@ -94,7 +94,7 @@ fn build_vtable<'tcx>(\n \n     let drop_in_place_fn = import_function(\n         tcx,\n-        &mut fx.cx.module,\n+        fx.cx.module,\n         Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n     );\n \n@@ -111,7 +111,7 @@ fn build_vtable<'tcx>(\n         opt_mth.map(|(def_id, substs)| {\n             import_function(\n                 tcx,\n-                &mut fx.cx.module,\n+                fx.cx.module,\n                 Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs)\n                     .unwrap()\n                     .polymorphize(fx.tcx),"}]}