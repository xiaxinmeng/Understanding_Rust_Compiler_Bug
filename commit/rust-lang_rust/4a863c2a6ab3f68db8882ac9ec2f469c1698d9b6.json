{"sha": "4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhODYzYzJhNmFiM2Y2OGRiODg4MmFjOWVjMmY0NjljMTY5OGQ5YjY=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-23T06:03:59Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-04-23T06:03:59Z"}, "message": "Replace Repr with the new ty::layout in rustc.\n\nLvalues still need work (see lvalue_layout).", "tree": {"sha": "159d257f99a4d7c70b7ac09fd75ef4194a02dd02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/159d257f99a4d7c70b7ac09fd75ef4194a02dd02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6", "html_url": "https://github.com/rust-lang/rust/commit/4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1531bd675c1074c41616826e57b99eb79ff6eb9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1531bd675c1074c41616826e57b99eb79ff6eb9e", "html_url": "https://github.com/rust-lang/rust/commit/1531bd675c1074c41616826e57b99eb79ff6eb9e"}], "stats": {"total": 370, "additions": 134, "deletions": 236}, "files": [{"sha": "546935dee76667b7561d557f012a641b8f4c8bfa", "filename": "src/interpreter.rs", "status": "modified", "additions": 129, "deletions": 181, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6", "patch": "@@ -1,15 +1,14 @@\n-use arena::TypedArena;\n use rustc::infer;\n use rustc::middle::const_val;\n use rustc::hir::def_id::DefId;\n use rustc::mir::mir_map::MirMap;\n use rustc::mir::repr as mir;\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::layout::{self, Layout, Size};\n use rustc::ty::subst::{self, Subst, Substs};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::DefIdMap;\n-use rustc_data_structures::fnv::FnvHashMap;\n use std::cell::RefCell;\n use std::ops::Deref;\n use std::rc::Rc;\n@@ -19,12 +18,12 @@ use syntax::attr;\n use syntax::codemap::{self, DUMMY_SP};\n \n use error::{EvalError, EvalResult};\n-use memory::{FieldRepr, Memory, Pointer, Repr};\n+use memory::{Memory, Pointer};\n use primval::{self, PrimVal};\n \n const TRACE_EXECUTION: bool = false;\n \n-struct Interpreter<'a, 'tcx: 'a, 'arena> {\n+struct Interpreter<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n     tcx: &'a TyCtxt<'tcx>,\n \n@@ -34,12 +33,6 @@ struct Interpreter<'a, 'tcx: 'a, 'arena> {\n     /// A local cache from DefIds to Mir for non-crate-local items.\n     mir_cache: RefCell<DefIdMap<Rc<mir::Mir<'tcx>>>>,\n \n-    /// An arena allocator for type representations.\n-    repr_arena: &'arena TypedArena<Repr>,\n-\n-    /// A cache for in-memory representations of types.\n-    repr_cache: RefCell<FnvHashMap<ty::Ty<'tcx>, &'arena Repr>>,\n-\n     /// The virtual memory system.\n     memory: Memory,\n \n@@ -112,16 +105,12 @@ enum TerminatorTarget {\n     Return,\n }\n \n-impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n-    fn new(tcx: &'a TyCtxt<'tcx>, mir_map: &'a MirMap<'tcx>, repr_arena: &'arena TypedArena<Repr>)\n-        -> Self\n-    {\n+impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n+    fn new(tcx: &'a TyCtxt<'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n         Interpreter {\n             tcx: tcx,\n             mir_map: mir_map,\n             mir_cache: RefCell::new(DefIdMap()),\n-            repr_arena: repr_arena,\n-            repr_cache: RefCell::new(FnvHashMap()),\n             memory: Memory::new(),\n             stack: Vec::new(),\n             substs_stack: Vec::new(),\n@@ -242,7 +231,8 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n                 let discr_ptr = try!(self.eval_lvalue(discr)).to_ptr();\n-                let discr_size = self.lvalue_repr(discr).size();\n+                let discr_size =\n+                    self.lvalue_layout(discr).size(&self.tcx.data_layout).bytes() as usize;\n                 let discr_val = try!(self.memory.read_uint(discr_ptr, discr_size));\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n@@ -262,12 +252,12 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n \n             Switch { ref discr, ref targets, adt_def } => {\n                 let adt_ptr = try!(self.eval_lvalue(discr)).to_ptr();\n-                let adt_repr = self.lvalue_repr(discr);\n-                let discr_size = match *adt_repr {\n-                    Repr::Aggregate { discr_size, .. } => discr_size,\n+                let adt_layout = self.lvalue_layout(discr);\n+                let discr_size = match *adt_layout {\n+                    Layout::General { discr, .. } => discr.size().bytes(),\n                     _ => panic!(\"attmpted to switch on non-aggregate type\"),\n                 };\n-                let discr_val = try!(self.memory.read_uint(adt_ptr, discr_size));\n+                let discr_val = try!(self.memory.read_uint(adt_ptr, discr_size as usize));\n \n                 let matching = adt_def.variants.iter()\n                     .position(|v| discr_val == v.disr_val.to_u64_unchecked());\n@@ -328,13 +318,15 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n                                     let last_arg = args.last().unwrap();\n                                     let last = try!(self.eval_operand(last_arg));\n                                     let last_ty = self.operand_ty(last_arg);\n-                                    let last_repr = self.type_repr(last_ty);\n-                                    match (&last_ty.sty, last_repr) {\n+                                    let last_layout = self.type_layout(last_ty);\n+                                    match (&last_ty.sty, last_layout) {\n                                         (&ty::TyTuple(ref fields),\n-                                         &Repr::Aggregate { discr_size: 0, ref variants, .. }) => {\n-                                            assert_eq!(variants.len(), 1);\n-                                            for (repr, ty) in variants[0].iter().zip(fields) {\n-                                                let src = last.offset(repr.offset as isize);\n+                                         &Layout::Univariant { ref variant, .. }) => {\n+                                            let offsets = iter::once(0)\n+                                                .chain(variant.offset_after_field.iter()\n+                                                    .map(|s| s.bytes()));\n+                                            for (offset, ty) in offsets.zip(fields) {\n+                                                let src = last.offset(offset as isize);\n                                                 arg_srcs.push((src, ty));\n                                             }\n                                         }\n@@ -578,28 +570,17 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n         Ok(TerminatorTarget::Call)\n     }\n \n-    fn assign_to_aggregate(\n+    fn assign_fields<I: IntoIterator<Item = u64>>(\n         &mut self,\n         dest: Pointer,\n-        dest_repr: &Repr,\n-        variant: usize,\n-        discr: Option<u64>,\n+        offsets: I,\n         operands: &[mir::Operand<'tcx>],\n     ) -> EvalResult<()> {\n-        match *dest_repr {\n-            Repr::Aggregate { discr_size, ref variants, .. } => {\n-                if discr_size > 0 {\n-                    try!(self.memory.write_uint(dest, discr.unwrap(), discr_size));\n-                }\n-                let after_discr = dest.offset(discr_size as isize);\n-                for (field, operand) in variants[variant].iter().zip(operands) {\n-                    let src = try!(self.eval_operand(operand));\n-                    let src_ty = self.operand_ty(operand);\n-                    let field_dest = after_discr.offset(field.offset as isize);\n-                    try!(self.move_(src, field_dest, src_ty));\n-                }\n-            }\n-            _ => panic!(\"expected Repr::Aggregate target\"),\n+        for (offset, operand) in offsets.into_iter().zip(operands) {\n+            let src = try!(self.eval_operand(operand));\n+            let src_ty = self.operand_ty(operand);\n+            let field_dest = dest.offset(offset as isize);\n+            try!(self.move_(src, field_dest, src_ty));\n         }\n         Ok(())\n     }\n@@ -609,7 +590,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n     {\n         let dest = try!(self.eval_lvalue(lvalue)).to_ptr();\n         let dest_ty = self.lvalue_ty(lvalue);\n-        let dest_repr = self.lvalue_repr(lvalue);\n+        let dest_layout = self.lvalue_layout(lvalue);\n \n         use rustc::mir::repr::Rvalue::*;\n         match *rvalue {\n@@ -639,39 +620,52 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n             }\n \n             Aggregate(ref kind, ref operands) => {\n-                use rustc::mir::repr::AggregateKind::*;\n-                match *kind {\n-                    Tuple | Closure(..) =>\n-                        try!(self.assign_to_aggregate(dest, &dest_repr, 0, None, operands)),\n-\n-                    Adt(adt_def, variant, _) => {\n-                        let discr = Some(adt_def.variants[variant].disr_val.to_u64_unchecked());\n-                        try!(self.assign_to_aggregate(dest, &dest_repr, variant, discr, operands));\n+                match *dest_layout {\n+                    Layout::Univariant { ref variant, .. } => {\n+                        let offsets = iter::once(0)\n+                            .chain(variant.offset_after_field.iter().map(|s| s.bytes()));\n+                        try!(self.assign_fields(dest, offsets, operands));\n+                    }\n+\n+                    Layout::Array { .. } => {\n+                        let elem_size = match dest_ty.sty {\n+                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty) as u64,\n+                            _ => panic!(\"tried to assign {:?} aggregate to non-array type {:?}\",\n+                                        kind, dest_ty),\n+                        };\n+                        let offsets = (0..).map(|i| i * elem_size);\n+                        try!(self.assign_fields(dest, offsets, operands));\n                     }\n \n-                    Vec => if let Repr::Array { elem_size, length } = *dest_repr {\n-                        assert_eq!(length, operands.len());\n-                        for (i, operand) in operands.iter().enumerate() {\n-                            let src = try!(self.eval_operand(operand));\n-                            let src_ty = self.operand_ty(operand);\n-                            let elem_dest = dest.offset((i * elem_size) as isize);\n-                            try!(self.move_(src, elem_dest, src_ty));\n+                    Layout::General { discr, ref variants, .. } => {\n+                        if let mir::AggregateKind::Adt(adt_def, variant, _) = *kind {\n+                            let discr_val = adt_def.variants[variant].disr_val.to_u64_unchecked();\n+                            let discr_size = discr.size().bytes() as usize;\n+                            try!(self.memory.write_uint(dest, discr_val, discr_size));\n+\n+                            let offsets = variants[variant].offset_after_field.iter()\n+                                .map(|s| s.bytes());\n+                            try!(self.assign_fields(dest, offsets, operands));\n+                        } else {\n+                            panic!(\"tried to assign {:?} aggregate to Layout::General dest\", kind);\n                         }\n-                    } else {\n-                        panic!(\"expected Repr::Array target\");\n-                    },\n+                    }\n+\n+                    _ => panic!(\"can't handle destination layout {:?} when assigning {:?}\",\n+                                dest_layout, kind),\n                 }\n             }\n \n             Repeat(ref operand, _) => {\n-                if let Repr::Array { elem_size, length } = *dest_repr {\n-                    let src = try!(self.eval_operand(operand));\n-                    for i in 0..length {\n-                        let elem_dest = dest.offset((i * elem_size) as isize);\n-                        try!(self.memory.copy(src, elem_dest, elem_size));\n-                    }\n-                } else {\n-                    panic!(\"expected Repr::Array target\");\n+                let (elem_size, length) = match dest_ty.sty {\n+                    ty::TyArray(elem_ty, n) => (self.type_size(elem_ty), n),\n+                    _ => panic!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n+                };\n+\n+                let src = try!(self.eval_operand(operand));\n+                for i in 0..length {\n+                    let elem_dest = dest.offset((i * elem_size) as isize);\n+                    try!(self.memory.copy(src, elem_dest, elem_size));\n                 }\n             }\n \n@@ -731,7 +725,7 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n \n                     Misc => {\n                         // FIXME(tsion): Wrong for almost everything.\n-                        let size = dest_repr.size();\n+                        let size = dest_layout.size(&self.tcx.data_layout).bytes() as usize;\n                         try!(self.memory.copy(src, dest, size));\n                     }\n \n@@ -747,38 +741,41 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n     }\n \n     fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<Pointer> {\n-        self.eval_operand_and_repr(op).map(|(p, _)| p)\n+        self.eval_operand_and_layout(op).map(|(p, _)| p)\n     }\n \n-    fn eval_operand_and_repr(&mut self, op: &mir::Operand<'tcx>)\n-        -> EvalResult<(Pointer, &'arena Repr)>\n+    fn eval_operand_and_layout(&mut self, op: &mir::Operand<'tcx>)\n+        -> EvalResult<(Pointer, &'tcx Layout)>\n     {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n             Consume(ref lvalue) =>\n-                Ok((try!(self.eval_lvalue(lvalue)).to_ptr(), self.lvalue_repr(lvalue))),\n+                Ok((try!(self.eval_lvalue(lvalue)).to_ptr(), self.lvalue_layout(lvalue))),\n             Constant(mir::Constant { ref literal, ty, .. }) => {\n                 use rustc::mir::repr::Literal::*;\n                 match *literal {\n                     Value { ref value } => Ok((\n                         try!(self.const_to_ptr(value)),\n-                        self.type_repr(ty),\n+                        self.type_layout(ty),\n                     )),\n                     Item { .. } => unimplemented!(),\n                 }\n             }\n         }\n     }\n \n-    // TODO(tsion): Replace this inefficient hack with a wrapper like LvalueTy (e.g. LvalueRepr).\n-    fn lvalue_repr(&self, lvalue: &mir::Lvalue<'tcx>) -> &'arena Repr {\n+    // TODO(tsion): Replace this inefficient hack with a wrapper like LvalueTy (e.g. LvalueLayout).\n+    fn lvalue_layout(&self, lvalue: &mir::Lvalue<'tcx>) -> &'tcx Layout {\n         use rustc::mir::tcx::LvalueTy;\n         match self.mir().lvalue_ty(self.tcx, lvalue) {\n-            LvalueTy::Ty { ty } => self.type_repr(ty),\n+            LvalueTy::Ty { ty } => self.type_layout(ty),\n             LvalueTy::Downcast { adt_def, substs, variant_index } => {\n                 let field_tys = adt_def.variants[variant_index].fields.iter()\n                     .map(|f| f.ty(self.tcx, substs));\n-                self.repr_arena.alloc(self.make_aggregate_repr(iter::once(field_tys)))\n+\n+                // FIXME(tsion): Handle LvalueTy::Downcast better somehow...\n+                unimplemented!();\n+                // self.repr_arena.alloc(self.make_aggregate_layout(iter::once(field_tys)))\n             }\n         }\n     }\n@@ -796,21 +793,23 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n \n             Projection(ref proj) => {\n                 let base_ptr = try!(self.eval_lvalue(&proj.base)).to_ptr();\n-                let base_repr = self.lvalue_repr(&proj.base);\n+                let base_layout = self.lvalue_layout(&proj.base);\n                 let base_ty = self.lvalue_ty(&proj.base);\n+\n                 use rustc::mir::repr::ProjectionElem::*;\n                 match proj.elem {\n-                    Field(field, _) => match *base_repr {\n-                        Repr::Aggregate { discr_size: 0, ref variants, .. } => {\n-                            let fields = &variants[0];\n-                            base_ptr.offset(fields[field.index()].offset as isize)\n+                    Field(field, _) => match *base_layout {\n+                        Layout::Univariant { ref variant, .. } => {\n+                            let offset = variant.field_offset(field.index()).bytes();\n+                            base_ptr.offset(offset as isize)\n                         }\n-                        _ => panic!(\"field access on non-product type: {:?}\", base_repr),\n+                        _ => panic!(\"field access on non-product type: {:?}\", base_layout),\n                     },\n \n-                    Downcast(..) => match *base_repr {\n-                        Repr::Aggregate { discr_size, .. } => base_ptr.offset(discr_size as isize),\n-                        _ => panic!(\"variant downcast on non-aggregate type: {:?}\", base_repr),\n+                    Downcast(..) => match *base_layout {\n+                        Layout::General { discr, .. } =>\n+                            base_ptr.offset(discr.size().bytes() as isize),\n+                        _ => panic!(\"variant downcast on non-aggregate type: {:?}\", base_layout),\n                     },\n \n                     Deref => {\n@@ -921,99 +920,17 @@ impl<'a, 'tcx: 'a, 'arena> Interpreter<'a, 'tcx, 'arena> {\n     }\n \n     fn type_size(&self, ty: ty::Ty<'tcx>) -> usize {\n-        self.type_repr(ty).size()\n+        self.type_layout(ty).size(&self.tcx.data_layout).bytes() as usize\n     }\n \n-    fn type_repr(&self, ty: ty::Ty<'tcx>) -> &'arena Repr {\n+    fn type_layout(&self, ty: ty::Ty<'tcx>) -> &'tcx Layout {\n+        // TODO(tsion): Is this inefficient? Needs investigation.\n         let ty = self.monomorphize(ty);\n \n-        if let Some(repr) = self.repr_cache.borrow().get(ty) {\n-            return repr;\n-        }\n-\n-        use syntax::ast::{IntTy, UintTy};\n-        let repr = match ty.sty {\n-            ty::TyBool => Repr::Primitive { size: 1 },\n-\n-            ty::TyInt(IntTy::I8)  | ty::TyUint(UintTy::U8)  => Repr::Primitive { size: 1 },\n-            ty::TyInt(IntTy::I16) | ty::TyUint(UintTy::U16) => Repr::Primitive { size: 2 },\n-            ty::TyInt(IntTy::I32) | ty::TyUint(UintTy::U32) => Repr::Primitive { size: 4 },\n-            ty::TyInt(IntTy::I64) | ty::TyUint(UintTy::U64) => Repr::Primitive { size: 8 },\n-\n-            ty::TyInt(IntTy::Is) | ty::TyUint(UintTy::Us) =>\n-                Repr::Primitive { size: self.memory.pointer_size },\n-\n-            ty::TyTuple(ref fields) =>\n-                self.make_aggregate_repr(iter::once(fields.iter().cloned())),\n-\n-            ty::TyEnum(adt_def, substs) | ty::TyStruct(adt_def, substs) => {\n-                let variants = adt_def.variants.iter().map(|v| {\n-                    v.fields.iter().map(|f| f.ty(self.tcx, substs))\n-                });\n-                self.make_aggregate_repr(variants)\n-            }\n-\n-            ty::TyArray(elem_ty, length) => Repr::Array {\n-                elem_size: self.type_size(elem_ty),\n-                length: length,\n-            },\n-\n-            ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n-            ty::TyBox(ty) => {\n-                if self.type_is_sized(ty) {\n-                    Repr::Primitive { size: self.memory.pointer_size }\n-                } else {\n-                    Repr::Primitive { size: self.memory.pointer_size * 2 }\n-                }\n-            }\n-\n-            ty::TyFnPtr(..) => Repr::Primitive { size: self.memory.pointer_size },\n-\n-            ty::TyClosure(_, ref closure_substs) =>\n-                self.make_aggregate_repr(iter::once(closure_substs.upvar_tys.iter().cloned())),\n-\n-            ref t => panic!(\"can't convert type to repr: {:?}\", t),\n-        };\n-\n-        let repr_ref = self.repr_arena.alloc(repr);\n-        self.repr_cache.borrow_mut().insert(ty, repr_ref);\n-        repr_ref\n-    }\n-\n-    fn make_aggregate_repr<V>(&self, variant_fields: V) -> Repr\n-        where V: IntoIterator, V::Item: IntoIterator<Item = ty::Ty<'tcx>>\n-    {\n-        let mut variants = Vec::new();\n-        let mut max_variant_size = 0;\n-\n-        for field_tys in variant_fields {\n-            let mut fields = Vec::new();\n-            let mut size = 0;\n-\n-            for ty in field_tys {\n-                let field_size = self.type_size(ty);\n-                let offest = size;\n-                size += field_size;\n-                fields.push(FieldRepr { offset: offest, size: field_size });\n-            }\n-\n-            if size > max_variant_size { max_variant_size = size; }\n-            variants.push(fields);\n-        }\n+        let infcx = infer::normalizing_infer_ctxt(self.tcx, &self.tcx.tables, ProjectionMode::Any);\n \n-        let discr_size = match variants.len() as u64 {\n-            n if n <= 1       => 0,\n-            n if n <= 1 << 8  => 1,\n-            n if n <= 1 << 16 => 2,\n-            n if n <= 1 << 32 => 4,\n-            _                 => 8,\n-        };\n-        Repr::Aggregate {\n-            discr_size: discr_size,\n-            size: max_variant_size + discr_size,\n-            variants: variants,\n-        }\n+        // TODO(tsion): Report this error properly.\n+        ty.layout(&infcx).unwrap()\n     }\n \n     pub fn read_primval(&mut self, ptr: Pointer, ty: ty::Ty<'tcx>) -> EvalResult<PrimVal> {\n@@ -1237,8 +1154,7 @@ pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>)\n \n                 println!(\"Interpreting: {}\", item.name);\n \n-                let repr_arena = TypedArena::new();\n-                let mut miri = Interpreter::new(tcx, mir_map, &repr_arena);\n+                let mut miri = Interpreter::new(tcx, mir_map);\n                 let return_ptr = match mir.return_ty {\n                     ty::FnConverging(ty) => {\n                         let size = miri.type_size(ty);\n@@ -1259,3 +1175,35 @@ pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>)\n         }\n     }\n }\n+\n+// TODO(tsion): Upstream these methods into rustc::ty::layout.\n+\n+trait IntegerExt {\n+    fn size(self) -> Size;\n+}\n+\n+impl IntegerExt for layout::Integer {\n+    fn size(self) -> Size {\n+        use rustc::ty::layout::Integer::*;\n+        match self {\n+            I1 | I8 => Size::from_bits(8),\n+            I16 => Size::from_bits(16),\n+            I32 => Size::from_bits(32),\n+            I64 => Size::from_bits(64),\n+        }\n+    }\n+}\n+\n+trait StructExt {\n+    fn field_offset(&self, index: usize) -> Size;\n+}\n+\n+impl StructExt for layout::Struct {\n+    fn field_offset(&self, index: usize) -> Size {\n+        if index == 0 {\n+            Size::from_bytes(0)\n+        } else {\n+            self.offset_after_field[index - 1]\n+        }\n+    }\n+}"}, {"sha": "0bf7dfb87d14c533c2d16db7621308ffa36821c9", "filename": "src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6", "patch": "@@ -8,9 +8,7 @@\n )]\n \n // From rustc.\n-extern crate arena;\n #[macro_use] extern crate rustc;\n-extern crate rustc_data_structures;\n extern crate rustc_mir;\n extern crate syntax;\n "}, {"sha": "9f4e2691bcce572718e3af4c544f91b55b5f5c08", "filename": "src/memory.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6", "patch": "@@ -6,54 +6,6 @@ use std::{fmt, iter, mem, ptr};\n use error::{EvalError, EvalResult};\n use primval::PrimVal;\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Value representations\n-////////////////////////////////////////////////////////////////////////////////\n-\n-#[derive(Clone, Debug, Eq, PartialEq)]\n-pub enum Repr {\n-    /// Representation for a non-aggregate type such as a boolean, integer, character or pointer.\n-    Primitive {\n-        size: usize\n-    },\n-\n-    /// The representation for aggregate types including structs, enums, and tuples.\n-    Aggregate {\n-        /// The size of the discriminant (an integer). Should be between 0 and 8. Always 0 for\n-        /// structs and tuples.\n-        discr_size: usize,\n-\n-        /// The size of the entire aggregate, including the discriminant.\n-        size: usize,\n-\n-        /// The representations of the contents of each variant.\n-        variants: Vec<Vec<FieldRepr>>,\n-    },\n-\n-    Array {\n-        elem_size: usize,\n-\n-        /// Number of elements.\n-        length: usize,\n-    },\n-}\n-\n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub struct FieldRepr {\n-    pub offset: usize,\n-    pub size: usize,\n-}\n-\n-impl Repr {\n-    pub fn size(&self) -> usize {\n-        match *self {\n-            Repr::Primitive { size } => size,\n-            Repr::Aggregate { size, .. } => size,\n-            Repr::Array { elem_size, length } => elem_size * length,\n-        }\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Allocations and pointers\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "d6eddc69fc9a5b5b0d4454b5310528114d193913", "filename": "tests/run-pass/sums.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6/tests%2Frun-pass%2Fsums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6/tests%2Frun-pass%2Fsums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fsums.rs?ref=4a863c2a6ab3f68db8882ac9ec2f469c1698d9b6", "patch": "@@ -2,24 +2,24 @@\n #![allow(dead_code, unused_attributes)]\n \n #[derive(Debug, PartialEq)]\n-enum Unit { Unit }\n+enum Unit { Unit(()) } // Force non-C-enum representation.\n \n #[miri_run]\n fn return_unit() -> Unit {\n-    Unit::Unit\n+    Unit::Unit(())\n }\n \n #[derive(Debug, PartialEq)]\n-enum MyBool { False, True }\n+enum MyBool { False(()), True(()) } // Force non-C-enum representation.\n \n #[miri_run]\n fn return_true() -> MyBool {\n-    MyBool::True\n+    MyBool::True(())\n }\n \n #[miri_run]\n fn return_false() -> MyBool {\n-    MyBool::False\n+    MyBool::False(())\n }\n \n #[miri_run]"}]}