{"sha": "52b835c5e7a68b32a8f0532f178c150d09be200d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYjgzNWM1ZTdhNjhiMzJhOGYwNTMyZjE3OGMxNTBkMDliZTIwMGQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-04T01:41:01Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-09T16:25:58Z"}, "message": "Store metadata separately in rlib files\n\nRight now whenever an rlib file is linked against, all of the metadata from the\nrlib is pulled in to the final staticlib or binary. The reason for this is that\nthe metadata is currently stored in a section of the object file. Note that this\nis intentional for dynamic libraries in order to distribute metadata bundled\nwith static libraries.\n\nThis commit alters the situation for rlib libraries to instead store the\nmetadata in a separate file in the archive. In doing so, when the archive is\npassed to the linker, none of the metadata will get pulled into the result\nexecutable. Furthermore, the metadata file is skipped when assembling rlibs into\nan archive.\n\nThe snag in this implementation comes with multiple output formats. When\ngenerating a dylib, the metadata needs to be in the object file, but when\ngenerating an rlib this needs to be separate. In order to accomplish this, the\nmetadata variable is inserted into an entirely separate LLVM Module which is\nthen codegen'd into a different location (foo.metadata.o). This is then linked\ninto dynamic libraries and silently ignored for rlib files.\n\nWhile changing how metadata is inserted into archives, I have also stopped\ncompressing metadata when inserted into rlib files. We have wanted to stop\ncompressing metadata, but the sections it creates in object file sections are\napparently too large. Thankfully if it's just an arbitrary file it doesn't\nmatter how large it is.\n\nI have seen massive reductions in executable sizes, as well as staticlib output\nsizes (to confirm that this is all working).", "tree": {"sha": "8bb348671eb0bc046cfeb3d233e54003c155b6e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bb348671eb0bc046cfeb3d233e54003c155b6e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52b835c5e7a68b32a8f0532f178c150d09be200d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52b835c5e7a68b32a8f0532f178c150d09be200d", "html_url": "https://github.com/rust-lang/rust/commit/52b835c5e7a68b32a8f0532f178c150d09be200d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52b835c5e7a68b32a8f0532f178c150d09be200d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e0cb316fc980f00e1b74f3fdb7a842b540be280", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e0cb316fc980f00e1b74f3fdb7a842b540be280", "html_url": "https://github.com/rust-lang/rust/commit/4e0cb316fc980f00e1b74f3fdb7a842b540be280"}], "stats": {"total": 234, "additions": 156, "deletions": 78}, "files": [{"sha": "d0225866cbebe0d0dfbded388bc323026bef74ba", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/52b835c5e7a68b32a8f0532f178c150d09be200d/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b835c5e7a68b32a8f0532f178c150d09be200d/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=52b835c5e7a68b32a8f0532f178c150d09be200d", "patch": "@@ -20,6 +20,8 @@ use std::str;\n use extra::tempfile::TempDir;\n use syntax::abi;\n \n+pub static METADATA_FILENAME: &'static str = \"metadata\";\n+\n pub struct Archive {\n     priv sess: Session,\n     priv dst: Path,\n@@ -81,17 +83,22 @@ impl Archive {\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) {\n         let location = self.find_library(name);\n-        self.add_archive(&location, name);\n+        self.add_archive(&location, name, []);\n     }\n \n     /// Adds all of the contents of the rlib at the specified path to this\n     /// archive.\n     pub fn add_rlib(&mut self, rlib: &Path) {\n         let name = rlib.filename_str().unwrap().split('-').next().unwrap();\n-        self.add_archive(rlib, name);\n+        self.add_archive(rlib, name, [METADATA_FILENAME]);\n+    }\n+\n+    /// Adds an arbitrary file to this archive\n+    pub fn add_file(&mut self, file: &Path) {\n+        run_ar(self.sess, \"r\", None, [&self.dst, file]);\n     }\n \n-    fn add_archive(&mut self, archive: &Path, name: &str) {\n+    fn add_archive(&mut self, archive: &Path, name: &str, skip: &[&str]) {\n         let loc = TempDir::new(\"rsar\").unwrap();\n \n         // First, extract the contents of the archive to a temporary directory\n@@ -106,6 +113,7 @@ impl Archive {\n         let mut inputs = ~[];\n         for file in files.iter() {\n             let filename = file.filename_str().unwrap();\n+            if skip.iter().any(|s| *s == filename) { continue }\n             let filename = format!(\"r-{}-{}\", name, filename);\n             let new_filename = file.with_filename(filename);\n             fs::rename(file, &new_filename);"}, {"sha": "cbe2dbebc0619f210b9e1666085b2a4e59774694", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 96, "deletions": 27, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/52b835c5e7a68b32a8f0532f178c150d09be200d/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b835c5e7a68b32a8f0532f178c150d09be200d/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=52b835c5e7a68b32a8f0532f178c150d09be200d", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n \n \n-use back::archive::Archive;\n+use back::archive::{Archive, METADATA_FILENAME};\n use back::rpath;\n+use driver::driver::CrateTranslation;\n use driver::session::Session;\n use driver::session;\n use lib::llvm::llvm;\n@@ -88,10 +89,11 @@ pub mod write {\n     use back::link::{output_type_assembly, output_type_bitcode};\n     use back::link::{output_type_exe, output_type_llvm_assembly};\n     use back::link::{output_type_object};\n+    use driver::driver::CrateTranslation;\n     use driver::session::Session;\n     use driver::session;\n     use lib::llvm::llvm;\n-    use lib::llvm::{ModuleRef, ContextRef};\n+    use lib::llvm::ModuleRef;\n     use lib;\n \n     use std::c_str::ToCStr;\n@@ -101,10 +103,11 @@ pub mod write {\n     use std::str;\n \n     pub fn run_passes(sess: Session,\n-                      llcx: ContextRef,\n-                      llmod: ModuleRef,\n+                      trans: &CrateTranslation,\n                       output_type: output_type,\n                       output: &Path) {\n+        let llmod = trans.module;\n+        let llcx = trans.context;\n         unsafe {\n             llvm::LLVMInitializePasses();\n \n@@ -204,12 +207,23 @@ pub mod write {\n                 })\n             }\n \n-            // Create a codegen-specific pass manager to emit the actual\n-            // assembly or object files. This may not end up getting used,\n-            // but we make it anyway for good measure.\n-            let cpm = llvm::LLVMCreatePassManager();\n-            llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n-            llvm::LLVMRustAddLibraryInfo(cpm, llmod);\n+            // A codegen-specific pass manager is used to generate object\n+            // files for an LLVM module.\n+            //\n+            // Apparently each of these pass managers is a one-shot kind of\n+            // thing, so we create a new one for each type of output. The\n+            // pass manager passed to the closure should be ensured to not\n+            // escape the closure itself, and the manager should only be\n+            // used once.\n+            fn with_codegen(tm: TargetMachineRef, llmod: ModuleRef,\n+                            f: |PassManagerRef|) {\n+                let cpm = llvm::LLVMCreatePassManager();\n+                llvm::LLVMRustAddAnalysisPasses(tm, cpm, llmod);\n+                llvm::LLVMRustAddLibraryInfo(cpm, llmod);\n+                f(cpm);\n+                llvm::LLVMDisposePassManager(cpm);\n+\n+            }\n \n             match output_type {\n                 output_type_none => {}\n@@ -220,20 +234,47 @@ pub mod write {\n                 }\n                 output_type_llvm_assembly => {\n                     output.with_c_str(|output| {\n-                        llvm::LLVMRustPrintModule(cpm, llmod, output)\n+                        with_codegen(tm, llmod, |cpm| {\n+                            llvm::LLVMRustPrintModule(cpm, llmod, output);\n+                        })\n                     })\n                 }\n                 output_type_assembly => {\n-                    WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::AssemblyFile);\n+                    with_codegen(tm, llmod, |cpm| {\n+                        WriteOutputFile(sess, tm, cpm, llmod, output,\n+                                        lib::llvm::AssemblyFile);\n+                    });\n+\n+                    // windows will invoke this function with an assembly output\n+                    // type when it's actually generating an object file. This\n+                    // is because g++ is used to compile the assembly instead of\n+                    // having LLVM directly output an object file. Regardless,\n+                    // in this case, we're going to possibly need a metadata\n+                    // file.\n+                    if sess.opts.output_type != output_type_assembly {\n+                        with_codegen(tm, trans.metadata_module, |cpm| {\n+                            let out = output.with_extension(\"metadata.o\");\n+                            WriteOutputFile(sess, tm, cpm,\n+                                            trans.metadata_module, &out,\n+                                            lib::llvm::ObjectFile);\n+                        })\n+                    }\n                 }\n                 output_type_exe | output_type_object => {\n-                    WriteOutputFile(sess, tm, cpm, llmod, output, lib::llvm::ObjectFile);\n+                    with_codegen(tm, llmod, |cpm| {\n+                        WriteOutputFile(sess, tm, cpm, llmod, output,\n+                                        lib::llvm::ObjectFile);\n+                    });\n+                    with_codegen(tm, trans.metadata_module, |cpm| {\n+                        WriteOutputFile(sess, tm, cpm, trans.metadata_module,\n+                                        &output.with_extension(\"metadata.o\"),\n+                                        lib::llvm::ObjectFile);\n+                    })\n                 }\n             }\n \n-            llvm::LLVMDisposePassManager(cpm);\n-\n             llvm::LLVMRustDisposeTargetMachine(tm);\n+            llvm::LLVMDisposeModule(trans.metadata_module);\n             llvm::LLVMDisposeModule(llmod);\n             llvm::LLVMContextDispose(llcx);\n             if sess.time_llvm_passes() { llvm::LLVMRustPrintPassTimings(); }\n@@ -782,10 +823,9 @@ pub fn get_cc_prog(sess: Session) -> ~str {\n /// Perform the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n pub fn link_binary(sess: Session,\n-                   crate_types: &[~str],\n+                   trans: &CrateTranslation,\n                    obj_filename: &Path,\n-                   out_filename: &Path,\n-                   lm: LinkMeta) {\n+                   out_filename: &Path) {\n     let outputs = if sess.opts.test {\n         // If we're generating a test executable, then ignore all other output\n         // styles at all other locations\n@@ -795,7 +835,7 @@ pub fn link_binary(sess: Session,\n         // look at what was in the crate file itself for generating output\n         // formats.\n         let mut outputs = sess.opts.outputs.clone();\n-        for ty in crate_types.iter() {\n+        for ty in trans.crate_types.iter() {\n             if \"bin\" == *ty {\n                 outputs.push(session::OutputExecutable);\n             } else if \"dylib\" == *ty || \"lib\" == *ty {\n@@ -813,12 +853,13 @@ pub fn link_binary(sess: Session,\n     };\n \n     for output in outputs.move_iter() {\n-        link_binary_output(sess, output, obj_filename, out_filename, lm);\n+        link_binary_output(sess, trans, output, obj_filename, out_filename);\n     }\n \n-    // Remove the temporary object file if we aren't saving temps\n+    // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.save_temps {\n         fs::unlink(obj_filename);\n+        fs::unlink(&obj_filename.with_extension(\"metadata.o\"));\n     }\n }\n \n@@ -832,11 +873,11 @@ fn is_writeable(p: &Path) -> bool {\n }\n \n fn link_binary_output(sess: Session,\n+                      trans: &CrateTranslation,\n                       output: session::OutputStyle,\n                       obj_filename: &Path,\n-                      out_filename: &Path,\n-                      lm: LinkMeta) {\n-    let libname = output_lib_filename(lm);\n+                      out_filename: &Path) {\n+    let libname = output_lib_filename(trans.link);\n     let out_filename = match output {\n         session::OutputRlib => {\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n@@ -874,7 +915,7 @@ fn link_binary_output(sess: Session,\n \n     match output {\n         session::OutputRlib => {\n-            link_rlib(sess, obj_filename, &out_filename);\n+            link_rlib(sess, Some(trans), obj_filename, &out_filename);\n         }\n         session::OutputStaticlib => {\n             link_staticlib(sess, obj_filename, &out_filename);\n@@ -894,9 +935,25 @@ fn link_binary_output(sess: Session,\n // rlib primarily contains the object file of the crate, but it also contains\n // all of the object files from native libraries. This is done by unzipping\n // native libraries and inserting all of the contents into this archive.\n-fn link_rlib(sess: Session, obj_filename: &Path,\n+//\n+// Instead of putting the metadata in an object file section, instead rlibs\n+// contain the metadata in a separate file.\n+fn link_rlib(sess: Session,\n+             trans: Option<&CrateTranslation>, // None == no metadata\n+             obj_filename: &Path,\n              out_filename: &Path) -> Archive {\n     let mut a = Archive::create(sess, out_filename, obj_filename);\n+\n+    match trans {\n+        Some(trans) => {\n+            let metadata = obj_filename.with_filename(METADATA_FILENAME);\n+            fs::File::create(&metadata).write(trans.metadata);\n+            a.add_file(&metadata);\n+            fs::unlink(&metadata);\n+        }\n+        None => {}\n+    }\n+\n     for &(ref l, kind) in cstore::get_used_libraries(sess.cstore).iter() {\n         match kind {\n             cstore::NativeStatic => {\n@@ -916,8 +973,12 @@ fn link_rlib(sess: Session, obj_filename: &Path,\n //\n // Additionally, there's no way for us to link dynamic libraries, so we warn\n // about all dynamic library dependencies that they're not linked in.\n+//\n+// There's no need to include metadata in a static archive, so ensure to not\n+// link in the metadata object file (and also don't prepare the archive with a\n+// metadata file).\n fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n-    let mut a = link_rlib(sess, obj_filename, out_filename);\n+    let mut a = link_rlib(sess, None, obj_filename, out_filename);\n     a.add_native_library(\"morestack\");\n \n     let crates = cstore::get_used_crates(sess.cstore, cstore::RequireStatic);\n@@ -998,6 +1059,14 @@ fn link_args(sess: Session,\n         ~\"-o\", out_filename.as_str().unwrap().to_owned(),\n         obj_filename.as_str().unwrap().to_owned()]);\n \n+    // When linking a dynamic library, we put the metadata into a section of the\n+    // executable. This metadata is in a separate object file from the main\n+    // object file, so we link that in here.\n+    if dylib {\n+        let metadata = obj_filename.with_extension(\"metadata.o\");\n+        args.push(metadata.as_str().unwrap().to_owned());\n+    }\n+\n     if sess.targ_cfg.os == abi::OsLinux {\n         // GNU-style linkers will use this to omit linking to libraries which\n         // don't actually fulfill any relocations, but only for libraries which"}, {"sha": "737bffeea02bf528f94033d0a965ecba647e0da1", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/52b835c5e7a68b32a8f0532f178c150d09be200d/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b835c5e7a68b32a8f0532f178c150d09be200d/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=52b835c5e7a68b32a8f0532f178c150d09be200d", "patch": "@@ -335,8 +335,10 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n pub struct CrateTranslation {\n     context: ContextRef,\n     module: ModuleRef,\n+    metadata_module: ModuleRef,\n     link: LinkMeta,\n     crate_types: ~[~str],\n+    metadata: ~[u8],\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n@@ -362,8 +364,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n \n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             link::write::run_passes(sess,\n-                                    trans.context,\n-                                    trans.module,\n+                                    trans,\n                                     output_type,\n                                     &asm_filename));\n \n@@ -376,8 +377,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n     } else {\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             link::write::run_passes(sess,\n-                                    trans.context,\n-                                    trans.module,\n+                                    trans,\n                                     sess.opts.output_type,\n                                     &outputs.obj_filename));\n     }\n@@ -390,10 +390,9 @@ pub fn phase_6_link_output(sess: Session,\n                            outputs: &OutputFilenames) {\n     time(sess.time_passes(), \"linking\", (), |_|\n          link::link_binary(sess,\n-                           trans.crate_types,\n+                           trans,\n                            &outputs.obj_filename,\n-                           &outputs.out_filename,\n-                           trans.link));\n+                           &outputs.out_filename));\n }\n \n pub fn stop_after_phase_3(sess: Session) -> bool {"}, {"sha": "bf50da3d7892e8b9867dbed90d347a7cf73b0d7b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/52b835c5e7a68b32a8f0532f178c150d09be200d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b835c5e7a68b32a8f0532f178c150d09be200d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=52b835c5e7a68b32a8f0532f178c150d09be200d", "patch": "@@ -21,13 +21,14 @@ use middle::ty;\n use middle::typeck;\n use middle;\n \n+use std::cast;\n use std::hashmap::{HashMap, HashSet};\n-use std::io::{Writer, Seek, Decorator};\n use std::io::mem::MemWriter;\n+use std::io::{Writer, Seek, Decorator};\n use std::str;\n+use std::util;\n use std::vec;\n \n-use extra::flate;\n use extra::serialize::Encodable;\n use extra;\n \n@@ -47,8 +48,6 @@ use syntax::parse::token;\n use syntax;\n use writer = extra::ebml::writer;\n \n-use std::cast;\n-\n // used by astencode:\n type abbrev_map = @mut HashMap<ty::t, tyencode::ty_abbrev>;\n \n@@ -1871,10 +1870,9 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n     // remaining % 4 bytes.\n     wr.write(&[0u8, 0u8, 0u8, 0u8]);\n \n-    let writer_bytes: &mut ~[u8] = wr.inner_mut_ref();\n-\n-    metadata_encoding_version.to_owned() +\n-        flate::deflate_bytes(*writer_bytes)\n+    // This is a horrible thing to do to the outer MemWriter, but thankfully we\n+    // don't use it again so... it's ok right?\n+    return util::replace(wr.inner_mut_ref(), ~[]);\n }\n \n // Get the encoded string for a type"}, {"sha": "5b1385c757973304b47cee38d2db5f2e4191006a", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/52b835c5e7a68b32a8f0532f178c150d09be200d/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b835c5e7a68b32a8f0532f178c150d09be200d/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=52b835c5e7a68b32a8f0532f178c150d09be200d", "patch": "@@ -10,7 +10,7 @@\n \n //! Finds crate binaries and loads their metadata\n \n-use back::archive::Archive;\n+use back::archive::{Archive, METADATA_FILENAME};\n use driver::session::Session;\n use lib::llvm::{False, llvm, ObjectFile, mk_section_iter};\n use metadata::decoder;\n@@ -27,7 +27,6 @@ use syntax::attr::AttrMetaMethods;\n use std::c_str::ToCStr;\n use std::cast;\n use std::io;\n-use std::libc;\n use std::num;\n use std::option;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n@@ -102,8 +101,7 @@ impl Context {\n                     if candidate && existing {\n                         FileMatches\n                     } else if candidate {\n-                        match get_metadata_section(self.sess, self.os, path,\n-                                                   crate_name) {\n+                        match get_metadata_section(self.sess, self.os, path) {\n                             Some(cvec) =>\n                                 if crate_matches(cvec, self.metas, self.hash) {\n                                     debug!(\"found {} with matching metadata\",\n@@ -271,22 +269,15 @@ pub fn metadata_matches(extern_metas: &[@ast::MetaItem],\n     local_metas.iter().all(|needed| attr::contains(extern_metas, *needed))\n }\n \n-fn get_metadata_section(sess: Session, os: Os, filename: &Path,\n-                        crate_name: &str) -> Option<@~[u8]> {\n+fn get_metadata_section(sess: Session, os: Os, filename: &Path) -> Option<@~[u8]> {\n+    if filename.filename_str().unwrap().ends_with(\".rlib\") {\n+        let archive = Archive::open(sess, filename.clone());\n+        return Some(@archive.read(METADATA_FILENAME));\n+    }\n     unsafe {\n-        let mb = if filename.filename_str().unwrap().ends_with(\".rlib\") {\n-            let archive = Archive::open(sess, filename.clone());\n-            let contents = archive.read(crate_name + \".o\");\n-            let ptr = vec::raw::to_ptr(contents);\n-            crate_name.with_c_str(|name| {\n-                llvm::LLVMCreateMemoryBufferWithMemoryRangeCopy(\n-                    ptr as *i8, contents.len() as libc::size_t, name)\n-            })\n-        } else {\n-            filename.with_c_str(|buf| {\n-                llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-            })\n-        };\n+        let mb = filename.with_c_str(|buf| {\n+            llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n+        });\n         if mb as int == 0 { return None }\n         let of = match ObjectFile::new(mb) {\n             Some(of) => of,\n@@ -356,12 +347,7 @@ pub fn list_file_metadata(sess: Session,\n                           os: Os,\n                           path: &Path,\n                           out: @mut io::Writer) {\n-    // guess the crate name from the pathname\n-    let crate_name = path.filename_str().unwrap();\n-    let crate_name = if crate_name.starts_with(\"lib\") {\n-        crate_name.slice_from(3) } else { crate_name };\n-    let crate_name = crate_name.split('-').next().unwrap();\n-    match get_metadata_section(sess, os, path, crate_name) {\n+    match get_metadata_section(sess, os, path) {\n       option::Some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n       option::None => {\n         write!(out, \"could not find metadata in {}.\\n\", path.display())"}, {"sha": "a0bfe402c246a35dc81ce81e417a295b52372057", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/52b835c5e7a68b32a8f0532f178c150d09be200d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b835c5e7a68b32a8f0532f178c150d09be200d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=52b835c5e7a68b32a8f0532f178c150d09be200d", "patch": "@@ -3044,19 +3044,24 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::encode_\n         }\n }\n \n-pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) {\n-    if !*cx.sess.building_library { return; }\n+pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) -> ~[u8] {\n+    use extra::flate;\n+\n+    if !*cx.sess.building_library { return ~[]; }\n \n     let encode_inlined_item: encoder::encode_inlined_item =\n         |ecx, ebml_w, path, ii|\n         astencode::encode_inlined_item(ecx, ebml_w, path, ii, cx.maps);\n \n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n-    let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n+    let metadata = encoder::encode_metadata(encode_parms, crate);\n+    let compressed = encoder::metadata_encoding_version +\n+                        flate::deflate_bytes(metadata);\n+    let llmeta = C_bytes(compressed);\n     let llconst = C_struct([llmeta], false);\n     let mut llglobal = \"rust_metadata\".with_c_str(|buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst).to_ref(), buf)\n+            llvm::LLVMAddGlobal(cx.metadata_llmod, val_ty(llconst).to_ref(), buf)\n         }\n     });\n     unsafe {\n@@ -3069,11 +3074,13 @@ pub fn write_metadata(cx: &CrateContext, crate: &ast::Crate) {\n         let t_ptr_i8 = Type::i8p();\n         llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8.to_ref());\n         let llvm_used = \"llvm.used\".with_c_str(|buf| {\n-            llvm::LLVMAddGlobal(cx.llmod, Type::array(&t_ptr_i8, 1).to_ref(), buf)\n+            llvm::LLVMAddGlobal(cx.metadata_llmod,\n+                                Type::array(&t_ptr_i8, 1).to_ref(), buf)\n         });\n         lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n         llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, [llglobal]));\n     }\n+    return metadata;\n }\n \n pub fn trans_crate(sess: session::Session,\n@@ -3140,7 +3147,7 @@ pub fn trans_crate(sess: session::Session,\n     }\n \n     // Translate the metadata.\n-    write_metadata(ccx, &crate);\n+    let metadata = write_metadata(ccx, &crate);\n     if ccx.sess.trans_stats() {\n         println(\"--- trans stats ---\");\n         println!(\"n_static_tydescs: {}\", ccx.stats.n_static_tydescs);\n@@ -3187,5 +3194,7 @@ pub fn trans_crate(sess: session::Session,\n         module: llmod,\n         link: link_meta,\n         crate_types: crate_types,\n+        metadata_module: ccx.metadata_llmod,\n+        metadata: metadata,\n     };\n }"}, {"sha": "86cbcd48e2c2fac912d526b5f62b933c34e94df6", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/52b835c5e7a68b32a8f0532f178c150d09be200d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b835c5e7a68b32a8f0532f178c150d09be200d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=52b835c5e7a68b32a8f0532f178c150d09be200d", "patch": "@@ -42,6 +42,7 @@ pub struct CrateContext {\n      sess: session::Session,\n      llmod: ModuleRef,\n      llcx: ContextRef,\n+     metadata_llmod: ModuleRef,\n      td: TargetData,\n      tn: TypeNames,\n      externs: ExternMap,\n@@ -134,11 +135,18 @@ impl CrateContext {\n             let llmod = name.with_c_str(|buf| {\n                 llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n             });\n+            let metadata_llmod = format!(\"{}_metadata\", name).with_c_str(|buf| {\n+                llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n+            });\n             let data_layout: &str = sess.targ_cfg.target_strs.data_layout;\n             let targ_triple: &str = sess.targ_cfg.target_strs.target_triple;\n-            data_layout.with_c_str(|buf| llvm::LLVMSetDataLayout(llmod, buf));\n+            data_layout.with_c_str(|buf| {\n+                llvm::LLVMSetDataLayout(llmod, buf);\n+                llvm::LLVMSetDataLayout(metadata_llmod, buf);\n+            });\n             targ_triple.with_c_str(|buf| {\n-                llvm::LLVMRustSetNormalizedTarget(llmod, buf)\n+                llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n+                llvm::LLVMRustSetNormalizedTarget(metadata_llmod, buf);\n             });\n             let targ_cfg = sess.targ_cfg;\n \n@@ -174,6 +182,7 @@ impl CrateContext {\n                   sess: sess,\n                   llmod: llmod,\n                   llcx: llcx,\n+                  metadata_llmod: metadata_llmod,\n                   td: td,\n                   tn: tn,\n                   externs: HashMap::new(),"}]}