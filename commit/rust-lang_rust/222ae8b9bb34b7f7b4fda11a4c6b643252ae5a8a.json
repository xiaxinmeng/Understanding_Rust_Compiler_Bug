{"sha": "222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyMmFlOGI5YmIzNGI3ZjdiNGZkYTExYTRjNmI2NDMyNTJhZTVhOGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-18T00:47:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-18T00:47:22Z"}, "message": "auto merge of #17815 : typelist/rust/recursive-structs, r=brson\n\nThe representability-checking routine ```is_type_representable``` failed to detect structural recursion in some cases, leading to stack overflow later on.\r\n\r\nThe first problem was in the loop in the ```find_nonrepresentable``` function. We were improperly terminating the iteration if we saw a ```ContainsRecursive``` condition. We should have kept going in case a later member of the struct (or enum, etc) being examined was ```SelfRecursive```. The example from #17431 triggered this issue:\r\n\r\n```rust\r\nuse std::sync::Mutex;\r\nstruct Foo { foo: Mutex<Option<Foo>> }\r\nimpl Foo { fn bar(self) {} }\r\nfn main() {}\r\n```\r\n\r\nI'm not 100% sure, but I think the ```ty_enum``` case of ```fn type_structurally_recursive``` had a similar problem, since it could ```break``` on ```ContainsRecursive``` before looking at all variants. I've replaced this with a ```flat_map``` call.\r\n\r\nThe second problem was that we were failing to identify code like ```struct Foo { foo: Option<Option<Foo>> }``` as SelfRecursive, even though we correctly identified ```struct Foo { foo: Option<Foo> }```. This was caused by using DefId's for the ```ContainsRecursive``` check, which meant the nested ```Option```s were identified as illegally recursive (because ```ContainsRecursive``` is not an error, we would then keep compiling and eventually hit a stack overflow).\r\n\r\nIn order to make sure that we can recurse through the different ```Option``` invocations, I've changed the type of ```seen``` from ```Vec<DefId>``` to ```Vec<t>``` and added a separate ```same_type``` function to check whether two types are the same when generics are taken into account. Now we only return ```ContainsRecursive``` when this stricter check is satisfied. (There's probably a better way to do this, and I'm not sure my code is entirely correct--but my knowledge of rustc internals is pretty limited, so any help here would be appreciated!)\r\n\r\nNote that the ```SelfRecursive``` check is still comparing ```DefId```s--this is necessary to prevent code like this from being allowed:\r\n\r\n```rust\r\nstruct Foo { x: Bar<Foo> }\r\nstruct Bar<T> { x: Bar<Foo> }\r\n```\r\n\r\nAll four of the new ```issue-17431``` tests cause infinite recursion on master, and errors with this pull request. I wrote the extra ```issue-3008-4.rs``` test to make sure I wasn't introducing a regression.\r\n\r\nFixes #17431.", "tree": {"sha": "99f342f7e56c1a8de1e3b2905001dfeccb1ff24c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99f342f7e56c1a8de1e3b2905001dfeccb1ff24c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a", "html_url": "https://github.com/rust-lang/rust/commit/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b80efd74eb1246189aa256c76b4e2ece4410969", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b80efd74eb1246189aa256c76b4e2ece4410969", "html_url": "https://github.com/rust-lang/rust/commit/9b80efd74eb1246189aa256c76b4e2ece4410969"}, {"sha": "53ddf2e57d59387443a062c4f4348801dea0c9dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/53ddf2e57d59387443a062c4f4348801dea0c9dd", "html_url": "https://github.com/rust-lang/rust/commit/53ddf2e57d59387443a062c4f4348801dea0c9dd"}], "stats": {"total": 302, "additions": 240, "deletions": 62}, "files": [{"sha": "0a5691541f1e09b6ce7b7c25e6fe84c64e46c14f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 117, "deletions": 62, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a", "patch": "@@ -2792,99 +2792,151 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n /// distinguish between types that are recursive with themselves and types that\n /// contain a different recursive type. These cases can therefore be treated\n /// differently when reporting errors.\n-#[deriving(PartialEq)]\n+///\n+/// The ordering of the cases is significant. They are sorted so that cmp::max\n+/// will keep the \"more erroneous\" of two values.\n+#[deriving(PartialOrd, Ord, Eq, PartialEq, Show)]\n pub enum Representability {\n     Representable,\n-    SelfRecursive,\n     ContainsRecursive,\n+    SelfRecursive,\n }\n \n /// Check whether a type is representable. This means it cannot contain unboxed\n /// structural recursion. This check is needed for structs and enums.\n pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n \n     // Iterate until something non-representable is found\n-    fn find_nonrepresentable<It: Iterator<t>>(cx: &ctxt, sp: Span, seen: &mut Vec<DefId>,\n+    fn find_nonrepresentable<It: Iterator<t>>(cx: &ctxt, sp: Span, seen: &mut Vec<t>,\n                                               mut iter: It) -> Representability {\n-        for ty in iter {\n-            let r = type_structurally_recursive(cx, sp, seen, ty);\n-            if r != Representable {\n-                 return r\n-            }\n-        }\n-        Representable\n+        iter.fold(Representable,\n+                  |r, ty| cmp::max(r, is_type_structurally_recursive(cx, sp, seen, ty)))\n     }\n \n-    // Does the type `ty` directly (without indirection through a pointer)\n-    // contain any types on stack `seen`?\n-    fn type_structurally_recursive(cx: &ctxt, sp: Span, seen: &mut Vec<DefId>,\n-                                   ty: t) -> Representability {\n-        debug!(\"type_structurally_recursive: {}\",\n-               ::util::ppaux::ty_to_string(cx, ty));\n-\n-        // Compare current type to previously seen types\n-        match get(ty).sty {\n-            ty_struct(did, _) |\n-            ty_enum(did, _) => {\n-                for (i, &seen_did) in seen.iter().enumerate() {\n-                    if did == seen_did {\n-                        return if i == 0 { SelfRecursive }\n-                               else { ContainsRecursive }\n-                    }\n-                }\n-            }\n-            _ => (),\n-        }\n-\n-        // Check inner types\n+    fn are_inner_types_recursive(cx: &ctxt, sp: Span,\n+                                 seen: &mut Vec<t>, ty: t) -> Representability {\n         match get(ty).sty {\n-            // Tuples\n             ty_tup(ref ts) => {\n                 find_nonrepresentable(cx, sp, seen, ts.iter().map(|t| *t))\n             }\n             // Fixed-length vectors.\n             // FIXME(#11924) Behavior undecided for zero-length vectors.\n             ty_vec(ty, Some(_)) => {\n-                type_structurally_recursive(cx, sp, seen, ty)\n+                is_type_structurally_recursive(cx, sp, seen, ty)\n             }\n-\n-            // Push struct and enum def-ids onto `seen` before recursing.\n             ty_struct(did, ref substs) => {\n-                seen.push(did);\n                 let fields = struct_fields(cx, did, substs);\n-                let r = find_nonrepresentable(cx, sp, seen,\n-                                              fields.iter().map(|f| f.mt.ty));\n-                seen.pop();\n-                r\n+                find_nonrepresentable(cx, sp, seen, fields.iter().map(|f| f.mt.ty))\n             }\n-\n             ty_enum(did, ref substs) => {\n-                seen.push(did);\n                 let vs = enum_variants(cx, did);\n+                let iter = vs.iter()\n+                    .flat_map(|variant| { variant.args.iter() })\n+                    .map(|aty| { aty.subst_spanned(cx, substs, Some(sp)) });\n \n-                let mut r = Representable;\n-                for variant in vs.iter() {\n-                    let iter = variant.args.iter().map(|aty| {\n-                        aty.subst_spanned(cx, substs, Some(sp))\n-                    });\n-                    r = find_nonrepresentable(cx, sp, seen, iter);\n+                find_nonrepresentable(cx, sp, seen, iter)\n+            }\n+            ty_unboxed_closure(did, _) => {\n+                let upvars = unboxed_closure_upvars(cx, did);\n+                find_nonrepresentable(cx, sp, seen, upvars.iter().map(|f| f.ty))\n+            }\n+            _ => Representable,\n+        }\n+    }\n \n-                    if r != Representable { break }\n+    fn same_struct_or_enum_def_id(ty: t, did: DefId) -> bool {\n+        match get(ty).sty {\n+            ty_struct(ty_did, _) | ty_enum(ty_did, _) => {\n+                 ty_did == did\n+            }\n+            _ => false\n+        }\n+    }\n+\n+    fn same_type(a: t, b: t) -> bool {\n+        match (&get(a).sty, &get(b).sty) {\n+            (&ty_struct(did_a, ref substs_a), &ty_struct(did_b, ref substs_b)) |\n+            (&ty_enum(did_a, ref substs_a), &ty_enum(did_b, ref substs_b)) => {\n+                if did_a != did_b {\n+                    return false;\n                 }\n \n-                seen.pop();\n-                r\n-            }\n+                let types_a = substs_a.types.get_slice(subst::TypeSpace);\n+                let types_b = substs_b.types.get_slice(subst::TypeSpace);\n \n-            ty_unboxed_closure(did, _) => {\n-                let upvars = unboxed_closure_upvars(cx, did);\n-                find_nonrepresentable(cx,\n-                                      sp,\n-                                      seen,\n-                                      upvars.iter().map(|f| f.ty))\n+                let mut pairs = types_a.iter().zip(types_b.iter());\n+\n+                pairs.all(|(&a, &b)| same_type(a, b))\n+            }\n+            _ => {\n+                type_id(a) == type_id(b)\n             }\n+        }\n+    }\n \n-            _ => Representable,\n+    // Does the type `ty` directly (without indirection through a pointer)\n+    // contain any types on stack `seen`?\n+    fn is_type_structurally_recursive(cx: &ctxt, sp: Span, seen: &mut Vec<t>,\n+                                      ty: t) -> Representability {\n+        debug!(\"is_type_structurally_recursive: {}\",\n+               ::util::ppaux::ty_to_string(cx, ty));\n+\n+        match get(ty).sty {\n+            ty_struct(did, _) | ty_enum(did, _) => {\n+                {\n+                    // Iterate through stack of previously seen types.\n+                    let mut iter = seen.iter();\n+\n+                    // The first item in `seen` is the type we are actually curious about.\n+                    // We want to return SelfRecursive if this type contains itself.\n+                    // It is important that we DON'T take generic parameters into account\n+                    // for this check, so that Bar<T> in this example counts as SelfRecursive:\n+                    //\n+                    // struct Foo;\n+                    // struct Bar<T> { x: Bar<Foo> }\n+\n+                    match iter.next() {\n+                        Some(&seen_type) => {\n+                            if same_struct_or_enum_def_id(seen_type, did) {\n+                                debug!(\"SelfRecursive: {} contains {}\",\n+                                       ::util::ppaux::ty_to_string(cx, seen_type),\n+                                       ::util::ppaux::ty_to_string(cx, ty));\n+                                return SelfRecursive;\n+                            }\n+                        }\n+                        None => {}\n+                    }\n+\n+                    // We also need to know whether the first item contains other types that\n+                    // are structurally recursive. If we don't catch this case, we will recurse\n+                    // infinitely for some inputs.\n+                    //\n+                    // It is important that we DO take generic parameters into account here,\n+                    // so that code like this is considered SelfRecursive, not ContainsRecursive:\n+                    //\n+                    // struct Foo { Option<Option<Foo>> }\n+\n+                    for &seen_type in iter {\n+                        if same_type(ty, seen_type) {\n+                            debug!(\"ContainsRecursive: {} contains {}\",\n+                                   ::util::ppaux::ty_to_string(cx, seen_type),\n+                                   ::util::ppaux::ty_to_string(cx, ty));\n+                            return ContainsRecursive;\n+                        }\n+                    }\n+                }\n+\n+                // For structs and enums, track all previously seen types by pushing them\n+                // onto the 'seen' stack.\n+                seen.push(ty);\n+                let out = are_inner_types_recursive(cx, sp, seen, ty);\n+                seen.pop();\n+                out\n+            }\n+            _ => {\n+                // No need to push in other cases.\n+                are_inner_types_recursive(cx, sp, seen, ty)\n+            }\n         }\n     }\n \n@@ -2894,8 +2946,11 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n     // To avoid a stack overflow when checking an enum variant or struct that\n     // contains a different, structurally recursive type, maintain a stack\n     // of seen types and check recursion for each of them (issues #3008, #3779).\n-    let mut seen: Vec<DefId> = Vec::new();\n-    type_structurally_recursive(cx, sp, &mut seen, ty)\n+    let mut seen: Vec<t> = Vec::new();\n+    let r = is_type_structurally_recursive(cx, sp, &mut seen, ty);\n+    debug!(\"is_type_representable: {} is {}\",\n+           ::util::ppaux::ty_to_string(cx, ty), r);\n+    r\n }\n \n pub fn type_is_trait(ty: t) -> bool {"}, {"sha": "896a9c06873e97c877b7a392c27834283ce7a169", "filename": "src/test/compile-fail/issue-17431-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-17431-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-17431-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-1.rs?ref=222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo { foo: Option<Option<Foo>> }\n+//~^ ERROR illegal recursive struct type; wrap the inner value in a box to make it representable\n+\n+impl Foo { fn bar(&self) {} }\n+\n+fn main() {}"}, {"sha": "886fe8d771a8cda13d0e30ed4e74e34f660a56f5", "filename": "src/test/compile-fail/issue-17431-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-17431-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-17431-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-2.rs?ref=222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Baz { q: Option<Foo> }\n+//~^ ERROR illegal recursive struct type; wrap the inner value in a box to make it representable\n+\n+struct Foo { q: Option<Baz> }\n+//~^ ERROR illegal recursive struct type; wrap the inner value in a box to make it representable\n+\n+impl Foo { fn bar(&self) {} }\n+\n+fn main() {}"}, {"sha": "c1c450935f6cb6e90ec33b477a2e17f3010c73a8", "filename": "src/test/compile-fail/issue-17431-3.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-17431-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-17431-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-3.rs?ref=222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::sync::Mutex;\n+\n+struct Foo { foo: Mutex<Option<Foo>> }\n+//~^ ERROR illegal recursive struct type; wrap the inner value in a box to make it representable\n+\n+impl Foo { fn bar(&self) {} }\n+\n+fn main() {}"}, {"sha": "1e27f02556470cccff1e6e1d01b0f57ecfc5abc8", "filename": "src/test/compile-fail/issue-17431-4.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-17431-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-17431-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-4.rs?ref=222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo<T> { foo: Option<Option<Foo<T>>> }\n+//~^ ERROR illegal recursive struct type; wrap the inner value in a box to make it representable\n+\n+impl<T> Foo<T> { fn bar(&self) {} }\n+\n+fn main() {}"}, {"sha": "d22d79ecaa5508d87ffbda69f54d8d6fa7017d57", "filename": "src/test/compile-fail/issue-17431-5.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-17431-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-17431-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-5.rs?ref=222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo { foo: Bar<Foo> }\n+struct Bar<T> { x: Bar<Foo> }\n+//~^ ERROR illegal recursive struct type; wrap the inner value in a box to make it representable\n+\n+impl Foo { fn foo(&self) {} }\n+\n+fn main() {\n+}"}, {"sha": "8eac295353d27a367c8d99d339498d98c1f5b331", "filename": "src/test/compile-fail/issue-17431-6.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-17431-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-17431-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-6.rs?ref=222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::sync::Mutex;\n+\n+enum Foo { X(Mutex<Option<Foo>>) }\n+//~^ ERROR illegal recursive enum type; wrap the inner value in a box to make it representable\n+\n+impl Foo { fn bar(self) {} }\n+\n+fn main() {}"}, {"sha": "c64c040aa44cba1b3227384e04e697233af056ef", "filename": "src/test/compile-fail/issue-17431-7.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-17431-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-17431-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-7.rs?ref=222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Foo { Voo(Option<Option<Foo>>) }\n+//~^ ERROR illegal recursive enum type; wrap the inner value in a box to make it representable\n+\n+impl Foo { fn bar(&self) {} }\n+\n+fn main() { }"}, {"sha": "a338a01690dea0d8f412bbab471ef2adbc243d3e", "filename": "src/test/compile-fail/issue-3008-3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-3008-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a/src%2Ftest%2Fcompile-fail%2Fissue-3008-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-3.rs?ref=222ae8b9bb34b7f7b4fda11a4c6b643252ae5a8a", "patch": "@@ -12,5 +12,7 @@ enum E1 { V1(E2<E1>), }\n enum E2<T> { V2(E2<E1>), }\n //~^ ERROR illegal recursive enum type; wrap the inner value in a box to make it representable\n \n+impl E1 { fn foo(&self) {} }\n+\n fn main() {\n }"}]}