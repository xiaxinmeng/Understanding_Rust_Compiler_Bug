{"sha": "7e7bc060c1564b19742fd241f40a02c9210e445c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlN2JjMDYwYzE1NjRiMTk3NDJmZDI0MWY0MGEwMmM5MjEwZTQ0NWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-29T09:58:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-29T09:58:09Z"}, "message": "Auto merge of #54554 - RalfJung:maybe-uninit, r=nagisa\n\nRevert most of MaybeUninit, except for the new API itself\n\nThis reverts most of https://github.com/rust-lang/rust/pull/53508/ for perf reasons (first commit reverts that entire PR), except for the new API itself (added back in 2nd commit).", "tree": {"sha": "02fced39e6b1d39695f9c896951cbfcef1ce9e23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02fced39e6b1d39695f9c896951cbfcef1ce9e23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e7bc060c1564b19742fd241f40a02c9210e445c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e7bc060c1564b19742fd241f40a02c9210e445c", "html_url": "https://github.com/rust-lang/rust/commit/7e7bc060c1564b19742fd241f40a02c9210e445c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e7bc060c1564b19742fd241f40a02c9210e445c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d95fd2585d8d7327a83beee10d9e32129b26cd68", "url": "https://api.github.com/repos/rust-lang/rust/commits/d95fd2585d8d7327a83beee10d9e32129b26cd68", "html_url": "https://github.com/rust-lang/rust/commit/d95fd2585d8d7327a83beee10d9e32129b26cd68"}, {"sha": "546e45ab5b20b9151b3331c727ecb5fd2e3eecaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/546e45ab5b20b9151b3331c727ecb5fd2e3eecaf", "html_url": "https://github.com/rust-lang/rust/commit/546e45ab5b20b9151b3331c727ecb5fd2e3eecaf"}], "stats": {"total": 339, "additions": 85, "deletions": 254}, "files": [{"sha": "216915dba5fe7c03116d1cf2906afd7bbafe392f", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -322,11 +322,8 @@ def to_string(self):\n     def children(self):\n         (length, data_ptr) = \\\n             rustpp.extract_length_and_ptr_from_std_btreeset(self.__val)\n-        leaf_node = GdbValue(data_ptr.get_wrapped_value().dereference())\n-        maybe_uninit_keys = leaf_node.get_child_at_index(3)\n-        manually_drop_keys = maybe_uninit_keys.get_child_at_index(1)\n-        keys = manually_drop_keys.get_child_at_index(0)\n-        gdb_ptr = keys.get_wrapped_value()\n+        val = GdbValue(data_ptr.get_wrapped_value().dereference()).get_child_at_index(3)\n+        gdb_ptr = val.get_wrapped_value()\n         for index in xrange(length):\n             yield (str(index), gdb_ptr[index])\n \n@@ -348,14 +345,9 @@ def to_string(self):\n     def children(self):\n         (length, data_ptr) = \\\n             rustpp.extract_length_and_ptr_from_std_btreemap(self.__val)\n-        leaf_node = GdbValue(data_ptr.get_wrapped_value().dereference())\n-        maybe_uninit_keys = leaf_node.get_child_at_index(3)\n-        manually_drop_keys = maybe_uninit_keys.get_child_at_index(1)\n-        keys = manually_drop_keys.get_child_at_index(0)\n+        keys = GdbValue(data_ptr.get_wrapped_value().dereference()).get_child_at_index(3)\n         keys_ptr = keys.get_wrapped_value()\n-        maybe_uninit_vals = leaf_node.get_child_at_index(4)\n-        manually_drop_vals = maybe_uninit_vals.get_child_at_index(1)\n-        vals = manually_drop_vals.get_child_at_index(0)\n+        vals = GdbValue(data_ptr.get_wrapped_value().dereference()).get_child_at_index(4)\n         vals_ptr = vals.get_wrapped_value()\n         for index in xrange(length):\n             yield (str(index), keys_ptr[index])"}, {"sha": "0315545262b6bc0a295953f22b4328070223356b", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -42,7 +42,7 @@\n //   This implies that even an empty internal node has at least one edge.\n \n use core::marker::PhantomData;\n-use core::mem::{self, MaybeUninit};\n+use core::mem;\n use core::ptr::{self, Unique, NonNull};\n use core::slice;\n \n@@ -73,7 +73,7 @@ struct LeafNode<K, V> {\n     /// This node's index into the parent node's `edges` array.\n     /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n     /// This is only guaranteed to be initialized when `parent` is nonnull.\n-    parent_idx: MaybeUninit<u16>,\n+    parent_idx: u16,\n \n     /// The number of keys and values this node stores.\n     ///\n@@ -83,8 +83,8 @@ struct LeafNode<K, V> {\n \n     /// The arrays storing the actual data of the node. Only the first `len` elements of each\n     /// array are initialized and valid.\n-    keys: MaybeUninit<[K; CAPACITY]>,\n-    vals: MaybeUninit<[V; CAPACITY]>,\n+    keys: [K; CAPACITY],\n+    vals: [V; CAPACITY],\n }\n \n impl<K, V> LeafNode<K, V> {\n@@ -94,10 +94,10 @@ impl<K, V> LeafNode<K, V> {\n         LeafNode {\n             // As a general policy, we leave fields uninitialized if they can be, as this should\n             // be both slightly faster and easier to track in Valgrind.\n-            keys: MaybeUninit::uninitialized(),\n-            vals: MaybeUninit::uninitialized(),\n+            keys: mem::uninitialized(),\n+            vals: mem::uninitialized(),\n             parent: ptr::null(),\n-            parent_idx: MaybeUninit::uninitialized(),\n+            parent_idx: mem::uninitialized(),\n             len: 0\n         }\n     }\n@@ -115,10 +115,10 @@ unsafe impl Sync for LeafNode<(), ()> {}\n // ever take a pointer past the first key.\n static EMPTY_ROOT_NODE: LeafNode<(), ()> = LeafNode {\n     parent: ptr::null(),\n-    parent_idx: MaybeUninit::uninitialized(),\n+    parent_idx: 0,\n     len: 0,\n-    keys: MaybeUninit::uninitialized(),\n-    vals: MaybeUninit::uninitialized(),\n+    keys: [(); CAPACITY],\n+    vals: [(); CAPACITY],\n };\n \n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n@@ -430,7 +430,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n                     root: self.root,\n                     _marker: PhantomData\n                 },\n-                idx: unsafe { usize::from(*self.as_leaf().parent_idx.get_ref()) },\n+                idx: self.as_leaf().parent_idx as usize,\n                 _marker: PhantomData\n             })\n         } else {\n@@ -567,7 +567,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n             // the node, which is allowed by LLVM.\n             unsafe {\n                 slice::from_raw_parts(\n-                    self.as_leaf().keys.as_ptr() as *const K,\n+                    self.as_leaf().keys.as_ptr(),\n                     self.len()\n                 )\n             }\n@@ -578,7 +578,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n         debug_assert!(!self.is_shared_root());\n         unsafe {\n             slice::from_raw_parts(\n-                self.as_leaf().vals.as_ptr() as *const V,\n+                self.as_leaf().vals.as_ptr(),\n                 self.len()\n             )\n         }\n@@ -605,7 +605,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         } else {\n             unsafe {\n                 slice::from_raw_parts_mut(\n-                    self.as_leaf_mut().keys.get_mut() as *mut [K] as *mut K,\n+                    &mut self.as_leaf_mut().keys as *mut [K] as *mut K,\n                     self.len()\n                 )\n             }\n@@ -616,7 +616,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         debug_assert!(!self.is_shared_root());\n         unsafe {\n             slice::from_raw_parts_mut(\n-                self.as_leaf_mut().vals.get_mut() as *mut [V] as *mut V,\n+                &mut self.as_leaf_mut().vals as *mut [V] as *mut V,\n                 self.len()\n             )\n         }\n@@ -1013,7 +1013,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         let ptr = self.node.as_internal_mut() as *mut _;\n         let mut child = self.descend();\n         child.as_leaf_mut().parent = ptr;\n-        child.as_leaf_mut().parent_idx.set(idx);\n+        child.as_leaf_mut().parent_idx = idx;\n     }\n \n     /// Unsafely asserts to the compiler some static information about whether the underlying\n@@ -1152,12 +1152,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n \n             ptr::copy_nonoverlapping(\n                 self.node.keys().as_ptr().add(self.idx + 1),\n-                new_node.keys.as_mut_ptr() as *mut K,\n+                new_node.keys.as_mut_ptr(),\n                 new_len\n             );\n             ptr::copy_nonoverlapping(\n                 self.node.vals().as_ptr().add(self.idx + 1),\n-                new_node.vals.as_mut_ptr() as *mut V,\n+                new_node.vals.as_mut_ptr(),\n                 new_len\n             );\n \n@@ -1210,12 +1210,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n             ptr::copy_nonoverlapping(\n                 self.node.keys().as_ptr().add(self.idx + 1),\n-                new_node.data.keys.as_mut_ptr() as *mut K,\n+                new_node.data.keys.as_mut_ptr(),\n                 new_len\n             );\n             ptr::copy_nonoverlapping(\n                 self.node.vals().as_ptr().add(self.idx + 1),\n-                new_node.data.vals.as_mut_ptr() as *mut V,\n+                new_node.data.vals.as_mut_ptr(),\n                 new_len\n             );\n             ptr::copy_nonoverlapping("}, {"sha": "f92075cc84e509a739ad3ef8984c77d2f1f27437", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -120,7 +120,6 @@\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n-#![feature(maybe_uninit)]\n \n // Allow testing this library\n "}, {"sha": "03e7a9a49d8a763da0c6772b678ab23cba06ceb6", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use fmt::{Formatter, Result, LowerExp, UpperExp, Display, Debug};\n-use mem::MaybeUninit;\n+use mem;\n use num::flt2dec;\n \n // Don't inline this so callers don't use the stack space this function\n@@ -20,11 +20,11 @@ fn float_to_decimal_common_exact<T>(fmt: &mut Formatter, num: &T,\n     where T: flt2dec::DecodableFloat\n {\n     unsafe {\n-        let mut buf = MaybeUninit::<[u8; 1024]>::uninitialized(); // enough for f32 and f64\n-        let mut parts = MaybeUninit::<[flt2dec::Part; 4]>::uninitialized();\n+        let mut buf: [u8; 1024] = mem::uninitialized(); // enough for f32 and f64\n+        let mut parts: [flt2dec::Part; 4] = mem::uninitialized();\n         let formatted = flt2dec::to_exact_fixed_str(flt2dec::strategy::grisu::format_exact,\n                                                     *num, sign, precision,\n-                                                    false, buf.get_mut(), parts.get_mut());\n+                                                    false, &mut buf, &mut parts);\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n@@ -38,11 +38,10 @@ fn float_to_decimal_common_shortest<T>(fmt: &mut Formatter, num: &T,\n {\n     unsafe {\n         // enough for f32 and f64\n-        let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninitialized();\n-        let mut parts = MaybeUninit::<[flt2dec::Part; 4]>::uninitialized();\n+        let mut buf: [u8; flt2dec::MAX_SIG_DIGITS] = mem::uninitialized();\n+        let mut parts: [flt2dec::Part; 4] = mem::uninitialized();\n         let formatted = flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest, *num,\n-                                                 sign, precision, false, buf.get_mut(),\n-                                                 parts.get_mut());\n+                                                 sign, precision, false, &mut buf, &mut parts);\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n@@ -76,11 +75,11 @@ fn float_to_exponential_common_exact<T>(fmt: &mut Formatter, num: &T,\n     where T: flt2dec::DecodableFloat\n {\n     unsafe {\n-        let mut buf = MaybeUninit::<[u8; 1024]>::uninitialized(); // enough for f32 and f64\n-        let mut parts = MaybeUninit::<[flt2dec::Part; 6]>::uninitialized();\n+        let mut buf: [u8; 1024] = mem::uninitialized(); // enough for f32 and f64\n+        let mut parts: [flt2dec::Part; 6] = mem::uninitialized();\n         let formatted = flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact,\n                                                   *num, sign, precision,\n-                                                  upper, buf.get_mut(), parts.get_mut());\n+                                                  upper, &mut buf, &mut parts);\n         fmt.pad_formatted_parts(&formatted)\n     }\n }\n@@ -95,11 +94,11 @@ fn float_to_exponential_common_shortest<T>(fmt: &mut Formatter,\n {\n     unsafe {\n         // enough for f32 and f64\n-        let mut buf = MaybeUninit::<[u8; flt2dec::MAX_SIG_DIGITS]>::uninitialized();\n-        let mut parts = MaybeUninit::<[flt2dec::Part; 6]>::uninitialized();\n+        let mut buf: [u8; flt2dec::MAX_SIG_DIGITS] = mem::uninitialized();\n+        let mut parts: [flt2dec::Part; 6] = mem::uninitialized();\n         let formatted = flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest,\n                                                      *num, sign, (0, 0), upper,\n-                                                     buf.get_mut(), parts.get_mut());\n+                                                     &mut buf, &mut parts);\n         fmt.pad_formatted_parts(&formatted)\n     }\n }"}, {"sha": "675e73e952cc2ca011c055a949d38c75e99b18e2", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -246,8 +246,6 @@ macro_rules! test_v512 { ($item:item) => {}; }\n #[allow(unused_macros)]\n macro_rules! vector_impl { ($([$f:ident, $($args:tt)*]),*) => { $($f!($($args)*);)* } }\n #[path = \"../stdsimd/coresimd/mod.rs\"]\n-// replacing uses of mem::{uninitialized,zeroed} with MaybeUninit needs to be in the stdsimd repo\n-#[allow(deprecated)]\n #[allow(missing_docs, missing_debug_implementations, dead_code, unused_imports)]\n #[unstable(feature = \"stdsimd\", issue = \"48556\")]\n #[cfg(not(stage0))] // allow changes to how stdsimd works in stage0"}, {"sha": "14f2148a64e0ef299e1cebf7e295b3a6e1d0bc2d", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -79,7 +79,7 @@ use ops::CoerceUnsized;\n use fmt;\n use hash;\n use marker::{PhantomData, Unsize};\n-use mem::{self, MaybeUninit};\n+use mem;\n use nonzero::NonZero;\n \n use cmp::Ordering::{self, Less, Equal, Greater};\n@@ -294,12 +294,16 @@ pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with\n-    let mut tmp = MaybeUninit::<T>::uninitialized();\n+    let mut tmp: T = mem::uninitialized();\n \n     // Perform the swap\n-    copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n+    copy_nonoverlapping(x, &mut tmp, 1);\n     copy(y, x, 1); // `x` and `y` may overlap\n-    copy_nonoverlapping(tmp.get_ref(), y, 1);\n+    copy_nonoverlapping(&tmp, y, 1);\n+\n+    // y and t now point to the same thing, but we need to completely forget `tmp`\n+    // because it's no longer relevant.\n+    mem::forget(tmp);\n }\n \n /// Swaps `count * size_of::<T>()` bytes between the two regions of memory\n@@ -386,8 +390,8 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n     while i + block_size <= len {\n         // Create some uninitialized memory as scratch space\n         // Declaring `t` here avoids aligning the stack when this loop is unused\n-        let mut t = mem::MaybeUninit::<Block>::uninitialized();\n-        let t = t.as_mut_ptr() as *mut u8;\n+        let mut t: Block = mem::uninitialized();\n+        let t = &mut t as *mut _ as *mut u8;\n         let x = x.add(i);\n         let y = y.add(i);\n \n@@ -401,10 +405,10 @@ unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n \n     if i < len {\n         // Swap any remaining bytes\n-        let mut t = mem::MaybeUninit::<UnalignedBlock>::uninitialized();\n+        let mut t: UnalignedBlock = mem::uninitialized();\n         let rem = len - i;\n \n-        let t = t.as_mut_ptr() as *mut u8;\n+        let t = &mut t as *mut _ as *mut u8;\n         let x = x.add(i);\n         let y = y.add(i);\n \n@@ -569,9 +573,9 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n-    let mut tmp = MaybeUninit::<T>::uninitialized();\n-    copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-    tmp.into_inner()\n+    let mut tmp: T = mem::uninitialized();\n+    copy_nonoverlapping(src, &mut tmp, 1);\n+    tmp\n }\n \n /// Reads the value from `src` without moving it. This leaves the\n@@ -636,11 +640,11 @@ pub unsafe fn read<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"ptr_unaligned\", since = \"1.17.0\")]\n pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n-    let mut tmp = MaybeUninit::<T>::uninitialized();\n+    let mut tmp: T = mem::uninitialized();\n     copy_nonoverlapping(src as *const u8,\n-                        tmp.as_mut_ptr() as *mut u8,\n+                        &mut tmp as *mut T as *mut u8,\n                         mem::size_of::<T>());\n-    tmp.into_inner()\n+    tmp\n }\n \n /// Overwrites a memory location with the given value without reading or"}, {"sha": "0d182b8497452e2bf7db6d6417b4b6e2092d3b34", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use cmp;\n-use mem::{self, MaybeUninit};\n+use mem;\n use ptr;\n \n /// Rotation is much faster if it has access to a little bit of memory. This\n@@ -26,6 +26,12 @@ union RawArray<T> {\n }\n \n impl<T> RawArray<T> {\n+    fn new() -> Self {\n+        unsafe { mem::uninitialized() }\n+    }\n+    fn ptr(&self) -> *mut T {\n+        unsafe { &self.typed as *const T as *mut T }\n+    }\n     fn cap() -> usize {\n         if mem::size_of::<T>() == 0 {\n             usize::max_value()\n@@ -82,8 +88,8 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mid: *mut T, mut right: usize) {\n         }\n     }\n \n-    let mut rawarray = MaybeUninit::<RawArray<T>>::uninitialized();\n-    let buf = &mut (*rawarray.as_mut_ptr()).typed as *mut [T; 2] as *mut T;\n+    let rawarray = RawArray::new();\n+    let buf = rawarray.ptr();\n \n     let dim = mid.sub(left).add(right);\n     if left <= right {"}, {"sha": "e4c1fd03f9eb384b1197e5a6d3b82ed14f85d349", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -17,7 +17,7 @@\n //! stable sorting implementation.\n \n use cmp;\n-use mem::{self, MaybeUninit};\n+use mem;\n use ptr;\n \n /// When dropped, copies from `src` into `dest`.\n@@ -226,14 +226,14 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n     let mut block_l = BLOCK;\n     let mut start_l = ptr::null_mut();\n     let mut end_l = ptr::null_mut();\n-    let mut offsets_l = MaybeUninit::<[u8; BLOCK]>::uninitialized();\n+    let mut offsets_l: [u8; BLOCK] = unsafe { mem::uninitialized() };\n \n     // The current block on the right side (from `r.sub(block_r)` to `r`).\n     let mut r = unsafe { l.add(v.len()) };\n     let mut block_r = BLOCK;\n     let mut start_r = ptr::null_mut();\n     let mut end_r = ptr::null_mut();\n-    let mut offsets_r = MaybeUninit::<[u8; BLOCK]>::uninitialized();\n+    let mut offsets_r: [u8; BLOCK] = unsafe { mem::uninitialized() };\n \n     // FIXME: When we get VLAs, try creating one array of length `min(v.len(), 2 * BLOCK)` rather\n     // than two fixed-size arrays of length `BLOCK`. VLAs might be more cache-efficient.\n@@ -272,8 +272,8 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n \n         if start_l == end_l {\n             // Trace `block_l` elements from the left side.\n-            start_l = offsets_l.as_mut_ptr() as *mut u8;\n-            end_l = offsets_l.as_mut_ptr() as *mut u8;\n+            start_l = offsets_l.as_mut_ptr();\n+            end_l = offsets_l.as_mut_ptr();\n             let mut elem = l;\n \n             for i in 0..block_l {\n@@ -288,8 +288,8 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n \n         if start_r == end_r {\n             // Trace `block_r` elements from the right side.\n-            start_r = offsets_r.as_mut_ptr() as *mut u8;\n-            end_r = offsets_r.as_mut_ptr() as *mut u8;\n+            start_r = offsets_r.as_mut_ptr();\n+            end_r = offsets_r.as_mut_ptr();\n             let mut elem = r;\n \n             for i in 0..block_r {"}, {"sha": "4e37a34a0c8a7f9af70d13a8f8d1cd8a790a3003", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n             }\n \n-            if sized && fields.iter().any(|f| f.abi.is_uninhabited()) {\n+            if sized && fields.iter().any(|f| f.abi == Abi::Uninhabited) {\n                 abi = Abi::Uninhabited;\n             }\n \n@@ -724,7 +724,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 // See issue #49298 for more details on the need to leave space\n                 // for non-ZST uninhabited data (mostly partial initialization).\n                 let absent = |fields: &[TyLayout]| {\n-                    let uninhabited = fields.iter().any(|f| f.abi.is_uninhabited());\n+                    let uninhabited = fields.iter().any(|f| f.abi == Abi::Uninhabited);\n                     let is_zst = fields.iter().all(|f| f.is_zst());\n                     uninhabited && is_zst\n                 };\n@@ -872,7 +872,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                                 _ => Abi::Aggregate { sized: true },\n                             };\n \n-                            if st.iter().all(|v| v.abi.is_uninhabited()) {\n+                            if st.iter().all(|v| v.abi == Abi::Uninhabited) {\n                                 abi = Abi::Uninhabited;\n                             }\n \n@@ -900,7 +900,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let discr_type = def.repr.discr_type();\n                 let bits = Integer::from_attr(tcx, discr_type).size().bits();\n                 for (i, discr) in def.discriminants(tcx).enumerate() {\n-                    if variants[i].iter().any(|f| f.abi.is_uninhabited()) {\n+                    if variants[i].iter().any(|f| f.abi == Abi::Uninhabited) {\n                         continue;\n                     }\n                     let mut x = discr.val as i128;\n@@ -1096,7 +1096,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     }\n                 }\n \n-                if layout_variants.iter().all(|v| v.abi.is_uninhabited()) {\n+                if layout_variants.iter().all(|v| v.abi == Abi::Uninhabited) {\n                     abi = Abi::Uninhabited;\n                 }\n "}, {"sha": "99919a940b40511dcd605cea460440d5a1a9e05a", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -279,7 +279,7 @@ pub fn create_function_debug_context(\n         }\n         None => {}\n     };\n-    if cx.layout_of(sig.output()).abi.is_uninhabited() {\n+    if cx.layout_of(sig.output()).abi == ty::layout::Abi::Uninhabited {\n         flags = flags | DIFlags::FlagNoReturn;\n     }\n "}, {"sha": "5e743ac51bc616ffebbf47aa31851f9911a243a7", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -23,7 +23,7 @@\n use llvm;\n use llvm::AttributePlace::Function;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty::layout::{self, LayoutOf};\n use rustc::session::config::Sanitizer;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_target::spec::PanicStrategy;\n@@ -137,7 +137,7 @@ pub fn declare_fn(\n     let fty = FnType::new(cx, sig, &[]);\n     let llfn = declare_raw_fn(cx, name, fty.llvm_cconv(), fty.llvm_type(cx));\n \n-    if cx.layout_of(sig.output()).abi.is_uninhabited() {\n+    if cx.layout_of(sig.output()).abi == layout::Abi::Uninhabited {\n         llvm::Attribute::NoReturn.apply_llfn(Function, llfn);\n     }\n "}, {"sha": "a534b4e478fb793e4f96496e4621287c25eb0a24", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -482,54 +482,6 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     _ => FnType::new(bx.cx, sig, &extra_args)\n                 };\n \n-                // emit a panic instead of instantiating an uninhabited type\n-                if (intrinsic == Some(\"init\") || intrinsic == Some(\"uninit\")) &&\n-                    fn_ty.ret.layout.abi.is_uninhabited()\n-                {\n-                    let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n-                    let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                    let filename = C_str_slice(bx.cx, filename);\n-                    let line = C_u32(bx.cx, loc.line as u32);\n-                    let col = C_u32(bx.cx, loc.col.to_usize() as u32 + 1);\n-                    let align = tcx.data_layout.aggregate_align\n-                        .max(tcx.data_layout.i32_align)\n-                        .max(tcx.data_layout.pointer_align);\n-\n-                    let str = format!(\n-                        \"Attempted to instantiate uninhabited type {} using mem::{}\",\n-                        sig.output(),\n-                        if intrinsic == Some(\"init\") { \"zeroed\" } else { \"uninitialized\" }\n-                    );\n-                    let msg_str = Symbol::intern(&str).as_str();\n-                    let msg_str = C_str_slice(bx.cx, msg_str);\n-                    let msg_file_line_col = C_struct(bx.cx,\n-                                                    &[msg_str, filename, line, col],\n-                                                    false);\n-                    let msg_file_line_col = consts::addr_of(bx.cx,\n-                                                            msg_file_line_col,\n-                                                            align,\n-                                                            Some(\"panic_loc\"));\n-\n-                    // Obtain the panic entry point.\n-                    let def_id =\n-                        common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n-                    let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                    let fn_ty = FnType::of_instance(bx.cx, &instance);\n-                    let llfn = callee::get_fn(bx.cx, instance);\n-\n-                    // Codegen the actual panic invoke/call.\n-                    do_call(\n-                        self,\n-                        bx,\n-                        fn_ty,\n-                        llfn,\n-                        &[msg_file_line_col],\n-                        destination.as_ref().map(|(_, bb)| (ReturnDest::Nothing, *bb)),\n-                        cleanup,\n-                    );\n-                    return;\n-                }\n-\n                 // The arguments we'll be passing. Plus one to account for outptr, if used.\n                 let arg_count = fn_ty.args.len() + fn_ty.ret.is_indirect() as usize;\n                 let mut llargs = Vec::with_capacity(arg_count);"}, {"sha": "c781b456af6b284825e3048984aaebaff01ab28d", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -275,7 +275,7 @@ impl PlaceRef<'ll, 'tcx> {\n     /// Obtain the actual discriminant of a value.\n     pub fn codegen_get_discr(self, bx: &Builder<'a, 'll, 'tcx>, cast_to: Ty<'tcx>) -> &'ll Value {\n         let cast_to = bx.cx.layout_of(cast_to).immediate_llvm_type(bx.cx);\n-        if self.layout.abi.is_uninhabited() {\n+        if self.layout.abi == layout::Abi::Uninhabited {\n             return C_undef(cast_to);\n         }\n         match self.layout.variants {\n@@ -338,7 +338,7 @@ impl PlaceRef<'ll, 'tcx> {\n     /// Set the discriminant for a new value of the given case of the given\n     /// representation.\n     pub fn codegen_set_discr(&self, bx: &Builder<'a, 'll, 'tcx>, variant_index: usize) {\n-        if self.layout.for_variant(bx.cx, variant_index).abi.is_uninhabited() {\n+        if self.layout.for_variant(bx.cx, variant_index).abi == layout::Abi::Uninhabited {\n             return;\n         }\n         match self.layout.variants {"}, {"sha": "c3ec347f60876c03dc846bbec04f75f546b8d75d", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -290,7 +290,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     mir::CastKind::Misc => {\n                         assert!(cast.is_llvm_immediate());\n                         let ll_t_out = cast.immediate_llvm_type(bx.cx);\n-                        if operand.layout.abi.is_uninhabited() {\n+                        if operand.layout.abi == layout::Abi::Uninhabited {\n                             return (bx, OperandRef {\n                                 val: OperandValue::Immediate(C_undef(ll_t_out)),\n                                 layout: cast,"}, {"sha": "fef2f916b415667652fbf123527509fd40d5257a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -514,7 +514,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         rval: OpTy<'tcx>,\n     ) -> EvalResult<'tcx, (u128, usize)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n-        if rval.layout.abi.is_uninhabited() {\n+        if rval.layout.abi == layout::Abi::Uninhabited {\n             return err!(Unreachable);\n         }\n "}, {"sha": "5c4cd849f89bcd681e323d5db483f2d6764a874e", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -802,14 +802,6 @@ impl Abi {\n             _ => false,\n         }\n     }\n-\n-    /// Returns true if this is an uninhabited type\n-    pub fn is_uninhabited(&self) -> bool {\n-        match *self {\n-            Abi::Uninhabited => true,\n-            _ => false,\n-        }\n-    }\n }\n \n #[derive(PartialEq, Eq, Hash, Debug)]"}, {"sha": "168e1a3eba0c56f9a22c0d9581fe50d95e89759f", "filename": "src/test/codegen/box-maybe-uninit.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d95fd2585d8d7327a83beee10d9e32129b26cd68/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95fd2585d8d7327a83beee10d9e32129b26cd68/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs?ref=d95fd2585d8d7327a83beee10d9e32129b26cd68", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -O\n-#![crate_type=\"lib\"]\n-#![feature(maybe_uninit)]\n-\n-use std::mem::MaybeUninit;\n-\n-// Boxing a `MaybeUninit` value should not copy junk from the stack\n-#[no_mangle]\n-pub fn box_uninitialized() -> Box<MaybeUninit<usize>> {\n-    // CHECK-LABEL: @box_uninitialized\n-    // CHECK-NOT: store\n-    Box::new(MaybeUninit::uninitialized())\n-}"}, {"sha": "94377421c0b0c9927a039b26970371581d959315", "filename": "src/test/debuginfo/nil-enum.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7bc060c1564b19742fd241f40a02c9210e445c/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fnil-enum.rs?ref=7e7bc060c1564b19742fd241f40a02c9210e445c", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NOTE Instantiating an empty enum is UB. This test may break in the future.\n-\n // LLDB can't handle zero-sized values\n // ignore-lldb\n \n@@ -27,11 +25,8 @@\n \n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]\n-#![feature(maybe_uninit)]\n #![omit_gdb_pretty_printer_section]\n \n-use std::mem::MaybeUninit;\n-\n enum ANilEnum {}\n enum AnotherNilEnum {}\n \n@@ -40,8 +35,8 @@ enum AnotherNilEnum {}\n // The error from gdbr is expected since nil enums are not supposed to exist.\n fn main() {\n     unsafe {\n-        let first: ANilEnum = MaybeUninit::uninitialized().into_inner();\n-        let second: AnotherNilEnum = MaybeUninit::uninitialized().into_inner();\n+        let first: ANilEnum = ::std::mem::zeroed();\n+        let second: AnotherNilEnum = ::std::mem::zeroed();\n \n         zzz(); // #break\n     }"}, {"sha": "2972f6efa32e05f3eab76c0229b61767a978ad44", "filename": "src/test/run-pass/panic-uninitialized-zeroed.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d95fd2585d8d7327a83beee10d9e32129b26cd68/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95fd2585d8d7327a83beee10d9e32129b26cd68/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs?ref=d95fd2585d8d7327a83beee10d9e32129b26cd68", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-wasm32-bare always compiled as panic=abort right now and this requires unwinding\n-// This test checks that instantiating an uninhabited type via `mem::{uninitialized,zeroed}` results\n-// in a runtime panic.\n-\n-#![feature(never_type)]\n-\n-use std::{mem, panic};\n-\n-#[allow(dead_code)]\n-struct Foo {\n-    x: u8,\n-    y: !,\n-}\n-\n-enum Bar {}\n-\n-fn main() {\n-    unsafe {\n-        assert_eq!(\n-            panic::catch_unwind(|| {\n-                mem::uninitialized::<!>()\n-            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n-                s == \"Attempted to instantiate uninhabited type ! using mem::uninitialized\"\n-            })),\n-            Some(true)\n-        );\n-\n-        assert_eq!(\n-            panic::catch_unwind(|| {\n-                mem::zeroed::<!>()\n-            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n-                s == \"Attempted to instantiate uninhabited type ! using mem::zeroed\"\n-            })),\n-            Some(true)\n-        );\n-\n-        assert_eq!(\n-            panic::catch_unwind(|| {\n-                mem::uninitialized::<Foo>()\n-            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n-                s == \"Attempted to instantiate uninhabited type Foo using mem::uninitialized\"\n-            })),\n-            Some(true)\n-        );\n-\n-        assert_eq!(\n-            panic::catch_unwind(|| {\n-                mem::zeroed::<Foo>()\n-            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n-                s == \"Attempted to instantiate uninhabited type Foo using mem::zeroed\"\n-            })),\n-            Some(true)\n-        );\n-\n-        assert_eq!(\n-            panic::catch_unwind(|| {\n-                mem::uninitialized::<Bar>()\n-            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n-                s == \"Attempted to instantiate uninhabited type Bar using mem::uninitialized\"\n-            })),\n-            Some(true)\n-        );\n-\n-        assert_eq!(\n-            panic::catch_unwind(|| {\n-                mem::zeroed::<Bar>()\n-            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n-                s == \"Attempted to instantiate uninhabited type Bar using mem::zeroed\"\n-            })),\n-            Some(true)\n-        );\n-    }\n-}"}]}