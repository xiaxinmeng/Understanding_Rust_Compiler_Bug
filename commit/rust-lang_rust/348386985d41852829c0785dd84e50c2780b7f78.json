{"sha": "348386985d41852829c0785dd84e50c2780b7f78", "node_id": "C_kwDOAAsO6NoAKDM0ODM4Njk4NWQ0MTg1MjgyOWMwNzg1ZGQ4NGU1MGMyNzgwYjdmNzg", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-12-12T17:13:27Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-12-12T17:23:36Z"}, "message": "Move logic to their own methods", "tree": {"sha": "f94b1fac89c4b90c081bcda4672be683e089a978", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f94b1fac89c4b90c081bcda4672be683e089a978"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/348386985d41852829c0785dd84e50c2780b7f78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/348386985d41852829c0785dd84e50c2780b7f78", "html_url": "https://github.com/rust-lang/rust/commit/348386985d41852829c0785dd84e50c2780b7f78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/348386985d41852829c0785dd84e50c2780b7f78/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2838b8e515d139245fba71895277fab26082d522", "url": "https://api.github.com/repos/rust-lang/rust/commits/2838b8e515d139245fba71895277fab26082d522", "html_url": "https://github.com/rust-lang/rust/commit/2838b8e515d139245fba71895277fab26082d522"}], "stats": {"total": 753, "additions": 391, "deletions": 362}, "files": [{"sha": "cb373d657721bf53758eff0aa91355bf5eaf8b9a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/method_chain.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/348386985d41852829c0785dd84e50c2780b7f78/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348386985d41852829c0785dd84e50c2780b7f78/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs?ref=348386985d41852829c0785dd84e50c2780b7f78", "patch": "@@ -0,0 +1,74 @@\n+use crate::infer::InferCtxt;\n+\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+\n+pub struct CollectAllMismatches<'a, 'tcx> {\n+    pub infcx: &'a InferCtxt<'tcx>,\n+    pub param_env: ty::ParamEnv<'tcx>,\n+    pub errors: Vec<TypeError<'tcx>>,\n+}\n+\n+impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n+    fn tag(&self) -> &'static str {\n+        \"CollectAllMismatches\"\n+    }\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    } // irrelevant\n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        _: ty::Variance,\n+        _: ty::VarianceDiagInfo<'tcx>,\n+        a: T,\n+        b: T,\n+    ) -> RelateResult<'tcx, T> {\n+        self.relate(a, b)\n+    }\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        _b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        Ok(a)\n+    }\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        if a == b || matches!(a.kind(), ty::Infer(_)) || matches!(b.kind(), ty::Infer(_)) {\n+            return Ok(a);\n+        }\n+        relate::super_relate_tys(self, a, b).or_else(|e| {\n+            self.errors.push(e);\n+            Ok(a)\n+        })\n+    }\n+    fn consts(\n+        &mut self,\n+        a: ty::Const<'tcx>,\n+        b: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n+        if a == b {\n+            return Ok(a);\n+        }\n+        relate::super_relate_consts(self, a, b) // could do something similar here for constants!\n+    }\n+    fn binders<T: Relate<'tcx>>(\n+        &mut self,\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>> {\n+        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n+    }\n+}"}, {"sha": "a0ed1fc751b9c5c9cb103cb10cbf533c3b93c106", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/348386985d41852829c0785dd84e50c2780b7f78/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348386985d41852829c0785dd84e50c2780b7f78/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=348386985d41852829c0785dd84e50c2780b7f78", "patch": "@@ -1,4 +1,5 @@\n mod ambiguity;\n+pub mod method_chain;\n pub mod on_unimplemented;\n pub mod suggestions;\n "}, {"sha": "df470f62089101ebedce4f4c7e7fe5924f8ffe5b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 316, "deletions": 362, "changes": 678, "blob_url": "https://github.com/rust-lang/rust/blob/348386985d41852829c0785dd84e50c2780b7f78/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/348386985d41852829c0785dd84e50c2780b7f78/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=348386985d41852829c0785dd84e50c2780b7f78", "patch": "@@ -24,7 +24,7 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::infer::{InferOk, LateBoundRegionConversionTime};\n use rustc_middle::hir::map;\n use rustc_middle::ty::error::TypeError::{self, Sorts};\n-use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n     GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, InternalSubsts,\n@@ -36,6 +36,7 @@ use rustc_span::{BytePos, DesugaringKind, ExpnKind, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use std::ops::Deref;\n \n+use super::method_chain::CollectAllMismatches;\n use super::InferCtxtPrivExt;\n use crate::infer::InferCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -332,6 +333,23 @@ pub trait TypeErrCtxtExt<'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n+    fn function_argument_obligation(\n+        &self,\n+        arg_hir_id: HirId,\n+        err: &mut Diagnostic,\n+        parent_code: &ObligationCauseCode<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: ty::Predicate<'tcx>,\n+        call_hir_id: HirId,\n+    );\n+    fn point_at_chain(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        typeck_results: &TypeckResults<'tcx>,\n+        type_diffs: Vec<TypeError<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        err: &mut Diagnostic,\n+    );\n }\n \n fn predicate_constraint(generics: &hir::Generics<'_>, pred: ty::Predicate<'_>) -> (Span, String) {\n@@ -2840,298 +2858,14 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 call_hir_id,\n                 ref parent_code,\n             } => {\n-                let hir = self.tcx.hir();\n-                if let Some(Node::Expr(expr)) = hir.find(arg_hir_id) {\n-                    let parent_id = hir.get_parent_item(arg_hir_id);\n-                    let typeck_results: &TypeckResults<'tcx> = match &self.typeck_results {\n-                        Some(t) if t.hir_owner == parent_id => t,\n-                        _ => self.tcx.typeck(parent_id.def_id),\n-                    };\n-                    if let hir::Expr { kind: hir::ExprKind::Block(..), .. } = expr {\n-                        let expr = expr.peel_blocks();\n-                        let ty =\n-                            typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error());\n-                        let span = expr.span;\n-                        if Some(span) != err.span.primary_span() {\n-                            err.span_label(\n-                                span,\n-                                if ty.references_error() {\n-                                    String::new()\n-                                } else {\n-                                    let ty = with_forced_trimmed_paths!(self.ty_to_string(ty));\n-                                    format!(\"this tail expression is of type `{ty}`\")\n-                                },\n-                            );\n-                        }\n-                    }\n-\n-                    let mut primary_spans = vec![];\n-                    let mut span_labels = vec![];\n-\n-                    // FIXME: visit the ty to see if there's any closure involved, and if there is,\n-                    // check whether its evaluated return type is the same as the one corresponding\n-                    // to an associated type (as seen from `trait_pred`) in the predicate. Like in\n-                    // trait_pred `S: Sum<<Self as Iterator>::Item>` and predicate `i32: Sum<&()>`\n-                    let mut type_diffs = vec![];\n-\n-                    if let ObligationCauseCode::ExprBindingObligation(def_id, _, _, idx) = parent_code.deref()\n-                        && let predicates = self.tcx.predicates_of(def_id).instantiate_identity(self.tcx)\n-                        && let Some(pred) = predicates.predicates.get(*idx)\n-                        && let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = pred.kind().skip_binder()\n-                    {\n-                        let mut c = CollectAllMismatches {\n-                            infcx: self.infcx,\n-                            param_env: param_env,\n-                            errors: vec![],\n-                        };\n-                        if let ty::PredicateKind::Clause(ty::Clause::Trait(\n-                                predicate\n-                            )) = predicate.kind().skip_binder()\n-                        {\n-                            if let Ok(_) = c.relate(trait_pred, predicate) {\n-                                type_diffs = c.errors;\n-                            }\n-                        }\n-                    }\n-                    let point_at_chain = |expr: &hir::Expr<'_>| {\n-                        let mut assocs = vec![];\n-                        // We still want to point at the different methods even if there hasn't\n-                        // been a change of assoc type.\n-                        let mut call_spans = vec![];\n-                        let mut expr = expr;\n-                        let mut prev_ty = self.resolve_vars_if_possible(\n-                            typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n-                        );\n-                        while let hir::ExprKind::MethodCall(_path_segment, rcvr_expr, _args, span) =\n-                            expr.kind\n-                        {\n-                            // Point at every method call in the chain with the resulting type.\n-                            // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n-                            //               ^^^^^^ ^^^^^^^^^^^\n-                            expr = rcvr_expr;\n-                            let mut assocs_in_this_method = Vec::with_capacity(type_diffs.len());\n-                            call_spans.push(span);\n-\n-                            let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n-                            for diff in &type_diffs {\n-                                let Sorts(expected_found) = diff else { continue; };\n-                                let ty::Projection(proj) = expected_found.expected.kind() else { continue; };\n-\n-                                let origin = TypeVariableOrigin {\n-                                    kind: TypeVariableOriginKind::TypeInference,\n-                                    span,\n-                                };\n-                                let trait_def_id = proj.trait_def_id(self.tcx);\n-                                // Make `Self` be equivalent to the type of the call chain\n-                                // expression we're looking at now, so that we can tell what\n-                                // for example `Iterator::Item` is at this point in the chain.\n-                                let substs =\n-                                    InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n-                                        match param.kind {\n-                                            ty::GenericParamDefKind::Type { .. } => {\n-                                                if param.index == 0 {\n-                                                    return prev_ty.into();\n-                                                }\n-                                            }\n-                                            ty::GenericParamDefKind::Lifetime\n-                                            | ty::GenericParamDefKind::Const { .. } => {}\n-                                        }\n-                                        self.var_for_def(span, param)\n-                                    });\n-                                // This will hold the resolved type of the associated type, if the\n-                                // current expression implements the trait that associated type is\n-                                // in. For example, this would be what `Iterator::Item` is here.\n-                                let ty_var = self.infcx.next_ty_var(origin);\n-                                // This corresponds to `<ExprTy as Iterator>::Item = _`.\n-                                let trait_ref = ty::Binder::dummy(ty::PredicateKind::Clause(\n-                                    ty::Clause::Projection(ty::ProjectionPredicate {\n-                                        projection_ty: ty::ProjectionTy {\n-                                            substs,\n-                                            item_def_id: proj.item_def_id,\n-                                        },\n-                                        term: ty_var.into(),\n-                                    }),\n-                                ));\n-                                // Add `<ExprTy as Iterator>::Item = _` obligation.\n-                                ocx.register_obligation(Obligation::misc(\n-                                    self.tcx,\n-                                    span,\n-                                    expr.hir_id,\n-                                    param_env,\n-                                    trait_ref,\n-                                ));\n-                                if ocx.select_where_possible().is_empty() {\n-                                    // `ty_var` now holds the type that `Item` is for `ExprTy`.\n-                                    let ty_var = self.resolve_vars_if_possible(ty_var);\n-                                    assocs_in_this_method\n-                                        .push(Some((span, (proj.item_def_id, ty_var))));\n-                                } else {\n-                                    // `<ExprTy as Iterator>` didn't select, so likely we've\n-                                    // reached the end of the iterator chain, like the originating\n-                                    // `Vec<_>`.\n-                                    // Keep the space consistent for later zipping.\n-                                    assocs_in_this_method.push(None);\n-                                }\n-                            }\n-                            assocs.push(assocs_in_this_method);\n-                            prev_ty = self.resolve_vars_if_possible(\n-                                typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n-                            );\n-\n-                            if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n-                                && let hir::Path { res: hir::def::Res::Local(hir_id), .. } = path\n-                                && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(*hir_id)\n-                                && let parent_hir_id = self.tcx.hir().get_parent_node(binding.hir_id)\n-                                && let Some(hir::Node::Local(local)) = self.tcx.hir().find(parent_hir_id)\n-                                && let Some(binding_expr) = local.init\n-                            {\n-                                // We've reached the root of the method call chain and it is a\n-                                // binding. Get the binding creation and try to continue the chain.\n-                                expr = binding_expr;\n-                            }\n-                        }\n-\n-                        // We want the type before deref coercions, otherwise we talk about `&[_]`\n-                        // instead of `Vec<_>`.\n-                        if let Some(ty) = typeck_results.expr_ty_opt(expr) {\n-                            let ty = with_forced_trimmed_paths!(self.ty_to_string(ty));\n-                            // Point at the root expression\n-                            // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n-                            // ^^^^^^^^^^^^^\n-                            span_labels\n-                                .push((expr.span, format!(\"this expression has type `{ty}`\")));\n-                        };\n-                        // Only show this if it is not a \"trivial\" expression (not a method\n-                        // chain) and there are associated types to talk about.\n-                        let mut assocs = assocs.into_iter().peekable();\n-                        while let Some(assocs_in_method) = assocs.next() {\n-                            let Some(prev_assoc_in_method) = assocs.peek() else {\n-                                for entry in assocs_in_method {\n-                                    let Some((span, (assoc, ty))) = entry else { continue; };\n-                                    if type_diffs.iter().any(|diff| {\n-                                        let Sorts(expected_found) = diff else { return false; };\n-                                        self.can_eq(param_env, expected_found.found, ty).is_ok()\n-                                    }) {\n-                                        // FIXME: this doesn't quite work for `Iterator::collect`\n-                                        // because we have `Vec<i32>` and `()`, but we'd want `i32`\n-                                        // to point at the `.into_iter()` call, but as long as we\n-                                        // still point at the other method calls that might have\n-                                        // introduced the issue, this is fine for now.\n-                                        primary_spans.push(span);\n-                                    }\n-                                    span_labels.push((\n-                                        span,\n-                                        with_forced_trimmed_paths!(format!(\n-                                            \"`{}` is `{ty}` here\",\n-                                            self.tcx.def_path_str(assoc),\n-                                        )),\n-                                    ));\n-                                }\n-                                break;\n-                            };\n-                            for (entry, prev_entry) in\n-                                assocs_in_method.into_iter().zip(prev_assoc_in_method.into_iter())\n-                            {\n-                                match (entry, prev_entry) {\n-                                    (Some((span, (assoc, ty))), Some((_, (_, prev_ty)))) => {\n-                                        let ty_str =\n-                                            with_forced_trimmed_paths!(self.ty_to_string(ty));\n-\n-                                        let assoc = with_forced_trimmed_paths!(\n-                                            self.tcx.def_path_str(assoc)\n-                                        );\n-                                        if ty != *prev_ty {\n-                                            if type_diffs.iter().any(|diff| {\n-                                                let Sorts(expected_found) = diff else { return false; };\n-                                                self.can_eq(param_env, expected_found.found, ty).is_ok()\n-                                            }) {\n-                                                primary_spans.push(span);\n-                                            }\n-                                            span_labels.push((\n-                                                span,\n-                                                format!(\"`{assoc}` changed to `{ty_str}` here\"),\n-                                            ));\n-                                        } else {\n-                                            span_labels.push((\n-                                                span,\n-                                                format!(\"`{assoc}` remains `{ty_str}` here\"),\n-                                            ));\n-                                        }\n-                                    }\n-                                    (Some((span, (assoc, ty))), None) => {\n-                                        span_labels.push((\n-                                            span,\n-                                            with_forced_trimmed_paths!(format!(\n-                                                \"`{}` is `{}` here\",\n-                                                self.tcx.def_path_str(assoc),\n-                                                self.ty_to_string(ty),\n-                                            )),\n-                                        ));\n-                                    }\n-                                    (None, Some(_)) | (None, None) => {}\n-                                }\n-                            }\n-                        }\n-                        for span in call_spans {\n-                            if span_labels.iter().find(|(s, _)| *s == span).is_none() {\n-                                // Ensure we are showing the entire chain, even if the assoc types\n-                                // haven't changed.\n-                                span_labels.push((span, String::new()));\n-                            }\n-                        }\n-                        if !primary_spans.is_empty() {\n-                            let mut multi_span: MultiSpan = primary_spans.into();\n-                            for (span, label) in span_labels {\n-                                multi_span.push_span_label(span, label);\n-                            }\n-                            err.span_note(\n-                                multi_span,\n-                                format!(\n-                                    \"the method call chain might not have had the expected \\\n-                                     associated types\",\n-                                ),\n-                            );\n-                        }\n-                    };\n-                    if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n-                        && let hir::Path { res: hir::def::Res::Local(hir_id), .. } = path\n-                        && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(*hir_id)\n-                        && let parent_hir_id = self.tcx.hir().get_parent_node(binding.hir_id)\n-                        && let Some(hir::Node::Local(local)) = self.tcx.hir().find(parent_hir_id)\n-                        && let Some(binding_expr) = local.init\n-                    {\n-                        // If the expression we're calling on is a binding, we want to point at the\n-                        // `let` when talking about the type. Otherwise we'll point at every part\n-                        // of the method chain with the type.\n-                        point_at_chain(binding_expr);\n-                    } else {\n-                        point_at_chain(expr);\n-                    }\n-                }\n-                let call_node = hir.find(call_hir_id);\n-                if let Some(Node::Expr(hir::Expr {\n-                    kind: hir::ExprKind::MethodCall(path, rcvr, ..),\n-                    ..\n-                })) = call_node\n-                {\n-                    if Some(rcvr.span) == err.span.primary_span() {\n-                        err.replace_span_with(path.ident.span);\n-                    }\n-                }\n-                if let Some(Node::Expr(hir::Expr {\n-                    kind:\n-                        hir::ExprKind::Call(hir::Expr { span, .. }, _)\n-                        | hir::ExprKind::MethodCall(\n-                            hir::PathSegment { ident: Ident { span, .. }, .. },\n-                            ..,\n-                        ),\n-                    ..\n-                })) = hir.find(call_hir_id)\n-                {\n-                    if Some(*span) != err.span.primary_span() {\n-                        err.span_label(*span, \"required by a bound introduced by this call\");\n-                    }\n-                }\n+                self.function_argument_obligation(\n+                    arg_hir_id,\n+                    err,\n+                    parent_code,\n+                    param_env,\n+                    predicate,\n+                    call_hir_id,\n+                );\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n                         err,\n@@ -3356,6 +3090,295 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             );\n         }\n     }\n+    fn function_argument_obligation(\n+        &self,\n+        arg_hir_id: HirId,\n+        err: &mut Diagnostic,\n+        parent_code: &ObligationCauseCode<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: ty::Predicate<'tcx>,\n+        call_hir_id: HirId,\n+    ) {\n+        let tcx = self.tcx;\n+        let hir = tcx.hir();\n+        if let Some(Node::Expr(expr)) = hir.find(arg_hir_id) {\n+            let parent_id = hir.get_parent_item(arg_hir_id);\n+            let typeck_results: &TypeckResults<'tcx> = match &self.typeck_results {\n+                Some(t) if t.hir_owner == parent_id => t,\n+                _ => self.tcx.typeck(parent_id.def_id),\n+            };\n+            if let hir::Expr { kind: hir::ExprKind::Block(..), .. } = expr {\n+                let expr = expr.peel_blocks();\n+                let ty = typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error());\n+                let span = expr.span;\n+                if Some(span) != err.span.primary_span() {\n+                    err.span_label(\n+                        span,\n+                        if ty.references_error() {\n+                            String::new()\n+                        } else {\n+                            let ty = with_forced_trimmed_paths!(self.ty_to_string(ty));\n+                            format!(\"this tail expression is of type `{ty}`\")\n+                        },\n+                    );\n+                }\n+            }\n+\n+            // FIXME: visit the ty to see if there's any closure involved, and if there is,\n+            // check whether its evaluated return type is the same as the one corresponding\n+            // to an associated type (as seen from `trait_pred`) in the predicate. Like in\n+            // trait_pred `S: Sum<<Self as Iterator>::Item>` and predicate `i32: Sum<&()>`\n+            let mut type_diffs = vec![];\n+\n+            if let ObligationCauseCode::ExprBindingObligation(def_id, _, _, idx) = parent_code.deref()\n+                && let predicates = self.tcx.predicates_of(def_id).instantiate_identity(self.tcx)\n+                && let Some(pred) = predicates.predicates.get(*idx)\n+                && let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = pred.kind().skip_binder()\n+            {\n+                let mut c = CollectAllMismatches {\n+                    infcx: self.infcx,\n+                    param_env,\n+                    errors: vec![],\n+                };\n+                if let ty::PredicateKind::Clause(ty::Clause::Trait(\n+                        predicate\n+                    )) = predicate.kind().skip_binder()\n+                {\n+                    if let Ok(_) = c.relate(trait_pred, predicate) {\n+                        type_diffs = c.errors;\n+                    }\n+                }\n+            }\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n+                && let hir::Path { res: hir::def::Res::Local(hir_id), .. } = path\n+                && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(*hir_id)\n+                && let parent_hir_id = self.tcx.hir().get_parent_node(binding.hir_id)\n+                && let Some(hir::Node::Local(local)) = self.tcx.hir().find(parent_hir_id)\n+                && let Some(binding_expr) = local.init\n+            {\n+                // If the expression we're calling on is a binding, we want to point at the\n+                // `let` when talking about the type. Otherwise we'll point at every part\n+                // of the method chain with the type.\n+                self.point_at_chain(binding_expr, typeck_results, type_diffs, param_env, err);\n+            } else {\n+                self.point_at_chain(expr, typeck_results, type_diffs, param_env, err);\n+            }\n+        }\n+        let call_node = hir.find(call_hir_id);\n+        if let Some(Node::Expr(hir::Expr {\n+            kind: hir::ExprKind::MethodCall(path, rcvr, ..), ..\n+        })) = call_node\n+        {\n+            if Some(rcvr.span) == err.span.primary_span() {\n+                err.replace_span_with(path.ident.span);\n+            }\n+        }\n+        if let Some(Node::Expr(hir::Expr {\n+            kind:\n+                hir::ExprKind::Call(hir::Expr { span, .. }, _)\n+                | hir::ExprKind::MethodCall(hir::PathSegment { ident: Ident { span, .. }, .. }, ..),\n+            ..\n+        })) = hir.find(call_hir_id)\n+        {\n+            if Some(*span) != err.span.primary_span() {\n+                err.span_label(*span, \"required by a bound introduced by this call\");\n+            }\n+        }\n+    }\n+\n+    fn point_at_chain(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+        typeck_results: &TypeckResults<'tcx>,\n+        type_diffs: Vec<TypeError<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        err: &mut Diagnostic,\n+    ) {\n+        let mut primary_spans = vec![];\n+        let mut span_labels = vec![];\n+\n+        let tcx = self.tcx;\n+\n+        let mut assocs = vec![];\n+        // We still want to point at the different methods even if there hasn't\n+        // been a change of assoc type.\n+        let mut call_spans = vec![];\n+        let mut expr = expr;\n+        let mut prev_ty = self.resolve_vars_if_possible(\n+            typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n+        );\n+        while let hir::ExprKind::MethodCall(_path_segment, rcvr_expr, _args, span) = expr.kind {\n+            // Point at every method call in the chain with the resulting type.\n+            // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n+            //               ^^^^^^ ^^^^^^^^^^^\n+            expr = rcvr_expr;\n+            let mut assocs_in_this_method = Vec::with_capacity(type_diffs.len());\n+            call_spans.push(span);\n+\n+            let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n+            for diff in &type_diffs {\n+                let Sorts(expected_found) = diff else { continue; };\n+                let ty::Projection(proj) = expected_found.expected.kind() else { continue; };\n+\n+                let origin =\n+                    TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span };\n+                let trait_def_id = proj.trait_def_id(self.tcx);\n+                // Make `Self` be equivalent to the type of the call chain\n+                // expression we're looking at now, so that we can tell what\n+                // for example `Iterator::Item` is at this point in the chain.\n+                let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n+                    match param.kind {\n+                        ty::GenericParamDefKind::Type { .. } => {\n+                            if param.index == 0 {\n+                                return prev_ty.into();\n+                            }\n+                        }\n+                        ty::GenericParamDefKind::Lifetime\n+                        | ty::GenericParamDefKind::Const { .. } => {}\n+                    }\n+                    self.var_for_def(span, param)\n+                });\n+                // This will hold the resolved type of the associated type, if the\n+                // current expression implements the trait that associated type is\n+                // in. For example, this would be what `Iterator::Item` is here.\n+                let ty_var = self.infcx.next_ty_var(origin);\n+                // This corresponds to `<ExprTy as Iterator>::Item = _`.\n+                let trait_ref = ty::Binder::dummy(ty::PredicateKind::Clause(\n+                    ty::Clause::Projection(ty::ProjectionPredicate {\n+                        projection_ty: ty::ProjectionTy { substs, item_def_id: proj.item_def_id },\n+                        term: ty_var.into(),\n+                    }),\n+                ));\n+                // Add `<ExprTy as Iterator>::Item = _` obligation.\n+                ocx.register_obligation(Obligation::misc(\n+                    self.tcx,\n+                    span,\n+                    expr.hir_id,\n+                    param_env,\n+                    trait_ref,\n+                ));\n+                if ocx.select_where_possible().is_empty() {\n+                    // `ty_var` now holds the type that `Item` is for `ExprTy`.\n+                    let ty_var = self.resolve_vars_if_possible(ty_var);\n+                    assocs_in_this_method.push(Some((span, (proj.item_def_id, ty_var))));\n+                } else {\n+                    // `<ExprTy as Iterator>` didn't select, so likely we've\n+                    // reached the end of the iterator chain, like the originating\n+                    // `Vec<_>`.\n+                    // Keep the space consistent for later zipping.\n+                    assocs_in_this_method.push(None);\n+                }\n+            }\n+            assocs.push(assocs_in_this_method);\n+            prev_ty = self.resolve_vars_if_possible(\n+                typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n+            );\n+\n+            if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n+                && let hir::Path { res: hir::def::Res::Local(hir_id), .. } = path\n+                && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(*hir_id)\n+                && let parent_hir_id = self.tcx.hir().get_parent_node(binding.hir_id)\n+                && let Some(hir::Node::Local(local)) = self.tcx.hir().find(parent_hir_id)\n+                && let Some(binding_expr) = local.init\n+            {\n+                // We've reached the root of the method call chain and it is a\n+                // binding. Get the binding creation and try to continue the chain.\n+                expr = binding_expr;\n+            }\n+        }\n+        // We want the type before deref coercions, otherwise we talk about `&[_]`\n+        // instead of `Vec<_>`.\n+        if let Some(ty) = typeck_results.expr_ty_opt(expr) {\n+            let ty = with_forced_trimmed_paths!(self.ty_to_string(ty));\n+            // Point at the root expression\n+            // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n+            // ^^^^^^^^^^^^^\n+            span_labels.push((expr.span, format!(\"this expression has type `{ty}`\")));\n+        };\n+        // Only show this if it is not a \"trivial\" expression (not a method\n+        // chain) and there are associated types to talk about.\n+        let mut assocs = assocs.into_iter().peekable();\n+        while let Some(assocs_in_method) = assocs.next() {\n+            let Some(prev_assoc_in_method) = assocs.peek() else {\n+                for entry in assocs_in_method {\n+                    let Some((span, (assoc, ty))) = entry else { continue; };\n+                    if type_diffs.iter().any(|diff| {\n+                        let Sorts(expected_found) = diff else { return false; };\n+                        self.can_eq(param_env, expected_found.found, ty).is_ok()\n+                    }) {\n+                        // FIXME: this doesn't quite work for `Iterator::collect`\n+                        // because we have `Vec<i32>` and `()`, but we'd want `i32`\n+                        // to point at the `.into_iter()` call, but as long as we\n+                        // still point at the other method calls that might have\n+                        // introduced the issue, this is fine for now.\n+                        primary_spans.push(span);\n+                    }\n+                    span_labels.push((\n+                        span,\n+                        with_forced_trimmed_paths!(format!(\n+                            \"`{}` is `{ty}` here\",\n+                            self.tcx.def_path_str(assoc),\n+                        )),\n+                    ));\n+                }\n+                break;\n+            };\n+            for (entry, prev_entry) in\n+                assocs_in_method.into_iter().zip(prev_assoc_in_method.into_iter())\n+            {\n+                match (entry, prev_entry) {\n+                    (Some((span, (assoc, ty))), Some((_, (_, prev_ty)))) => {\n+                        let ty_str = with_forced_trimmed_paths!(self.ty_to_string(ty));\n+\n+                        let assoc = with_forced_trimmed_paths!(self.tcx.def_path_str(assoc));\n+                        if ty != *prev_ty {\n+                            if type_diffs.iter().any(|diff| {\n+                                let Sorts(expected_found) = diff else { return false; };\n+                                self.can_eq(param_env, expected_found.found, ty).is_ok()\n+                            }) {\n+                                primary_spans.push(span);\n+                            }\n+                            span_labels\n+                                .push((span, format!(\"`{assoc}` changed to `{ty_str}` here\")));\n+                        } else {\n+                            span_labels.push((span, format!(\"`{assoc}` remains `{ty_str}` here\")));\n+                        }\n+                    }\n+                    (Some((span, (assoc, ty))), None) => {\n+                        span_labels.push((\n+                            span,\n+                            with_forced_trimmed_paths!(format!(\n+                                \"`{}` is `{}` here\",\n+                                self.tcx.def_path_str(assoc),\n+                                self.ty_to_string(ty),\n+                            )),\n+                        ));\n+                    }\n+                    (None, Some(_)) | (None, None) => {}\n+                }\n+            }\n+        }\n+        for span in call_spans {\n+            if span_labels.iter().find(|(s, _)| *s == span).is_none() {\n+                // Ensure we are showing the entire chain, even if the assoc types\n+                // haven't changed.\n+                span_labels.push((span, String::new()));\n+            }\n+        }\n+        if !primary_spans.is_empty() {\n+            let mut multi_span: MultiSpan = primary_spans.into();\n+            for (span, label) in span_labels {\n+                multi_span.push_span_label(span, label);\n+            }\n+            err.span_note(\n+                multi_span,\n+                format!(\n+                    \"the method call chain might not have had the expected \\\n+                                     associated types\",\n+                ),\n+            );\n+        }\n+    }\n }\n \n /// Collect all the returned expressions within the input expression.\n@@ -3543,72 +3566,3 @@ impl<'tcx> TypeFolder<'tcx> for ReplaceImplTraitFolder<'tcx> {\n         self.tcx\n     }\n }\n-\n-pub struct CollectAllMismatches<'a, 'tcx> {\n-    pub infcx: &'a InferCtxt<'tcx>,\n-    pub param_env: ty::ParamEnv<'tcx>,\n-    pub errors: Vec<TypeError<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n-    fn tag(&self) -> &'static str {\n-        \"CollectAllMismatches\"\n-    }\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-    fn intercrate(&self) -> bool {\n-        false\n-    }\n-    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        self.param_env\n-    }\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    } // irrelevant\n-    fn mark_ambiguous(&mut self) {\n-        bug!()\n-    }\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        _: ty::Variance,\n-        _: ty::VarianceDiagInfo<'tcx>,\n-        a: T,\n-        b: T,\n-    ) -> RelateResult<'tcx, T> {\n-        self.relate(a, b)\n-    }\n-    fn regions(\n-        &mut self,\n-        a: ty::Region<'tcx>,\n-        _b: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        Ok(a)\n-    }\n-    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        if a == b || matches!(a.kind(), ty::Infer(_)) || matches!(b.kind(), ty::Infer(_)) {\n-            return Ok(a);\n-        }\n-        relate::super_relate_tys(self, a, b).or_else(|e| {\n-            self.errors.push(e);\n-            Ok(a)\n-        })\n-    }\n-    fn consts(\n-        &mut self,\n-        a: ty::Const<'tcx>,\n-        b: ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n-        if a == b {\n-            return Ok(a);\n-        }\n-        relate::super_relate_consts(self, a, b) // could do something similar here for constants!\n-    }\n-    fn binders<T: Relate<'tcx>>(\n-        &mut self,\n-        a: ty::Binder<'tcx, T>,\n-        b: ty::Binder<'tcx, T>,\n-    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>> {\n-        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n-    }\n-}"}]}