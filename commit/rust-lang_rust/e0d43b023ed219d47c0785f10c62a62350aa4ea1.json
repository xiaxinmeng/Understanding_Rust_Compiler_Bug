{"sha": "e0d43b023ed219d47c0785f10c62a62350aa4ea1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZDQzYjAyM2VkMjE5ZDQ3YzA3ODVmMTBjNjJhNjIzNTBhYTRlYTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-01T06:19:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-07T15:16:14Z"}, "message": "core: Implement necessary traits for ~[T]/~str\n\nCoherence requires that libcore's traits be implemented in libcore for ~[T] and\n~str (due to them being language defined types). These implementations cannot\nlive in libcore forever, but for now, until Heap/Box/Uniq is a lang item, these\nimplementations must reside inside of libcore. While not perfect\nimplementations, these shouldn't reside in libcore for too long.\n\nWith some form of lang item these implementations can be in a proper crate\nbecause the lang item will not be present in libcore.", "tree": {"sha": "a08d2477e448f46526108c94c897ad68f7104ecc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a08d2477e448f46526108c94c897ad68f7104ecc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0d43b023ed219d47c0785f10c62a62350aa4ea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0d43b023ed219d47c0785f10c62a62350aa4ea1", "html_url": "https://github.com/rust-lang/rust/commit/e0d43b023ed219d47c0785f10c62a62350aa4ea1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0d43b023ed219d47c0785f10c62a62350aa4ea1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c67ebf1ef3fa7766ad17059fc953095116eadba9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c67ebf1ef3fa7766ad17059fc953095116eadba9", "html_url": "https://github.com/rust-lang/rust/commit/c67ebf1ef3fa7766ad17059fc953095116eadba9"}], "stats": {"total": 200, "additions": 200, "deletions": 0}, "files": [{"sha": "a1833534ab864bff603a9b34b750d39deb39661d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0d43b023ed219d47c0785f10c62a62350aa4ea1/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d43b023ed219d47c0785f10c62a62350aa4ea1/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=e0d43b023ed219d47c0785f10c62a62350aa4ea1", "patch": "@@ -73,3 +73,6 @@ pub mod char;\n pub mod slice;\n pub mod str;\n pub mod tuple;\n+\n+// FIXME: this module should not exist\n+mod should_not_exist;"}, {"sha": "83e4c0d339f2632f9a6a14247ebb66c5033739d5", "filename": "src/libcore/should_not_exist.rs", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/e0d43b023ed219d47c0785f10c62a62350aa4ea1/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0d43b023ed219d47c0785f10c62a62350aa4ea1/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=e0d43b023ed219d47c0785f10c62a62350aa4ea1", "patch": "@@ -0,0 +1,197 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast;\n+use char::Char;\n+use clone::Clone;\n+use container::Container;\n+use default::Default;\n+use intrinsics;\n+use iter::{Iterator, FromIterator};\n+use mem;\n+use num::{CheckedMul, CheckedAdd};\n+use ops::Add;\n+use option::{Some, None};\n+use ptr::RawPtr;\n+use ptr;\n+use raw::Vec;\n+use slice::{ImmutableVector, Vector};\n+use str::StrSlice;\n+\n+#[allow(ctypes)]\n+extern {\n+    fn malloc(size: uint) -> *u8;\n+    fn free(ptr: *u8);\n+}\n+\n+unsafe fn alloc(cap: uint) -> *mut Vec<()> {\n+    let cap = cap.checked_add(&mem::size_of::<Vec<()>>()).expect(\"cap overflow\");\n+    let ret = malloc(cap) as *mut Vec<()>;\n+    if ret.is_null() {\n+        intrinsics::abort();\n+    }\n+    (*ret).fill = 0;\n+    (*ret).alloc = cap;\n+    ret\n+}\n+\n+// Strings\n+\n+impl Default for ~str {\n+    fn default() -> ~str {\n+        unsafe {\n+            // Get some memory\n+            let ptr = alloc(0);\n+\n+            // Initialize the memory\n+            (*ptr).fill = 0;\n+            (*ptr).alloc = 0;\n+\n+            cast::transmute(ptr)\n+        }\n+    }\n+}\n+\n+impl Clone for ~str {\n+    fn clone(&self) -> ~str {\n+        // Don't use the clone() implementation above because it'll start\n+        // requiring the eh_personality lang item (no fun)\n+        unsafe {\n+            let bytes = self.as_bytes().as_ptr();\n+            let len = self.len();\n+\n+            let ptr = alloc(len) as *mut Vec<u8>;\n+            ptr::copy_nonoverlapping_memory(&mut (*ptr).data, bytes, len);\n+            (*ptr).fill = len;\n+            (*ptr).alloc = len;\n+\n+            cast::transmute(ptr)\n+        }\n+    }\n+}\n+\n+impl FromIterator<char> for ~str {\n+    #[inline]\n+    fn from_iter<T: Iterator<char>>(mut iterator: T) -> ~str {\n+        let (lower, _) = iterator.size_hint();\n+        let mut cap = if lower == 0 {16} else {lower};\n+        let mut len = 0;\n+        let mut tmp = [0u8, ..4];\n+\n+        unsafe {\n+            let mut ptr = alloc(cap) as *mut Vec<u8>;\n+            let mut ret = cast::transmute(ptr);\n+            for ch in iterator {\n+                let amt = ch.encode_utf8(tmp);\n+\n+                if len + amt > cap {\n+                    cap = cap.checked_mul(&2).expect(\"cap overflow\");\n+                    if cap < len + amt {\n+                        cap = len + amt;\n+                    }\n+                    let ptr2 = alloc(cap) as *mut Vec<u8>;\n+                    ptr::copy_nonoverlapping_memory(&mut (*ptr2).data,\n+                                                    &(*ptr).data,\n+                                                    len);\n+                    free(ptr as *u8);\n+                    cast::forget(ret);\n+                    ret = cast::transmute(ptr2);\n+                    ptr = ptr2;\n+                }\n+\n+                let base = &mut (*ptr).data as *mut u8;\n+                for byte in tmp.slice_to(amt).iter() {\n+                    *base.offset(len as int) = *byte;\n+                    len += 1;\n+                }\n+                (*ptr).fill = len;\n+            }\n+            ret\n+        }\n+    }\n+}\n+\n+impl<'a> Add<&'a str,~str> for &'a str {\n+    #[inline]\n+    fn add(&self, rhs: & &'a str) -> ~str {\n+        let amt = self.len().checked_add(&rhs.len()).expect(\"len overflow\");\n+        unsafe {\n+            let ptr = alloc(amt) as *mut Vec<u8>;\n+            let base = &mut (*ptr).data as *mut _;\n+            ptr::copy_nonoverlapping_memory(base,\n+                                            self.as_bytes().as_ptr(),\n+                                            self.len());\n+            let base = base.offset(self.len() as int);\n+            ptr::copy_nonoverlapping_memory(base,\n+                                            rhs.as_bytes().as_ptr(),\n+                                            rhs.len());\n+            (*ptr).fill = amt;\n+            (*ptr).alloc = amt;\n+            cast::transmute(ptr)\n+        }\n+    }\n+}\n+\n+// Arrays\n+\n+impl<A: Clone> Clone for ~[A] {\n+    #[inline]\n+    fn clone(&self) -> ~[A] {\n+        self.iter().map(|a| a.clone()).collect()\n+    }\n+}\n+\n+impl<A> FromIterator<A> for ~[A] {\n+    fn from_iter<T: Iterator<A>>(mut iterator: T) -> ~[A] {\n+        let (lower, _) = iterator.size_hint();\n+        let cap = if lower == 0 {16} else {lower};\n+        let mut cap = cap.checked_mul(&mem::size_of::<A>()).expect(\"cap overflow\");\n+        let mut len = 0;\n+\n+        unsafe {\n+            let mut ptr = alloc(cap) as *mut Vec<A>;\n+            let mut ret = cast::transmute(ptr);\n+            for elt in iterator {\n+                if len * mem::size_of::<A>() >= cap {\n+                    cap = cap.checked_mul(&2).expect(\"cap overflow\");\n+                    let ptr2 = alloc(cap) as *mut Vec<A>;\n+                    ptr::copy_nonoverlapping_memory(&mut (*ptr2).data,\n+                                                    &(*ptr).data,\n+                                                    len);\n+                    free(ptr as *u8);\n+                    cast::forget(ret);\n+                    ret = cast::transmute(ptr2);\n+                    ptr = ptr2;\n+                }\n+\n+                let base = &mut (*ptr).data as *mut A;\n+                intrinsics::move_val_init(&mut *base.offset(len as int), elt);\n+                len += 1;\n+                (*ptr).fill = len * mem::nonzero_size_of::<A>();\n+            }\n+            ret\n+        }\n+    }\n+}\n+\n+impl<'a,T:Clone, V: Vector<T>> Add<V, ~[T]> for &'a [T] {\n+    #[inline]\n+    fn add(&self, rhs: &V) -> ~[T] {\n+        let first = self.iter().map(|t| t.clone());\n+        first.chain(rhs.as_slice().iter().map(|t| t.clone())).collect()\n+    }\n+}\n+\n+impl<T:Clone, V: Vector<T>> Add<V, ~[T]> for ~[T] {\n+    #[inline]\n+    fn add(&self, rhs: &V) -> ~[T] {\n+        self.as_slice() + rhs.as_slice()\n+    }\n+}"}]}