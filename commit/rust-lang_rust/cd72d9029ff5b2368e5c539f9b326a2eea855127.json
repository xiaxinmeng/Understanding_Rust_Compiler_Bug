{"sha": "cd72d9029ff5b2368e5c539f9b326a2eea855127", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNzJkOTAyOWZmNWIyMzY4ZTVjNTM5ZjliMzI2YTJlZWE4NTUxMjc=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-01T03:28:38Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-05T17:56:57Z"}, "message": "Find the first segment that failed to resolve for _any_ namespace\n\nMoves this detection into `resolution_failure` to avoid doing\nunnecessary work and make the control flow a little easier to work with.", "tree": {"sha": "43695d1e5e3a3ae5f67c9608f64cc232810d893b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43695d1e5e3a3ae5f67c9608f64cc232810d893b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd72d9029ff5b2368e5c539f9b326a2eea855127", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd72d9029ff5b2368e5c539f9b326a2eea855127", "html_url": "https://github.com/rust-lang/rust/commit/cd72d9029ff5b2368e5c539f9b326a2eea855127", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd72d9029ff5b2368e5c539f9b326a2eea855127/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8318a185f301de617c64376fbd3a2d556296c8bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8318a185f301de617c64376fbd3a2d556296c8bb", "html_url": "https://github.com/rust-lang/rust/commit/8318a185f301de617c64376fbd3a2d556296c8bb"}], "stats": {"total": 161, "additions": 102, "deletions": 59}, "files": [{"sha": "d8abf411de7c23914e3ef5ab48b603cc7a0df7a8", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 64, "deletions": 45, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/cd72d9029ff5b2368e5c539f9b326a2eea855127/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd72d9029ff5b2368e5c539f9b326a2eea855127/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=cd72d9029ff5b2368e5c539f9b326a2eea855127", "patch": "@@ -60,8 +60,8 @@ enum ResolutionFailure<'a> {\n     /// This has a partial resolution, but is not in the TypeNS and so cannot\n     /// have associated items or fields.\n     CannotHaveAssociatedItems(Res, Namespace),\n-    /// `String` is the base name of the path (not necessarily the whole link)\n-    NotInScope(Cow<'a, str>),\n+    /// `name` is the base name of the path (not necessarily the whole link)\n+    NotInScope { module_id: DefId, name: Cow<'a, str> },\n     /// this is a primitive type without an impls (no associated methods)\n     /// when will this actually happen?\n     /// the `Res` is the primitive it resolved to\n@@ -92,7 +92,7 @@ impl ResolutionFailure<'a> {\n             | NotAVariant(res, _)\n             | WrongNamespace(res, _)\n             | CannotHaveAssociatedItems(res, _) => Some(*res),\n-            NotInScope(_) | NoParentItem | Dummy => None,\n+            NotInScope { .. } | NoParentItem | Dummy => None,\n         }\n     }\n \n@@ -142,7 +142,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             .expect(\"fold_item should ensure link is non-empty\");\n         let variant_name =\n             // we're not sure this is a variant at all, so use the full string\n-            split.next().map(|f| Symbol::intern(f)).ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope(path_str.into())))?;\n+            split.next().map(|f| Symbol::intern(f)).ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope{\n+                module_id,\n+                name: path_str.into(),\n+            }))?;\n         let path = split\n             .next()\n             .map(|f| {\n@@ -153,38 +156,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n                 f.to_owned()\n             })\n-            .ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope(\n-                variant_name.to_string().into(),\n-            )))?;\n+            .ok_or(ErrorKind::Resolve(ResolutionFailure::NotInScope {\n+                module_id,\n+                name: variant_name.to_string().into(),\n+            }))?;\n         let ty_res = cx\n             .enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n             })\n             .map(|(_, res)| res)\n             .unwrap_or(Res::Err);\n-        // This code only gets hit if three path segments in a row don't get resolved.\n-        // It's a good time to check if _any_ parent of the path gets resolved.\n-        // If so, report it and say the first which failed; if not, say the first path segment didn't resolve.\n         if let Res::Err = ty_res {\n-            let mut current = path.as_str();\n-            while let Some(parent) = current.rsplitn(2, \"::\").nth(1) {\n-                current = parent;\n-                if let Some(res) = self.check_full_res(\n-                    TypeNS,\n-                    &current,\n-                    Some(module_id),\n-                    current_item,\n-                    extra_fragment,\n-                ) {\n-                    return Err(ErrorKind::Resolve(ResolutionFailure::NoAssocItem(\n-                        res,\n-                        Symbol::intern(&path),\n-                    )));\n-                }\n-            }\n-            return Err(ErrorKind::Resolve(ResolutionFailure::NotInScope(\n-                current.to_string().into(),\n-            )));\n+            return Err(ErrorKind::Resolve(ResolutionFailure::NotInScope {\n+                module_id,\n+                name: path.into(),\n+            }));\n         }\n         let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n         match ty_res {\n@@ -301,7 +287,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     });\n                 }\n             }\n-            Err(ResolutionFailure::NotInScope(path_str.into()))\n+            Err(ResolutionFailure::NotInScope {\n+                module_id: parent_id.expect(\"already saw `Some` when resolving as a macro\"),\n+                name: path_str.into(),\n+            })\n         })\n     }\n     /// Resolves a string as a path within a particular namespace. Also returns an optional\n@@ -384,7 +373,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n                 .ok_or_else(|| {\n                     debug!(\"found no `::`, assumming {} was correctly not in scope\", item_name);\n-                    ErrorKind::Resolve(ResolutionFailure::NotInScope(item_name.to_string().into()))\n+                    ErrorKind::Resolve(ResolutionFailure::NotInScope {\n+                        module_id,\n+                        name: item_name.to_string().into(),\n+                    })\n                 })?;\n \n             if let Some((path, prim)) = is_primitive(&path_root, TypeNS) {\n@@ -451,7 +443,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                     }\n                                 }\n                             }\n-                            ResolutionFailure::NotInScope(path_root.into())\n+                            ResolutionFailure::NotInScope { module_id, name: path_root.into() }\n                         });\n                         Err(ErrorKind::Resolve(kind))\n                     };\n@@ -996,7 +988,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                     }\n                                 }\n                                 resolution_failure(\n-                                    cx,\n+                                    self,\n                                     &item,\n                                     path_str,\n                                     disambiguator,\n@@ -1076,7 +1068,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         if len == 0 {\n                             drop(candidates_iter);\n                             resolution_failure(\n-                                cx,\n+                                self,\n                                 &item,\n                                 path_str,\n                                 disambiguator,\n@@ -1096,8 +1088,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         } else {\n                             drop(candidates_iter);\n                             if is_derive_trait_collision(&candidates) {\n-                                candidates.macro_ns =\n-                                    Err(ResolutionFailure::NotInScope(path_str.into()));\n+                                candidates.macro_ns = Err(ResolutionFailure::Dummy);\n                             }\n                             // If we're reporting an ambiguity, don't mention the namespaces that failed\n                             let candidates =\n@@ -1131,7 +1122,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                     }\n                                 }\n                                 resolution_failure(\n-                                    cx,\n+                                    self,\n                                     &item,\n                                     path_str,\n                                     disambiguator,\n@@ -1507,7 +1498,7 @@ fn report_diagnostic(\n }\n \n fn resolution_failure(\n-    cx: &DocContext<'_>,\n+    collector: &LinkCollector<'_, '_>,\n     item: &Item,\n     path_str: &str,\n     disambiguator: Option<Disambiguator>,\n@@ -1516,19 +1507,23 @@ fn resolution_failure(\n     kinds: SmallVec<[ResolutionFailure<'_>; 3]>,\n ) {\n     report_diagnostic(\n-        cx,\n+        collector.cx,\n         &format!(\"unresolved link to `{}`\", path_str),\n         item,\n         dox,\n         &link_range,\n         |diag, sp| {\n             let in_scope = kinds.iter().any(|kind| kind.res().is_some());\n             let item = |res: Res| {\n-                format!(\"the {} `{}`\", res.descr(), cx.tcx.item_name(res.def_id()).to_string())\n+                format!(\n+                    \"the {} `{}`\",\n+                    res.descr(),\n+                    collector.cx.tcx.item_name(res.def_id()).to_string()\n+                )\n             };\n             let assoc_item_not_allowed = |res: Res, diag: &mut DiagnosticBuilder<'_>| {\n                 let def_id = res.def_id();\n-                let name = cx.tcx.item_name(def_id);\n+                let name = collector.cx.tcx.item_name(def_id);\n                 let note = format!(\n                     \"`{}` is {} {}, not a module or type, and cannot have associated items\",\n                     name,\n@@ -1539,18 +1534,42 @@ fn resolution_failure(\n             };\n             // ignore duplicates\n             let mut variants_seen = SmallVec::<[_; 3]>::new();\n-            for failure in kinds {\n+            for mut failure in kinds {\n+                // Check if _any_ parent of the path gets resolved.\n+                // If so, report it and say the first which failed; if not, say the first path segment didn't resolve.\n+                if let ResolutionFailure::NotInScope { module_id, name } = &mut failure {\n+                    let mut current = name.as_ref();\n+                    loop {\n+                        current = match current.rsplitn(2, \"::\").nth(1) {\n+                            Some(p) => p,\n+                            None => {\n+                                *name = current.to_owned().into();\n+                                break;\n+                            }\n+                        };\n+                        if let Some(res) = collector.check_full_res(\n+                            TypeNS,\n+                            &current,\n+                            Some(*module_id),\n+                            &None,\n+                            &None,\n+                        ) {\n+                            failure = ResolutionFailure::NoAssocItem(res, Symbol::intern(current));\n+                            break;\n+                        }\n+                    }\n+                }\n                 let variant = std::mem::discriminant(&failure);\n                 if variants_seen.contains(&variant) {\n                     continue;\n                 }\n                 variants_seen.push(variant);\n                 match failure {\n-                    ResolutionFailure::NotInScope(base) => {\n+                    ResolutionFailure::NotInScope { name, .. } => {\n                         if in_scope {\n                             continue;\n                         }\n-                        diag.note(&format!(\"no item named `{}` is in scope\", base));\n+                        diag.note(&format!(\"no item named `{}` is in scope\", name));\n                         // If the link has `::` in the path, assume it's meant to be an intra-doc link\n                         if !path_str.contains(\"::\") {\n                             // Otherwise, the `[]` might be unrelated.\n@@ -1608,7 +1627,7 @@ fn resolution_failure(\n                                 x,\n                             ),\n                         };\n-                        let name = cx.tcx.item_name(def_id);\n+                        let name = collector.cx.tcx.item_name(def_id);\n                         let path_description = if let Some(disambiguator) = disambiguator {\n                             disambiguator.descr()\n                         } else {"}, {"sha": "477ad6464f8878f033d2c383bd2c9c7eb7c221ab", "filename": "src/test/rustdoc-ui/intra-link-errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd72d9029ff5b2368e5c539f9b326a2eea855127/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd72d9029ff5b2368e5c539f9b326a2eea855127/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.rs?ref=cd72d9029ff5b2368e5c539f9b326a2eea855127", "patch": "@@ -8,6 +8,14 @@\n //~^ ERROR unresolved link\n //~| NOTE no item named `path` is in scope\n \n+/// [path::to::nonexistent::macro!]\n+//~^ ERROR unresolved link\n+//~| NOTE no item named `path` is in scope\n+\n+/// [type@path::to::nonexistent::type]\n+//~^ ERROR unresolved link\n+//~| NOTE no item named `path` is in scope\n+\n /// [std::io::not::here]\n //~^ ERROR unresolved link\n //~| NOTE the module `io` has no inner item"}, {"sha": "3b1a09f913e9f5d70f0dbe0e8b369562efcfc4c5", "filename": "src/test/rustdoc-ui/intra-link-errors.stderr", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cd72d9029ff5b2368e5c539f9b326a2eea855127/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd72d9029ff5b2368e5c539f9b326a2eea855127/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr?ref=cd72d9029ff5b2368e5c539f9b326a2eea855127", "patch": "@@ -11,109 +11,125 @@ LL | #![deny(broken_intra_doc_links)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n    = note: no item named `path` is in scope\n \n-error: unresolved link to `std::io::not::here`\n+error: unresolved link to `path::to::nonexistent::macro`\n   --> $DIR/intra-link-errors.rs:11:6\n    |\n+LL | /// [path::to::nonexistent::macro!]\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: no item named `path` is in scope\n+\n+error: unresolved link to `path::to::nonexistent::type`\n+  --> $DIR/intra-link-errors.rs:15:6\n+   |\n+LL | /// [type@path::to::nonexistent::type]\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: no item named `path` is in scope\n+\n+error: unresolved link to `std::io::not::here`\n+  --> $DIR/intra-link-errors.rs:19:6\n+   |\n LL | /// [std::io::not::here]\n    |      ^^^^^^^^^^^^^^^^^^\n    |\n    = note: the module `io` has no inner item named `not`\n \n error: unresolved link to `std::io::Error::x`\n-  --> $DIR/intra-link-errors.rs:15:6\n+  --> $DIR/intra-link-errors.rs:23:6\n    |\n LL | /// [std::io::Error::x]\n    |      ^^^^^^^^^^^^^^^^^\n    |\n    = note: the struct `Error` has no field or associated item named `x`\n \n error: unresolved link to `std::io::ErrorKind::x`\n-  --> $DIR/intra-link-errors.rs:19:6\n+  --> $DIR/intra-link-errors.rs:27:6\n    |\n LL | /// [std::io::ErrorKind::x]\n    |      ^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the enum `ErrorKind` has no variant or associated item named `x`\n \n error: unresolved link to `f::A`\n-  --> $DIR/intra-link-errors.rs:23:6\n+  --> $DIR/intra-link-errors.rs:31:6\n    |\n LL | /// [f::A]\n    |      ^^^^\n    |\n    = note: `f` is a function, not a module or type, and cannot have associated items\n \n error: unresolved link to `S::A`\n-  --> $DIR/intra-link-errors.rs:27:6\n+  --> $DIR/intra-link-errors.rs:35:6\n    |\n LL | /// [S::A]\n    |      ^^^^\n    |\n    = note: the struct `S` has no field or associated item named `A`\n \n error: unresolved link to `S::fmt`\n-  --> $DIR/intra-link-errors.rs:31:6\n+  --> $DIR/intra-link-errors.rs:39:6\n    |\n LL | /// [S::fmt]\n    |      ^^^^^^\n    |\n    = note: the struct `S` has no field or associated item named `fmt`\n \n error: unresolved link to `E::D`\n-  --> $DIR/intra-link-errors.rs:35:6\n+  --> $DIR/intra-link-errors.rs:43:6\n    |\n LL | /// [E::D]\n    |      ^^^^\n    |\n    = note: the enum `E` has no variant or associated item named `D`\n \n error: unresolved link to `u8::not_found`\n-  --> $DIR/intra-link-errors.rs:39:6\n+  --> $DIR/intra-link-errors.rs:47:6\n    |\n LL | /// [u8::not_found]\n    |      ^^^^^^^^^^^^^\n    |\n    = note: the builtin type `u8` does not have an associated item named `not_found`\n \n error: unresolved link to `S`\n-  --> $DIR/intra-link-errors.rs:43:6\n+  --> $DIR/intra-link-errors.rs:51:6\n    |\n LL | /// [S!]\n    |      ^^ help: to link to the struct, prefix with `struct@`: `struct@S`\n    |\n    = note: this link resolves to the struct `S`, which is not in the macro namespace\n \n error: unresolved link to `T::g`\n-  --> $DIR/intra-link-errors.rs:61:6\n+  --> $DIR/intra-link-errors.rs:69:6\n    |\n LL | /// [type@T::g]\n    |      ^^^^^^^^^ help: to link to the associated function, add parentheses: `T::g()`\n    |\n    = note: this link resolves to the associated function `g`, which is not in the type namespace\n \n error: unresolved link to `T::h`\n-  --> $DIR/intra-link-errors.rs:66:6\n+  --> $DIR/intra-link-errors.rs:74:6\n    |\n LL | /// [T::h!]\n    |      ^^^^^\n    |\n    = note: the trait `T` has no macro named `h`\n \n error: unresolved link to `S::h`\n-  --> $DIR/intra-link-errors.rs:53:6\n+  --> $DIR/intra-link-errors.rs:61:6\n    |\n LL | /// [type@S::h]\n    |      ^^^^^^^^^ help: to link to the associated function, add parentheses: `S::h()`\n    |\n    = note: this link resolves to the associated function `h`, which is not in the type namespace\n \n error: unresolved link to `m`\n-  --> $DIR/intra-link-errors.rs:73:6\n+  --> $DIR/intra-link-errors.rs:81:6\n    |\n LL | /// [m()]\n    |      ^^^ help: to link to the macro, add an exclamation mark: `m!`\n    |\n    = note: this link resolves to the macro `m`, which is not in the value namespace\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 16 previous errors\n "}]}