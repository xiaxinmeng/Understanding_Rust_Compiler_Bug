{"sha": "ed3810bf5e284b243b4500951652839235dd2113", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMzgxMGJmNWUyODRiMjQzYjQ1MDA5NTE2NTI4MzkyMzVkZDIxMTM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-18T12:05:27Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-18T12:09:11Z"}, "message": "lower `move_val_init` during MIR construction\n\nBecause of its \"magic\" order-of-evaluation semantics, `move_val_init`\nmust be lowered during MIR construction in order to work.", "tree": {"sha": "c6b9e3b0aae1d0c99de6375b1951e4d4eab481c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6b9e3b0aae1d0c99de6375b1951e4d4eab481c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed3810bf5e284b243b4500951652839235dd2113", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed3810bf5e284b243b4500951652839235dd2113", "html_url": "https://github.com/rust-lang/rust/commit/ed3810bf5e284b243b4500951652839235dd2113", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed3810bf5e284b243b4500951652839235dd2113/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e473b1aaa4adf205c4d825a35fcd7b74dad1518", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e473b1aaa4adf205c4d825a35fcd7b74dad1518", "html_url": "https://github.com/rust-lang/rust/commit/3e473b1aaa4adf205c4d825a35fcd7b74dad1518"}], "stats": {"total": 106, "additions": 76, "deletions": 30}, "files": [{"sha": "a334923546fb2df76a8c4ccb73cd242bf11ae6ab", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed3810bf5e284b243b4500951652839235dd2113/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3810bf5e284b243b4500951652839235dd2113/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=ed3810bf5e284b243b4500951652839235dd2113", "patch": "@@ -38,9 +38,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"expr_as_temp(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n-        if let ExprKind::Scope { .. } = expr.kind {\n-            span_bug!(expr.span, \"unexpected scope expression in as_temp: {:?}\",\n-                      expr);\n+        if let ExprKind::Scope { extent, value } = expr.kind {\n+            return this.in_scope(extent, block, |this| {\n+                this.as_temp(block, temp_lifetime, value)\n+            });\n         }\n \n         let expr_ty = expr.ty.clone();"}, {"sha": "5982d3bdc81a49191e8e1771261ac7df5d9912c0", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ed3810bf5e284b243b4500951652839235dd2113/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3810bf5e284b243b4500951652839235dd2113/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=ed3810bf5e284b243b4500951652839235dd2113", "patch": "@@ -16,6 +16,8 @@ use hair::*;\n use rustc::ty;\n use rustc::mir::*;\n \n+use syntax::abi::Abi;\n+\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n@@ -206,25 +208,49 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                     _ => false\n                 };\n+                let intrinsic = match ty.sty {\n+                    ty::TyFnDef(def_id, _, ref f) if\n+                        f.abi() == Abi::RustIntrinsic ||\n+                        f.abi() == Abi::PlatformIntrinsic =>\n+                    {\n+                        Some(this.hir.tcx().item_name(def_id).as_str())\n+                    }\n+                    _ => None\n+                };\n+                let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n                 let fun = unpack!(block = this.as_local_operand(block, fun));\n-                let args: Vec<_> =\n-                    args.into_iter()\n-                        .map(|arg| unpack!(block = this.as_local_operand(block, arg)))\n-                        .collect();\n+                if intrinsic == Some(\"move_val_init\") {\n+                    // `move_val_init` has \"magic\" semantics - the second argument is\n+                    // always evaluated \"directly\" into the first one.\n \n-                let success = this.cfg.start_new_block();\n-                let cleanup = this.diverge_cleanup();\n-                this.cfg.terminate(block, source_info, TerminatorKind::Call {\n-                    func: fun,\n-                    args: args,\n-                    cleanup: cleanup,\n-                    destination: if diverges {\n-                        None\n-                    } else {\n-                        Some ((destination.clone(), success))\n-                    }\n-                });\n-                success.unit()\n+                    let mut args = args.into_iter();\n+                    let ptr = args.next().expect(\"0 arguments to `move_val_init`\");\n+                    let val = args.next().expect(\"1 argument to `move_val_init`\");\n+                    assert!(args.next().is_none(), \">2 arguments to `move_val_init`\");\n+\n+                    let topmost_scope = this.topmost_scope();\n+                    let ptr = unpack!(block = this.as_temp(block, Some(topmost_scope), ptr));\n+                    this.into(&ptr.deref(), block, val)\n+                } else {\n+                    let args: Vec<_> =\n+                        args.into_iter()\n+                            .map(|arg| unpack!(block = this.as_local_operand(block, arg)))\n+                            .collect();\n+\n+                    let success = this.cfg.start_new_block();\n+                    let cleanup = this.diverge_cleanup();\n+                    this.cfg.terminate(block, source_info, TerminatorKind::Call {\n+                        func: fun,\n+                        args: args,\n+                        cleanup: cleanup,\n+                        destination: if diverges {\n+                            None\n+                        } else {\n+                            Some ((destination.clone(), success))\n+                        }\n+                    });\n+                    success.unit()\n+                }\n             }\n \n             // These cases don't actually need a destination"}, {"sha": "0f5a38ac7f6b886343372514dd9ce887baa29a08", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed3810bf5e284b243b4500951652839235dd2113/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3810bf5e284b243b4500951652839235dd2113/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ed3810bf5e284b243b4500951652839235dd2113", "patch": "@@ -418,16 +418,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 };\n                 let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n \n-                if intrinsic == Some(\"move_val_init\") {\n-                    let &(_, target) = destination.as_ref().unwrap();\n-                    // The first argument is a thin destination pointer.\n-                    let llptr = self.trans_operand(&bcx, &args[0]).immediate();\n-                    let val = self.trans_operand(&bcx, &args[1]);\n-                    self.store_operand(&bcx, llptr, None, val);\n-                    funclet_br(self, bcx, target);\n-                    return;\n-                }\n-\n                 if intrinsic == Some(\"transmute\") {\n                     let &(ref dest, target) = destination.as_ref().unwrap();\n                     self.trans_transmute(&bcx, &args[0], dest);"}, {"sha": "98b7db60b68fc8a6016519ee0fdaa0884c5fc285", "filename": "src/test/codegen/move-val-init.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ed3810bf5e284b243b4500951652839235dd2113/src%2Ftest%2Fcodegen%2Fmove-val-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed3810bf5e284b243b4500951652839235dd2113/src%2Ftest%2Fcodegen%2Fmove-val-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmove-val-init.rs?ref=ed3810bf5e284b243b4500951652839235dd2113", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![feature(core_intrinsics)]\n+#![crate_type = \"lib\"]\n+\n+// test that `move_val_init` actually avoids big allocas\n+\n+use std::intrinsics::move_val_init;\n+\n+pub struct Big {\n+    pub data: [u8; 65536]\n+}\n+\n+// CHECK-LABEL: @test_mvi\n+#[no_mangle]\n+pub unsafe fn test_mvi(target: *mut Big, make_big: fn() -> Big) {\n+    // CHECK: call void %1(%Big*{{[^%]*}} %0)\n+    move_val_init(target, make_big());\n+}"}]}