{"sha": "61be3cc19e4c01cb0d9f9fac3ed52a0819c8fcc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxYmUzY2MxOWU0YzAxY2IwZDlmOWZhYzNlZDUyYTA4MTljOGZjYzU=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-22T19:52:13Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-06T17:42:38Z"}, "message": "An example using pipes with most of the synchronization code in place.\n\nFixed a bug in the atomic intrinsics where they wouldn't correctly return their old value.\n\nPipes currently busy wait. The next step is to teach the scheduler how to deal with them.", "tree": {"sha": "b4f78ef65d4b0f4d907bf1f1c928e5ed357af7c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4f78ef65d4b0f4d907bf1f1c928e5ed357af7c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61be3cc19e4c01cb0d9f9fac3ed52a0819c8fcc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61be3cc19e4c01cb0d9f9fac3ed52a0819c8fcc5", "html_url": "https://github.com/rust-lang/rust/commit/61be3cc19e4c01cb0d9f9fac3ed52a0819c8fcc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61be3cc19e4c01cb0d9f9fac3ed52a0819c8fcc5/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dbd10a7024a30ca21571254166ebbe4a10b1beb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dbd10a7024a30ca21571254166ebbe4a10b1beb", "html_url": "https://github.com/rust-lang/rust/commit/4dbd10a7024a30ca21571254166ebbe4a10b1beb"}], "stats": {"total": 247, "additions": 247, "deletions": 0}, "files": [{"sha": "e0c77026f48f9319fca0589e4e0914208a965aaf", "filename": "src/test/run-pass/pipe-manual-2.rs", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/61be3cc19e4c01cb0d9f9fac3ed52a0819c8fcc5/src%2Ftest%2Frun-pass%2Fpipe-manual-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61be3cc19e4c01cb0d9f9fac3ed52a0819c8fcc5/src%2Ftest%2Frun-pass%2Fpipe-manual-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-manual-2.rs?ref=61be3cc19e4c01cb0d9f9fac3ed52a0819c8fcc5", "patch": "@@ -0,0 +1,247 @@\n+/*\n+The first test case using pipes. The idea is to break this into\n+several stages for prototyping. Here's the plan:\n+\n+1. Write an already-compiled protocol using existing ports and chans.\n+\n+2. Take the already-compiled version and add the low-level\n+synchronization code instead. (That's what this file attempts to do)\n+\n+3. Write a syntax extension to compile the protocols.\n+\n+At some point, we'll need to add support for select.\n+\n+*/\n+\n+// Hopefully someday we'll move this into core.\n+mod pipes {\n+    import unsafe::{forget, reinterpret_cast};\n+\n+    enum state {\n+        empty,\n+        full,\n+        blocked,\n+        terminated\n+    }\n+\n+    type packet<T: send> = {\n+        mut state: state,\n+        mut blocked_task: option<task::task>,\n+        mut payload: option<T>\n+    };\n+\n+    fn packet<T: send>() -> *packet<T> unsafe {\n+        let p: *packet<T> = unsafe::transmute(~{\n+            mut state: empty,\n+            mut blocked_task: none::<task::task>,\n+            mut payload: none::<T>\n+        });\n+        p\n+    }\n+\n+    #[abi = \"rust-intrinsic\"]\n+    native mod rusti {\n+        fn atomic_xchng(&dst: int, src: int) -> int;\n+        fn atomic_xchng_acq(&dst: int, src: int) -> int;\n+        fn atomic_xchng_rel(&dst: int, src: int) -> int;\n+    }\n+\n+    // We should consider moving this to core::unsafe, although I\n+    // suspect graydon would want us to use void pointers instead.\n+    unsafe fn uniquify<T>(x: *T) -> ~T {\n+        unsafe { unsafe::reinterpret_cast(x) }\n+    }\n+\n+    fn swap_state_acq(&dst: state, src: state) -> state {\n+        unsafe {\n+            reinterpret_cast(rusti::atomic_xchng_acq(\n+                *(ptr::mut_addr_of(dst) as *mut int),\n+                src as int))\n+        }\n+    }\n+\n+    fn swap_state_rel(&dst: state, src: state) -> state {\n+        unsafe {\n+            reinterpret_cast(rusti::atomic_xchng_rel(\n+                *(ptr::mut_addr_of(dst) as *mut int),\n+                src as int))\n+        }\n+    }\n+\n+    fn send<T: send>(p: *packet<T>, -payload: T) {\n+        let p = unsafe { uniquify(p) };\n+        assert (*p).payload == none;\n+        (*p).payload <- some(payload);\n+        let old_state = swap_state_rel((*p).state, full);\n+        alt old_state {\n+          empty {\n+            // Yay, fastpath.\n+\n+            // The receiver will eventually clean this up.\n+            unsafe { forget(p); }\n+          }\n+          full { fail \"duplicate send\" }\n+          blocked {\n+            // FIXME: once the target will actually block, tell the\n+            // scheduler to wake it up.\n+\n+            // The receiver will eventually clean this up.\n+            unsafe { forget(p); }\n+          }\n+          terminated {\n+            // The receiver will never receive this. Rely on drop_glue\n+            // to clean everything up.\n+          }\n+        }\n+    }\n+\n+    fn recv<T: send>(p: *packet<T>) -> option<T> {\n+        let p = unsafe { uniquify(p) };\n+        loop {\n+            let old_state = swap_state_acq((*p).state,\n+                                           blocked);\n+            alt old_state {\n+              empty | blocked { task::yield(); }\n+              full {\n+                let mut payload = none;\n+                payload <-> (*p).payload;\n+                ret some(option::unwrap(payload))\n+              }\n+              terminated {\n+                assert old_state == terminated;\n+                ret none;\n+              }\n+            }\n+        }\n+    }\n+\n+    fn sender_terminate<T: send>(p: *packet<T>) {\n+        let p = unsafe { uniquify(p) };\n+        alt swap_state_rel((*p).state, terminated) {\n+          empty | blocked {\n+            // The receiver will eventually clean up.\n+            unsafe { forget(p) }\n+          }\n+          full {\n+            // This is impossible\n+            fail \"you dun goofed\"\n+          }\n+          terminated {\n+            // I have to clean up, use drop_glue\n+          }\n+        }\n+    }\n+\n+    fn receiver_terminate<T: send>(p: *packet<T>) {\n+        let p = unsafe { uniquify(p) };\n+        alt swap_state_rel((*p).state, terminated) {\n+          empty {\n+            // the sender will clean up\n+            unsafe { forget(p) }\n+          }\n+          blocked {\n+            // this shouldn't happen.\n+            fail \"terminating a blocked packet\"\n+          }\n+          terminated | full {\n+            // I have to clean up, use drop_glue\n+          }\n+        }\n+    }\n+}\n+\n+mod pingpong {\n+    enum ping = *pipes::packet<pong>;\n+    enum pong = *pipes::packet<ping>;\n+\n+    fn init() -> (client::ping, server::ping) {\n+        let p = pipes::packet();\n+        let p = pingpong::ping(p);\n+\n+        let client = client::ping(p);\n+        let server = server::ping(p);\n+\n+        (client, server)\n+    }\n+\n+    mod client {\n+        enum ping = pingpong::ping;\n+        enum pong = pingpong::pong;\n+\n+        fn do_ping(-c: ping) -> pong {\n+            let packet = pipes::packet();\n+            let packet = pingpong::pong(packet);\n+\n+            pipes::send(**c, copy packet);\n+            pong(packet)\n+        }\n+\n+        fn do_pong(-c: pong) -> (ping, ()) {\n+            let packet = pipes::recv(**c);\n+            alt packet {\n+              none {\n+                fail \"sender closed the connection\"\n+              }\n+              some(new_packet) {\n+                (ping(new_packet), ())\n+              }\n+            }\n+        }\n+    }\n+\n+    mod server {\n+        enum ping = pingpong::ping;\n+        enum pong = pingpong::pong;\n+\n+        fn do_ping(-c: ping) -> (pong, ()) {\n+            let packet = pipes::recv(**c);\n+            alt packet {\n+              none { fail \"sender closed the connection\" }\n+              some(new_packet) {\n+                (pong(new_packet), ())\n+              }\n+            }\n+        }\n+\n+        fn do_pong(-c: pong) -> ping {\n+            let packet = pipes::packet();\n+            let packet = pingpong::ping(packet);\n+\n+            pipes::send(**c, copy packet);\n+            ping(packet)\n+        }\n+    }\n+}\n+\n+fn client(-chan: pingpong::client::ping) {\n+    let chan = pingpong::client::do_ping(chan);\n+    log(error, \"Sent ping\");\n+    let (chan, _data) = pingpong::client::do_pong(chan);\n+    log(error, \"Received pong\");\n+    pipes::sender_terminate(**chan);\n+}\n+\n+fn server(-chan: pingpong::server::ping) {\n+    let (chan, _data) = pingpong::server::do_ping(chan);\n+    log(error, \"Received ping\");\n+    let chan = pingpong::server::do_pong(chan);\n+    log(error, \"Sent pong\");\n+    pipes::receiver_terminate(**chan);\n+}\n+\n+fn main() {\n+    let (client_, server_) = pingpong::init();\n+    let client_ = ~mut some(client_);\n+    let server_ = ~mut some(server_);\n+\n+    task::spawn {|move client_|\n+        let mut client__ = none;\n+        *client_ <-> client__;\n+        client(option::unwrap(client__));\n+    };\n+    task::spawn {|move server_|\n+        let mut server_\u02ca = none;\n+        *server_ <-> server_\u02ca;\n+        server(option::unwrap(server_\u02ca));\n+    };\n+}"}]}