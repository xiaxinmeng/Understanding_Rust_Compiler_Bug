{"sha": "5388037f8a16d3bf443f348e28873d255db044d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzODgwMzdmOGExNmQzYmY0NDNmMzQ4ZTI4ODczZDI1NWRiMDQ0ZDA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-23T13:59:50Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-23T13:59:50Z"}, "message": "remove code duplication by letting reactivatable() compute what reactivate() has to do", "tree": {"sha": "8725872f5bf189b5d3791110b96fb7a56f9f1ee2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8725872f5bf189b5d3791110b96fb7a56f9f1ee2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5388037f8a16d3bf443f348e28873d255db044d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5388037f8a16d3bf443f348e28873d255db044d0", "html_url": "https://github.com/rust-lang/rust/commit/5388037f8a16d3bf443f348e28873d255db044d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5388037f8a16d3bf443f348e28873d255db044d0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe83ef323cec57465948bdba654201eed22c3355", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe83ef323cec57465948bdba654201eed22c3355", "html_url": "https://github.com/rust-lang/rust/commit/fe83ef323cec57465948bdba654201eed22c3355"}], "stats": {"total": 105, "additions": 47, "deletions": 58}, "files": [{"sha": "f634f17109c747800fd2e6ef96fea15c4a197fcf", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 39, "deletions": 50, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5388037f8a16d3bf443f348e28873d255db044d0/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5388037f8a16d3bf443f348e28873d255db044d0/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=5388037f8a16d3bf443f348e28873d255db044d0", "patch": "@@ -137,75 +137,64 @@ impl<'tcx> Stack {\n     }\n \n     /// Check if `bor` could be activated by unfreezing and popping.\n-    /// This should be in sync with `reactivate`!\n-    fn reactivatable(&self, bor: Borrow) -> bool {\n-        if self.check(bor) {\n-            return true;\n-        }\n-\n-        let acc_m = match bor {\n-            Borrow::Frz(_) => return false,\n-            Borrow::Mut(acc_m) => acc_m\n-        };\n-        // This is where we would unfreeze.\n-        for &itm in self.borrows.iter().rev() {\n-            match itm {\n-                BorStackItem::FnBarrier(_) => return false,\n-                BorStackItem::Mut(loc_m) => {\n-                    if loc_m == acc_m { return true; }\n-                    // Go on looking.\n-                }\n-            }\n-        }\n-        // Nothing to be found.\n-        false\n-    }\n-\n-    /// Reactive `bor` for this stack.  If `force_mut` is set, we want to aggressively\n-    /// unfreeze this location (because we are about to mutate, so a frozen `Raw` is not okay).\n-    fn reactivate(&mut self, bor: Borrow, force_mut: bool) -> EvalResult<'tcx> {\n+    /// `force_mut` indicates whether being frozen is potentially acceptable.\n+    /// Returns `Err` if the answer is \"no\"; otherwise the data says\n+    /// what needs to happen to activate this: `None` = nothing,\n+    /// `Some(n)` = unfreeze and make item `n` the top item of the stack.\n+    fn reactivatable(&self, bor: Borrow, force_mut: bool) -> Result<Option<usize>, String> {\n         // Unless mutation is bound to happen, do NOT change anything if `bor` is already active.\n         // In particular, if it is a `Mut(Raw)` and we are frozen, this should be a NOP.\n         if !force_mut && self.check(bor) {\n-            return Ok(());\n+            return Ok(None);\n         }\n \n         let acc_m = match bor {\n             Borrow::Frz(since) =>\n-                if force_mut {\n-                    return err!(MachineError(format!(\"Using a shared borrow for mutation\")))\n+                return Err(if force_mut {\n+                    format!(\"Using a shared borrow for mutation\")\n                 } else {\n-                    return err!(MachineError(format!(\n+                    format!(\n                         \"Location should be frozen since {} but {}\",\n                         since,\n                         match self.frozen_since {\n                             None => format!(\"it is not frozen at all\"),\n                             Some(since) => format!(\"it is only frozen since {}\", since),\n                         }\n-                    )))\n-                }\n-            Borrow::Mut(acc_m) => acc_m,\n+                    )\n+                }),\n+            Borrow::Mut(acc_m) => acc_m\n         };\n-        // We definitely have to unfreeze this, even if we use the topmost item.\n-        if self.frozen_since.is_some() {\n-            trace!(\"reactivate: Unfreezing\");\n-        }\n-        self.frozen_since = None;\n-        // Pop until we see the one we are looking for.\n-        while let Some(&itm) = self.borrows.last() {\n+        // This is where we would unfreeze.\n+        for (idx, &itm) in self.borrows.iter().enumerate().rev() {\n             match itm {\n-                BorStackItem::FnBarrier(_) => {\n-                    return err!(MachineError(format!(\"Trying to reactivate a borrow that lives behind a barrier\")));\n-                }\n+                BorStackItem::FnBarrier(_) =>\n+                    return Err(format!(\"Trying to reactivate a mutable borrow ({:?}) that lives behind a barrier\", acc_m)),\n                 BorStackItem::Mut(loc_m) => {\n-                    if loc_m == acc_m { return Ok(()); }\n-                    trace!(\"reactivate: Popping {:?}\", itm);\n-                    self.borrows.pop();\n+                    if loc_m == acc_m { return Ok(Some(idx)); }\n                 }\n             }\n         }\n         // Nothing to be found.\n-        err!(MachineError(format!(\"Borrow-to-reactivate does not exist on the stack\")))\n+        Err(format!(\"Mutable borrow-to-reactivate ({:?}) does not exist on the stack\", acc_m))\n+    }\n+\n+    /// Reactive `bor` for this stack.  If `force_mut` is set, we want to aggressively\n+    /// unfreeze this location (because we are about to mutate, so a frozen `Raw` is not okay).\n+    fn reactivate(&mut self, bor: Borrow, force_mut: bool) -> EvalResult<'tcx> {\n+        let action = match self.reactivatable(bor, force_mut) {\n+            Ok(action) => action,\n+            Err(err) => return err!(MachineError(err)),\n+        };\n+\n+        match action {\n+            None => {}, // nothing to do\n+            Some(top) => {\n+                self.frozen_since = None;\n+                self.borrows.truncate(top+1);\n+            }\n+        }\n+\n+        Ok(())\n     }\n \n     /// Initiate `bor`; mostly this means freezing or pushing.\n@@ -471,8 +460,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             // be shared reborrows that we are about to invalidate with this access.\n             // We cannot invalidate them aggressively here because the deref might also be\n             // to just create more shared refs.\n-            if !stack.reactivatable(ptr.tag) {\n-                return err!(MachineError(format!(\"Encountered {:?} reference with non-reactivatable tag {:?}\", ref_kind, ptr.tag)))\n+            if let Err(err) = stack.reactivatable(ptr.tag, /*force_mut*/false) {\n+                return err!(MachineError(format!(\"Encountered {:?} reference with non-reactivatable tag: {}\", ref_kind, err)))\n             }\n         }\n         // All is good."}, {"sha": "7d56f30b3e69db4d636c4c8533527d3ccfae89ed", "filename": "tests/compile-fail/stacked_borrows/alias_through_mutation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs?ref=5388037f8a16d3bf443f348e28873d255db044d0", "patch": "@@ -14,5 +14,5 @@ fn main() {\n     retarget(&mut target_alias, target);\n     // now `target_alias` points to the same thing as `target`\n     *target = 13;\n-    let _val = *target_alias; //~ ERROR Shr reference with non-reactivatable tag Frz\n+    let _val = *target_alias; //~ ERROR Shr reference with non-reactivatable tag\n }"}, {"sha": "dc1e3cc81e9e8af25aad5ea982dac399a808e104", "filename": "tests/compile-fail/stacked_borrows/buggy_as_mut_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=5388037f8a16d3bf443f348e28873d255db044d0", "patch": "@@ -17,6 +17,6 @@ fn main() {\n     let v = vec![0,1,2];\n     let v1 = safe::as_mut_slice(&v);\n     let v2 = safe::as_mut_slice(&v);\n-    v1[1] = 5; //~ ERROR Mut reference with non-reactivatable tag Mut(Uniq\n+    v1[1] = 5; //~ ERROR Mut reference with non-reactivatable tag\n     v1[1] = 6;\n }"}, {"sha": "a697ba9167c0748042b83560a306efa026dd320d", "filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=5388037f8a16d3bf443f348e28873d255db044d0", "patch": "@@ -14,7 +14,7 @@ mod safe {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n-            //~^ ERROR Mut reference with non-reactivatable tag Mut(Uniq\n+            //~^ ERROR Mut reference with non-reactivatable tag\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n         }\n     }"}, {"sha": "131e89572a5015559d0ded780003e3a3e754bff5", "filename": "tests/compile-fail/stacked_borrows/illegal_write1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs?ref=5388037f8a16d3bf443f348e28873d255db044d0", "patch": "@@ -8,5 +8,5 @@ fn main() {\n     let target = Box::new(42); // has an implicit raw\n     let ref_ = &*target;\n     evil(ref_); // invalidates shared ref, activates raw\n-    let _x = *ref_; //~ ERROR Shr reference with non-reactivatable tag Frz\n+    let _x = *ref_; //~ ERROR Shr reference with non-reactivatable tag\n }"}, {"sha": "060cec962c477d99db2cb5db3af4c8f3703136aa", "filename": "tests/compile-fail/stacked_borrows/load_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs?ref=5388037f8a16d3bf443f348e28873d255db044d0", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let xref = unsafe { &mut *xraw };\n     let xref_in_mem = Box::new(xref);\n     let _val = *x; // invalidate xraw\n-    let _val = *xref_in_mem; //~ ERROR Mut reference with non-reactivatable tag Mut(Uniq\n+    let _val = *xref_in_mem; //~ ERROR Mut reference with non-reactivatable tag\n }"}, {"sha": "bc950771add4fb9763c9e7676f0eb0fb25ac8ac4", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs?ref=5388037f8a16d3bf443f348e28873d255db044d0", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &mut *xraw };\n     let _val = *x; // invalidate xraw\n-    foo(xref); //~ ERROR Mut reference with non-reactivatable tag Mut(Uniq\n+    foo(xref); //~ ERROR Mut reference with non-reactivatable tag\n }"}, {"sha": "c02892671e907f75f9a24891098d69472691b40a", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs?ref=5388037f8a16d3bf443f348e28873d255db044d0", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> &mut i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &mut (*xraw).1 };\n     let _val = *x; // invalidate xraw and its children\n-    ret //~ ERROR Mut reference with non-reactivatable tag Mut(Uniq\n+    ret //~ ERROR Mut reference with non-reactivatable tag\n }\n \n fn main() {"}, {"sha": "e3e4c4da7765e921a8577f9839b2614a345fa42d", "filename": "tests/compile-fail/stacked_borrows/shared_confusion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5388037f8a16d3bf443f348e28873d255db044d0/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs?ref=5388037f8a16d3bf443f348e28873d255db044d0", "patch": "@@ -13,7 +13,7 @@ fn test(r: &mut RefCell<i32>) {\n     }\n     // Our old raw should be dead by now\n     unsafe { *x_evil = 0; } // this falls back to some Raw higher up the stack\n-    *x_inner = 12; //~ ERROR Mut reference with non-reactivatable tag Mut(Uniq\n+    *x_inner = 12; //~ ERROR Mut reference with non-reactivatable tag\n }\n \n fn main() {"}]}