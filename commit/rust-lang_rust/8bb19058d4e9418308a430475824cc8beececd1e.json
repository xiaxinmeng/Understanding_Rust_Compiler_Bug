{"sha": "8bb19058d4e9418308a430475824cc8beececd1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYjE5MDU4ZDRlOTQxODMwOGE0MzA0NzU4MjRjYzhiZWVjZWNkMWU=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-04-06T18:08:28Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-04-07T04:01:55Z"}, "message": "Remove rustdocs json format", "tree": {"sha": "b4a0dec309c08d1bdd517d063d0946205e065c73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4a0dec309c08d1bdd517d063d0946205e065c73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bb19058d4e9418308a430475824cc8beececd1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb19058d4e9418308a430475824cc8beececd1e", "html_url": "https://github.com/rust-lang/rust/commit/8bb19058d4e9418308a430475824cc8beececd1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bb19058d4e9418308a430475824cc8beececd1e/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9f34c86a4dd43efa20c673688529516524f23c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9f34c86a4dd43efa20c673688529516524f23c5", "html_url": "https://github.com/rust-lang/rust/commit/a9f34c86a4dd43efa20c673688529516524f23c5"}], "stats": {"total": 189, "additions": 31, "deletions": 158}, "files": [{"sha": "d1134b81e674edc6d7ee985f852063197cab6355", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb19058d4e9418308a430475824cc8beececd1e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb19058d4e9418308a430475824cc8beececd1e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8bb19058d4e9418308a430475824cc8beececd1e", "patch": "@@ -54,10 +54,6 @@ use doctree;\n use visit_ast;\n use html::item_type::ItemType;\n \n-/// A stable identifier to the particular version of JSON output.\n-/// Increment this when the `Crate` and related structures change.\n-pub const SCHEMA_VERSION: &'static str = \"0.8.3\";\n-\n mod inline;\n mod simplify;\n "}, {"sha": "34c0edd8ee1e4f235832c4c3656f46caadc21f23", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 7, "deletions": 94, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8bb19058d4e9418308a430475824cc8beececd1e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb19058d4e9418308a430475824cc8beececd1e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=8bb19058d4e9418308a430475824cc8beececd1e", "patch": "@@ -54,22 +54,16 @@ use std::cell::RefCell;\n use std::collections::HashMap;\n use std::default::Default;\n use std::env;\n-use std::fs::File;\n-use std::io::{self, Read, Write};\n+use std::io::Read;\n use std::path::PathBuf;\n use std::process;\n use std::rc::Rc;\n use std::sync::mpsc::channel;\n \n use externalfiles::ExternalHtml;\n-use serialize::Decodable;\n-use serialize::json::{self, Json};\n use rustc::session::search_paths::SearchPaths;\n use rustc::session::config::{ErrorOutputType, RustcOptGroup, nightly_options};\n \n-// reexported from `clean` so it can be easily updated with the mod itself\n-pub use clean::SCHEMA_VERSION;\n-\n #[macro_use]\n pub mod externalfiles;\n \n@@ -127,7 +121,6 @@ thread_local!(pub static ANALYSISKEY: Rc<RefCell<Option<core::CrateAnalysis>>> =\n \n struct Output {\n     krate: clean::Crate,\n-    json_plugins: Vec<plugins::PluginJson>,\n     passes: Vec<String>,\n }\n \n@@ -150,9 +143,9 @@ pub fn opts() -> Vec<RustcOptGroup> {\n         stable(optflag(\"V\", \"version\", \"print rustdoc's version\")),\n         stable(optflag(\"v\", \"verbose\", \"use verbose output\")),\n         stable(optopt(\"r\", \"input-format\", \"the input type of the specified file\",\n-                      \"[rust|json]\")),\n+                      \"[rust]\")),\n         stable(optopt(\"w\", \"output-format\", \"the output type to write\",\n-                      \"[html|json]\")),\n+                      \"[html]\")),\n         stable(optopt(\"o\", \"output\", \"where to place the output\", \"PATH\")),\n         stable(optopt(\"\", \"crate-name\", \"specify the name of this crate\", \"NAME\")),\n         stable(optmulti(\"L\", \"library-path\", \"directory to add to crate search path\",\n@@ -311,7 +304,7 @@ pub fn main_args(args: &[String]) -> isize {\n             return 1;\n         }\n     };\n-    let Output { krate, json_plugins, passes, } = out;\n+    let Output { krate, passes, } = out;\n     info!(\"going to format\");\n     match matches.opt_str(\"w\").as_ref().map(|s| &**s) {\n         Some(\"html\") | None => {\n@@ -321,11 +314,6 @@ pub fn main_args(args: &[String]) -> isize {\n                               css_file_extension)\n                 .expect(\"failed to generate documentation\")\n         }\n-        Some(\"json\") => {\n-            json_output(krate, json_plugins,\n-                        output.unwrap_or(PathBuf::from(\"doc.json\")))\n-                .expect(\"failed to write json\")\n-        }\n         Some(s) => {\n             println!(\"unknown output format: {}\", s);\n             return 1;\n@@ -342,14 +330,9 @@ fn acquire_input(input: &str,\n                  matches: &getopts::Matches) -> Result<Output, String> {\n     match matches.opt_str(\"r\").as_ref().map(|s| &**s) {\n         Some(\"rust\") => Ok(rust_input(input, externs, matches)),\n-        Some(\"json\") => json_input(input),\n         Some(s) => Err(format!(\"unknown input format: {}\", s)),\n         None => {\n-            if input.ends_with(\".json\") {\n-                json_input(input)\n-            } else {\n-                Ok(rust_input(input, externs, matches))\n-            }\n+            Ok(rust_input(input, externs, matches))\n         }\n     }\n }\n@@ -461,76 +444,6 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n \n     // Run everything!\n     info!(\"Executing passes/plugins\");\n-    let (krate, json) = pm.run_plugins(krate);\n-    Output { krate: krate, json_plugins: json, passes: passes }\n-}\n-\n-/// This input format purely deserializes the json output file. No passes are\n-/// run over the deserialized output.\n-fn json_input(input: &str) -> Result<Output, String> {\n-    let mut bytes = Vec::new();\n-    if let Err(e) = File::open(input).and_then(|mut f| f.read_to_end(&mut bytes)) {\n-        return Err(format!(\"couldn't open {}: {}\", input, e))\n-    }\n-    match json::from_reader(&mut &bytes[..]) {\n-        Err(s) => Err(format!(\"{:?}\", s)),\n-        Ok(Json::Object(obj)) => {\n-            let mut obj = obj;\n-            // Make sure the schema is what we expect\n-            match obj.remove(&\"schema\".to_string()) {\n-                Some(Json::String(version)) => {\n-                    if version != SCHEMA_VERSION {\n-                        return Err(format!(\n-                                \"sorry, but I only understand version {}\",\n-                                SCHEMA_VERSION))\n-                    }\n-                }\n-                Some(..) => return Err(\"malformed json\".to_string()),\n-                None => return Err(\"expected a schema version\".to_string()),\n-            }\n-            let krate = match obj.remove(&\"crate\".to_string()) {\n-                Some(json) => {\n-                    let mut d = json::Decoder::new(json);\n-                    Decodable::decode(&mut d).unwrap()\n-                }\n-                None => return Err(\"malformed json\".to_string()),\n-            };\n-            // FIXME: this should read from the \"plugins\" field, but currently\n-            //      Json doesn't implement decodable...\n-            let plugin_output = Vec::new();\n-            Ok(Output { krate: krate, json_plugins: plugin_output, passes: Vec::new(), })\n-        }\n-        Ok(..) => {\n-            Err(\"malformed json input: expected an object at the \\\n-                 top\".to_string())\n-        }\n-    }\n-}\n-\n-/// Outputs the crate/plugin json as a giant json blob at the specified\n-/// destination.\n-fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n-               dst: PathBuf) -> io::Result<()> {\n-    // {\n-    //   \"schema\": version,\n-    //   \"crate\": { parsed crate ... },\n-    //   \"plugins\": { output of plugins ... }\n-    // }\n-    let mut json = std::collections::BTreeMap::new();\n-    json.insert(\"schema\".to_string(), Json::String(SCHEMA_VERSION.to_string()));\n-    let plugins_json = res.into_iter()\n-                          .filter_map(|opt| {\n-                              opt.map(|(string, json)| (string.to_string(), json))\n-                          }).collect();\n-\n-    // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n-    // straight to the Rust JSON representation.\n-    let crate_json_str = format!(\"{}\", json::as_json(&krate));\n-    let crate_json = json::from_str(&crate_json_str).expect(\"Rust generated JSON is invalid\");\n-\n-    json.insert(\"crate\".to_string(), crate_json);\n-    json.insert(\"plugins\".to_string(), Json::Object(plugins_json));\n-\n-    let mut file = File::create(&dst)?;\n-    write!(&mut file, \"{}\", Json::Object(json))\n+    let krate = pm.run_plugins(krate);\n+    Output { krate: krate, passes: passes }\n }"}, {"sha": "adc39b69986d62fe230e4332b17ee31fed62cf3f", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8bb19058d4e9418308a430475824cc8beececd1e/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb19058d4e9418308a430475824cc8beececd1e/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=8bb19058d4e9418308a430475824cc8beececd1e", "patch": "@@ -54,7 +54,7 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n     };\n \n     // strip any traits implemented on stripped items\n-    let krate = {\n+    {\n         struct ImplStripper<'a> {\n             stripped: &'a mut DefIdSet\n         }\n@@ -80,9 +80,7 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n         }\n         let mut stripper = ImplStripper{ stripped: &mut stripped };\n         stripper.fold_crate(krate)\n-    };\n-\n-    (krate, None)\n+    }\n }\n \n /// Strip private items from the point of view of a crate or externally from a\n@@ -107,9 +105,8 @@ pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n     // strip all private implementations of traits\n     {\n         let mut stripper = ImplStripper(&retained);\n-        krate = stripper.fold_crate(krate);\n+        stripper.fold_crate(krate)\n     }\n-    (krate, None)\n }\n \n struct Stripper<'a> {\n@@ -192,17 +189,19 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             self.fold_item_recur(i)\n         };\n \n-        i.and_then(|i| { match i.inner {\n-            // emptied modules/impls have no need to exist\n-            clean::ModuleItem(ref m)\n-                if m.items.is_empty() &&\n-                   i.doc_value().is_none() => None,\n-            clean::ImplItem(ref i) if i.items.is_empty() => None,\n-            _ => {\n-                self.retained.insert(i.def_id);\n-                Some(i)\n+        i.and_then(|i| {\n+            match i.inner {\n+                // emptied modules/impls have no need to exist\n+                clean::ModuleItem(ref m)\n+                    if m.items.is_empty() &&\n+                       i.doc_value().is_none() => None,\n+                clean::ImplItem(ref i) if i.items.is_empty() => None,\n+                _ => {\n+                    self.retained.insert(i.def_id);\n+                    Some(i)\n+                }\n             }\n-        }})\n+        })\n     }\n }\n \n@@ -234,7 +233,7 @@ impl fold::DocFolder for ImportStripper {\n }\n \n pub fn strip_priv_imports(krate: clean::Crate)  -> plugins::PluginResult {\n-    (ImportStripper.fold_crate(krate), None)\n+    ImportStripper.fold_crate(krate)\n }\n \n pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n@@ -258,7 +257,7 @@ pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n     }\n     let mut cleaner = CommentCleaner;\n     let krate = cleaner.fold_crate(krate);\n-    (krate, None)\n+    krate\n }\n \n pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n@@ -287,7 +286,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n     }\n     let mut collapser = Collapser;\n     let krate = collapser.fold_crate(krate);\n-    (krate, None)\n+    krate\n }\n \n pub fn unindent(s: &str) -> String {"}, {"sha": "b8be84825c9ccf88e29c43a2edfbee73deb650f4", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb19058d4e9418308a430475824cc8beececd1e/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb19058d4e9418308a430475824cc8beececd1e/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=8bb19058d4e9418308a430475824cc8beececd1e", "patch": "@@ -12,15 +12,13 @@\n \n use clean;\n \n-use serialize::json;\n use std::mem;\n use std::string::String;\n use std::path::PathBuf;\n \n use rustc_back::dynamic_lib as dl;\n \n-pub type PluginJson = Option<(String, json::Json)>;\n-pub type PluginResult = (clean::Crate, PluginJson);\n+pub type PluginResult = clean::Crate;\n pub type PluginCallback = fn (clean::Crate) -> PluginResult;\n \n /// Manages loading and running of plugins\n@@ -65,15 +63,11 @@ impl PluginManager {\n         self.callbacks.push(plugin);\n     }\n     /// Run all the loaded plugins over the crate, returning their results\n-    pub fn run_plugins(&self, krate: clean::Crate) -> (clean::Crate, Vec<PluginJson> ) {\n-        let mut out_json = Vec::new();\n-        let mut krate = krate;\n+    pub fn run_plugins(&self, mut krate: clean::Crate) -> clean::Crate {\n         for &callback in &self.callbacks {\n-            let (c, res) = callback(krate);\n-            krate = c;\n-            out_json.push(res);\n+            krate = callback(krate);\n         }\n-        (krate, out_json)\n+        krate\n     }\n }\n "}, {"sha": "1fe9a8240fa80d97e002b218c0ecb8a70c68e401", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb19058d4e9418308a430475824cc8beececd1e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb19058d4e9418308a430475824cc8beececd1e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=8bb19058d4e9418308a430475824cc8beececd1e", "patch": "@@ -122,8 +122,8 @@ pub fn run(input: &str,\n     if let Some(name) = crate_name {\n         krate.name = name;\n     }\n-    let (krate, _) = passes::collapse_docs(krate);\n-    let (krate, _) = passes::unindent_comments(krate);\n+    let krate = passes::collapse_docs(krate);\n+    let krate = passes::unindent_comments(krate);\n \n     let mut collector = Collector::new(krate.name.to_string(),\n                                        cfgs,"}, {"sha": "e49ab64b6958a8ac62818825daa3bd895be045af", "filename": "src/test/run-make/rustdoc-json/Makefile", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9f34c86a4dd43efa20c673688529516524f23c5/src%2Ftest%2Frun-make%2Frustdoc-json%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/a9f34c86a4dd43efa20c673688529516524f23c5/src%2Ftest%2Frun-make%2Frustdoc-json%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-json%2FMakefile?ref=a9f34c86a4dd43efa20c673688529516524f23c5", "patch": "@@ -1,4 +0,0 @@\n--include ../tools.mk\n-all:\n-\t$(HOST_RPATH_ENV) $(RUSTDOC) -w json -o $(TMPDIR)/doc.json foo.rs\n-\t$(HOST_RPATH_ENV) $(RUSTDOC) -o $(TMPDIR)/doc $(TMPDIR)/doc.json"}, {"sha": "3bd56c14193a8524d7e4dc25cf2e474779e5181f", "filename": "src/test/run-make/rustdoc-json/foo.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a9f34c86a4dd43efa20c673688529516524f23c5/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f34c86a4dd43efa20c673688529516524f23c5/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs?ref=a9f34c86a4dd43efa20c673688529516524f23c5", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![crate_name = \"foo\"]\n-\n-//! Very docs\n-\n-pub mod bar {\n-\n-    /// So correct\n-    pub mod baz {\n-        /// Much detail\n-        pub fn baz() { }\n-    }\n-\n-    /// *wow*\n-    pub trait Doge { fn dummy(&self) { } }\n-}"}]}