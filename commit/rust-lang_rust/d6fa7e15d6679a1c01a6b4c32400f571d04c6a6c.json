{"sha": "d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZmE3ZTE1ZDY2NzlhMWMwMWE2YjRjMzI0MDBmNTcxZDA0YzZhNmM=", "commit": {"author": {"name": "Ayrton", "email": "a.munoz3327@gmail.com", "date": "2020-10-06T21:55:46Z"}, "committer": {"name": "Ayrton", "email": "a.munoz3327@gmail.com", "date": "2020-10-27T15:04:04Z"}, "message": "Fixed compiler error in lint checker triggered by associated types\n\nWhen a function argument bound by `Pointer` is an associated type, we only\nperform substitutions using the parameters from the callsite but don't attempt\nto normalize since it may not succeed. A simplified version of the scenario that\ntriggered this error was added as a test case. Also fixed `Pointer::fmt` which\nwas being double-counted when called outside of macros and added a test case for\nthis.", "tree": {"sha": "93fc85647e721e624575ba056d3d9bcf1a6906e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93fc85647e721e624575ba056d3d9bcf1a6906e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c", "html_url": "https://github.com/rust-lang/rust/commit/d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c/comments", "author": {"login": "ayrtonm", "id": 4975834, "node_id": "MDQ6VXNlcjQ5NzU4MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4975834?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ayrtonm", "html_url": "https://github.com/ayrtonm", "followers_url": "https://api.github.com/users/ayrtonm/followers", "following_url": "https://api.github.com/users/ayrtonm/following{/other_user}", "gists_url": "https://api.github.com/users/ayrtonm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ayrtonm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ayrtonm/subscriptions", "organizations_url": "https://api.github.com/users/ayrtonm/orgs", "repos_url": "https://api.github.com/users/ayrtonm/repos", "events_url": "https://api.github.com/users/ayrtonm/events{/privacy}", "received_events_url": "https://api.github.com/users/ayrtonm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ayrtonm", "id": 4975834, "node_id": "MDQ6VXNlcjQ5NzU4MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4975834?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ayrtonm", "html_url": "https://github.com/ayrtonm", "followers_url": "https://api.github.com/users/ayrtonm/followers", "following_url": "https://api.github.com/users/ayrtonm/following{/other_user}", "gists_url": "https://api.github.com/users/ayrtonm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ayrtonm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ayrtonm/subscriptions", "organizations_url": "https://api.github.com/users/ayrtonm/orgs", "repos_url": "https://api.github.com/users/ayrtonm/repos", "events_url": "https://api.github.com/users/ayrtonm/events{/privacy}", "received_events_url": "https://api.github.com/users/ayrtonm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "432ebd57efe38e691acc25570cb79acbe4956651", "url": "https://api.github.com/repos/rust-lang/rust/commits/432ebd57efe38e691acc25570cb79acbe4956651", "html_url": "https://github.com/rust-lang/rust/commit/432ebd57efe38e691acc25570cb79acbe4956651"}], "stats": {"total": 205, "additions": 122, "deletions": 83}, "files": [{"sha": "6e94fad5d0d75962426feaf05037a566a4bac6c0", "filename": "compiler/rustc_mir/src/transform/function_references.rs", "status": "modified", "additions": 65, "deletions": 53, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_references.rs?ref=d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c", "patch": "@@ -1,7 +1,11 @@\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, subst::GenericArgKind, PredicateAtom, Ty, TyCtxt, TyS};\n+use rustc_middle::ty::{\n+    self,\n+    subst::{GenericArgKind, Subst},\n+    PredicateAtom, Ty, TyCtxt, TyS,\n+};\n use rustc_session::lint::builtin::FUNCTION_ITEM_REFERENCES;\n use rustc_span::{symbol::sym, Span};\n use rustc_target::spec::abi::Abi;\n@@ -33,48 +37,50 @@ impl<'a, 'tcx> Visitor<'tcx> for FunctionItemRefChecker<'a, 'tcx> {\n             fn_span: _,\n         } = &terminator.kind\n         {\n-            let func_ty = func.ty(self.body, self.tcx);\n-            if let ty::FnDef(def_id, substs_ref) = *func_ty.kind() {\n-                //check arguments for `std::mem::transmute`\n-                if self.tcx.is_diagnostic_item(sym::transmute, def_id) {\n-                    let arg_ty = args[0].ty(self.body, self.tcx);\n-                    for generic_inner_ty in arg_ty.walk() {\n-                        if let GenericArgKind::Type(inner_ty) = generic_inner_ty.unpack() {\n-                            if let Some(fn_id) = FunctionItemRefChecker::is_fn_ref(inner_ty) {\n-                                let ident = self.tcx.item_name(fn_id).to_ident_string();\n-                                let source_info = *self.body.source_info(location);\n-                                let span = self.nth_arg_span(&args, 0);\n-                                self.emit_lint(ident, fn_id, source_info, span);\n+            let source_info = *self.body.source_info(location);\n+            //this handles all function calls outside macros\n+            if !source_info.span.from_expansion() {\n+                let func_ty = func.ty(self.body, self.tcx);\n+                if let ty::FnDef(def_id, substs_ref) = *func_ty.kind() {\n+                    //handle `std::mem::transmute`\n+                    if self.tcx.is_diagnostic_item(sym::transmute, def_id) {\n+                        let arg_ty = args[0].ty(self.body, self.tcx);\n+                        for generic_inner_ty in arg_ty.walk() {\n+                            if let GenericArgKind::Type(inner_ty) = generic_inner_ty.unpack() {\n+                                if let Some(fn_id) = FunctionItemRefChecker::is_fn_ref(inner_ty) {\n+                                    let ident = self.tcx.item_name(fn_id).to_ident_string();\n+                                    let span = self.nth_arg_span(&args, 0);\n+                                    self.emit_lint(ident, fn_id, source_info, span);\n+                                }\n                             }\n                         }\n-                    }\n-                } else {\n-                    //check arguments for any function with `std::fmt::Pointer` as a bound trait\n-                    let param_env = self.tcx.param_env(def_id);\n-                    let bounds = param_env.caller_bounds();\n-                    for bound in bounds {\n-                        if let Some(bound_ty) = self.is_pointer_trait(&bound.skip_binders()) {\n-                            let arg_defs = self.tcx.fn_sig(def_id).skip_binder().inputs();\n-                            for (arg_num, arg_def) in arg_defs.iter().enumerate() {\n-                                for generic_inner_ty in arg_def.walk() {\n-                                    if let GenericArgKind::Type(inner_ty) =\n-                                        generic_inner_ty.unpack()\n-                                    {\n-                                        //if any type reachable from the argument types in the fn sig matches the type bound by `Pointer`\n-                                        if TyS::same_type(inner_ty, bound_ty) {\n-                                            //check if this type is a function reference in the function call\n-                                            let norm_ty =\n-                                                self.tcx.subst_and_normalize_erasing_regions(\n-                                                    substs_ref, param_env, &inner_ty,\n-                                                );\n-                                            if let Some(fn_id) =\n-                                                FunctionItemRefChecker::is_fn_ref(norm_ty)\n-                                            {\n-                                                let ident =\n-                                                    self.tcx.item_name(fn_id).to_ident_string();\n-                                                let source_info = *self.body.source_info(location);\n-                                                let span = self.nth_arg_span(&args, arg_num);\n-                                                self.emit_lint(ident, fn_id, source_info, span);\n+                    } else {\n+                        //handle any function call with `std::fmt::Pointer` as a bound trait\n+                        //this includes calls to `std::fmt::Pointer::fmt` outside of macros\n+                        let param_env = self.tcx.param_env(def_id);\n+                        let bounds = param_env.caller_bounds();\n+                        for bound in bounds {\n+                            if let Some(bound_ty) = self.is_pointer_trait(&bound.skip_binders()) {\n+                                //get the argument types as they appear in the function signature\n+                                let arg_defs = self.tcx.fn_sig(def_id).skip_binder().inputs();\n+                                for (arg_num, arg_def) in arg_defs.iter().enumerate() {\n+                                    //for all types reachable from the argument type in the fn sig\n+                                    for generic_inner_ty in arg_def.walk() {\n+                                        if let GenericArgKind::Type(inner_ty) =\n+                                            generic_inner_ty.unpack()\n+                                        {\n+                                            //if the inner type matches the type bound by `Pointer`\n+                                            if TyS::same_type(inner_ty, bound_ty) {\n+                                                //do a substitution using the parameters from the callsite\n+                                                let subst_ty = inner_ty.subst(self.tcx, substs_ref);\n+                                                if let Some(fn_id) =\n+                                                    FunctionItemRefChecker::is_fn_ref(subst_ty)\n+                                                {\n+                                                    let ident =\n+                                                        self.tcx.item_name(fn_id).to_ident_string();\n+                                                    let span = self.nth_arg_span(&args, arg_num);\n+                                                    self.emit_lint(ident, fn_id, source_info, span);\n+                                                }\n                                             }\n                                         }\n                                     }\n@@ -87,19 +93,25 @@ impl<'a, 'tcx> Visitor<'tcx> for FunctionItemRefChecker<'a, 'tcx> {\n         }\n         self.super_terminator(terminator, location);\n     }\n-    //check for `std::fmt::Pointer::<T>::fmt` where T is a function reference\n-    //this is used in formatting macros, but doesn't rely on the specific expansion\n+    //This handles `std::fmt::Pointer::fmt` when it's used in the formatting macros.\n+    //It's handled as an operand instead of a Call terminator so it won't depend on\n+    //whether the formatting macros call `fmt` directly, transmute it first or other\n+    //internal fmt details.\n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n-        let op_ty = operand.ty(self.body, self.tcx);\n-        if let ty::FnDef(def_id, substs_ref) = *op_ty.kind() {\n-            if self.tcx.is_diagnostic_item(sym::pointer_trait_fmt, def_id) {\n-                let param_ty = substs_ref.type_at(0);\n-                if let Some(fn_id) = FunctionItemRefChecker::is_fn_ref(param_ty) {\n-                    let source_info = *self.body.source_info(location);\n-                    let callsite_ctxt = source_info.span.source_callsite().ctxt();\n-                    let span = source_info.span.with_ctxt(callsite_ctxt);\n-                    let ident = self.tcx.item_name(fn_id).to_ident_string();\n-                    self.emit_lint(ident, fn_id, source_info, span);\n+        let source_info = *self.body.source_info(location);\n+        if source_info.span.from_expansion() {\n+            let op_ty = operand.ty(self.body, self.tcx);\n+            if let ty::FnDef(def_id, substs_ref) = *op_ty.kind() {\n+                if self.tcx.is_diagnostic_item(sym::pointer_trait_fmt, def_id) {\n+                    let param_ty = substs_ref.type_at(0);\n+                    if let Some(fn_id) = FunctionItemRefChecker::is_fn_ref(param_ty) {\n+                        //the operand's ctxt wouldn't display the lint since it's inside a macro\n+                        //so we have to use the callsite's ctxt\n+                        let callsite_ctxt = source_info.span.source_callsite().ctxt();\n+                        let span = source_info.span.with_ctxt(callsite_ctxt);\n+                        let ident = self.tcx.item_name(fn_id).to_ident_string();\n+                        self.emit_lint(ident, fn_id, source_info, span);\n+                    }\n                 }\n             }\n         }"}, {"sha": "28c66a31322c46d75b25e3472d5cf925c8581498", "filename": "src/test/ui/lint/function-references.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c/src%2Ftest%2Fui%2Flint%2Ffunction-references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c/src%2Ftest%2Fui%2Flint%2Ffunction-references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffunction-references.rs?ref=d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c", "patch": "@@ -2,6 +2,7 @@\n #![feature(c_variadic)]\n #![warn(function_item_references)]\n use std::fmt::Pointer;\n+use std::fmt::Formatter;\n \n fn nop() { }\n fn foo() -> u32 { 42 }\n@@ -20,6 +21,25 @@ fn parameterized_call_fn<F: Fn(u32) -> u32>(f: &F, x: u32) { f(x); }\n fn print_ptr<F: Pointer>(f: F) { println!(\"{:p}\", f); }\n fn bound_by_ptr_trait<F: Pointer>(_f: F) { }\n fn bound_by_ptr_trait_tuple<F: Pointer, G: Pointer>(_t: (F, G)) { }\n+fn implicit_ptr_trait<F>(f: &F) { println!(\"{:p}\", f); }\n+\n+//case found in tinyvec that triggered a compiler error in an earlier version of the lint checker\n+trait HasItem {\n+  type Item;\n+  fn assoc_item(&self) -> Self::Item;\n+}\n+fn _format_assoc_item<T: HasItem>(data: T, f: &mut Formatter) -> std::fmt::Result\n+    where T::Item: Pointer {\n+    //when the arg type bound by `Pointer` is an associated type, we shouldn't attempt to normalize\n+    Pointer::fmt(&data.assoc_item(), f)\n+}\n+\n+//simple test to make sure that calls to `Pointer::fmt` aren't double counted\n+fn _call_pointer_fmt(f: &mut Formatter) -> std::fmt::Result {\n+    let zst_ref = &foo;\n+    Pointer::fmt(&zst_ref, f)\n+    //~^ WARNING cast `foo` with `as fn() -> _` to obtain a function pointer\n+}\n \n fn main() {\n     //`let` bindings with function references shouldn't lint\n@@ -126,6 +146,7 @@ fn main() {\n     bound_by_ptr_trait_tuple((&foo, &bar));\n     //~^ WARNING cast `foo` with `as fn() -> _` to obtain a function pointer\n     //~^^ WARNING cast `bar` with `as fn(_) -> _` to obtain a function pointer\n+    implicit_ptr_trait(&bar); // ignore\n \n     //correct ways to pass function pointers as arguments bound by std::fmt::Pointer\n     print_ptr(bar as fn(u32) -> u32);"}, {"sha": "5e399c163050fbe7a1143cdbfe01feb28a5f0df0", "filename": "src/test/ui/lint/function-references.stderr", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c/src%2Ftest%2Fui%2Flint%2Ffunction-references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c/src%2Ftest%2Fui%2Flint%2Ffunction-references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffunction-references.stderr?ref=d6fa7e15d6679a1c01a6b4c32400f571d04c6a6c", "patch": "@@ -1,8 +1,8 @@\n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:57:22\n+  --> $DIR/function-references.rs:40:18\n    |\n-LL |     println!(\"{:p}\", &foo);\n-   |                      ^^^^\n+LL |     Pointer::fmt(&zst_ref, f)\n+   |                  ^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/function-references.rs:3:9\n@@ -11,160 +11,166 @@ LL | #![warn(function_item_references)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:59:20\n+  --> $DIR/function-references.rs:77:22\n+   |\n+LL |     println!(\"{:p}\", &foo);\n+   |                      ^^^^\n+\n+warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n+  --> $DIR/function-references.rs:79:20\n    |\n LL |     print!(\"{:p}\", &foo);\n    |                    ^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:61:21\n+  --> $DIR/function-references.rs:81:21\n    |\n LL |     format!(\"{:p}\", &foo);\n    |                     ^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:64:22\n+  --> $DIR/function-references.rs:84:22\n    |\n LL |     println!(\"{:p}\", &foo as *const _);\n    |                      ^^^^^^^^^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:66:22\n+  --> $DIR/function-references.rs:86:22\n    |\n LL |     println!(\"{:p}\", zst_ref);\n    |                      ^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:68:22\n+  --> $DIR/function-references.rs:88:22\n    |\n LL |     println!(\"{:p}\", cast_zst_ptr);\n    |                      ^^^^^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:70:22\n+  --> $DIR/function-references.rs:90:22\n    |\n LL |     println!(\"{:p}\", coerced_zst_ptr);\n    |                      ^^^^^^^^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:73:22\n+  --> $DIR/function-references.rs:93:22\n    |\n LL |     println!(\"{:p}\", &fn_item);\n    |                      ^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:75:22\n+  --> $DIR/function-references.rs:95:22\n    |\n LL |     println!(\"{:p}\", indirect_ref);\n    |                      ^^^^^^^^^^^^\n \n warning: cast `nop` with `as fn()` to obtain a function pointer\n-  --> $DIR/function-references.rs:78:22\n+  --> $DIR/function-references.rs:98:22\n    |\n LL |     println!(\"{:p}\", &nop);\n    |                      ^^^^\n \n warning: cast `bar` with `as fn(_) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:80:22\n+  --> $DIR/function-references.rs:100:22\n    |\n LL |     println!(\"{:p}\", &bar);\n    |                      ^^^^\n \n warning: cast `baz` with `as fn(_, _) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:82:22\n+  --> $DIR/function-references.rs:102:22\n    |\n LL |     println!(\"{:p}\", &baz);\n    |                      ^^^^\n \n warning: cast `unsafe_fn` with `as unsafe fn()` to obtain a function pointer\n-  --> $DIR/function-references.rs:84:22\n+  --> $DIR/function-references.rs:104:22\n    |\n LL |     println!(\"{:p}\", &unsafe_fn);\n    |                      ^^^^^^^^^^\n \n warning: cast `c_fn` with `as extern \"C\" fn()` to obtain a function pointer\n-  --> $DIR/function-references.rs:86:22\n+  --> $DIR/function-references.rs:106:22\n    |\n LL |     println!(\"{:p}\", &c_fn);\n    |                      ^^^^^\n \n warning: cast `unsafe_c_fn` with `as unsafe extern \"C\" fn()` to obtain a function pointer\n-  --> $DIR/function-references.rs:88:22\n+  --> $DIR/function-references.rs:108:22\n    |\n LL |     println!(\"{:p}\", &unsafe_c_fn);\n    |                      ^^^^^^^^^^^^\n \n warning: cast `variadic` with `as unsafe extern \"C\" fn(_, ...)` to obtain a function pointer\n-  --> $DIR/function-references.rs:90:22\n+  --> $DIR/function-references.rs:110:22\n    |\n LL |     println!(\"{:p}\", &variadic);\n    |                      ^^^^^^^^^\n \n warning: cast `var` with `as fn(_) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:92:22\n+  --> $DIR/function-references.rs:112:22\n    |\n LL |     println!(\"{:p}\", &std::env::var::<String>);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: cast `nop` with `as fn()` to obtain a function pointer\n-  --> $DIR/function-references.rs:95:32\n+  --> $DIR/function-references.rs:115:32\n    |\n LL |     println!(\"{:p} {:p} {:p}\", &nop, &foo, &bar);\n    |                                ^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:95:38\n+  --> $DIR/function-references.rs:115:38\n    |\n LL |     println!(\"{:p} {:p} {:p}\", &nop, &foo, &bar);\n    |                                      ^^^^\n \n warning: cast `bar` with `as fn(_) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:95:44\n+  --> $DIR/function-references.rs:115:44\n    |\n LL |     println!(\"{:p} {:p} {:p}\", &nop, &foo, &bar);\n    |                                            ^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:110:41\n+  --> $DIR/function-references.rs:130:41\n    |\n LL |         std::mem::transmute::<_, usize>(&foo);\n    |                                         ^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:112:50\n+  --> $DIR/function-references.rs:132:50\n    |\n LL |         std::mem::transmute::<_, (usize, usize)>((&foo, &bar));\n    |                                                  ^^^^^^^^^^^^\n \n warning: cast `bar` with `as fn(_) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:112:50\n+  --> $DIR/function-references.rs:132:50\n    |\n LL |         std::mem::transmute::<_, (usize, usize)>((&foo, &bar));\n    |                                                  ^^^^^^^^^^^^\n \n warning: cast `bar` with `as fn(_) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:122:15\n+  --> $DIR/function-references.rs:142:15\n    |\n LL |     print_ptr(&bar);\n    |               ^^^^\n \n warning: cast `bar` with `as fn(_) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:124:24\n+  --> $DIR/function-references.rs:144:24\n    |\n LL |     bound_by_ptr_trait(&bar);\n    |                        ^^^^\n \n warning: cast `bar` with `as fn(_) -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:126:30\n+  --> $DIR/function-references.rs:146:30\n    |\n LL |     bound_by_ptr_trait_tuple((&foo, &bar));\n    |                              ^^^^^^^^^^^^\n \n warning: cast `foo` with `as fn() -> _` to obtain a function pointer\n-  --> $DIR/function-references.rs:126:30\n+  --> $DIR/function-references.rs:146:30\n    |\n LL |     bound_by_ptr_trait_tuple((&foo, &bar));\n    |                              ^^^^^^^^^^^^\n \n-warning: 27 warnings emitted\n+warning: 28 warnings emitted\n "}]}