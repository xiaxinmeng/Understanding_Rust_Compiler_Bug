{"sha": "d41a1690d2aa5d3287b00d100897136b6186c39c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MWExNjkwZDJhYTVkMzI4N2IwMGQxMDA4OTcxMzZiNjE4NmMzOWM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-18T12:16:27Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-18T12:16:27Z"}, "message": "Track source file IDs in source mapping of Attrs", "tree": {"sha": "5ad953d6959a1255f09e3ca730ac48669dab9030", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ad953d6959a1255f09e3ca730ac48669dab9030"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d41a1690d2aa5d3287b00d100897136b6186c39c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d41a1690d2aa5d3287b00d100897136b6186c39c", "html_url": "https://github.com/rust-lang/rust/commit/d41a1690d2aa5d3287b00d100897136b6186c39c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d41a1690d2aa5d3287b00d100897136b6186c39c/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80d497e5415e9826cfe0596b6be88c6733f56cb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/80d497e5415e9826cfe0596b6be88c6733f56cb5", "html_url": "https://github.com/rust-lang/rust/commit/80d497e5415e9826cfe0596b6be88c6733f56cb5"}], "stats": {"total": 102, "additions": 76, "deletions": 26}, "files": [{"sha": "739e3f5e36247fbf8eb6b7acb195436126f0eddd", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d41a1690d2aa5d3287b00d100897136b6186c39c/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d41a1690d2aa5d3287b00d100897136b6186c39c/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=d41a1690d2aa5d3287b00d100897136b6186c39c", "patch": "@@ -283,8 +283,51 @@ impl Attrs {\n     /// Constructs a map that maps the lowered `Attr`s in this `Attrs` back to its original syntax nodes.\n     ///\n     /// `owner` must be the original owner of the attributes.\n-    pub fn source_map(&self, owner: &dyn ast::AttrsOwner) -> AttrSourceMap {\n-        AttrSourceMap { attrs: collect_attrs(owner).collect() }\n+    // FIXME: figure out a better api that doesnt require the for_module hack\n+    pub fn source_map(&self, owner: InFile<&dyn ast::AttrsOwner>) -> AttrSourceMap {\n+        // FIXME: This doesn't work correctly for modules, as the attributes there can have up to\n+        // two different owners\n+        AttrSourceMap {\n+            attrs: collect_attrs(owner.value)\n+                .map(|attr| InFile::new(owner.file_id, attr))\n+                .collect(),\n+        }\n+    }\n+\n+    pub fn source_map_for_module(\n+        &self,\n+        db: &dyn DefDatabase,\n+        module: crate::ModuleId,\n+    ) -> AttrSourceMap {\n+        let def_map = module.def_map(db);\n+        let mod_data = &def_map[module.local_id];\n+        let attrs = match mod_data.declaration_source(db) {\n+            Some(it) => {\n+                let mut attrs: Vec<_> = collect_attrs(&it.value as &dyn ast::AttrsOwner)\n+                    .map(|attr| InFile::new(it.file_id, attr))\n+                    .collect();\n+                if let InFile { file_id, value: ModuleSource::SourceFile(file) } =\n+                    mod_data.definition_source(db)\n+                {\n+                    attrs.extend(\n+                        collect_attrs(&file as &dyn ast::AttrsOwner)\n+                            .map(|attr| InFile::new(file_id, attr)),\n+                    )\n+                }\n+                attrs\n+            }\n+            None => {\n+                let InFile { file_id, value } = mod_data.definition_source(db);\n+                match &value {\n+                    ModuleSource::SourceFile(file) => collect_attrs(file as &dyn ast::AttrsOwner),\n+                    ModuleSource::Module(module) => collect_attrs(module as &dyn ast::AttrsOwner),\n+                    ModuleSource::BlockExpr(block) => collect_attrs(block as &dyn ast::AttrsOwner),\n+                }\n+                .map(|attr| InFile::new(file_id, attr))\n+                .collect()\n+            }\n+        };\n+        AttrSourceMap { attrs }\n     }\n \n     pub fn by_key(&self, key: &'static str) -> AttrQuery<'_> {\n@@ -379,7 +422,7 @@ fn inner_attributes(\n }\n \n pub struct AttrSourceMap {\n-    attrs: Vec<Either<ast::Attr, ast::Comment>>,\n+    attrs: Vec<InFile<Either<ast::Attr, ast::Comment>>>,\n }\n \n impl AttrSourceMap {\n@@ -389,10 +432,11 @@ impl AttrSourceMap {\n     ///\n     /// Note that the returned syntax node might be a `#[cfg_attr]`, or a doc comment, instead of\n     /// the attribute represented by `Attr`.\n-    pub fn source_of(&self, attr: &Attr) -> &Either<ast::Attr, ast::Comment> {\n+    pub fn source_of(&self, attr: &Attr) -> InFile<&Either<ast::Attr, ast::Comment>> {\n         self.attrs\n             .get(attr.index as usize)\n             .unwrap_or_else(|| panic!(\"cannot find `Attr` at index {}\", attr.index))\n+            .as_ref()\n     }\n }\n \n@@ -428,18 +472,6 @@ impl Attr {\n         Some(Attr { index, path, input })\n     }\n \n-    /// Maps this lowered `Attr` back to its original syntax node.\n-    ///\n-    /// `owner` must be the original owner of the attribute.\n-    ///\n-    /// Note that the returned syntax node might be a `#[cfg_attr]`, or a doc comment, instead of\n-    /// the attribute represented by `Attr`.\n-    pub fn to_src(&self, owner: &dyn ast::AttrsOwner) -> Either<ast::Attr, ast::Comment> {\n-        collect_attrs(owner).nth(self.index as usize).unwrap_or_else(|| {\n-            panic!(\"cannot find `Attr` at index {} in {}\", self.index, owner.syntax())\n-        })\n-    }\n-\n     /// Parses this attribute as a `#[derive]`, returns an iterator that yields all contained paths\n     /// to derive macros.\n     ///"}, {"sha": "e25b698e0c6e028b6d544b2d5551b4c2ca8697d0", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d41a1690d2aa5d3287b00d100897136b6186c39c/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d41a1690d2aa5d3287b00d100897136b6186c39c/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=d41a1690d2aa5d3287b00d100897136b6186c39c", "patch": "@@ -12,7 +12,7 @@ mod html;\n #[cfg(test)]\n mod tests;\n \n-use hir::{Name, Semantics};\n+use hir::{InFile, Name, Semantics};\n use ide_db::{RootDatabase, SymbolKind};\n use rustc_hash::FxHashMap;\n use syntax::{\n@@ -73,14 +73,20 @@ pub(crate) fn highlight(\n     };\n \n     let mut hl = highlights::Highlights::new(root.text_range());\n-    traverse(&mut hl, &sema, &root, range_to_highlight, syntactic_name_ref_highlighting);\n+    traverse(\n+        &mut hl,\n+        &sema,\n+        InFile::new(file_id.into(), &root),\n+        range_to_highlight,\n+        syntactic_name_ref_highlighting,\n+    );\n     hl.to_vec()\n }\n \n fn traverse(\n     hl: &mut Highlights,\n     sema: &Semantics<RootDatabase>,\n-    root: &SyntaxNode,\n+    root: InFile<&SyntaxNode>,\n     range_to_highlight: TextRange,\n     syntactic_name_ref_highlighting: bool,\n ) {\n@@ -93,7 +99,7 @@ fn traverse(\n \n     // Walk all nodes, keeping track of whether we are inside a macro or not.\n     // If in macro, expand it first and highlight the expanded code.\n-    for event in root.preorder_with_tokens() {\n+    for event in root.value.preorder_with_tokens() {\n         let event_range = match &event {\n             WalkEvent::Enter(it) | WalkEvent::Leave(it) => it.text_range(),\n         };\n@@ -150,7 +156,7 @@ fn traverse(\n             WalkEvent::Enter(it) => it,\n             WalkEvent::Leave(it) => {\n                 if let Some(node) = it.as_node() {\n-                    inject::doc_comment(hl, sema, node);\n+                    inject::doc_comment(hl, sema, root.with_value(node));\n                 }\n                 continue;\n             }"}, {"sha": "e6dbd307ec866ba142d12e3f5110ec54b0c0f6b2", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d41a1690d2aa5d3287b00d100897136b6186c39c/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d41a1690d2aa5d3287b00d100897136b6186c39c/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=d41a1690d2aa5d3287b00d100897136b6186c39c", "patch": "@@ -3,7 +3,7 @@\n use std::{mem, ops::Range};\n \n use either::Either;\n-use hir::{HasAttrs, Semantics};\n+use hir::{HasAttrs, InFile, Semantics};\n use ide_db::{call_info::ActiveParameter, defs::Definition};\n use syntax::{\n     ast::{self, AstNode, AttrsOwner, DocCommentsOwner},\n@@ -148,16 +148,25 @@ fn doc_attributes<'node>(\n }\n \n /// Injection of syntax highlighting of doctests.\n-pub(super) fn doc_comment(hl: &mut Highlights, sema: &Semantics<RootDatabase>, node: &SyntaxNode) {\n-    let (owner, attributes, def) = match doc_attributes(sema, node) {\n+pub(super) fn doc_comment(\n+    hl: &mut Highlights,\n+    sema: &Semantics<RootDatabase>,\n+    node: InFile<&SyntaxNode>,\n+) {\n+    let (owner, attributes, def) = match doc_attributes(sema, node.value) {\n         Some(it) => it,\n         None => return,\n     };\n \n     let mut inj = Injector::default();\n     inj.add_unmapped(\"fn doctest() {\\n\");\n \n-    let attrs_source_map = attributes.source_map(&owner);\n+    let attrs_source_map = match def {\n+        Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n+            attributes.source_map_for_module(sema.db, module.into())\n+        }\n+        _ => attributes.source_map(node.with_value(&owner)),\n+    };\n \n     let mut is_codeblock = false;\n     let mut is_doctest = false;\n@@ -168,7 +177,10 @@ pub(super) fn doc_comment(hl: &mut Highlights, sema: &Semantics<RootDatabase>, n\n     let mut intra_doc_links = Vec::new();\n     let mut string;\n     for attr in attributes.by_key(\"doc\").attrs() {\n-        let src = attrs_source_map.source_of(&attr);\n+        let InFile { file_id, value: src } = attrs_source_map.source_of(&attr);\n+        if file_id != node.file_id {\n+            continue;\n+        }\n         let (line, range, prefix) = match &src {\n             Either::Left(it) => {\n                 string = match find_doc_string_in_attr(attr, it) {"}]}